const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/NodeCreation-whyzgIo4.js","assets/_plugin-vue_export-helper-DltO58Gh.js","assets/src-BPnX41kb.js","assets/CalendarDate-DpJ94D5y.js","assets/_MapCache-D28pXLlm.js","assets/vue.runtime.esm-bundler-XtMkEjzB.js","assets/chunk-r2Y0G7H8.js","assets/sanitize-html-JHjOJhXQ.js","assets/en-BoKY3_VE.js","assets/src-Djrqh-50.css","assets/nodeCreator.store-CU0pOvyQ.js","assets/constants-DJi2tANw.js","assets/merge-PRabpGkI.js","assets/users.store-Dzwfthm5.js","assets/_baseOrderBy-DIP3iRVc.js","assets/dateformat-Bc6vycUF.js","assets/useDebounce-C7bvlNGQ.js","assets/nodeIcon-COQtWQBM.js","assets/canvas.utils-C0nDCBMd.js","assets/assistant.store-CX2RqSch.js","assets/KeyboardShortcutTooltip-CO2z5CTh.js","assets/KeyboardShortcutTooltip-DD3OwInQ.css","assets/chatPanel.store-CG1Jl_8w.js","assets/useActions-B50kzV-K.js","assets/NodeCreation-CPUFbQeT.css","assets/NodeDetailsView-UjRKuU_S.js","assets/RunData-B5ec4zqt.js","assets/uniqBy-CW1EKBts.js","assets/NDVEmptyState-BuQ1DMFp.js","assets/NDVEmptyState-Bho0_Ev8.css","assets/vue-json-pretty-CuBVqeNj.js","assets/useRunWorkflow-COepbjiS.js","assets/useCanvasOperations-Bg6EndeW.js","assets/core-VADtcMBO.js","assets/core-XmFv11t6.js","assets/xml-BMqNMrYo.js","assets/VueMarkdown-BnlX_HaA.js","assets/usePinnedData-D0_pVdJU.js","assets/folders.store-BtYwe6Tn.js","assets/executions.store-FiMweW-1.js","assets/useCanvasOperations-BGIelHPw.css","assets/retry-C1TxraVv.js","assets/pushConnection.store-VPzR9qb2.js","assets/collaboration.store-azdYLKEm.js","assets/useClipboard-CJVeJQPL.js","assets/useExecutionHelpers-DHBdKfZ-.js","assets/dateFormatter-Be41lUNW.js","assets/externalSecrets.ee.store-DLAzGhQ9.js","assets/useEnvFeatureFlag-D0d3xQTx.js","assets/RunDataHtml-Cw8vfNJ3.js","assets/RunDataHtml-CPkTgQ0s.css","assets/RunData-y_mkyVlS.css","assets/ParameterInputList-BVhLsD4f.js","assets/exports-DYzjmh6G.js","assets/vue-B-h9D2g4.js","assets/comlink-CKk5H2qz.js","assets/date-picker-BvAxZus9.js","assets/flatten-BtkI3kHd.js","assets/dialog-BJWIreAU.js","assets/VirtualSchema-C-fJWt8W.js","assets/Draggable-ygB13kd1.js","assets/Draggable-Dqq_ig-6.css","assets/NodeIcon-DKBaXy4A.js","assets/NodeIcon-DYIwbj2N.css","assets/useCalloutHelpers-BeT7yPWr.js","assets/useTelemetryContext-sXxpNQLl.js","assets/useTelemetryContext-DHOsGVft.css","assets/nodeTransforms-TojKNbNE.js","assets/TextWithHighlights-Dz1Q69Xq.js","assets/TextWithHighlights-_TQjEA06.css","assets/VirtualSchema-BcG_eYav.css","assets/CredentialIcon-B2dTX4rq.js","assets/CredentialIcon-CiJkhU0f.css","assets/useQuickConnect-CtTzfgnq.js","assets/useDynamicCredentials-BvVppdeE.js","assets/ParameterInputList-H1Ra_i78.css","assets/NodeSettings-a0Uac8aD.js","assets/col-D8ZibPUF.js","assets/useFreeAiCredits-BpeuNufQ.js","assets/dataTable.store-B6r9Jo-h.js","assets/QuickConnectBanner-DGtKVnz1.js","assets/semver-DsbaYmkG.js","assets/QuickConnectBanner-CrGD09Mo.css","assets/NodeSettings-BiaH1p-4.css","assets/useLogsTreeExpand-BppUWw0O.js","assets/AnimatedSpinner-DxjSO1-I.js","assets/AnimatedSpinner-CoP6Lyme.css","assets/useLogsTreeExpand-CDwBt1Gl.css","assets/CopyInput-ticOEv-n.js","assets/CopyInput-x-Kt5YkE.css","assets/useExecutionData-aQ60k2Ju.js","assets/TriggerPanel-CoG7BsjT.js","assets/RunDataParsedAiContent-DQVm9Q0d.js","assets/RunDataParsedAiContent-BZ1TsOsZ.css","assets/TriggerPanel-D9--jCab.css","assets/NodeDetailsView-CF_rqMHQ.css","assets/NodeDetailsViewV2-BFA6Fc0N.js","assets/useKeybindings-zRfAe5jr.js","assets/NodeDetailsViewV2-CBlLSP7K.css","assets/SetupWorkflowCredentialsButton-BB6DBoDB.js","assets/readyToRun.store-B0tsjGrt.js","assets/setupPanel.store-DOMStRy8.js"])))=>i.map(i=>d[i]);
import { C as computed, Cn as toDisplayString, D as createElementBlock, E as createCommentVNode, G as nextTick, Gt as unref, It as ref, J as onBeforeUnmount, K as onActivated, L as h, M as createVNode, N as defineAsyncComponent, P as defineComponent, Q as onUnmounted, T as createBlock, U as mergeModels, Vt as toRef, W as mergeProps, Y as onDeactivated, Z as onMounted, _ as Fragment, _t as watch, at as renderSlot, bn as normalizeStyle, bt as withCtx, c as useCssModule, et as openBlock, ft as useModel, h as withModifiers, it as renderList, j as createTextVNode, jt as isRef, mt as useTemplateRef, nt as provide, q as onBeforeMount, vn as normalizeClass, w as createBaseVNode, y as Suspense } from "./vue.runtime.esm-bundler-XtMkEjzB.js";
import { $ as refThrottled, b as useActiveElement, h as computedAsync, ot as useDebounceFn, st as useThrottleFn, yt as useI18n } from "./_MapCache-D28pXLlm.js";
import { Bi as N8nCallout_default, Ci as useRoute, Hi as N8nButton_default, I as N8nResizeWrapper_default, Ki as __vitePreload, Mi as N8nIconButton_default, Oi as N8nTooltip_default, Ot as N8nKeyboardShortcut_default, Q as N8nInfoTip_default, Si as onBeforeRouteLeave, St as CanvasThinkingPill_default, Ui as N8nIcon_default, Vi as N8nText_default, _t as createEventBus, d as N8nInlineTextEdit_default, j as N8nTabs_default, ji as Input_default, kt as useDeviceSupport, wi as useRouter, xt as CanvasCollaborationPill_default, z as N8nRadioButtons_default } from "./src-BPnX41kb.js";
import { t as __plugin_vue_export_helper_default } from "./_plugin-vue_export-helper-DltO58Gh.js";
import "./sanitize-html-JHjOJhXQ.js";
import "./date-picker-BvAxZus9.js";
import { Bt as useNDVStore, C as useNodeTypesStore, Ci as historyBus, Er as useNpsSurveyStore, Ft as useEnvironmentsStore, Gt as useProjectsStore, It as useNodeHelpers, Ji as isValueExpression, Ln as getNodeViewTab, Lt as useTelemetry, Mn as getBounds, Ot as useTagsStore, Rr as useWorkflowsListStore, Sr as useCanvasStore, Tr as useMessage, Vt as injectWorkflowState, di as CanvasNodeRenderType, er as getRectOfNodes, fn as useDocumentTitle, ga as nodeViewEventBus, gn as useFocusPanelStore, ia as hasFocusOnInput, ir as useVueFlow, li as CanvasConnectionMode, pn as useWorkflowSaving, r as useUIStore, rt as useCredentialsStore, s as useWorkflowsStore, sa as isFocusableEl, t as useUsersStore, un as useBuilderStore, va as htmlEditorEventBus, wr as useSourceControlStore, xr as useExternalHooks, yr as useToast, zn as getNodesWithNormalizedPosition } from "./users.store-Dzwfthm5.js";
import { D as ExpressionEditorModalInput_default, M as CodeNodeEditor_default, N as JsEditor_default, P as HtmlEditor_default, T as SqlEditor_default, _ as getParameterTypeOption, a as ParameterOptions_default, b as parseFromExpression, d as useNodeSettingsParameters, h as formatAsExpression, s as useResolvedExpression, u as CssEditor_default, v as isValidParameterOption } from "./ParameterInputList-BVhLsD4f.js";
import { An as MANUAL_CHAT_TRIGGER_NODE_TYPE, Ct as HUMAN_IN_THE_LOOP_CATEGORY, Ga as jsonParse, Gt as CHAT_TRIGGER_NODE_TYPE, M as VALID_WORKFLOW_IMPORT_URL_REGEX, Qc as DEBOUNCE_TIME, R as DRAG_EVENT_DATA_KEY, Ra as isResourceLocatorValue, Ss as MODAL_CONFIRM, Tc as WorkflowIdKey, To as HTML_NODE_TYPE, Tt as NODE_CREATOR_OPEN_SOURCES, Vs as WORKFLOW_SETTINGS_MODAL_KEY, Zn as PRODUCTION_ONLY_TRIGGER_NODE_TYPES, bo as EVALUATION_NODE_TYPE, da as getNodeOutputs, hr as STICKY_NODE_TYPE, hs as FROM_AI_PARAMETERS_MODAL_KEY, is as ABOUT_MODAL_KEY, mo as AI_TRANSFORM_NODE_TYPE, ns as MAIN_HEADER_TABS, ol as getDebounceTime, qo as getResourcePermissions, rs as VIEWS, so as NodeConnectionTypes, ua as getNodeInputs, wa as isTriggerNode, xc as ExpressionLocalResolveContextSymbol, xo as EVALUATION_TRIGGER_NODE_TYPE } from "./constants-DJi2tANw.js";
import "./merge-PRabpGkI.js";
import { N as storeToRefs, r as useRootStore } from "./_baseOrderBy-DIP3iRVc.js";
import "./dateformat-Bc6vycUF.js";
import "./useDebounce-C7bvlNGQ.js";
import "./dataTable.store-B6r9Jo-h.js";
import { t as useClipboard } from "./useClipboard-CJVeJQPL.js";
import { t as useExecutionsStore } from "./executions.store-FiMweW-1.js";
import "./assistant.store-CX2RqSch.js";
import { t as useChatPanelStore } from "./chatPanel.store-CG1Jl_8w.js";
import { s as JsonEditor_default } from "./RunData-B5ec4zqt.js";
import "./NDVEmptyState-BuQ1DMFp.js";
import "./useEnvFeatureFlag-D0d3xQTx.js";
import "./externalSecrets.ee.store-DLAzGhQ9.js";
import "./uniqBy-CW1EKBts.js";
import "./semver-DsbaYmkG.js";
import "./usePinnedData-D0_pVdJU.js";
import "./nodeIcon-COQtWQBM.js";
import { c as parseCanvasConnectionHandleString, l as shouldIgnoreCanvasShortcut } from "./canvas.utils-C0nDCBMd.js";
import { t as useNodeCreatorStore } from "./nodeCreator.store-CU0pOvyQ.js";
import { a as useLogsStore, i as useExperimentalNdvStore, r as canvasEventBus, t as useCanvasOperations } from "./useCanvasOperations-Bg6EndeW.js";
import "./folders.store-BtYwe6Tn.js";
import "./QuickConnectBanner-DGtKVnz1.js";
import "./useQuickConnect-CtTzfgnq.js";
import "./CredentialIcon-B2dTX4rq.js";
import "./useDynamicCredentials-BvVppdeE.js";
import "./RunDataHtml-Cw8vfNJ3.js";
import "./Draggable-ygB13kd1.js";
import { t as NodeIcon_default } from "./NodeIcon-DKBaXy4A.js";
import { n as NodeExecuteButton_default, r as useNodeExecution } from "./VirtualSchema-C-fJWt8W.js";
import "./useCalloutHelpers-BeT7yPWr.js";
import { t as useTelemetryContext } from "./useTelemetryContext-sXxpNQLl.js";
import { n as useAgentRequestStore, t as useRunWorkflow } from "./useRunWorkflow-COepbjiS.js";
import { t as usePushConnectionStore } from "./pushConnection.store-VPzR9qb2.js";
import { i as getNodeTypeDisplayableCredentials, o as needsAgentInput } from "./nodeTransforms-TojKNbNE.js";
import "./vue-json-pretty-CuBVqeNj.js";
import { n as useBeforeUnload, t as useCollaborationStore } from "./collaboration.store-azdYLKEm.js";
import "./dateFormatter-Be41lUNW.js";
import "./useExecutionHelpers-DHBdKfZ-.js";
import "./useFreeAiCredits-BpeuNufQ.js";
import "./NodeSettings-a0Uac8aD.js";
import { t as KeyboardShortcutTooltip_default } from "./KeyboardShortcutTooltip-CO2z5CTh.js";
import "./vue-B-h9D2g4.js";
import { t as CredentialPicker_default } from "./CredentialPicker-CEy39tU5.js";
import { t as sourceControlEventBus } from "./sourceControl.eventBus-Dn6c9-mJ.js";
import { n as useGlobalLinkActions, r as useWorkflowExtraction, t as CanvasRunWorkflowButton_default } from "./CanvasRunWorkflowButton-JzfX29L5.js";
import { a as ExperimentalCanvasNodeSettings_default, i as useExpressionResolveCtx, n as Canvas_default, s as useContextMenuItems, t as useCanvasMapping } from "./useCanvasMapping-Dk5TP7Q5.js";
import { t as useKeybindings } from "./useKeybindings-zRfAe5jr.js";
import { t as injectStrict } from "./injectStrict-DRL1gb3N.js";
import "./useActions-B50kzV-K.js";
import { t as useSetupPanelStore } from "./setupPanel.store-DOMStRy8.js";
import { t as useExecutionData } from "./useExecutionData-aQ60k2Ju.js";
import { t as useEmptyStateBuilderPromptStore } from "./emptyStateBuilderPrompt.store-gMTE38Yd.js";
var WorkflowCanvas_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	inheritAttrs: false,
	__name: "WorkflowCanvas",
	props: {
		id: { default: "canvas" },
		workflow: {},
		workflowObject: {},
		fallbackNodes: { default: () => [] },
		showFallbackNodes: {
			type: Boolean,
			default: true
		},
		eventBus: { default: () => createEventBus() },
		readOnly: { type: Boolean },
		executing: { type: Boolean },
		suppressInteraction: {
			type: Boolean,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const canvasRef = useTemplateRef("canvas");
		const $style = useCssModule();
		const { onNodesInitialized, viewport, viewportRef, getNodes, fitBounds } = useVueFlow(props.id);
		const workflow = toRef(props, "workflow");
		const workflowObject = toRef(props, "workflowObject");
		const { nodes: mappedNodes, connections: mappedConnections } = useCanvasMapping({
			nodes: computed(() => {
				return props.showFallbackNodes ? [...props.workflow.nodes, ...props.fallbackNodes] : props.workflow.nodes;
			}),
			connections: computed(() => props.workflow.connections),
			workflowObject
		});
		const initialFitViewDone = ref(false);
		const { off } = onNodesInitialized(() => {
			if (!initialFitViewDone.value) {
				props.eventBus.emit("fitView");
				initialFitViewDone.value = true;
				off();
			}
		});
		const mappedNodesThrottled = refThrottled(mappedNodes, 200);
		const mappedConnectionsThrottled = refThrottled(mappedConnections, 200);
		__expose({
			executeContextMenuAction: (action, nodeIds) => canvasRef.value?.executeContextMenuAction(action, nodeIds),
			ensureNodesAreVisible: (ids) => {
				const canvasElement = viewportRef.value;
				if (!canvasElement) return;
				const targetNodes = getNodes.value.filter((node) => ids.includes(node.id));
				if (targetNodes.length === 0) return;
				const insertionDone = onNodesInitialized(() => {
					const vp = viewport.value;
					const canvasWidth = canvasElement.clientWidth;
					const canvasHeight = canvasElement.clientHeight;
					const nodesRect = getRectOfNodes(targetNodes);
					const screenX = nodesRect.x * vp.zoom + vp.x;
					const screenY = nodesRect.y * vp.zoom + vp.y;
					const screenWidth = nodesRect.width * vp.zoom;
					const screenHeight = nodesRect.height * vp.zoom;
					if (!(screenX >= 0 && screenY >= 0 && screenX + screenWidth <= canvasWidth && screenY + screenHeight <= canvasHeight)) {
						const viewportRect = {
							x: -vp.x / vp.zoom,
							y: -vp.y / vp.zoom,
							width: canvasWidth / vp.zoom,
							height: canvasHeight / vp.zoom
						};
						const minX = Math.min(viewportRect.x, nodesRect.x);
						const minY = Math.min(viewportRect.y, nodesRect.y);
						const maxX = Math.max(viewportRect.x + viewportRect.width, nodesRect.x + nodesRect.width);
						const maxY = Math.max(viewportRect.y + viewportRect.height, nodesRect.y + nodesRect.height);
						fitBounds({
							x: minX,
							y: minY,
							width: maxX - minX,
							height: maxY - minY
						}, {
							padding: .15,
							duration: 100
						});
					}
					props.eventBus.emit("nodes:select", { ids });
					insertionDone.off();
				});
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(unref($style).wrapper),
				"data-test-id": "canvas-wrapper"
			}, [createBaseVNode("div", {
				id: "canvas",
				class: normalizeClass(unref($style).canvas)
			}, [workflow.value ? (openBlock(), createBlock(Canvas_default, mergeProps({
				key: 0,
				id: __props.id,
				ref: "canvas",
				nodes: __props.executing ? unref(mappedNodesThrottled) : unref(mappedNodes),
				connections: __props.executing ? unref(mappedConnectionsThrottled) : unref(mappedConnections),
				"event-bus": __props.eventBus,
				"read-only": __props.readOnly,
				executing: __props.executing,
				"suppress-interaction": __props.suppressInteraction
			}, _ctx.$attrs), null, 16, [
				"id",
				"nodes",
				"connections",
				"event-bus",
				"read-only",
				"executing",
				"suppress-interaction"
			])) : createCommentVNode("", true)], 2), renderSlot(_ctx.$slots, "default")], 2);
		};
	}
});
var WorkflowCanvas_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_gh0gb_125",
	canvas: "_canvas_gh0gb_133"
};
var WorkflowCanvas_default = /* @__PURE__ */ __plugin_vue_export_helper_default(WorkflowCanvas_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": WorkflowCanvas_vue_vue_type_style_index_0_lang_module_default }]]);
var FocusSidebarTabs_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FocusSidebarTabs",
	props: {
		modelValue: { default: "setup" },
		tabLabels: { default: () => ({}) }
	},
	emits: ["update:modelValue"],
	setup(__props, { emit: __emit }) {
		const i18n = useI18n();
		const props = __props;
		const emit = __emit;
		const tabs = computed(() => [{
			label: props.tabLabels?.setup ?? i18n.baseText("setupPanel.tabs.setup"),
			value: "setup"
		}, {
			label: props.tabLabels?.focus ?? i18n.baseText("setupPanel.tabs.focus"),
			value: "focus"
		}]);
		const onTabSelected = (tab) => {
			emit("update:modelValue", tab);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "setup-panel-tabs"
			}, [createVNode(unref(N8nTabs_default), {
				"model-value": __props.modelValue,
				options: tabs.value,
				size: "small",
				"onUpdate:modelValue": onTabSelected
			}, null, 8, ["model-value", "options"])], 2);
		};
	}
});
var FocusSidebarTabs_vue_vue_type_style_index_0_lang_module_default = { container: "_container_1xsug_125" };
var FocusSidebarTabs_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FocusSidebarTabs_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FocusSidebarTabs_vue_vue_type_style_index_0_lang_module_default }]]);
function getNodeCredentialTypes(nodeTypeProvider, node) {
	const credentialTypes = /* @__PURE__ */ new Set();
	const displayableCredentials = getNodeTypeDisplayableCredentials(nodeTypeProvider, node);
	for (const cred of displayableCredentials) credentialTypes.add(cred.name);
	const credentialIssues = node.issues?.credentials ?? {};
	for (const credType of Object.keys(credentialIssues)) credentialTypes.add(credType);
	if (node.credentials) for (const credType of Object.keys(node.credentials)) credentialTypes.add(credType);
	return Array.from(credentialTypes);
}
function buildCredentialRequirement(node, credentialType, getCredentialDisplayName, credentialTypeToNodeNames) {
	const credValue = node.credentials?.[credentialType];
	const selectedCredentialId = typeof credValue === "string" ? void 0 : credValue?.id ?? void 0;
	const issueMessages = [(node.issues?.credentials ?? {})[credentialType] ?? []].flat();
	return {
		credentialType,
		credentialDisplayName: getCredentialDisplayName(credentialType),
		selectedCredentialId,
		issues: issueMessages,
		nodesWithSameCredential: credentialTypeToNodeNames.get(credentialType) ?? []
	};
}
function isNodeSetupComplete(requirements) {
	return requirements.every((req) => req.selectedCredentialId && req.issues.length === 0);
}
function buildNodeSetupState(node, credentialTypes, getCredentialDisplayName, credentialTypeToNodeNames, isTrigger = false, hasTriggerExecuted = false) {
	const credentialRequirements = credentialTypes.map((credType) => buildCredentialRequirement(node, credType, getCredentialDisplayName, credentialTypeToNodeNames));
	const credentialsConfigured = isNodeSetupComplete(credentialRequirements);
	return {
		node,
		credentialRequirements,
		isComplete: isTrigger ? credentialsConfigured && hasTriggerExecuted : credentialsConfigured,
		isTrigger
	};
}
const useWorkflowSetupState = (nodes) => {
	const workflowsStore = useWorkflowsStore();
	const credentialsStore = useCredentialsStore();
	const nodeTypesStore = useNodeTypesStore();
	const nodeHelpers = useNodeHelpers();
	const workflowState = injectWorkflowState();
	const toast = useToast();
	const i18n = useI18n();
	const sourceNodes = computed(() => nodes?.value ?? workflowsStore.allNodes);
	const getCredentialDisplayName = (credentialType) => {
		return credentialsStore.getCredentialTypeByName(credentialType)?.displayName ?? credentialType;
	};
	const isTriggerNode$1 = (node) => {
		return nodeTypesStore.isTriggerNode(node.type);
	};
	const hasTriggerExecutedSuccessfully = (nodeName) => {
		const runData = workflowsStore.getWorkflowResultDataByNodeName(nodeName);
		return runData !== null && runData.length > 0;
	};
	const nodesRequiringSetup = computed(() => {
		return sourceNodes.value.filter((node) => !node.disabled).map((node) => ({
			node,
			credentialTypes: getNodeCredentialTypes(nodeTypesStore, node),
			isTrigger: isTriggerNode$1(node)
		})).filter(({ credentialTypes, isTrigger }) => credentialTypes.length > 0 || isTrigger).sort((a, b) => Number(b.isTrigger) - Number(a.isTrigger) || a.node.position[0] - b.node.position[0]);
	});
	const credentialTypeToNodeNames = computed(() => {
		const map = /* @__PURE__ */ new Map();
		for (const { node, credentialTypes } of nodesRequiringSetup.value) for (const credType of credentialTypes) {
			const existing = map.get(credType) ?? [];
			existing.push(node.name);
			map.set(credType, existing);
		}
		return map;
	});
	const nodeSetupStates = computed(() => nodesRequiringSetup.value.map(({ node, credentialTypes, isTrigger }) => buildNodeSetupState(node, credentialTypes, getCredentialDisplayName, credentialTypeToNodeNames.value, isTrigger, hasTriggerExecutedSuccessfully(node.name))));
	const totalCredentialsMissing = computed(() => {
		return nodeSetupStates.value.reduce((total, state) => {
			return total + state.credentialRequirements.filter((req) => !req.selectedCredentialId || req.issues.length > 0).length;
		}, 0);
	});
	const totalNodesRequiringSetup = computed(() => {
		return nodeSetupStates.value.length;
	});
	const isAllComplete = computed(() => {
		return nodeSetupStates.value.length > 0 && nodeSetupStates.value.every((state) => state.isComplete);
	});
	const setCredential = (nodeName, credentialType, credentialId) => {
		const credential = credentialsStore.getCredentialById(credentialId);
		if (!credential) return;
		const node = workflowsStore.getNodeByName(nodeName);
		if (!node) return;
		const credentialDetails = {
			id: credentialId,
			name: credential.name
		};
		workflowState.updateNodeProperties({
			name: nodeName,
			properties: { credentials: {
				...node.credentials,
				[credentialType]: credentialDetails
			} }
		});
		nodeHelpers.updateNodeCredentialIssuesByName(nodeName);
		const otherNodesUpdated = [];
		for (const state of nodeSetupStates.value) {
			if (state.node.name === nodeName) continue;
			if (state.credentialRequirements.some((req) => req.credentialType === credentialType && !req.selectedCredentialId)) {
				const targetNode = workflowsStore.getNodeByName(state.node.name);
				if (targetNode) {
					workflowState.updateNodeProperties({
						name: state.node.name,
						properties: { credentials: {
							...targetNode.credentials,
							[credentialType]: credentialDetails
						} }
					});
					otherNodesUpdated.push(state.node.name);
				}
			}
		}
		if (otherNodesUpdated.length > 0) {
			nodeHelpers.updateNodesCredentialsIssues();
			toast.showMessage({
				title: i18n.baseText("nodeCredentials.showMessage.title"),
				message: i18n.baseText("nodeCredentials.autoAssigned.message", { interpolate: { count: String(otherNodesUpdated.length) } }),
				type: "success"
			});
		}
	};
	const unsetCredential = (nodeName, credentialType) => {
		const node = workflowsStore.getNodeByName(nodeName);
		if (!node) return;
		const updatedCredentials = { ...node.credentials };
		delete updatedCredentials[credentialType];
		workflowState.updateNodeProperties({
			name: nodeName,
			properties: { credentials: updatedCredentials }
		});
		nodeHelpers.updateNodeCredentialIssuesByName(nodeName);
	};
	return {
		nodeSetupStates,
		totalCredentialsMissing,
		totalNodesRequiringSetup,
		isAllComplete,
		setCredential,
		unsetCredential
	};
};
var _hoisted_1$2 = ["for"];
var SetupCredentialLabel_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SetupCredentialLabel",
	props: {
		nodeName: {},
		credentialType: {},
		nodesWithSameCredential: {}
	},
	setup(__props) {
		const i18n = useI18n();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style["credential-label-row"]) }, [createBaseVNode("label", {
				"data-test-id": "node-setup-card-credential-label",
				for: `credential-picker-${__props.nodeName}-${__props.credentialType}`,
				class: normalizeClass(_ctx.$style["credential-label"])
			}, toDisplayString(unref(i18n).baseText("setupPanel.credentialLabel")), 11, _hoisted_1$2), __props.nodesWithSameCredential.length > 1 ? (openBlock(), createBlock(unref(N8nTooltip_default), {
				key: 0,
				placement: "top"
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(__props.nodesWithSameCredential.join(", ")), 1)]),
				default: withCtx(() => [createBaseVNode("span", {
					"data-test-id": "node-setup-card-shared-nodes-hint",
					class: normalizeClass(_ctx.$style["shared-nodes-hint"])
				}, toDisplayString(unref(i18n).baseText("setupPanel.usedInNodes", { interpolate: { count: String(__props.nodesWithSameCredential.length) } })), 3)]),
				_: 1
			})) : createCommentVNode("", true)], 2);
		};
	}
});
var SetupCredentialLabel_vue_vue_type_style_index_0_lang_module_default = {
	"credential-label-row": "_credential-label-row_1nlke_125",
	"credential-label": "_credential-label_1nlke_125",
	"shared-nodes-hint": "_shared-nodes-hint_1nlke_136"
};
var SetupCredentialLabel_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SetupCredentialLabel_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SetupCredentialLabel_vue_vue_type_style_index_0_lang_module_default }]]);
var NodeSetupCard_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "NodeSetupCard",
	props: /* @__PURE__ */ mergeModels({ state: {} }, {
		"expanded": {
			type: Boolean,
			default: false
		},
		"expandedModifiers": {}
	}),
	emits: /* @__PURE__ */ mergeModels(["credentialSelected", "credentialDeselected"], ["update:expanded"]),
	setup(__props, { emit: __emit }) {
		const props = __props;
		const expanded = useModel(__props, "expanded");
		const emit = __emit;
		const i18n = useI18n();
		const telemetry = useTelemetry();
		const nodeTypesStore = useNodeTypesStore();
		const workflowsStore = useWorkflowsStore();
		const { isExecuting, buttonLabel, buttonIcon, disabledReason, hasIssues, execute } = useNodeExecution(computed(() => props.state.node));
		const nodeType = computed(() => nodeTypesStore.getNodeType(props.state.node.type, props.state.node.typeVersion));
		const isButtonDisabled = computed(() => isExecuting.value || hasIssues.value || !!disabledReason.value);
		const showFooter = computed(() => props.state.isTrigger || props.state.isComplete);
		const tooltipText = computed(() => {
			if (hasIssues.value) return i18n.baseText("ndv.execute.requiredFieldsMissing");
			return disabledReason.value;
		});
		const onHeaderClick = () => {
			expanded.value = !expanded.value;
		};
		const hadManualInteraction = ref(false);
		const onCredentialSelected = (credentialType, credentialId) => {
			hadManualInteraction.value = true;
			emit("credentialSelected", {
				credentialType,
				credentialId
			});
		};
		const onCredentialDeselected = (credentialType) => {
			hadManualInteraction.value = true;
			emit("credentialDeselected", credentialType);
		};
		const onTestClick = async () => {
			hadManualInteraction.value = true;
			await execute();
		};
		function collectNodeTypesFromRequirements(requirements) {
			const types = /* @__PURE__ */ new Set();
			for (const req of requirements) for (const nodeName of req.nodesWithSameCredential) {
				const node = workflowsStore.getNodeByName(nodeName);
				if (node) types.add(node.type);
			}
			return types;
		}
		function countRelatedNodes(requirements) {
			let count = 0;
			for (const req of requirements) count += req.nodesWithSameCredential.length;
			return count;
		}
		watch(() => props.state.isComplete, (isComplete) => {
			if (isComplete) {
				expanded.value = false;
				if (hadManualInteraction.value) {
					telemetry.track("User completed setup step", {
						template_id: workflowsStore.workflow.meta?.templateId,
						workflow_id: workflowsStore.workflowId,
						type: props.state.isTrigger ? "trigger" : "credential",
						nodes: Array.from(collectNodeTypesFromRequirements(props.state.credentialRequirements)),
						related_nodes_count: countRelatedNodes(props.state.credentialRequirements)
					});
					hadManualInteraction.value = false;
				}
			}
		});
		onMounted(() => {
			if (props.state.isComplete) expanded.value = false;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				"data-test-id": "node-setup-card",
				class: normalizeClass([_ctx.$style.card, {
					[_ctx.$style.collapsed]: !expanded.value,
					[_ctx.$style.completed]: __props.state.isComplete,
					[_ctx.$style["no-content"]]: !__props.state.credentialRequirements.length
				}])
			}, [createBaseVNode("header", {
				"data-test-id": "node-setup-card-header",
				class: normalizeClass(_ctx.$style.header),
				onClick: onHeaderClick
			}, [
				!expanded.value && __props.state.isComplete ? (openBlock(), createBlock(unref(N8nIcon_default), {
					key: 0,
					"data-test-id": "node-setup-card-complete-icon",
					icon: "check",
					class: normalizeClass(_ctx.$style["complete-icon"]),
					size: "medium"
				}, null, 8, ["class"])) : (openBlock(), createBlock(NodeIcon_default, {
					key: 1,
					"node-type": nodeType.value,
					size: 16
				}, null, 8, ["node-type"])),
				createVNode(unref(N8nText_default), {
					class: normalizeClass(_ctx.$style["node-name"]),
					size: "medium",
					color: "text-dark"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(props.state.node.name), 1)]),
					_: 1
				}, 8, ["class"]),
				__props.state.isTrigger ? (openBlock(), createBlock(unref(N8nTooltip_default), { key: 2 }, {
					content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("nodeCreator.nodeItem.triggerIconTitle")), 1)]),
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						class: normalizeClass([_ctx.$style["header-icon"], _ctx.$style["trigger"]]),
						icon: "zap",
						size: "small",
						color: "text-light"
					}, null, 8, ["class"])]),
					_: 1
				})) : createCommentVNode("", true),
				createVNode(unref(N8nIcon_default), {
					class: normalizeClass([_ctx.$style["header-icon"], _ctx.$style["chevron"]]),
					icon: expanded.value ? "chevrons-down-up" : "chevrons-up-down",
					size: "medium",
					color: "text-light"
				}, null, 8, ["class", "icon"])
			], 2), expanded.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [__props.state.credentialRequirements.length ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass({
					[_ctx.$style.content]: true,
					["pb-s"]: !showFooter.value
				})
			}, [__props.state.isTrigger ? (openBlock(), createBlock(unref(N8nText_default), {
				key: 0,
				size: "medium",
				color: "text-light",
				class: "mb-3xs"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("setupPanel.trigger.credential.note")), 1)]),
				_: 1
			})) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(__props.state.credentialRequirements, (requirement) => {
				return openBlock(), createElementBlock("div", {
					key: requirement.credentialType,
					class: normalizeClass(_ctx.$style["credential-container"])
				}, [createVNode(SetupCredentialLabel_default, {
					"node-name": __props.state.node.name,
					"credential-type": requirement.credentialType,
					"nodes-with-same-credential": requirement.nodesWithSameCredential
				}, null, 8, [
					"node-name",
					"credential-type",
					"nodes-with-same-credential"
				]), createVNode(CredentialPicker_default, {
					"create-button-type": "secondary",
					class: normalizeClass(_ctx.$style["credential-picker"]),
					"app-name": requirement.credentialDisplayName,
					"credential-type": requirement.credentialType,
					"selected-credential-id": requirement.selectedCredentialId ?? null,
					onCredentialSelected: ($event) => onCredentialSelected(requirement.credentialType, $event),
					onCredentialDeselected: ($event) => onCredentialDeselected(requirement.credentialType)
				}, null, 8, [
					"class",
					"app-name",
					"credential-type",
					"selected-credential-id",
					"onCredentialSelected",
					"onCredentialDeselected"
				])], 2);
			}), 128))], 2)) : createCommentVNode("", true), showFooter.value ? (openBlock(), createElementBlock("footer", {
				key: 1,
				class: normalizeClass(_ctx.$style.footer)
			}, [__props.state.isComplete ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style["footer-complete-check"])
			}, [createVNode(unref(N8nIcon_default), {
				icon: "check",
				class: normalizeClass(_ctx.$style["complete-icon"]),
				size: "large"
			}, null, 8, ["class"]), createVNode(unref(N8nText_default), {
				size: "medium",
				color: "success"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("generic.complete")), 1)]),
				_: 1
			})], 2)) : createCommentVNode("", true), __props.state.isTrigger ? (openBlock(), createBlock(unref(N8nTooltip_default), {
				key: 1,
				disabled: !tooltipText.value,
				placement: "top"
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(tooltipText.value), 1)]),
				default: withCtx(() => [createVNode(unref(N8nButton_default), {
					"data-test-id": "node-setup-card-test-button",
					label: unref(buttonLabel),
					disabled: isButtonDisabled.value,
					loading: unref(isExecuting),
					icon: unref(buttonIcon),
					size: "small",
					onClick: onTestClick
				}, null, 8, [
					"label",
					"disabled",
					"loading",
					"icon"
				])]),
				_: 1
			}, 8, ["disabled"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)], 2);
		};
	}
});
const card = "_card_l1dfx_125";
const chevron = "_chevron_l1dfx_134";
const trigger = "_trigger_l1dfx_140";
const header = "_header_l1dfx_134";
const collapsed = "_collapsed_l1dfx_151";
const content$1 = "_content_l1dfx_167";
const footer = "_footer_l1dfx_184";
const completed = "_completed_l1dfx_206";
var NodeSetupCard_vue_vue_type_style_index_0_lang_module_default = {
	card,
	"header-icon": "_header-icon_l1dfx_134",
	chevron,
	trigger,
	header,
	collapsed,
	"no-content": "_no-content_l1dfx_154",
	"node-name": "_node-name_l1dfx_158",
	"complete-icon": "_complete-icon_l1dfx_163",
	content: content$1,
	"credential-container": "_credential-container_l1dfx_174",
	"credential-picker": "_credential-picker_l1dfx_180",
	footer,
	"footer-complete-check": "_footer-complete-check_l1dfx_190",
	completed
};
var NodeSetupCard_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NodeSetupCard_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NodeSetupCard_vue_vue_type_style_index_0_lang_module_default }]]);
var SetupPanelCards_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SetupPanelCards",
	setup(__props) {
		const i18n = useI18n();
		const telemetry = useTelemetry();
		const workflowsStore = useWorkflowsStore();
		const { nodeSetupStates, isAllComplete, setCredential, unsetCredential } = useWorkflowSetupState();
		watch(isAllComplete, (allComplete) => {
			if (allComplete) telemetry.track("User completed all setup steps", {
				template_id: workflowsStore.workflow.meta?.templateId,
				workflow_id: workflowsStore.workflowId
			});
		});
		const onCredentialSelected = (nodeName, payload) => {
			setCredential(nodeName, payload.credentialType, payload.credentialId);
		};
		const onCredentialDeselected = (nodeName, credentialType) => {
			unsetCredential(nodeName, credentialType);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "setup-panel-cards-container"
			}, [unref(nodeSetupStates).length === 0 ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style["empty-state"]),
				"data-test-id": "setup-cards-empty"
			}, [createVNode(unref(N8nIcon_default), {
				icon: "list-checks",
				class: normalizeClass(_ctx.$style["empty-icon"]),
				size: 24,
				color: "text-base"
			}, null, 8, ["class"]), createBaseVNode("div", { class: normalizeClass(_ctx.$style["empty-text"]) }, [createVNode(unref(N8nText_default), {
				size: "medium",
				color: "text-base",
				bold: true,
				"data-test-id": "setup-cards-empty-heading"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("setupPanel.empty.heading")), 1)]),
				_: 1
			}), createVNode(unref(N8nText_default), {
				size: "medium",
				color: "text-light",
				"data-test-id": "setup-cards-empty-description"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("setupPanel.empty.description")), 1)]),
				_: 1
			})], 2)], 2)) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style["card-list"]),
				"data-test-id": "setup-cards-list"
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(nodeSetupStates), (state, index) => {
				return openBlock(), createBlock(NodeSetupCard_default, {
					key: state.node.id,
					state,
					expanded: index === 0,
					onCredentialSelected: ($event) => onCredentialSelected(state.node.name, $event),
					onCredentialDeselected: ($event) => onCredentialDeselected(state.node.name, $event)
				}, null, 8, [
					"state",
					"expanded",
					"onCredentialSelected",
					"onCredentialDeselected"
				]);
			}), 128)), unref(isAllComplete) ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style["complete-message"]),
				"data-test-id": "setup-cards-complete-message"
			}, [createVNode(unref(N8nText_default), {
				size: "medium",
				color: "text-base"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("setupPanel.everythingConfigured.message")), 1)]),
				_: 1
			})], 2)) : createCommentVNode("", true)], 2))], 2);
		};
	}
});
var SetupPanelCards_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_1011p_125",
	"card-list": "_card-list_1011p_126",
	"empty-state": "_empty-state_1011p_134",
	"empty-text": "_empty-text_1011p_144",
	"complete-message": "_complete-message_1011p_150"
};
var SetupPanelCards_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SetupPanelCards_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SetupPanelCards_vue_vue_type_style_index_0_lang_module_default }]]);
var SetupPanel_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SetupPanel",
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "setup-panel-container"
			}, [createVNode(SetupPanelCards_default)], 2);
		};
	}
});
var SetupPanel_vue_vue_type_style_index_0_lang_module_default = { container: "_container_17sfi_125" };
var SetupPanel_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SetupPanel_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SetupPanel_vue_vue_type_style_index_0_lang_module_default }]]);
var ExperimentalNodeDetailsDrawer_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExperimentalNodeDetailsDrawer",
	props: {
		node: {},
		nodeIds: {},
		isReadOnly: { type: Boolean }
	},
	emits: ["openNdv", "contextMenuAction"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const expressionResolveCtx = useExpressionResolveCtx(computed(() => __props.node));
		const contextMenuItems = useContextMenuItems(computed(() => __props.nodeIds));
		const ndvStore = useNDVStore();
		const ndvCloseTimes = ref(0);
		const nodeSettingsViewKey = computed(() => [__props.node.id, ndvCloseTimes.value].join("|"));
		watch(() => ndvStore.activeNodeName, (name, oldName) => {
			if (name === null && oldName !== null) ndvCloseTimes.value += 1;
		});
		provide(ExpressionLocalResolveContextSymbol, expressionResolveCtx);
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.component) }, [__props.nodeIds.length > 1 ? (openBlock(), createBlock(unref(N8nText_default), {
				key: 0,
				tag: "div",
				color: "text-base",
				class: normalizeClass(_ctx.$style.multipleNodes)
			}, {
				default: withCtx(() => [createBaseVNode("div", null, toDisplayString(__props.nodeIds.length) + " nodes selected", 1), createBaseVNode("ul", { class: normalizeClass(_ctx.$style.multipleNodesActions) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(contextMenuItems), (action) => {
					return openBlock(), createElementBlock("li", {
						key: action.id,
						class: normalizeClass(_ctx.$style.multipleNodesAction)
					}, [createVNode(unref(N8nButton_default), {
						variant: "subtle",
						disabled: action.disabled,
						onClick: ($event) => emit("contextMenuAction", action.id, __props.nodeIds)
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(action.label) + " ", 1), action.shortcut ? (openBlock(), createBlock(unref(N8nKeyboardShortcut_default), mergeProps({
							key: 0,
							ref_for: true
						}, action.shortcut), null, 16)) : createCommentVNode("", true)]),
						_: 2
					}, 1032, ["disabled", "onClick"])], 2);
				}), 128))], 2)]),
				_: 1
			}, 8, ["class"])) : __props.node ? (openBlock(), createBlock(ExperimentalCanvasNodeSettings_default, {
				key: nodeSettingsViewKey.value,
				"node-id": __props.node.id,
				"is-read-only": __props.isReadOnly
			}, null, 8, ["node-id", "is-read-only"])) : createCommentVNode("", true)], 2);
		};
	}
});
var ExperimentalNodeDetailsDrawer_vue_vue_type_style_index_0_lang_module_default = {
	component: "_component_1ef46_125",
	multipleNodes: "_multipleNodes_1ef46_130",
	multipleNodesActions: "_multipleNodesActions_1ef46_140",
	multipleNodesAction: "_multipleNodesAction_1ef46_140"
};
var ExperimentalNodeDetailsDrawer_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExperimentalNodeDetailsDrawer_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExperimentalNodeDetailsDrawer_vue_vue_type_style_index_0_lang_module_default }]]);
var ExperimentalFocusPanelHeader_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExperimentalFocusPanelHeader",
	props: {
		node: {},
		parameter: {},
		isExecutable: { type: Boolean },
		readOnly: { type: Boolean }
	},
	emits: [
		"execute",
		"openNdv",
		"clearParameter",
		"renameNode"
	],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const nodeTypesStore = useNodeTypesStore();
		const i18n = useI18n();
		const nodeType = computed(() => nodeTypesStore.getNodeType(__props.node.type, __props.node.typeVersion));
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nText_default), {
				tag: "header",
				size: "small",
				bold: "",
				class: normalizeClass(_ctx.$style.component)
			}, {
				default: withCtx(() => [
					createVNode(NodeIcon_default, {
						"node-type": nodeType.value,
						size: 16
					}, null, 8, ["node-type"]),
					createBaseVNode("div", { class: normalizeClass(_ctx.$style.breadcrumbs) }, [__props.parameter ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
						createVNode(unref(N8nText_default), {
							size: "small",
							color: "text-base",
							bold: ""
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(__props.node.name), 1)]),
							_: 1
						}),
						createVNode(unref(N8nText_default), {
							size: "small",
							color: "text-light"
						}, {
							default: withCtx(() => [..._cache[4] || (_cache[4] = [createTextVNode("/", -1)])]),
							_: 1
						}),
						createTextVNode(" " + toDisplayString(__props.parameter.displayName), 1)
					], 64)) : (openBlock(), createBlock(unref(N8nInlineTextEdit_default), {
						key: 1,
						"model-value": __props.node.name,
						"min-width": 0,
						"max-width": 500,
						placeholder: unref(i18n).baseText("ndv.title.rename.placeholder"),
						"read-only": __props.readOnly,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => emit("renameNode", $event))
					}, null, 8, [
						"model-value",
						"placeholder",
						"read-only"
					]))], 2),
					__props.parameter ? (openBlock(), createBlock(unref(N8nIconButton_default), {
						key: 0,
						variant: "ghost",
						icon: "x",
						size: "small",
						onClick: _cache[1] || (_cache[1] = ($event) => emit("clearParameter"))
					})) : (openBlock(), createBlock(unref(N8nIconButton_default), {
						key: 1,
						variant: "ghost",
						icon: "expand",
						size: "small",
						onClick: _cache[2] || (_cache[2] = ($event) => emit("openNdv"))
					})),
					__props.isExecutable ? (openBlock(), createBlock(NodeExecuteButton_default, {
						key: 2,
						"data-test-id": "node-execute-button",
						"node-name": __props.node.name,
						tooltip: `Execute ${__props.node.name}`,
						type: "secondary",
						size: "small",
						icon: "play",
						square: true,
						"hide-label": true,
						"telemetry-source": "focus",
						onExecute: _cache[3] || (_cache[3] = ($event) => emit("execute"))
					}, null, 8, ["node-name", "tooltip"])) : createCommentVNode("", true)
				]),
				_: 1
			}, 8, ["class"]);
		};
	}
});
var ExperimentalFocusPanelHeader_vue_vue_type_style_index_0_lang_module_default = {
	component: "_component_1p4tv_125",
	breadcrumbs: "_breadcrumbs_1p4tv_133"
};
var ExperimentalFocusPanelHeader_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExperimentalFocusPanelHeader_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExperimentalFocusPanelHeader_vue_vue_type_style_index_0_lang_module_default }]]);
var FocusPanel_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "FocusPanel",
	__name: "FocusPanel",
	props: { isCanvasReadOnly: { type: Boolean } },
	emits: [
		"focus",
		"saveKeyboardShortcut",
		"contextMenuAction"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const inputField = ref();
		const locale = useI18n();
		const nodeHelpers = useNodeHelpers();
		const focusPanelStore = useFocusPanelStore();
		const workflowsStore = useWorkflowsStore();
		const workflowState = injectWorkflowState();
		const nodeTypesStore = useNodeTypesStore();
		const telemetry = useTelemetry();
		const nodeSettingsParameters = useNodeSettingsParameters();
		const environmentsStore = useEnvironmentsStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const ndvStore = useNDVStore();
		const vueFlow = useVueFlow(workflowsStore.workflowId);
		const { renameNode } = useCanvasOperations();
		const resolvedParameter = computed(() => focusPanelStore.resolvedParameter);
		const inputValue = ref("");
		const isDisabled = computedAsync(async () => {
			if (!resolvedParameter.value) return false;
			const parentPath = resolvedParameter.value.parameterPath.split(".").slice(1, -1).join(".");
			return !!resolvedParameter.value.parameter.disabledOptions && await nodeSettingsParameters.shouldDisplayNodeParameter(resolvedParameter.value.node.parameters, resolvedParameter.value.node, resolvedParameter.value.parameter, parentPath, "disabledOptions");
		}, false);
		const isDisplayed = computedAsync(async () => {
			if (!resolvedParameter.value) return true;
			const parentPath = resolvedParameter.value.parameterPath.split(".").slice(1, -1).join(".");
			return await nodeSettingsParameters.shouldDisplayNodeParameter(resolvedParameter.value.node.parameters, resolvedParameter.value.node, resolvedParameter.value.parameter, parentPath, "displayOptions");
		}, true);
		const node = computed(() => {
			if (!experimentalNdvStore.isNdvInFocusPanelEnabled || resolvedParameter.value) return resolvedParameter.value?.node;
			const selected = vueFlow.getSelectedNodes.value[0];
			return selected?.data?.render.type === CanvasNodeRenderType.Default ? workflowsStore.allNodes.find((n) => n.id === selected.id) : void 0;
		});
		const multipleNodesSelected = computed(() => vueFlow.getSelectedNodes.value.length > 1);
		const isExecutable = computed(() => {
			if (!node.value) return false;
			if (!isDisplayed.value) return false;
			const foreignCredentials = nodeHelpers.getForeignCredentialsIfSharingEnabled(node.value.credentials);
			return nodeHelpers.isNodeExecutable(node.value, !props.isCanvasReadOnly, foreignCredentials);
		});
		const { workflowRunData } = useExecutionData({ node });
		const hasNodeRun = computed(() => {
			if (!node.value) return true;
			const parentNode = workflowsStore.workflowObject.getParentNodes(node.value.name, "main", 1)[0];
			return Boolean(parentNode && workflowRunData.value && Object.prototype.hasOwnProperty.bind(workflowRunData.value)(parentNode));
		});
		function getTypeOption(optionName) {
			return resolvedParameter.value ? getParameterTypeOption(resolvedParameter.value.parameter, optionName) : void 0;
		}
		const codeEditorMode = computed(() => {
			return resolvedParameter.value?.node.parameters.mode;
		});
		const editorType = computed(() => {
			return getTypeOption("editor") ?? void 0;
		});
		const editorLanguage = computed(() => {
			if (editorType.value === "json" || resolvedParameter.value?.parameter.type === "json") return "json";
			return getTypeOption("editorLanguage") ?? "javaScript";
		});
		const editorRows = computed(() => getTypeOption("rows"));
		const isToolNode = computed(() => resolvedParameter.value ? nodeTypesStore.isToolNode(resolvedParameter.value?.node.type) : false);
		const isHtmlNode = computed(() => !!resolvedParameter.value && resolvedParameter.value.node.type === "n8n-nodes-base.html");
		const expressionModeEnabled = computed(() => resolvedParameter.value && isValueExpression(resolvedParameter.value.parameter, resolvedParameter.value.value));
		const expression = computed(() => {
			if (!expressionModeEnabled.value) return "";
			return isResourceLocatorValue(resolvedParameter.value) ? resolvedParameter.value.value : resolvedParameter.value;
		});
		const shouldCaptureForPosthog = computed(() => resolvedParameter.value?.node.type === AI_TRANSFORM_NODE_TYPE);
		const isReadOnly = computed(() => props.isCanvasReadOnly || isDisabled.value);
		const resolvedAdditionalExpressionData = computed(() => {
			return { $vars: environmentsStore.variablesAsObject };
		});
		const targetNodeParameterContext = computed(() => {
			if (!resolvedParameter.value) return void 0;
			return {
				nodeName: resolvedParameter.value.node.name,
				parameterPath: resolvedParameter.value.parameterPath
			};
		});
		const isNodeExecuting = computed(() => workflowState.executingNode.isNodeExecuting(node.value?.name ?? ""));
		const selectedNodeIds = computed(() => vueFlow.getSelectedNodes.value.map((n) => n.id));
		const emptyTitle = computed(() => experimentalNdvStore.isNdvInFocusPanelEnabled ? locale.baseText("nodeView.focusPanel.v2.noParameters.title") : locale.baseText("nodeView.focusPanel.noParameters.title"));
		const emptySubtitle = computed(() => experimentalNdvStore.isNdvInFocusPanelEnabled ? locale.baseText("nodeView.focusPanel.v2.noParameters.subtitle") : locale.baseText("nodeView.focusPanel.noParameters.subtitle"));
		const { resolvedExpression } = useResolvedExpression({
			expression,
			additionalData: resolvedAdditionalExpressionData,
			stringifyObject: resolvedParameter.value && resolvedParameter.value.parameter.type !== "multiOptions"
		});
		function valueChanged(value) {
			if (resolvedParameter.value === void 0) return;
			nodeSettingsParameters.updateNodeParameter(toRef(resolvedParameter.value.node.parameters), {
				value,
				name: resolvedParameter.value.parameterPath
			}, value, resolvedParameter.value.node, isToolNode.value);
		}
		async function setFocus() {
			await nextTick();
			if (inputField.value) {
				if (hasFocusOnInput(inputField.value)) inputField.value.focusOnInput();
				else if (isFocusableEl(inputField.value)) inputField.value.focus();
			}
			emit("focus");
		}
		function optionSelected(command) {
			if (!resolvedParameter.value) return;
			switch (command) {
				case "resetValue":
					if (typeof resolvedParameter.value.parameter.default === "string") valueChanged(resolvedParameter.value.parameter.default);
					setFocus();
					break;
				case "addExpression": {
					const newValue = formatAsExpression(resolvedParameter.value.value, resolvedParameter.value.parameter.type);
					valueChanged(typeof newValue === "string" ? newValue : newValue.value);
					setFocus();
					break;
				}
				case "removeExpression": {
					const newValue = parseFromExpression(resolvedParameter.value.value, resolvedExpression.value, resolvedParameter.value.parameter.type, resolvedParameter.value.parameter.default, (resolvedParameter.value.parameter.options ?? []).filter(isValidParameterOption));
					if (typeof newValue === "string") valueChanged(newValue);
					else if (newValue && typeof newValue.value === "string") valueChanged(newValue.value);
					setFocus();
					break;
				}
				case "formatHtml":
					htmlEditorEventBus.emit("format-html");
					break;
			}
		}
		function closeFocusPanel() {
			if (experimentalNdvStore.isNdvInFocusPanelEnabled && resolvedParameter.value) {
				focusPanelStore.unsetParameters();
				telemetry.track("User removed focused param", {
					source: "closeIcon",
					parameters: focusPanelStore.focusedNodeParametersInTelemetryFormat
				});
				return;
			}
			telemetry.track("User closed focus panel", {
				source: "closeIcon",
				parameters: focusPanelStore.focusedNodeParametersInTelemetryFormat
			});
			focusPanelStore.closeFocusPanel();
		}
		function onExecute() {
			telemetry.track("User executed node from focus panel", focusPanelStore.focusedNodeParametersInTelemetryFormat[0]);
		}
		function onInputChange(val) {
			inputValue.value = val;
			valueChanged(val);
		}
		function focusWithDelay() {
			setTimeout(() => {
				setFocus();
			}, 50);
		}
		watch([() => focusPanelStore.lastFocusTimestamp, () => expressionModeEnabled.value], () => focusWithDelay());
		watch(() => resolvedParameter.value, (newValue) => {
			if (newValue) {
				const value = newValue.value;
				if (typeof value === "string" && value !== inputValue.value) inputValue.value = value;
			}
		}, { immediate: true });
		function onOpenNdv() {
			if (node.value) ndvStore.setActiveNodeName(node.value.name, "focus_panel");
		}
		function onRenameNode(value) {
			if (node.value) renameNode(node.value.name, value);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				"data-test-id": "focus-panel",
				class: normalizeClass([_ctx.$style.content, { [_ctx.$style.isNdvInFocusPanelEnabled]: unref(experimentalNdvStore).isNdvInFocusPanelEnabled }])
			}, [unref(experimentalNdvStore).isNdvInFocusPanelEnabled && node.value && !multipleNodesSelected.value ? (openBlock(), createBlock(ExperimentalFocusPanelHeader_default, {
				key: 0,
				node: node.value,
				parameter: resolvedParameter.value?.parameter,
				"is-executable": isExecutable.value,
				"read-only": __props.isCanvasReadOnly,
				onExecute,
				onOpenNdv,
				onClearParameter: closeFocusPanel,
				onRenameNode
			}, null, 8, [
				"node",
				"parameter",
				"is-executable",
				"read-only"
			])) : createCommentVNode("", true), resolvedParameter.value ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.content),
				"data-test-id": "focus-parameter"
			}, [!unref(experimentalNdvStore).isNdvInFocusPanelEnabled ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.tabHeader)
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.tabHeaderText) }, [createVNode(unref(N8nText_default), {
				color: "text-dark",
				size: "small"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(resolvedParameter.value.parameter.displayName), 1)]),
				_: 1
			}), createVNode(unref(N8nText_default), {
				color: "text-base",
				size: "xsmall"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(resolvedParameter.value.node.name), 1)]),
				_: 1
			})], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.buttonWrapper) }, [createVNode(NodeExecuteButton_default, {
				"data-test-id": "node-execute-button",
				"node-name": resolvedParameter.value.node.name,
				tooltip: `Execute ${resolvedParameter.value.node.name}`,
				disabled: !isExecutable.value,
				size: "small",
				icon: "play",
				square: true,
				"hide-label": true,
				"telemetry-source": "focus",
				onExecute
			}, null, 8, [
				"node-name",
				"tooltip",
				"disabled"
			]), createVNode(unref(N8nIcon_default), {
				class: normalizeClass(_ctx.$style.closeButton),
				icon: "x",
				color: "text-base",
				size: "xlarge",
				onClick: closeFocusPanel
			}, null, 8, ["class"])], 2)], 2)) : createCommentVNode("", true), createBaseVNode("div", { class: normalizeClass(_ctx.$style.parameterDetailsWrapper) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.parameterOptionsWrapper) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.noExecutionDataTip) }, [!hasNodeRun.value && !isNodeExecuting.value ? (openBlock(), createBlock(unref(N8nInfoTip_default), {
				key: 0,
				class: normalizeClass(_ctx.$style.delayedShow),
				bold: true
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(locale).baseText("nodeView.focusPanel.noExecutionData")), 1)]),
				_: 1
			}, 8, ["class"])) : createCommentVNode("", true)], 2), unref(isDisplayed) ? (openBlock(), createBlock(ParameterOptions_default, {
				key: 0,
				parameter: resolvedParameter.value.parameter,
				value: resolvedParameter.value.value,
				"is-read-only": isReadOnly.value,
				"onUpdate:modelValue": optionSelected
			}, null, 8, [
				"parameter",
				"value",
				"is-read-only"
			])) : createCommentVNode("", true)], 2), typeof resolvedParameter.value.value === "string" ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.editorContainer)
			}, [!unref(isDisplayed) ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass([_ctx.$style.content, _ctx.$style.emptyContent])
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.emptyText) }, [createVNode(unref(N8nText_default), { color: "text-base" }, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(locale).baseText("nodeView.focusPanel.missingParameter")), 1)]),
				_: 1
			})], 2)], 2)) : expressionModeEnabled.value ? (openBlock(), createBlock(ExpressionEditorModalInput_default, {
				key: 1,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
				class: normalizeClass(_ctx.$style.editor),
				"is-read-only": isReadOnly.value,
				path: resolvedParameter.value.parameterPath,
				"data-test-id": "expression-modal-input",
				"target-node-parameter-context": targetNodeParameterContext.value,
				onChange: _cache[1] || (_cache[1] = ($event) => onInputChange($event.value))
			}, null, 8, [
				"modelValue",
				"class",
				"is-read-only",
				"path",
				"target-node-parameter-context"
			])) : ["json", "string"].includes(resolvedParameter.value.parameter.type) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [editorType.value === "codeNodeEditor" ? (openBlock(), createBlock(CodeNodeEditor_default, {
				key: 0,
				id: resolvedParameter.value.parameterPath,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[2] || (_cache[2] = ($event) => inputValue.value = $event), onInputChange],
				class: normalizeClass(_ctx.$style.heightFull),
				mode: codeEditorMode.value,
				"default-value": resolvedParameter.value.parameter.default,
				language: editorLanguage.value,
				"is-read-only": isReadOnly.value,
				"target-node-parameter-context": targetNodeParameterContext.value,
				"fill-parent": "",
				"disable-ask-ai": true
			}, null, 8, [
				"id",
				"modelValue",
				"class",
				"mode",
				"default-value",
				"language",
				"is-read-only",
				"target-node-parameter-context"
			])) : editorType.value === "htmlEditor" ? (openBlock(), createBlock(HtmlEditor_default, {
				key: 1,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[3] || (_cache[3] = ($event) => inputValue.value = $event), onInputChange],
				"is-read-only": isReadOnly.value,
				rows: editorRows.value,
				"disable-expression-coloring": !isHtmlNode.value,
				"disable-expression-completions": !isHtmlNode.value,
				fullscreen: "",
				"target-node-parameter-context": targetNodeParameterContext.value
			}, null, 8, [
				"modelValue",
				"is-read-only",
				"rows",
				"disable-expression-coloring",
				"disable-expression-completions",
				"target-node-parameter-context"
			])) : editorType.value === "cssEditor" ? (openBlock(), createBlock(CssEditor_default, {
				key: 2,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[4] || (_cache[4] = ($event) => inputValue.value = $event), onInputChange],
				"is-read-only": isReadOnly.value,
				rows: editorRows.value,
				fullscreen: "",
				"target-node-parameter-context": targetNodeParameterContext.value
			}, null, 8, [
				"modelValue",
				"is-read-only",
				"rows",
				"target-node-parameter-context"
			])) : editorType.value === "sqlEditor" ? (openBlock(), createBlock(SqlEditor_default, {
				key: 3,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[5] || (_cache[5] = ($event) => inputValue.value = $event), onInputChange],
				dialect: getTypeOption("sqlDialect"),
				"is-read-only": isReadOnly.value,
				rows: editorRows.value,
				fullscreen: "",
				"target-node-parameter-context": targetNodeParameterContext.value
			}, null, 8, [
				"modelValue",
				"dialect",
				"is-read-only",
				"rows",
				"target-node-parameter-context"
			])) : editorType.value === "jsEditor" ? (openBlock(), createBlock(JsEditor_default, {
				key: 4,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[6] || (_cache[6] = ($event) => inputValue.value = $event), onInputChange],
				"is-read-only": isReadOnly.value,
				rows: editorRows.value,
				"posthog-capture": shouldCaptureForPosthog.value,
				"fill-parent": ""
			}, null, 8, [
				"modelValue",
				"is-read-only",
				"rows",
				"posthog-capture"
			])) : resolvedParameter.value.parameter.type === "json" ? (openBlock(), createBlock(JsonEditor_default, {
				key: 5,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[7] || (_cache[7] = ($event) => inputValue.value = $event), onInputChange],
				"is-read-only": isReadOnly.value,
				rows: editorRows.value,
				fullscreen: "",
				"fill-parent": ""
			}, null, 8, [
				"modelValue",
				"is-read-only",
				"rows"
			])) : (openBlock(), createBlock(unref(Input_default), {
				key: 6,
				ref_key: "inputField",
				ref: inputField,
				modelValue: inputValue.value,
				"onUpdate:modelValue": [_cache[8] || (_cache[8] = ($event) => inputValue.value = $event), onInputChange],
				class: normalizeClass(_ctx.$style.editor),
				readonly: isReadOnly.value,
				type: "textarea",
				resize: "none"
			}, null, 8, [
				"modelValue",
				"class",
				"readonly"
			]))], 64)) : createCommentVNode("", true)], 2)) : createCommentVNode("", true)], 2)], 2)) : node.value && unref(experimentalNdvStore).isNdvInFocusPanelEnabled ? (openBlock(), createBlock(ExperimentalNodeDetailsDrawer_default, {
				key: 2,
				node: node.value,
				"node-ids": selectedNodeIds.value,
				"is-read-only": isReadOnly.value,
				onOpenNdv,
				onContextMenuAction: _cache[9] || (_cache[9] = (action, nodeIds) => emit("contextMenuAction", action, nodeIds))
			}, null, 8, [
				"node",
				"node-ids",
				"is-read-only"
			])) : (openBlock(), createElementBlock("div", {
				key: 3,
				class: normalizeClass([_ctx.$style.content, _ctx.$style.emptyContent])
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.focusParameterWrapper) }, [
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.iconWrapper) }, [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.forceHover),
					icon: "panel-right",
					size: "medium"
				}, null, 8, ["class"]), createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.pointerIcon),
					icon: "mouse-pointer",
					color: "text-dark",
					size: "large"
				}, null, 8, ["class"])], 2),
				createVNode(unref(N8nIcon_default), {
					icon: "ellipsis-vertical",
					size: "small",
					color: "text-base"
				}),
				createVNode(unref(N8nRadioButtons_default), {
					size: "small",
					"model-value": "expression",
					disabled: true,
					options: [{
						label: unref(locale).baseText("parameterInput.fixed"),
						value: "fixed"
					}, {
						label: unref(locale).baseText("parameterInput.expression"),
						value: "expression"
					}]
				}, null, 8, ["options"])
			], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.emptyText) }, [createVNode(unref(N8nText_default), {
				color: "text-base",
				size: "medium",
				bold: true
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(emptyTitle.value), 1)]),
				_: 1
			}), createVNode(unref(N8nText_default), {
				color: "text-base",
				size: "small"
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(emptySubtitle.value), 1)]),
				_: 1
			})], 2)], 2))], 2);
		};
	}
});
var FocusPanel_vue_vue_type_style_index_0_lang_module_default = {
	content: "_content_9h1id_125",
	emptyContent: "_emptyContent_9h1id_131",
	isNdvInFocusPanelEnabled: "_isNdvInFocusPanelEnabled_9h1id_136",
	emptyText: "_emptyText_9h1id_139",
	focusParameterWrapper: "_focusParameterWrapper_9h1id_145",
	iconWrapper: "_iconWrapper_9h1id_152",
	pointerIcon: "_pointerIcon_9h1id_156",
	tabHeader: "_tabHeader_9h1id_166",
	tabHeaderText: "_tabHeaderText_9h1id_173",
	buttonWrapper: "_buttonWrapper_9h1id_178",
	parameterDetailsWrapper: "_parameterDetailsWrapper_9h1id_183",
	parameterOptionsWrapper: "_parameterOptionsWrapper_9h1id_190",
	noExecutionDataTip: "_noExecutionDataTip_9h1id_194",
	editorContainer: "_editorContainer_9h1id_197",
	editor: "_editor_9h1id_197",
	delayedShow: "_delayedShow_9h1id_213",
	triggerShow: "_triggerShow_9h1id_1",
	closeButton: "_closeButton_9h1id_224",
	heightFull: "_heightFull_9h1id_228",
	forceHover: "_forceHover_9h1id_232"
};
var FocusPanel_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FocusPanel_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FocusPanel_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$1 = { key: 0 };
var FocusSidebar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "FocusSidebar",
	__name: "FocusSidebar",
	props: { isCanvasReadOnly: { type: Boolean } },
	emits: ["contextMenuAction"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const wrapperRef = useTemplateRef("wrapper");
		const focusPanelStore = useFocusPanelStore();
		const workflowsStore = useWorkflowsStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const setupPanelStore = useSetupPanelStore();
		const telemetry = useTelemetry();
		const deviceSupport = useDeviceSupport();
		const vueFlow = useVueFlow(workflowsStore.workflowId);
		const activeElement = useActiveElement();
		useTelemetryContext({ view_shown: "focus_panel" });
		const { selectedTab } = storeToRefs(focusPanelStore);
		const focusPanelActive = computed(() => focusPanelStore.focusPanelActive);
		const focusPanelWidth = computed(() => focusPanelStore.focusPanelWidth);
		const resolvedParameter = computed(() => focusPanelStore.resolvedParameter);
		const isSetupPanelEnabled = computed(() => setupPanelStore.isFeatureEnabled);
		const showSetupPanel = computed(() => setupPanelStore.isFeatureEnabled && selectedTab.value === "setup");
		const node = computed(() => {
			if (!experimentalNdvStore.isNdvInFocusPanelEnabled || resolvedParameter.value) return resolvedParameter.value?.node;
			const selected = vueFlow.getSelectedNodes.value[0];
			return selected?.data?.render.type === CanvasNodeRenderType.Default ? workflowsStore.allNodes.find((n) => n.id === selected.id) : void 0;
		});
		const labelOverrides = computed(() => {
			const focusLabel = resolvedParameter.value?.parameter.displayName ?? node.value?.name;
			return focusLabel ? { focus: focusLabel } : void 0;
		});
		function handleKeydown(event) {
			if (event.key === "s" && deviceSupport.isCtrlKeyPressed(event)) {
				event.stopPropagation();
				event.preventDefault();
			}
		}
		const registerKeyboardListener = () => {
			document.addEventListener("keydown", handleKeydown, true);
		};
		const unregisterKeyboardListener = () => {
			document.removeEventListener("keydown", handleKeydown, true);
		};
		watch(() => focusPanelStore.focusPanelActive, (newValue) => {
			if (newValue) registerKeyboardListener();
			else unregisterKeyboardListener();
		}, { immediate: true });
		watch(activeElement, (active) => {
			if (!node.value || !active || !wrapperRef.value?.contains(active)) return;
			const path = active.closest(".parameter-input")?.getAttribute("data-parameter-path");
			if (!path) return;
			telemetry.track("User focused focus panel", {
				node_id: node.value.id,
				node_type: node.value.type,
				parameter_path: path
			});
		});
		function onResize(event) {
			focusPanelStore.updateWidth(event.width);
		}
		const onResizeThrottle = useThrottleFn(onResize, 10);
		function onContextMenuAction(action, nodeIds) {
			emit("contextMenuAction", action, nodeIds);
		}
		onBeforeUnmount(() => {
			unregisterKeyboardListener();
		});
		return (_ctx, _cache) => {
			return focusPanelActive.value ? (openBlock(), createElementBlock("div", {
				key: 0,
				ref: "wrapper",
				"data-test-id": "focus-sidebar",
				class: normalizeClass([
					_ctx.$style.wrapper,
					"ignore-key-press-canvas",
					{ [_ctx.$style.isNdvInFocusPanelEnabled]: unref(experimentalNdvStore).isNdvInFocusPanelEnabled }
				]),
				onKeydown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
			}, [createVNode(unref(N8nResizeWrapper_default), {
				width: focusPanelWidth.value,
				"supported-directions": ["left"],
				"min-width": isSetupPanelEnabled.value ? 420 : 300,
				"max-width": unref(experimentalNdvStore).isNdvInFocusPanelEnabled ? void 0 : 1e3,
				"grid-size": 8,
				style: normalizeStyle({ width: `${focusPanelWidth.value}px` }),
				onResize: unref(onResizeThrottle)
			}, {
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.container) }, [isSetupPanelEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_1$1, [createVNode(FocusSidebarTabs_default, {
					modelValue: unref(selectedTab),
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(selectedTab) ? selectedTab.value = $event : null),
					"tab-labels": labelOverrides.value
				}, null, 8, ["modelValue", "tab-labels"])])) : createCommentVNode("", true), showSetupPanel.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style["setup-panel-wrapper"])
				}, [createVNode(SetupPanel_default)], 2)) : (openBlock(), createBlock(FocusPanel_default, {
					key: 2,
					"is-canvas-read-only": __props.isCanvasReadOnly,
					onContextMenuAction
				}, null, 8, ["is-canvas-read-only"]))], 2)]),
				_: 1
			}, 8, [
				"width",
				"min-width",
				"max-width",
				"style",
				"onResize"
			])], 34)) : createCommentVNode("", true);
		};
	}
});
var FocusSidebar_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_1ek2u_125",
	container: "_container_1ek2u_137",
	"setup-panel-wrapper": "_setup-panel-wrapper_1ek2u_143"
};
var FocusSidebar_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FocusSidebar_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FocusSidebar_vue_vue_type_style_index_0_lang_module_default }]]);
var CanvasStopCurrentExecutionButton_default = /* @__PURE__ */ defineComponent({
	__name: "CanvasStopCurrentExecutionButton",
	props: { stopping: { type: Boolean } },
	setup(__props) {
		const props = __props;
		const i18n = useI18n();
		const title = computed(() => props.stopping ? i18n.baseText("nodeView.stoppingCurrentExecution") : i18n.baseText("nodeView.stopCurrentExecution"));
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nIconButton_default), {
				variant: "subtle",
				icon: "square",
				size: "large",
				class: "stop-execution",
				title: title.value,
				loading: __props.stopping,
				"data-test-id": "stop-execution-button"
			}, null, 8, ["title", "loading"]);
		};
	}
});
var CanvasStopWaitingForWebhookButton_default = /* @__PURE__ */ defineComponent({
	__name: "CanvasStopWaitingForWebhookButton",
	setup(__props) {
		const i18n = useI18n();
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nIconButton_default), {
				variant: "subtle",
				class: "stop-execution",
				icon: "square",
				size: "large",
				title: unref(i18n).baseText("nodeView.stopWaitingForWebhookCall"),
				"data-test-id": "stop-execution-waiting-for-webhook-button"
			}, null, 8, ["title"]);
		};
	}
});
var _hoisted_1 = { "data-action": "reload" };
var _hoisted_2 = {
	href: "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/",
	target: "_blank"
};
var NodeViewUnfinishedWorkflowMessage_default = /* @__PURE__ */ defineComponent({
	__name: "NodeViewUnfinishedWorkflowMessage",
	setup(__props) {
		const i18 = useI18n();
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [
				createBaseVNode("a", _hoisted_1, toDisplayString(unref(i18).baseText("nodeView.refresh")), 1),
				createTextVNode(" " + toDisplayString(unref(i18).baseText("nodeView.toSeeTheLatestStatus")) + ". ", 1),
				_cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
				createBaseVNode("a", _hoisted_2, toDisplayString(unref(i18).baseText("nodeView.moreInfo")), 1)
			]);
		};
	}
});
var CanvasChatButton_default = /* @__PURE__ */ defineComponent({
	__name: "CanvasChatButton",
	props: {
		label: {},
		variant: {}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nButton_default), {
				label: __props.label,
				size: "large",
				icon: "message-circle",
				variant: __props.variant,
				"data-test-id": "workflow-chat-button"
			}, null, 8, ["label", "variant"]);
		};
	}
});
function useActivityDetection() {
	const collaborationStore = useCollaborationStore();
	const recordActivity = useDebounceFn(() => {
		collaborationStore.recordActivity();
	}, getDebounceTime(DEBOUNCE_TIME.COLLABORATION.ACTIVITY));
	const events = [
		"mousedown",
		"keydown",
		"touchstart"
	];
	const attachListeners = () => {
		events.forEach((event) => {
			document.addEventListener(event, recordActivity, { passive: true });
		});
	};
	const detachListeners = () => {
		events.forEach((event) => {
			document.removeEventListener(event, recordActivity);
		});
	};
	watch(() => collaborationStore.isCurrentUserWriter, (isWriter) => {
		if (isWriter) attachListeners();
		else detachListeners();
	});
	onMounted(() => {
		if (collaborationStore.isCurrentUserWriter) attachListeners();
	});
	onUnmounted(() => {
		detachListeners();
	});
	return { recordActivity };
}
var NodeView_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	name: "NodeView",
	__name: "NodeView",
	setup(__props) {
		const LazyNodeCreation = defineAsyncComponent(async () => await __vitePreload(() => import("./NodeCreation-whyzgIo4.js"), __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24])));
		const LazyNodeDetailsView = defineAsyncComponent(async () => await __vitePreload(() => import("./NodeDetailsView-UjRKuU_S.js"), __vite__mapDeps([25,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,19,43,44,22,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,23,83,84,85,86,87,88,89,90,91,92,93,94,95])));
		const LazyNodeDetailsViewV2 = defineAsyncComponent(async () => await __vitePreload(() => import("./NodeDetailsViewV2-BFA6Fc0N.js"), __vite__mapDeps([96,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,19,43,44,22,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,23,83,84,85,86,87,88,89,97,90,91,92,93,94,98])));
		const LazySetupWorkflowCredentialsButton = defineAsyncComponent(async () => await __vitePreload(() => import("./SetupWorkflowCredentialsButton-BB6DBoDB.js"), __vite__mapDeps([99,2,1,3,4,5,6,7,8,9,11,12,13,14,15,16,67,100,38,101])));
		const $style = useCssModule();
		const router = useRouter();
		const route = useRoute();
		const i18n = useI18n();
		const telemetry = useTelemetry();
		const externalHooks = useExternalHooks();
		const toast = useToast();
		const message = useMessage();
		const documentTitle = useDocumentTitle();
		const workflowSaving = useWorkflowSaving({
			router,
			onSaved: (isFirstSave) => {
				canvasEventBus.emit("saved:workflow", { isFirstSave });
			}
		});
		const nodeHelpers = useNodeHelpers();
		const clipboard = useClipboard({ onPaste: onClipboardPaste });
		const nodeTypesStore = useNodeTypesStore();
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const workflowsListStore = useWorkflowsListStore();
		const sourceControlStore = useSourceControlStore();
		const nodeCreatorStore = useNodeCreatorStore();
		const credentialsStore = useCredentialsStore();
		const environmentsStore = useEnvironmentsStore();
		const rootStore = useRootStore();
		const executionsStore = useExecutionsStore();
		const canvasStore = useCanvasStore();
		const npsSurveyStore = useNpsSurveyStore();
		const projectsStore = useProjectsStore();
		const usersStore = useUsersStore();
		const tagsStore = useTagsStore();
		const pushConnectionStore = usePushConnectionStore();
		const ndvStore = useNDVStore();
		const focusPanelStore = useFocusPanelStore();
		const builderStore = useBuilderStore();
		const agentRequestStore = useAgentRequestStore();
		const logsStore = useLogsStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const collaborationStore = useCollaborationStore();
		const emptyStateBuilderPromptStore = useEmptyStateBuilderPromptStore();
		const chatPanelStore = useChatPanelStore();
		const workflowState = injectWorkflowState();
		useActivityDetection();
		const { addBeforeUnloadEventBindings, removeBeforeUnloadEventBindings } = useBeforeUnload({ route });
		const { registerCustomAction, unregisterCustomAction } = useGlobalLinkActions();
		const { runWorkflow, runEntireWorkflow, stopCurrentExecution, stopWaitingForWebhook } = useRunWorkflow({ router });
		const { updateNodePosition, updateNodesPosition, tidyUp, revertUpdateNodePosition, renameNode, revertRenameNode, revertReplaceNodeParameters, setNodeActive, setNodeSelected, toggleNodesDisabled, revertToggleNodeDisabled, toggleNodesPinned, setNodeParameters, deleteNode, deleteNodes, copyNodes, cutNodes, duplicateNodes, revertDeleteNode, revertAddNode, createConnection, revertCreateConnection, deleteConnection, revertDeleteConnection, revalidateNodeInputConnections, revalidateNodeOutputConnections, setNodeActiveByName, clearNodeActive, tryToOpenSubworkflowInNewTab, importWorkflowData, fetchWorkflowDataFromUrl, resetWorkspace, initializeWorkspace, openExecution, editableWorkflow, editableWorkflowObject, lastClickPosition, startChat, addNodesAndConnections, fitView } = useCanvasOperations();
		const { extractWorkflow } = useWorkflowExtraction();
		useKeybindings({ ctrl_alt_o: () => uiStore.openModal(ABOUT_MODAL_KEY) });
		const canvasRef = useTemplateRef("canvas");
		const isLoading = ref(true);
		const readOnlyNotification = ref(null);
		const isProductionExecutionPreview = ref(false);
		const isExecutionPreview = ref(false);
		const canOpenNDV = ref(true);
		const hideNodeIssues = ref(false);
		const fallbackNodes = ref([]);
		const workflowId = injectStrict(WorkflowIdKey);
		const routeNodeId = computed(() => {
			const nodeId = route.params.nodeId;
			return Array.isArray(nodeId) ? nodeId[0] : nodeId;
		});
		const isNewWorkflowRoute = computed(() => {
			return route.query.new === "true";
		});
		const hideCanvasControls = computed(() => {
			return route.query.hideControls === "true";
		});
		const isDemoRoute = computed(() => route.name === VIEWS.DEMO);
		const isReadOnlyRoute = computed(() => !!route?.meta?.readOnlyCanvas);
		const isReadOnlyEnvironment = computed(() => {
			return sourceControlStore.preferences.branchReadOnly;
		});
		const isNDVV2 = computed(() => true);
		const isCanvasReadOnly = computed(() => {
			return isDemoRoute.value || isReadOnlyEnvironment.value || collaborationStore.shouldBeReadOnly || !(workflowPermissions.value.update ?? projectPermissions.value.workflow.update) || editableWorkflow.value.isArchived || builderStore.streaming;
		});
		const showFallbackNodes = computed(() => triggerNodes.value.length === 0);
		const keyBindingsEnabled = computed(() => {
			return !ndvStore.activeNode && uiStore.activeModals.length === 0;
		});
		const isLogsPanelOpen = computed(() => logsStore.isOpen);
		function initializeRoute() {
			if (route.query.action === "addEvaluationTrigger") nodeCreatorStore.openNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.ADD_EVALUATION_TRIGGER_BUTTON);
			else if (route.query.action === "addEvaluationNode") nodeCreatorStore.openNodeCreatorForActions(EVALUATION_NODE_TYPE, NODE_CREATOR_OPEN_SOURCES.ADD_EVALUATION_NODE_BUTTON);
			else if (route.query.action === "executeEvaluation") {
				if (evaluationTriggerNode.value) runEntireWorkflow("node", evaluationTriggerNode.value.name);
			}
			canvasEventBus.off("saved:workflow", onSaveFromWithinExecutionDebug);
			if (route.name === VIEWS.EXECUTION_DEBUG) canvasEventBus.on("saved:workflow", onSaveFromWithinExecutionDebug);
			nextTick(() => {
				updateNodesIssues();
			});
		}
		function updateNodesIssues() {
			nodeHelpers.updateNodesInputIssues();
			nodeHelpers.updateNodesCredentialsIssues();
			nodeHelpers.updateNodesParameterIssues();
		}
		async function openWorkflow(data) {
			resetWorkspace();
			if (builderStore.streaming) documentTitle.setDocumentTitle(data.name, "AI_BUILDING");
			else documentTitle.setDocumentTitle(data.name, "IDLE");
			await initializeWorkspace(data);
			externalHooks.run("workflow.open", {
				workflowId: data.id,
				workflowName: data.name
			});
			fitView();
		}
		const triggerNodes = computed(() => {
			return editableWorkflow.value.nodes.filter((node) => nodeTypesStore.isTriggerNode(node.type));
		});
		const containsTriggerNodes = computed(() => triggerNodes.value.length > 0);
		const allTriggerNodesDisabled = computed(() => {
			return triggerNodes.value.filter((node) => node.disabled).length === triggerNodes.value.length;
		});
		function onTidyUp(event, options) {
			tidyUp(event, options);
		}
		function onExtractWorkflow(nodeIds) {
			extractWorkflow(nodeIds);
		}
		function onUpdateNodesPosition(events) {
			updateNodesPosition(events, { trackHistory: true });
		}
		function onUpdateNodePosition(id, position) {
			updateNodePosition(id, position, { trackHistory: true });
		}
		function onRevertNodePosition({ nodeName, position }) {
			revertUpdateNodePosition(nodeName, {
				x: position[0],
				y: position[1]
			});
		}
		function onDeleteNode(id) {
			const matchedFallbackNode = fallbackNodes.value.findIndex((node) => node.id === id);
			if (matchedFallbackNode >= 0) fallbackNodes.value.splice(matchedFallbackNode, 1);
			else deleteNode(id, { trackHistory: true });
		}
		function onDeleteNodes(ids) {
			deleteNodes(ids);
		}
		function onRevertDeleteNode({ node }) {
			revertDeleteNode(node);
		}
		function onToggleNodeDisabled(id) {
			if (!checkIfEditingIsAllowed()) return;
			toggleNodesDisabled([id]);
		}
		function onRevertToggleNodeDisabled({ nodeName }) {
			revertToggleNodeDisabled(nodeName);
		}
		function onToggleNodesDisabled(ids) {
			if (!checkIfEditingIsAllowed()) return;
			toggleNodesDisabled(ids);
		}
		function onClickNode(_id, event) {
			lastClickPosition.value = [event.x, event.y];
			closeNodeCreator();
		}
		function onSetNodeActivated(id, event) {
			if (event?.metaKey || event?.ctrlKey) {
				if (tryToOpenSubworkflowInNewTab(id)) return;
			}
			setNodeActive(id, "canvas_default_view");
		}
		function onOpenSubWorkflow(id) {
			tryToOpenSubworkflowInNewTab(id);
		}
		function onSetNodeDeactivated() {
			clearNodeActive();
		}
		function onSetNodeSelected(id) {
			closeNodeCreator();
			setNodeSelected(id);
		}
		async function onCopyNodes(ids) {
			await copyNodes(ids);
			toast.showMessage({
				title: i18n.baseText("generic.copiedToClipboard"),
				type: "success"
			});
		}
		async function onClipboardPaste(plainTextData) {
			if (getNodeViewTab(route) !== MAIN_HEADER_TABS.WORKFLOW || !keyBindingsEnabled.value || !checkIfEditingIsAllowed()) return;
			let workflowData = null;
			if (plainTextData.match(VALID_WORKFLOW_IMPORT_URL_REGEX)) {
				if (await message.confirm(i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.message", { interpolate: { plainTextData } }), i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.headline"), {
					type: "warning",
					confirmButtonText: i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.confirmButtonText"),
					cancelButtonText: i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.cancelButtonText")
				}) !== "confirm") return;
				workflowData = await fetchWorkflowDataFromUrl(plainTextData);
			} else workflowData = jsonParse(plainTextData, { fallbackValue: null });
			if (!workflowData) return;
			const ids = (await importWorkflowData(workflowData, "paste", {
				importTags: false,
				viewport: viewportBoundaries.value
			})).nodes?.map((node) => node.id) ?? [];
			canvasRef.value?.ensureNodesAreVisible(ids);
		}
		async function onCutNodes(ids) {
			if (isCanvasReadOnly.value) await copyNodes(ids);
			else await cutNodes(ids);
		}
		async function onDuplicateNodes(ids) {
			if (!checkIfEditingIsAllowed()) return;
			const newIds = await duplicateNodes(ids, { viewport: viewportBoundaries.value });
			canvasRef.value?.ensureNodesAreVisible(newIds);
		}
		function onPinNodes(ids, source) {
			if (!checkIfEditingIsAllowed()) return;
			toggleNodesPinned(ids, source);
		}
		function onContextMenuAction(action, nodeIds) {
			canvasRef.value?.executeContextMenuAction(action, nodeIds);
		}
		function addWorkflowSavedEventBindings() {
			canvasEventBus.on("saved:workflow", npsSurveyStore.showNpsSurveyIfPossible);
		}
		function removeWorkflowSavedEventBindings() {
			canvasEventBus.off("saved:workflow", npsSurveyStore.showNpsSurveyIfPossible);
			canvasEventBus.off("saved:workflow", onSaveFromWithinExecutionDebug);
		}
		async function onCreateWorkflow() {
			await router.push({ name: VIEWS.NEW_WORKFLOW });
		}
		function onRenameNode(name) {
			if (ndvStore.activeNode?.name) renameNode(ndvStore.activeNode.name, name);
		}
		async function onOpenRenameNodeModal(id) {
			const currentName = workflowsStore.getNodeById(id)?.name ?? "";
			const activeElement = document.activeElement;
			if (activeElement && shouldIgnoreCanvasShortcut(activeElement)) return;
			if (!keyBindingsEnabled.value || document.querySelector(".rename-prompt")) return;
			try {
				const promptResponsePromise = message.prompt(i18n.baseText("nodeView.prompt.newName") + ":", i18n.baseText("nodeView.prompt.renameNode") + `: ${currentName}`, {
					customClass: "rename-prompt",
					confirmButtonText: i18n.baseText("nodeView.prompt.rename"),
					cancelButtonText: i18n.baseText("nodeView.prompt.cancel"),
					inputErrorMessage: i18n.baseText("nodeView.prompt.invalidName"),
					inputValue: currentName,
					inputValidator: (value) => {
						if (!value.trim()) return i18n.baseText("nodeView.prompt.invalidName");
						return true;
					}
				});
				await nextTick();
				const nameInput = document.querySelector(".rename-prompt .el-input__inner");
				nameInput?.focus();
				nameInput?.select();
				const promptResponse = await promptResponsePromise;
				if (promptResponse.action === "confirm") await renameNode(currentName, promptResponse.value, { trackHistory: true });
			} catch (e) {}
		}
		async function onRevertRenameNode({ currentName, newName }) {
			await revertRenameNode(currentName, newName);
		}
		async function onRevertReplaceNodeParameters({ nodeId, currentProperties, newProperties }) {
			await revertReplaceNodeParameters(nodeId, currentProperties, newProperties);
		}
		function onUpdateNodeParameters(id, parameters) {
			setNodeParameters(id, parameters);
		}
		function onUpdateNodeInputs(id) {
			revalidateNodeInputConnections(id);
		}
		function onUpdateNodeOutputs(id) {
			revalidateNodeOutputConnections(id);
		}
		function onClickNodeAdd(source, sourceHandle) {
			nodeCreatorStore.openNodeCreatorForConnectingNode({
				connection: {
					source,
					sourceHandle
				},
				eventSource: NODE_CREATOR_OPEN_SOURCES.PLUS_ENDPOINT
			});
		}
		async function loadCredentials() {
			let options;
			if (workflowId.value && !isNewWorkflowRoute.value) options = { workflowId: workflowId.value };
			else {
				const projectId = (typeof route.query?.projectId === "string" ? route.query?.projectId : void 0) ?? projectsStore.personalProject?.id;
				if (projectId === void 0) throw new Error("Could not find projectId in the query nor could I find the personal project in the project store");
				options = { projectId };
			}
			await credentialsStore.fetchAllCredentialsForWorkflow(options);
		}
		function onCreateConnection(connection) {
			createConnection(connection, { trackHistory: true });
		}
		function onRevertCreateConnection({ connection }) {
			revertCreateConnection(connection);
		}
		function onCreateConnectionCancelled(event, position, mouseEvent) {
			if ((mouseEvent?.target).classList?.contains("clickable")) return;
			uiStore.lastInteractedWithNodeId = event.nodeId;
			uiStore.lastInteractedWithNodeHandle = event.handleId;
			uiStore.lastCancelledConnectionPosition = [position.x, position.y];
			setTimeout(() => {
				if (!event.nodeId) return;
				nodeCreatorStore.openNodeCreatorForConnectingNode({
					connection: {
						source: event.nodeId,
						sourceHandle: event.handleId
					},
					eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_DROP
				});
			});
		}
		function onDeleteConnection(connection) {
			deleteConnection(connection, { trackHistory: true });
		}
		function onRevertDeleteConnection({ connection }) {
			revertDeleteConnection(connection);
		}
		async function importWorkflowExact({ workflow: workflowData }) {
			if (!workflowData.nodes || !workflowData.connections) throw new Error("Invalid workflow object");
			resetWorkspace();
			await initializeWorkspace({
				...workflowData,
				nodes: getNodesWithNormalizedPosition(workflowData.nodes)
			});
			fitView();
		}
		async function onImportWorkflowDataEvent(data) {
			const workflowData = data.data;
			const trackEvents = typeof data.trackEvents === "boolean" ? data.trackEvents : void 0;
			const setStateDirty = typeof data.setStateDirty === "boolean" ? data.setStateDirty : void 0;
			await importWorkflowData(workflowData, "file", {
				viewport: viewportBoundaries.value,
				regenerateIds: data.regenerateIds === true || data.regenerateIds === void 0,
				trackEvents,
				setStateDirty
			});
			await nextTick();
			fitView();
			selectNodes(workflowData.nodes?.map((node) => node.id) ?? []);
			if (data.tidyUp) {
				const nodesIdsToTidyUp = data.nodesIdsToTidyUp;
				setTimeout(async () => {
					canvasEventBus.emit("tidyUp", {
						source: "import-workflow-data",
						nodeIdsFilter: nodesIdsToTidyUp,
						trackEvents
					});
					await nextTick();
					fitView();
				}, 0);
			}
		}
		async function onImportWorkflowUrlEvent(data) {
			const workflowData = await fetchWorkflowDataFromUrl(data.url);
			if (!workflowData) return;
			await importWorkflowData(workflowData, "url", { viewport: viewportBoundaries.value });
			canvasRef.value?.ensureNodesAreVisible(workflowData.nodes?.map((node) => node.id) ?? []);
		}
		function addImportEventBindings() {
			nodeViewEventBus.on("importWorkflowData", onImportWorkflowDataEvent);
			nodeViewEventBus.on("importWorkflowUrl", onImportWorkflowUrlEvent);
			nodeViewEventBus.on("openChat", onOpenChat);
		}
		function removeImportEventBindings() {
			nodeViewEventBus.off("importWorkflowData", onImportWorkflowDataEvent);
			nodeViewEventBus.off("importWorkflowUrl", onImportWorkflowUrlEvent);
			nodeViewEventBus.off("openChat", onOpenChat);
		}
		const nodeCreatorReplaceTargetId = ref(void 0);
		function onNodeCreatorClose() {
			nodeCreatorReplaceTargetId.value = void 0;
		}
		async function onAddNodesAndConnections({ nodes, connections }, dragAndDrop = false, position) {
			if (!checkIfEditingIsAllowed()) return;
			if (nodeCreatorReplaceTargetId.value !== void 0) {
				uiStore.resetLastInteractedWith();
				nodes = nodes.map((x) => ({
					...x,
					openDetail: false
				}));
			}
			const { addedNodes } = await addNodesAndConnections(nodes, connections, {
				dragAndDrop,
				position,
				viewport: viewportBoundaries.value,
				telemetry: true,
				replaceNodeId: nodeCreatorReplaceTargetId.value
			});
			if (addedNodes.length > 0) {
				const lastAddedNodeId = addedNodes[addedNodes.length - 1].id;
				selectNodes([lastAddedNodeId]);
			}
		}
		async function onRevertAddNode({ node }) {
			await revertAddNode(node.name);
		}
		function onSwitchActiveNode(nodeName) {
			const node = workflowsStore.getNodeByName(nodeName);
			if (!node) return;
			setNodeActiveByName(nodeName, "other");
			selectNodes([node.id]);
		}
		function onOpenSelectiveNodeCreator(node, connectionType, connectionIndex = 0) {
			nodeCreatorStore.openSelectiveNodeCreator({
				node,
				connectionType,
				connectionIndex
			});
		}
		function onToggleNodeCreator(options) {
			nodeCreatorStore.setNodeCreatorState(options);
			if (!options.createNodeActive) {
				nodeCreatorReplaceTargetId.value = void 0;
				if (!options.hasAddedNodes) uiStore.resetLastInteractedWith();
			}
		}
		function onOpenNodeCreatorFromCanvas(source) {
			onToggleNodeCreator({
				createNodeActive: true,
				source
			});
		}
		function onOpenNodeCreatorForTriggerNodes(source) {
			nodeCreatorStore.openNodeCreatorForTriggerNodes(source);
		}
		function onToggleFocusPanel() {
			focusPanelStore.toggleFocusPanel();
			telemetry.track(`User ${focusPanelStore.focusPanelActive ? "opened" : "closed"} focus panel`, {
				source: "canvasKeyboardShortcut",
				parameters: focusPanelStore.focusedNodeParametersInTelemetryFormat,
				parameterCount: focusPanelStore.focusedNodeParametersInTelemetryFormat.length
			});
		}
		function closeNodeCreator() {
			if (nodeCreatorStore.isCreateNodeActive) nodeCreatorStore.isCreateNodeActive = false;
		}
		function onCreateSticky() {
			onAddNodesAndConnections({
				nodes: [{ type: STICKY_NODE_TYPE }],
				connections: []
			});
		}
		function onClickConnectionAdd(connection) {
			const { type, mode } = parseCanvasConnectionHandleString(connection.sourceHandle);
			if (type === NodeConnectionTypes.AiTool && mode === CanvasConnectionMode.Output) nodeCreatorStore.openNodeCreatorForConnectingNode({
				connection,
				eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION,
				nodeCreatorView: HUMAN_IN_THE_LOOP_CATEGORY
			});
			else nodeCreatorStore.openNodeCreatorForConnectingNode({
				connection,
				eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION
			});
		}
		function onClickReplaceNode(nodeId) {
			const node = workflowsStore.getNodeById(nodeId);
			if (!node) return;
			const nodeType = nodeTypesStore.getNodeType(node.type);
			if (!nodeType) return;
			nodeCreatorReplaceTargetId.value = nodeId;
			if (isTriggerNode(nodeType)) nodeCreatorStore.openNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.REPLACE_NODE_ACTION);
			else {
				const inputs = getNodeInputs(editableWorkflowObject.value, node, nodeType).map((output) => typeof output === "string" ? output : output.type);
				const outputs = getNodeOutputs(editableWorkflowObject.value, node, nodeType).map((output) => typeof output === "string" ? output : output.type);
				if (inputs[0] && outputs[0] && inputs[0] !== outputs[0]) nodeCreatorStore.openNodeCreatorForRegularNodes(NODE_CREATOR_OPEN_SOURCES.REPLACE_NODE_ACTION);
				else nodeCreatorStore.openSelectiveNodeCreator({
					connectionType: inputs[0] ?? outputs[0],
					node: node.name
				});
			}
		}
		const workflowPermissions = computed(() => {
			return workflowId.value ? getResourcePermissions(workflowsListStore.getWorkflowById(workflowId.value)?.scopes).workflow : {};
		});
		const projectPermissions = computed(() => {
			return getResourcePermissions((route.query?.projectId ? projectsStore.myProjects.find((p) => p.id === route.query.projectId) : projectsStore.currentProject ?? projectsStore.personalProject)?.scopes);
		});
		const isStoppingExecution = ref(false);
		const isWorkflowRunning = computed(() => workflowsStore.isWorkflowRunning);
		const isExecutionWaitingForWebhook = computed(() => workflowsStore.executionWaitingForWebhook);
		const isExecutionDisabled = computed(() => {
			if (containsChatTriggerNodes.value && isOnlyChatTriggerNodeActive.value && !chatTriggerNodePinnedData.value) return true;
			return !containsTriggerNodes.value || allTriggerNodesDisabled.value;
		});
		const isRunWorkflowButtonVisible = computed(() => !isOnlyChatTriggerNodeActive.value || chatTriggerNodePinnedData.value);
		const isStopExecutionButtonVisible = computed(() => isWorkflowRunning.value && !isExecutionWaitingForWebhook.value);
		const isStopWaitingForWebhookButtonVisible = computed(() => isWorkflowRunning.value && isExecutionWaitingForWebhook.value);
		async function onRunWorkflowToNode(id) {
			const node = workflowsStore.getNodeById(id);
			if (!node) return;
			if (needsAgentInput(node) && nodeTypesStore.isToolNode(node.type)) uiStore.openModalWithData({
				name: FROM_AI_PARAMETERS_MODAL_KEY,
				data: { nodeName: node.name }
			});
			else {
				trackRunWorkflowToNode(node);
				agentRequestStore.clearAgentRequests(workflowsStore.workflowId, node.id);
				runWorkflow({
					destinationNode: {
						nodeName: node.name,
						mode: "inclusive"
					},
					source: "Node.executeNode"
				});
			}
		}
		async function copyWebhookUrl(id, webhookType) {
			const webhookUrl = await workflowsStore.getWebhookUrl(id, webhookType);
			if (!webhookUrl) return;
			clipboard.copy(webhookUrl);
			toast.showMessage({
				title: i18n.baseText("nodeWebhooks.showMessage.title"),
				type: "success"
			});
		}
		async function onCopyTestUrl(id) {
			const node = workflowsStore.getNodeById(id);
			if (PRODUCTION_ONLY_TRIGGER_NODE_TYPES.includes(node?.type ?? "")) {
				toast.showMessage({
					title: i18n.baseText("nodeWebhooks.showMessage.testWebhookUrl"),
					type: "warning"
				});
				return;
			}
			copyWebhookUrl(id, "test");
		}
		async function onCopyProductionUrl(id) {
			if (!workflowsStore.workflow.active) {
				toast.showMessage({
					title: i18n.baseText("nodeWebhooks.showMessage.not.active"),
					type: "warning"
				});
				return;
			}
			copyWebhookUrl(id, "production");
		}
		function trackRunWorkflowToNode(node) {
			const telemetryPayload = {
				node_type: node.type,
				workflow_id: workflowsStore.workflowId,
				source: "canvas",
				push_ref: ndvStore.pushRef
			};
			telemetry.track("User clicked execute node button", telemetryPayload);
			externalHooks.run("nodeView.onRunNode", telemetryPayload);
		}
		async function onOpenExecution(executionId, nodeId) {
			canvasStore.startLoading();
			resetWorkspace();
			const data = await openExecution(executionId, nodeId);
			if (!data) return;
			nextTick(() => {
				updateNodesIssues();
			});
			canvasStore.stopLoading();
			fitView();
			canvasEventBus.emit("open:execution", data);
			externalHooks.run("execution.open", {
				workflowId: data.workflowData.id,
				workflowName: data.workflowData.name,
				executionId
			});
			telemetry.track("User opened read-only execution", {
				workflow_id: data.workflowData.id,
				execution_mode: data.mode,
				execution_finished: data.finished
			});
		}
		function onExecutionOpenedWithError(data) {
			if (!data.finished && data.data?.resultData?.error) {
				let nodeErrorFound = false;
				if (data.data.resultData.runData) {
					const runData = data.data.resultData.runData;
					errorCheck: for (const nodeName of Object.keys(runData)) for (const taskData of runData[nodeName]) if (taskData.error) {
						nodeErrorFound = true;
						break errorCheck;
					}
				}
				if (!nodeErrorFound && (data.data.resultData.error.stack ?? data.data.resultData.error.message)) {
					console.error(`Execution ${data.id} error:`);
					console.error(data.data.resultData.error.stack);
					toast.showMessage({
						title: i18n.baseText("nodeView.showError.workflowError"),
						message: data.data.resultData.error.message,
						type: "error",
						duration: 0
					});
				}
			}
		}
		function onExecutionOpenedWithWaitTill(data) {
			if (data.waitTill) toast.showMessage({
				title: i18n.baseText("nodeView.thisExecutionHasntFinishedYet"),
				message: h(NodeViewUnfinishedWorkflowMessage_default),
				type: "warning",
				duration: 0
			});
		}
		function addExecutionOpenedEventBindings() {
			canvasEventBus.on("open:execution", onExecutionOpenedWithError);
			canvasEventBus.on("open:execution", onExecutionOpenedWithWaitTill);
		}
		function removeExecutionOpenedEventBindings() {
			canvasEventBus.off("open:execution", onExecutionOpenedWithError);
			canvasEventBus.off("open:execution", onExecutionOpenedWithWaitTill);
		}
		async function onStopExecution() {
			isStoppingExecution.value = true;
			await stopCurrentExecution();
			isStoppingExecution.value = false;
		}
		async function onStopWaitingForWebhook() {
			await stopWaitingForWebhook();
		}
		function onRunWorkflowButtonMouseEnter() {
			nodeViewEventBus.emit("runWorkflowButton:mouseenter");
		}
		function onRunWorkflowButtonMouseLeave() {
			nodeViewEventBus.emit("runWorkflowButton:mouseleave");
		}
		const chatTriggerNode = computed(() => {
			return editableWorkflow.value.nodes.find((node) => node.type === CHAT_TRIGGER_NODE_TYPE);
		});
		const containsChatTriggerNodes = computed(() => {
			return !isExecutionWaitingForWebhook.value && !!editableWorkflow.value.nodes.find((node) => ["@n8n/n8n-nodes-langchain.manualChatTrigger", "@n8n/n8n-nodes-langchain.chatTrigger"].includes(node.type) && node.disabled !== true);
		});
		const isOnlyChatTriggerNodeActive = computed(() => {
			return triggerNodes.value.every((node) => node.disabled || node.type === "@n8n/n8n-nodes-langchain.chatTrigger");
		});
		const chatTriggerNodePinnedData = computed(() => {
			if (!chatTriggerNode.value) return null;
			return workflowsStore.pinDataByNodeName(chatTriggerNode.value.name);
		});
		function onOpenChat() {
			startChat("main");
		}
		const evaluationTriggerNode = computed(() => {
			return editableWorkflow.value.nodes.find((node) => node.type === EVALUATION_TRIGGER_NODE_TYPE);
		});
		function addUndoRedoEventBindings() {
			historyBus.on("nodeMove", onRevertNodePosition);
			historyBus.on("revertAddNode", onRevertAddNode);
			historyBus.on("revertRemoveNode", onRevertDeleteNode);
			historyBus.on("revertAddConnection", onRevertCreateConnection);
			historyBus.on("revertRemoveConnection", onRevertDeleteConnection);
			historyBus.on("revertRenameNode", onRevertRenameNode);
			historyBus.on("revertReplaceNodeParameters", onRevertReplaceNodeParameters);
			historyBus.on("enableNodeToggle", onRevertToggleNodeDisabled);
		}
		function removeUndoRedoEventBindings() {
			historyBus.off("nodeMove", onRevertNodePosition);
			historyBus.off("revertAddNode", onRevertAddNode);
			historyBus.off("revertRemoveNode", onRevertDeleteNode);
			historyBus.off("revertAddConnection", onRevertCreateConnection);
			historyBus.off("revertRemoveConnection", onRevertDeleteConnection);
			historyBus.off("revertRenameNode", onRevertRenameNode);
			historyBus.off("revertReplaceNodeParameters", onRevertReplaceNodeParameters);
			historyBus.off("enableNodeToggle", onRevertToggleNodeDisabled);
		}
		async function onSourceControlPull() {
			try {
				await Promise.all([
					environmentsStore.fetchAllVariables(),
					tagsStore.fetchAll(),
					loadCredentials(),
					projectsStore.getAvailableProjects()
				]);
				if (workflowId.value && !uiStore.stateIsDirty) {
					const workflowData = await workflowsListStore.fetchWorkflow(workflowId.value);
					if (workflowData) await openWorkflow(workflowData);
				}
			} catch (error) {
				console.error(error);
			}
		}
		function addSourceControlEventBindings() {
			sourceControlEventBus.on("pull", onSourceControlPull);
		}
		function removeSourceControlEventBindings() {
			sourceControlEventBus.off("pull", onSourceControlPull);
		}
		function addCommandBarEventBindings() {
			canvasEventBus.on("create:sticky", onCreateSticky);
		}
		function removeCommandBarEventBindings() {
			canvasEventBus.off("create:sticky", onCreateSticky);
		}
		function addPostMessageEventBindings() {
			window.addEventListener("message", onPostMessageReceived);
		}
		function removePostMessageEventBindings() {
			window.removeEventListener("message", onPostMessageReceived);
		}
		function emitPostMessageReady() {
			if (window.parent) window.parent.postMessage(JSON.stringify({
				command: "n8nReady",
				version: rootStore.versionCli
			}), "*");
		}
		async function onPostMessageReceived(messageEvent) {
			if (!messageEvent || typeof messageEvent.data !== "string" || !messageEvent.data?.includes?.("\"command\"")) return;
			try {
				const json = JSON.parse(messageEvent.data);
				if (json && json.command === "openWorkflow") try {
					if (json.projectId) await projectsStore.fetchAndSetProject(json.projectId);
					await importWorkflowExact(json);
					canOpenNDV.value = json.canOpenNDV ?? true;
					hideNodeIssues.value = json.hideNodeIssues ?? false;
					isExecutionPreview.value = false;
					if (json.tidyUp === true) canvasEventBus.emit("tidyUp", { source: "import-workflow-data" });
				} catch (e) {
					if (window.top) window.top.postMessage(JSON.stringify({
						command: "error",
						message: i18n.baseText("openWorkflow.workflowImportError")
					}), "*");
					toast.showError(e, i18n.baseText("openWorkflow.workflowImportError"));
				}
				else if (json && json.command === "openExecution") try {
					if (json.projectId) await projectsStore.fetchAndSetProject(json.projectId);
					isProductionExecutionPreview.value = json.executionMode !== "manual" && json.executionMode !== "evaluation";
					await onOpenExecution(json.executionId, json.nodeId);
					canOpenNDV.value = json.canOpenNDV ?? true;
					hideNodeIssues.value = json.hideNodeIssues ?? false;
					isExecutionPreview.value = true;
				} catch (e) {
					if (window.top) window.top.postMessage(JSON.stringify({
						command: "error",
						message: i18n.baseText("nodeView.showError.openExecution.title")
					}), "*");
					toast.showMessage({
						title: i18n.baseText("nodeView.showError.openExecution.title"),
						message: e.message,
						type: "error"
					});
				}
				else if (json?.command === "setActiveExecution") executionsStore.activeExecution = await executionsStore.fetchExecution(json.executionId);
			} catch (e) {}
		}
		function checkIfEditingIsAllowed() {
			if (!uiStore.nodeViewInitialized) return true;
			if (readOnlyNotification.value?.visible) return false;
			if (!(workflowPermissions.value.update ?? projectPermissions.value.workflow.update)) return false;
			if (collaborationStore.shouldBeReadOnly) return false;
			if (isReadOnlyRoute.value || isReadOnlyEnvironment.value) {
				const messageContext = isReadOnlyRoute.value ? "executions" : "workflows";
				readOnlyNotification.value = toast.showMessage({
					title: i18n.baseText(isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.title` : "readOnly.showMessage.executions.title"),
					message: i18n.baseText(isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.message` : "readOnly.showMessage.executions.message"),
					type: "info"
				});
				return false;
			}
			return true;
		}
		function checkIfRouteIsAllowed() {
			if (isReadOnlyEnvironment.value && [VIEWS.NEW_WORKFLOW, VIEWS.TEMPLATE_IMPORT].find((view) => view === route.name)) nextTick(async () => {
				resetWorkspace();
				uiStore.markStateClean();
				await router.replace({ name: VIEWS.HOMEPAGE });
			});
		}
		async function onSaveFromWithinExecutionDebug() {
			if (route.name !== VIEWS.EXECUTION_DEBUG) return;
			await router.replace({
				name: VIEWS.WORKFLOW,
				params: { name: workflowId.value }
			});
		}
		const viewportTransform = ref({
			x: 0,
			y: 0,
			zoom: 1
		});
		const viewportDimensions = ref({
			width: 0,
			height: 0
		});
		const viewportBoundaries = computed(() => getBounds(viewportTransform.value, viewportDimensions.value));
		function onViewportChange(viewport, dimensions) {
			viewportTransform.value = viewport;
			viewportDimensions.value = dimensions;
			uiStore.nodeViewOffsetPosition = [viewport.x, viewport.y];
		}
		function selectNodes(ids) {
			setTimeout(() => canvasEventBus.emit("nodes:select", { ids }));
		}
		function onClickPane(position) {
			lastClickPosition.value = [position.x, position.y];
			onSetNodeSelected();
		}
		function onSelectionEnd(position) {
			lastClickPosition.value = [position.x, position.y];
		}
		async function onDragAndDrop(position, event) {
			if (!event.dataTransfer) return;
			const dropData = jsonParse(event.dataTransfer.getData(DRAG_EVENT_DATA_KEY));
			if (dropData) {
				await onAddNodesAndConnections(dropData, true, [position.x, position.y]);
				onToggleNodeCreator({
					createNodeActive: false,
					hasAddedNodes: true
				});
			}
		}
		function registerCustomActions() {
			registerCustomAction({
				key: "openNodeDetail",
				action: ({ node }) => {
					setNodeActiveByName(node, "other");
				}
			});
			registerCustomAction({
				key: "openSelectiveNodeCreator",
				action: ({ creatorview: creatorView, connectiontype: connectionType, node }) => {
					nodeCreatorStore.openSelectiveNodeCreator({
						node,
						connectionType,
						creatorView
					});
				}
			});
			registerCustomAction({
				key: "showNodeCreator",
				action: () => {
					ndvStore.unsetActiveNodeName();
					nextTick(() => {
						onOpenNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.TAB);
					});
				}
			});
		}
		function unregisterCustomActions() {
			unregisterCustomAction("openNodeDetail");
			unregisterCustomAction("openSelectiveNodeCreator");
			unregisterCustomAction("showNodeCreator");
		}
		function showAddFirstStepIfEnabled() {
			if (uiStore.addFirstStepOnLoad) {
				onOpenNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
				uiStore.addFirstStepOnLoad = false;
			}
		}
		async function handlePendingBuilderPrompt() {
			const pendingPrompt = emptyStateBuilderPromptStore.consumePendingPrompt();
			if (pendingPrompt) {
				await chatPanelStore.open({
					mode: "builder",
					showCoachmark: false
				});
				await builderStore.sendChatMessage({
					text: pendingPrompt,
					initialGeneration: true,
					source: "empty-state"
				});
			}
		}
		function updateNodeRoute(nodeId) {
			const nodeUi = workflowsStore.findNodeByPartialId(nodeId);
			if (nodeUi) setNodeActive(nodeUi.id, "other");
			else {
				toast.showToast({
					title: i18n.baseText("nodeView.showMessage.ndvUrl.missingNodes.title"),
					message: i18n.baseText("nodeView.showMessage.ndvUrl.missingNodes.content"),
					type: "warning"
				});
				router.replace({
					name: route.name,
					params: { name: workflowId.value },
					query: route.query
				});
			}
		}
		watch([() => route.name, () => route.params.name], () => {
			initializeRoute();
		});
		watch(() => {
			return isLoading.value || isCanvasReadOnly.value || editableWorkflow.value.nodes.length !== 0;
		}, (isReadOnlyOrLoading) => {
			if (isReadOnlyOrLoading) {
				fallbackNodes.value = [];
				return;
			}
			const addNodesItem = {
				id: CanvasNodeRenderType.AddNodes,
				name: CanvasNodeRenderType.AddNodes,
				type: CanvasNodeRenderType.AddNodes,
				typeVersion: 1,
				position: [0, 0],
				parameters: {}
			};
			const choicePromptItem = {
				id: CanvasNodeRenderType.ChoicePrompt,
				name: CanvasNodeRenderType.ChoicePrompt,
				type: CanvasNodeRenderType.ChoicePrompt,
				typeVersion: 1,
				position: [0, 0],
				parameters: {},
				draggable: false
			};
			fallbackNodes.value = builderStore.isAIBuilderEnabled ? [choicePromptItem] : [addNodesItem];
		});
		watch(() => route.params.nodeId, async (newId) => {
			if (typeof newId !== "string" || newId === "") ndvStore.unsetActiveNodeName();
			else updateNodeRoute(newId);
		});
		watch(() => ndvStore.activeNode, async (val) => {
			if (![VIEWS.WORKFLOW].includes(String(route.name))) return;
			const nodeId = val?.id ? workflowsStore.getPartialIdForNode(val?.id) : "";
			if (nodeId !== route.params.nodeId) await router.replace({
				name: route.name,
				params: {
					name: workflowId.value,
					nodeId
				},
				query: route.query
			});
		});
		watch(() => uiStore.dirtyStateSetCount, (dirtyStateSetCount) => {
			if (dirtyStateSetCount > 0) {
				if (isDemoRoute.value) return;
				collaborationStore.requestWriteAccess();
				if (!builderStore.streaming) workflowSaving.autoSaveWorkflow();
			}
		});
		watch(() => builderStore.streaming, (isStreaming, wasStreaming) => {
			if (wasStreaming && !isStreaming) {
				if (uiStore.stateIsDirty && !collaborationStore.shouldBeReadOnly) workflowSaving.autoSaveWorkflow();
			}
		});
		onBeforeRouteLeave(async (to, from, next) => {
			if (focusPanelStore.focusPanelActive) focusPanelStore.closeFocusPanel();
			if (isReadOnlyEnvironment.value) {
				next();
				return;
			}
			const toNodeViewTab = getNodeViewTab(to);
			const isNavigatingBetweenWorkflows = [VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW].includes(from.name) && [VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW].includes(to.name) && from.params.name !== to.params.name;
			if ((toNodeViewTab === MAIN_HEADER_TABS.EXECUTIONS || from.name === VIEWS.TEMPLATE_IMPORT || toNodeViewTab === MAIN_HEADER_TABS.WORKFLOW && from.name === VIEWS.EXECUTION_DEBUG) && !isNavigatingBetweenWorkflows) {
				next();
				return;
			}
			await useWorkflowSaving({ router }).promptSaveUnsavedWorkflowChanges(next, { async confirm() {
				if (from.name === VIEWS.NEW_WORKFLOW) {
					const savedWorkflowId = workflowsStore.workflowId;
					await router.replace({
						name: VIEWS.WORKFLOW,
						params: { name: savedWorkflowId }
					});
					await router.push(to);
					return false;
				}
				workflowState.setWorkflowId("");
				return true;
			} });
		});
		onBeforeMount(() => {
			if (!isDemoRoute.value) pushConnectionStore.pushConnect();
			addPostMessageEventBindings();
		});
		onMounted(async () => {
			canvasStore.startLoading();
			documentTitle.reset();
			collaborationStore.setRefreshCanvasCallback(async (workflow) => {
				await initializeWorkspace(workflow);
			});
			try {
				initializeRoute();
				toast.showNotificationForViews([VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW]);
				if (route.query.settings) {
					uiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);
					router.replace({ query: { settings: void 0 } });
				}
			} finally {
				isLoading.value = false;
				canvasStore.stopLoading();
				externalHooks.run("nodeView.mount").catch(() => {});
				setTimeout(() => {
					if (routeNodeId.value) updateNodeRoute(routeNodeId.value);
				}, 500);
				emitPostMessageReady();
				handlePendingBuilderPrompt();
			}
			usersStore.showPersonalizationSurvey();
			checkIfRouteIsAllowed();
			addSourceControlEventBindings();
			addWorkflowSavedEventBindings();
			addBeforeUnloadEventBindings();
			addImportEventBindings();
			addExecutionOpenedEventBindings();
			addCommandBarEventBindings();
			registerCustomActions();
		});
		onActivated(() => {
			addUndoRedoEventBindings();
			showAddFirstStepIfEnabled();
		});
		onDeactivated(() => {
			uiStore.closeModal(WORKFLOW_SETTINGS_MODAL_KEY);
			removeUndoRedoEventBindings();
			toast.clearAllStickyNotifications();
		});
		onBeforeUnmount(() => {
			removeSourceControlEventBindings();
			removePostMessageEventBindings();
			removeWorkflowSavedEventBindings();
			removeBeforeUnloadEventBindings();
			removeImportEventBindings();
			removeExecutionOpenedEventBindings();
			removeCommandBarEventBindings();
			unregisterCustomActions();
			canvasEventBus.off("saved:workflow", onSaveFromWithinExecutionDebug);
			if (!isDemoRoute.value) pushConnectionStore.pushDisconnect();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(unref($style).wrapper) }, [unref(editableWorkflow) && unref(editableWorkflowObject) && !isLoading.value ? (openBlock(), createBlock(WorkflowCanvas_default, {
				key: 0,
				id: unref(editableWorkflow).id,
				ref: "canvas",
				workflow: unref(editableWorkflow),
				"workflow-object": unref(editableWorkflowObject),
				"fallback-nodes": fallbackNodes.value,
				"show-fallback-nodes": showFallbackNodes.value,
				"event-bus": unref(canvasEventBus),
				"read-only": isCanvasReadOnly.value,
				executing: isWorkflowRunning.value,
				"key-bindings": keyBindingsEnabled.value,
				"suppress-interaction": unref(experimentalNdvStore).isMapperOpen,
				"hide-controls": hideCanvasControls.value,
				"onUpdate:nodes:position": onUpdateNodesPosition,
				"onUpdate:node:position": onUpdateNodePosition,
				"onUpdate:node:activated": onSetNodeActivated,
				"onUpdate:node:deactivated": onSetNodeDeactivated,
				"onUpdate:node:selected": onSetNodeSelected,
				"onUpdate:node:enabled": onToggleNodeDisabled,
				"onUpdate:node:name": onOpenRenameNodeModal,
				"onUpdate:node:parameters": onUpdateNodeParameters,
				"onUpdate:node:inputs": onUpdateNodeInputs,
				"onUpdate:node:outputs": onUpdateNodeOutputs,
				"onUpdate:logsOpen": _cache[3] || (_cache[3] = ($event) => unref(logsStore).toggleOpen($event)),
				"onUpdate:logs:inputOpen": unref(logsStore).toggleInputOpen,
				"onUpdate:logs:outputOpen": unref(logsStore).toggleOutputOpen,
				"onUpdate:hasRangeSelection": unref(canvasStore).setHasRangeSelection,
				"onOpen:subWorkflow": onOpenSubWorkflow,
				"onClick:node": onClickNode,
				"onClick:node:add": onClickNodeAdd,
				"onRun:node": onRunWorkflowToNode,
				"onCopy:production:url": onCopyProductionUrl,
				"onCopy:test:url": onCopyTestUrl,
				"onDelete:node": onDeleteNode,
				"onCreate:connection": onCreateConnection,
				"onCreate:connection:cancelled": onCreateConnectionCancelled,
				"onDelete:connection": onDeleteConnection,
				"onClick:connection:add": onClickConnectionAdd,
				"onClick:pane": onClickPane,
				"onCreate:node": onOpenNodeCreatorFromCanvas,
				"onCreate:sticky": onCreateSticky,
				"onDelete:nodes": onDeleteNodes,
				"onUpdate:nodes:enabled": onToggleNodesDisabled,
				"onUpdate:nodes:pin": onPinNodes,
				"onDuplicate:nodes": onDuplicateNodes,
				"onCopy:nodes": onCopyNodes,
				"onCut:nodes": onCutNodes,
				"onReplace:node": onClickReplaceNode,
				"onRun:workflow": _cache[4] || (_cache[4] = ($event) => unref(runEntireWorkflow)("main")),
				"onCreate:workflow": onCreateWorkflow,
				"onViewport:change": onViewportChange,
				"onSelection:end": onSelectionEnd,
				onDragAndDrop,
				onTidyUp,
				"onToggle:focusPanel": onToggleFocusPanel,
				onExtractWorkflow,
				onStartChat: _cache[5] || (_cache[5] = ($event) => unref(startChat)())
			}, {
				default: withCtx(() => [
					!isCanvasReadOnly.value ? (openBlock(), createBlock(Suspense, { key: 0 }, {
						default: withCtx(() => [createVNode(unref(LazySetupWorkflowCredentialsButton), { class: normalizeClass(unref($style).setupCredentialsButtonWrapper) }, null, 8, ["class"])]),
						_: 1
					})) : createCommentVNode("", true),
					!isCanvasReadOnly.value ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(unref($style).executionButtons)
					}, [
						isRunWorkflowButtonVisible.value ? (openBlock(), createBlock(CanvasRunWorkflowButton_default, {
							key: 0,
							"waiting-for-webhook": isExecutionWaitingForWebhook.value,
							disabled: isExecutionDisabled.value,
							executing: isWorkflowRunning.value,
							"trigger-nodes": triggerNodes.value,
							"get-node-type": unref(nodeTypesStore).getNodeType,
							"selected-trigger-node-name": unref(workflowsStore).selectedTriggerNodeName,
							onMouseenter: onRunWorkflowButtonMouseEnter,
							onMouseleave: onRunWorkflowButtonMouseLeave,
							onExecute: _cache[0] || (_cache[0] = ($event) => unref(runEntireWorkflow)("main")),
							onSelectTriggerNode: unref(workflowsStore).setSelectedTriggerNodeName
						}, null, 8, [
							"waiting-for-webhook",
							"disabled",
							"executing",
							"trigger-nodes",
							"get-node-type",
							"selected-trigger-node-name",
							"onSelectTriggerNode"
						])) : createCommentVNode("", true),
						containsChatTriggerNodes.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [isLogsPanelOpen.value ? (openBlock(), createBlock(CanvasChatButton_default, {
							key: 0,
							variant: "subtle",
							label: unref(i18n).baseText("chat.hide"),
							class: normalizeClass(unref($style).chatButton),
							onClick: _cache[1] || (_cache[1] = ($event) => unref(logsStore).toggleOpen(false))
						}, null, 8, ["label", "class"])) : (openBlock(), createBlock(KeyboardShortcutTooltip_default, {
							key: 1,
							label: unref(i18n).baseText("chat.open"),
							shortcut: { keys: ["c"] }
						}, {
							default: withCtx(() => [createVNode(CanvasChatButton_default, {
								variant: isRunWorkflowButtonVisible.value ? "subtle" : "solid",
								label: unref(i18n).baseText("chat.open"),
								class: normalizeClass(unref($style).chatButton),
								onClick: onOpenChat
							}, null, 8, [
								"variant",
								"label",
								"class"
							])]),
							_: 1
						}, 8, ["label"]))], 64)) : createCommentVNode("", true),
						isStopExecutionButtonVisible.value ? (openBlock(), createBlock(CanvasStopCurrentExecutionButton_default, {
							key: 2,
							stopping: isStoppingExecution.value,
							onClick: onStopExecution
						}, null, 8, ["stopping"])) : createCommentVNode("", true),
						isStopWaitingForWebhookButtonVisible.value ? (openBlock(), createBlock(CanvasStopWaitingForWebhookButton_default, {
							key: 3,
							onClick: onStopWaitingForWebhook
						})) : createCommentVNode("", true)
					], 2)) : createCommentVNode("", true),
					isReadOnlyEnvironment.value ? (openBlock(), createBlock(unref(N8nCallout_default), {
						key: 2,
						theme: "warning",
						icon: "lock",
						class: normalizeClass(unref($style).readOnlyEnvironmentNotification)
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("readOnlyEnv.cantEditOrRun")), 1)]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("", true),
					unref(collaborationStore).currentWriter && !unref(collaborationStore).isCurrentUserWriter ? (openBlock(), createBlock(unref(CanvasCollaborationPill_default), {
						key: 3,
						"first-name": unref(collaborationStore).currentWriter.user.firstName,
						"last-name": unref(collaborationStore).currentWriter.user.lastName,
						class: normalizeClass(unref($style).canvasCenterPill)
					}, null, 8, [
						"first-name",
						"last-name",
						"class"
					])) : createCommentVNode("", true),
					unref(builderStore).streaming ? (openBlock(), createBlock(unref(CanvasThinkingPill_default), {
						key: 4,
						class: normalizeClass(unref($style).canvasCenterPill),
						"show-stop": "",
						onStop: unref(builderStore).abortStreaming
					}, null, 8, ["class", "onStop"])) : createCommentVNode("", true),
					(openBlock(), createBlock(Suspense, null, {
						default: withCtx(() => [!isCanvasReadOnly.value ? (openBlock(), createBlock(unref(LazyNodeCreation), {
							key: 0,
							"create-node-active": unref(nodeCreatorStore).isCreateNodeActive,
							"node-view-scale": viewportTransform.value.zoom,
							"focus-panel-active": unref(focusPanelStore).focusPanelActive,
							onToggleNodeCreator,
							onAddNodes: onAddNodesAndConnections,
							onClose: onNodeCreatorClose
						}, null, 8, [
							"create-node-active",
							"node-view-scale",
							"focus-panel-active"
						])) : createCommentVNode("", true)]),
						_: 1
					})),
					(openBlock(), createBlock(Suspense, null, {
						default: withCtx(() => [!isNDVV2.value ? (openBlock(), createBlock(unref(LazyNodeDetailsView), {
							key: 0,
							"workflow-object": unref(editableWorkflowObject),
							"read-only": isCanvasReadOnly.value,
							"is-production-execution-preview": isProductionExecutionPreview.value,
							renaming: false,
							onValueChanged: _cache[2] || (_cache[2] = ($event) => onRenameNode($event.value)),
							onStopExecution,
							onSwitchSelectedNode: onSwitchActiveNode,
							onOpenConnectionNodeCreator: onOpenSelectiveNodeCreator
						}, null, 8, [
							"workflow-object",
							"read-only",
							"is-production-execution-preview"
						])) : createCommentVNode("", true)]),
						_: 1
					})),
					(openBlock(), createBlock(Suspense, null, {
						default: withCtx(() => [isNDVV2.value ? (openBlock(), createBlock(unref(LazyNodeDetailsViewV2), {
							key: 0,
							"workflow-object": unref(editableWorkflowObject),
							"read-only": isCanvasReadOnly.value,
							"is-production-execution-preview": isProductionExecutionPreview.value,
							onRenameNode,
							onStopExecution,
							onSwitchSelectedNode: onSwitchActiveNode,
							onOpenConnectionNodeCreator: onOpenSelectiveNodeCreator
						}, null, 8, [
							"workflow-object",
							"read-only",
							"is-production-execution-preview"
						])) : createCommentVNode("", true)]),
						_: 1
					}))
				]),
				_: 1
			}, 8, [
				"id",
				"workflow",
				"workflow-object",
				"fallback-nodes",
				"show-fallback-nodes",
				"event-bus",
				"read-only",
				"executing",
				"key-bindings",
				"suppress-interaction",
				"hide-controls",
				"onUpdate:logs:inputOpen",
				"onUpdate:logs:outputOpen",
				"onUpdate:hasRangeSelection"
			])) : createCommentVNode("", true), !isLoading.value && (unref(experimentalNdvStore).isNdvInFocusPanelEnabled ? !isCanvasReadOnly.value : true) ? (openBlock(), createBlock(FocusSidebar_default, {
				key: 1,
				"is-canvas-read-only": isCanvasReadOnly.value,
				onContextMenuAction
			}, null, 8, ["is-canvas-read-only"])) : createCommentVNode("", true)], 2);
		};
	}
});
var NodeView_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_1uyi2_125",
	executionButtons: "_executionButtons_1uyi2_130",
	chatButton: "_chatButton_1uyi2_148",
	setupCredentialsButtonWrapper: "_setupCredentialsButtonWrapper_1uyi2_152",
	readOnlyEnvironmentNotification: "_readOnlyEnvironmentNotification_1uyi2_158",
	canvasCenterPill: "_canvasCenterPill_1uyi2_165"
};
var NodeView_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NodeView_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NodeView_vue_vue_type_style_index_0_lang_module_default }]]);
export { NodeView_default as default };
