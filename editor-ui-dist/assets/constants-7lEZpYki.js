import { a as __toCommonJS, n as __esmMin, o as __toESM, r as __export, t as __commonJSMin } from "./chunk-6z4oVpB-.js";
import { En as init_dist, Tn as global } from "./vue.runtime.esm-bundler-DDuXT-9r.js";
import { a as require__getNative, c as require_isObject, d as require__Symbol, f as require__root, i as require_eq, l as require_isObjectLike, m as require_isArray, n as require__Map, o as require__toSource, t as require__MapCache, u as require__baseGetTag } from "./_MapCache-CMopfp37.js";
import { a as require__toKey, f as require_lib$1, i as require__baseGet, o as require__castPath, r as require_get, s as require_toString, u as require__isKey } from "./truncate-D09te2fm.js";
import { D as process$1, E as init_dist$1, T as require___vite_browser_external, a as require_callBound$1, b as require_gopd, c as require_has_property_descriptors, d as require_hasown, f as require_get_proto, g as require_function_bind, h as require_functionApply, i as init_dist$2, l as require_define_data_property, m as require_actualApply, n as init_empty, p as require_call_bind_apply_helpers, r as Buffer, s as require_set_function_length, t as empty_exports, u as require_get_intrinsic, v as require_shams$1, x as require_type, y as require_es_define_property } from "./empty-BuGRxzl4.js";
import { A as require__Uint8Array, C as require_isTypedArray, D as require__isIndex, E as require_isLength, O as require_isBuffer, S as require__arrayLikeKeys, T as require__baseUnary, _ as require__baseFor, b as require__overArg, c as require__copyObject, d as require__initCloneObject, f as require__getPrototype, g as require__cloneBuffer, h as require__cloneArrayBuffer, j as require__Stack, k as require_isArguments$1, l as require__assignValue, m as require__cloneTypedArray, o as require_identity, p as require__copyArray, s as require_keysIn, t as require_merge, v as require__baseAssignValue, w as require__nodeUtil, x as require__isPrototype, y as require_isArrayLike } from "./merge-9-BpYlRV.js";
var require_isArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toStr$5 = Object.prototype.toString;
	module.exports = function isArguments$1(value) {
		var str = toStr$5.call(value);
		var isArgs$2 = str === "[object Arguments]";
		if (!isArgs$2) isArgs$2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$5.call(value.callee) === "[object Function]";
		return isArgs$2;
	};
}));
var require_implementation$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var keysShim$1;
	if (!Object.keys) {
		var has$1 = Object.prototype.hasOwnProperty;
		var toStr$4 = Object.prototype.toString;
		var isArgs$1 = require_isArguments();
		var isEnumerable = Object.prototype.propertyIsEnumerable;
		var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
		var hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
		var dontEnums = [
			"toString",
			"toLocaleString",
			"valueOf",
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"constructor"
		];
		var equalsConstructorPrototype = function(o$1) {
			var ctor = o$1.constructor;
			return ctor && ctor.prototype === o$1;
		};
		var excludedKeys = {
			$applicationCache: true,
			$console: true,
			$external: true,
			$frame: true,
			$frameElement: true,
			$frames: true,
			$innerHeight: true,
			$innerWidth: true,
			$onmozfullscreenchange: true,
			$onmozfullscreenerror: true,
			$outerHeight: true,
			$outerWidth: true,
			$pageXOffset: true,
			$pageYOffset: true,
			$parent: true,
			$scrollLeft: true,
			$scrollTop: true,
			$scrollX: true,
			$scrollY: true,
			$self: true,
			$webkitIndexedDB: true,
			$webkitStorageInfo: true,
			$window: true
		};
		var hasAutomationEqualityBug = function() {
			if (typeof window === "undefined") return false;
			for (var k$1 in window) try {
				if (!excludedKeys["$" + k$1] && has$1.call(window, k$1) && window[k$1] !== null && typeof window[k$1] === "object") try {
					equalsConstructorPrototype(window[k$1]);
				} catch (e$1) {
					return true;
				}
			} catch (e$1) {
				return true;
			}
			return false;
		}();
		var equalsConstructorPrototypeIfNotBuggy = function(o$1) {
			if (typeof window === "undefined" || !hasAutomationEqualityBug) return equalsConstructorPrototype(o$1);
			try {
				return equalsConstructorPrototype(o$1);
			} catch (e$1) {
				return false;
			}
		};
		keysShim$1 = function keys$9(object) {
			var isObject$8 = object !== null && typeof object === "object";
			var isFunction$2 = toStr$4.call(object) === "[object Function]";
			var isArguments$1 = isArgs$1(object);
			var isString$4 = isObject$8 && toStr$4.call(object) === "[object String]";
			var theKeys = [];
			if (!isObject$8 && !isFunction$2 && !isArguments$1) throw new TypeError("Object.keys called on a non-object");
			var skipProto = hasProtoEnumBug && isFunction$2;
			if (isString$4 && object.length > 0 && !has$1.call(object, 0)) for (var i$2 = 0; i$2 < object.length; ++i$2) theKeys.push(String(i$2));
			if (isArguments$1 && object.length > 0) for (var j$1 = 0; j$1 < object.length; ++j$1) theKeys.push(String(j$1));
			else for (var name in object) if (!(skipProto && name === "prototype") && has$1.call(object, name)) theKeys.push(String(name));
			if (hasDontEnumBug) {
				var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
				for (var k$1 = 0; k$1 < dontEnums.length; ++k$1) if (!(skipConstructor && dontEnums[k$1] === "constructor") && has$1.call(object, dontEnums[k$1])) theKeys.push(dontEnums[k$1]);
			}
			return theKeys;
		};
	}
	module.exports = keysShim$1;
}));
var require_object_keys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var slice = Array.prototype.slice;
	var isArgs = require_isArguments();
	var origKeys = Object.keys;
	var keysShim = origKeys ? function keys$9(o$1) {
		return origKeys(o$1);
	} : require_implementation$3();
	var originalKeys = Object.keys;
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			if (!function() {
				var args = Object.keys(arguments);
				return args && args.length === arguments.length;
			}(1, 2)) Object.keys = function keys$9(object) {
				if (isArgs(object)) return originalKeys(slice.call(object));
				return originalKeys(object);
			};
		} else Object.keys = keysShim;
		return Object.keys || keysShim;
	};
	module.exports = keysShim;
}));
var require_define_properties = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var keys$8 = require_object_keys();
	var hasSymbols$2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
	var toStr$3 = Object.prototype.toString;
	var concat$1 = Array.prototype.concat;
	var defineDataProperty = require_define_data_property();
	var isFunction$1 = function(fn$1) {
		return typeof fn$1 === "function" && toStr$3.call(fn$1) === "[object Function]";
	};
	var supportsDescriptors = require_has_property_descriptors()();
	var defineProperty = function(object, name, value, predicate) {
		if (name in object) {
			if (predicate === true) {
				if (object[name] === value) return;
			} else if (!isFunction$1(predicate) || !predicate()) return;
		}
		if (supportsDescriptors) defineDataProperty(object, name, value, true);
		else defineDataProperty(object, name, value);
	};
	var defineProperties = function(object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys$8(map);
		if (hasSymbols$2) props = concat$1.call(props, Object.getOwnPropertySymbols(map));
		for (var i$2 = 0; i$2 < props.length; i$2 += 1) defineProperty(object, props[i$2], map[props[i$2]], predicates[props[i$2]]);
	};
	defineProperties.supportsDescriptors = !!supportsDescriptors;
	module.exports = defineProperties;
}));
var require_is_callable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fnToStr$1 = Function.prototype.toString;
	var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") try {
		badArrayLike = Object.defineProperty({}, "length", { get: function() {
			throw isCallableMarker;
		} });
		isCallableMarker = {};
		reflectApply(function() {
			throw 42;
		}, null, badArrayLike);
	} catch (_$1) {
		if (_$1 !== isCallableMarker) reflectApply = null;
	}
	else reflectApply = null;
	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
		try {
			var fnStr = fnToStr$1.call(value);
			return constructorRegex.test(fnStr);
		} catch (e$1) {
			return false;
		}
	};
	var tryFunctionObject = function tryFunctionToStr(value) {
		try {
			if (isES6ClassFn(value)) return false;
			fnToStr$1.call(value);
			return true;
		} catch (e$1) {
			return false;
		}
	};
	var toStr$2 = Object.prototype.toString;
	var objectClass = "[object Object]";
	var fnClass = "[object Function]";
	var genClass = "[object GeneratorFunction]";
	var ddaClass = "[object HTMLAllCollection]";
	var ddaClass2 = "[object HTML document.all class]";
	var ddaClass3 = "[object HTMLCollection]";
	var hasToStringTag$4 = typeof Symbol === "function" && !!Symbol.toStringTag;
	var isIE68 = !(0 in [,]);
	var isDDA = function isDocumentDotAll() {
		return false;
	};
	if (typeof document === "object") {
		var all = document.all;
		if (toStr$2.call(all) === toStr$2.call(document.all)) isDDA = function isDocumentDotAll(value) {
			if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) try {
				var str = toStr$2.call(value);
				return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
			} catch (e$1) {}
			return false;
		};
	}
	module.exports = reflectApply ? function isCallable$1(value) {
		if (isDDA(value)) return true;
		if (!value) return false;
		if (typeof value !== "function" && typeof value !== "object") return false;
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e$1) {
			if (e$1 !== isCallableMarker) return false;
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	} : function isCallable$1(value) {
		if (isDDA(value)) return true;
		if (!value) return false;
		if (typeof value !== "function" && typeof value !== "object") return false;
		if (hasToStringTag$4) return tryFunctionObject(value);
		if (isES6ClassFn(value)) return false;
		var strClass = toStr$2.call(value);
		if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) return false;
		return tryFunctionObject(value);
	};
}));
var require_call_bound = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic$1 = require_get_intrinsic();
	var callBindBasic$1 = require_call_bind_apply_helpers();
	var $indexOf$2 = callBindBasic$1([GetIntrinsic$1("%String.prototype.indexOf%")]);
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic$1(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf$2(name, ".prototype.") > -1) return callBindBasic$1([intrinsic]);
		return intrinsic;
	};
}));
var require_shams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasSymbols$1 = require_shams$1();
	module.exports = function hasToStringTagShams() {
		return hasSymbols$1() && !!Symbol.toStringTag;
	};
}));
var require_is_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBound$4 = require_call_bound();
	var hasToStringTag$3 = require_shams()();
	var hasOwn$11 = require_hasown();
	var gOPD$1 = require_gopd();
	var fn;
	if (hasToStringTag$3) {
		var $exec$1 = callBound$4("RegExp.prototype.exec");
		var isRegexMarker = {};
		var throwRegexMarker = function() {
			throw isRegexMarker;
		};
		var badStringifier = {
			toString: throwRegexMarker,
			valueOf: throwRegexMarker
		};
		if (typeof Symbol.toPrimitive === "symbol") badStringifier[Symbol.toPrimitive] = throwRegexMarker;
		fn = function isRegex$1(value) {
			if (!value || typeof value !== "object") return false;
			var descriptor = gOPD$1(value, "lastIndex");
			if (!(descriptor && hasOwn$11(descriptor, "value"))) return false;
			try {
				$exec$1(value, badStringifier);
			} catch (e$1) {
				return e$1 === isRegexMarker;
			}
		};
	} else {
		var $toString$2 = callBound$4("Object.prototype.toString");
		var regexClass = "[object RegExp]";
		fn = function isRegex$1(value) {
			if (!value || typeof value !== "object" && typeof value !== "function") return false;
			return $toString$2(value) === regexClass;
		};
	}
	module.exports = fn;
}));
var require_safe_regex_test = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBound$3 = require_call_bound();
	var isRegex = require_is_regex();
	var $exec = callBound$3("RegExp.prototype.exec");
	var $TypeError = require_type();
	module.exports = function regexTester(regex) {
		if (!isRegex(regex)) throw new $TypeError("`regex` must be a RegExp");
		return function test(s$2) {
			return $exec(regex, s$2) !== null;
		};
	};
}));
var require_applyBind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bind = require_function_bind();
	var $apply = require_functionApply();
	var actualApply = require_actualApply();
	module.exports = function applyBind$1() {
		return actualApply(bind, $apply, arguments);
	};
}));
var require_call_bind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var setFunctionLength = require_set_function_length();
	var $defineProperty = require_es_define_property();
	var callBindBasic = require_call_bind_apply_helpers();
	var applyBind = require_applyBind();
	module.exports = function callBind$4(originalFunction) {
		var func = callBindBasic(arguments);
		var adjustedLength = originalFunction.length - (arguments.length - 1);
		return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
	};
	if ($defineProperty) $defineProperty(module.exports, "apply", { value: applyBind });
	else module.exports.apply = applyBind;
}));
var require_callBound = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBind$3 = require_call_bind();
	var $indexOf$1 = callBind$3(GetIntrinsic("String.prototype.indexOf"));
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.") > -1) return callBind$3(intrinsic);
		return intrinsic;
	};
}));
var noOp = () => {};
let error = noOp;
let warn = noOp;
var require__setCacheAdd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	function setCacheAdd$1(value) {
		this.__data__.set(value, HASH_UNDEFINED);
		return this;
	}
	module.exports = setCacheAdd$1;
}));
var require__setCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setCacheHas$1(value) {
		return this.__data__.has(value);
	}
	module.exports = setCacheHas$1;
}));
var require__SetCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache = require__MapCache(), setCacheAdd = require__setCacheAdd(), setCacheHas = require__setCacheHas();
	function SetCache$2(values$1) {
		var index = -1, length$1 = values$1 == null ? 0 : values$1.length;
		this.__data__ = new MapCache();
		while (++index < length$1) this.add(values$1[index]);
	}
	SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
	SetCache$2.prototype.has = setCacheHas;
	module.exports = SetCache$2;
}));
var require__arraySome = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arraySome$1(array, predicate) {
		var index = -1, length$1 = array == null ? 0 : array.length;
		while (++index < length$1) if (predicate(array[index], index, array)) return true;
		return false;
	}
	module.exports = arraySome$1;
}));
var require__cacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function cacheHas$2(cache$1, key) {
		return cache$1.has(key);
	}
	module.exports = cacheHas$2;
}));
var require__equalArrays = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache$1 = require__SetCache(), arraySome = require__arraySome(), cacheHas$1 = require__cacheHas();
	var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
		if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
		var arrStacked = stack.get(array);
		var othStacked = stack.get(other);
		if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
		var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
		stack.set(array, other);
		stack.set(other, array);
		while (++index < arrLength) {
			var arrValue = array[index], othValue = other[index];
			if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
			if (compared !== void 0) {
				if (compared) continue;
				result = false;
				break;
			}
			if (seen) {
				if (!arraySome(other, function(othValue$1, othIndex) {
					if (!cacheHas$1(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
				})) {
					result = false;
					break;
				}
			} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
				result = false;
				break;
			}
		}
		stack["delete"](array);
		stack["delete"](other);
		return result;
	}
	module.exports = equalArrays$2;
}));
var require__mapToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function mapToArray$1(map) {
		var index = -1, result = Array(map.size);
		map.forEach(function(value, key) {
			result[++index] = [key, value];
		});
		return result;
	}
	module.exports = mapToArray$1;
}));
var require__setToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setToArray$3(set) {
		var index = -1, result = Array(set.size);
		set.forEach(function(value) {
			result[++index] = value;
		});
		return result;
	}
	module.exports = setToArray$3;
}));
var require__equalByTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$2 = require__Symbol(), Uint8Array$1 = require__Uint8Array(), eq = require_eq(), equalArrays$1 = require__equalArrays(), mapToArray = require__mapToArray(), setToArray$2 = require__setToArray();
	var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
	var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
	var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]";
	var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
		switch (tag) {
			case dataViewTag$3:
				if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
				object = object.buffer;
				other = other.buffer;
			case arrayBufferTag$2:
				if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) return false;
				return true;
			case boolTag$2:
			case dateTag$2:
			case numberTag$2: return eq(+object, +other);
			case errorTag$1: return object.name == other.name && object.message == other.message;
			case regexpTag$2:
			case stringTag$2: return object == other + "";
			case mapTag$4: var convert = mapToArray;
			case setTag$4:
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
				convert || (convert = setToArray$2);
				if (object.size != other.size && !isPartial) return false;
				var stacked = stack.get(object);
				if (stacked) return stacked == other;
				bitmask |= COMPARE_UNORDERED_FLAG$2;
				stack.set(object, other);
				var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
				stack["delete"](object);
				return result;
			case symbolTag$2: if (symbolValueOf$1) return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
		}
		return false;
	}
	module.exports = equalByTag$1;
}));
var require__arrayPush = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayPush$2(array, values$1) {
		var index = -1, length$1 = values$1.length, offset$1 = array.length;
		while (++index < length$1) array[offset$1 + index] = values$1[index];
		return array;
	}
	module.exports = arrayPush$2;
}));
var require__baseGetAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush$1 = require__arrayPush(), isArray$10 = require_isArray();
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
		var result = keysFunc(object);
		return isArray$10(object) ? result : arrayPush$1(result, symbolsFunc(object));
	}
	module.exports = baseGetAllKeys$2;
}));
var require__arrayFilter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayFilter$1(array, predicate) {
		var index = -1, length$1 = array == null ? 0 : array.length, resIndex = 0, result = [];
		while (++index < length$1) {
			var value = array[index];
			if (predicate(value, index, array)) result[resIndex++] = value;
		}
		return result;
	}
	module.exports = arrayFilter$1;
}));
var require_stubArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubArray$2() {
		return [];
	}
	module.exports = stubArray$2;
}));
var require__getSymbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayFilter = require__arrayFilter(), stubArray$1 = require_stubArray();
	var propertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable;
	var nativeGetSymbols = Object.getOwnPropertySymbols;
	module.exports = !nativeGetSymbols ? stubArray$1 : function(object) {
		if (object == null) return [];
		object = Object(object);
		return arrayFilter(nativeGetSymbols(object), function(symbol) {
			return propertyIsEnumerable$1.call(object, symbol);
		});
	};
}));
var require__nativeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.keys, Object);
}));
var require__baseKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isPrototype = require__isPrototype(), nativeKeys = require__nativeKeys();
	var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
	function baseKeys$1(object) {
		if (!isPrototype(object)) return nativeKeys(object);
		var result = [];
		for (var key in Object(object)) if (hasOwnProperty$9.call(object, key) && key != "constructor") result.push(key);
		return result;
	}
	module.exports = baseKeys$1;
}));
var require_keys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayLikeKeys = require__arrayLikeKeys(), baseKeys = require__baseKeys(), isArrayLike = require_isArrayLike();
	function keys$7(object) {
		return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	module.exports = keys$7;
}));
var require__getAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetAllKeys$1 = require__baseGetAllKeys(), getSymbols$2 = require__getSymbols(), keys$6 = require_keys();
	function getAllKeys$2(object) {
		return baseGetAllKeys$1(object, keys$6, getSymbols$2);
	}
	module.exports = getAllKeys$2;
}));
var require__equalObjects = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getAllKeys$1 = require__getAllKeys();
	var COMPARE_PARTIAL_FLAG$3 = 1;
	var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object), objLength = objProps.length;
		if (objLength != getAllKeys$1(other).length && !isPartial) return false;
		var index = objLength;
		while (index--) {
			var key = objProps[index];
			if (!(isPartial ? key in other : hasOwnProperty$8.call(other, key))) return false;
		}
		var objStacked = stack.get(object);
		var othStacked = stack.get(other);
		if (objStacked && othStacked) return objStacked == other && othStacked == object;
		var result = true;
		stack.set(object, other);
		stack.set(other, object);
		var skipCtor = isPartial;
		while (++index < objLength) {
			key = objProps[index];
			var objValue = object[key], othValue = other[key];
			if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
			if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
				result = false;
				break;
			}
			skipCtor || (skipCtor = key == "constructor");
		}
		if (result && !skipCtor) {
			var objCtor = object.constructor, othCtor = other.constructor;
			if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
		}
		stack["delete"](object);
		stack["delete"](other);
		return result;
	}
	module.exports = equalObjects$1;
}));
var require__DataView = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "DataView");
}));
var require__Promise = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Promise");
}));
var require__Set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Set");
}));
var require__WeakMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "WeakMap");
}));
var require__getTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var DataView$1 = require__DataView(), Map$1 = require__Map(), Promise$1 = require__Promise(), Set$2 = require__Set(), WeakMap$1 = require__WeakMap(), baseGetTag = require__baseGetTag(), toSource = require__toSource();
	var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
	var dataViewTag$2 = "[object DataView]";
	var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
	var getTag$4 = baseGetTag;
	if (DataView$1 && getTag$4(new DataView$1(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$2 && getTag$4(new Set$2()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) getTag$4 = function(value) {
		var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
		if (ctorString) switch (ctorString) {
			case dataViewCtorString: return dataViewTag$2;
			case mapCtorString: return mapTag$3;
			case promiseCtorString: return promiseTag;
			case setCtorString: return setTag$3;
			case weakMapCtorString: return weakMapTag$1;
		}
		return result;
	};
	module.exports = getTag$4;
}));
var require__baseIsEqualDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack$2 = require__Stack(), equalArrays = require__equalArrays(), equalByTag = require__equalByTag(), equalObjects = require__equalObjects(), getTag$3 = require__getTag(), isArray$9 = require_isArray(), isBuffer$2 = require_isBuffer(), isTypedArray$1 = require_isTypedArray();
	var COMPARE_PARTIAL_FLAG$2 = 1;
	var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
	var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
		var objIsArr = isArray$9(object), othIsArr = isArray$9(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
		objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
		othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
		var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
		if (isSameTag && isBuffer$2(object)) {
			if (!isBuffer$2(other)) return false;
			objIsArr = true;
			objIsObj = false;
		}
		if (isSameTag && !objIsObj) {
			stack || (stack = new Stack$2());
			return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		}
		if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
			var objIsWrapped = objIsObj && hasOwnProperty$7.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$7.call(other, "__wrapped__");
			if (objIsWrapped || othIsWrapped) {
				var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
				stack || (stack = new Stack$2());
				return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
			}
		}
		if (!isSameTag) return false;
		stack || (stack = new Stack$2());
		return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	module.exports = baseIsEqualDeep$1;
}));
var require__baseIsEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqualDeep = require__baseIsEqualDeep(), isObjectLike$2 = require_isObjectLike();
	function baseIsEqual$3(value, other, bitmask, customizer, stack) {
		if (value === other) return true;
		if (value == null || other == null || !isObjectLike$2(value) && !isObjectLike$2(other)) return value !== value && other !== other;
		return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
	}
	module.exports = baseIsEqual$3;
}));
var require_isEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual$2 = require__baseIsEqual();
	function isEqual$3(value, other) {
		return baseIsEqual$2(value, other);
	}
	module.exports = isEqual$3;
}));
const DIGITS = "0123456789";
const UPPERCASE_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const ALPHABET = [
	DIGITS,
	UPPERCASE_LETTERS,
	UPPERCASE_LETTERS.toLowerCase()
].join("");
const WAIT_INDEFINITELY = /* @__PURE__ */ new Date("3000-01-01T00:00:00.000Z");
const CREDENTIAL_EMPTY_VALUE = "__n8n_EMPTY_VALUE_7b1af746-3729-4c60-9b9b-e08eb29e58da";
const STICKY_NODE_TYPE$1 = "n8n-nodes-base.stickyNote";
const HTTP_REQUEST_NODE_TYPE$1 = "n8n-nodes-base.httpRequest";
const WEBHOOK_NODE_TYPE$1 = "n8n-nodes-base.webhook";
const MANUAL_TRIGGER_NODE_TYPE$1 = "n8n-nodes-base.manualTrigger";
const EVALUATION_TRIGGER_NODE_TYPE = "n8n-nodes-base.evaluationTrigger";
const EVALUATION_NODE_TYPE = "n8n-nodes-base.evaluation";
const ERROR_TRIGGER_NODE_TYPE$1 = "n8n-nodes-base.errorTrigger";
const START_NODE_TYPE$1 = "n8n-nodes-base.start";
const EXECUTE_WORKFLOW_NODE_TYPE$1 = "n8n-nodes-base.executeWorkflow";
const EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE$1 = "n8n-nodes-base.executeWorkflowTrigger";
const CODE_NODE_TYPE$1 = "n8n-nodes-base.code";
const FUNCTION_NODE_TYPE = "n8n-nodes-base.function";
const FUNCTION_ITEM_NODE_TYPE = "n8n-nodes-base.functionItem";
const AI_TRANSFORM_NODE_TYPE$1 = "n8n-nodes-base.aiTransform";
const FORM_NODE_TYPE$1 = "n8n-nodes-base.form";
const FORM_TRIGGER_NODE_TYPE$1 = "n8n-nodes-base.formTrigger";
const CHAT_TRIGGER_NODE_TYPE$1 = "@n8n/n8n-nodes-langchain.chatTrigger";
const HTML_NODE_TYPE$1 = "n8n-nodes-base.html";
const MAILGUN_NODE_TYPE = "n8n-nodes-base.mailgun";
const STARTING_NODE_TYPES = [
	MANUAL_TRIGGER_NODE_TYPE$1,
	EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE$1,
	ERROR_TRIGGER_NODE_TYPE$1,
	START_NODE_TYPE$1,
	EVALUATION_TRIGGER_NODE_TYPE
];
const SCRIPTING_NODE_TYPES = [
	FUNCTION_NODE_TYPE,
	FUNCTION_ITEM_NODE_TYPE,
	CODE_NODE_TYPE$1,
	AI_TRANSFORM_NODE_TYPE$1
];
const ADD_FORM_NOTICE = "addFormPage";
const NODES_WITH_RENAMABLE_CONTENT = new Set([
	CODE_NODE_TYPE$1,
	FUNCTION_NODE_TYPE,
	FUNCTION_ITEM_NODE_TYPE,
	AI_TRANSFORM_NODE_TYPE$1
]);
const NODES_WITH_RENAMABLE_FORM_HTML_CONTENT = new Set([FORM_NODE_TYPE$1]);
const NODES_WITH_RENAMEABLE_TOPLEVEL_HTML_CONTENT = new Set([MAILGUN_NODE_TYPE, HTML_NODE_TYPE$1]);
const AGENT_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.agent";
const CHAIN_LLM_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.chainLlm";
const CODE_TOOL_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.toolCode";
const WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.toolWorkflow";
const LANGCHAIN_CUSTOM_TOOLS = [
	CODE_TOOL_LANGCHAIN_NODE_TYPE,
	WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE,
	"@n8n/n8n-nodes-langchain.toolHttpRequest"
];
const SEND_AND_WAIT_OPERATION = "sendAndWait";
const AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT = "codeGeneratedForPrompt";
const AI_TRANSFORM_JS_CODE = "jsCode";
const TRIMMED_TASK_DATA_CONNECTIONS_KEY = "__isTrimmedManualExecutionDataItem";
const OPEN_AI_API_CREDENTIAL_TYPE = "openAiApi";
const FROM_AI_AUTO_GENERATED_MARKER = "/*n8n-auto-generated-fromAI-override*/";
const PROJECT_ROOT = "0";
var require_callsites = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callsites$2 = () => {
		const _prepareStackTrace = Error.prepareStackTrace;
		Error.prepareStackTrace = (_$1, stack$1) => stack$1;
		const stack = (/* @__PURE__ */ new Error()).stack.slice(1);
		Error.prepareStackTrace = _prepareStackTrace;
		return stack;
	};
	module.exports = callsites$2;
	module.exports.default = callsites$2;
}));
var import_callsites$1 = /* @__PURE__ */ __toESM(require_callsites());
var ApplicationError = class extends Error {
	constructor(message, { level, tags = {}, extra,...rest } = {}) {
		super(message, rest);
		this.level = level ?? "error";
		this.tags = tags;
		this.extra = extra;
		try {
			const filePath = (0, import_callsites$1.default)()[2].getFileName() ?? "";
			const match$1 = /packages\/([^\/]+)\//.exec(filePath)?.[1];
			if (match$1) this.tags.packageName = match$1;
		} catch {}
	}
};
const NodeConnectionTypes = {
	AiAgent: "ai_agent",
	AiChain: "ai_chain",
	AiDocument: "ai_document",
	AiEmbedding: "ai_embedding",
	AiLanguageModel: "ai_languageModel",
	AiMemory: "ai_memory",
	AiOutputParser: "ai_outputParser",
	AiRetriever: "ai_retriever",
	AiReranker: "ai_reranker",
	AiTextSplitter: "ai_textSplitter",
	AiTool: "ai_tool",
	AiVectorStore: "ai_vectorStore",
	Main: "main"
};
const nodeConnectionTypes = Object.values(NodeConnectionTypes);
var LuxonError = class extends Error {};
var InvalidDateTimeError = class extends LuxonError {
	constructor(reason) {
		super(`Invalid DateTime: ${reason.toMessage()}`);
	}
};
var InvalidIntervalError = class extends LuxonError {
	constructor(reason) {
		super(`Invalid Interval: ${reason.toMessage()}`);
	}
};
var InvalidDurationError = class extends LuxonError {
	constructor(reason) {
		super(`Invalid Duration: ${reason.toMessage()}`);
	}
};
var ConflictingSpecificationError = class extends LuxonError {};
var InvalidUnitError = class extends LuxonError {
	constructor(unit) {
		super(`Invalid unit ${unit}`);
	}
};
var InvalidArgumentError = class extends LuxonError {};
var ZoneIsAbstractError = class extends LuxonError {
	constructor() {
		super("Zone is an abstract class");
	}
};
var n$5 = "numeric", s$1 = "short", l$1 = "long";
const DATE_SHORT = {
	year: n$5,
	month: n$5,
	day: n$5
};
const DATE_MED = {
	year: n$5,
	month: s$1,
	day: n$5
};
const DATE_MED_WITH_WEEKDAY = {
	year: n$5,
	month: s$1,
	day: n$5,
	weekday: s$1
};
const DATE_FULL = {
	year: n$5,
	month: l$1,
	day: n$5
};
const DATE_HUGE = {
	year: n$5,
	month: l$1,
	day: n$5,
	weekday: l$1
};
const TIME_SIMPLE = {
	hour: n$5,
	minute: n$5
};
const TIME_WITH_SECONDS = {
	hour: n$5,
	minute: n$5,
	second: n$5
};
const TIME_WITH_SHORT_OFFSET = {
	hour: n$5,
	minute: n$5,
	second: n$5,
	timeZoneName: s$1
};
const TIME_WITH_LONG_OFFSET = {
	hour: n$5,
	minute: n$5,
	second: n$5,
	timeZoneName: l$1
};
const TIME_24_SIMPLE = {
	hour: n$5,
	minute: n$5,
	hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
	hour: n$5,
	minute: n$5,
	second: n$5,
	hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
	hour: n$5,
	minute: n$5,
	second: n$5,
	hourCycle: "h23",
	timeZoneName: s$1
};
const TIME_24_WITH_LONG_OFFSET = {
	hour: n$5,
	minute: n$5,
	second: n$5,
	hourCycle: "h23",
	timeZoneName: l$1
};
const DATETIME_SHORT = {
	year: n$5,
	month: n$5,
	day: n$5,
	hour: n$5,
	minute: n$5
};
const DATETIME_SHORT_WITH_SECONDS = {
	year: n$5,
	month: n$5,
	day: n$5,
	hour: n$5,
	minute: n$5,
	second: n$5
};
const DATETIME_MED = {
	year: n$5,
	month: s$1,
	day: n$5,
	hour: n$5,
	minute: n$5
};
const DATETIME_MED_WITH_SECONDS = {
	year: n$5,
	month: s$1,
	day: n$5,
	hour: n$5,
	minute: n$5,
	second: n$5
};
const DATETIME_MED_WITH_WEEKDAY = {
	year: n$5,
	month: s$1,
	day: n$5,
	weekday: s$1,
	hour: n$5,
	minute: n$5
};
const DATETIME_FULL = {
	year: n$5,
	month: l$1,
	day: n$5,
	hour: n$5,
	minute: n$5,
	timeZoneName: s$1
};
const DATETIME_FULL_WITH_SECONDS = {
	year: n$5,
	month: l$1,
	day: n$5,
	hour: n$5,
	minute: n$5,
	second: n$5,
	timeZoneName: s$1
};
const DATETIME_HUGE = {
	year: n$5,
	month: l$1,
	day: n$5,
	weekday: l$1,
	hour: n$5,
	minute: n$5,
	timeZoneName: l$1
};
const DATETIME_HUGE_WITH_SECONDS = {
	year: n$5,
	month: l$1,
	day: n$5,
	weekday: l$1,
	hour: n$5,
	minute: n$5,
	second: n$5,
	timeZoneName: l$1
};
var Zone = class {
	get type() {
		throw new ZoneIsAbstractError();
	}
	get name() {
		throw new ZoneIsAbstractError();
	}
	get ianaName() {
		return this.name;
	}
	get isUniversal() {
		throw new ZoneIsAbstractError();
	}
	offsetName(ts, opts) {
		throw new ZoneIsAbstractError();
	}
	formatOffset(ts, format$2) {
		throw new ZoneIsAbstractError();
	}
	offset(ts) {
		throw new ZoneIsAbstractError();
	}
	equals(otherZone) {
		throw new ZoneIsAbstractError();
	}
	get isValid() {
		throw new ZoneIsAbstractError();
	}
};
var singleton$1 = null;
var SystemZone = class SystemZone extends Zone {
	static get instance() {
		if (singleton$1 === null) singleton$1 = new SystemZone();
		return singleton$1;
	}
	get type() {
		return "system";
	}
	get name() {
		return new Intl.DateTimeFormat().resolvedOptions().timeZone;
	}
	get isUniversal() {
		return false;
	}
	offsetName(ts, { format: format$2, locale }) {
		return parseZoneInfo(ts, format$2, locale);
	}
	formatOffset(ts, format$2) {
		return formatOffset(this.offset(ts), format$2);
	}
	offset(ts) {
		return -new Date(ts).getTimezoneOffset();
	}
	equals(otherZone) {
		return otherZone.type === "system";
	}
	get isValid() {
		return true;
	}
};
var dtfCache = {};
function makeDTF(zone) {
	if (!dtfCache[zone]) dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
		hour12: false,
		timeZone: zone,
		year: "numeric",
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit",
		era: "short"
	});
	return dtfCache[zone];
}
var typeToPos = {
	year: 0,
	month: 1,
	day: 2,
	era: 3,
	hour: 4,
	minute: 5,
	second: 6
};
function hackyOffset(dtf, date) {
	const formatted = dtf.format(date).replace(/\u200E/g, ""), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted);
	return [
		fYear,
		fMonth,
		fDay,
		fadOrBc,
		fHour,
		fMinute,
		fSecond
	];
}
function partsOffset(dtf, date) {
	const formatted = dtf.formatToParts(date);
	const filled = [];
	for (let i$2 = 0; i$2 < formatted.length; i$2++) {
		const { type, value } = formatted[i$2];
		const pos = typeToPos[type];
		if (type === "era") filled[pos] = value;
		else if (!isUndefined$1(pos)) filled[pos] = parseInt(value, 10);
	}
	return filled;
}
var ianaZoneCache = {};
var IANAZone = class IANAZone extends Zone {
	static create(name) {
		if (!ianaZoneCache[name]) ianaZoneCache[name] = new IANAZone(name);
		return ianaZoneCache[name];
	}
	static resetCache() {
		ianaZoneCache = {};
		dtfCache = {};
	}
	static isValidSpecifier(s$2) {
		return this.isValidZone(s$2);
	}
	static isValidZone(zone) {
		if (!zone) return false;
		try {
			new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
			return true;
		} catch (e$1) {
			return false;
		}
	}
	constructor(name) {
		super();
		this.zoneName = name;
		this.valid = IANAZone.isValidZone(name);
	}
	get type() {
		return "iana";
	}
	get name() {
		return this.zoneName;
	}
	get isUniversal() {
		return false;
	}
	offsetName(ts, { format: format$2, locale }) {
		return parseZoneInfo(ts, format$2, locale, this.name);
	}
	formatOffset(ts, format$2) {
		return formatOffset(this.offset(ts), format$2);
	}
	offset(ts) {
		const date = new Date(ts);
		if (isNaN(date)) return NaN;
		const dtf = makeDTF(this.name);
		let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
		if (adOrBc === "BC") year = -Math.abs(year) + 1;
		const asUTC = objToLocalTS({
			year,
			month,
			day,
			hour: hour === 24 ? 0 : hour,
			minute,
			second,
			millisecond: 0
		});
		let asTS = +date;
		const over = asTS % 1e3;
		asTS -= over >= 0 ? over : 1e3 + over;
		return (asUTC - asTS) / (60 * 1e3);
	}
	equals(otherZone) {
		return otherZone.type === "iana" && otherZone.name === this.name;
	}
	get isValid() {
		return this.valid;
	}
};
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
	const key = JSON.stringify([locString, opts]);
	let dtf = intlLFCache[key];
	if (!dtf) {
		dtf = new Intl.ListFormat(locString, opts);
		intlLFCache[key] = dtf;
	}
	return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
	const key = JSON.stringify([locString, opts]);
	let dtf = intlDTCache[key];
	if (!dtf) {
		dtf = new Intl.DateTimeFormat(locString, opts);
		intlDTCache[key] = dtf;
	}
	return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
	const key = JSON.stringify([locString, opts]);
	let inf = intlNumCache[key];
	if (!inf) {
		inf = new Intl.NumberFormat(locString, opts);
		intlNumCache[key] = inf;
	}
	return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
	const { base,...cacheKeyOpts } = opts;
	const key = JSON.stringify([locString, cacheKeyOpts]);
	let inf = intlRelCache[key];
	if (!inf) {
		inf = new Intl.RelativeTimeFormat(locString, opts);
		intlRelCache[key] = inf;
	}
	return inf;
}
var sysLocaleCache = null;
function systemLocale() {
	if (sysLocaleCache) return sysLocaleCache;
	else {
		sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
		return sysLocaleCache;
	}
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
	let data = weekInfoCache[locString];
	if (!data) {
		const locale = new Intl.Locale(locString);
		data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
		weekInfoCache[locString] = data;
	}
	return data;
}
function parseLocaleString(localeStr) {
	const xIndex = localeStr.indexOf("-x-");
	if (xIndex !== -1) localeStr = localeStr.substring(0, xIndex);
	const uIndex = localeStr.indexOf("-u-");
	if (uIndex === -1) return [localeStr];
	else {
		let options;
		let selectedStr;
		try {
			options = getCachedDTF(localeStr).resolvedOptions();
			selectedStr = localeStr;
		} catch (e$1) {
			const smaller = localeStr.substring(0, uIndex);
			options = getCachedDTF(smaller).resolvedOptions();
			selectedStr = smaller;
		}
		const { numberingSystem, calendar } = options;
		return [
			selectedStr,
			numberingSystem,
			calendar
		];
	}
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
	if (outputCalendar || numberingSystem) {
		if (!localeStr.includes("-u-")) localeStr += "-u";
		if (outputCalendar) localeStr += `-ca-${outputCalendar}`;
		if (numberingSystem) localeStr += `-nu-${numberingSystem}`;
		return localeStr;
	} else return localeStr;
}
function mapMonths(f$1) {
	const ms = [];
	for (let i$2 = 1; i$2 <= 12; i$2++) {
		const dt = DateTime.utc(2009, i$2, 1);
		ms.push(f$1(dt));
	}
	return ms;
}
function mapWeekdays(f$1) {
	const ms = [];
	for (let i$2 = 1; i$2 <= 7; i$2++) {
		const dt = DateTime.utc(2016, 11, 13 + i$2);
		ms.push(f$1(dt));
	}
	return ms;
}
function listStuff(loc, length$1, englishFn, intlFn) {
	const mode = loc.listingMode();
	if (mode === "error") return null;
	else if (mode === "en") return englishFn(length$1);
	else return intlFn(length$1);
}
function supportsFastNumbers(loc) {
	if (loc.numberingSystem && loc.numberingSystem !== "latn") return false;
	else return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
}
var PolyNumberFormatter = class {
	constructor(intl, forceSimple, opts) {
		this.padTo = opts.padTo || 0;
		this.floor = opts.floor || false;
		const { padTo, floor: floor$1,...otherOpts } = opts;
		if (!forceSimple || Object.keys(otherOpts).length > 0) {
			const intlOpts = {
				useGrouping: false,
				...opts
			};
			if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
			this.inf = getCachedINF(intl, intlOpts);
		}
	}
	format(i$2) {
		if (this.inf) {
			const fixed = this.floor ? Math.floor(i$2) : i$2;
			return this.inf.format(fixed);
		} else return padStart(this.floor ? Math.floor(i$2) : roundTo(i$2, 3), this.padTo);
	}
};
var PolyDateFormatter = class {
	constructor(dt, intl, opts) {
		this.opts = opts;
		this.originalZone = void 0;
		let z$1 = void 0;
		if (this.opts.timeZone) this.dt = dt;
		else if (dt.zone.type === "fixed") {
			const gmtOffset = -1 * (dt.offset / 60);
			const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
			if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
				z$1 = offsetZ;
				this.dt = dt;
			} else {
				z$1 = "UTC";
				this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
				this.originalZone = dt.zone;
			}
		} else if (dt.zone.type === "system") this.dt = dt;
		else if (dt.zone.type === "iana") {
			this.dt = dt;
			z$1 = dt.zone.name;
		} else {
			z$1 = "UTC";
			this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
			this.originalZone = dt.zone;
		}
		const intlOpts = { ...this.opts };
		intlOpts.timeZone = intlOpts.timeZone || z$1;
		this.dtf = getCachedDTF(intl, intlOpts);
	}
	format() {
		if (this.originalZone) return this.formatToParts().map(({ value }) => value).join("");
		return this.dtf.format(this.dt.toJSDate());
	}
	formatToParts() {
		const parts = this.dtf.formatToParts(this.dt.toJSDate());
		if (this.originalZone) return parts.map((part) => {
			if (part.type === "timeZoneName") {
				const offsetName = this.originalZone.offsetName(this.dt.ts, {
					locale: this.dt.locale,
					format: this.opts.timeZoneName
				});
				return {
					...part,
					value: offsetName
				};
			} else return part;
		});
		return parts;
	}
	resolvedOptions() {
		return this.dtf.resolvedOptions();
	}
};
var PolyRelFormatter = class {
	constructor(intl, isEnglish, opts) {
		this.opts = {
			style: "long",
			...opts
		};
		if (!isEnglish && hasRelative()) this.rtf = getCachedRTF(intl, opts);
	}
	format(count, unit) {
		if (this.rtf) return this.rtf.format(count, unit);
		else return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
	}
	formatToParts(count, unit) {
		if (this.rtf) return this.rtf.formatToParts(count, unit);
		else return [];
	}
};
var fallbackWeekSettings = {
	firstDay: 1,
	minimalDays: 4,
	weekend: [6, 7]
};
var Locale = class Locale {
	static fromOpts(opts) {
		return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
	}
	static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
		const specifiedLocale = locale || Settings.defaultLocale;
		return new Locale(specifiedLocale || (defaultToEN ? "en-US" : systemLocale()), numberingSystem || Settings.defaultNumberingSystem, outputCalendar || Settings.defaultOutputCalendar, validateWeekSettings(weekSettings) || Settings.defaultWeekSettings, specifiedLocale);
	}
	static resetCache() {
		sysLocaleCache = null;
		intlDTCache = {};
		intlNumCache = {};
		intlRelCache = {};
	}
	static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
		return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
	}
	constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
		const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
		this.locale = parsedLocale;
		this.numberingSystem = numbering || parsedNumberingSystem || null;
		this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
		this.weekSettings = weekSettings;
		this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
		this.weekdaysCache = {
			format: {},
			standalone: {}
		};
		this.monthsCache = {
			format: {},
			standalone: {}
		};
		this.meridiemCache = null;
		this.eraCache = {};
		this.specifiedLocale = specifiedLocale;
		this.fastNumbersCached = null;
	}
	get fastNumbers() {
		if (this.fastNumbersCached == null) this.fastNumbersCached = supportsFastNumbers(this);
		return this.fastNumbersCached;
	}
	listingMode() {
		const isActuallyEn = this.isEnglish();
		const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
		return isActuallyEn && hasNoWeirdness ? "en" : "intl";
	}
	clone(alts) {
		if (!alts || Object.getOwnPropertyNames(alts).length === 0) return this;
		else return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
	}
	redefaultToEN(alts = {}) {
		return this.clone({
			...alts,
			defaultToEN: true
		});
	}
	redefaultToSystem(alts = {}) {
		return this.clone({
			...alts,
			defaultToEN: false
		});
	}
	months(length$1, format$2 = false) {
		return listStuff(this, length$1, months$1, () => {
			const intl = format$2 ? {
				month: length$1,
				day: "numeric"
			} : { month: length$1 }, formatStr = format$2 ? "format" : "standalone";
			if (!this.monthsCache[formatStr][length$1]) this.monthsCache[formatStr][length$1] = mapMonths((dt) => this.extract(dt, intl, "month"));
			return this.monthsCache[formatStr][length$1];
		});
	}
	weekdays(length$1, format$2 = false) {
		return listStuff(this, length$1, weekdays, () => {
			const intl = format$2 ? {
				weekday: length$1,
				year: "numeric",
				month: "long",
				day: "numeric"
			} : { weekday: length$1 }, formatStr = format$2 ? "format" : "standalone";
			if (!this.weekdaysCache[formatStr][length$1]) this.weekdaysCache[formatStr][length$1] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
			return this.weekdaysCache[formatStr][length$1];
		});
	}
	meridiems() {
		return listStuff(this, void 0, () => meridiems, () => {
			if (!this.meridiemCache) {
				const intl = {
					hour: "numeric",
					hourCycle: "h12"
				};
				this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
			}
			return this.meridiemCache;
		});
	}
	eras(length$1) {
		return listStuff(this, length$1, eras, () => {
			const intl = { era: length$1 };
			if (!this.eraCache[length$1]) this.eraCache[length$1] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
			return this.eraCache[length$1];
		});
	}
	extract(dt, intlOpts, field) {
		const matching = this.dtFormatter(dt, intlOpts).formatToParts().find((m$1) => m$1.type.toLowerCase() === field);
		return matching ? matching.value : null;
	}
	numberFormatter(opts = {}) {
		return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
	}
	dtFormatter(dt, intlOpts = {}) {
		return new PolyDateFormatter(dt, this.intl, intlOpts);
	}
	relFormatter(opts = {}) {
		return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
	}
	listFormatter(opts = {}) {
		return getCachedLF(this.intl, opts);
	}
	isEnglish() {
		return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
	}
	getWeekSettings() {
		if (this.weekSettings) return this.weekSettings;
		else if (!hasLocaleWeekInfo()) return fallbackWeekSettings;
		else return getCachedWeekInfo(this.locale);
	}
	getStartOfWeek() {
		return this.getWeekSettings().firstDay;
	}
	getMinDaysInFirstWeek() {
		return this.getWeekSettings().minimalDays;
	}
	getWeekendDays() {
		return this.getWeekSettings().weekend;
	}
	equals(other) {
		return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
	}
};
var singleton = null;
var FixedOffsetZone = class FixedOffsetZone extends Zone {
	static get utcInstance() {
		if (singleton === null) singleton = new FixedOffsetZone(0);
		return singleton;
	}
	static instance(offset$1) {
		return offset$1 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset$1);
	}
	static parseSpecifier(s$2) {
		if (s$2) {
			const r$1 = s$2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
			if (r$1) return new FixedOffsetZone(signedOffset(r$1[1], r$1[2]));
		}
		return null;
	}
	constructor(offset$1) {
		super();
		this.fixed = offset$1;
	}
	get type() {
		return "fixed";
	}
	get name() {
		return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
	}
	get ianaName() {
		if (this.fixed === 0) return "Etc/UTC";
		else return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
	}
	offsetName() {
		return this.name;
	}
	formatOffset(ts, format$2) {
		return formatOffset(this.fixed, format$2);
	}
	get isUniversal() {
		return true;
	}
	offset() {
		return this.fixed;
	}
	equals(otherZone) {
		return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
	}
	get isValid() {
		return true;
	}
};
var InvalidZone = class extends Zone {
	constructor(zoneName) {
		super();
		this.zoneName = zoneName;
	}
	get type() {
		return "invalid";
	}
	get name() {
		return this.zoneName;
	}
	get isUniversal() {
		return false;
	}
	offsetName() {
		return null;
	}
	formatOffset() {
		return "";
	}
	offset() {
		return NaN;
	}
	equals() {
		return false;
	}
	get isValid() {
		return false;
	}
};
function normalizeZone(input, defaultZone$1) {
	if (isUndefined$1(input) || input === null) return defaultZone$1;
	else if (input instanceof Zone) return input;
	else if (isString$3(input)) {
		const lowered = input.toLowerCase();
		if (lowered === "default") return defaultZone$1;
		else if (lowered === "local" || lowered === "system") return SystemZone.instance;
		else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
		else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
	} else if (isNumber$2(input)) return FixedOffsetZone.instance(input);
	else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") return input;
	else return new InvalidZone(input);
}
var now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid, defaultWeekSettings = null;
var Settings = class {
	static get now() {
		return now;
	}
	static set now(n$6) {
		now = n$6;
	}
	static set defaultZone(zone) {
		defaultZone = zone;
	}
	static get defaultZone() {
		return normalizeZone(defaultZone, SystemZone.instance);
	}
	static get defaultLocale() {
		return defaultLocale;
	}
	static set defaultLocale(locale) {
		defaultLocale = locale;
	}
	static get defaultNumberingSystem() {
		return defaultNumberingSystem;
	}
	static set defaultNumberingSystem(numberingSystem) {
		defaultNumberingSystem = numberingSystem;
	}
	static get defaultOutputCalendar() {
		return defaultOutputCalendar;
	}
	static set defaultOutputCalendar(outputCalendar) {
		defaultOutputCalendar = outputCalendar;
	}
	static get defaultWeekSettings() {
		return defaultWeekSettings;
	}
	static set defaultWeekSettings(weekSettings) {
		defaultWeekSettings = validateWeekSettings(weekSettings);
	}
	static get twoDigitCutoffYear() {
		return twoDigitCutoffYear;
	}
	static set twoDigitCutoffYear(cutoffYear) {
		twoDigitCutoffYear = cutoffYear % 100;
	}
	static get throwOnInvalid() {
		return throwOnInvalid;
	}
	static set throwOnInvalid(t$1) {
		throwOnInvalid = t$1;
	}
	static resetCaches() {
		Locale.resetCache();
		IANAZone.resetCache();
	}
};
var Invalid = class {
	constructor(reason, explanation) {
		this.reason = reason;
		this.explanation = explanation;
	}
	toMessage() {
		if (this.explanation) return `${this.reason}: ${this.explanation}`;
		else return this.reason;
	}
};
var nonLeapLadder = [
	0,
	31,
	59,
	90,
	120,
	151,
	181,
	212,
	243,
	273,
	304,
	334
], leapLadder = [
	0,
	31,
	60,
	91,
	121,
	152,
	182,
	213,
	244,
	274,
	305,
	335
];
function unitOutOfRange(unit, value) {
	return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
	const d$1 = new Date(Date.UTC(year, month - 1, day));
	if (year < 100 && year >= 0) d$1.setUTCFullYear(d$1.getUTCFullYear() - 1900);
	const js = d$1.getUTCDay();
	return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
	return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
	const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i$2) => i$2 < ordinal), day = ordinal - table[month0];
	return {
		month: month0 + 1,
		day
	};
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
	return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
	const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
	let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
	if (weekNumber < 1) {
		weekYear = year - 1;
		weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
	} else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
		weekYear = year + 1;
		weekNumber = 1;
	} else weekYear = year;
	return {
		weekYear,
		weekNumber,
		weekday,
		...timeObject(gregObj)
	};
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
	const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
	let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
	if (ordinal < 1) {
		year = weekYear - 1;
		ordinal += daysInYear(year);
	} else if (ordinal > yearInDays) {
		year = weekYear + 1;
		ordinal -= daysInYear(weekYear);
	} else year = weekYear;
	const { month, day } = uncomputeOrdinal(year, ordinal);
	return {
		year,
		month,
		day,
		...timeObject(weekData)
	};
}
function gregorianToOrdinal(gregData) {
	const { year, month, day } = gregData;
	return {
		year,
		ordinal: computeOrdinal(year, month, day),
		...timeObject(gregData)
	};
}
function ordinalToGregorian(ordinalData) {
	const { year, ordinal } = ordinalData;
	const { month, day } = uncomputeOrdinal(year, ordinal);
	return {
		year,
		month,
		day,
		...timeObject(ordinalData)
	};
}
function usesLocalWeekValues(obj, loc) {
	if (!isUndefined$1(obj.localWeekday) || !isUndefined$1(obj.localWeekNumber) || !isUndefined$1(obj.localWeekYear)) {
		if (!isUndefined$1(obj.weekday) || !isUndefined$1(obj.weekNumber) || !isUndefined$1(obj.weekYear)) throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
		if (!isUndefined$1(obj.localWeekday)) obj.weekday = obj.localWeekday;
		if (!isUndefined$1(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
		if (!isUndefined$1(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
		delete obj.localWeekday;
		delete obj.localWeekNumber;
		delete obj.localWeekYear;
		return {
			minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
			startOfWeek: loc.getStartOfWeek()
		};
	} else return {
		minDaysInFirstWeek: 4,
		startOfWeek: 1
	};
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
	const validYear = isInteger$1(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
	if (!validYear) return unitOutOfRange("weekYear", obj.weekYear);
	else if (!validWeek) return unitOutOfRange("week", obj.weekNumber);
	else if (!validWeekday) return unitOutOfRange("weekday", obj.weekday);
	else return false;
}
function hasInvalidOrdinalData(obj) {
	const validYear = isInteger$1(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
	if (!validYear) return unitOutOfRange("year", obj.year);
	else if (!validOrdinal) return unitOutOfRange("ordinal", obj.ordinal);
	else return false;
}
function hasInvalidGregorianData(obj) {
	const validYear = isInteger$1(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
	if (!validYear) return unitOutOfRange("year", obj.year);
	else if (!validMonth) return unitOutOfRange("month", obj.month);
	else if (!validDay) return unitOutOfRange("day", obj.day);
	else return false;
}
function hasInvalidTimeData(obj) {
	const { hour, minute, second, millisecond } = obj;
	const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
	if (!validHour) return unitOutOfRange("hour", hour);
	else if (!validMinute) return unitOutOfRange("minute", minute);
	else if (!validSecond) return unitOutOfRange("second", second);
	else if (!validMillisecond) return unitOutOfRange("millisecond", millisecond);
	else return false;
}
function isUndefined$1(o$1) {
	return typeof o$1 === "undefined";
}
function isNumber$2(o$1) {
	return typeof o$1 === "number";
}
function isInteger$1(o$1) {
	return typeof o$1 === "number" && o$1 % 1 === 0;
}
function isString$3(o$1) {
	return typeof o$1 === "string";
}
function isDate$3(o$1) {
	return Object.prototype.toString.call(o$1) === "[object Date]";
}
function hasRelative() {
	try {
		return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
	} catch (e$1) {
		return false;
	}
}
function hasLocaleWeekInfo() {
	try {
		return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
	} catch (e$1) {
		return false;
	}
}
function maybeArray(thing) {
	return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare$1) {
	if (arr.length === 0) return;
	return arr.reduce((best, next) => {
		const pair = [by(next), next];
		if (!best) return pair;
		else if (compare$1(best[0], pair[0]) === best[0]) return best;
		else return pair;
	}, null)[1];
}
function pick(obj, keys$9) {
	return keys$9.reduce((a$1, k$1) => {
		a$1[k$1] = obj[k$1];
		return a$1;
	}, {});
}
function hasOwnProperty$6(obj, prop) {
	return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
	if (settings == null) return null;
	else if (typeof settings !== "object") throw new InvalidArgumentError("Week settings must be an object");
	else {
		if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v$3) => !integerBetween(v$3, 1, 7))) throw new InvalidArgumentError("Invalid week settings");
		return {
			firstDay: settings.firstDay,
			minimalDays: settings.minimalDays,
			weekend: Array.from(settings.weekend)
		};
	}
}
function integerBetween(thing, bottom, top) {
	return isInteger$1(thing) && thing >= bottom && thing <= top;
}
function floorMod(x$1, n$6) {
	return x$1 - n$6 * Math.floor(x$1 / n$6);
}
function padStart(input, n$6 = 2) {
	const isNeg = input < 0;
	let padded;
	if (isNeg) padded = "-" + ("" + -input).padStart(n$6, "0");
	else padded = ("" + input).padStart(n$6, "0");
	return padded;
}
function parseInteger(string) {
	if (isUndefined$1(string) || string === null || string === "") return;
	else return parseInt(string, 10);
}
function parseFloating(string) {
	if (isUndefined$1(string) || string === null || string === "") return;
	else return parseFloat(string);
}
function parseMillis(fraction) {
	if (isUndefined$1(fraction) || fraction === null || fraction === "") return;
	else {
		const f$1 = parseFloat("0." + fraction) * 1e3;
		return Math.floor(f$1);
	}
}
function roundTo(number, digits, towardZero = false) {
	const factor = 10 ** digits;
	return (towardZero ? Math.trunc : Math.round)(number * factor) / factor;
}
function isLeapYear(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
	return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
	const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
	if (modMonth === 2) return isLeapYear(modYear) ? 29 : 28;
	else return [
		31,
		null,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	][modMonth - 1];
}
function objToLocalTS(obj) {
	let d$1 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
	if (obj.year < 100 && obj.year >= 0) {
		d$1 = new Date(d$1);
		d$1.setUTCFullYear(obj.year, obj.month - 1, obj.day);
	}
	return +d$1;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
	return -isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek) + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
	const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
	const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
	return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
	if (year > 99) return year;
	else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
	const date = new Date(ts), intlOpts = {
		hourCycle: "h23",
		year: "numeric",
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit"
	};
	if (timeZone) intlOpts.timeZone = timeZone;
	const modified = {
		timeZoneName: offsetFormat,
		...intlOpts
	};
	const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m$1) => m$1.type.toLowerCase() === "timezonename");
	return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
	let offHour = parseInt(offHourStr, 10);
	if (Number.isNaN(offHour)) offHour = 0;
	const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
	return offHour * 60 + offMinSigned;
}
function asNumber(value) {
	const numericValue = Number(value);
	if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`);
	return numericValue;
}
function normalizeObject(obj, normalizer) {
	const normalized = {};
	for (const u$1 in obj) if (hasOwnProperty$6(obj, u$1)) {
		const v$3 = obj[u$1];
		if (v$3 === void 0 || v$3 === null) continue;
		normalized[normalizer(u$1)] = asNumber(v$3);
	}
	return normalized;
}
function formatOffset(offset$1, format$2) {
	const hours = Math.trunc(Math.abs(offset$1 / 60)), minutes = Math.trunc(Math.abs(offset$1 % 60)), sign = offset$1 >= 0 ? "+" : "-";
	switch (format$2) {
		case "short": return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
		case "narrow": return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
		case "techie": return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
		default: throw new RangeError(`Value format ${format$2} is out of range for property format`);
	}
}
function timeObject(obj) {
	return pick(obj, [
		"hour",
		"minute",
		"second",
		"millisecond"
	]);
}
const monthsLong = [
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December"
];
const monthsShort = [
	"Jan",
	"Feb",
	"Mar",
	"Apr",
	"May",
	"Jun",
	"Jul",
	"Aug",
	"Sep",
	"Oct",
	"Nov",
	"Dec"
];
const monthsNarrow = [
	"J",
	"F",
	"M",
	"A",
	"M",
	"J",
	"J",
	"A",
	"S",
	"O",
	"N",
	"D"
];
function months$1(length$1) {
	switch (length$1) {
		case "narrow": return [...monthsNarrow];
		case "short": return [...monthsShort];
		case "long": return [...monthsLong];
		case "numeric": return [
			"1",
			"2",
			"3",
			"4",
			"5",
			"6",
			"7",
			"8",
			"9",
			"10",
			"11",
			"12"
		];
		case "2-digit": return [
			"01",
			"02",
			"03",
			"04",
			"05",
			"06",
			"07",
			"08",
			"09",
			"10",
			"11",
			"12"
		];
		default: return null;
	}
}
const weekdaysLong = [
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
	"Saturday",
	"Sunday"
];
const weekdaysShort = [
	"Mon",
	"Tue",
	"Wed",
	"Thu",
	"Fri",
	"Sat",
	"Sun"
];
const weekdaysNarrow = [
	"M",
	"T",
	"W",
	"T",
	"F",
	"S",
	"S"
];
function weekdays(length$1) {
	switch (length$1) {
		case "narrow": return [...weekdaysNarrow];
		case "short": return [...weekdaysShort];
		case "long": return [...weekdaysLong];
		case "numeric": return [
			"1",
			"2",
			"3",
			"4",
			"5",
			"6",
			"7"
		];
		default: return null;
	}
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length$1) {
	switch (length$1) {
		case "narrow": return [...erasNarrow];
		case "short": return [...erasShort];
		case "long": return [...erasLong];
		default: return null;
	}
}
function meridiemForDateTime(dt) {
	return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length$1) {
	return weekdays(length$1)[dt.weekday - 1];
}
function monthForDateTime(dt, length$1) {
	return months$1(length$1)[dt.month - 1];
}
function eraForDateTime(dt, length$1) {
	return eras(length$1)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
	const units = {
		years: ["year", "yr."],
		quarters: ["quarter", "qtr."],
		months: ["month", "mo."],
		weeks: ["week", "wk."],
		days: [
			"day",
			"day",
			"days"
		],
		hours: ["hour", "hr."],
		minutes: ["minute", "min."],
		seconds: ["second", "sec."]
	};
	const lastable = [
		"hours",
		"minutes",
		"seconds"
	].indexOf(unit) === -1;
	if (numeric === "auto" && lastable) {
		const isDay = unit === "days";
		switch (count) {
			case 1: return isDay ? "tomorrow" : `next ${units[unit][0]}`;
			case -1: return isDay ? "yesterday" : `last ${units[unit][0]}`;
			case 0: return isDay ? "today" : `this ${units[unit][0]}`;
			default:
		}
	}
	const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
	return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
	let s$2 = "";
	for (const token of splits) if (token.literal) s$2 += token.val;
	else s$2 += tokenToString(token.val);
	return s$2;
}
var macroTokenToFormatOpts = {
	D: DATE_SHORT,
	DD: DATE_MED,
	DDD: DATE_FULL,
	DDDD: DATE_HUGE,
	t: TIME_SIMPLE,
	tt: TIME_WITH_SECONDS,
	ttt: TIME_WITH_SHORT_OFFSET,
	tttt: TIME_WITH_LONG_OFFSET,
	T: TIME_24_SIMPLE,
	TT: TIME_24_WITH_SECONDS,
	TTT: TIME_24_WITH_SHORT_OFFSET,
	TTTT: TIME_24_WITH_LONG_OFFSET,
	f: DATETIME_SHORT,
	ff: DATETIME_MED,
	fff: DATETIME_FULL,
	ffff: DATETIME_HUGE,
	F: DATETIME_SHORT_WITH_SECONDS,
	FF: DATETIME_MED_WITH_SECONDS,
	FFF: DATETIME_FULL_WITH_SECONDS,
	FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class Formatter {
	static create(locale, opts = {}) {
		return new Formatter(locale, opts);
	}
	static parseFormat(fmt) {
		let current = null, currentFull = "", bracketed = false;
		const splits = [];
		for (let i$2 = 0; i$2 < fmt.length; i$2++) {
			const c$1 = fmt.charAt(i$2);
			if (c$1 === "'") {
				if (currentFull.length > 0) splits.push({
					literal: bracketed || /^\s+$/.test(currentFull),
					val: currentFull
				});
				current = null;
				currentFull = "";
				bracketed = !bracketed;
			} else if (bracketed) currentFull += c$1;
			else if (c$1 === current) currentFull += c$1;
			else {
				if (currentFull.length > 0) splits.push({
					literal: /^\s+$/.test(currentFull),
					val: currentFull
				});
				currentFull = c$1;
				current = c$1;
			}
		}
		if (currentFull.length > 0) splits.push({
			literal: bracketed || /^\s+$/.test(currentFull),
			val: currentFull
		});
		return splits;
	}
	static macroTokenToFormatOpts(token) {
		return macroTokenToFormatOpts[token];
	}
	constructor(locale, formatOpts) {
		this.opts = formatOpts;
		this.loc = locale;
		this.systemLoc = null;
	}
	formatWithSystemDefault(dt, opts) {
		if (this.systemLoc === null) this.systemLoc = this.loc.redefaultToSystem();
		return this.systemLoc.dtFormatter(dt, {
			...this.opts,
			...opts
		}).format();
	}
	dtFormatter(dt, opts = {}) {
		return this.loc.dtFormatter(dt, {
			...this.opts,
			...opts
		});
	}
	formatDateTime(dt, opts) {
		return this.dtFormatter(dt, opts).format();
	}
	formatDateTimeParts(dt, opts) {
		return this.dtFormatter(dt, opts).formatToParts();
	}
	formatInterval(interval, opts) {
		return this.dtFormatter(interval.start, opts).dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
	}
	resolvedOptions(dt, opts) {
		return this.dtFormatter(dt, opts).resolvedOptions();
	}
	num(n$6, p$1 = 0) {
		if (this.opts.forceSimple) return padStart(n$6, p$1);
		const opts = { ...this.opts };
		if (p$1 > 0) opts.padTo = p$1;
		return this.loc.numberFormatter(opts).format(n$6);
	}
	formatDateTimeFromString(dt, fmt) {
		const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract$1) => this.loc.extract(dt, opts, extract$1), formatOffset$1 = (opts) => {
			if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) return "Z";
			return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
		}, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
			hour: "numeric",
			hourCycle: "h12"
		}, "dayperiod"), month = (length$1, standalone) => knownEnglish ? monthForDateTime(dt, length$1) : string(standalone ? { month: length$1 } : {
			month: length$1,
			day: "numeric"
		}, "month"), weekday = (length$1, standalone) => knownEnglish ? weekdayForDateTime(dt, length$1) : string(standalone ? { weekday: length$1 } : {
			weekday: length$1,
			month: "long",
			day: "numeric"
		}, "weekday"), maybeMacro = (token) => {
			const formatOpts = Formatter.macroTokenToFormatOpts(token);
			if (formatOpts) return this.formatWithSystemDefault(dt, formatOpts);
			else return token;
		}, era = (length$1) => knownEnglish ? eraForDateTime(dt, length$1) : string({ era: length$1 }, "era"), tokenToString = (token) => {
			switch (token) {
				case "S": return this.num(dt.millisecond);
				case "u":
				case "SSS": return this.num(dt.millisecond, 3);
				case "s": return this.num(dt.second);
				case "ss": return this.num(dt.second, 2);
				case "uu": return this.num(Math.floor(dt.millisecond / 10), 2);
				case "uuu": return this.num(Math.floor(dt.millisecond / 100));
				case "m": return this.num(dt.minute);
				case "mm": return this.num(dt.minute, 2);
				case "h": return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
				case "hh": return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
				case "H": return this.num(dt.hour);
				case "HH": return this.num(dt.hour, 2);
				case "Z": return formatOffset$1({
					format: "narrow",
					allowZ: this.opts.allowZ
				});
				case "ZZ": return formatOffset$1({
					format: "short",
					allowZ: this.opts.allowZ
				});
				case "ZZZ": return formatOffset$1({
					format: "techie",
					allowZ: this.opts.allowZ
				});
				case "ZZZZ": return dt.zone.offsetName(dt.ts, {
					format: "short",
					locale: this.loc.locale
				});
				case "ZZZZZ": return dt.zone.offsetName(dt.ts, {
					format: "long",
					locale: this.loc.locale
				});
				case "z": return dt.zoneName;
				case "a": return meridiem();
				case "d": return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
				case "dd": return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
				case "c": return this.num(dt.weekday);
				case "ccc": return weekday("short", true);
				case "cccc": return weekday("long", true);
				case "ccccc": return weekday("narrow", true);
				case "E": return this.num(dt.weekday);
				case "EEE": return weekday("short", false);
				case "EEEE": return weekday("long", false);
				case "EEEEE": return weekday("narrow", false);
				case "L": return useDateTimeFormatter ? string({
					month: "numeric",
					day: "numeric"
				}, "month") : this.num(dt.month);
				case "LL": return useDateTimeFormatter ? string({
					month: "2-digit",
					day: "numeric"
				}, "month") : this.num(dt.month, 2);
				case "LLL": return month("short", true);
				case "LLLL": return month("long", true);
				case "LLLLL": return month("narrow", true);
				case "M": return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
				case "MM": return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
				case "MMM": return month("short", false);
				case "MMMM": return month("long", false);
				case "MMMMM": return month("narrow", false);
				case "y": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
				case "yy": return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
				case "yyyy": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
				case "yyyyyy": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
				case "G": return era("short");
				case "GG": return era("long");
				case "GGGGG": return era("narrow");
				case "kk": return this.num(dt.weekYear.toString().slice(-2), 2);
				case "kkkk": return this.num(dt.weekYear, 4);
				case "W": return this.num(dt.weekNumber);
				case "WW": return this.num(dt.weekNumber, 2);
				case "n": return this.num(dt.localWeekNumber);
				case "nn": return this.num(dt.localWeekNumber, 2);
				case "ii": return this.num(dt.localWeekYear.toString().slice(-2), 2);
				case "iiii": return this.num(dt.localWeekYear, 4);
				case "o": return this.num(dt.ordinal);
				case "ooo": return this.num(dt.ordinal, 3);
				case "q": return this.num(dt.quarter);
				case "qq": return this.num(dt.quarter, 2);
				case "X": return this.num(Math.floor(dt.ts / 1e3));
				case "x": return this.num(dt.ts);
				default: return maybeMacro(token);
			}
		};
		return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
	}
	formatDurationFromString(dur, fmt) {
		const tokenToField = (token) => {
			switch (token[0]) {
				case "S": return "millisecond";
				case "s": return "second";
				case "m": return "minute";
				case "h": return "hour";
				case "d": return "day";
				case "w": return "week";
				case "M": return "month";
				case "y": return "year";
				default: return null;
			}
		}, tokenToString = (lildur) => (token) => {
			const mapped = tokenToField(token);
			if (mapped) return this.num(lildur.get(mapped), token.length);
			else return token;
		}, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []);
		return stringifyTokens(tokens, tokenToString(dur.shiftTo(...realTokens.map(tokenToField).filter((t$1) => t$1))));
	}
};
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
	const full = regexes.reduce((f$1, r$1) => f$1 + r$1.source, "");
	return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
	return (m$1) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
		const [val, zone, next] = ex(m$1, cursor);
		return [
			{
				...mergedVals,
				...val
			},
			zone || mergedZone,
			next
		];
	}, [
		{},
		null,
		1
	]).slice(0, 2);
}
function parse$6(s$2, ...patterns) {
	if (s$2 == null) return [null, null];
	for (const [regex, extractor] of patterns) {
		const m$1 = regex.exec(s$2);
		if (m$1) return extractor(m$1);
	}
	return [null, null];
}
function simpleParse(...keys$9) {
	return (match$1, cursor) => {
		const ret = {};
		let i$2;
		for (i$2 = 0; i$2 < keys$9.length; i$2++) ret[keys$9[i$2]] = parseInteger(match$1[cursor + i$2]);
		return [
			ret,
			null,
			cursor + i$2
		];
	};
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match$1, pos, fallback) {
	const m$1 = match$1[pos];
	return isUndefined$1(m$1) ? fallback : parseInteger(m$1);
}
function extractISOYmd(match$1, cursor) {
	return [
		{
			year: int(match$1, cursor),
			month: int(match$1, cursor + 1, 1),
			day: int(match$1, cursor + 2, 1)
		},
		null,
		cursor + 3
	];
}
function extractISOTime(match$1, cursor) {
	return [
		{
			hours: int(match$1, cursor, 0),
			minutes: int(match$1, cursor + 1, 0),
			seconds: int(match$1, cursor + 2, 0),
			milliseconds: parseMillis(match$1[cursor + 3])
		},
		null,
		cursor + 4
	];
}
function extractISOOffset(match$1, cursor) {
	const local = !match$1[cursor] && !match$1[cursor + 1], fullOffset = signedOffset(match$1[cursor + 1], match$1[cursor + 2]);
	return [
		{},
		local ? null : FixedOffsetZone.instance(fullOffset),
		cursor + 3
	];
}
function extractIANAZone(match$1, cursor) {
	return [
		{},
		match$1[cursor] ? IANAZone.create(match$1[cursor]) : null,
		cursor + 1
	];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match$1) {
	const [s$2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match$1;
	const hasNegativePrefix = s$2[0] === "-";
	const negativeSeconds = secondStr && secondStr[0] === "-";
	const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
	return [{
		years: maybeNegate(parseFloating(yearStr)),
		months: maybeNegate(parseFloating(monthStr)),
		weeks: maybeNegate(parseFloating(weekStr)),
		days: maybeNegate(parseFloating(dayStr)),
		hours: maybeNegate(parseFloating(hourStr)),
		minutes: maybeNegate(parseFloating(minuteStr)),
		seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
		milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
	}];
}
var obsOffsets = {
	GMT: 0,
	EDT: -240,
	EST: -300,
	CDT: -300,
	CST: -360,
	MDT: -360,
	MST: -420,
	PDT: -420,
	PST: -480
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	const result = {
		year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
		month: monthsShort.indexOf(monthStr) + 1,
		day: parseInteger(dayStr),
		hour: parseInteger(hourStr),
		minute: parseInteger(minuteStr)
	};
	if (secondStr) result.second = parseInteger(secondStr);
	if (weekdayStr) result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
	return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match$1) {
	const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match$1, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
	let offset$1;
	if (obsOffset) offset$1 = obsOffsets[obsOffset];
	else if (milOffset) offset$1 = 0;
	else offset$1 = signedOffset(offHourStr, offMinuteStr);
	return [result, new FixedOffsetZone(offset$1)];
}
function preprocessRFC2822(s$2) {
	return s$2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match$1) {
	const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match$1;
	return [fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr), FixedOffsetZone.utcInstance];
}
function extractASCII(match$1) {
	const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match$1;
	return [fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr), FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(s$2) {
	return parse$6(s$2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s$2) {
	return parse$6(preprocessRFC2822(s$2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s$2) {
	return parse$6(s$2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s$2) {
	return parse$6(s$2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s$2) {
	return parse$6(s$2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s$2) {
	return parse$6(s$2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}
var INVALID$3 = "Invalid Duration";
const lowOrderMatrix = {
	weeks: {
		days: 7,
		hours: 168,
		minutes: 10080,
		seconds: 10080 * 60,
		milliseconds: 10080 * 60 * 1e3
	},
	days: {
		hours: 24,
		minutes: 1440,
		seconds: 1440 * 60,
		milliseconds: 1440 * 60 * 1e3
	},
	hours: {
		minutes: 60,
		seconds: 3600,
		milliseconds: 3600 * 1e3
	},
	minutes: {
		seconds: 60,
		milliseconds: 60 * 1e3
	},
	seconds: { milliseconds: 1e3 }
};
const casualMatrix = {
	years: {
		quarters: 4,
		months: 12,
		weeks: 52,
		days: 365,
		hours: 365 * 24,
		minutes: 365 * 24 * 60,
		seconds: 365 * 24 * 60 * 60,
		milliseconds: 365 * 24 * 60 * 60 * 1e3
	},
	quarters: {
		months: 3,
		weeks: 13,
		days: 91,
		hours: 2184,
		minutes: 2184 * 60,
		seconds: 2184 * 60 * 60,
		milliseconds: 2184 * 60 * 60 * 1e3
	},
	months: {
		weeks: 4,
		days: 30,
		hours: 720,
		minutes: 720 * 60,
		seconds: 720 * 60 * 60,
		milliseconds: 720 * 60 * 60 * 1e3
	},
	...lowOrderMatrix
};
const daysInYearAccurate = 146097 / 400;
const daysInMonthAccurate = 146097 / 4800;
const accurateMatrix = {
	years: {
		quarters: 4,
		months: 12,
		weeks: daysInYearAccurate / 7,
		days: daysInYearAccurate,
		hours: daysInYearAccurate * 24,
		minutes: daysInYearAccurate * 24 * 60,
		seconds: daysInYearAccurate * 24 * 60 * 60,
		milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
	},
	quarters: {
		months: 3,
		weeks: daysInYearAccurate / 28,
		days: daysInYearAccurate / 4,
		hours: daysInYearAccurate * 24 / 4,
		minutes: daysInYearAccurate * 24 * 60 / 4,
		seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
		milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
	},
	months: {
		weeks: daysInMonthAccurate / 7,
		days: daysInMonthAccurate,
		hours: daysInMonthAccurate * 24,
		minutes: daysInMonthAccurate * 24 * 60,
		seconds: daysInMonthAccurate * 24 * 60 * 60,
		milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
	},
	...lowOrderMatrix
};
var orderedUnits$1 = [
	"years",
	"quarters",
	"months",
	"weeks",
	"days",
	"hours",
	"minutes",
	"seconds",
	"milliseconds"
];
var reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear = false) {
	return new Duration({
		values: clear ? alts.values : {
			...dur.values,
			...alts.values || {}
		},
		loc: dur.loc.clone(alts.loc),
		conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
		matrix: alts.matrix || dur.matrix
	});
}
function durationToMillis(matrix, vals) {
	let sum$1 = vals.milliseconds ?? 0;
	for (const unit of reverseUnits.slice(1)) if (vals[unit]) sum$1 += vals[unit] * matrix[unit]["milliseconds"];
	return sum$1;
}
function normalizeValues(matrix, vals) {
	const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
	orderedUnits$1.reduceRight((previous, current) => {
		if (!isUndefined$1(vals[current])) {
			if (previous) {
				const previousVal = vals[previous] * factor;
				const conv = matrix[current][previous];
				const rollUp = Math.floor(previousVal / conv);
				vals[current] += rollUp * factor;
				vals[previous] -= rollUp * conv * factor;
			}
			return current;
		} else return previous;
	}, null);
	orderedUnits$1.reduce((previous, current) => {
		if (!isUndefined$1(vals[current])) {
			if (previous) {
				const fraction = vals[previous] % 1;
				vals[previous] -= fraction;
				vals[current] += fraction * matrix[previous][current];
			}
			return current;
		} else return previous;
	}, null);
}
function removeZeroes(vals) {
	const newVals = {};
	for (const [key, value] of Object.entries(vals)) if (value !== 0) newVals[key] = value;
	return newVals;
}
var Duration = class Duration {
	constructor(config$1) {
		const accurate = config$1.conversionAccuracy === "longterm" || false;
		let matrix = accurate ? accurateMatrix : casualMatrix;
		if (config$1.matrix) matrix = config$1.matrix;
		this.values = config$1.values;
		this.loc = config$1.loc || Locale.create();
		this.conversionAccuracy = accurate ? "longterm" : "casual";
		this.invalid = config$1.invalid || null;
		this.matrix = matrix;
		this.isLuxonDuration = true;
	}
	static fromMillis(count, opts) {
		return Duration.fromObject({ milliseconds: count }, opts);
	}
	static fromObject(obj, opts = {}) {
		if (obj == null || typeof obj !== "object") throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
		return new Duration({
			values: normalizeObject(obj, Duration.normalizeUnit),
			loc: Locale.fromObject(opts),
			conversionAccuracy: opts.conversionAccuracy,
			matrix: opts.matrix
		});
	}
	static fromDurationLike(durationLike) {
		if (isNumber$2(durationLike)) return Duration.fromMillis(durationLike);
		else if (Duration.isDuration(durationLike)) return durationLike;
		else if (typeof durationLike === "object") return Duration.fromObject(durationLike);
		else throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
	}
	static fromISO(text, opts) {
		const [parsed] = parseISODuration(text);
		if (parsed) return Duration.fromObject(parsed, opts);
		else return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
	}
	static fromISOTime(text, opts) {
		const [parsed] = parseISOTimeOnly(text);
		if (parsed) return Duration.fromObject(parsed, opts);
		else return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
	}
	static invalid(reason, explanation = null) {
		if (!reason) throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
		const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
		if (Settings.throwOnInvalid) throw new InvalidDurationError(invalid);
		else return new Duration({ invalid });
	}
	static normalizeUnit(unit) {
		const normalized = {
			year: "years",
			years: "years",
			quarter: "quarters",
			quarters: "quarters",
			month: "months",
			months: "months",
			week: "weeks",
			weeks: "weeks",
			day: "days",
			days: "days",
			hour: "hours",
			hours: "hours",
			minute: "minutes",
			minutes: "minutes",
			second: "seconds",
			seconds: "seconds",
			millisecond: "milliseconds",
			milliseconds: "milliseconds"
		}[unit ? unit.toLowerCase() : unit];
		if (!normalized) throw new InvalidUnitError(unit);
		return normalized;
	}
	static isDuration(o$1) {
		return o$1 && o$1.isLuxonDuration || false;
	}
	get locale() {
		return this.isValid ? this.loc.locale : null;
	}
	get numberingSystem() {
		return this.isValid ? this.loc.numberingSystem : null;
	}
	toFormat(fmt, opts = {}) {
		const fmtOpts = {
			...opts,
			floor: opts.round !== false && opts.floor !== false
		};
		return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$3;
	}
	toHuman(opts = {}) {
		if (!this.isValid) return INVALID$3;
		const l$2 = orderedUnits$1.map((unit) => {
			const val = this.values[unit];
			if (isUndefined$1(val)) return null;
			return this.loc.numberFormatter({
				style: "unit",
				unitDisplay: "long",
				...opts,
				unit: unit.slice(0, -1)
			}).format(val);
		}).filter((n$6) => n$6);
		return this.loc.listFormatter({
			type: "conjunction",
			style: opts.listStyle || "narrow",
			...opts
		}).format(l$2);
	}
	toObject() {
		if (!this.isValid) return {};
		return { ...this.values };
	}
	toISO() {
		if (!this.isValid) return null;
		let s$2 = "P";
		if (this.years !== 0) s$2 += this.years + "Y";
		if (this.months !== 0 || this.quarters !== 0) s$2 += this.months + this.quarters * 3 + "M";
		if (this.weeks !== 0) s$2 += this.weeks + "W";
		if (this.days !== 0) s$2 += this.days + "D";
		if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s$2 += "T";
		if (this.hours !== 0) s$2 += this.hours + "H";
		if (this.minutes !== 0) s$2 += this.minutes + "M";
		if (this.seconds !== 0 || this.milliseconds !== 0) s$2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
		if (s$2 === "P") s$2 += "T0S";
		return s$2;
	}
	toISOTime(opts = {}) {
		if (!this.isValid) return null;
		const millis = this.toMillis();
		if (millis < 0 || millis >= 864e5) return null;
		opts = {
			suppressMilliseconds: false,
			suppressSeconds: false,
			includePrefix: false,
			format: "extended",
			...opts,
			includeOffset: false
		};
		return DateTime.fromMillis(millis, { zone: "UTC" }).toISOTime(opts);
	}
	toJSON() {
		return this.toISO();
	}
	toString() {
		return this.toISO();
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		if (this.isValid) return `Duration { values: ${JSON.stringify(this.values)} }`;
		else return `Duration { Invalid, reason: ${this.invalidReason} }`;
	}
	toMillis() {
		if (!this.isValid) return NaN;
		return durationToMillis(this.matrix, this.values);
	}
	valueOf() {
		return this.toMillis();
	}
	plus(duration) {
		if (!this.isValid) return this;
		const dur = Duration.fromDurationLike(duration), result = {};
		for (const k$1 of orderedUnits$1) if (hasOwnProperty$6(dur.values, k$1) || hasOwnProperty$6(this.values, k$1)) result[k$1] = dur.get(k$1) + this.get(k$1);
		return clone$1(this, { values: result }, true);
	}
	minus(duration) {
		if (!this.isValid) return this;
		const dur = Duration.fromDurationLike(duration);
		return this.plus(dur.negate());
	}
	mapUnits(fn$1) {
		if (!this.isValid) return this;
		const result = {};
		for (const k$1 of Object.keys(this.values)) result[k$1] = asNumber(fn$1(this.values[k$1], k$1));
		return clone$1(this, { values: result }, true);
	}
	get(unit) {
		return this[Duration.normalizeUnit(unit)];
	}
	set(values$1) {
		if (!this.isValid) return this;
		const mixed = {
			...this.values,
			...normalizeObject(values$1, Duration.normalizeUnit)
		};
		return clone$1(this, { values: mixed });
	}
	reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
		const opts = {
			loc: this.loc.clone({
				locale,
				numberingSystem
			}),
			matrix,
			conversionAccuracy
		};
		return clone$1(this, opts);
	}
	as(unit) {
		return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
	}
	normalize() {
		if (!this.isValid) return this;
		const vals = this.toObject();
		normalizeValues(this.matrix, vals);
		return clone$1(this, { values: vals }, true);
	}
	rescale() {
		if (!this.isValid) return this;
		const vals = removeZeroes(this.normalize().shiftToAll().toObject());
		return clone$1(this, { values: vals }, true);
	}
	shiftTo(...units) {
		if (!this.isValid) return this;
		if (units.length === 0) return this;
		units = units.map((u$1) => Duration.normalizeUnit(u$1));
		const built = {}, accumulated = {}, vals = this.toObject();
		let lastUnit;
		for (const k$1 of orderedUnits$1) if (units.indexOf(k$1) >= 0) {
			lastUnit = k$1;
			let own = 0;
			for (const ak in accumulated) {
				own += this.matrix[ak][k$1] * accumulated[ak];
				accumulated[ak] = 0;
			}
			if (isNumber$2(vals[k$1])) own += vals[k$1];
			const i$2 = Math.trunc(own);
			built[k$1] = i$2;
			accumulated[k$1] = (own * 1e3 - i$2 * 1e3) / 1e3;
		} else if (isNumber$2(vals[k$1])) accumulated[k$1] = vals[k$1];
		for (const key in accumulated) if (accumulated[key] !== 0) built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
		normalizeValues(this.matrix, built);
		return clone$1(this, { values: built }, true);
	}
	shiftToAll() {
		if (!this.isValid) return this;
		return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
	}
	negate() {
		if (!this.isValid) return this;
		const negated = {};
		for (const k$1 of Object.keys(this.values)) negated[k$1] = this.values[k$1] === 0 ? 0 : -this.values[k$1];
		return clone$1(this, { values: negated }, true);
	}
	get years() {
		return this.isValid ? this.values.years || 0 : NaN;
	}
	get quarters() {
		return this.isValid ? this.values.quarters || 0 : NaN;
	}
	get months() {
		return this.isValid ? this.values.months || 0 : NaN;
	}
	get weeks() {
		return this.isValid ? this.values.weeks || 0 : NaN;
	}
	get days() {
		return this.isValid ? this.values.days || 0 : NaN;
	}
	get hours() {
		return this.isValid ? this.values.hours || 0 : NaN;
	}
	get minutes() {
		return this.isValid ? this.values.minutes || 0 : NaN;
	}
	get seconds() {
		return this.isValid ? this.values.seconds || 0 : NaN;
	}
	get milliseconds() {
		return this.isValid ? this.values.milliseconds || 0 : NaN;
	}
	get isValid() {
		return this.invalid === null;
	}
	get invalidReason() {
		return this.invalid ? this.invalid.reason : null;
	}
	get invalidExplanation() {
		return this.invalid ? this.invalid.explanation : null;
	}
	equals(other) {
		if (!this.isValid || !other.isValid) return false;
		if (!this.loc.equals(other.loc)) return false;
		function eq$1(v1, v2) {
			if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
			return v1 === v2;
		}
		for (const u$1 of orderedUnits$1) if (!eq$1(this.values[u$1], other.values[u$1])) return false;
		return true;
	}
};
var INVALID$2 = "Invalid Interval";
function validateStartEnd(start, end) {
	if (!start || !start.isValid) return Interval.invalid("missing or invalid start");
	else if (!end || !end.isValid) return Interval.invalid("missing or invalid end");
	else if (end < start) return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
	else return null;
}
var Interval = class Interval {
	constructor(config$1) {
		this.s = config$1.start;
		this.e = config$1.end;
		this.invalid = config$1.invalid || null;
		this.isLuxonInterval = true;
	}
	static invalid(reason, explanation = null) {
		if (!reason) throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
		const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
		if (Settings.throwOnInvalid) throw new InvalidIntervalError(invalid);
		else return new Interval({ invalid });
	}
	static fromDateTimes(start, end) {
		const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
		const validateError = validateStartEnd(builtStart, builtEnd);
		if (validateError == null) return new Interval({
			start: builtStart,
			end: builtEnd
		});
		else return validateError;
	}
	static after(start, duration) {
		const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
		return Interval.fromDateTimes(dt, dt.plus(dur));
	}
	static before(end, duration) {
		const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
		return Interval.fromDateTimes(dt.minus(dur), dt);
	}
	static fromISO(text, opts) {
		const [s$2, e$1] = (text || "").split("/", 2);
		if (s$2 && e$1) {
			let start, startIsValid;
			try {
				start = DateTime.fromISO(s$2, opts);
				startIsValid = start.isValid;
			} catch (e$2) {
				startIsValid = false;
			}
			let end, endIsValid;
			try {
				end = DateTime.fromISO(e$1, opts);
				endIsValid = end.isValid;
			} catch (e$2) {
				endIsValid = false;
			}
			if (startIsValid && endIsValid) return Interval.fromDateTimes(start, end);
			if (startIsValid) {
				const dur = Duration.fromISO(e$1, opts);
				if (dur.isValid) return Interval.after(start, dur);
			} else if (endIsValid) {
				const dur = Duration.fromISO(s$2, opts);
				if (dur.isValid) return Interval.before(end, dur);
			}
		}
		return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
	}
	static isInterval(o$1) {
		return o$1 && o$1.isLuxonInterval || false;
	}
	get start() {
		return this.isValid ? this.s : null;
	}
	get end() {
		return this.isValid ? this.e : null;
	}
	get isValid() {
		return this.invalidReason === null;
	}
	get invalidReason() {
		return this.invalid ? this.invalid.reason : null;
	}
	get invalidExplanation() {
		return this.invalid ? this.invalid.explanation : null;
	}
	length(unit = "milliseconds") {
		return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
	}
	count(unit = "milliseconds", opts) {
		if (!this.isValid) return NaN;
		const start = this.start.startOf(unit, opts);
		let end;
		if (opts?.useLocaleWeeks) end = this.end.reconfigure({ locale: start.locale });
		else end = this.end;
		end = end.startOf(unit, opts);
		return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
	}
	hasSame(unit) {
		return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
	}
	isEmpty() {
		return this.s.valueOf() === this.e.valueOf();
	}
	isAfter(dateTime) {
		if (!this.isValid) return false;
		return this.s > dateTime;
	}
	isBefore(dateTime) {
		if (!this.isValid) return false;
		return this.e <= dateTime;
	}
	contains(dateTime) {
		if (!this.isValid) return false;
		return this.s <= dateTime && this.e > dateTime;
	}
	set({ start, end } = {}) {
		if (!this.isValid) return this;
		return Interval.fromDateTimes(start || this.s, end || this.e);
	}
	splitAt(...dateTimes) {
		if (!this.isValid) return [];
		const sorted = dateTimes.map(friendlyDateTime).filter((d$1) => this.contains(d$1)).sort((a$1, b$5) => a$1.toMillis() - b$5.toMillis()), results = [];
		let { s: s$2 } = this, i$2 = 0;
		while (s$2 < this.e) {
			const added = sorted[i$2] || this.e, next = +added > +this.e ? this.e : added;
			results.push(Interval.fromDateTimes(s$2, next));
			s$2 = next;
			i$2 += 1;
		}
		return results;
	}
	splitBy(duration) {
		const dur = Duration.fromDurationLike(duration);
		if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) return [];
		let { s: s$2 } = this, idx = 1, next;
		const results = [];
		while (s$2 < this.e) {
			const added = this.start.plus(dur.mapUnits((x$1) => x$1 * idx));
			next = +added > +this.e ? this.e : added;
			results.push(Interval.fromDateTimes(s$2, next));
			s$2 = next;
			idx += 1;
		}
		return results;
	}
	divideEqually(numberOfParts) {
		if (!this.isValid) return [];
		return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
	}
	overlaps(other) {
		return this.e > other.s && this.s < other.e;
	}
	abutsStart(other) {
		if (!this.isValid) return false;
		return +this.e === +other.s;
	}
	abutsEnd(other) {
		if (!this.isValid) return false;
		return +other.e === +this.s;
	}
	engulfs(other) {
		if (!this.isValid) return false;
		return this.s <= other.s && this.e >= other.e;
	}
	equals(other) {
		if (!this.isValid || !other.isValid) return false;
		return this.s.equals(other.s) && this.e.equals(other.e);
	}
	intersection(other) {
		if (!this.isValid) return this;
		const s$2 = this.s > other.s ? this.s : other.s, e$1 = this.e < other.e ? this.e : other.e;
		if (s$2 >= e$1) return null;
		else return Interval.fromDateTimes(s$2, e$1);
	}
	union(other) {
		if (!this.isValid) return this;
		const s$2 = this.s < other.s ? this.s : other.s, e$1 = this.e > other.e ? this.e : other.e;
		return Interval.fromDateTimes(s$2, e$1);
	}
	static merge(intervals) {
		const [found, final] = intervals.sort((a$1, b$5) => a$1.s - b$5.s).reduce(([sofar, current], item) => {
			if (!current) return [sofar, item];
			else if (current.overlaps(item) || current.abutsStart(item)) return [sofar, current.union(item)];
			else return [sofar.concat([current]), item];
		}, [[], null]);
		if (final) found.push(final);
		return found;
	}
	static xor(intervals) {
		let start = null, currentCount = 0;
		const results = [], ends = intervals.map((i$2) => [{
			time: i$2.s,
			type: "s"
		}, {
			time: i$2.e,
			type: "e"
		}]), arr = Array.prototype.concat(...ends).sort((a$1, b$5) => a$1.time - b$5.time);
		for (const i$2 of arr) {
			currentCount += i$2.type === "s" ? 1 : -1;
			if (currentCount === 1) start = i$2.time;
			else {
				if (start && +start !== +i$2.time) results.push(Interval.fromDateTimes(start, i$2.time));
				start = null;
			}
		}
		return Interval.merge(results);
	}
	difference(...intervals) {
		return Interval.xor([this].concat(intervals)).map((i$2) => this.intersection(i$2)).filter((i$2) => i$2 && !i$2.isEmpty());
	}
	toString() {
		if (!this.isValid) return INVALID$2;
		return `[${this.s.toISO()} – ${this.e.toISO()})`;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		if (this.isValid) return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
		else return `Interval { Invalid, reason: ${this.invalidReason} }`;
	}
	toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
		return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$2;
	}
	toISO(opts) {
		if (!this.isValid) return INVALID$2;
		return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
	}
	toISODate() {
		if (!this.isValid) return INVALID$2;
		return `${this.s.toISODate()}/${this.e.toISODate()}`;
	}
	toISOTime(opts) {
		if (!this.isValid) return INVALID$2;
		return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
	}
	toFormat(dateFormat, { separator = " – " } = {}) {
		if (!this.isValid) return INVALID$2;
		return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
	}
	toDuration(unit, opts) {
		if (!this.isValid) return Duration.invalid(this.invalidReason);
		return this.e.diff(this.s, unit, opts);
	}
	mapEndpoints(mapFn) {
		return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
	}
};
var Info = class {
	static hasDST(zone = Settings.defaultZone) {
		const proto = DateTime.now().setZone(zone).set({ month: 12 });
		return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
	}
	static isValidIANAZone(zone) {
		return IANAZone.isValidZone(zone);
	}
	static normalizeZone(input) {
		return normalizeZone(input, Settings.defaultZone);
	}
	static getStartOfWeek({ locale = null, locObj = null } = {}) {
		return (locObj || Locale.create(locale)).getStartOfWeek();
	}
	static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
		return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
	}
	static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
		return (locObj || Locale.create(locale)).getWeekendDays().slice();
	}
	static months(length$1 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
		return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length$1);
	}
	static monthsFormat(length$1 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
		return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length$1, true);
	}
	static weekdays(length$1 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
		return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length$1);
	}
	static weekdaysFormat(length$1 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
		return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length$1, true);
	}
	static meridiems({ locale = null } = {}) {
		return Locale.create(locale).meridiems();
	}
	static eras(length$1 = "short", { locale = null } = {}) {
		return Locale.create(locale, null, "gregory").eras(length$1);
	}
	static features() {
		return {
			relative: hasRelative(),
			localeWeek: hasLocaleWeekInfo()
		};
	}
};
function dayDiff(earlier, later) {
	const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
	return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
	const differs = [
		["years", (a$1, b$5) => b$5.year - a$1.year],
		["quarters", (a$1, b$5) => b$5.quarter - a$1.quarter + (b$5.year - a$1.year) * 4],
		["months", (a$1, b$5) => b$5.month - a$1.month + (b$5.year - a$1.year) * 12],
		["weeks", (a$1, b$5) => {
			const days = dayDiff(a$1, b$5);
			return (days - days % 7) / 7;
		}],
		["days", dayDiff]
	];
	const results = {};
	const earlier = cursor;
	let lowestOrder, highWater;
	for (const [unit, differ] of differs) if (units.indexOf(unit) >= 0) {
		lowestOrder = unit;
		results[unit] = differ(cursor, later);
		highWater = earlier.plus(results);
		if (highWater > later) {
			results[unit]--;
			cursor = earlier.plus(results);
			if (cursor > later) {
				highWater = cursor;
				results[unit]--;
				cursor = earlier.plus(results);
			}
		} else cursor = highWater;
	}
	return [
		cursor,
		results,
		highWater,
		lowestOrder
	];
}
function diff_default(earlier, later, units, opts) {
	let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
	const remainingMillis = later - cursor;
	const lowerOrderUnits = units.filter((u$1) => [
		"hours",
		"minutes",
		"seconds",
		"milliseconds"
	].indexOf(u$1) >= 0);
	if (lowerOrderUnits.length === 0) {
		if (highWater < later) highWater = cursor.plus({ [lowestOrder]: 1 });
		if (highWater !== cursor) results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
	}
	const duration = Duration.fromObject(results, opts);
	if (lowerOrderUnits.length > 0) return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
	else return duration;
}
var numberingSystems = {
	arab: "[٠-٩]",
	arabext: "[۰-۹]",
	bali: "[᭐-᭙]",
	beng: "[০-৯]",
	deva: "[०-९]",
	fullwide: "[０-９]",
	gujr: "[૦-૯]",
	hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
	khmr: "[០-៩]",
	knda: "[೦-೯]",
	laoo: "[໐-໙]",
	limb: "[᥆-᥏]",
	mlym: "[൦-൯]",
	mong: "[᠐-᠙]",
	mymr: "[၀-၉]",
	orya: "[୦-୯]",
	tamldec: "[௦-௯]",
	telu: "[౦-౯]",
	thai: "[๐-๙]",
	tibt: "[༠-༩]",
	latn: "\\d"
};
var numberingSystemsUTF16 = {
	arab: [1632, 1641],
	arabext: [1776, 1785],
	bali: [6992, 7001],
	beng: [2534, 2543],
	deva: [2406, 2415],
	fullwide: [65296, 65303],
	gujr: [2790, 2799],
	khmr: [6112, 6121],
	knda: [3302, 3311],
	laoo: [3792, 3801],
	limb: [6470, 6479],
	mlym: [3430, 3439],
	mong: [6160, 6169],
	mymr: [4160, 4169],
	orya: [2918, 2927],
	tamldec: [3046, 3055],
	telu: [3174, 3183],
	thai: [3664, 3673],
	tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
	let value = parseInt(str, 10);
	if (isNaN(value)) {
		value = "";
		for (let i$2 = 0; i$2 < str.length; i$2++) {
			const code$1 = str.charCodeAt(i$2);
			if (str[i$2].search(numberingSystems.hanidec) !== -1) value += hanidecChars.indexOf(str[i$2]);
			else for (const key in numberingSystemsUTF16) {
				const [min$2, max$2] = numberingSystemsUTF16[key];
				if (code$1 >= min$2 && code$1 <= max$2) value += code$1 - min$2;
			}
		}
		return parseInt(value, 10);
	} else return value;
}
function digitRegex({ numberingSystem }, append$1 = "") {
	return /* @__PURE__ */ new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append$1}`);
}
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i$2) => i$2) {
	return {
		regex,
		deser: ([s$2]) => post(parseDigits(s$2))
	};
}
var spaceOrNBSP = `[ ${String.fromCharCode(160)}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s$2) {
	return s$2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s$2) {
	return s$2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf$2(strings, startIndex) {
	if (strings === null) return null;
	else return {
		regex: RegExp(strings.map(fixListRegex).join("|")),
		deser: ([s$2]) => strings.findIndex((i$2) => stripInsensitivities(s$2) === stripInsensitivities(i$2)) + startIndex
	};
}
function offset(regex, groups) {
	return {
		regex,
		deser: ([, h$1, m$1]) => signedOffset(h$1, m$1),
		groups
	};
}
function simple(regex) {
	return {
		regex,
		deser: ([s$2]) => s$2
	};
}
function escapeToken(value) {
	return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
	const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t$1) => ({
		regex: RegExp(escapeToken(t$1.val)),
		deser: ([s$2]) => s$2,
		literal: true
	}), unitate = (t$1) => {
		if (token.literal) return literal(t$1);
		switch (t$1.val) {
			case "G": return oneOf$2(loc.eras("short"), 0);
			case "GG": return oneOf$2(loc.eras("long"), 0);
			case "y": return intUnit(oneToSix);
			case "yy": return intUnit(twoToFour, untruncateYear);
			case "yyyy": return intUnit(four);
			case "yyyyy": return intUnit(fourToSix);
			case "yyyyyy": return intUnit(six);
			case "M": return intUnit(oneOrTwo);
			case "MM": return intUnit(two);
			case "MMM": return oneOf$2(loc.months("short", true), 1);
			case "MMMM": return oneOf$2(loc.months("long", true), 1);
			case "L": return intUnit(oneOrTwo);
			case "LL": return intUnit(two);
			case "LLL": return oneOf$2(loc.months("short", false), 1);
			case "LLLL": return oneOf$2(loc.months("long", false), 1);
			case "d": return intUnit(oneOrTwo);
			case "dd": return intUnit(two);
			case "o": return intUnit(oneToThree);
			case "ooo": return intUnit(three);
			case "HH": return intUnit(two);
			case "H": return intUnit(oneOrTwo);
			case "hh": return intUnit(two);
			case "h": return intUnit(oneOrTwo);
			case "mm": return intUnit(two);
			case "m": return intUnit(oneOrTwo);
			case "q": return intUnit(oneOrTwo);
			case "qq": return intUnit(two);
			case "s": return intUnit(oneOrTwo);
			case "ss": return intUnit(two);
			case "S": return intUnit(oneToThree);
			case "SSS": return intUnit(three);
			case "u": return simple(oneToNine);
			case "uu": return simple(oneOrTwo);
			case "uuu": return intUnit(one);
			case "a": return oneOf$2(loc.meridiems(), 0);
			case "kkkk": return intUnit(four);
			case "kk": return intUnit(twoToFour, untruncateYear);
			case "W": return intUnit(oneOrTwo);
			case "WW": return intUnit(two);
			case "E":
			case "c": return intUnit(one);
			case "EEE": return oneOf$2(loc.weekdays("short", false), 1);
			case "EEEE": return oneOf$2(loc.weekdays("long", false), 1);
			case "ccc": return oneOf$2(loc.weekdays("short", true), 1);
			case "cccc": return oneOf$2(loc.weekdays("long", true), 1);
			case "Z":
			case "ZZ": return offset(/* @__PURE__ */ new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
			case "ZZZ": return offset(/* @__PURE__ */ new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
			case "z": return simple(/[a-z_+-/]{1,256}?/i);
			case " ": return simple(/[^\S\n\r]/);
			default: return literal(t$1);
		}
	};
	const unit = unitate(token) || { invalidReason: MISSING_FTP };
	unit.token = token;
	return unit;
}
var partTypeStyleToTokenVal = {
	year: {
		"2-digit": "yy",
		numeric: "yyyyy"
	},
	month: {
		numeric: "M",
		"2-digit": "MM",
		short: "MMM",
		long: "MMMM"
	},
	day: {
		numeric: "d",
		"2-digit": "dd"
	},
	weekday: {
		short: "EEE",
		long: "EEEE"
	},
	dayperiod: "a",
	dayPeriod: "a",
	hour12: {
		numeric: "h",
		"2-digit": "hh"
	},
	hour24: {
		numeric: "H",
		"2-digit": "HH"
	},
	minute: {
		numeric: "m",
		"2-digit": "mm"
	},
	second: {
		numeric: "s",
		"2-digit": "ss"
	},
	timeZoneName: {
		long: "ZZZZZ",
		short: "ZZZ"
	}
};
function tokenForPart(part, formatOpts, resolvedOpts) {
	const { type, value } = part;
	if (type === "literal") {
		const isSpace = /^\s+$/.test(value);
		return {
			literal: !isSpace,
			val: isSpace ? " " : value
		};
	}
	const style = formatOpts[type];
	let actualType = type;
	if (type === "hour") if (formatOpts.hour12 != null) actualType = formatOpts.hour12 ? "hour12" : "hour24";
	else if (formatOpts.hourCycle != null) if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") actualType = "hour12";
	else actualType = "hour24";
	else actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
	let val = partTypeStyleToTokenVal[actualType];
	if (typeof val === "object") val = val[style];
	if (val) return {
		literal: false,
		val
	};
}
function buildRegex(units) {
	return [`^${units.map((u$1) => u$1.regex).reduce((f$1, r$1) => `${f$1}(${r$1.source})`, "")}$`, units];
}
function match(input, regex, handlers) {
	const matches = input.match(regex);
	if (matches) {
		const all$1 = {};
		let matchIndex = 1;
		for (const i$2 in handlers) if (hasOwnProperty$6(handlers, i$2)) {
			const h$1 = handlers[i$2], groups = h$1.groups ? h$1.groups + 1 : 1;
			if (!h$1.literal && h$1.token) all$1[h$1.token.val[0]] = h$1.deser(matches.slice(matchIndex, matchIndex + groups));
			matchIndex += groups;
		}
		return [matches, all$1];
	} else return [matches, {}];
}
function dateTimeFromMatches(matches) {
	const toField = (token) => {
		switch (token) {
			case "S": return "millisecond";
			case "s": return "second";
			case "m": return "minute";
			case "h":
			case "H": return "hour";
			case "d": return "day";
			case "o": return "ordinal";
			case "L":
			case "M": return "month";
			case "y": return "year";
			case "E":
			case "c": return "weekday";
			case "W": return "weekNumber";
			case "k": return "weekYear";
			case "q": return "quarter";
			default: return null;
		}
	};
	let zone = null;
	let specificOffset;
	if (!isUndefined$1(matches.z)) zone = IANAZone.create(matches.z);
	if (!isUndefined$1(matches.Z)) {
		if (!zone) zone = new FixedOffsetZone(matches.Z);
		specificOffset = matches.Z;
	}
	if (!isUndefined$1(matches.q)) matches.M = (matches.q - 1) * 3 + 1;
	if (!isUndefined$1(matches.h)) {
		if (matches.h < 12 && matches.a === 1) matches.h += 12;
		else if (matches.h === 12 && matches.a === 0) matches.h = 0;
	}
	if (matches.G === 0 && matches.y) matches.y = -matches.y;
	if (!isUndefined$1(matches.u)) matches.S = parseMillis(matches.u);
	return [
		Object.keys(matches).reduce((r$1, k$1) => {
			const f$1 = toField(k$1);
			if (f$1) r$1[f$1] = matches[k$1];
			return r$1;
		}, {}),
		zone,
		specificOffset
	];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
	if (!dummyDateTimeCache) dummyDateTimeCache = DateTime.fromMillis(1555555555555);
	return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
	if (token.literal) return token;
	const tokens = formatOptsToTokens(Formatter.macroTokenToFormatOpts(token.val), locale);
	if (tokens == null || tokens.includes(void 0)) return token;
	return tokens;
}
function expandMacroTokens(tokens, locale) {
	return Array.prototype.concat(...tokens.map((t$1) => maybeExpandMacroToken(t$1, locale)));
}
function explainFromTokens(locale, input, format$2) {
	const tokens = expandMacroTokens(Formatter.parseFormat(format$2), locale), units = tokens.map((t$1) => unitForToken(t$1, locale)), disqualifyingUnit = units.find((t$1) => t$1.invalidReason);
	if (disqualifyingUnit) return {
		input,
		tokens,
		invalidReason: disqualifyingUnit.invalidReason
	};
	else {
		const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [
			null,
			null,
			void 0
		];
		if (hasOwnProperty$6(matches, "a") && hasOwnProperty$6(matches, "H")) throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
		return {
			input,
			tokens,
			regex,
			rawMatches,
			matches,
			result,
			zone,
			specificOffset
		};
	}
}
function parseFromTokens(locale, input, format$2) {
	const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format$2);
	return [
		result,
		zone,
		specificOffset,
		invalidReason
	];
}
function formatOptsToTokens(formatOpts, locale) {
	if (!formatOpts) return null;
	const df = Formatter.create(locale, formatOpts).dtFormatter(getDummyDateTime());
	const parts = df.formatToParts();
	const resolvedOpts = df.resolvedOptions();
	return parts.map((p$1) => tokenForPart(p$1, formatOpts, resolvedOpts));
}
var INVALID$1 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
	return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
	if (dt.weekData === null) dt.weekData = gregorianToWeek(dt.c);
	return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
	if (dt.localWeekData === null) dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
	return dt.localWeekData;
}
function clone(inst, alts) {
	const current = {
		ts: inst.ts,
		zone: inst.zone,
		c: inst.c,
		o: inst.o,
		loc: inst.loc,
		invalid: inst.invalid
	};
	return new DateTime({
		...current,
		...alts,
		old: current
	});
}
function fixOffset(localTS, o$1, tz) {
	let utcGuess = localTS - o$1 * 60 * 1e3;
	const o2 = tz.offset(utcGuess);
	if (o$1 === o2) return [utcGuess, o$1];
	utcGuess -= (o2 - o$1) * 60 * 1e3;
	const o3 = tz.offset(utcGuess);
	if (o2 === o3) return [utcGuess, o2];
	return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset$1) {
	ts += offset$1 * 60 * 1e3;
	const d$1 = new Date(ts);
	return {
		year: d$1.getUTCFullYear(),
		month: d$1.getUTCMonth() + 1,
		day: d$1.getUTCDate(),
		hour: d$1.getUTCHours(),
		minute: d$1.getUTCMinutes(),
		second: d$1.getUTCSeconds(),
		millisecond: d$1.getUTCMilliseconds()
	};
}
function objToTS(obj, offset$1, zone) {
	return fixOffset(objToLocalTS(obj), offset$1, zone);
}
function adjustTime(inst, dur) {
	const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c$1 = {
		...inst.c,
		year,
		month,
		day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
	}, millisToAdd = Duration.fromObject({
		years: dur.years - Math.trunc(dur.years),
		quarters: dur.quarters - Math.trunc(dur.quarters),
		months: dur.months - Math.trunc(dur.months),
		weeks: dur.weeks - Math.trunc(dur.weeks),
		days: dur.days - Math.trunc(dur.days),
		hours: dur.hours,
		minutes: dur.minutes,
		seconds: dur.seconds,
		milliseconds: dur.milliseconds
	}).as("milliseconds");
	let [ts, o$1] = fixOffset(objToLocalTS(c$1), oPre, inst.zone);
	if (millisToAdd !== 0) {
		ts += millisToAdd;
		o$1 = inst.zone.offset(ts);
	}
	return {
		ts,
		o: o$1
	};
}
function parseDataToDateTime(parsed, parsedZone, opts, format$2, text, specificOffset) {
	const { setZone, zone } = opts;
	if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
		const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
			...opts,
			zone: interpretationZone,
			specificOffset
		});
		return setZone ? inst : inst.setZone(zone);
	} else return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format$2}`));
}
function toTechFormat(dt, format$2, allowZ = true) {
	return dt.isValid ? Formatter.create(Locale.create("en-US"), {
		allowZ,
		forceSimple: true
	}).formatDateTimeFromString(dt, format$2) : null;
}
function toISODate(o$1, extended) {
	const longFormat = o$1.c.year > 9999 || o$1.c.year < 0;
	let c$1 = "";
	if (longFormat && o$1.c.year >= 0) c$1 += "+";
	c$1 += padStart(o$1.c.year, longFormat ? 6 : 4);
	if (extended) {
		c$1 += "-";
		c$1 += padStart(o$1.c.month);
		c$1 += "-";
		c$1 += padStart(o$1.c.day);
	} else {
		c$1 += padStart(o$1.c.month);
		c$1 += padStart(o$1.c.day);
	}
	return c$1;
}
function toISOTime(o$1, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
	let c$1 = padStart(o$1.c.hour);
	if (extended) {
		c$1 += ":";
		c$1 += padStart(o$1.c.minute);
		if (o$1.c.millisecond !== 0 || o$1.c.second !== 0 || !suppressSeconds) c$1 += ":";
	} else c$1 += padStart(o$1.c.minute);
	if (o$1.c.millisecond !== 0 || o$1.c.second !== 0 || !suppressSeconds) {
		c$1 += padStart(o$1.c.second);
		if (o$1.c.millisecond !== 0 || !suppressMilliseconds) {
			c$1 += ".";
			c$1 += padStart(o$1.c.millisecond, 3);
		}
	}
	if (includeOffset) if (o$1.isOffsetFixed && o$1.offset === 0 && !extendedZone) c$1 += "Z";
	else if (o$1.o < 0) {
		c$1 += "-";
		c$1 += padStart(Math.trunc(-o$1.o / 60));
		c$1 += ":";
		c$1 += padStart(Math.trunc(-o$1.o % 60));
	} else {
		c$1 += "+";
		c$1 += padStart(Math.trunc(o$1.o / 60));
		c$1 += ":";
		c$1 += padStart(Math.trunc(o$1.o % 60));
	}
	if (extendedZone) c$1 += "[" + o$1.zone.ianaName + "]";
	return c$1;
}
var defaultUnitValues = {
	month: 1,
	day: 1,
	hour: 0,
	minute: 0,
	second: 0,
	millisecond: 0
}, defaultWeekUnitValues = {
	weekNumber: 1,
	weekday: 1,
	hour: 0,
	minute: 0,
	second: 0,
	millisecond: 0
}, defaultOrdinalUnitValues = {
	ordinal: 1,
	hour: 0,
	minute: 0,
	second: 0,
	millisecond: 0
};
var orderedUnits = [
	"year",
	"month",
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
], orderedWeekUnits = [
	"weekYear",
	"weekNumber",
	"weekday",
	"hour",
	"minute",
	"second",
	"millisecond"
], orderedOrdinalUnits = [
	"year",
	"ordinal",
	"hour",
	"minute",
	"second",
	"millisecond"
];
function normalizeUnit(unit) {
	const normalized = {
		year: "year",
		years: "year",
		month: "month",
		months: "month",
		day: "day",
		days: "day",
		hour: "hour",
		hours: "hour",
		minute: "minute",
		minutes: "minute",
		quarter: "quarter",
		quarters: "quarter",
		second: "second",
		seconds: "second",
		millisecond: "millisecond",
		milliseconds: "millisecond",
		weekday: "weekday",
		weekdays: "weekday",
		weeknumber: "weekNumber",
		weeksnumber: "weekNumber",
		weeknumbers: "weekNumber",
		weekyear: "weekYear",
		weekyears: "weekYear",
		ordinal: "ordinal"
	}[unit.toLowerCase()];
	if (!normalized) throw new InvalidUnitError(unit);
	return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
	switch (unit.toLowerCase()) {
		case "localweekday":
		case "localweekdays": return "localWeekday";
		case "localweeknumber":
		case "localweeknumbers": return "localWeekNumber";
		case "localweekyear":
		case "localweekyears": return "localWeekYear";
		default: return normalizeUnit(unit);
	}
}
function quickDT(obj, opts) {
	const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
	let ts, o$1;
	if (!isUndefined$1(obj.year)) {
		for (const u$1 of orderedUnits) if (isUndefined$1(obj[u$1])) obj[u$1] = defaultUnitValues[u$1];
		const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
		if (invalid) return DateTime.invalid(invalid);
		const offsetProvis = zone.offset(tsNow);
		[ts, o$1] = objToTS(obj, offsetProvis, zone);
	} else ts = tsNow;
	return new DateTime({
		ts,
		zone,
		loc,
		o: o$1
	});
}
function diffRelative(start, end, opts) {
	const round$1 = isUndefined$1(opts.round) ? true : opts.round, format$2 = (c$1, unit) => {
		c$1 = roundTo(c$1, round$1 || opts.calendary ? 0 : 2, true);
		return end.loc.clone(opts).relFormatter(opts).format(c$1, unit);
	}, differ = (unit) => {
		if (opts.calendary) if (!end.hasSame(start, unit)) return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
		else return 0;
		else return end.diff(start, unit).get(unit);
	};
	if (opts.unit) return format$2(differ(opts.unit), opts.unit);
	for (const unit of opts.units) {
		const count = differ(unit);
		if (Math.abs(count) >= 1) return format$2(count, unit);
	}
	return format$2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
	let opts = {}, args;
	if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
		opts = argList[argList.length - 1];
		args = Array.from(argList).slice(0, argList.length - 1);
	} else args = Array.from(argList);
	return [opts, args];
}
var DateTime = class DateTime {
	constructor(config$1) {
		const zone = config$1.zone || Settings.defaultZone;
		let invalid = config$1.invalid || (Number.isNaN(config$1.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
		this.ts = isUndefined$1(config$1.ts) ? Settings.now() : config$1.ts;
		let c$1 = null, o$1 = null;
		if (!invalid) if (config$1.old && config$1.old.ts === this.ts && config$1.old.zone.equals(zone)) [c$1, o$1] = [config$1.old.c, config$1.old.o];
		else {
			const ot$1 = zone.offset(this.ts);
			c$1 = tsToObj(this.ts, ot$1);
			invalid = Number.isNaN(c$1.year) ? new Invalid("invalid input") : null;
			c$1 = invalid ? null : c$1;
			o$1 = invalid ? null : ot$1;
		}
		this._zone = zone;
		this.loc = config$1.loc || Locale.create();
		this.invalid = invalid;
		this.weekData = null;
		this.localWeekData = null;
		this.c = c$1;
		this.o = o$1;
		this.isLuxonDateTime = true;
	}
	static now() {
		return new DateTime({});
	}
	static local() {
		const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
		return quickDT({
			year,
			month,
			day,
			hour,
			minute,
			second,
			millisecond
		}, opts);
	}
	static utc() {
		const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
		opts.zone = FixedOffsetZone.utcInstance;
		return quickDT({
			year,
			month,
			day,
			hour,
			minute,
			second,
			millisecond
		}, opts);
	}
	static fromJSDate(date, options = {}) {
		const ts = isDate$3(date) ? date.valueOf() : NaN;
		if (Number.isNaN(ts)) return DateTime.invalid("invalid input");
		const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
		if (!zoneToUse.isValid) return DateTime.invalid(unsupportedZone(zoneToUse));
		return new DateTime({
			ts,
			zone: zoneToUse,
			loc: Locale.fromObject(options)
		});
	}
	static fromMillis(milliseconds, options = {}) {
		if (!isNumber$2(milliseconds)) throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
		else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) return DateTime.invalid("Timestamp out of range");
		else return new DateTime({
			ts: milliseconds,
			zone: normalizeZone(options.zone, Settings.defaultZone),
			loc: Locale.fromObject(options)
		});
	}
	static fromSeconds(seconds, options = {}) {
		if (!isNumber$2(seconds)) throw new InvalidArgumentError("fromSeconds requires a numerical input");
		else return new DateTime({
			ts: seconds * 1e3,
			zone: normalizeZone(options.zone, Settings.defaultZone),
			loc: Locale.fromObject(options)
		});
	}
	static fromObject(obj, opts = {}) {
		obj = obj || {};
		const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
		if (!zoneToUse.isValid) return DateTime.invalid(unsupportedZone(zoneToUse));
		const loc = Locale.fromObject(opts);
		const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
		const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
		const tsNow = Settings.now(), offsetProvis = !isUndefined$1(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined$1(normalized.ordinal), containsGregorYear = !isUndefined$1(normalized.year), containsGregorMD = !isUndefined$1(normalized.month) || !isUndefined$1(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
		if ((containsGregor || containsOrdinal) && definiteWeekDef) throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
		if (containsGregorMD && containsOrdinal) throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
		const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
		let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
		if (useWeekData) {
			units = orderedWeekUnits;
			defaultValues = defaultWeekUnitValues;
			objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
		} else if (containsOrdinal) {
			units = orderedOrdinalUnits;
			defaultValues = defaultOrdinalUnitValues;
			objNow = gregorianToOrdinal(objNow);
		} else {
			units = orderedUnits;
			defaultValues = defaultUnitValues;
		}
		let foundFirst = false;
		for (const u$1 of units) {
			const v$3 = normalized[u$1];
			if (!isUndefined$1(v$3)) foundFirst = true;
			else if (foundFirst) normalized[u$1] = defaultValues[u$1];
			else normalized[u$1] = objNow[u$1];
		}
		const invalid = (useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized)) || hasInvalidTimeData(normalized);
		if (invalid) return DateTime.invalid(invalid);
		const [tsFinal, offsetFinal] = objToTS(useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, offsetProvis, zoneToUse), inst = new DateTime({
			ts: tsFinal,
			zone: zoneToUse,
			o: offsetFinal,
			loc
		});
		if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
		return inst;
	}
	static fromISO(text, opts = {}) {
		const [vals, parsedZone] = parseISODate(text);
		return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
	}
	static fromRFC2822(text, opts = {}) {
		const [vals, parsedZone] = parseRFC2822Date(text);
		return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
	}
	static fromHTTP(text, opts = {}) {
		const [vals, parsedZone] = parseHTTPDate(text);
		return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
	}
	static fromFormat(text, fmt, opts = {}) {
		if (isUndefined$1(text) || isUndefined$1(fmt)) throw new InvalidArgumentError("fromFormat requires an input string and a format");
		const { locale = null, numberingSystem = null } = opts, [vals, parsedZone, specificOffset, invalid] = parseFromTokens(Locale.fromOpts({
			locale,
			numberingSystem,
			defaultToEN: true
		}), text, fmt);
		if (invalid) return DateTime.invalid(invalid);
		else return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
	}
	static fromString(text, fmt, opts = {}) {
		return DateTime.fromFormat(text, fmt, opts);
	}
	static fromSQL(text, opts = {}) {
		const [vals, parsedZone] = parseSQL(text);
		return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
	}
	static invalid(reason, explanation = null) {
		if (!reason) throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
		const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
		if (Settings.throwOnInvalid) throw new InvalidDateTimeError(invalid);
		else return new DateTime({ invalid });
	}
	static isDateTime(o$1) {
		return o$1 && o$1.isLuxonDateTime || false;
	}
	static parseFormatForOpts(formatOpts, localeOpts = {}) {
		const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
		return !tokenList ? null : tokenList.map((t$1) => t$1 ? t$1.val : null).join("");
	}
	static expandFormat(fmt, localeOpts = {}) {
		return expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts)).map((t$1) => t$1.val).join("");
	}
	get(unit) {
		return this[unit];
	}
	get isValid() {
		return this.invalid === null;
	}
	get invalidReason() {
		return this.invalid ? this.invalid.reason : null;
	}
	get invalidExplanation() {
		return this.invalid ? this.invalid.explanation : null;
	}
	get locale() {
		return this.isValid ? this.loc.locale : null;
	}
	get numberingSystem() {
		return this.isValid ? this.loc.numberingSystem : null;
	}
	get outputCalendar() {
		return this.isValid ? this.loc.outputCalendar : null;
	}
	get zone() {
		return this._zone;
	}
	get zoneName() {
		return this.isValid ? this.zone.name : null;
	}
	get year() {
		return this.isValid ? this.c.year : NaN;
	}
	get quarter() {
		return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
	}
	get month() {
		return this.isValid ? this.c.month : NaN;
	}
	get day() {
		return this.isValid ? this.c.day : NaN;
	}
	get hour() {
		return this.isValid ? this.c.hour : NaN;
	}
	get minute() {
		return this.isValid ? this.c.minute : NaN;
	}
	get second() {
		return this.isValid ? this.c.second : NaN;
	}
	get millisecond() {
		return this.isValid ? this.c.millisecond : NaN;
	}
	get weekYear() {
		return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
	}
	get weekNumber() {
		return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
	}
	get weekday() {
		return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
	}
	get isWeekend() {
		return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
	}
	get localWeekday() {
		return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
	}
	get localWeekNumber() {
		return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
	}
	get localWeekYear() {
		return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
	}
	get ordinal() {
		return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
	}
	get monthShort() {
		return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
	}
	get monthLong() {
		return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
	}
	get weekdayShort() {
		return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
	}
	get weekdayLong() {
		return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
	}
	get offset() {
		return this.isValid ? +this.o : NaN;
	}
	get offsetNameShort() {
		if (this.isValid) return this.zone.offsetName(this.ts, {
			format: "short",
			locale: this.locale
		});
		else return null;
	}
	get offsetNameLong() {
		if (this.isValid) return this.zone.offsetName(this.ts, {
			format: "long",
			locale: this.locale
		});
		else return null;
	}
	get isOffsetFixed() {
		return this.isValid ? this.zone.isUniversal : null;
	}
	get isInDST() {
		if (this.isOffsetFixed) return false;
		else return this.offset > this.set({
			month: 1,
			day: 1
		}).offset || this.offset > this.set({ month: 5 }).offset;
	}
	getPossibleOffsets() {
		if (!this.isValid || this.isOffsetFixed) return [this];
		const dayMs = 864e5;
		const minuteMs = 6e4;
		const localTS = objToLocalTS(this.c);
		const oEarlier = this.zone.offset(localTS - dayMs);
		const oLater = this.zone.offset(localTS + dayMs);
		const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
		const o2 = this.zone.offset(localTS - oLater * minuteMs);
		if (o1 === o2) return [this];
		const ts1 = localTS - o1 * minuteMs;
		const ts2 = localTS - o2 * minuteMs;
		const c1 = tsToObj(ts1, o1);
		const c2 = tsToObj(ts2, o2);
		if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];
		return [this];
	}
	get isInLeapYear() {
		return isLeapYear(this.year);
	}
	get daysInMonth() {
		return daysInMonth(this.year, this.month);
	}
	get daysInYear() {
		return this.isValid ? daysInYear(this.year) : NaN;
	}
	get weeksInWeekYear() {
		return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
	}
	get weeksInLocalWeekYear() {
		return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
	}
	resolvedLocaleOptions(opts = {}) {
		const { locale, numberingSystem, calendar } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
		return {
			locale,
			numberingSystem,
			outputCalendar: calendar
		};
	}
	toUTC(offset$1 = 0, opts = {}) {
		return this.setZone(FixedOffsetZone.instance(offset$1), opts);
	}
	toLocal() {
		return this.setZone(Settings.defaultZone);
	}
	setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
		zone = normalizeZone(zone, Settings.defaultZone);
		if (zone.equals(this.zone)) return this;
		else if (!zone.isValid) return DateTime.invalid(unsupportedZone(zone));
		else {
			let newTS = this.ts;
			if (keepLocalTime || keepCalendarTime) {
				const offsetGuess = zone.offset(this.ts);
				const asObj = this.toObject();
				[newTS] = objToTS(asObj, offsetGuess, zone);
			}
			return clone(this, {
				ts: newTS,
				zone
			});
		}
	}
	reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
		const loc = this.loc.clone({
			locale,
			numberingSystem,
			outputCalendar
		});
		return clone(this, { loc });
	}
	setLocale(locale) {
		return this.reconfigure({ locale });
	}
	set(values$1) {
		if (!this.isValid) return this;
		const normalized = normalizeObject(values$1, normalizeUnitWithLocalWeeks);
		const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
		const settingWeekStuff = !isUndefined$1(normalized.weekYear) || !isUndefined$1(normalized.weekNumber) || !isUndefined$1(normalized.weekday), containsOrdinal = !isUndefined$1(normalized.ordinal), containsGregorYear = !isUndefined$1(normalized.year), containsGregorMD = !isUndefined$1(normalized.month) || !isUndefined$1(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
		if ((containsGregor || containsOrdinal) && definiteWeekDef) throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
		if (containsGregorMD && containsOrdinal) throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
		let mixed;
		if (settingWeekStuff) mixed = weekToGregorian({
			...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
			...normalized
		}, minDaysInFirstWeek, startOfWeek);
		else if (!isUndefined$1(normalized.ordinal)) mixed = ordinalToGregorian({
			...gregorianToOrdinal(this.c),
			...normalized
		});
		else {
			mixed = {
				...this.toObject(),
				...normalized
			};
			if (isUndefined$1(normalized.day)) mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
		}
		const [ts, o$1] = objToTS(mixed, this.o, this.zone);
		return clone(this, {
			ts,
			o: o$1
		});
	}
	plus(duration) {
		if (!this.isValid) return this;
		const dur = Duration.fromDurationLike(duration);
		return clone(this, adjustTime(this, dur));
	}
	minus(duration) {
		if (!this.isValid) return this;
		const dur = Duration.fromDurationLike(duration).negate();
		return clone(this, adjustTime(this, dur));
	}
	startOf(unit, { useLocaleWeeks = false } = {}) {
		if (!this.isValid) return this;
		const o$1 = {}, normalizedUnit = Duration.normalizeUnit(unit);
		switch (normalizedUnit) {
			case "years": o$1.month = 1;
			case "quarters":
			case "months": o$1.day = 1;
			case "weeks":
			case "days": o$1.hour = 0;
			case "hours": o$1.minute = 0;
			case "minutes": o$1.second = 0;
			case "seconds":
				o$1.millisecond = 0;
				break;
			case "milliseconds": break;
		}
		if (normalizedUnit === "weeks") if (useLocaleWeeks) {
			const startOfWeek = this.loc.getStartOfWeek();
			const { weekday } = this;
			if (weekday < startOfWeek) o$1.weekNumber = this.weekNumber - 1;
			o$1.weekday = startOfWeek;
		} else o$1.weekday = 1;
		if (normalizedUnit === "quarters") o$1.month = (Math.ceil(this.month / 3) - 1) * 3 + 1;
		return this.set(o$1);
	}
	endOf(unit, opts) {
		return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
	}
	toFormat(fmt, opts = {}) {
		return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$1;
	}
	toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
		return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID$1;
	}
	toLocaleParts(opts = {}) {
		return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
	}
	toISO({ format: format$2 = "extended", suppressSeconds = false, suppressMilliseconds = false, includeOffset = true, extendedZone = false } = {}) {
		if (!this.isValid) return null;
		const ext = format$2 === "extended";
		let c$1 = toISODate(this, ext);
		c$1 += "T";
		c$1 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
		return c$1;
	}
	toISODate({ format: format$2 = "extended" } = {}) {
		if (!this.isValid) return null;
		return toISODate(this, format$2 === "extended");
	}
	toISOWeekDate() {
		return toTechFormat(this, "kkkk-'W'WW-c");
	}
	toISOTime({ suppressMilliseconds = false, suppressSeconds = false, includeOffset = true, includePrefix = false, extendedZone = false, format: format$2 = "extended" } = {}) {
		if (!this.isValid) return null;
		return (includePrefix ? "T" : "") + toISOTime(this, format$2 === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
	}
	toRFC2822() {
		return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
	}
	toHTTP() {
		return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
	}
	toSQLDate() {
		if (!this.isValid) return null;
		return toISODate(this, true);
	}
	toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
		let fmt = "HH:mm:ss.SSS";
		if (includeZone || includeOffset) {
			if (includeOffsetSpace) fmt += " ";
			if (includeZone) fmt += "z";
			else if (includeOffset) fmt += "ZZ";
		}
		return toTechFormat(this, fmt, true);
	}
	toSQL(opts = {}) {
		if (!this.isValid) return null;
		return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
	}
	toString() {
		return this.isValid ? this.toISO() : INVALID$1;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		if (this.isValid) return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
		else return `DateTime { Invalid, reason: ${this.invalidReason} }`;
	}
	valueOf() {
		return this.toMillis();
	}
	toMillis() {
		return this.isValid ? this.ts : NaN;
	}
	toSeconds() {
		return this.isValid ? this.ts / 1e3 : NaN;
	}
	toUnixInteger() {
		return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
	}
	toJSON() {
		return this.toISO();
	}
	toBSON() {
		return this.toJSDate();
	}
	toObject(opts = {}) {
		if (!this.isValid) return {};
		const base = { ...this.c };
		if (opts.includeConfig) {
			base.outputCalendar = this.outputCalendar;
			base.numberingSystem = this.loc.numberingSystem;
			base.locale = this.loc.locale;
		}
		return base;
	}
	toJSDate() {
		return new Date(this.isValid ? this.ts : NaN);
	}
	diff(otherDateTime, unit = "milliseconds", opts = {}) {
		if (!this.isValid || !otherDateTime.isValid) return Duration.invalid("created by diffing an invalid DateTime");
		const durOpts = {
			locale: this.locale,
			numberingSystem: this.numberingSystem,
			...opts
		};
		const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), diffed = diff_default(otherIsLater ? this : otherDateTime, otherIsLater ? otherDateTime : this, units, durOpts);
		return otherIsLater ? diffed.negate() : diffed;
	}
	diffNow(unit = "milliseconds", opts = {}) {
		return this.diff(DateTime.now(), unit, opts);
	}
	until(otherDateTime) {
		return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
	}
	hasSame(otherDateTime, unit, opts) {
		if (!this.isValid) return false;
		const inputMs = otherDateTime.valueOf();
		const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
		return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
	}
	equals(other) {
		return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
	}
	toRelative(options = {}) {
		if (!this.isValid) return null;
		const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
		let units = [
			"years",
			"months",
			"days",
			"hours",
			"minutes",
			"seconds"
		];
		let unit = options.unit;
		if (Array.isArray(options.unit)) {
			units = options.unit;
			unit = void 0;
		}
		return diffRelative(base, this.plus(padding), {
			...options,
			numeric: "always",
			units,
			unit
		});
	}
	toRelativeCalendar(options = {}) {
		if (!this.isValid) return null;
		return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
			...options,
			numeric: "auto",
			units: [
				"years",
				"months",
				"days"
			],
			calendary: true
		});
	}
	static min(...dateTimes) {
		if (!dateTimes.every(DateTime.isDateTime)) throw new InvalidArgumentError("min requires all arguments be DateTimes");
		return bestBy(dateTimes, (i$2) => i$2.valueOf(), Math.min);
	}
	static max(...dateTimes) {
		if (!dateTimes.every(DateTime.isDateTime)) throw new InvalidArgumentError("max requires all arguments be DateTimes");
		return bestBy(dateTimes, (i$2) => i$2.valueOf(), Math.max);
	}
	static fromFormatExplain(text, fmt, options = {}) {
		const { locale = null, numberingSystem = null } = options;
		return explainFromTokens(Locale.fromOpts({
			locale,
			numberingSystem,
			defaultToEN: true
		}), text, fmt);
	}
	static fromStringExplain(text, fmt, options = {}) {
		return DateTime.fromFormatExplain(text, fmt, options);
	}
	static get DATE_SHORT() {
		return DATE_SHORT;
	}
	static get DATE_MED() {
		return DATE_MED;
	}
	static get DATE_MED_WITH_WEEKDAY() {
		return DATE_MED_WITH_WEEKDAY;
	}
	static get DATE_FULL() {
		return DATE_FULL;
	}
	static get DATE_HUGE() {
		return DATE_HUGE;
	}
	static get TIME_SIMPLE() {
		return TIME_SIMPLE;
	}
	static get TIME_WITH_SECONDS() {
		return TIME_WITH_SECONDS;
	}
	static get TIME_WITH_SHORT_OFFSET() {
		return TIME_WITH_SHORT_OFFSET;
	}
	static get TIME_WITH_LONG_OFFSET() {
		return TIME_WITH_LONG_OFFSET;
	}
	static get TIME_24_SIMPLE() {
		return TIME_24_SIMPLE;
	}
	static get TIME_24_WITH_SECONDS() {
		return TIME_24_WITH_SECONDS;
	}
	static get TIME_24_WITH_SHORT_OFFSET() {
		return TIME_24_WITH_SHORT_OFFSET;
	}
	static get TIME_24_WITH_LONG_OFFSET() {
		return TIME_24_WITH_LONG_OFFSET;
	}
	static get DATETIME_SHORT() {
		return DATETIME_SHORT;
	}
	static get DATETIME_SHORT_WITH_SECONDS() {
		return DATETIME_SHORT_WITH_SECONDS;
	}
	static get DATETIME_MED() {
		return DATETIME_MED;
	}
	static get DATETIME_MED_WITH_SECONDS() {
		return DATETIME_MED_WITH_SECONDS;
	}
	static get DATETIME_MED_WITH_WEEKDAY() {
		return DATETIME_MED_WITH_WEEKDAY;
	}
	static get DATETIME_FULL() {
		return DATETIME_FULL;
	}
	static get DATETIME_FULL_WITH_SECONDS() {
		return DATETIME_FULL_WITH_SECONDS;
	}
	static get DATETIME_HUGE() {
		return DATETIME_HUGE;
	}
	static get DATETIME_HUGE_WITH_SECONDS() {
		return DATETIME_HUGE_WITH_SECONDS;
	}
};
function friendlyDateTime(dateTimeish) {
	if (DateTime.isDateTime(dateTimeish)) return dateTimeish;
	else if (dateTimeish && dateTimeish.valueOf && isNumber$2(dateTimeish.valueOf())) return DateTime.fromJSDate(dateTimeish);
	else if (dateTimeish && typeof dateTimeish === "object") return DateTime.fromObject(dateTimeish);
	else throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
}
var import_callsites = /* @__PURE__ */ __toESM(require_callsites());
var BaseError = class extends Error {
	level;
	shouldReport;
	description;
	tags;
	extra;
	packageName;
	constructor(message, { level = "error", description, shouldReport, tags = {}, extra,...rest } = {}) {
		super(message, rest);
		this.level = level;
		this.shouldReport = shouldReport ?? (level === "error" || level === "fatal");
		this.description = description;
		this.tags = tags;
		this.extra = extra;
		try {
			const filePath = (0, import_callsites.default)()[2].getFileName() ?? "";
			const match$1 = /packages\/([^\/]+)\//.exec(filePath)?.[1];
			if (match$1) this.tags.packageName = match$1;
		} catch {}
	}
};
var OperationalError = class extends BaseError {
	constructor(message, opts = {}) {
		opts.level = opts.level ?? "warning";
		super(message, opts);
	}
};
var UserError = class extends BaseError {
	constructor(message, opts = {}) {
		opts.level = opts.level ?? "info";
		super(message, opts);
	}
};
var ExecutionBaseError = class ExecutionBaseError extends ApplicationError {
	description;
	cause;
	errorResponse;
	timestamp;
	context = {};
	lineNumber;
	functionality = "regular";
	constructor(message, options = {}) {
		super(message, options);
		this.name = this.constructor.name;
		this.timestamp = Date.now();
		const { cause, errorResponse } = options;
		if (cause instanceof ExecutionBaseError) this.context = cause.context;
		else if (cause && !(cause instanceof Error)) this.cause = cause;
		if (errorResponse) this.errorResponse = errorResponse;
	}
	toJSON() {
		return {
			message: this.message,
			lineNumber: this.lineNumber,
			timestamp: this.timestamp,
			name: this.name,
			description: this.description,
			context: this.context,
			cause: this.cause
		};
	}
};
var ExpressionError = class extends ExecutionBaseError {
	constructor(message, options) {
		super(message, {
			cause: options?.cause,
			level: "warning"
		});
		if (options?.description !== void 0) this.description = options.description;
		const allowedKeys = [
			"causeDetailed",
			"descriptionTemplate",
			"descriptionKey",
			"itemIndex",
			"messageTemplate",
			"nodeCause",
			"parameter",
			"runIndex",
			"type"
		];
		if (options !== void 0) {
			if (options.functionality !== void 0) this.functionality = options.functionality;
			Object.keys(options).forEach((key) => {
				if (allowedKeys.includes(key)) this.context[key] = options[key];
			});
		}
	}
};
var require_defaults = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		exports.defaults = {
			"0.1": {
				explicitCharkey: false,
				trim: true,
				normalize: true,
				normalizeTags: false,
				attrkey: "@",
				charkey: "#",
				explicitArray: false,
				ignoreAttrs: false,
				mergeAttrs: false,
				explicitRoot: false,
				validator: null,
				xmlns: false,
				explicitChildren: false,
				childkey: "@@",
				charsAsChildren: false,
				includeWhiteChars: false,
				async: false,
				strict: true,
				attrNameProcessors: null,
				attrValueProcessors: null,
				tagNameProcessors: null,
				valueProcessors: null,
				emptyTag: ""
			},
			"0.2": {
				explicitCharkey: false,
				trim: false,
				normalize: false,
				normalizeTags: false,
				attrkey: "$",
				charkey: "_",
				explicitArray: true,
				ignoreAttrs: false,
				mergeAttrs: false,
				explicitRoot: true,
				validator: null,
				xmlns: false,
				explicitChildren: false,
				preserveChildrenOrder: false,
				childkey: "$$",
				charsAsChildren: false,
				includeWhiteChars: false,
				async: false,
				strict: true,
				attrNameProcessors: null,
				attrValueProcessors: null,
				tagNameProcessors: null,
				valueProcessors: null,
				rootName: "root",
				xmldec: {
					"version": "1.0",
					"encoding": "UTF-8",
					"standalone": true
				},
				doctype: null,
				renderOpts: {
					"pretty": true,
					"indent": "  ",
					"newline": "\n"
				},
				headless: false,
				chunkSize: 1e4,
				emptyTag: "",
				cdata: false
			}
		};
	}).call(exports);
}));
var require_Utility = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var assign, getValue, isArray$11, isEmpty$5, isFunction$2, isObject$8, isPlainObject, slice$1 = [].slice, hasProp = {}.hasOwnProperty;
		assign = function() {
			var i$2, key, len$1, source, sources, target = arguments[0];
			sources = 2 <= arguments.length ? slice$1.call(arguments, 1) : [];
			if (isFunction$2(Object.assign)) Object.assign.apply(null, arguments);
			else for (i$2 = 0, len$1 = sources.length; i$2 < len$1; i$2++) {
				source = sources[i$2];
				if (source != null) for (key in source) {
					if (!hasProp.call(source, key)) continue;
					target[key] = source[key];
				}
			}
			return target;
		};
		isFunction$2 = function(val) {
			return !!val && Object.prototype.toString.call(val) === "[object Function]";
		};
		isObject$8 = function(val) {
			var ref;
			return !!val && ((ref = typeof val) === "function" || ref === "object");
		};
		isArray$11 = function(val) {
			if (isFunction$2(Array.isArray)) return Array.isArray(val);
			else return Object.prototype.toString.call(val) === "[object Array]";
		};
		isEmpty$5 = function(val) {
			var key;
			if (isArray$11(val)) return !val.length;
			else {
				for (key in val) {
					if (!hasProp.call(val, key)) continue;
					return false;
				}
				return true;
			}
		};
		isPlainObject = function(val) {
			var ctor, proto;
			return isObject$8(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
		};
		getValue = function(obj) {
			if (isFunction$2(obj.valueOf)) return obj.valueOf();
			else return obj;
		};
		module.exports.assign = assign;
		module.exports.isFunction = isFunction$2;
		module.exports.isObject = isObject$8;
		module.exports.isArray = isArray$11;
		module.exports.isEmpty = isEmpty$5;
		module.exports.isPlainObject = isPlainObject;
		module.exports.getValue = getValue;
	}).call(exports);
}));
var require_XMLDOMImplementation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = (function() {
			function XMLDOMImplementation() {}
			XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
				return true;
			};
			XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
				throw new Error("This DOM method is not implemented.");
			};
			XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
				throw new Error("This DOM method is not implemented.");
			};
			XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
				throw new Error("This DOM method is not implemented.");
			};
			XMLDOMImplementation.prototype.getFeature = function(feature, version) {
				throw new Error("This DOM method is not implemented.");
			};
			return XMLDOMImplementation;
		})();
	}).call(exports);
}));
var require_XMLDOMErrorHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = (function() {
			function XMLDOMErrorHandler() {}
			XMLDOMErrorHandler.prototype.handleError = function(error$1) {
				throw new Error(error$1);
			};
			return XMLDOMErrorHandler;
		})();
	}).call(exports);
}));
var require_XMLDOMStringList = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = (function() {
			function XMLDOMStringList(arr) {
				this.arr = arr || [];
			}
			Object.defineProperty(XMLDOMStringList.prototype, "length", { get: function() {
				return this.arr.length;
			} });
			XMLDOMStringList.prototype.item = function(index) {
				return this.arr[index] || null;
			};
			XMLDOMStringList.prototype.contains = function(str) {
				return this.arr.indexOf(str) !== -1;
			};
			return XMLDOMStringList;
		})();
	}).call(exports);
}));
var require_XMLDOMConfiguration = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var XMLDOMErrorHandler = require_XMLDOMErrorHandler(), XMLDOMStringList = require_XMLDOMStringList();
		module.exports = (function() {
			function XMLDOMConfiguration() {
				this.defaultParams = {
					"canonical-form": false,
					"cdata-sections": false,
					"comments": false,
					"datatype-normalization": false,
					"element-content-whitespace": true,
					"entities": true,
					"error-handler": new XMLDOMErrorHandler(),
					"infoset": true,
					"validate-if-schema": false,
					"namespaces": true,
					"namespace-declarations": true,
					"normalize-characters": false,
					"schema-location": "",
					"schema-type": "",
					"split-cdata-sections": true,
					"validate": false,
					"well-formed": true
				};
				this.params = Object.create(this.defaultParams);
			}
			Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", { get: function() {
				return new XMLDOMStringList(Object.keys(this.defaultParams));
			} });
			XMLDOMConfiguration.prototype.getParameter = function(name) {
				if (this.params.hasOwnProperty(name)) return this.params[name];
				else return null;
			};
			XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
				return true;
			};
			XMLDOMConfiguration.prototype.setParameter = function(name, value) {
				if (value != null) return this.params[name] = value;
				else return delete this.params[name];
			};
			return XMLDOMConfiguration;
		})();
	}).call(exports);
}));
var require_NodeType = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = {
			Element: 1,
			Attribute: 2,
			Text: 3,
			CData: 4,
			EntityReference: 5,
			EntityDeclaration: 6,
			ProcessingInstruction: 7,
			Comment: 8,
			Document: 9,
			DocType: 10,
			DocumentFragment: 11,
			NotationDeclaration: 12,
			Declaration: 201,
			Raw: 202,
			AttributeDeclaration: 203,
			ElementDeclaration: 204,
			Dummy: 205
		};
	}).call(exports);
}));
var require_XMLAttribute = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType = require_NodeType();
		require_XMLNode();
		module.exports = (function() {
			function XMLAttribute(parent, name, value) {
				this.parent = parent;
				if (this.parent) {
					this.options = this.parent.options;
					this.stringify = this.parent.stringify;
				}
				if (name == null) throw new Error("Missing attribute name. " + this.debugInfo(name));
				this.name = this.stringify.name(name);
				this.value = this.stringify.attValue(value);
				this.type = NodeType.Attribute;
				this.isId = false;
				this.schemaTypeInfo = null;
			}
			Object.defineProperty(XMLAttribute.prototype, "nodeType", { get: function() {
				return this.type;
			} });
			Object.defineProperty(XMLAttribute.prototype, "ownerElement", { get: function() {
				return this.parent;
			} });
			Object.defineProperty(XMLAttribute.prototype, "textContent", {
				get: function() {
					return this.value;
				},
				set: function(value) {
					return this.value = value || "";
				}
			});
			Object.defineProperty(XMLAttribute.prototype, "namespaceURI", { get: function() {
				return "";
			} });
			Object.defineProperty(XMLAttribute.prototype, "prefix", { get: function() {
				return "";
			} });
			Object.defineProperty(XMLAttribute.prototype, "localName", { get: function() {
				return this.name;
			} });
			Object.defineProperty(XMLAttribute.prototype, "specified", { get: function() {
				return true;
			} });
			XMLAttribute.prototype.clone = function() {
				return Object.create(this);
			};
			XMLAttribute.prototype.toString = function(options) {
				return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
			};
			XMLAttribute.prototype.debugInfo = function(name) {
				name = name || this.name;
				if (name == null) return "parent: <" + this.parent.name + ">";
				else return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
			};
			XMLAttribute.prototype.isEqualNode = function(node) {
				if (node.namespaceURI !== this.namespaceURI) return false;
				if (node.prefix !== this.prefix) return false;
				if (node.localName !== this.localName) return false;
				if (node.value !== this.value) return false;
				return true;
			};
			return XMLAttribute;
		})();
	}).call(exports);
}));
var require_XMLNamedNodeMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = (function() {
			function XMLNamedNodeMap(nodes) {
				this.nodes = nodes;
			}
			Object.defineProperty(XMLNamedNodeMap.prototype, "length", { get: function() {
				return Object.keys(this.nodes).length || 0;
			} });
			XMLNamedNodeMap.prototype.clone = function() {
				return this.nodes = null;
			};
			XMLNamedNodeMap.prototype.getNamedItem = function(name) {
				return this.nodes[name];
			};
			XMLNamedNodeMap.prototype.setNamedItem = function(node) {
				var oldNode = this.nodes[node.nodeName];
				this.nodes[node.nodeName] = node;
				return oldNode || null;
			};
			XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
				var oldNode = this.nodes[name];
				delete this.nodes[name];
				return oldNode || null;
			};
			XMLNamedNodeMap.prototype.item = function(index) {
				return this.nodes[Object.keys(this.nodes)[index]] || null;
			};
			XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented.");
			};
			XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
				throw new Error("This DOM method is not implemented.");
			};
			XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented.");
			};
			return XMLNamedNodeMap;
		})();
	}).call(exports);
}));
var require_XMLElement = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction$2, isObject$8, ref, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		ref = require_Utility(), isObject$8 = ref.isObject, isFunction$2 = ref.isFunction, getValue = ref.getValue;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		XMLAttribute = require_XMLAttribute();
		XMLNamedNodeMap = require_XMLNamedNodeMap();
		module.exports = (function(superClass) {
			extend$1(XMLElement, superClass);
			function XMLElement(parent, name, attributes) {
				var child, j$1, len$1, ref1;
				XMLElement.__super__.constructor.call(this, parent);
				if (name == null) throw new Error("Missing element name. " + this.debugInfo());
				this.name = this.stringify.name(name);
				this.type = NodeType.Element;
				this.attribs = {};
				this.schemaTypeInfo = null;
				if (attributes != null) this.attribute(attributes);
				if (parent.type === NodeType.Document) {
					this.isRoot = true;
					this.documentObject = parent;
					parent.rootObject = this;
					if (parent.children) {
						ref1 = parent.children;
						for (j$1 = 0, len$1 = ref1.length; j$1 < len$1; j$1++) {
							child = ref1[j$1];
							if (child.type === NodeType.DocType) {
								child.name = this.name;
								break;
							}
						}
					}
				}
			}
			Object.defineProperty(XMLElement.prototype, "tagName", { get: function() {
				return this.name;
			} });
			Object.defineProperty(XMLElement.prototype, "namespaceURI", { get: function() {
				return "";
			} });
			Object.defineProperty(XMLElement.prototype, "prefix", { get: function() {
				return "";
			} });
			Object.defineProperty(XMLElement.prototype, "localName", { get: function() {
				return this.name;
			} });
			Object.defineProperty(XMLElement.prototype, "id", { get: function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			} });
			Object.defineProperty(XMLElement.prototype, "className", { get: function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			} });
			Object.defineProperty(XMLElement.prototype, "classList", { get: function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			} });
			Object.defineProperty(XMLElement.prototype, "attributes", { get: function() {
				if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new XMLNamedNodeMap(this.attribs);
				return this.attributeMap;
			} });
			XMLElement.prototype.clone = function() {
				var att, attName, clonedSelf = Object.create(this), ref1;
				if (clonedSelf.isRoot) clonedSelf.documentObject = null;
				clonedSelf.attribs = {};
				ref1 = this.attribs;
				for (attName in ref1) {
					if (!hasProp.call(ref1, attName)) continue;
					att = ref1[attName];
					clonedSelf.attribs[attName] = att.clone();
				}
				clonedSelf.children = [];
				this.children.forEach(function(child) {
					var clonedChild = child.clone();
					clonedChild.parent = clonedSelf;
					return clonedSelf.children.push(clonedChild);
				});
				return clonedSelf;
			};
			XMLElement.prototype.attribute = function(name, value) {
				var attName, attValue;
				if (name != null) name = getValue(name);
				if (isObject$8(name)) for (attName in name) {
					if (!hasProp.call(name, attName)) continue;
					attValue = name[attName];
					this.attribute(attName, attValue);
				}
				else {
					if (isFunction$2(value)) value = value.apply();
					if (this.options.keepNullAttributes && value == null) this.attribs[name] = new XMLAttribute(this, name, "");
					else if (value != null) this.attribs[name] = new XMLAttribute(this, name, value);
				}
				return this;
			};
			XMLElement.prototype.removeAttribute = function(name) {
				var attName, j$1, len$1;
				if (name == null) throw new Error("Missing attribute name. " + this.debugInfo());
				name = getValue(name);
				if (Array.isArray(name)) for (j$1 = 0, len$1 = name.length; j$1 < len$1; j$1++) {
					attName = name[j$1];
					delete this.attribs[attName];
				}
				else delete this.attribs[name];
				return this;
			};
			XMLElement.prototype.toString = function(options) {
				return this.options.writer.element(this, this.options.writer.filterOptions(options));
			};
			XMLElement.prototype.att = function(name, value) {
				return this.attribute(name, value);
			};
			XMLElement.prototype.a = function(name, value) {
				return this.attribute(name, value);
			};
			XMLElement.prototype.getAttribute = function(name) {
				if (this.attribs.hasOwnProperty(name)) return this.attribs[name].value;
				else return null;
			};
			XMLElement.prototype.setAttribute = function(name, value) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getAttributeNode = function(name) {
				if (this.attribs.hasOwnProperty(name)) return this.attribs[name];
				else return null;
			};
			XMLElement.prototype.setAttributeNode = function(newAttr) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.removeAttributeNode = function(oldAttr) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getElementsByTagName = function(name) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.hasAttribute = function(name) {
				return this.attribs.hasOwnProperty(name);
			};
			XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.setIdAttribute = function(name, isId) {
				if (this.attribs.hasOwnProperty(name)) return this.attribs[name].isId;
				else return isId;
			};
			XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getElementsByTagName = function(tagname) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.getElementsByClassName = function(classNames) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLElement.prototype.isEqualNode = function(node) {
				var i$2, j$1, ref1;
				if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
				if (node.namespaceURI !== this.namespaceURI) return false;
				if (node.prefix !== this.prefix) return false;
				if (node.localName !== this.localName) return false;
				if (node.attribs.length !== this.attribs.length) return false;
				for (i$2 = j$1 = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j$1 <= ref1 : j$1 >= ref1; i$2 = 0 <= ref1 ? ++j$1 : --j$1) if (!this.attribs[i$2].isEqualNode(node.attribs[i$2])) return false;
				return true;
			};
			return XMLElement;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLCharacterData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLNode = require_XMLNode();
		module.exports = (function(superClass) {
			extend$1(XMLCharacterData, superClass);
			function XMLCharacterData(parent) {
				XMLCharacterData.__super__.constructor.call(this, parent);
				this.value = "";
			}
			Object.defineProperty(XMLCharacterData.prototype, "data", {
				get: function() {
					return this.value;
				},
				set: function(value) {
					return this.value = value || "";
				}
			});
			Object.defineProperty(XMLCharacterData.prototype, "length", { get: function() {
				return this.value.length;
			} });
			Object.defineProperty(XMLCharacterData.prototype, "textContent", {
				get: function() {
					return this.value;
				},
				set: function(value) {
					return this.value = value || "";
				}
			});
			XMLCharacterData.prototype.clone = function() {
				return Object.create(this);
			};
			XMLCharacterData.prototype.substringData = function(offset$1, count) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLCharacterData.prototype.appendData = function(arg) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLCharacterData.prototype.insertData = function(offset$1, arg) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLCharacterData.prototype.deleteData = function(offset$1, count) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLCharacterData.prototype.replaceData = function(offset$1, count, arg) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLCharacterData.prototype.isEqualNode = function(node) {
				if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
				if (node.data !== this.data) return false;
				return true;
			};
			return XMLCharacterData;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLCData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLCharacterData, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLCharacterData = require_XMLCharacterData();
		module.exports = (function(superClass) {
			extend$1(XMLCData, superClass);
			function XMLCData(parent, text) {
				XMLCData.__super__.constructor.call(this, parent);
				if (text == null) throw new Error("Missing CDATA text. " + this.debugInfo());
				this.name = "#cdata-section";
				this.type = NodeType.CData;
				this.value = this.stringify.cdata(text);
			}
			XMLCData.prototype.clone = function() {
				return Object.create(this);
			};
			XMLCData.prototype.toString = function(options) {
				return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
			};
			return XMLCData;
		})(XMLCharacterData);
	}).call(exports);
}));
var require_XMLComment = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLCharacterData, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLCharacterData = require_XMLCharacterData();
		module.exports = (function(superClass) {
			extend$1(XMLComment, superClass);
			function XMLComment(parent, text) {
				XMLComment.__super__.constructor.call(this, parent);
				if (text == null) throw new Error("Missing comment text. " + this.debugInfo());
				this.name = "#comment";
				this.type = NodeType.Comment;
				this.value = this.stringify.comment(text);
			}
			XMLComment.prototype.clone = function() {
				return Object.create(this);
			};
			XMLComment.prototype.toString = function(options) {
				return this.options.writer.comment(this, this.options.writer.filterOptions(options));
			};
			return XMLComment;
		})(XMLCharacterData);
	}).call(exports);
}));
var require_XMLDeclaration = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, isObject$8, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		isObject$8 = require_Utility().isObject;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDeclaration, superClass);
			function XMLDeclaration(parent, version, encoding, standalone) {
				var ref;
				XMLDeclaration.__super__.constructor.call(this, parent);
				if (isObject$8(version)) ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
				if (!version) version = "1.0";
				this.type = NodeType.Declaration;
				this.version = this.stringify.xmlVersion(version);
				if (encoding != null) this.encoding = this.stringify.xmlEncoding(encoding);
				if (standalone != null) this.standalone = this.stringify.xmlStandalone(standalone);
			}
			XMLDeclaration.prototype.toString = function(options) {
				return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
			};
			return XMLDeclaration;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDTDAttList = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDTDAttList, superClass);
			function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
				XMLDTDAttList.__super__.constructor.call(this, parent);
				if (elementName == null) throw new Error("Missing DTD element name. " + this.debugInfo());
				if (attributeName == null) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
				if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
				if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
				if (defaultValueType.indexOf("#") !== 0) defaultValueType = "#" + defaultValueType;
				if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
				if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
				this.elementName = this.stringify.name(elementName);
				this.type = NodeType.AttributeDeclaration;
				this.attributeName = this.stringify.name(attributeName);
				this.attributeType = this.stringify.dtdAttType(attributeType);
				if (defaultValue) this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
				this.defaultValueType = defaultValueType;
			}
			XMLDTDAttList.prototype.toString = function(options) {
				return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
			};
			return XMLDTDAttList;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDTDEntity = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, isObject$8, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		isObject$8 = require_Utility().isObject;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDTDEntity, superClass);
			function XMLDTDEntity(parent, pe, name, value) {
				XMLDTDEntity.__super__.constructor.call(this, parent);
				if (name == null) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
				if (value == null) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
				this.pe = !!pe;
				this.name = this.stringify.name(name);
				this.type = NodeType.EntityDeclaration;
				if (!isObject$8(value)) {
					this.value = this.stringify.dtdEntityValue(value);
					this.internal = true;
				} else {
					if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
					if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
					this.internal = false;
					if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
					if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
					if (value.nData != null) this.nData = this.stringify.dtdNData(value.nData);
					if (this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
				}
			}
			Object.defineProperty(XMLDTDEntity.prototype, "publicId", { get: function() {
				return this.pubID;
			} });
			Object.defineProperty(XMLDTDEntity.prototype, "systemId", { get: function() {
				return this.sysID;
			} });
			Object.defineProperty(XMLDTDEntity.prototype, "notationName", { get: function() {
				return this.nData || null;
			} });
			Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", { get: function() {
				return null;
			} });
			XMLDTDEntity.prototype.toString = function(options) {
				return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
			};
			return XMLDTDEntity;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDTDElement = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDTDElement, superClass);
			function XMLDTDElement(parent, name, value) {
				XMLDTDElement.__super__.constructor.call(this, parent);
				if (name == null) throw new Error("Missing DTD element name. " + this.debugInfo());
				if (!value) value = "(#PCDATA)";
				if (Array.isArray(value)) value = "(" + value.join(",") + ")";
				this.name = this.stringify.name(name);
				this.type = NodeType.ElementDeclaration;
				this.value = this.stringify.dtdElementValue(value);
			}
			XMLDTDElement.prototype.toString = function(options) {
				return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
			};
			return XMLDTDElement;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDTDNotation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDTDNotation, superClass);
			function XMLDTDNotation(parent, name, value) {
				XMLDTDNotation.__super__.constructor.call(this, parent);
				if (name == null) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
				if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
				this.name = this.stringify.name(name);
				this.type = NodeType.NotationDeclaration;
				if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
				if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
			}
			Object.defineProperty(XMLDTDNotation.prototype, "publicId", { get: function() {
				return this.pubID;
			} });
			Object.defineProperty(XMLDTDNotation.prototype, "systemId", { get: function() {
				return this.sysID;
			} });
			XMLDTDNotation.prototype.toString = function(options) {
				return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
			};
			return XMLDTDNotation;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDocType = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject$8, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		isObject$8 = require_Utility().isObject;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		XMLDTDAttList = require_XMLDTDAttList();
		XMLDTDEntity = require_XMLDTDEntity();
		XMLDTDElement = require_XMLDTDElement();
		XMLDTDNotation = require_XMLDTDNotation();
		XMLNamedNodeMap = require_XMLNamedNodeMap();
		module.exports = (function(superClass) {
			extend$1(XMLDocType, superClass);
			function XMLDocType(parent, pubID, sysID) {
				var child, i$2, len$1, ref, ref1, ref2;
				XMLDocType.__super__.constructor.call(this, parent);
				this.type = NodeType.DocType;
				if (parent.children) {
					ref = parent.children;
					for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
						child = ref[i$2];
						if (child.type === NodeType.Element) {
							this.name = child.name;
							break;
						}
					}
				}
				this.documentObject = parent;
				if (isObject$8(pubID)) ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
				if (sysID == null) ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
				if (pubID != null) this.pubID = this.stringify.dtdPubID(pubID);
				if (sysID != null) this.sysID = this.stringify.dtdSysID(sysID);
			}
			Object.defineProperty(XMLDocType.prototype, "entities", { get: function() {
				var child, i$2, len$1, nodes = {}, ref = this.children;
				for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
					child = ref[i$2];
					if (child.type === NodeType.EntityDeclaration && !child.pe) nodes[child.name] = child;
				}
				return new XMLNamedNodeMap(nodes);
			} });
			Object.defineProperty(XMLDocType.prototype, "notations", { get: function() {
				var child, i$2, len$1, nodes = {}, ref = this.children;
				for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
					child = ref[i$2];
					if (child.type === NodeType.NotationDeclaration) nodes[child.name] = child;
				}
				return new XMLNamedNodeMap(nodes);
			} });
			Object.defineProperty(XMLDocType.prototype, "publicId", { get: function() {
				return this.pubID;
			} });
			Object.defineProperty(XMLDocType.prototype, "systemId", { get: function() {
				return this.sysID;
			} });
			Object.defineProperty(XMLDocType.prototype, "internalSubset", { get: function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			} });
			XMLDocType.prototype.element = function(name, value) {
				var child = new XMLDTDElement(this, name, value);
				this.children.push(child);
				return this;
			};
			XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
				var child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
				this.children.push(child);
				return this;
			};
			XMLDocType.prototype.entity = function(name, value) {
				var child = new XMLDTDEntity(this, false, name, value);
				this.children.push(child);
				return this;
			};
			XMLDocType.prototype.pEntity = function(name, value) {
				var child = new XMLDTDEntity(this, true, name, value);
				this.children.push(child);
				return this;
			};
			XMLDocType.prototype.notation = function(name, value) {
				var child = new XMLDTDNotation(this, name, value);
				this.children.push(child);
				return this;
			};
			XMLDocType.prototype.toString = function(options) {
				return this.options.writer.docType(this, this.options.writer.filterOptions(options));
			};
			XMLDocType.prototype.ele = function(name, value) {
				return this.element(name, value);
			};
			XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
				return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
			};
			XMLDocType.prototype.ent = function(name, value) {
				return this.entity(name, value);
			};
			XMLDocType.prototype.pent = function(name, value) {
				return this.pEntity(name, value);
			};
			XMLDocType.prototype.not = function(name, value) {
				return this.notation(name, value);
			};
			XMLDocType.prototype.up = function() {
				return this.root() || this.documentObject;
			};
			XMLDocType.prototype.isEqualNode = function(node) {
				if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
				if (node.name !== this.name) return false;
				if (node.publicId !== this.publicId) return false;
				if (node.systemId !== this.systemId) return false;
				return true;
			};
			return XMLDocType;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLRaw = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLNode = require_XMLNode();
		module.exports = (function(superClass) {
			extend$1(XMLRaw, superClass);
			function XMLRaw(parent, text) {
				XMLRaw.__super__.constructor.call(this, parent);
				if (text == null) throw new Error("Missing raw text. " + this.debugInfo());
				this.type = NodeType.Raw;
				this.value = this.stringify.raw(text);
			}
			XMLRaw.prototype.clone = function() {
				return Object.create(this);
			};
			XMLRaw.prototype.toString = function(options) {
				return this.options.writer.raw(this, this.options.writer.filterOptions(options));
			};
			return XMLRaw;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLText = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLCharacterData, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLCharacterData = require_XMLCharacterData();
		module.exports = (function(superClass) {
			extend$1(XMLText, superClass);
			function XMLText(parent, text) {
				XMLText.__super__.constructor.call(this, parent);
				if (text == null) throw new Error("Missing element text. " + this.debugInfo());
				this.name = "#text";
				this.type = NodeType.Text;
				this.value = this.stringify.text(text);
			}
			Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", { get: function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			} });
			Object.defineProperty(XMLText.prototype, "wholeText", { get: function() {
				var next, prev, str = "";
				prev = this.previousSibling;
				while (prev) {
					str = prev.data + str;
					prev = prev.previousSibling;
				}
				str += this.data;
				next = this.nextSibling;
				while (next) {
					str = str + next.data;
					next = next.nextSibling;
				}
				return str;
			} });
			XMLText.prototype.clone = function() {
				return Object.create(this);
			};
			XMLText.prototype.toString = function(options) {
				return this.options.writer.text(this, this.options.writer.filterOptions(options));
			};
			XMLText.prototype.splitText = function(offset$1) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLText.prototype.replaceWholeText = function(content) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			return XMLText;
		})(XMLCharacterData);
	}).call(exports);
}));
var require_XMLProcessingInstruction = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLCharacterData, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLCharacterData = require_XMLCharacterData();
		module.exports = (function(superClass) {
			extend$1(XMLProcessingInstruction, superClass);
			function XMLProcessingInstruction(parent, target, value) {
				XMLProcessingInstruction.__super__.constructor.call(this, parent);
				if (target == null) throw new Error("Missing instruction target. " + this.debugInfo());
				this.type = NodeType.ProcessingInstruction;
				this.target = this.stringify.insTarget(target);
				this.name = this.target;
				if (value) this.value = this.stringify.insValue(value);
			}
			XMLProcessingInstruction.prototype.clone = function() {
				return Object.create(this);
			};
			XMLProcessingInstruction.prototype.toString = function(options) {
				return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
			};
			XMLProcessingInstruction.prototype.isEqualNode = function(node) {
				if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
				if (node.target !== this.target) return false;
				return true;
			};
			return XMLProcessingInstruction;
		})(XMLCharacterData);
	}).call(exports);
}));
var require_XMLDummy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLNode, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		module.exports = (function(superClass) {
			extend$1(XMLDummy, superClass);
			function XMLDummy(parent) {
				XMLDummy.__super__.constructor.call(this, parent);
				this.type = NodeType.Dummy;
			}
			XMLDummy.prototype.clone = function() {
				return Object.create(this);
			};
			XMLDummy.prototype.toString = function(options) {
				return "";
			};
			return XMLDummy;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLNodeList = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = (function() {
			function XMLNodeList(nodes) {
				this.nodes = nodes;
			}
			Object.defineProperty(XMLNodeList.prototype, "length", { get: function() {
				return this.nodes.length || 0;
			} });
			XMLNodeList.prototype.clone = function() {
				return this.nodes = null;
			};
			XMLNodeList.prototype.item = function(index) {
				return this.nodes[index] || null;
			};
			return XMLNodeList;
		})();
	}).call(exports);
}));
var require_DocumentPosition = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = {
			Disconnected: 1,
			Preceding: 2,
			Following: 4,
			Contains: 8,
			ContainedBy: 16,
			ImplementationSpecific: 32
		};
	}).call(exports);
}));
var require_XMLNode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty$5, isFunction$2, isObject$8, ref1, hasProp = {}.hasOwnProperty;
		ref1 = require_Utility(), isObject$8 = ref1.isObject, isFunction$2 = ref1.isFunction, isEmpty$5 = ref1.isEmpty, getValue = ref1.getValue;
		XMLElement = null;
		XMLCData = null;
		XMLComment = null;
		XMLDeclaration = null;
		XMLDocType = null;
		XMLRaw = null;
		XMLText = null;
		XMLProcessingInstruction = null;
		XMLDummy = null;
		NodeType = null;
		XMLNodeList = null;
		DocumentPosition = null;
		module.exports = (function() {
			function XMLNode(parent1) {
				this.parent = parent1;
				if (this.parent) {
					this.options = this.parent.options;
					this.stringify = this.parent.stringify;
				}
				this.value = null;
				this.children = [];
				this.baseURI = null;
				if (!XMLElement) {
					XMLElement = require_XMLElement();
					XMLCData = require_XMLCData();
					XMLComment = require_XMLComment();
					XMLDeclaration = require_XMLDeclaration();
					XMLDocType = require_XMLDocType();
					XMLRaw = require_XMLRaw();
					XMLText = require_XMLText();
					XMLProcessingInstruction = require_XMLProcessingInstruction();
					XMLDummy = require_XMLDummy();
					NodeType = require_NodeType();
					XMLNodeList = require_XMLNodeList();
					require_XMLNamedNodeMap();
					DocumentPosition = require_DocumentPosition();
				}
			}
			Object.defineProperty(XMLNode.prototype, "nodeName", { get: function() {
				return this.name;
			} });
			Object.defineProperty(XMLNode.prototype, "nodeType", { get: function() {
				return this.type;
			} });
			Object.defineProperty(XMLNode.prototype, "nodeValue", { get: function() {
				return this.value;
			} });
			Object.defineProperty(XMLNode.prototype, "parentNode", { get: function() {
				return this.parent;
			} });
			Object.defineProperty(XMLNode.prototype, "childNodes", { get: function() {
				if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new XMLNodeList(this.children);
				return this.childNodeList;
			} });
			Object.defineProperty(XMLNode.prototype, "firstChild", { get: function() {
				return this.children[0] || null;
			} });
			Object.defineProperty(XMLNode.prototype, "lastChild", { get: function() {
				return this.children[this.children.length - 1] || null;
			} });
			Object.defineProperty(XMLNode.prototype, "previousSibling", { get: function() {
				var i$2 = this.parent.children.indexOf(this);
				return this.parent.children[i$2 - 1] || null;
			} });
			Object.defineProperty(XMLNode.prototype, "nextSibling", { get: function() {
				var i$2 = this.parent.children.indexOf(this);
				return this.parent.children[i$2 + 1] || null;
			} });
			Object.defineProperty(XMLNode.prototype, "ownerDocument", { get: function() {
				return this.document() || null;
			} });
			Object.defineProperty(XMLNode.prototype, "textContent", {
				get: function() {
					var child, j$1, len$1, ref2, str;
					if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
						str = "";
						ref2 = this.children;
						for (j$1 = 0, len$1 = ref2.length; j$1 < len$1; j$1++) {
							child = ref2[j$1];
							if (child.textContent) str += child.textContent;
						}
						return str;
					} else return null;
				},
				set: function(value) {
					throw new Error("This DOM method is not implemented." + this.debugInfo());
				}
			});
			XMLNode.prototype.setParent = function(parent) {
				var child, j$1, len$1, ref2, results;
				this.parent = parent;
				if (parent) {
					this.options = parent.options;
					this.stringify = parent.stringify;
				}
				ref2 = this.children;
				results = [];
				for (j$1 = 0, len$1 = ref2.length; j$1 < len$1; j$1++) {
					child = ref2[j$1];
					results.push(child.setParent(this));
				}
				return results;
			};
			XMLNode.prototype.element = function(name, attributes, text) {
				var childNode, item, j$1, k$1, key, lastChild = null, len$1, len1, ref2, ref3, val;
				if (attributes === null && text == null) ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
				if (attributes == null) attributes = {};
				attributes = getValue(attributes);
				if (!isObject$8(attributes)) ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
				if (name != null) name = getValue(name);
				if (Array.isArray(name)) for (j$1 = 0, len$1 = name.length; j$1 < len$1; j$1++) {
					item = name[j$1];
					lastChild = this.element(item);
				}
				else if (isFunction$2(name)) lastChild = this.element(name.apply());
				else if (isObject$8(name)) for (key in name) {
					if (!hasProp.call(name, key)) continue;
					val = name[key];
					if (isFunction$2(val)) val = val.apply();
					if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
					else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty$5(val)) lastChild = this.dummy();
					else if (isObject$8(val) && isEmpty$5(val)) lastChild = this.element(key);
					else if (!this.options.keepNullNodes && val == null) lastChild = this.dummy();
					else if (!this.options.separateArrayItems && Array.isArray(val)) for (k$1 = 0, len1 = val.length; k$1 < len1; k$1++) {
						item = val[k$1];
						childNode = {};
						childNode[key] = item;
						lastChild = this.element(childNode);
					}
					else if (isObject$8(val)) if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.element(val);
					else {
						lastChild = this.element(key);
						lastChild.element(val);
					}
					else lastChild = this.element(key, val);
				}
				else if (!this.options.keepNullNodes && text === null) lastChild = this.dummy();
				else if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.text(text);
				else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) lastChild = this.cdata(text);
				else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) lastChild = this.comment(text);
				else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) lastChild = this.raw(text);
				else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
				else lastChild = this.node(name, attributes, text);
				if (lastChild == null) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
				return lastChild;
			};
			XMLNode.prototype.insertBefore = function(name, attributes, text) {
				var child, i$2, newChild, refChild, removed;
				if (name != null ? name.type : void 0) {
					newChild = name;
					refChild = attributes;
					newChild.setParent(this);
					if (refChild) {
						i$2 = children.indexOf(refChild);
						removed = children.splice(i$2);
						children.push(newChild);
						Array.prototype.push.apply(children, removed);
					} else children.push(newChild);
					return newChild;
				} else {
					if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
					i$2 = this.parent.children.indexOf(this);
					removed = this.parent.children.splice(i$2);
					child = this.parent.element(name, attributes, text);
					Array.prototype.push.apply(this.parent.children, removed);
					return child;
				}
			};
			XMLNode.prototype.insertAfter = function(name, attributes, text) {
				var child, i$2, removed;
				if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
				i$2 = this.parent.children.indexOf(this);
				removed = this.parent.children.splice(i$2 + 1);
				child = this.parent.element(name, attributes, text);
				Array.prototype.push.apply(this.parent.children, removed);
				return child;
			};
			XMLNode.prototype.remove = function() {
				var i$2;
				if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
				i$2 = this.parent.children.indexOf(this);
				[].splice.apply(this.parent.children, [i$2, i$2 - i$2 + 1].concat([]));
				return this.parent;
			};
			XMLNode.prototype.node = function(name, attributes, text) {
				var child, ref2;
				if (name != null) name = getValue(name);
				attributes || (attributes = {});
				attributes = getValue(attributes);
				if (!isObject$8(attributes)) ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
				child = new XMLElement(this, name, attributes);
				if (text != null) child.text(text);
				this.children.push(child);
				return child;
			};
			XMLNode.prototype.text = function(value) {
				var child;
				if (isObject$8(value)) this.element(value);
				child = new XMLText(this, value);
				this.children.push(child);
				return this;
			};
			XMLNode.prototype.cdata = function(value) {
				var child = new XMLCData(this, value);
				this.children.push(child);
				return this;
			};
			XMLNode.prototype.comment = function(value) {
				var child = new XMLComment(this, value);
				this.children.push(child);
				return this;
			};
			XMLNode.prototype.commentBefore = function(value) {
				var i$2 = this.parent.children.indexOf(this), removed = this.parent.children.splice(i$2);
				this.parent.comment(value);
				Array.prototype.push.apply(this.parent.children, removed);
				return this;
			};
			XMLNode.prototype.commentAfter = function(value) {
				var i$2 = this.parent.children.indexOf(this), removed = this.parent.children.splice(i$2 + 1);
				this.parent.comment(value);
				Array.prototype.push.apply(this.parent.children, removed);
				return this;
			};
			XMLNode.prototype.raw = function(value) {
				var child = new XMLRaw(this, value);
				this.children.push(child);
				return this;
			};
			XMLNode.prototype.dummy = function() {
				return new XMLDummy(this);
			};
			XMLNode.prototype.instruction = function(target, value) {
				var insTarget, insValue, instruction, j$1, len$1;
				if (target != null) target = getValue(target);
				if (value != null) value = getValue(value);
				if (Array.isArray(target)) for (j$1 = 0, len$1 = target.length; j$1 < len$1; j$1++) {
					insTarget = target[j$1];
					this.instruction(insTarget);
				}
				else if (isObject$8(target)) for (insTarget in target) {
					if (!hasProp.call(target, insTarget)) continue;
					insValue = target[insTarget];
					this.instruction(insTarget, insValue);
				}
				else {
					if (isFunction$2(value)) value = value.apply();
					instruction = new XMLProcessingInstruction(this, target, value);
					this.children.push(instruction);
				}
				return this;
			};
			XMLNode.prototype.instructionBefore = function(target, value) {
				var i$2 = this.parent.children.indexOf(this), removed = this.parent.children.splice(i$2);
				this.parent.instruction(target, value);
				Array.prototype.push.apply(this.parent.children, removed);
				return this;
			};
			XMLNode.prototype.instructionAfter = function(target, value) {
				var i$2 = this.parent.children.indexOf(this), removed = this.parent.children.splice(i$2 + 1);
				this.parent.instruction(target, value);
				Array.prototype.push.apply(this.parent.children, removed);
				return this;
			};
			XMLNode.prototype.declaration = function(version, encoding, standalone) {
				var doc = this.document(), xmldec = new XMLDeclaration(doc, version, encoding, standalone);
				if (doc.children.length === 0) doc.children.unshift(xmldec);
				else if (doc.children[0].type === NodeType.Declaration) doc.children[0] = xmldec;
				else doc.children.unshift(xmldec);
				return doc.root() || doc;
			};
			XMLNode.prototype.dtd = function(pubID, sysID) {
				var child, doc = this.document(), doctype = new XMLDocType(doc, pubID, sysID), i$2, j$1, k$1, len$1, len1, ref2 = doc.children, ref3;
				for (i$2 = j$1 = 0, len$1 = ref2.length; j$1 < len$1; i$2 = ++j$1) {
					child = ref2[i$2];
					if (child.type === NodeType.DocType) {
						doc.children[i$2] = doctype;
						return doctype;
					}
				}
				ref3 = doc.children;
				for (i$2 = k$1 = 0, len1 = ref3.length; k$1 < len1; i$2 = ++k$1) {
					child = ref3[i$2];
					if (child.isRoot) {
						doc.children.splice(i$2, 0, doctype);
						return doctype;
					}
				}
				doc.children.push(doctype);
				return doctype;
			};
			XMLNode.prototype.up = function() {
				if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
				return this.parent;
			};
			XMLNode.prototype.root = function() {
				var node = this;
				while (node) if (node.type === NodeType.Document) return node.rootObject;
				else if (node.isRoot) return node;
				else node = node.parent;
			};
			XMLNode.prototype.document = function() {
				var node = this;
				while (node) if (node.type === NodeType.Document) return node;
				else node = node.parent;
			};
			XMLNode.prototype.end = function(options) {
				return this.document().end(options);
			};
			XMLNode.prototype.prev = function() {
				var i$2 = this.parent.children.indexOf(this);
				if (i$2 < 1) throw new Error("Already at the first node. " + this.debugInfo());
				return this.parent.children[i$2 - 1];
			};
			XMLNode.prototype.next = function() {
				var i$2 = this.parent.children.indexOf(this);
				if (i$2 === -1 || i$2 === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
				return this.parent.children[i$2 + 1];
			};
			XMLNode.prototype.importDocument = function(doc) {
				var clonedRoot = doc.root().clone();
				clonedRoot.parent = this;
				clonedRoot.isRoot = false;
				this.children.push(clonedRoot);
				return this;
			};
			XMLNode.prototype.debugInfo = function(name) {
				var ref2, ref3;
				name = name || this.name;
				if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) return "";
				else if (name == null) return "parent: <" + this.parent.name + ">";
				else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) return "node: <" + name + ">";
				else return "node: <" + name + ">, parent: <" + this.parent.name + ">";
			};
			XMLNode.prototype.ele = function(name, attributes, text) {
				return this.element(name, attributes, text);
			};
			XMLNode.prototype.nod = function(name, attributes, text) {
				return this.node(name, attributes, text);
			};
			XMLNode.prototype.txt = function(value) {
				return this.text(value);
			};
			XMLNode.prototype.dat = function(value) {
				return this.cdata(value);
			};
			XMLNode.prototype.com = function(value) {
				return this.comment(value);
			};
			XMLNode.prototype.ins = function(target, value) {
				return this.instruction(target, value);
			};
			XMLNode.prototype.doc = function() {
				return this.document();
			};
			XMLNode.prototype.dec = function(version, encoding, standalone) {
				return this.declaration(version, encoding, standalone);
			};
			XMLNode.prototype.e = function(name, attributes, text) {
				return this.element(name, attributes, text);
			};
			XMLNode.prototype.n = function(name, attributes, text) {
				return this.node(name, attributes, text);
			};
			XMLNode.prototype.t = function(value) {
				return this.text(value);
			};
			XMLNode.prototype.d = function(value) {
				return this.cdata(value);
			};
			XMLNode.prototype.c = function(value) {
				return this.comment(value);
			};
			XMLNode.prototype.r = function(value) {
				return this.raw(value);
			};
			XMLNode.prototype.i = function(target, value) {
				return this.instruction(target, value);
			};
			XMLNode.prototype.u = function() {
				return this.up();
			};
			XMLNode.prototype.importXMLBuilder = function(doc) {
				return this.importDocument(doc);
			};
			XMLNode.prototype.replaceChild = function(newChild, oldChild) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.removeChild = function(oldChild) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.appendChild = function(newChild) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.hasChildNodes = function() {
				return this.children.length !== 0;
			};
			XMLNode.prototype.cloneNode = function(deep) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.normalize = function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.isSupported = function(feature, version) {
				return true;
			};
			XMLNode.prototype.hasAttributes = function() {
				return this.attribs.length !== 0;
			};
			XMLNode.prototype.compareDocumentPosition = function(other) {
				var ref = this, res;
				if (ref === other) return 0;
				else if (this.document() !== other.document()) {
					res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
					if (Math.random() < .5) res |= DocumentPosition.Preceding;
					else res |= DocumentPosition.Following;
					return res;
				} else if (ref.isAncestor(other)) return DocumentPosition.Contains | DocumentPosition.Preceding;
				else if (ref.isDescendant(other)) return DocumentPosition.Contains | DocumentPosition.Following;
				else if (ref.isPreceding(other)) return DocumentPosition.Preceding;
				else return DocumentPosition.Following;
			};
			XMLNode.prototype.isSameNode = function(other) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.lookupPrefix = function(namespaceURI) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.lookupNamespaceURI = function(prefix) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.isEqualNode = function(node) {
				var i$2, j$1, ref2;
				if (node.nodeType !== this.nodeType) return false;
				if (node.children.length !== this.children.length) return false;
				for (i$2 = j$1 = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j$1 <= ref2 : j$1 >= ref2; i$2 = 0 <= ref2 ? ++j$1 : --j$1) if (!this.children[i$2].isEqualNode(node.children[i$2])) return false;
				return true;
			};
			XMLNode.prototype.getFeature = function(feature, version) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.setUserData = function(key, data, handler) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.getUserData = function(key) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLNode.prototype.contains = function(other) {
				if (!other) return false;
				return other === this || this.isDescendant(other);
			};
			XMLNode.prototype.isDescendant = function(node) {
				var child, isDescendantChild, j$1, len$1, ref2 = this.children;
				for (j$1 = 0, len$1 = ref2.length; j$1 < len$1; j$1++) {
					child = ref2[j$1];
					if (node === child) return true;
					isDescendantChild = child.isDescendant(node);
					if (isDescendantChild) return true;
				}
				return false;
			};
			XMLNode.prototype.isAncestor = function(node) {
				return node.isDescendant(this);
			};
			XMLNode.prototype.isPreceding = function(node) {
				var nodePos = this.treePosition(node), thisPos = this.treePosition(this);
				if (nodePos === -1 || thisPos === -1) return false;
				else return nodePos < thisPos;
			};
			XMLNode.prototype.isFollowing = function(node) {
				var nodePos = this.treePosition(node), thisPos = this.treePosition(this);
				if (nodePos === -1 || thisPos === -1) return false;
				else return nodePos > thisPos;
			};
			XMLNode.prototype.treePosition = function(node) {
				var found, pos = 0;
				found = false;
				this.foreachTreeNode(this.document(), function(childNode) {
					pos++;
					if (!found && childNode === node) return found = true;
				});
				if (found) return pos;
				else return -1;
			};
			XMLNode.prototype.foreachTreeNode = function(node, func) {
				var child, j$1, len$1, ref2, res;
				node || (node = this.document());
				ref2 = node.children;
				for (j$1 = 0, len$1 = ref2.length; j$1 < len$1; j$1++) {
					child = ref2[j$1];
					if (res = func(child)) return res;
					else {
						res = this.foreachTreeNode(child, func);
						if (res) return res;
					}
				}
			};
			return XMLNode;
		})();
	}).call(exports);
}));
var require_XMLStringifier = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var bind$1 = function(fn$1, me) {
			return function() {
				return fn$1.apply(me, arguments);
			};
		}, hasProp = {}.hasOwnProperty;
		module.exports = (function() {
			function XMLStringifier(options) {
				this.assertLegalName = bind$1(this.assertLegalName, this);
				this.assertLegalChar = bind$1(this.assertLegalChar, this);
				var key, ref, value;
				options || (options = {});
				this.options = options;
				if (!this.options.version) this.options.version = "1.0";
				ref = options.stringify || {};
				for (key in ref) {
					if (!hasProp.call(ref, key)) continue;
					value = ref[key];
					this[key] = value;
				}
			}
			XMLStringifier.prototype.name = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalName("" + val || "");
			};
			XMLStringifier.prototype.text = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar(this.textEscape("" + val || ""));
			};
			XMLStringifier.prototype.cdata = function(val) {
				if (this.options.noValidation) return val;
				val = "" + val || "";
				val = val.replace("]]>", "]]]]><![CDATA[>");
				return this.assertLegalChar(val);
			};
			XMLStringifier.prototype.comment = function(val) {
				if (this.options.noValidation) return val;
				val = "" + val || "";
				if (val.match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
				return this.assertLegalChar(val);
			};
			XMLStringifier.prototype.raw = function(val) {
				if (this.options.noValidation) return val;
				return "" + val || "";
			};
			XMLStringifier.prototype.attValue = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar(this.attEscape(val = "" + val || ""));
			};
			XMLStringifier.prototype.insTarget = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.insValue = function(val) {
				if (this.options.noValidation) return val;
				val = "" + val || "";
				if (val.match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
				return this.assertLegalChar(val);
			};
			XMLStringifier.prototype.xmlVersion = function(val) {
				if (this.options.noValidation) return val;
				val = "" + val || "";
				if (!val.match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
				return val;
			};
			XMLStringifier.prototype.xmlEncoding = function(val) {
				if (this.options.noValidation) return val;
				val = "" + val || "";
				if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
				return this.assertLegalChar(val);
			};
			XMLStringifier.prototype.xmlStandalone = function(val) {
				if (this.options.noValidation) return val;
				if (val) return "yes";
				else return "no";
			};
			XMLStringifier.prototype.dtdPubID = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdSysID = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdElementValue = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdAttType = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdAttDefault = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdEntityValue = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.dtdNData = function(val) {
				if (this.options.noValidation) return val;
				return this.assertLegalChar("" + val || "");
			};
			XMLStringifier.prototype.convertAttKey = "@";
			XMLStringifier.prototype.convertPIKey = "?";
			XMLStringifier.prototype.convertTextKey = "#text";
			XMLStringifier.prototype.convertCDataKey = "#cdata";
			XMLStringifier.prototype.convertCommentKey = "#comment";
			XMLStringifier.prototype.convertRawKey = "#raw";
			XMLStringifier.prototype.assertLegalChar = function(str) {
				var regex, res;
				if (this.options.noValidation) return str;
				regex = "";
				if (this.options.version === "1.0") {
					regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
					if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
				} else if (this.options.version === "1.1") {
					regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
					if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
				}
				return str;
			};
			XMLStringifier.prototype.assertLegalName = function(str) {
				var regex;
				if (this.options.noValidation) return str;
				this.assertLegalChar(str);
				regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
				if (!str.match(regex)) throw new Error("Invalid character in name");
				return str;
			};
			XMLStringifier.prototype.textEscape = function(str) {
				var ampregex;
				if (this.options.noValidation) return str;
				ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
				return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
			};
			XMLStringifier.prototype.attEscape = function(str) {
				var ampregex;
				if (this.options.noValidation) return str;
				ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
				return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
			};
			return XMLStringifier;
		})();
	}).call(exports);
}));
var require_WriterState = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		module.exports = {
			None: 0,
			OpenTag: 1,
			InsideTag: 2,
			CloseTag: 3
		};
	}).call(exports);
}));
var require_XMLWriterBase = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, WriterState, assign, hasProp = {}.hasOwnProperty;
		assign = require_Utility().assign;
		NodeType = require_NodeType();
		require_XMLDeclaration();
		require_XMLDocType();
		require_XMLCData();
		require_XMLComment();
		require_XMLElement();
		require_XMLRaw();
		require_XMLText();
		require_XMLProcessingInstruction();
		require_XMLDummy();
		require_XMLDTDAttList();
		require_XMLDTDElement();
		require_XMLDTDEntity();
		require_XMLDTDNotation();
		WriterState = require_WriterState();
		module.exports = (function() {
			function XMLWriterBase(options) {
				var key, ref, value;
				options || (options = {});
				this.options = options;
				ref = options.writer || {};
				for (key in ref) {
					if (!hasProp.call(ref, key)) continue;
					value = ref[key];
					this["_" + key] = this[key];
					this[key] = value;
				}
			}
			XMLWriterBase.prototype.filterOptions = function(options) {
				var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
				options || (options = {});
				options = assign({}, this.options, options);
				filteredOptions = { writer: this };
				filteredOptions.pretty = options.pretty || false;
				filteredOptions.allowEmpty = options.allowEmpty || false;
				filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
				filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
				filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
				filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
				filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
				if (filteredOptions.spaceBeforeSlash === true) filteredOptions.spaceBeforeSlash = " ";
				filteredOptions.suppressPrettyCount = 0;
				filteredOptions.user = {};
				filteredOptions.state = WriterState.None;
				return filteredOptions;
			};
			XMLWriterBase.prototype.indent = function(node, options, level) {
				var indentLevel;
				if (!options.pretty || options.suppressPrettyCount) return "";
				else if (options.pretty) {
					indentLevel = (level || 0) + options.offset + 1;
					if (indentLevel > 0) return new Array(indentLevel).join(options.indent);
				}
				return "";
			};
			XMLWriterBase.prototype.endline = function(node, options, level) {
				if (!options.pretty || options.suppressPrettyCount) return "";
				else return options.newline;
			};
			XMLWriterBase.prototype.attribute = function(att, options, level) {
				var r$1;
				this.openAttribute(att, options, level);
				r$1 = " " + att.name + "=\"" + att.value + "\"";
				this.closeAttribute(att, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.cdata = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<![CDATA[";
				options.state = WriterState.InsideTag;
				r$1 += node.value;
				options.state = WriterState.CloseTag;
				r$1 += "]]>" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.comment = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<!-- ";
				options.state = WriterState.InsideTag;
				r$1 += node.value;
				options.state = WriterState.CloseTag;
				r$1 += " -->" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.declaration = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<?xml";
				options.state = WriterState.InsideTag;
				r$1 += " version=\"" + node.version + "\"";
				if (node.encoding != null) r$1 += " encoding=\"" + node.encoding + "\"";
				if (node.standalone != null) r$1 += " standalone=\"" + node.standalone + "\"";
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + "?>";
				r$1 += this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.docType = function(node, options, level) {
				var child, i$2, len$1, r$1, ref;
				level || (level = 0);
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level);
				r$1 += "<!DOCTYPE " + node.root().name;
				if (node.pubID && node.sysID) r$1 += " PUBLIC \"" + node.pubID + "\" \"" + node.sysID + "\"";
				else if (node.sysID) r$1 += " SYSTEM \"" + node.sysID + "\"";
				if (node.children.length > 0) {
					r$1 += " [";
					r$1 += this.endline(node, options, level);
					options.state = WriterState.InsideTag;
					ref = node.children;
					for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
						child = ref[i$2];
						r$1 += this.writeChildNode(child, options, level + 1);
					}
					options.state = WriterState.CloseTag;
					r$1 += "]";
				}
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + ">";
				r$1 += this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.element = function(node, options, level) {
				var att, child, childNodeCount, firstChildNode, i$2, j$1, len$1, len1, name, prettySuppressed, r$1, ref, ref1, ref2;
				level || (level = 0);
				prettySuppressed = false;
				r$1 = "";
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 += this.indent(node, options, level) + "<" + node.name;
				ref = node.attribs;
				for (name in ref) {
					if (!hasProp.call(ref, name)) continue;
					att = ref[name];
					r$1 += this.attribute(att, options, level);
				}
				childNodeCount = node.children.length;
				firstChildNode = childNodeCount === 0 ? null : node.children[0];
				if (childNodeCount === 0 || node.children.every(function(e$1) {
					return (e$1.type === NodeType.Text || e$1.type === NodeType.Raw) && e$1.value === "";
				})) if (options.allowEmpty) {
					r$1 += ">";
					options.state = WriterState.CloseTag;
					r$1 += "</" + node.name + ">" + this.endline(node, options, level);
				} else {
					options.state = WriterState.CloseTag;
					r$1 += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
				}
				else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
					r$1 += ">";
					options.state = WriterState.InsideTag;
					options.suppressPrettyCount++;
					prettySuppressed = true;
					r$1 += this.writeChildNode(firstChildNode, options, level + 1);
					options.suppressPrettyCount--;
					prettySuppressed = false;
					options.state = WriterState.CloseTag;
					r$1 += "</" + node.name + ">" + this.endline(node, options, level);
				} else {
					if (options.dontPrettyTextNodes) {
						ref1 = node.children;
						for (i$2 = 0, len$1 = ref1.length; i$2 < len$1; i$2++) {
							child = ref1[i$2];
							if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
								options.suppressPrettyCount++;
								prettySuppressed = true;
								break;
							}
						}
					}
					r$1 += ">" + this.endline(node, options, level);
					options.state = WriterState.InsideTag;
					ref2 = node.children;
					for (j$1 = 0, len1 = ref2.length; j$1 < len1; j$1++) {
						child = ref2[j$1];
						r$1 += this.writeChildNode(child, options, level + 1);
					}
					options.state = WriterState.CloseTag;
					r$1 += this.indent(node, options, level) + "</" + node.name + ">";
					if (prettySuppressed) options.suppressPrettyCount--;
					r$1 += this.endline(node, options, level);
					options.state = WriterState.None;
				}
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
				switch (node.type) {
					case NodeType.CData: return this.cdata(node, options, level);
					case NodeType.Comment: return this.comment(node, options, level);
					case NodeType.Element: return this.element(node, options, level);
					case NodeType.Raw: return this.raw(node, options, level);
					case NodeType.Text: return this.text(node, options, level);
					case NodeType.ProcessingInstruction: return this.processingInstruction(node, options, level);
					case NodeType.Dummy: return "";
					case NodeType.Declaration: return this.declaration(node, options, level);
					case NodeType.DocType: return this.docType(node, options, level);
					case NodeType.AttributeDeclaration: return this.dtdAttList(node, options, level);
					case NodeType.ElementDeclaration: return this.dtdElement(node, options, level);
					case NodeType.EntityDeclaration: return this.dtdEntity(node, options, level);
					case NodeType.NotationDeclaration: return this.dtdNotation(node, options, level);
					default: throw new Error("Unknown XML node type: " + node.constructor.name);
				}
			};
			XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<?";
				options.state = WriterState.InsideTag;
				r$1 += node.target;
				if (node.value) r$1 += " " + node.value;
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + "?>";
				r$1 += this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.raw = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level);
				options.state = WriterState.InsideTag;
				r$1 += node.value;
				options.state = WriterState.CloseTag;
				r$1 += this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.text = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level);
				options.state = WriterState.InsideTag;
				r$1 += node.value;
				options.state = WriterState.CloseTag;
				r$1 += this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<!ATTLIST";
				options.state = WriterState.InsideTag;
				r$1 += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
				if (node.defaultValueType !== "#DEFAULT") r$1 += " " + node.defaultValueType;
				if (node.defaultValue) r$1 += " \"" + node.defaultValue + "\"";
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.dtdElement = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<!ELEMENT";
				options.state = WriterState.InsideTag;
				r$1 += " " + node.name + " " + node.value;
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<!ENTITY";
				options.state = WriterState.InsideTag;
				if (node.pe) r$1 += " %";
				r$1 += " " + node.name;
				if (node.value) r$1 += " \"" + node.value + "\"";
				else {
					if (node.pubID && node.sysID) r$1 += " PUBLIC \"" + node.pubID + "\" \"" + node.sysID + "\"";
					else if (node.sysID) r$1 += " SYSTEM \"" + node.sysID + "\"";
					if (node.nData) r$1 += " NDATA " + node.nData;
				}
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
				var r$1;
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				r$1 = this.indent(node, options, level) + "<!NOTATION";
				options.state = WriterState.InsideTag;
				r$1 += " " + node.name;
				if (node.pubID && node.sysID) r$1 += " PUBLIC \"" + node.pubID + "\" \"" + node.sysID + "\"";
				else if (node.pubID) r$1 += " PUBLIC \"" + node.pubID + "\"";
				else if (node.sysID) r$1 += " SYSTEM \"" + node.sysID + "\"";
				options.state = WriterState.CloseTag;
				r$1 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
				options.state = WriterState.None;
				this.closeNode(node, options, level);
				return r$1;
			};
			XMLWriterBase.prototype.openNode = function(node, options, level) {};
			XMLWriterBase.prototype.closeNode = function(node, options, level) {};
			XMLWriterBase.prototype.openAttribute = function(att, options, level) {};
			XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};
			return XMLWriterBase;
		})();
	}).call(exports);
}));
var require_XMLStringWriter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var XMLWriterBase, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		XMLWriterBase = require_XMLWriterBase();
		module.exports = (function(superClass) {
			extend$1(XMLStringWriter, superClass);
			function XMLStringWriter(options) {
				XMLStringWriter.__super__.constructor.call(this, options);
			}
			XMLStringWriter.prototype.document = function(doc, options) {
				var child, i$2, len$1, r$1, ref;
				options = this.filterOptions(options);
				r$1 = "";
				ref = doc.children;
				for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
					child = ref[i$2];
					r$1 += this.writeChildNode(child, options, 0);
				}
				if (options.pretty && r$1.slice(-options.newline.length) === options.newline) r$1 = r$1.slice(0, -options.newline.length);
				return r$1;
			};
			return XMLStringWriter;
		})(XMLWriterBase);
	}).call(exports);
}));
var require_XMLDocument = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		isPlainObject = require_Utility().isPlainObject;
		XMLDOMImplementation = require_XMLDOMImplementation();
		XMLDOMConfiguration = require_XMLDOMConfiguration();
		XMLNode = require_XMLNode();
		NodeType = require_NodeType();
		XMLStringifier = require_XMLStringifier();
		XMLStringWriter = require_XMLStringWriter();
		module.exports = (function(superClass) {
			extend$1(XMLDocument, superClass);
			function XMLDocument(options) {
				XMLDocument.__super__.constructor.call(this, null);
				this.name = "#document";
				this.type = NodeType.Document;
				this.documentURI = null;
				this.domConfig = new XMLDOMConfiguration();
				options || (options = {});
				if (!options.writer) options.writer = new XMLStringWriter();
				this.options = options;
				this.stringify = new XMLStringifier(options);
			}
			Object.defineProperty(XMLDocument.prototype, "implementation", { value: new XMLDOMImplementation() });
			Object.defineProperty(XMLDocument.prototype, "doctype", { get: function() {
				var child, i$2, len$1, ref = this.children;
				for (i$2 = 0, len$1 = ref.length; i$2 < len$1; i$2++) {
					child = ref[i$2];
					if (child.type === NodeType.DocType) return child;
				}
				return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "documentElement", { get: function() {
				return this.rootObject || null;
			} });
			Object.defineProperty(XMLDocument.prototype, "inputEncoding", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", { get: function() {
				return false;
			} });
			Object.defineProperty(XMLDocument.prototype, "xmlEncoding", { get: function() {
				if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].encoding;
				else return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "xmlStandalone", { get: function() {
				if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].standalone === "yes";
				else return false;
			} });
			Object.defineProperty(XMLDocument.prototype, "xmlVersion", { get: function() {
				if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].version;
				else return "1.0";
			} });
			Object.defineProperty(XMLDocument.prototype, "URL", { get: function() {
				return this.documentURI;
			} });
			Object.defineProperty(XMLDocument.prototype, "origin", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "compatMode", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "characterSet", { get: function() {
				return null;
			} });
			Object.defineProperty(XMLDocument.prototype, "contentType", { get: function() {
				return null;
			} });
			XMLDocument.prototype.end = function(writer) {
				var writerOptions = {};
				if (!writer) writer = this.options.writer;
				else if (isPlainObject(writer)) {
					writerOptions = writer;
					writer = this.options.writer;
				}
				return writer.document(this, writer.filterOptions(writerOptions));
			};
			XMLDocument.prototype.toString = function(options) {
				return this.options.writer.document(this, this.options.writer.filterOptions(options));
			};
			XMLDocument.prototype.createElement = function(tagName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createDocumentFragment = function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createTextNode = function(data) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createComment = function(data) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createCDATASection = function(data) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createProcessingInstruction = function(target, data) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createAttribute = function(name) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createEntityReference = function(name) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.getElementsByTagName = function(tagname) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.importNode = function(importedNode, deep) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.getElementById = function(elementId) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.adoptNode = function(source) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.normalizeDocument = function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.getElementsByClassName = function(classNames) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createEvent = function(eventInterface) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createRange = function() {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
				throw new Error("This DOM method is not implemented." + this.debugInfo());
			};
			return XMLDocument;
		})(XMLNode);
	}).call(exports);
}));
var require_XMLDocumentCB = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction$2, isObject$8, isPlainObject, ref, hasProp = {}.hasOwnProperty;
		ref = require_Utility(), isObject$8 = ref.isObject, isFunction$2 = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
		NodeType = require_NodeType();
		XMLDocument = require_XMLDocument();
		XMLElement = require_XMLElement();
		XMLCData = require_XMLCData();
		XMLComment = require_XMLComment();
		XMLRaw = require_XMLRaw();
		XMLText = require_XMLText();
		XMLProcessingInstruction = require_XMLProcessingInstruction();
		XMLDeclaration = require_XMLDeclaration();
		XMLDocType = require_XMLDocType();
		XMLDTDAttList = require_XMLDTDAttList();
		XMLDTDEntity = require_XMLDTDEntity();
		XMLDTDElement = require_XMLDTDElement();
		XMLDTDNotation = require_XMLDTDNotation();
		XMLAttribute = require_XMLAttribute();
		XMLStringifier = require_XMLStringifier();
		XMLStringWriter = require_XMLStringWriter();
		WriterState = require_WriterState();
		module.exports = (function() {
			function XMLDocumentCB(options, onData, onEnd) {
				var writerOptions;
				this.name = "?xml";
				this.type = NodeType.Document;
				options || (options = {});
				writerOptions = {};
				if (!options.writer) options.writer = new XMLStringWriter();
				else if (isPlainObject(options.writer)) {
					writerOptions = options.writer;
					options.writer = new XMLStringWriter();
				}
				this.options = options;
				this.writer = options.writer;
				this.writerOptions = this.writer.filterOptions(writerOptions);
				this.stringify = new XMLStringifier(options);
				this.onDataCallback = onData || function() {};
				this.onEndCallback = onEnd || function() {};
				this.currentNode = null;
				this.currentLevel = -1;
				this.openTags = {};
				this.documentStarted = false;
				this.documentCompleted = false;
				this.root = null;
			}
			XMLDocumentCB.prototype.createChildNode = function(node) {
				var att, attName, attributes, child, i$2, len$1, ref1, ref2;
				switch (node.type) {
					case NodeType.CData:
						this.cdata(node.value);
						break;
					case NodeType.Comment:
						this.comment(node.value);
						break;
					case NodeType.Element:
						attributes = {};
						ref1 = node.attribs;
						for (attName in ref1) {
							if (!hasProp.call(ref1, attName)) continue;
							att = ref1[attName];
							attributes[attName] = att.value;
						}
						this.node(node.name, attributes);
						break;
					case NodeType.Dummy:
						this.dummy();
						break;
					case NodeType.Raw:
						this.raw(node.value);
						break;
					case NodeType.Text:
						this.text(node.value);
						break;
					case NodeType.ProcessingInstruction:
						this.instruction(node.target, node.value);
						break;
					default: throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
				}
				ref2 = node.children;
				for (i$2 = 0, len$1 = ref2.length; i$2 < len$1; i$2++) {
					child = ref2[i$2];
					this.createChildNode(child);
					if (child.type === NodeType.Element) this.up();
				}
				return this;
			};
			XMLDocumentCB.prototype.dummy = function() {
				return this;
			};
			XMLDocumentCB.prototype.node = function(name, attributes, text) {
				var ref1;
				if (name == null) throw new Error("Missing node name.");
				if (this.root && this.currentLevel === -1) throw new Error("Document can only have one root node. " + this.debugInfo(name));
				this.openCurrent();
				name = getValue(name);
				if (attributes == null) attributes = {};
				attributes = getValue(attributes);
				if (!isObject$8(attributes)) ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
				this.currentNode = new XMLElement(this, name, attributes);
				this.currentNode.children = false;
				this.currentLevel++;
				this.openTags[this.currentLevel] = this.currentNode;
				if (text != null) this.text(text);
				return this;
			};
			XMLDocumentCB.prototype.element = function(name, attributes, text) {
				var child, i$2, len$1, oldValidationFlag, ref1, root;
				if (this.currentNode && this.currentNode.type === NodeType.DocType) this.dtdElement.apply(this, arguments);
				else if (Array.isArray(name) || isObject$8(name) || isFunction$2(name)) {
					oldValidationFlag = this.options.noValidation;
					this.options.noValidation = true;
					root = new XMLDocument(this.options).element("TEMP_ROOT");
					root.element(name);
					this.options.noValidation = oldValidationFlag;
					ref1 = root.children;
					for (i$2 = 0, len$1 = ref1.length; i$2 < len$1; i$2++) {
						child = ref1[i$2];
						this.createChildNode(child);
						if (child.type === NodeType.Element) this.up();
					}
				} else this.node(name, attributes, text);
				return this;
			};
			XMLDocumentCB.prototype.attribute = function(name, value) {
				var attName, attValue;
				if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
				if (name != null) name = getValue(name);
				if (isObject$8(name)) for (attName in name) {
					if (!hasProp.call(name, attName)) continue;
					attValue = name[attName];
					this.attribute(attName, attValue);
				}
				else {
					if (isFunction$2(value)) value = value.apply();
					if (this.options.keepNullAttributes && value == null) this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
					else if (value != null) this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
				}
				return this;
			};
			XMLDocumentCB.prototype.text = function(value) {
				var node;
				this.openCurrent();
				node = new XMLText(this, value);
				this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.cdata = function(value) {
				var node;
				this.openCurrent();
				node = new XMLCData(this, value);
				this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.comment = function(value) {
				var node;
				this.openCurrent();
				node = new XMLComment(this, value);
				this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.raw = function(value) {
				var node;
				this.openCurrent();
				node = new XMLRaw(this, value);
				this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.instruction = function(target, value) {
				var i$2, insTarget, insValue, len$1, node;
				this.openCurrent();
				if (target != null) target = getValue(target);
				if (value != null) value = getValue(value);
				if (Array.isArray(target)) for (i$2 = 0, len$1 = target.length; i$2 < len$1; i$2++) {
					insTarget = target[i$2];
					this.instruction(insTarget);
				}
				else if (isObject$8(target)) for (insTarget in target) {
					if (!hasProp.call(target, insTarget)) continue;
					insValue = target[insTarget];
					this.instruction(insTarget, insValue);
				}
				else {
					if (isFunction$2(value)) value = value.apply();
					node = new XMLProcessingInstruction(this, target, value);
					this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				}
				return this;
			};
			XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
				var node;
				this.openCurrent();
				if (this.documentStarted) throw new Error("declaration() must be the first node.");
				node = new XMLDeclaration(this, version, encoding, standalone);
				this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
				this.openCurrent();
				if (root == null) throw new Error("Missing root node name.");
				if (this.root) throw new Error("dtd() must come before the root node.");
				this.currentNode = new XMLDocType(this, pubID, sysID);
				this.currentNode.rootNodeName = root;
				this.currentNode.children = false;
				this.currentLevel++;
				this.openTags[this.currentLevel] = this.currentNode;
				return this;
			};
			XMLDocumentCB.prototype.dtdElement = function(name, value) {
				var node;
				this.openCurrent();
				node = new XMLDTDElement(this, name, value);
				this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
				var node;
				this.openCurrent();
				node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
				this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.entity = function(name, value) {
				var node;
				this.openCurrent();
				node = new XMLDTDEntity(this, false, name, value);
				this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.pEntity = function(name, value) {
				var node;
				this.openCurrent();
				node = new XMLDTDEntity(this, true, name, value);
				this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.notation = function(name, value) {
				var node;
				this.openCurrent();
				node = new XMLDTDNotation(this, name, value);
				this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
				return this;
			};
			XMLDocumentCB.prototype.up = function() {
				if (this.currentLevel < 0) throw new Error("The document node has no parent.");
				if (this.currentNode) {
					if (this.currentNode.children) this.closeNode(this.currentNode);
					else this.openNode(this.currentNode);
					this.currentNode = null;
				} else this.closeNode(this.openTags[this.currentLevel]);
				delete this.openTags[this.currentLevel];
				this.currentLevel--;
				return this;
			};
			XMLDocumentCB.prototype.end = function() {
				while (this.currentLevel >= 0) this.up();
				return this.onEnd();
			};
			XMLDocumentCB.prototype.openCurrent = function() {
				if (this.currentNode) {
					this.currentNode.children = true;
					return this.openNode(this.currentNode);
				}
			};
			XMLDocumentCB.prototype.openNode = function(node) {
				var att, chunk$1, name, ref1;
				if (!node.isOpen) {
					if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) this.root = node;
					chunk$1 = "";
					if (node.type === NodeType.Element) {
						this.writerOptions.state = WriterState.OpenTag;
						chunk$1 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
						ref1 = node.attribs;
						for (name in ref1) {
							if (!hasProp.call(ref1, name)) continue;
							att = ref1[name];
							chunk$1 += this.writer.attribute(att, this.writerOptions, this.currentLevel);
						}
						chunk$1 += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
						this.writerOptions.state = WriterState.InsideTag;
					} else {
						this.writerOptions.state = WriterState.OpenTag;
						chunk$1 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
						if (node.pubID && node.sysID) chunk$1 += " PUBLIC \"" + node.pubID + "\" \"" + node.sysID + "\"";
						else if (node.sysID) chunk$1 += " SYSTEM \"" + node.sysID + "\"";
						if (node.children) {
							chunk$1 += " [";
							this.writerOptions.state = WriterState.InsideTag;
						} else {
							this.writerOptions.state = WriterState.CloseTag;
							chunk$1 += ">";
						}
						chunk$1 += this.writer.endline(node, this.writerOptions, this.currentLevel);
					}
					this.onData(chunk$1, this.currentLevel);
					return node.isOpen = true;
				}
			};
			XMLDocumentCB.prototype.closeNode = function(node) {
				var chunk$1;
				if (!node.isClosed) {
					chunk$1 = "";
					this.writerOptions.state = WriterState.CloseTag;
					if (node.type === NodeType.Element) chunk$1 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
					else chunk$1 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
					this.writerOptions.state = WriterState.None;
					this.onData(chunk$1, this.currentLevel);
					return node.isClosed = true;
				}
			};
			XMLDocumentCB.prototype.onData = function(chunk$1, level) {
				this.documentStarted = true;
				return this.onDataCallback(chunk$1, level + 1);
			};
			XMLDocumentCB.prototype.onEnd = function() {
				this.documentCompleted = true;
				return this.onEndCallback();
			};
			XMLDocumentCB.prototype.debugInfo = function(name) {
				if (name == null) return "";
				else return "node: <" + name + ">";
			};
			XMLDocumentCB.prototype.ele = function() {
				return this.element.apply(this, arguments);
			};
			XMLDocumentCB.prototype.nod = function(name, attributes, text) {
				return this.node(name, attributes, text);
			};
			XMLDocumentCB.prototype.txt = function(value) {
				return this.text(value);
			};
			XMLDocumentCB.prototype.dat = function(value) {
				return this.cdata(value);
			};
			XMLDocumentCB.prototype.com = function(value) {
				return this.comment(value);
			};
			XMLDocumentCB.prototype.ins = function(target, value) {
				return this.instruction(target, value);
			};
			XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
				return this.declaration(version, encoding, standalone);
			};
			XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
				return this.doctype(root, pubID, sysID);
			};
			XMLDocumentCB.prototype.e = function(name, attributes, text) {
				return this.element(name, attributes, text);
			};
			XMLDocumentCB.prototype.n = function(name, attributes, text) {
				return this.node(name, attributes, text);
			};
			XMLDocumentCB.prototype.t = function(value) {
				return this.text(value);
			};
			XMLDocumentCB.prototype.d = function(value) {
				return this.cdata(value);
			};
			XMLDocumentCB.prototype.c = function(value) {
				return this.comment(value);
			};
			XMLDocumentCB.prototype.r = function(value) {
				return this.raw(value);
			};
			XMLDocumentCB.prototype.i = function(target, value) {
				return this.instruction(target, value);
			};
			XMLDocumentCB.prototype.att = function() {
				if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
				else return this.attribute.apply(this, arguments);
			};
			XMLDocumentCB.prototype.a = function() {
				if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
				else return this.attribute.apply(this, arguments);
			};
			XMLDocumentCB.prototype.ent = function(name, value) {
				return this.entity(name, value);
			};
			XMLDocumentCB.prototype.pent = function(name, value) {
				return this.pEntity(name, value);
			};
			XMLDocumentCB.prototype.not = function(name, value) {
				return this.notation(name, value);
			};
			return XMLDocumentCB;
		})();
	}).call(exports);
}));
var require_XMLStreamWriter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, WriterState, XMLWriterBase, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		NodeType = require_NodeType();
		XMLWriterBase = require_XMLWriterBase();
		WriterState = require_WriterState();
		module.exports = (function(superClass) {
			extend$1(XMLStreamWriter, superClass);
			function XMLStreamWriter(stream, options) {
				this.stream = stream;
				XMLStreamWriter.__super__.constructor.call(this, options);
			}
			XMLStreamWriter.prototype.endline = function(node, options, level) {
				if (node.isLastRootNode && options.state === WriterState.CloseTag) return "";
				else return XMLStreamWriter.__super__.endline.call(this, node, options, level);
			};
			XMLStreamWriter.prototype.document = function(doc, options) {
				var child, i$2, j$1, k$1, len$1, len1, ref = doc.children, ref1, results;
				for (i$2 = j$1 = 0, len$1 = ref.length; j$1 < len$1; i$2 = ++j$1) {
					child = ref[i$2];
					child.isLastRootNode = i$2 === doc.children.length - 1;
				}
				options = this.filterOptions(options);
				ref1 = doc.children;
				results = [];
				for (k$1 = 0, len1 = ref1.length; k$1 < len1; k$1++) {
					child = ref1[k$1];
					results.push(this.writeChildNode(child, options, 0));
				}
				return results;
			};
			XMLStreamWriter.prototype.attribute = function(att, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
			};
			XMLStreamWriter.prototype.cdata = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.comment = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.declaration = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.docType = function(node, options, level) {
				var child, j$1, len$1, ref;
				level || (level = 0);
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				this.stream.write(this.indent(node, options, level));
				this.stream.write("<!DOCTYPE " + node.root().name);
				if (node.pubID && node.sysID) this.stream.write(" PUBLIC \"" + node.pubID + "\" \"" + node.sysID + "\"");
				else if (node.sysID) this.stream.write(" SYSTEM \"" + node.sysID + "\"");
				if (node.children.length > 0) {
					this.stream.write(" [");
					this.stream.write(this.endline(node, options, level));
					options.state = WriterState.InsideTag;
					ref = node.children;
					for (j$1 = 0, len$1 = ref.length; j$1 < len$1; j$1++) {
						child = ref[j$1];
						this.writeChildNode(child, options, level + 1);
					}
					options.state = WriterState.CloseTag;
					this.stream.write("]");
				}
				options.state = WriterState.CloseTag;
				this.stream.write(options.spaceBeforeSlash + ">");
				this.stream.write(this.endline(node, options, level));
				options.state = WriterState.None;
				return this.closeNode(node, options, level);
			};
			XMLStreamWriter.prototype.element = function(node, options, level) {
				var att, child, childNodeCount, firstChildNode, j$1, len$1, name, ref, ref1;
				level || (level = 0);
				this.openNode(node, options, level);
				options.state = WriterState.OpenTag;
				this.stream.write(this.indent(node, options, level) + "<" + node.name);
				ref = node.attribs;
				for (name in ref) {
					if (!hasProp.call(ref, name)) continue;
					att = ref[name];
					this.attribute(att, options, level);
				}
				childNodeCount = node.children.length;
				firstChildNode = childNodeCount === 0 ? null : node.children[0];
				if (childNodeCount === 0 || node.children.every(function(e$1) {
					return (e$1.type === NodeType.Text || e$1.type === NodeType.Raw) && e$1.value === "";
				})) if (options.allowEmpty) {
					this.stream.write(">");
					options.state = WriterState.CloseTag;
					this.stream.write("</" + node.name + ">");
				} else {
					options.state = WriterState.CloseTag;
					this.stream.write(options.spaceBeforeSlash + "/>");
				}
				else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
					this.stream.write(">");
					options.state = WriterState.InsideTag;
					options.suppressPrettyCount++;
					this.writeChildNode(firstChildNode, options, level + 1);
					options.suppressPrettyCount--;
					options.state = WriterState.CloseTag;
					this.stream.write("</" + node.name + ">");
				} else {
					this.stream.write(">" + this.endline(node, options, level));
					options.state = WriterState.InsideTag;
					ref1 = node.children;
					for (j$1 = 0, len$1 = ref1.length; j$1 < len$1; j$1++) {
						child = ref1[j$1];
						this.writeChildNode(child, options, level + 1);
					}
					options.state = WriterState.CloseTag;
					this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
				}
				this.stream.write(this.endline(node, options, level));
				options.state = WriterState.None;
				return this.closeNode(node, options, level);
			};
			XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.raw = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.text = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
			};
			XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
				return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
			};
			return XMLStreamWriter;
		})(XMLWriterBase);
	}).call(exports);
}));
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction$2, ref = require_Utility();
		assign = ref.assign, isFunction$2 = ref.isFunction;
		XMLDOMImplementation = require_XMLDOMImplementation();
		XMLDocument = require_XMLDocument();
		XMLDocumentCB = require_XMLDocumentCB();
		XMLStringWriter = require_XMLStringWriter();
		XMLStreamWriter = require_XMLStreamWriter();
		NodeType = require_NodeType();
		WriterState = require_WriterState();
		module.exports.create = function(name, xmldec, doctype, options) {
			var doc, root;
			if (name == null) throw new Error("Root element needs a name.");
			options = assign({}, xmldec, doctype, options);
			doc = new XMLDocument(options);
			root = doc.element(name);
			if (!options.headless) {
				doc.declaration(options);
				if (options.pubID != null || options.sysID != null) doc.dtd(options);
			}
			return root;
		};
		module.exports.begin = function(options, onData, onEnd) {
			var ref1;
			if (isFunction$2(options)) {
				ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
				options = {};
			}
			if (onData) return new XMLDocumentCB(options, onData, onEnd);
			else return new XMLDocument(options);
		};
		module.exports.stringWriter = function(options) {
			return new XMLStringWriter(options);
		};
		module.exports.streamWriter = function(stream, options) {
			return new XMLStreamWriter(stream, options);
		};
		module.exports.implementation = new XMLDOMImplementation();
		module.exports.nodeType = NodeType;
		module.exports.writerState = WriterState;
	}).call(exports);
}));
var require_builder = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		var builder, defaults$1, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
		builder = require_lib();
		defaults$1 = require_defaults().defaults;
		requiresCDATA = function(entry) {
			return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
		};
		wrapCDATA = function(entry) {
			return "<![CDATA[" + escapeCDATA(entry) + "]]>";
		};
		escapeCDATA = function(entry) {
			return entry.replace("]]>", "]]]]><![CDATA[>");
		};
		exports.Builder = (function() {
			function Builder(opts) {
				var key, ref, value;
				this.options = {};
				ref = defaults$1["0.2"];
				for (key in ref) {
					if (!hasProp.call(ref, key)) continue;
					value = ref[key];
					this.options[key] = value;
				}
				for (key in opts) {
					if (!hasProp.call(opts, key)) continue;
					value = opts[key];
					this.options[key] = value;
				}
			}
			Builder.prototype.buildObject = function(rootObj) {
				var attrkey = this.options.attrkey, charkey = this.options.charkey, render, rootElement, rootName;
				if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults$1["0.2"].rootName) {
					rootName = Object.keys(rootObj)[0];
					rootObj = rootObj[rootName];
				} else rootName = this.options.rootName;
				render = (function(_this) {
					return function(element, obj) {
						var attr, child, entry, index, key, value;
						if (typeof obj !== "object") if (_this.options.cdata && requiresCDATA(obj)) element.raw(wrapCDATA(obj));
						else element.txt(obj);
						else if (Array.isArray(obj)) for (index in obj) {
							if (!hasProp.call(obj, index)) continue;
							child = obj[index];
							for (key in child) {
								entry = child[key];
								element = render(element.ele(key), entry).up();
							}
						}
						else for (key in obj) {
							if (!hasProp.call(obj, key)) continue;
							child = obj[key];
							if (key === attrkey) {
								if (typeof child === "object") for (attr in child) {
									value = child[attr];
									element = element.att(attr, value);
								}
							} else if (key === charkey) if (_this.options.cdata && requiresCDATA(child)) element = element.raw(wrapCDATA(child));
							else element = element.txt(child);
							else if (Array.isArray(child)) for (index in child) {
								if (!hasProp.call(child, index)) continue;
								entry = child[index];
								if (typeof entry === "string") if (_this.options.cdata && requiresCDATA(entry)) element = element.ele(key).raw(wrapCDATA(entry)).up();
								else element = element.ele(key, entry).up();
								else element = render(element.ele(key), entry).up();
							}
							else if (typeof child === "object") element = render(element.ele(key), child).up();
							else if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) element = element.ele(key).raw(wrapCDATA(child)).up();
							else {
								if (child == null) child = "";
								element = element.ele(key, child.toString()).up();
							}
						}
						return element;
					};
				})(this);
				rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
					headless: this.options.headless,
					allowSurrogateChars: this.options.allowSurrogateChars
				});
				return render(rootElement, rootObj).end(this.options.renderOpts);
			};
			return Builder;
		})();
	}).call(exports);
}));
var require_events = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var R$1 = typeof Reflect === "object" ? Reflect : null;
	var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply$1(target, receiver, args) {
		return Function.prototype.apply.call(target, receiver, args);
	};
	var ReflectOwnKeys;
	if (R$1 && typeof R$1.ownKeys === "function") ReflectOwnKeys = R$1.ownKeys;
	else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
	};
	else ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target);
	};
	function ProcessEmitWarning(warning) {
		if (console && console.warn) console.warn(warning);
	}
	var NumberIsNaN = Number.isNaN || function NumberIsNaN$1(value) {
		return value !== value;
	};
	function EventEmitter() {
		EventEmitter.init.call(this);
	}
	module.exports = EventEmitter;
	module.exports.once = once$2;
	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.prototype._events = void 0;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = void 0;
	var defaultMaxListeners = 10;
	function checkListener(listener) {
		if (typeof listener !== "function") throw new TypeError("The \"listener\" argument must be of type Function. Received type " + typeof listener);
	}
	Object.defineProperty(EventEmitter, "defaultMaxListeners", {
		enumerable: true,
		get: function() {
			return defaultMaxListeners;
		},
		set: function(arg) {
			if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError("The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received " + arg + ".");
			defaultMaxListeners = arg;
		}
	});
	EventEmitter.init = function() {
		if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
			this._events = Object.create(null);
			this._eventsCount = 0;
		}
		this._maxListeners = this._maxListeners || void 0;
	};
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n$6) {
		if (typeof n$6 !== "number" || n$6 < 0 || NumberIsNaN(n$6)) throw new RangeError("The value of \"n\" is out of range. It must be a non-negative number. Received " + n$6 + ".");
		this._maxListeners = n$6;
		return this;
	};
	function _getMaxListeners(that) {
		if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
		return that._maxListeners;
	}
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		return _getMaxListeners(this);
	};
	EventEmitter.prototype.emit = function emit(type) {
		var args = [];
		for (var i$2 = 1; i$2 < arguments.length; i$2++) args.push(arguments[i$2]);
		var doError = type === "error";
		var events = this._events;
		if (events !== void 0) doError = doError && events.error === void 0;
		else if (!doError) return false;
		if (doError) {
			var er;
			if (args.length > 0) er = args[0];
			if (er instanceof Error) throw er;
			var err = /* @__PURE__ */ new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
			err.context = er;
			throw err;
		}
		var handler = events[type];
		if (handler === void 0) return false;
		if (typeof handler === "function") ReflectApply(handler, this, args);
		else {
			var len$1 = handler.length;
			var listeners = arrayClone(handler, len$1);
			for (var i$2 = 0; i$2 < len$1; ++i$2) ReflectApply(listeners[i$2], this, args);
		}
		return true;
	};
	function _addListener(target, type, listener, prepend) {
		var m$1;
		var events;
		var existing;
		checkListener(listener);
		events = target._events;
		if (events === void 0) {
			events = target._events = Object.create(null);
			target._eventsCount = 0;
		} else {
			if (events.newListener !== void 0) {
				target.emit("newListener", type, listener.listener ? listener.listener : listener);
				events = target._events;
			}
			existing = events[type];
		}
		if (existing === void 0) {
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === "function") existing = events[type] = prepend ? [listener, existing] : [existing, listener];
			else if (prepend) existing.unshift(listener);
			else existing.push(listener);
			m$1 = _getMaxListeners(target);
			if (m$1 > 0 && existing.length > m$1 && !existing.warned) {
				existing.warned = true;
				var w$1 = /* @__PURE__ */ new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
				w$1.name = "MaxListenersExceededWarning";
				w$1.emitter = target;
				w$1.type = type;
				w$1.count = existing.length;
				ProcessEmitWarning(w$1);
			}
		}
		return target;
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	EventEmitter.prototype.prependListener = function prependListener$1(type, listener) {
		return _addListener(this, type, listener, true);
	};
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			if (arguments.length === 0) return this.listener.call(this.target);
			return this.listener.apply(this.target, arguments);
		}
	}
	function _onceWrap(target, type, listener) {
		var state = {
			fired: false,
			wrapFn: void 0,
			target,
			type,
			listener
		};
		var wrapped = onceWrapper.bind(state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	EventEmitter.prototype.once = function once$3(type, listener) {
		checkListener(listener);
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
		checkListener(listener);
		this.prependListener(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter.prototype.removeListener = function removeListener(type, listener) {
		var list, events, position, i$2, originalListener;
		checkListener(listener);
		events = this._events;
		if (events === void 0) return this;
		list = events[type];
		if (list === void 0) return this;
		if (list === listener || list.listener === listener) if (--this._eventsCount === 0) this._events = Object.create(null);
		else {
			delete events[type];
			if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
		}
		else if (typeof list !== "function") {
			position = -1;
			for (i$2 = list.length - 1; i$2 >= 0; i$2--) if (list[i$2] === listener || list[i$2].listener === listener) {
				originalListener = list[i$2].listener;
				position = i$2;
				break;
			}
			if (position < 0) return this;
			if (position === 0) list.shift();
			else spliceOne(list, position);
			if (list.length === 1) events[type] = list[0];
			if (events.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
		}
		return this;
	};
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
		var listeners, events = this._events, i$2;
		if (events === void 0) return this;
		if (events.removeListener === void 0) {
			if (arguments.length === 0) {
				this._events = Object.create(null);
				this._eventsCount = 0;
			} else if (events[type] !== void 0) if (--this._eventsCount === 0) this._events = Object.create(null);
			else delete events[type];
			return this;
		}
		if (arguments.length === 0) {
			var keys$9 = Object.keys(events);
			var key;
			for (i$2 = 0; i$2 < keys$9.length; ++i$2) {
				key = keys$9[i$2];
				if (key === "removeListener") continue;
				this.removeAllListeners(key);
			}
			this.removeAllListeners("removeListener");
			this._events = Object.create(null);
			this._eventsCount = 0;
			return this;
		}
		listeners = events[type];
		if (typeof listeners === "function") this.removeListener(type, listeners);
		else if (listeners !== void 0) for (i$2 = listeners.length - 1; i$2 >= 0; i$2--) this.removeListener(type, listeners[i$2]);
		return this;
	};
	function _listeners(target, type, unwrap) {
		var events = target._events;
		if (events === void 0) return [];
		var evlistener = events[type];
		if (evlistener === void 0) return [];
		if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
		return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}
	EventEmitter.prototype.listeners = function listeners(type) {
		return _listeners(this, type, true);
	};
	EventEmitter.prototype.rawListeners = function rawListeners(type) {
		return _listeners(this, type, false);
	};
	EventEmitter.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
		else return listenerCount.call(emitter, type);
	};
	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
		if (events !== void 0) {
			var evlistener = events[type];
			if (typeof evlistener === "function") return 1;
			else if (evlistener !== void 0) return evlistener.length;
		}
		return 0;
	}
	EventEmitter.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};
	function arrayClone(arr, n$6) {
		var copy = new Array(n$6);
		for (var i$2 = 0; i$2 < n$6; ++i$2) copy[i$2] = arr[i$2];
		return copy;
	}
	function spliceOne(list, index) {
		for (; index + 1 < list.length; index++) list[index] = list[index + 1];
		list.pop();
	}
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i$2 = 0; i$2 < ret.length; ++i$2) ret[i$2] = arr[i$2].listener || arr[i$2];
		return ret;
	}
	function once$2(emitter, name) {
		return new Promise(function(resolve, reject) {
			function errorListener(err) {
				emitter.removeListener(name, resolver);
				reject(err);
			}
			function resolver() {
				if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
				resolve([].slice.call(arguments));
			}
			eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
			if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
		});
	}
	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
	}
	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		if (typeof emitter.on === "function") if (flags.once) emitter.once(name, listener);
		else emitter.on(name, listener);
		else if (typeof emitter.addEventListener === "function") emitter.addEventListener(name, function wrapListener(arg) {
			if (flags.once) emitter.removeEventListener(name, wrapListener);
			listener(arg);
		});
		else throw new TypeError("The \"emitter\" argument must be of type EventEmitter. Received type " + typeof emitter);
	}
}));
var require_inherits_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));
var require_stream_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_events().EventEmitter;
}));
var require_base64_js = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.byteLength = byteLength$1;
	exports.toByteArray = toByteArray;
	exports.fromByteArray = fromByteArray;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
		lookup[i$1] = code[i$1];
		revLookup[code.charCodeAt(i$1)] = i$1;
	}
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len$1 = b64.length;
		if (len$1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len$1;
		var placeHoldersLen = validLen === len$1 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength$1(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len$1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i$2;
		for (i$2 = 0; i$2 < len$1; i$2 += 4) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 18 | revLookup[b64.charCodeAt(i$2 + 1)] << 12 | revLookup[b64.charCodeAt(i$2 + 2)] << 6 | revLookup[b64.charCodeAt(i$2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 2 | revLookup[b64.charCodeAt(i$2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 10 | revLookup[b64.charCodeAt(i$2 + 1)] << 4 | revLookup[b64.charCodeAt(i$2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i$2 = start; i$2 < end; i$2 += 3) {
			tmp = (uint8[i$2] << 16 & 16711680) + (uint8[i$2 + 1] << 8 & 65280) + (uint8[i$2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray(uint8) {
		var tmp;
		var len$1 = uint8.length;
		var extraBytes = len$1 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i$2 = 0, len2 = len$1 - extraBytes; i$2 < len2; i$2 += maxChunkLength) parts.push(encodeChunk(uint8, i$2, i$2 + maxChunkLength > len2 ? len2 : i$2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len$1 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len$1 - 2] << 8) + uint8[len$1 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
}));
var require_ieee754 = /* @__PURE__ */ __commonJSMin(((exports) => {
	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
	exports.read = function(buffer$1, offset$1, isLE, mLen, nBytes) {
		var e$1, m$1;
		var eLen = nBytes * 8 - mLen - 1;
		var eMax = (1 << eLen) - 1;
		var eBias = eMax >> 1;
		var nBits = -7;
		var i$2 = isLE ? nBytes - 1 : 0;
		var d$1 = isLE ? -1 : 1;
		var s$2 = buffer$1[offset$1 + i$2];
		i$2 += d$1;
		e$1 = s$2 & (1 << -nBits) - 1;
		s$2 >>= -nBits;
		nBits += eLen;
		for (; nBits > 0; e$1 = e$1 * 256 + buffer$1[offset$1 + i$2], i$2 += d$1, nBits -= 8);
		m$1 = e$1 & (1 << -nBits) - 1;
		e$1 >>= -nBits;
		nBits += mLen;
		for (; nBits > 0; m$1 = m$1 * 256 + buffer$1[offset$1 + i$2], i$2 += d$1, nBits -= 8);
		if (e$1 === 0) e$1 = 1 - eBias;
		else if (e$1 === eMax) return m$1 ? NaN : (s$2 ? -1 : 1) * Infinity;
		else {
			m$1 = m$1 + Math.pow(2, mLen);
			e$1 = e$1 - eBias;
		}
		return (s$2 ? -1 : 1) * m$1 * Math.pow(2, e$1 - mLen);
	};
	exports.write = function(buffer$1, value, offset$1, isLE, mLen, nBytes) {
		var e$1, m$1, c$1;
		var eLen = nBytes * 8 - mLen - 1;
		var eMax = (1 << eLen) - 1;
		var eBias = eMax >> 1;
		var rt$1 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
		var i$2 = isLE ? 0 : nBytes - 1;
		var d$1 = isLE ? 1 : -1;
		var s$2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		value = Math.abs(value);
		if (isNaN(value) || value === Infinity) {
			m$1 = isNaN(value) ? 1 : 0;
			e$1 = eMax;
		} else {
			e$1 = Math.floor(Math.log(value) / Math.LN2);
			if (value * (c$1 = Math.pow(2, -e$1)) < 1) {
				e$1--;
				c$1 *= 2;
			}
			if (e$1 + eBias >= 1) value += rt$1 / c$1;
			else value += rt$1 * Math.pow(2, 1 - eBias);
			if (value * c$1 >= 2) {
				e$1++;
				c$1 /= 2;
			}
			if (e$1 + eBias >= eMax) {
				m$1 = 0;
				e$1 = eMax;
			} else if (e$1 + eBias >= 1) {
				m$1 = (value * c$1 - 1) * Math.pow(2, mLen);
				e$1 = e$1 + eBias;
			} else {
				m$1 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
				e$1 = 0;
			}
		}
		for (; mLen >= 8; buffer$1[offset$1 + i$2] = m$1 & 255, i$2 += d$1, m$1 /= 256, mLen -= 8);
		e$1 = e$1 << mLen | m$1;
		eLen += mLen;
		for (; eLen > 0; buffer$1[offset$1 + i$2] = e$1 & 255, i$2 += d$1, e$1 /= 256, eLen -= 8);
		buffer$1[offset$1 + i$2 - d$1] |= s$2 * 128;
	};
}));
var require_buffer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var base64$1 = require_base64_js();
	var ieee754 = require_ieee754();
	var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
	exports.Buffer = Buffer$6;
	exports.SlowBuffer = SlowBuffer;
	exports.INSPECT_MAX_BYTES = 50;
	var K_MAX_LENGTH = 2147483647;
	exports.kMaxLength = K_MAX_LENGTH;
	Buffer$6.TYPED_ARRAY_SUPPORT = typedArraySupport();
	if (!Buffer$6.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
	function typedArraySupport() {
		try {
			var arr = new Uint8Array(1);
			var proto = { foo: function() {
				return 42;
			} };
			Object.setPrototypeOf(proto, Uint8Array.prototype);
			Object.setPrototypeOf(arr, proto);
			return arr.foo() === 42;
		} catch (e$1) {
			return false;
		}
	}
	Object.defineProperty(Buffer$6.prototype, "parent", {
		enumerable: true,
		get: function() {
			if (!Buffer$6.isBuffer(this)) return void 0;
			return this.buffer;
		}
	});
	Object.defineProperty(Buffer$6.prototype, "offset", {
		enumerable: true,
		get: function() {
			if (!Buffer$6.isBuffer(this)) return void 0;
			return this.byteOffset;
		}
	});
	function createBuffer(length$1) {
		if (length$1 > K_MAX_LENGTH) throw new RangeError("The value \"" + length$1 + "\" is invalid for option \"size\"");
		var buf = new Uint8Array(length$1);
		Object.setPrototypeOf(buf, Buffer$6.prototype);
		return buf;
	}
	function Buffer$6(arg, encodingOrOffset, length$1) {
		if (typeof arg === "number") {
			if (typeof encodingOrOffset === "string") throw new TypeError("The \"string\" argument must be of type string. Received type number");
			return allocUnsafe(arg);
		}
		return from$1(arg, encodingOrOffset, length$1);
	}
	Buffer$6.poolSize = 8192;
	function from$1(value, encodingOrOffset, length$1) {
		if (typeof value === "string") return fromString$1(value, encodingOrOffset);
		if (ArrayBuffer.isView(value)) return fromArrayView(value);
		if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length$1);
		if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length$1);
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type number");
		var valueOf = value.valueOf && value.valueOf();
		if (valueOf != null && valueOf !== value) return Buffer$6.from(valueOf, encodingOrOffset, length$1);
		var b$5 = fromObject(value);
		if (b$5) return b$5;
		if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer$6.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length$1);
		throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
	}
	Buffer$6.from = function(value, encodingOrOffset, length$1) {
		return from$1(value, encodingOrOffset, length$1);
	};
	Object.setPrototypeOf(Buffer$6.prototype, Uint8Array.prototype);
	Object.setPrototypeOf(Buffer$6, Uint8Array);
	function assertSize(size) {
		if (typeof size !== "number") throw new TypeError("\"size\" argument must be of type number");
		else if (size < 0) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
	}
	function alloc(size, fill, encoding) {
		assertSize(size);
		if (size <= 0) return createBuffer(size);
		if (fill !== void 0) return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
		return createBuffer(size);
	}
	Buffer$6.alloc = function(size, fill, encoding) {
		return alloc(size, fill, encoding);
	};
	function allocUnsafe(size) {
		assertSize(size);
		return createBuffer(size < 0 ? 0 : checked(size) | 0);
	}
	Buffer$6.allocUnsafe = function(size) {
		return allocUnsafe(size);
	};
	Buffer$6.allocUnsafeSlow = function(size) {
		return allocUnsafe(size);
	};
	function fromString$1(string, encoding) {
		if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
		if (!Buffer$6.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
		var length$1 = byteLength(string, encoding) | 0;
		var buf = createBuffer(length$1);
		var actual = buf.write(string, encoding);
		if (actual !== length$1) buf = buf.slice(0, actual);
		return buf;
	}
	function fromArrayLike(array) {
		var length$1 = array.length < 0 ? 0 : checked(array.length) | 0;
		var buf = createBuffer(length$1);
		for (var i$2 = 0; i$2 < length$1; i$2 += 1) buf[i$2] = array[i$2] & 255;
		return buf;
	}
	function fromArrayView(arrayView) {
		if (isInstance(arrayView, Uint8Array)) {
			var copy = new Uint8Array(arrayView);
			return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
		}
		return fromArrayLike(arrayView);
	}
	function fromArrayBuffer(array, byteOffset, length$1) {
		if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("\"offset\" is outside of buffer bounds");
		if (array.byteLength < byteOffset + (length$1 || 0)) throw new RangeError("\"length\" is outside of buffer bounds");
		var buf;
		if (byteOffset === void 0 && length$1 === void 0) buf = new Uint8Array(array);
		else if (length$1 === void 0) buf = new Uint8Array(array, byteOffset);
		else buf = new Uint8Array(array, byteOffset, length$1);
		Object.setPrototypeOf(buf, Buffer$6.prototype);
		return buf;
	}
	function fromObject(obj) {
		if (Buffer$6.isBuffer(obj)) {
			var len$1 = checked(obj.length) | 0;
			var buf = createBuffer(len$1);
			if (buf.length === 0) return buf;
			obj.copy(buf, 0, 0, len$1);
			return buf;
		}
		if (obj.length !== void 0) {
			if (typeof obj.length !== "number" || numberIsNaN$2(obj.length)) return createBuffer(0);
			return fromArrayLike(obj);
		}
		if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
	}
	function checked(length$1) {
		if (length$1 >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
		return length$1 | 0;
	}
	function SlowBuffer(length$1) {
		if (+length$1 != length$1) length$1 = 0;
		return Buffer$6.alloc(+length$1);
	}
	Buffer$6.isBuffer = function isBuffer$3(b$5) {
		return b$5 != null && b$5._isBuffer === true && b$5 !== Buffer$6.prototype;
	};
	Buffer$6.compare = function compare$1(a$1, b$5) {
		if (isInstance(a$1, Uint8Array)) a$1 = Buffer$6.from(a$1, a$1.offset, a$1.byteLength);
		if (isInstance(b$5, Uint8Array)) b$5 = Buffer$6.from(b$5, b$5.offset, b$5.byteLength);
		if (!Buffer$6.isBuffer(a$1) || !Buffer$6.isBuffer(b$5)) throw new TypeError("The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array");
		if (a$1 === b$5) return 0;
		var x$1 = a$1.length;
		var y$1 = b$5.length;
		for (var i$2 = 0, len$1 = Math.min(x$1, y$1); i$2 < len$1; ++i$2) if (a$1[i$2] !== b$5[i$2]) {
			x$1 = a$1[i$2];
			y$1 = b$5[i$2];
			break;
		}
		if (x$1 < y$1) return -1;
		if (y$1 < x$1) return 1;
		return 0;
	};
	Buffer$6.isEncoding = function isEncoding$1(encoding) {
		switch (String(encoding).toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "latin1":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return true;
			default: return false;
		}
	};
	Buffer$6.concat = function concat$2(list, length$1) {
		if (!Array.isArray(list)) throw new TypeError("\"list\" argument must be an Array of Buffers");
		if (list.length === 0) return Buffer$6.alloc(0);
		var i$2;
		if (length$1 === void 0) {
			length$1 = 0;
			for (i$2 = 0; i$2 < list.length; ++i$2) length$1 += list[i$2].length;
		}
		var buffer$1 = Buffer$6.allocUnsafe(length$1);
		var pos = 0;
		for (i$2 = 0; i$2 < list.length; ++i$2) {
			var buf = list[i$2];
			if (isInstance(buf, Uint8Array)) if (pos + buf.length > buffer$1.length) Buffer$6.from(buf).copy(buffer$1, pos);
			else Uint8Array.prototype.set.call(buffer$1, buf, pos);
			else if (!Buffer$6.isBuffer(buf)) throw new TypeError("\"list\" argument must be an Array of Buffers");
			else buf.copy(buffer$1, pos);
			pos += buf.length;
		}
		return buffer$1;
	};
	function byteLength(string, encoding) {
		if (Buffer$6.isBuffer(string)) return string.length;
		if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
		if (typeof string !== "string") throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
		var len$1 = string.length;
		var mustMatch = arguments.length > 2 && arguments[2] === true;
		if (!mustMatch && len$1 === 0) return 0;
		var loweredCase = false;
		for (;;) switch (encoding) {
			case "ascii":
			case "latin1":
			case "binary": return len$1;
			case "utf8":
			case "utf-8": return utf8ToBytes(string).length;
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return len$1 * 2;
			case "hex": return len$1 >>> 1;
			case "base64": return base64ToBytes(string).length;
			default:
				if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
				encoding = ("" + encoding).toLowerCase();
				loweredCase = true;
		}
	}
	Buffer$6.byteLength = byteLength;
	function slowToString(encoding, start, end) {
		var loweredCase = false;
		if (start === void 0 || start < 0) start = 0;
		if (start > this.length) return "";
		if (end === void 0 || end > this.length) end = this.length;
		if (end <= 0) return "";
		end >>>= 0;
		start >>>= 0;
		if (end <= start) return "";
		if (!encoding) encoding = "utf8";
		while (true) switch (encoding) {
			case "hex": return hexSlice(this, start, end);
			case "utf8":
			case "utf-8": return utf8Slice(this, start, end);
			case "ascii": return asciiSlice(this, start, end);
			case "latin1":
			case "binary": return latin1Slice(this, start, end);
			case "base64": return base64Slice(this, start, end);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return utf16leSlice(this, start, end);
			default:
				if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
				encoding = (encoding + "").toLowerCase();
				loweredCase = true;
		}
	}
	Buffer$6.prototype._isBuffer = true;
	function swap$1(b$5, n$6, m$1) {
		var i$2 = b$5[n$6];
		b$5[n$6] = b$5[m$1];
		b$5[m$1] = i$2;
	}
	Buffer$6.prototype.swap16 = function swap16() {
		var len$1 = this.length;
		if (len$1 % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
		for (var i$2 = 0; i$2 < len$1; i$2 += 2) swap$1(this, i$2, i$2 + 1);
		return this;
	};
	Buffer$6.prototype.swap32 = function swap32() {
		var len$1 = this.length;
		if (len$1 % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
		for (var i$2 = 0; i$2 < len$1; i$2 += 4) {
			swap$1(this, i$2, i$2 + 3);
			swap$1(this, i$2 + 1, i$2 + 2);
		}
		return this;
	};
	Buffer$6.prototype.swap64 = function swap64() {
		var len$1 = this.length;
		if (len$1 % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
		for (var i$2 = 0; i$2 < len$1; i$2 += 8) {
			swap$1(this, i$2, i$2 + 7);
			swap$1(this, i$2 + 1, i$2 + 6);
			swap$1(this, i$2 + 2, i$2 + 5);
			swap$1(this, i$2 + 3, i$2 + 4);
		}
		return this;
	};
	Buffer$6.prototype.toString = function toString$1() {
		var length$1 = this.length;
		if (length$1 === 0) return "";
		if (arguments.length === 0) return utf8Slice(this, 0, length$1);
		return slowToString.apply(this, arguments);
	};
	Buffer$6.prototype.toLocaleString = Buffer$6.prototype.toString;
	Buffer$6.prototype.equals = function equals(b$5) {
		if (!Buffer$6.isBuffer(b$5)) throw new TypeError("Argument must be a Buffer");
		if (this === b$5) return true;
		return Buffer$6.compare(this, b$5) === 0;
	};
	Buffer$6.prototype.inspect = function inspect$4() {
		var str = "";
		var max$2 = exports.INSPECT_MAX_BYTES;
		str = this.toString("hex", 0, max$2).replace(/(.{2})/g, "$1 ").trim();
		if (this.length > max$2) str += " ... ";
		return "<Buffer " + str + ">";
	};
	if (customInspectSymbol) Buffer$6.prototype[customInspectSymbol] = Buffer$6.prototype.inspect;
	Buffer$6.prototype.compare = function compare$1(target, start, end, thisStart, thisEnd) {
		if (isInstance(target, Uint8Array)) target = Buffer$6.from(target, target.offset, target.byteLength);
		if (!Buffer$6.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
		if (start === void 0) start = 0;
		if (end === void 0) end = target ? target.length : 0;
		if (thisStart === void 0) thisStart = 0;
		if (thisEnd === void 0) thisEnd = this.length;
		if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
		if (thisStart >= thisEnd && start >= end) return 0;
		if (thisStart >= thisEnd) return -1;
		if (start >= end) return 1;
		start >>>= 0;
		end >>>= 0;
		thisStart >>>= 0;
		thisEnd >>>= 0;
		if (this === target) return 0;
		var x$1 = thisEnd - thisStart;
		var y$1 = end - start;
		var len$1 = Math.min(x$1, y$1);
		var thisCopy = this.slice(thisStart, thisEnd);
		var targetCopy = target.slice(start, end);
		for (var i$2 = 0; i$2 < len$1; ++i$2) if (thisCopy[i$2] !== targetCopy[i$2]) {
			x$1 = thisCopy[i$2];
			y$1 = targetCopy[i$2];
			break;
		}
		if (x$1 < y$1) return -1;
		if (y$1 < x$1) return 1;
		return 0;
	};
	function bidirectionalIndexOf(buffer$1, val, byteOffset, encoding, dir) {
		if (buffer$1.length === 0) return -1;
		if (typeof byteOffset === "string") {
			encoding = byteOffset;
			byteOffset = 0;
		} else if (byteOffset > 2147483647) byteOffset = 2147483647;
		else if (byteOffset < -2147483648) byteOffset = -2147483648;
		byteOffset = +byteOffset;
		if (numberIsNaN$2(byteOffset)) byteOffset = dir ? 0 : buffer$1.length - 1;
		if (byteOffset < 0) byteOffset = buffer$1.length + byteOffset;
		if (byteOffset >= buffer$1.length) if (dir) return -1;
		else byteOffset = buffer$1.length - 1;
		else if (byteOffset < 0) if (dir) byteOffset = 0;
		else return -1;
		if (typeof val === "string") val = Buffer$6.from(val, encoding);
		if (Buffer$6.isBuffer(val)) {
			if (val.length === 0) return -1;
			return arrayIndexOf(buffer$1, val, byteOffset, encoding, dir);
		} else if (typeof val === "number") {
			val = val & 255;
			if (typeof Uint8Array.prototype.indexOf === "function") if (dir) return Uint8Array.prototype.indexOf.call(buffer$1, val, byteOffset);
			else return Uint8Array.prototype.lastIndexOf.call(buffer$1, val, byteOffset);
			return arrayIndexOf(buffer$1, [val], byteOffset, encoding, dir);
		}
		throw new TypeError("val must be string, number or Buffer");
	}
	function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
		var indexSize = 1;
		var arrLength = arr.length;
		var valLength = val.length;
		if (encoding !== void 0) {
			encoding = String(encoding).toLowerCase();
			if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
				if (arr.length < 2 || val.length < 2) return -1;
				indexSize = 2;
				arrLength /= 2;
				valLength /= 2;
				byteOffset /= 2;
			}
		}
		function read(buf, i$3) {
			if (indexSize === 1) return buf[i$3];
			else return buf.readUInt16BE(i$3 * indexSize);
		}
		var i$2;
		if (dir) {
			var foundIndex = -1;
			for (i$2 = byteOffset; i$2 < arrLength; i$2++) if (read(arr, i$2) === read(val, foundIndex === -1 ? 0 : i$2 - foundIndex)) {
				if (foundIndex === -1) foundIndex = i$2;
				if (i$2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
			} else {
				if (foundIndex !== -1) i$2 -= i$2 - foundIndex;
				foundIndex = -1;
			}
		} else {
			if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
			for (i$2 = byteOffset; i$2 >= 0; i$2--) {
				var found = true;
				for (var j$1 = 0; j$1 < valLength; j$1++) if (read(arr, i$2 + j$1) !== read(val, j$1)) {
					found = false;
					break;
				}
				if (found) return i$2;
			}
		}
		return -1;
	}
	Buffer$6.prototype.includes = function includes$2(val, byteOffset, encoding) {
		return this.indexOf(val, byteOffset, encoding) !== -1;
	};
	Buffer$6.prototype.indexOf = function indexOf$1(val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
	};
	Buffer$6.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
	};
	function hexWrite(buf, string, offset$1, length$1) {
		offset$1 = Number(offset$1) || 0;
		var remaining = buf.length - offset$1;
		if (!length$1) length$1 = remaining;
		else {
			length$1 = Number(length$1);
			if (length$1 > remaining) length$1 = remaining;
		}
		var strLen = string.length;
		if (length$1 > strLen / 2) length$1 = strLen / 2;
		for (var i$2 = 0; i$2 < length$1; ++i$2) {
			var parsed = parseInt(string.substr(i$2 * 2, 2), 16);
			if (numberIsNaN$2(parsed)) return i$2;
			buf[offset$1 + i$2] = parsed;
		}
		return i$2;
	}
	function utf8Write(buf, string, offset$1, length$1) {
		return blitBuffer(utf8ToBytes(string, buf.length - offset$1), buf, offset$1, length$1);
	}
	function asciiWrite(buf, string, offset$1, length$1) {
		return blitBuffer(asciiToBytes(string), buf, offset$1, length$1);
	}
	function base64Write(buf, string, offset$1, length$1) {
		return blitBuffer(base64ToBytes(string), buf, offset$1, length$1);
	}
	function ucs2Write(buf, string, offset$1, length$1) {
		return blitBuffer(utf16leToBytes(string, buf.length - offset$1), buf, offset$1, length$1);
	}
	Buffer$6.prototype.write = function write(string, offset$1, length$1, encoding) {
		if (offset$1 === void 0) {
			encoding = "utf8";
			length$1 = this.length;
			offset$1 = 0;
		} else if (length$1 === void 0 && typeof offset$1 === "string") {
			encoding = offset$1;
			length$1 = this.length;
			offset$1 = 0;
		} else if (isFinite(offset$1)) {
			offset$1 = offset$1 >>> 0;
			if (isFinite(length$1)) {
				length$1 = length$1 >>> 0;
				if (encoding === void 0) encoding = "utf8";
			} else {
				encoding = length$1;
				length$1 = void 0;
			}
		} else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
		var remaining = this.length - offset$1;
		if (length$1 === void 0 || length$1 > remaining) length$1 = remaining;
		if (string.length > 0 && (length$1 < 0 || offset$1 < 0) || offset$1 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
		if (!encoding) encoding = "utf8";
		var loweredCase = false;
		for (;;) switch (encoding) {
			case "hex": return hexWrite(this, string, offset$1, length$1);
			case "utf8":
			case "utf-8": return utf8Write(this, string, offset$1, length$1);
			case "ascii":
			case "latin1":
			case "binary": return asciiWrite(this, string, offset$1, length$1);
			case "base64": return base64Write(this, string, offset$1, length$1);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return ucs2Write(this, string, offset$1, length$1);
			default:
				if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
				encoding = ("" + encoding).toLowerCase();
				loweredCase = true;
		}
	};
	Buffer$6.prototype.toJSON = function toJSON() {
		return {
			type: "Buffer",
			data: Array.prototype.slice.call(this._arr || this, 0)
		};
	};
	function base64Slice(buf, start, end) {
		if (start === 0 && end === buf.length) return base64$1.fromByteArray(buf);
		else return base64$1.fromByteArray(buf.slice(start, end));
	}
	function utf8Slice(buf, start, end) {
		end = Math.min(buf.length, end);
		var res = [];
		var i$2 = start;
		while (i$2 < end) {
			var firstByte = buf[i$2];
			var codePoint = null;
			var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
			if (i$2 + bytesPerSequence <= end) {
				var secondByte, thirdByte, fourthByte, tempCodePoint;
				switch (bytesPerSequence) {
					case 1:
						if (firstByte < 128) codePoint = firstByte;
						break;
					case 2:
						secondByte = buf[i$2 + 1];
						if ((secondByte & 192) === 128) {
							tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
							if (tempCodePoint > 127) codePoint = tempCodePoint;
						}
						break;
					case 3:
						secondByte = buf[i$2 + 1];
						thirdByte = buf[i$2 + 2];
						if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
							tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
							if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
						}
						break;
					case 4:
						secondByte = buf[i$2 + 1];
						thirdByte = buf[i$2 + 2];
						fourthByte = buf[i$2 + 3];
						if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
							tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
							if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
						}
				}
			}
			if (codePoint === null) {
				codePoint = 65533;
				bytesPerSequence = 1;
			} else if (codePoint > 65535) {
				codePoint -= 65536;
				res.push(codePoint >>> 10 & 1023 | 55296);
				codePoint = 56320 | codePoint & 1023;
			}
			res.push(codePoint);
			i$2 += bytesPerSequence;
		}
		return decodeCodePointsArray(res);
	}
	var MAX_ARGUMENTS_LENGTH = 4096;
	function decodeCodePointsArray(codePoints) {
		var len$1 = codePoints.length;
		if (len$1 <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
		var res = "";
		var i$2 = 0;
		while (i$2 < len$1) res += String.fromCharCode.apply(String, codePoints.slice(i$2, i$2 += MAX_ARGUMENTS_LENGTH));
		return res;
	}
	function asciiSlice(buf, start, end) {
		var ret = "";
		end = Math.min(buf.length, end);
		for (var i$2 = start; i$2 < end; ++i$2) ret += String.fromCharCode(buf[i$2] & 127);
		return ret;
	}
	function latin1Slice(buf, start, end) {
		var ret = "";
		end = Math.min(buf.length, end);
		for (var i$2 = start; i$2 < end; ++i$2) ret += String.fromCharCode(buf[i$2]);
		return ret;
	}
	function hexSlice(buf, start, end) {
		var len$1 = buf.length;
		if (!start || start < 0) start = 0;
		if (!end || end < 0 || end > len$1) end = len$1;
		var out = "";
		for (var i$2 = start; i$2 < end; ++i$2) out += hexSliceLookupTable[buf[i$2]];
		return out;
	}
	function utf16leSlice(buf, start, end) {
		var bytes = buf.slice(start, end);
		var res = "";
		for (var i$2 = 0; i$2 < bytes.length - 1; i$2 += 2) res += String.fromCharCode(bytes[i$2] + bytes[i$2 + 1] * 256);
		return res;
	}
	Buffer$6.prototype.slice = function slice$1(start, end) {
		var len$1 = this.length;
		start = ~~start;
		end = end === void 0 ? len$1 : ~~end;
		if (start < 0) {
			start += len$1;
			if (start < 0) start = 0;
		} else if (start > len$1) start = len$1;
		if (end < 0) {
			end += len$1;
			if (end < 0) end = 0;
		} else if (end > len$1) end = len$1;
		if (end < start) end = start;
		var newBuf = this.subarray(start, end);
		Object.setPrototypeOf(newBuf, Buffer$6.prototype);
		return newBuf;
	};
	function checkOffset(offset$1, ext, length$1) {
		if (offset$1 % 1 !== 0 || offset$1 < 0) throw new RangeError("offset is not uint");
		if (offset$1 + ext > length$1) throw new RangeError("Trying to access beyond buffer length");
	}
	Buffer$6.prototype.readUintLE = Buffer$6.prototype.readUIntLE = function readUIntLE(offset$1, byteLength$2, noAssert) {
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) checkOffset(offset$1, byteLength$2, this.length);
		var val = this[offset$1];
		var mul = 1;
		var i$2 = 0;
		while (++i$2 < byteLength$2 && (mul *= 256)) val += this[offset$1 + i$2] * mul;
		return val;
	};
	Buffer$6.prototype.readUintBE = Buffer$6.prototype.readUIntBE = function readUIntBE(offset$1, byteLength$2, noAssert) {
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) checkOffset(offset$1, byteLength$2, this.length);
		var val = this[offset$1 + --byteLength$2];
		var mul = 1;
		while (byteLength$2 > 0 && (mul *= 256)) val += this[offset$1 + --byteLength$2] * mul;
		return val;
	};
	Buffer$6.prototype.readUint8 = Buffer$6.prototype.readUInt8 = function readUInt8(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 1, this.length);
		return this[offset$1];
	};
	Buffer$6.prototype.readUint16LE = Buffer$6.prototype.readUInt16LE = function readUInt16LE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 2, this.length);
		return this[offset$1] | this[offset$1 + 1] << 8;
	};
	Buffer$6.prototype.readUint16BE = Buffer$6.prototype.readUInt16BE = function readUInt16BE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 2, this.length);
		return this[offset$1] << 8 | this[offset$1 + 1];
	};
	Buffer$6.prototype.readUint32LE = Buffer$6.prototype.readUInt32LE = function readUInt32LE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return (this[offset$1] | this[offset$1 + 1] << 8 | this[offset$1 + 2] << 16) + this[offset$1 + 3] * 16777216;
	};
	Buffer$6.prototype.readUint32BE = Buffer$6.prototype.readUInt32BE = function readUInt32BE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return this[offset$1] * 16777216 + (this[offset$1 + 1] << 16 | this[offset$1 + 2] << 8 | this[offset$1 + 3]);
	};
	Buffer$6.prototype.readIntLE = function readIntLE(offset$1, byteLength$2, noAssert) {
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) checkOffset(offset$1, byteLength$2, this.length);
		var val = this[offset$1];
		var mul = 1;
		var i$2 = 0;
		while (++i$2 < byteLength$2 && (mul *= 256)) val += this[offset$1 + i$2] * mul;
		mul *= 128;
		if (val >= mul) val -= Math.pow(2, 8 * byteLength$2);
		return val;
	};
	Buffer$6.prototype.readIntBE = function readIntBE(offset$1, byteLength$2, noAssert) {
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) checkOffset(offset$1, byteLength$2, this.length);
		var i$2 = byteLength$2;
		var mul = 1;
		var val = this[offset$1 + --i$2];
		while (i$2 > 0 && (mul *= 256)) val += this[offset$1 + --i$2] * mul;
		mul *= 128;
		if (val >= mul) val -= Math.pow(2, 8 * byteLength$2);
		return val;
	};
	Buffer$6.prototype.readInt8 = function readInt8(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 1, this.length);
		if (!(this[offset$1] & 128)) return this[offset$1];
		return (255 - this[offset$1] + 1) * -1;
	};
	Buffer$6.prototype.readInt16LE = function readInt16LE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 2, this.length);
		var val = this[offset$1] | this[offset$1 + 1] << 8;
		return val & 32768 ? val | 4294901760 : val;
	};
	Buffer$6.prototype.readInt16BE = function readInt16BE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 2, this.length);
		var val = this[offset$1 + 1] | this[offset$1] << 8;
		return val & 32768 ? val | 4294901760 : val;
	};
	Buffer$6.prototype.readInt32LE = function readInt32LE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return this[offset$1] | this[offset$1 + 1] << 8 | this[offset$1 + 2] << 16 | this[offset$1 + 3] << 24;
	};
	Buffer$6.prototype.readInt32BE = function readInt32BE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return this[offset$1] << 24 | this[offset$1 + 1] << 16 | this[offset$1 + 2] << 8 | this[offset$1 + 3];
	};
	Buffer$6.prototype.readFloatLE = function readFloatLE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return ieee754.read(this, offset$1, true, 23, 4);
	};
	Buffer$6.prototype.readFloatBE = function readFloatBE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 4, this.length);
		return ieee754.read(this, offset$1, false, 23, 4);
	};
	Buffer$6.prototype.readDoubleLE = function readDoubleLE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 8, this.length);
		return ieee754.read(this, offset$1, true, 52, 8);
	};
	Buffer$6.prototype.readDoubleBE = function readDoubleBE(offset$1, noAssert) {
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkOffset(offset$1, 8, this.length);
		return ieee754.read(this, offset$1, false, 52, 8);
	};
	function checkInt(buf, value, offset$1, ext, max$2, min$2) {
		if (!Buffer$6.isBuffer(buf)) throw new TypeError("\"buffer\" argument must be a Buffer instance");
		if (value > max$2 || value < min$2) throw new RangeError("\"value\" argument is out of bounds");
		if (offset$1 + ext > buf.length) throw new RangeError("Index out of range");
	}
	Buffer$6.prototype.writeUintLE = Buffer$6.prototype.writeUIntLE = function writeUIntLE(value, offset$1, byteLength$2, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) {
			var maxBytes = Math.pow(2, 8 * byteLength$2) - 1;
			checkInt(this, value, offset$1, byteLength$2, maxBytes, 0);
		}
		var mul = 1;
		var i$2 = 0;
		this[offset$1] = value & 255;
		while (++i$2 < byteLength$2 && (mul *= 256)) this[offset$1 + i$2] = value / mul & 255;
		return offset$1 + byteLength$2;
	};
	Buffer$6.prototype.writeUintBE = Buffer$6.prototype.writeUIntBE = function writeUIntBE(value, offset$1, byteLength$2, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		byteLength$2 = byteLength$2 >>> 0;
		if (!noAssert) {
			var maxBytes = Math.pow(2, 8 * byteLength$2) - 1;
			checkInt(this, value, offset$1, byteLength$2, maxBytes, 0);
		}
		var i$2 = byteLength$2 - 1;
		var mul = 1;
		this[offset$1 + i$2] = value & 255;
		while (--i$2 >= 0 && (mul *= 256)) this[offset$1 + i$2] = value / mul & 255;
		return offset$1 + byteLength$2;
	};
	Buffer$6.prototype.writeUint8 = Buffer$6.prototype.writeUInt8 = function writeUInt8(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 1, 255, 0);
		this[offset$1] = value & 255;
		return offset$1 + 1;
	};
	Buffer$6.prototype.writeUint16LE = Buffer$6.prototype.writeUInt16LE = function writeUInt16LE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 2, 65535, 0);
		this[offset$1] = value & 255;
		this[offset$1 + 1] = value >>> 8;
		return offset$1 + 2;
	};
	Buffer$6.prototype.writeUint16BE = Buffer$6.prototype.writeUInt16BE = function writeUInt16BE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 2, 65535, 0);
		this[offset$1] = value >>> 8;
		this[offset$1 + 1] = value & 255;
		return offset$1 + 2;
	};
	Buffer$6.prototype.writeUint32LE = Buffer$6.prototype.writeUInt32LE = function writeUInt32LE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 4, 4294967295, 0);
		this[offset$1 + 3] = value >>> 24;
		this[offset$1 + 2] = value >>> 16;
		this[offset$1 + 1] = value >>> 8;
		this[offset$1] = value & 255;
		return offset$1 + 4;
	};
	Buffer$6.prototype.writeUint32BE = Buffer$6.prototype.writeUInt32BE = function writeUInt32BE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 4, 4294967295, 0);
		this[offset$1] = value >>> 24;
		this[offset$1 + 1] = value >>> 16;
		this[offset$1 + 2] = value >>> 8;
		this[offset$1 + 3] = value & 255;
		return offset$1 + 4;
	};
	Buffer$6.prototype.writeIntLE = function writeIntLE(value, offset$1, byteLength$2, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) {
			var limit = Math.pow(2, 8 * byteLength$2 - 1);
			checkInt(this, value, offset$1, byteLength$2, limit - 1, -limit);
		}
		var i$2 = 0;
		var mul = 1;
		var sub = 0;
		this[offset$1] = value & 255;
		while (++i$2 < byteLength$2 && (mul *= 256)) {
			if (value < 0 && sub === 0 && this[offset$1 + i$2 - 1] !== 0) sub = 1;
			this[offset$1 + i$2] = (value / mul >> 0) - sub & 255;
		}
		return offset$1 + byteLength$2;
	};
	Buffer$6.prototype.writeIntBE = function writeIntBE(value, offset$1, byteLength$2, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) {
			var limit = Math.pow(2, 8 * byteLength$2 - 1);
			checkInt(this, value, offset$1, byteLength$2, limit - 1, -limit);
		}
		var i$2 = byteLength$2 - 1;
		var mul = 1;
		var sub = 0;
		this[offset$1 + i$2] = value & 255;
		while (--i$2 >= 0 && (mul *= 256)) {
			if (value < 0 && sub === 0 && this[offset$1 + i$2 + 1] !== 0) sub = 1;
			this[offset$1 + i$2] = (value / mul >> 0) - sub & 255;
		}
		return offset$1 + byteLength$2;
	};
	Buffer$6.prototype.writeInt8 = function writeInt8(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 1, 127, -128);
		if (value < 0) value = 255 + value + 1;
		this[offset$1] = value & 255;
		return offset$1 + 1;
	};
	Buffer$6.prototype.writeInt16LE = function writeInt16LE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 2, 32767, -32768);
		this[offset$1] = value & 255;
		this[offset$1 + 1] = value >>> 8;
		return offset$1 + 2;
	};
	Buffer$6.prototype.writeInt16BE = function writeInt16BE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 2, 32767, -32768);
		this[offset$1] = value >>> 8;
		this[offset$1 + 1] = value & 255;
		return offset$1 + 2;
	};
	Buffer$6.prototype.writeInt32LE = function writeInt32LE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 4, 2147483647, -2147483648);
		this[offset$1] = value & 255;
		this[offset$1 + 1] = value >>> 8;
		this[offset$1 + 2] = value >>> 16;
		this[offset$1 + 3] = value >>> 24;
		return offset$1 + 4;
	};
	Buffer$6.prototype.writeInt32BE = function writeInt32BE(value, offset$1, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkInt(this, value, offset$1, 4, 2147483647, -2147483648);
		if (value < 0) value = 4294967295 + value + 1;
		this[offset$1] = value >>> 24;
		this[offset$1 + 1] = value >>> 16;
		this[offset$1 + 2] = value >>> 8;
		this[offset$1 + 3] = value & 255;
		return offset$1 + 4;
	};
	function checkIEEE754(buf, value, offset$1, ext, max$2, min$2) {
		if (offset$1 + ext > buf.length) throw new RangeError("Index out of range");
		if (offset$1 < 0) throw new RangeError("Index out of range");
	}
	function writeFloat(buf, value, offset$1, littleEndian, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkIEEE754(buf, value, offset$1, 4, 34028234663852886e22, -34028234663852886e22);
		ieee754.write(buf, value, offset$1, littleEndian, 23, 4);
		return offset$1 + 4;
	}
	Buffer$6.prototype.writeFloatLE = function writeFloatLE(value, offset$1, noAssert) {
		return writeFloat(this, value, offset$1, true, noAssert);
	};
	Buffer$6.prototype.writeFloatBE = function writeFloatBE(value, offset$1, noAssert) {
		return writeFloat(this, value, offset$1, false, noAssert);
	};
	function writeDouble(buf, value, offset$1, littleEndian, noAssert) {
		value = +value;
		offset$1 = offset$1 >>> 0;
		if (!noAssert) checkIEEE754(buf, value, offset$1, 8, 17976931348623157e292, -17976931348623157e292);
		ieee754.write(buf, value, offset$1, littleEndian, 52, 8);
		return offset$1 + 8;
	}
	Buffer$6.prototype.writeDoubleLE = function writeDoubleLE(value, offset$1, noAssert) {
		return writeDouble(this, value, offset$1, true, noAssert);
	};
	Buffer$6.prototype.writeDoubleBE = function writeDoubleBE(value, offset$1, noAssert) {
		return writeDouble(this, value, offset$1, false, noAssert);
	};
	Buffer$6.prototype.copy = function copy(target, targetStart, start, end) {
		if (!Buffer$6.isBuffer(target)) throw new TypeError("argument should be a Buffer");
		if (!start) start = 0;
		if (!end && end !== 0) end = this.length;
		if (targetStart >= target.length) targetStart = target.length;
		if (!targetStart) targetStart = 0;
		if (end > 0 && end < start) end = start;
		if (end === start) return 0;
		if (target.length === 0 || this.length === 0) return 0;
		if (targetStart < 0) throw new RangeError("targetStart out of bounds");
		if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
		if (end < 0) throw new RangeError("sourceEnd out of bounds");
		if (end > this.length) end = this.length;
		if (target.length - targetStart < end - start) end = target.length - targetStart + start;
		var len$1 = end - start;
		if (this === target && typeof Uint8Array.prototype.copyWithin === "function") this.copyWithin(targetStart, start, end);
		else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
		return len$1;
	};
	Buffer$6.prototype.fill = function fill(val, start, end, encoding) {
		if (typeof val === "string") {
			if (typeof start === "string") {
				encoding = start;
				start = 0;
				end = this.length;
			} else if (typeof end === "string") {
				encoding = end;
				end = this.length;
			}
			if (encoding !== void 0 && typeof encoding !== "string") throw new TypeError("encoding must be a string");
			if (typeof encoding === "string" && !Buffer$6.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
			if (val.length === 1) {
				var code$1 = val.charCodeAt(0);
				if (encoding === "utf8" && code$1 < 128 || encoding === "latin1") val = code$1;
			}
		} else if (typeof val === "number") val = val & 255;
		else if (typeof val === "boolean") val = Number(val);
		if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
		if (end <= start) return this;
		start = start >>> 0;
		end = end === void 0 ? this.length : end >>> 0;
		if (!val) val = 0;
		var i$2;
		if (typeof val === "number") for (i$2 = start; i$2 < end; ++i$2) this[i$2] = val;
		else {
			var bytes = Buffer$6.isBuffer(val) ? val : Buffer$6.from(val, encoding);
			var len$1 = bytes.length;
			if (len$1 === 0) throw new TypeError("The value \"" + val + "\" is invalid for argument \"value\"");
			for (i$2 = 0; i$2 < end - start; ++i$2) this[i$2 + start] = bytes[i$2 % len$1];
		}
		return this;
	};
	var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
	function base64clean(str) {
		str = str.split("=")[0];
		str = str.trim().replace(INVALID_BASE64_RE, "");
		if (str.length < 2) return "";
		while (str.length % 4 !== 0) str = str + "=";
		return str;
	}
	function utf8ToBytes(string, units) {
		units = units || Infinity;
		var codePoint;
		var length$1 = string.length;
		var leadSurrogate = null;
		var bytes = [];
		for (var i$2 = 0; i$2 < length$1; ++i$2) {
			codePoint = string.charCodeAt(i$2);
			if (codePoint > 55295 && codePoint < 57344) {
				if (!leadSurrogate) {
					if (codePoint > 56319) {
						if ((units -= 3) > -1) bytes.push(239, 191, 189);
						continue;
					} else if (i$2 + 1 === length$1) {
						if ((units -= 3) > -1) bytes.push(239, 191, 189);
						continue;
					}
					leadSurrogate = codePoint;
					continue;
				}
				if (codePoint < 56320) {
					if ((units -= 3) > -1) bytes.push(239, 191, 189);
					leadSurrogate = codePoint;
					continue;
				}
				codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
			} else if (leadSurrogate) {
				if ((units -= 3) > -1) bytes.push(239, 191, 189);
			}
			leadSurrogate = null;
			if (codePoint < 128) {
				if ((units -= 1) < 0) break;
				bytes.push(codePoint);
			} else if (codePoint < 2048) {
				if ((units -= 2) < 0) break;
				bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
			} else if (codePoint < 65536) {
				if ((units -= 3) < 0) break;
				bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
			} else if (codePoint < 1114112) {
				if ((units -= 4) < 0) break;
				bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
			} else throw new Error("Invalid code point");
		}
		return bytes;
	}
	function asciiToBytes(str) {
		var byteArray = [];
		for (var i$2 = 0; i$2 < str.length; ++i$2) byteArray.push(str.charCodeAt(i$2) & 255);
		return byteArray;
	}
	function utf16leToBytes(str, units) {
		var c$1, hi, lo;
		var byteArray = [];
		for (var i$2 = 0; i$2 < str.length; ++i$2) {
			if ((units -= 2) < 0) break;
			c$1 = str.charCodeAt(i$2);
			hi = c$1 >> 8;
			lo = c$1 % 256;
			byteArray.push(lo);
			byteArray.push(hi);
		}
		return byteArray;
	}
	function base64ToBytes(str) {
		return base64$1.toByteArray(base64clean(str));
	}
	function blitBuffer(src, dst, offset$1, length$1) {
		for (var i$2 = 0; i$2 < length$1; ++i$2) {
			if (i$2 + offset$1 >= dst.length || i$2 >= src.length) break;
			dst[i$2 + offset$1] = src[i$2];
		}
		return i$2;
	}
	function isInstance(obj, type) {
		return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
	}
	function numberIsNaN$2(obj) {
		return obj !== obj;
	}
	var hexSliceLookupTable = (function() {
		var alphabet = "0123456789abcdef";
		var table = new Array(256);
		for (var i$2 = 0; i$2 < 16; ++i$2) {
			var i16 = i$2 * 16;
			for (var j$1 = 0; j$1 < 16; ++j$1) table[i16 + j$1] = alphabet[i$2] + alphabet[j$1];
		}
		return table;
	})();
}));
var require_is_arguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasToStringTag$2 = require_shams()();
	var $toString$1 = require_callBound()("Object.prototype.toString");
	var isStandardArguments = function isArguments$1(value) {
		if (hasToStringTag$2 && value && typeof value === "object" && Symbol.toStringTag in value) return false;
		return $toString$1(value) === "[object Arguments]";
	};
	var isLegacyArguments = function isArguments$1(value) {
		if (isStandardArguments(value)) return true;
		return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
	};
	var supportsStandardArguments = function() {
		return isStandardArguments(arguments);
	}();
	isStandardArguments.isLegacyArguments = isLegacyArguments;
	module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
}));
var require_is_generator_function = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBound$2 = require_call_bound();
	var isFnRegex = require_safe_regex_test()(/^\s*(?:function)?\*/);
	var hasToStringTag$1 = require_shams()();
	var getProto$1 = require_get_proto();
	var toStr$1 = callBound$2("Object.prototype.toString");
	var fnToStr = callBound$2("Function.prototype.toString");
	var getGeneratorFunc = function() {
		if (!hasToStringTag$1) return false;
		try {
			return Function("return function*() {}")();
		} catch (e$1) {}
	};
	var GeneratorFunction;
	module.exports = function isGeneratorFunction$1(fn$1) {
		if (typeof fn$1 !== "function") return false;
		if (isFnRegex(fnToStr(fn$1))) return true;
		if (!hasToStringTag$1) return toStr$1(fn$1) === "[object GeneratorFunction]";
		if (!getProto$1) return false;
		if (typeof GeneratorFunction === "undefined") {
			var generatorFunc = getGeneratorFunc();
			GeneratorFunction = generatorFunc ? getProto$1(generatorFunc) : false;
		}
		return getProto$1(fn$1) === GeneratorFunction;
	};
}));
var require_for_each = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isCallable = require_is_callable();
	var toStr = Object.prototype.toString;
	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var forEachArray = function forEachArray$1(array, iterator, receiver) {
		for (var i$2 = 0, len$1 = array.length; i$2 < len$1; i$2++) if (hasOwnProperty$5.call(array, i$2)) if (receiver == null) iterator(array[i$2], i$2, array);
		else iterator.call(receiver, array[i$2], i$2, array);
	};
	var forEachString = function forEachString$1(string, iterator, receiver) {
		for (var i$2 = 0, len$1 = string.length; i$2 < len$1; i$2++) if (receiver == null) iterator(string.charAt(i$2), i$2, string);
		else iterator.call(receiver, string.charAt(i$2), i$2, string);
	};
	var forEachObject = function forEachObject$1(object, iterator, receiver) {
		for (var k$1 in object) if (hasOwnProperty$5.call(object, k$1)) if (receiver == null) iterator(object[k$1], k$1, object);
		else iterator.call(receiver, object[k$1], k$1, object);
	};
	function isArray$8(x$1) {
		return toStr.call(x$1) === "[object Array]";
	}
	module.exports = function forEach$1(list, iterator, thisArg) {
		if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
		var receiver;
		if (arguments.length >= 3) receiver = thisArg;
		if (isArray$8(list)) forEachArray(list, iterator, receiver);
		else if (typeof list === "string") forEachString(list, iterator, receiver);
		else forEachObject(list, iterator, receiver);
	};
}));
var require_possible_typed_array_names = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		"Float16Array",
		"Float32Array",
		"Float64Array",
		"Int8Array",
		"Int16Array",
		"Int32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"Uint16Array",
		"Uint32Array",
		"BigInt64Array",
		"BigUint64Array"
	];
}));
var require_available_typed_arrays = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	var possibleNames = require_possible_typed_array_names();
	var g$2 = typeof globalThis === "undefined" ? global : globalThis;
	module.exports = function availableTypedArrays$1() {
		var out = [];
		for (var i$2 = 0; i$2 < possibleNames.length; i$2++) if (typeof g$2[possibleNames[i$2]] === "function") out[out.length] = possibleNames[i$2];
		return out;
	};
}));
var require_which_typed_array = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	var forEach = require_for_each();
	var availableTypedArrays = require_available_typed_arrays();
	var callBind$2 = require_call_bind();
	var callBound$1 = require_call_bound();
	var gOPD = require_gopd();
	var getProto = require_get_proto();
	var $toString = callBound$1("Object.prototype.toString");
	var hasToStringTag = require_shams()();
	var g$1 = typeof globalThis === "undefined" ? global : globalThis;
	var typedArrays = availableTypedArrays();
	var $slice = callBound$1("String.prototype.slice");
	var $indexOf = callBound$1("Array.prototype.indexOf", true) || function indexOf$1(array, value) {
		for (var i$2 = 0; i$2 < array.length; i$2 += 1) if (array[i$2] === value) return i$2;
		return -1;
	};
	var cache = { __proto__: null };
	if (hasToStringTag && gOPD && getProto) forEach(typedArrays, function(typedArray) {
		var arr = new g$1[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) descriptor = gOPD(getProto(proto), Symbol.toStringTag);
			cache["$" + typedArray] = callBind$2(descriptor.get);
		}
	});
	else forEach(typedArrays, function(typedArray) {
		var arr = new g$1[typedArray]();
		var fn$1 = arr.slice || arr.set;
		if (fn$1) cache["$" + typedArray] = callBind$2(fn$1);
	});
	var tryTypedArrays = function tryAllTypedArrays(value) {
		var found = false;
		forEach(cache, function(getter, typedArray) {
			if (!found) try {
				if ("$" + getter(value) === typedArray) found = $slice(typedArray, 1);
			} catch (e$1) {}
		});
		return found;
	};
	var trySlices = function tryAllSlices(value) {
		var found = false;
		forEach(cache, function(getter, name) {
			if (!found) try {
				getter(value);
				found = $slice(name, 1);
			} catch (e$1) {}
		});
		return found;
	};
	module.exports = function whichTypedArray$2(value) {
		if (!value || typeof value !== "object") return false;
		if (!hasToStringTag) {
			var tag = $slice($toString(value), 8, -1);
			if ($indexOf(typedArrays, tag) > -1) return tag;
			if (tag !== "Object") return false;
			return trySlices(value);
		}
		if (!gOPD) return null;
		return tryTypedArrays(value);
	};
}));
var require_is_typed_array = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var whichTypedArray$1 = require_which_typed_array();
	module.exports = function isTypedArray$2(value) {
		return !!whichTypedArray$1(value);
	};
}));
var require_types$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var isArgumentsObject = require_is_arguments();
	var isGeneratorFunction = require_is_generator_function();
	var whichTypedArray = require_which_typed_array();
	var isTypedArray = require_is_typed_array();
	function uncurryThis$1(f$1) {
		return f$1.call.bind(f$1);
	}
	var BigIntSupported = typeof BigInt !== "undefined";
	var SymbolSupported = typeof Symbol !== "undefined";
	var ObjectToString = uncurryThis$1(Object.prototype.toString);
	var numberValue = uncurryThis$1(Number.prototype.valueOf);
	var stringValue = uncurryThis$1(String.prototype.valueOf);
	var booleanValue = uncurryThis$1(Boolean.prototype.valueOf);
	if (BigIntSupported) var bigIntValue = uncurryThis$1(BigInt.prototype.valueOf);
	if (SymbolSupported) var symbolValue = uncurryThis$1(Symbol.prototype.valueOf);
	function checkBoxedPrimitive(value, prototypeValueOf) {
		if (typeof value !== "object") return false;
		try {
			prototypeValueOf(value);
			return true;
		} catch (e$1) {
			return false;
		}
	}
	exports.isArgumentsObject = isArgumentsObject;
	exports.isGeneratorFunction = isGeneratorFunction;
	exports.isTypedArray = isTypedArray;
	function isPromise$1(input) {
		return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
	}
	exports.isPromise = isPromise$1;
	function isArrayBufferView$1(value) {
		if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
		return isTypedArray(value) || isDataView(value);
	}
	exports.isArrayBufferView = isArrayBufferView$1;
	function isUint8Array(value) {
		return whichTypedArray(value) === "Uint8Array";
	}
	exports.isUint8Array = isUint8Array;
	function isUint8ClampedArray(value) {
		return whichTypedArray(value) === "Uint8ClampedArray";
	}
	exports.isUint8ClampedArray = isUint8ClampedArray;
	function isUint16Array(value) {
		return whichTypedArray(value) === "Uint16Array";
	}
	exports.isUint16Array = isUint16Array;
	function isUint32Array(value) {
		return whichTypedArray(value) === "Uint32Array";
	}
	exports.isUint32Array = isUint32Array;
	function isInt8Array(value) {
		return whichTypedArray(value) === "Int8Array";
	}
	exports.isInt8Array = isInt8Array;
	function isInt16Array(value) {
		return whichTypedArray(value) === "Int16Array";
	}
	exports.isInt16Array = isInt16Array;
	function isInt32Array(value) {
		return whichTypedArray(value) === "Int32Array";
	}
	exports.isInt32Array = isInt32Array;
	function isFloat32Array$1(value) {
		return whichTypedArray(value) === "Float32Array";
	}
	exports.isFloat32Array = isFloat32Array$1;
	function isFloat64Array$1(value) {
		return whichTypedArray(value) === "Float64Array";
	}
	exports.isFloat64Array = isFloat64Array$1;
	function isBigInt64Array(value) {
		return whichTypedArray(value) === "BigInt64Array";
	}
	exports.isBigInt64Array = isBigInt64Array;
	function isBigUint64Array(value) {
		return whichTypedArray(value) === "BigUint64Array";
	}
	exports.isBigUint64Array = isBigUint64Array;
	function isMapToString(value) {
		return ObjectToString(value) === "[object Map]";
	}
	isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
	function isMap$3(value) {
		if (typeof Map === "undefined") return false;
		return isMapToString.working ? isMapToString(value) : value instanceof Map;
	}
	exports.isMap = isMap$3;
	function isSetToString(value) {
		return ObjectToString(value) === "[object Set]";
	}
	isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
	function isSet$3(value) {
		if (typeof Set === "undefined") return false;
		return isSetToString.working ? isSetToString(value) : value instanceof Set;
	}
	exports.isSet = isSet$3;
	function isWeakMapToString(value) {
		return ObjectToString(value) === "[object WeakMap]";
	}
	isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
	function isWeakMap(value) {
		if (typeof WeakMap === "undefined") return false;
		return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
	}
	exports.isWeakMap = isWeakMap;
	function isWeakSetToString(value) {
		return ObjectToString(value) === "[object WeakSet]";
	}
	isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
	function isWeakSet(value) {
		return isWeakSetToString(value);
	}
	exports.isWeakSet = isWeakSet;
	function isArrayBufferToString(value) {
		return ObjectToString(value) === "[object ArrayBuffer]";
	}
	isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(/* @__PURE__ */ new ArrayBuffer());
	function isArrayBuffer(value) {
		if (typeof ArrayBuffer === "undefined") return false;
		return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
	}
	exports.isArrayBuffer = isArrayBuffer;
	function isDataViewToString(value) {
		return ObjectToString(value) === "[object DataView]";
	}
	isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(/* @__PURE__ */ new ArrayBuffer(1), 0, 1));
	function isDataView(value) {
		if (typeof DataView === "undefined") return false;
		return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
	}
	exports.isDataView = isDataView;
	var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
	function isSharedArrayBufferToString(value) {
		return ObjectToString(value) === "[object SharedArrayBuffer]";
	}
	function isSharedArrayBuffer(value) {
		if (typeof SharedArrayBufferCopy === "undefined") return false;
		if (typeof isSharedArrayBufferToString.working === "undefined") isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
	}
	exports.isSharedArrayBuffer = isSharedArrayBuffer;
	function isAsyncFunction(value) {
		return ObjectToString(value) === "[object AsyncFunction]";
	}
	exports.isAsyncFunction = isAsyncFunction;
	function isMapIterator(value) {
		return ObjectToString(value) === "[object Map Iterator]";
	}
	exports.isMapIterator = isMapIterator;
	function isSetIterator(value) {
		return ObjectToString(value) === "[object Set Iterator]";
	}
	exports.isSetIterator = isSetIterator;
	function isGeneratorObject(value) {
		return ObjectToString(value) === "[object Generator]";
	}
	exports.isGeneratorObject = isGeneratorObject;
	function isWebAssemblyCompiledModule(value) {
		return ObjectToString(value) === "[object WebAssembly.Module]";
	}
	exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
	function isNumberObject$1(value) {
		return checkBoxedPrimitive(value, numberValue);
	}
	exports.isNumberObject = isNumberObject$1;
	function isStringObject$1(value) {
		return checkBoxedPrimitive(value, stringValue);
	}
	exports.isStringObject = isStringObject$1;
	function isBooleanObject$1(value) {
		return checkBoxedPrimitive(value, booleanValue);
	}
	exports.isBooleanObject = isBooleanObject$1;
	function isBigIntObject$1(value) {
		return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
	}
	exports.isBigIntObject = isBigIntObject$1;
	function isSymbolObject$1(value) {
		return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
	}
	exports.isSymbolObject = isSymbolObject$1;
	function isBoxedPrimitive$1(value) {
		return isNumberObject$1(value) || isStringObject$1(value) || isBooleanObject$1(value) || isBigIntObject$1(value) || isSymbolObject$1(value);
	}
	exports.isBoxedPrimitive = isBoxedPrimitive$1;
	function isAnyArrayBuffer$1(value) {
		return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
	}
	exports.isAnyArrayBuffer = isAnyArrayBuffer$1;
	[
		"isProxy",
		"isExternal",
		"isModuleNamespaceObject"
	].forEach(function(method$1) {
		Object.defineProperty(exports, method$1, {
			enumerable: false,
			value: function() {
				throw new Error(method$1 + " is not supported in userland");
			}
		});
	});
}));
var require_isBufferBrowser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function isBuffer$3(arg) {
		return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
	};
}));
var require_util$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	init_dist$1();
	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors$1(obj) {
		var keys$9 = Object.keys(obj);
		var descriptors = {};
		for (var i$2 = 0; i$2 < keys$9.length; i$2++) descriptors[keys$9[i$2]] = Object.getOwnPropertyDescriptor(obj, keys$9[i$2]);
		return descriptors;
	};
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f$1) {
		if (!isString$2(f$1)) {
			var objects = [];
			for (var i$2 = 0; i$2 < arguments.length; i$2++) objects.push(inspect$3(arguments[i$2]));
			return objects.join(" ");
		}
		var i$2 = 1;
		var args = arguments;
		var len$1 = args.length;
		var str = String(f$1).replace(formatRegExp, function(x$2) {
			if (x$2 === "%%") return "%";
			if (i$2 >= len$1) return x$2;
			switch (x$2) {
				case "%s": return String(args[i$2++]);
				case "%d": return Number(args[i$2++]);
				case "%j": try {
					return JSON.stringify(args[i$2++]);
				} catch (_$1) {
					return "[Circular]";
				}
				default: return x$2;
			}
		});
		for (var x$1 = args[i$2]; i$2 < len$1; x$1 = args[++i$2]) if (isNull(x$1) || !isObject$7(x$1)) str += " " + x$1;
		else str += " " + inspect$3(x$1);
		return str;
	};
	exports.deprecate = function(fn$1, msg) {
		if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) return fn$1;
		if (typeof process$1 === "undefined") return function() {
			return exports.deprecate(fn$1, msg).apply(this, arguments);
		};
		var warned$1 = false;
		function deprecated() {
			if (!warned$1) {
				if (process$1.throwDeprecation) throw new Error(msg);
				else if (process$1.traceDeprecation) console.trace(msg);
				else console.error(msg);
				warned$1 = true;
			}
			return fn$1.apply(this, arguments);
		}
		return deprecated;
	};
	var debugs = {};
	var debugEnvRegex = /^$/;
	if ({}.NODE_DEBUG) {
		var debugEnv = {}.NODE_DEBUG;
		debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
		debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
	}
	exports.debuglog = function(set) {
		set = set.toUpperCase();
		if (!debugs[set]) if (debugEnvRegex.test(set)) {
			var pid = process$1.pid;
			debugs[set] = function() {
				var msg = exports.format.apply(exports, arguments);
				console.error("%s %d: %s", set, pid, msg);
			};
		} else debugs[set] = function() {};
		return debugs[set];
	};
	function inspect$3(obj, opts) {
		var ctx = {
			seen: [],
			stylize: stylizeNoColor
		};
		if (arguments.length >= 3) ctx.depth = arguments[2];
		if (arguments.length >= 4) ctx.colors = arguments[3];
		if (isBoolean(opts)) ctx.showHidden = opts;
		else if (opts) exports._extend(ctx, opts);
		if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		if (isUndefined(ctx.depth)) ctx.depth = 2;
		if (isUndefined(ctx.colors)) ctx.colors = false;
		if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		if (ctx.colors) ctx.stylize = stylizeWithColor;
		return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect$3;
	inspect$3.colors = {
		"bold": [1, 22],
		"italic": [3, 23],
		"underline": [4, 24],
		"inverse": [7, 27],
		"white": [37, 39],
		"grey": [90, 39],
		"black": [30, 39],
		"blue": [34, 39],
		"cyan": [36, 39],
		"green": [32, 39],
		"magenta": [35, 39],
		"red": [31, 39],
		"yellow": [33, 39]
	};
	inspect$3.styles = {
		"special": "cyan",
		"number": "yellow",
		"boolean": "yellow",
		"undefined": "grey",
		"null": "bold",
		"string": "green",
		"date": "magenta",
		"regexp": "red"
	};
	function stylizeWithColor(str, styleType) {
		var style = inspect$3.styles[styleType];
		if (style) return "\x1B[" + inspect$3.colors[style][0] + "m" + str + "\x1B[" + inspect$3.colors[style][1] + "m";
		else return str;
	}
	function stylizeNoColor(str, styleType) {
		return str;
	}
	function arrayToHash(array) {
		var hash$1 = {};
		array.forEach(function(val, idx) {
			hash$1[val] = true;
		});
		return hash$1;
	}
	function formatValue(ctx, value, recurseTimes) {
		if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
			var ret = value.inspect(recurseTimes, ctx);
			if (!isString$2(ret)) ret = formatValue(ctx, ret, recurseTimes);
			return ret;
		}
		var primitive = formatPrimitive(ctx, value);
		if (primitive) return primitive;
		var keys$9 = Object.keys(value);
		var visibleKeys = arrayToHash(keys$9);
		if (ctx.showHidden) keys$9 = Object.getOwnPropertyNames(value);
		if (isError(value) && (keys$9.indexOf("message") >= 0 || keys$9.indexOf("description") >= 0)) return formatError(value);
		if (keys$9.length === 0) {
			if (isFunction(value)) {
				var name = value.name ? ": " + value.name : "";
				return ctx.stylize("[Function" + name + "]", "special");
			}
			if (isRegExp$2(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
			if (isDate$2(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
			if (isError(value)) return formatError(value);
		}
		var base = "", array = false, braces = ["{", "}"];
		if (isArray$7(value)) {
			array = true;
			braces = ["[", "]"];
		}
		if (isFunction(value)) base = " [Function" + (value.name ? ": " + value.name : "") + "]";
		if (isRegExp$2(value)) base = " " + RegExp.prototype.toString.call(value);
		if (isDate$2(value)) base = " " + Date.prototype.toUTCString.call(value);
		if (isError(value)) base = " " + formatError(value);
		if (keys$9.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
		if (recurseTimes < 0) if (isRegExp$2(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
		else return ctx.stylize("[Object]", "special");
		ctx.seen.push(value);
		var output;
		if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys$9);
		else output = keys$9.map(function(key) {
			return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		});
		ctx.seen.pop();
		return reduceToSingleString(output, base, braces);
	}
	function formatPrimitive(ctx, value) {
		if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
		if (isString$2(value)) {
			var simple$1 = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\"") + "'";
			return ctx.stylize(simple$1, "string");
		}
		if (isNumber$1(value)) return ctx.stylize("" + value, "number");
		if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
		if (isNull(value)) return ctx.stylize("null", "null");
	}
	function formatError(value) {
		return "[" + Error.prototype.toString.call(value) + "]";
	}
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys$9) {
		var output = [];
		for (var i$2 = 0, l$2 = value.length; i$2 < l$2; ++i$2) if (hasOwnProperty$4(value, String(i$2))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i$2), true));
		else output.push("");
		keys$9.forEach(function(key) {
			if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
		});
		return output;
	}
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		var name, str, desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		if (desc.get) if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
		else str = ctx.stylize("[Getter]", "special");
		else if (desc.set) str = ctx.stylize("[Setter]", "special");
		if (!hasOwnProperty$4(visibleKeys, key)) name = "[" + key + "]";
		if (!str) if (ctx.seen.indexOf(desc.value) < 0) {
			if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
			else str = formatValue(ctx, desc.value, recurseTimes - 1);
			if (str.indexOf("\n") > -1) if (array) str = str.split("\n").map(function(line) {
				return "  " + line;
			}).join("\n").slice(2);
			else str = "\n" + str.split("\n").map(function(line) {
				return "   " + line;
			}).join("\n");
		} else str = ctx.stylize("[Circular]", "special");
		if (isUndefined(name)) {
			if (array && key.match(/^\d+$/)) return str;
			name = JSON.stringify("" + key);
			if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
				name = name.slice(1, -1);
				name = ctx.stylize(name, "name");
			} else {
				name = name.replace(/'/g, "\\'").replace(/\\"/g, "\"").replace(/(^"|"$)/g, "'");
				name = ctx.stylize(name, "string");
			}
		}
		return name + ": " + str;
	}
	function reduceToSingleString(output, base, braces) {
		var numLinesEst = 0;
		if (output.reduce(function(prev, cur) {
			numLinesEst++;
			if (cur.indexOf("\n") >= 0) numLinesEst++;
			return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
		}, 0) > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
		return braces[0] + base + " " + output.join(", ") + " " + braces[1];
	}
	exports.types = require_types$2();
	function isArray$7(ar) {
		return Array.isArray(ar);
	}
	exports.isArray = isArray$7;
	function isBoolean(arg) {
		return typeof arg === "boolean";
	}
	exports.isBoolean = isBoolean;
	function isNull(arg) {
		return arg === null;
	}
	exports.isNull = isNull;
	function isNullOrUndefined(arg) {
		return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	function isNumber$1(arg) {
		return typeof arg === "number";
	}
	exports.isNumber = isNumber$1;
	function isString$2(arg) {
		return typeof arg === "string";
	}
	exports.isString = isString$2;
	function isSymbol(arg) {
		return typeof arg === "symbol";
	}
	exports.isSymbol = isSymbol;
	function isUndefined(arg) {
		return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	function isRegExp$2(re) {
		return isObject$7(re) && objectToString$1(re) === "[object RegExp]";
	}
	exports.isRegExp = isRegExp$2;
	exports.types.isRegExp = isRegExp$2;
	function isObject$7(arg) {
		return typeof arg === "object" && arg !== null;
	}
	exports.isObject = isObject$7;
	function isDate$2(d$1) {
		return isObject$7(d$1) && objectToString$1(d$1) === "[object Date]";
	}
	exports.isDate = isDate$2;
	exports.types.isDate = isDate$2;
	function isError(e$1) {
		return isObject$7(e$1) && (objectToString$1(e$1) === "[object Error]" || e$1 instanceof Error);
	}
	exports.isError = isError;
	exports.types.isNativeError = isError;
	function isFunction(arg) {
		return typeof arg === "function";
	}
	exports.isFunction = isFunction;
	function isPrimitive(arg) {
		return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
	}
	exports.isPrimitive = isPrimitive;
	exports.isBuffer = require_isBufferBrowser();
	function objectToString$1(o$1) {
		return Object.prototype.toString.call(o$1);
	}
	function pad(n$6) {
		return n$6 < 10 ? "0" + n$6.toString(10) : n$6.toString(10);
	}
	var months = [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	];
	function timestamp() {
		var d$1 = /* @__PURE__ */ new Date();
		var time = [
			pad(d$1.getHours()),
			pad(d$1.getMinutes()),
			pad(d$1.getSeconds())
		].join(":");
		return [
			d$1.getDate(),
			months[d$1.getMonth()],
			time
		].join(" ");
	}
	exports.log = function() {
		console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
	};
	exports.inherits = require_inherits_browser();
	exports._extend = function(origin, add) {
		if (!add || !isObject$7(add)) return origin;
		var keys$9 = Object.keys(add);
		var i$2 = keys$9.length;
		while (i$2--) origin[keys$9[i$2]] = add[keys$9[i$2]];
		return origin;
	};
	function hasOwnProperty$4(obj, prop) {
		return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
	exports.promisify = function promisify(original) {
		if (typeof original !== "function") throw new TypeError("The \"original\" argument must be of type Function");
		if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
			var fn$1 = original[kCustomPromisifiedSymbol];
			if (typeof fn$1 !== "function") throw new TypeError("The \"util.promisify.custom\" argument must be of type Function");
			Object.defineProperty(fn$1, kCustomPromisifiedSymbol, {
				value: fn$1,
				enumerable: false,
				writable: false,
				configurable: true
			});
			return fn$1;
		}
		function fn$1() {
			var promiseResolve, promiseReject;
			var promise = new Promise(function(resolve, reject) {
				promiseResolve = resolve;
				promiseReject = reject;
			});
			var args = [];
			for (var i$2 = 0; i$2 < arguments.length; i$2++) args.push(arguments[i$2]);
			args.push(function(err, value) {
				if (err) promiseReject(err);
				else promiseResolve(value);
			});
			try {
				original.apply(this, args);
			} catch (err) {
				promiseReject(err);
			}
			return promise;
		}
		Object.setPrototypeOf(fn$1, Object.getPrototypeOf(original));
		if (kCustomPromisifiedSymbol) Object.defineProperty(fn$1, kCustomPromisifiedSymbol, {
			value: fn$1,
			enumerable: false,
			writable: false,
			configurable: true
		});
		return Object.defineProperties(fn$1, getOwnPropertyDescriptors(original));
	};
	exports.promisify.custom = kCustomPromisifiedSymbol;
	function callbackifyOnRejected(reason, cb) {
		if (!reason) {
			var newReason = /* @__PURE__ */ new Error("Promise was rejected with a falsy value");
			newReason.reason = reason;
			reason = newReason;
		}
		return cb(reason);
	}
	function callbackify(original) {
		if (typeof original !== "function") throw new TypeError("The \"original\" argument must be of type Function");
		function callbackified() {
			var args = [];
			for (var i$2 = 0; i$2 < arguments.length; i$2++) args.push(arguments[i$2]);
			var maybeCb = args.pop();
			if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
			var self$1 = this;
			var cb = function() {
				return maybeCb.apply(self$1, arguments);
			};
			original.apply(this, args).then(function(ret) {
				process$1.nextTick(cb.bind(null, null, ret));
			}, function(rej) {
				process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
			});
		}
		Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
		return callbackified;
	}
	exports.callbackify = callbackify;
}));
var require_buffer_list = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function ownKeys$2(object, enumerableOnly) {
		var keys$9 = Object.keys(object);
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return Object.getOwnPropertyDescriptor(object, sym).enumerable;
			});
			keys$9.push.apply(keys$9, symbols);
		}
		return keys$9;
	}
	function _objectSpread$1(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2] != null ? arguments[i$2] : {};
			if (i$2 % 2) ownKeys$2(Object(source), true).forEach(function(key) {
				_defineProperty$2(target, key, source[key]);
			});
			else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
			else ownKeys$2(Object(source)).forEach(function(key) {
				Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
			});
		}
		return target;
	}
	function _defineProperty$2(obj, key, value) {
		if (key in obj) Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
		else obj[key] = value;
		return obj;
	}
	function _classCallCheck$3(instance, Constructor) {
		if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	}
	function _defineProperties$3(target, props) {
		for (var i$2 = 0; i$2 < props.length; i$2++) {
			var descriptor = props[i$2];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}
	function _createClass$3(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties$3(Constructor, staticProps);
		return Constructor;
	}
	var Buffer$5 = require_buffer().Buffer;
	var inspect$2 = require_util$2().inspect;
	var custom = inspect$2 && inspect$2.custom || "inspect";
	function copyBuffer(src, target, offset$1) {
		Buffer$5.prototype.copy.call(src, target, offset$1);
	}
	module.exports = /* @__PURE__ */ function() {
		function BufferList$1() {
			_classCallCheck$3(this, BufferList$1);
			this.head = null;
			this.tail = null;
			this.length = 0;
		}
		_createClass$3(BufferList$1, [
			{
				key: "push",
				value: function push(v$3) {
					var entry = {
						data: v$3,
						next: null
					};
					if (this.length > 0) this.tail.next = entry;
					else this.head = entry;
					this.tail = entry;
					++this.length;
				}
			},
			{
				key: "unshift",
				value: function unshift(v$3) {
					var entry = {
						data: v$3,
						next: this.head
					};
					if (this.length === 0) this.tail = entry;
					this.head = entry;
					++this.length;
				}
			},
			{
				key: "shift",
				value: function shift() {
					if (this.length === 0) return;
					var ret = this.head.data;
					if (this.length === 1) this.head = this.tail = null;
					else this.head = this.head.next;
					--this.length;
					return ret;
				}
			},
			{
				key: "clear",
				value: function clear() {
					this.head = this.tail = null;
					this.length = 0;
				}
			},
			{
				key: "join",
				value: function join$1(s$2) {
					if (this.length === 0) return "";
					var p$1 = this.head;
					var ret = "" + p$1.data;
					while (p$1 = p$1.next) ret += s$2 + p$1.data;
					return ret;
				}
			},
			{
				key: "concat",
				value: function concat$2(n$6) {
					if (this.length === 0) return Buffer$5.alloc(0);
					var ret = Buffer$5.allocUnsafe(n$6 >>> 0);
					var p$1 = this.head;
					var i$2 = 0;
					while (p$1) {
						copyBuffer(p$1.data, ret, i$2);
						i$2 += p$1.data.length;
						p$1 = p$1.next;
					}
					return ret;
				}
			},
			{
				key: "consume",
				value: function consume(n$6, hasStrings) {
					var ret;
					if (n$6 < this.head.data.length) {
						ret = this.head.data.slice(0, n$6);
						this.head.data = this.head.data.slice(n$6);
					} else if (n$6 === this.head.data.length) ret = this.shift();
					else ret = hasStrings ? this._getString(n$6) : this._getBuffer(n$6);
					return ret;
				}
			},
			{
				key: "first",
				value: function first$1() {
					return this.head.data;
				}
			},
			{
				key: "_getString",
				value: function _getString(n$6) {
					var p$1 = this.head;
					var c$1 = 1;
					var ret = p$1.data;
					n$6 -= ret.length;
					while (p$1 = p$1.next) {
						var str = p$1.data;
						var nb = n$6 > str.length ? str.length : n$6;
						if (nb === str.length) ret += str;
						else ret += str.slice(0, n$6);
						n$6 -= nb;
						if (n$6 === 0) {
							if (nb === str.length) {
								++c$1;
								if (p$1.next) this.head = p$1.next;
								else this.head = this.tail = null;
							} else {
								this.head = p$1;
								p$1.data = str.slice(nb);
							}
							break;
						}
						++c$1;
					}
					this.length -= c$1;
					return ret;
				}
			},
			{
				key: "_getBuffer",
				value: function _getBuffer(n$6) {
					var ret = Buffer$5.allocUnsafe(n$6);
					var p$1 = this.head;
					var c$1 = 1;
					p$1.data.copy(ret);
					n$6 -= p$1.data.length;
					while (p$1 = p$1.next) {
						var buf = p$1.data;
						var nb = n$6 > buf.length ? buf.length : n$6;
						buf.copy(ret, ret.length - n$6, 0, nb);
						n$6 -= nb;
						if (n$6 === 0) {
							if (nb === buf.length) {
								++c$1;
								if (p$1.next) this.head = p$1.next;
								else this.head = this.tail = null;
							} else {
								this.head = p$1;
								p$1.data = buf.slice(nb);
							}
							break;
						}
						++c$1;
					}
					this.length -= c$1;
					return ret;
				}
			},
			{
				key: custom,
				value: function value(_$1, options) {
					return inspect$2(this, _objectSpread$1({}, options, {
						depth: 0,
						customInspect: false
					}));
				}
			}
		]);
		return BufferList$1;
	}();
}));
var require_destroy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist$1();
	function destroy(err, cb) {
		var _this = this;
		var readableDestroyed = this._readableState && this._readableState.destroyed;
		var writableDestroyed = this._writableState && this._writableState.destroyed;
		if (readableDestroyed || writableDestroyed) {
			if (cb) cb(err);
			else if (err) {
				if (!this._writableState) process$1.nextTick(emitErrorNT, this, err);
				else if (!this._writableState.errorEmitted) {
					this._writableState.errorEmitted = true;
					process$1.nextTick(emitErrorNT, this, err);
				}
			}
			return this;
		}
		if (this._readableState) this._readableState.destroyed = true;
		if (this._writableState) this._writableState.destroyed = true;
		this._destroy(err || null, function(err$1) {
			if (!cb && err$1) if (!_this._writableState) process$1.nextTick(emitErrorAndCloseNT, _this, err$1);
			else if (!_this._writableState.errorEmitted) {
				_this._writableState.errorEmitted = true;
				process$1.nextTick(emitErrorAndCloseNT, _this, err$1);
			} else process$1.nextTick(emitCloseNT, _this);
			else if (cb) {
				process$1.nextTick(emitCloseNT, _this);
				cb(err$1);
			} else process$1.nextTick(emitCloseNT, _this);
		});
		return this;
	}
	function emitErrorAndCloseNT(self$1, err) {
		emitErrorNT(self$1, err);
		emitCloseNT(self$1);
	}
	function emitCloseNT(self$1) {
		if (self$1._writableState && !self$1._writableState.emitClose) return;
		if (self$1._readableState && !self$1._readableState.emitClose) return;
		self$1.emit("close");
	}
	function undestroy() {
		if (this._readableState) {
			this._readableState.destroyed = false;
			this._readableState.reading = false;
			this._readableState.ended = false;
			this._readableState.endEmitted = false;
		}
		if (this._writableState) {
			this._writableState.destroyed = false;
			this._writableState.ended = false;
			this._writableState.ending = false;
			this._writableState.finalCalled = false;
			this._writableState.prefinished = false;
			this._writableState.finished = false;
			this._writableState.errorEmitted = false;
		}
	}
	function emitErrorNT(self$1, err) {
		self$1.emit("error", err);
	}
	function errorOrDestroy$2(stream, err) {
		var rState = stream._readableState;
		var wState = stream._writableState;
		if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
		else stream.emit("error", err);
	}
	module.exports = {
		destroy,
		undestroy,
		errorOrDestroy: errorOrDestroy$2
	};
}));
var require_errors_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _inheritsLoose(subClass, superClass) {
		subClass.prototype = Object.create(superClass.prototype);
		subClass.prototype.constructor = subClass;
		subClass.__proto__ = superClass;
	}
	var codes$1 = {};
	function createErrorType$1(code$1, message, Base) {
		if (!Base) Base = Error;
		function getMessage(arg1, arg2, arg3) {
			if (typeof message === "string") return message;
			else return message(arg1, arg2, arg3);
		}
		var NodeError = /* @__PURE__ */ function(_Base) {
			_inheritsLoose(NodeError$1, _Base);
			function NodeError$1(arg1, arg2, arg3) {
				return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
			}
			return NodeError$1;
		}(Base);
		NodeError.prototype.name = Base.name;
		NodeError.prototype.code = code$1;
		codes$1[code$1] = NodeError;
	}
	function oneOf$1(expected, thing) {
		if (Array.isArray(expected)) {
			var len$1 = expected.length;
			expected = expected.map(function(i$2) {
				return String(i$2);
			});
			if (len$1 > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len$1 - 1).join(", "), ", or ") + expected[len$1 - 1];
			else if (len$1 === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
			else return "of ".concat(thing, " ").concat(expected[0]);
		} else return "of ".concat(thing, " ").concat(String(expected));
	}
	function startsWith$1(str, search, pos) {
		return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	}
	function endsWith$2(str, search, this_len) {
		if (this_len === void 0 || this_len > str.length) this_len = str.length;
		return str.substring(this_len - search.length, this_len) === search;
	}
	function includes$1(str, search, start) {
		if (typeof start !== "number") start = 0;
		if (start + search.length > str.length) return false;
		else return str.indexOf(search, start) !== -1;
	}
	createErrorType$1("ERR_INVALID_OPT_VALUE", function(name, value) {
		return "The value \"" + value + "\" is invalid for option \"" + name + "\"";
	}, TypeError);
	createErrorType$1("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
		var determiner;
		if (typeof expected === "string" && startsWith$1(expected, "not ")) {
			determiner = "must not be";
			expected = expected.replace(/^not /, "");
		} else determiner = "must be";
		var msg;
		if (endsWith$2(name, " argument")) msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf$1(expected, "type"));
		else {
			var type = includes$1(name, ".") ? "property" : "argument";
			msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf$1(expected, "type"));
		}
		msg += ". Received type ".concat(typeof actual);
		return msg;
	}, TypeError);
	createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
	createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
		return "The " + name + " method is not implemented";
	});
	createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
	createErrorType$1("ERR_STREAM_DESTROYED", function(name) {
		return "Cannot call " + name + " after a stream was destroyed";
	});
	createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
	createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
	createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
	createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
	createErrorType$1("ERR_UNKNOWN_ENCODING", function(arg) {
		return "Unknown encoding: " + arg;
	}, TypeError);
	createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
	module.exports.codes = codes$1;
}));
var require_state = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
		return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark$2(state, options, duplexKey, isDuplex) {
		var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
		if (hwm != null) {
			if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) throw new ERR_INVALID_OPT_VALUE(isDuplex ? duplexKey : "highWaterMark", hwm);
			return Math.floor(hwm);
		}
		return state.objectMode ? 16 : 16 * 1024;
	}
	module.exports = { getHighWaterMark: getHighWaterMark$2 };
}));
var require_browser$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	module.exports = deprecate;
	function deprecate(fn$1, msg) {
		if (config("noDeprecation")) return fn$1;
		var warned$1 = false;
		function deprecated() {
			if (!warned$1) {
				if (config("throwDeprecation")) throw new Error(msg);
				else if (config("traceDeprecation")) console.trace(msg);
				else console.warn(msg);
				warned$1 = true;
			}
			return fn$1.apply(this, arguments);
		}
		return deprecated;
	}
	function config(name) {
		try {
			if (!global.localStorage) return false;
		} catch (_$1) {
			return false;
		}
		var val = global.localStorage[name];
		if (null == val) return false;
		return String(val).toLowerCase() === "true";
	}
}));
var require__stream_writable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	init_dist$1();
	module.exports = Writable$1;
	function CorkedRequest(state) {
		var _this = this;
		this.next = null;
		this.entry = null;
		this.finish = function() {
			onCorkedFinish(_this, state);
		};
	}
	var Duplex$3;
	Writable$1.WritableState = WritableState;
	var internalUtil = { deprecate: require_browser$1() };
	var Stream$2 = require_stream_browser();
	var Buffer$4 = require_buffer().Buffer;
	var OurUint8Array$1 = global.Uint8Array || function() {};
	function _uint8ArrayToBuffer$1(chunk$1) {
		return Buffer$4.from(chunk$1);
	}
	function _isUint8Array$1(obj) {
		return Buffer$4.isBuffer(obj) || obj instanceof OurUint8Array$1;
	}
	var destroyImpl$1 = require_destroy();
	var getHighWaterMark$1 = require_state().getHighWaterMark;
	var _require$codes$4 = require_errors_browser().codes, ERR_INVALID_ARG_TYPE$3 = _require$codes$4.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$4.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$4.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes$4.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED$1 = _require$codes$4.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes$4.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes$4.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes$4.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
	require_inherits_browser()(Writable$1, Stream$2);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
		Duplex$3 = Duplex$3 || require__stream_duplex();
		options = options || {};
		if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex$3;
		this.objectMode = !!options.objectMode;
		if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
		this.highWaterMark = getHighWaterMark$1(this, options, "writableHighWaterMark", isDuplex);
		this.finalCalled = false;
		this.needDrain = false;
		this.ending = false;
		this.ended = false;
		this.finished = false;
		this.destroyed = false;
		this.decodeStrings = !(options.decodeStrings === false);
		this.defaultEncoding = options.defaultEncoding || "utf8";
		this.length = 0;
		this.writing = false;
		this.corked = 0;
		this.sync = true;
		this.bufferProcessing = false;
		this.onwrite = function(er) {
			onwrite(stream, er);
		};
		this.writecb = null;
		this.writelen = 0;
		this.bufferedRequest = null;
		this.lastBufferedRequest = null;
		this.pendingcb = 0;
		this.prefinished = false;
		this.errorEmitted = false;
		this.emitClose = options.emitClose !== false;
		this.autoDestroy = !!options.autoDestroy;
		this.bufferedRequestCount = 0;
		this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
		var current = this.bufferedRequest;
		var out = [];
		while (current) {
			out.push(current);
			current = current.next;
		}
		return out;
	};
	(function() {
		try {
			Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function writableStateBufferGetter() {
				return this.getBuffer();
			}, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
		} catch (_$1) {}
	})();
	var realHasInstance;
	if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
		realHasInstance = Function.prototype[Symbol.hasInstance];
		Object.defineProperty(Writable$1, Symbol.hasInstance, { value: function value(object) {
			if (realHasInstance.call(this, object)) return true;
			if (this !== Writable$1) return false;
			return object && object._writableState instanceof WritableState;
		} });
	} else realHasInstance = function realHasInstance$1(object) {
		return object instanceof this;
	};
	function Writable$1(options) {
		Duplex$3 = Duplex$3 || require__stream_duplex();
		var isDuplex = this instanceof Duplex$3;
		if (!isDuplex && !realHasInstance.call(Writable$1, this)) return new Writable$1(options);
		this._writableState = new WritableState(options, this, isDuplex);
		this.writable = true;
		if (options) {
			if (typeof options.write === "function") this._write = options.write;
			if (typeof options.writev === "function") this._writev = options.writev;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.final === "function") this._final = options.final;
		}
		Stream$2.call(this);
	}
	Writable$1.prototype.pipe = function() {
		errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
		var er = new ERR_STREAM_WRITE_AFTER_END();
		errorOrDestroy$1(stream, er);
		process$1.nextTick(cb, er);
	}
	function validChunk(stream, state, chunk$1, cb) {
		var er;
		if (chunk$1 === null) er = new ERR_STREAM_NULL_VALUES();
		else if (typeof chunk$1 !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE$3("chunk", ["string", "Buffer"], chunk$1);
		if (er) {
			errorOrDestroy$1(stream, er);
			process$1.nextTick(cb, er);
			return false;
		}
		return true;
	}
	Writable$1.prototype.write = function(chunk$1, encoding, cb) {
		var state = this._writableState;
		var ret = false;
		var isBuf = !state.objectMode && _isUint8Array$1(chunk$1);
		if (isBuf && !Buffer$4.isBuffer(chunk$1)) chunk$1 = _uint8ArrayToBuffer$1(chunk$1);
		if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		if (isBuf) encoding = "buffer";
		else if (!encoding) encoding = state.defaultEncoding;
		if (typeof cb !== "function") cb = nop;
		if (state.ending) writeAfterEnd(this, cb);
		else if (isBuf || validChunk(this, state, chunk$1, cb)) {
			state.pendingcb++;
			ret = writeOrBuffer(this, state, isBuf, chunk$1, encoding, cb);
		}
		return ret;
	};
	Writable$1.prototype.cork = function() {
		this._writableState.corked++;
	};
	Writable$1.prototype.uncork = function() {
		var state = this._writableState;
		if (state.corked) {
			state.corked--;
			if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		}
	};
	Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		if (typeof encoding === "string") encoding = encoding.toLowerCase();
		if (!([
			"hex",
			"utf8",
			"utf-8",
			"ascii",
			"binary",
			"base64",
			"ucs2",
			"ucs-2",
			"utf16le",
			"utf-16le",
			"raw"
		].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
		this._writableState.defaultEncoding = encoding;
		return this;
	};
	Object.defineProperty(Writable$1.prototype, "writableBuffer", {
		enumerable: false,
		get: function get$2() {
			return this._writableState && this._writableState.getBuffer();
		}
	});
	function decodeChunk(state, chunk$1, encoding) {
		if (!state.objectMode && state.decodeStrings !== false && typeof chunk$1 === "string") chunk$1 = Buffer$4.from(chunk$1, encoding);
		return chunk$1;
	}
	Object.defineProperty(Writable$1.prototype, "writableHighWaterMark", {
		enumerable: false,
		get: function get$2() {
			return this._writableState.highWaterMark;
		}
	});
	function writeOrBuffer(stream, state, isBuf, chunk$1, encoding, cb) {
		if (!isBuf) {
			var newChunk = decodeChunk(state, chunk$1, encoding);
			if (chunk$1 !== newChunk) {
				isBuf = true;
				encoding = "buffer";
				chunk$1 = newChunk;
			}
		}
		var len$1 = state.objectMode ? 1 : chunk$1.length;
		state.length += len$1;
		var ret = state.length < state.highWaterMark;
		if (!ret) state.needDrain = true;
		if (state.writing || state.corked) {
			var last$1 = state.lastBufferedRequest;
			state.lastBufferedRequest = {
				chunk: chunk$1,
				encoding,
				isBuf,
				callback: cb,
				next: null
			};
			if (last$1) last$1.next = state.lastBufferedRequest;
			else state.bufferedRequest = state.lastBufferedRequest;
			state.bufferedRequestCount += 1;
		} else doWrite(stream, state, false, len$1, chunk$1, encoding, cb);
		return ret;
	}
	function doWrite(stream, state, writev, len$1, chunk$1, encoding, cb) {
		state.writelen = len$1;
		state.writecb = cb;
		state.writing = true;
		state.sync = true;
		if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1("write"));
		else if (writev) stream._writev(chunk$1, state.onwrite);
		else stream._write(chunk$1, encoding, state.onwrite);
		state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
		--state.pendingcb;
		if (sync) {
			process$1.nextTick(cb, er);
			process$1.nextTick(finishMaybe, stream, state);
			stream._writableState.errorEmitted = true;
			errorOrDestroy$1(stream, er);
		} else {
			cb(er);
			stream._writableState.errorEmitted = true;
			errorOrDestroy$1(stream, er);
			finishMaybe(stream, state);
		}
	}
	function onwriteStateUpdate(state) {
		state.writing = false;
		state.writecb = null;
		state.length -= state.writelen;
		state.writelen = 0;
	}
	function onwrite(stream, er) {
		var state = stream._writableState;
		var sync = state.sync;
		var cb = state.writecb;
		if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
		onwriteStateUpdate(state);
		if (er) onwriteError(stream, state, sync, er, cb);
		else {
			var finished$1 = needFinish(state) || stream.destroyed;
			if (!finished$1 && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
			if (sync) process$1.nextTick(afterWrite, stream, state, finished$1, cb);
			else afterWrite(stream, state, finished$1, cb);
		}
	}
	function afterWrite(stream, state, finished$1, cb) {
		if (!finished$1) onwriteDrain(stream, state);
		state.pendingcb--;
		cb();
		finishMaybe(stream, state);
	}
	function onwriteDrain(stream, state) {
		if (state.length === 0 && state.needDrain) {
			state.needDrain = false;
			stream.emit("drain");
		}
	}
	function clearBuffer(stream, state) {
		state.bufferProcessing = true;
		var entry = state.bufferedRequest;
		if (stream._writev && entry && entry.next) {
			var l$2 = state.bufferedRequestCount;
			var buffer$1 = new Array(l$2);
			var holder = state.corkedRequestsFree;
			holder.entry = entry;
			var count = 0;
			var allBuffers = true;
			while (entry) {
				buffer$1[count] = entry;
				if (!entry.isBuf) allBuffers = false;
				entry = entry.next;
				count += 1;
			}
			buffer$1.allBuffers = allBuffers;
			doWrite(stream, state, true, state.length, buffer$1, "", holder.finish);
			state.pendingcb++;
			state.lastBufferedRequest = null;
			if (holder.next) {
				state.corkedRequestsFree = holder.next;
				holder.next = null;
			} else state.corkedRequestsFree = new CorkedRequest(state);
			state.bufferedRequestCount = 0;
		} else {
			while (entry) {
				var chunk$1 = entry.chunk;
				var encoding = entry.encoding;
				var cb = entry.callback;
				doWrite(stream, state, false, state.objectMode ? 1 : chunk$1.length, chunk$1, encoding, cb);
				entry = entry.next;
				state.bufferedRequestCount--;
				if (state.writing) break;
			}
			if (entry === null) state.lastBufferedRequest = null;
		}
		state.bufferedRequest = entry;
		state.bufferProcessing = false;
	}
	Writable$1.prototype._write = function(chunk$1, encoding, cb) {
		cb(new ERR_METHOD_NOT_IMPLEMENTED$2("_write()"));
	};
	Writable$1.prototype._writev = null;
	Writable$1.prototype.end = function(chunk$1, encoding, cb) {
		var state = this._writableState;
		if (typeof chunk$1 === "function") {
			cb = chunk$1;
			chunk$1 = null;
			encoding = null;
		} else if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		if (chunk$1 !== null && chunk$1 !== void 0) this.write(chunk$1, encoding);
		if (state.corked) {
			state.corked = 1;
			this.uncork();
		}
		if (!state.ending) endWritable(this, state, cb);
		return this;
	};
	Object.defineProperty(Writable$1.prototype, "writableLength", {
		enumerable: false,
		get: function get$2() {
			return this._writableState.length;
		}
	});
	function needFinish(state) {
		return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
		stream._final(function(err) {
			state.pendingcb--;
			if (err) errorOrDestroy$1(stream, err);
			state.prefinished = true;
			stream.emit("prefinish");
			finishMaybe(stream, state);
		});
	}
	function prefinish$1(stream, state) {
		if (!state.prefinished && !state.finalCalled) if (typeof stream._final === "function" && !state.destroyed) {
			state.pendingcb++;
			state.finalCalled = true;
			process$1.nextTick(callFinal, stream, state);
		} else {
			state.prefinished = true;
			stream.emit("prefinish");
		}
	}
	function finishMaybe(stream, state) {
		var need = needFinish(state);
		if (need) {
			prefinish$1(stream, state);
			if (state.pendingcb === 0) {
				state.finished = true;
				stream.emit("finish");
				if (state.autoDestroy) {
					var rState = stream._readableState;
					if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
				}
			}
		}
		return need;
	}
	function endWritable(stream, state, cb) {
		state.ending = true;
		finishMaybe(stream, state);
		if (cb) if (state.finished) process$1.nextTick(cb);
		else stream.once("finish", cb);
		state.ended = true;
		stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
		var entry = corkReq.entry;
		corkReq.entry = null;
		while (entry) {
			var cb = entry.callback;
			state.pendingcb--;
			cb(err);
			entry = entry.next;
		}
		state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable$1.prototype, "destroyed", {
		enumerable: false,
		get: function get$2() {
			if (this._writableState === void 0) return false;
			return this._writableState.destroyed;
		},
		set: function set(value) {
			if (!this._writableState) return;
			this._writableState.destroyed = value;
		}
	});
	Writable$1.prototype.destroy = destroyImpl$1.destroy;
	Writable$1.prototype._undestroy = destroyImpl$1.undestroy;
	Writable$1.prototype._destroy = function(err, cb) {
		cb(err);
	};
}));
var require__stream_duplex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist$1();
	var objectKeys$1 = Object.keys || function(obj) {
		var keys$9 = [];
		for (var key in obj) keys$9.push(key);
		return keys$9;
	};
	module.exports = Duplex$2;
	var Readable$1 = require__stream_readable();
	var Writable = require__stream_writable();
	require_inherits_browser()(Duplex$2, Readable$1);
	var keys$5 = objectKeys$1(Writable.prototype);
	for (var v$2 = 0; v$2 < keys$5.length; v$2++) {
		var method = keys$5[v$2];
		if (!Duplex$2.prototype[method]) Duplex$2.prototype[method] = Writable.prototype[method];
	}
	function Duplex$2(options) {
		if (!(this instanceof Duplex$2)) return new Duplex$2(options);
		Readable$1.call(this, options);
		Writable.call(this, options);
		this.allowHalfOpen = true;
		if (options) {
			if (options.readable === false) this.readable = false;
			if (options.writable === false) this.writable = false;
			if (options.allowHalfOpen === false) {
				this.allowHalfOpen = false;
				this.once("end", onend);
			}
		}
	}
	Object.defineProperty(Duplex$2.prototype, "writableHighWaterMark", {
		enumerable: false,
		get: function get$2() {
			return this._writableState.highWaterMark;
		}
	});
	Object.defineProperty(Duplex$2.prototype, "writableBuffer", {
		enumerable: false,
		get: function get$2() {
			return this._writableState && this._writableState.getBuffer();
		}
	});
	Object.defineProperty(Duplex$2.prototype, "writableLength", {
		enumerable: false,
		get: function get$2() {
			return this._writableState.length;
		}
	});
	function onend() {
		if (this._writableState.ended) return;
		process$1.nextTick(onEndNT, this);
	}
	function onEndNT(self$1) {
		self$1.end();
	}
	Object.defineProperty(Duplex$2.prototype, "destroyed", {
		enumerable: false,
		get: function get$2() {
			if (this._readableState === void 0 || this._writableState === void 0) return false;
			return this._readableState.destroyed && this._writableState.destroyed;
		},
		set: function set(value) {
			if (this._readableState === void 0 || this._writableState === void 0) return;
			this._readableState.destroyed = value;
			this._writableState.destroyed = value;
		}
	});
}));
var require_safe_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = require_buffer();
	var Buffer$3 = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer$3.from && Buffer$3.alloc && Buffer$3.allocUnsafe && Buffer$3.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length$1) {
		return Buffer$3(arg, encodingOrOffset, length$1);
	}
	SafeBuffer.prototype = Object.create(Buffer$3.prototype);
	copyProps(Buffer$3, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length$1) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$3(arg, encodingOrOffset, length$1);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$3(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$3(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}));
var require_string_decoder = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$2 = require_safe_buffer().Buffer;
	var isEncoding = Buffer$2.isEncoding || function(encoding) {
		encoding = "" + encoding;
		switch (encoding && encoding.toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
			case "raw": return true;
			default: return false;
		}
	};
	function _normalizeEncoding(enc) {
		if (!enc) return "utf8";
		var retried;
		while (true) switch (enc) {
			case "utf8":
			case "utf-8": return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return "utf16le";
			case "latin1":
			case "binary": return "latin1";
			case "base64":
			case "ascii":
			case "hex": return enc;
			default:
				if (retried) return;
				enc = ("" + enc).toLowerCase();
				retried = true;
		}
	}
	function normalizeEncoding(enc) {
		var nenc = _normalizeEncoding(enc);
		if (typeof nenc !== "string" && (Buffer$2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
		return nenc || enc;
	}
	exports.StringDecoder = StringDecoder$1;
	function StringDecoder$1(encoding) {
		this.encoding = normalizeEncoding(encoding);
		var nb;
		switch (this.encoding) {
			case "utf16le":
				this.text = utf16Text;
				this.end = utf16End;
				nb = 4;
				break;
			case "utf8":
				this.fillLast = utf8FillLast;
				nb = 4;
				break;
			case "base64":
				this.text = base64Text;
				this.end = base64End;
				nb = 3;
				break;
			default:
				this.write = simpleWrite;
				this.end = simpleEnd;
				return;
		}
		this.lastNeed = 0;
		this.lastTotal = 0;
		this.lastChar = Buffer$2.allocUnsafe(nb);
	}
	StringDecoder$1.prototype.write = function(buf) {
		if (buf.length === 0) return "";
		var r$1;
		var i$2;
		if (this.lastNeed) {
			r$1 = this.fillLast(buf);
			if (r$1 === void 0) return "";
			i$2 = this.lastNeed;
			this.lastNeed = 0;
		} else i$2 = 0;
		if (i$2 < buf.length) return r$1 ? r$1 + this.text(buf, i$2) : this.text(buf, i$2);
		return r$1 || "";
	};
	StringDecoder$1.prototype.end = utf8End;
	StringDecoder$1.prototype.text = utf8Text;
	StringDecoder$1.prototype.fillLast = function(buf) {
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		this.lastNeed -= buf.length;
	};
	function utf8CheckByte(byte) {
		if (byte <= 127) return 0;
		else if (byte >> 5 === 6) return 2;
		else if (byte >> 4 === 14) return 3;
		else if (byte >> 3 === 30) return 4;
		return byte >> 6 === 2 ? -1 : -2;
	}
	function utf8CheckIncomplete(self$1, buf, i$2) {
		var j$1 = buf.length - 1;
		if (j$1 < i$2) return 0;
		var nb = utf8CheckByte(buf[j$1]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 1;
			return nb;
		}
		if (--j$1 < i$2 || nb === -2) return 0;
		nb = utf8CheckByte(buf[j$1]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 2;
			return nb;
		}
		if (--j$1 < i$2 || nb === -2) return 0;
		nb = utf8CheckByte(buf[j$1]);
		if (nb >= 0) {
			if (nb > 0) if (nb === 2) nb = 0;
			else self$1.lastNeed = nb - 3;
			return nb;
		}
		return 0;
	}
	function utf8CheckExtraBytes(self$1, buf, p$1) {
		if ((buf[0] & 192) !== 128) {
			self$1.lastNeed = 0;
			return "�";
		}
		if (self$1.lastNeed > 1 && buf.length > 1) {
			if ((buf[1] & 192) !== 128) {
				self$1.lastNeed = 1;
				return "�";
			}
			if (self$1.lastNeed > 2 && buf.length > 2) {
				if ((buf[2] & 192) !== 128) {
					self$1.lastNeed = 2;
					return "�";
				}
			}
		}
	}
	function utf8FillLast(buf) {
		var p$1 = this.lastTotal - this.lastNeed;
		var r$1 = utf8CheckExtraBytes(this, buf, p$1);
		if (r$1 !== void 0) return r$1;
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, p$1, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, p$1, 0, buf.length);
		this.lastNeed -= buf.length;
	}
	function utf8Text(buf, i$2) {
		var total = utf8CheckIncomplete(this, buf, i$2);
		if (!this.lastNeed) return buf.toString("utf8", i$2);
		this.lastTotal = total;
		var end = buf.length - (total - this.lastNeed);
		buf.copy(this.lastChar, 0, end);
		return buf.toString("utf8", i$2, end);
	}
	function utf8End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + "�";
		return r$1;
	}
	function utf16Text(buf, i$2) {
		if ((buf.length - i$2) % 2 === 0) {
			var r$1 = buf.toString("utf16le", i$2);
			if (r$1) {
				var c$1 = r$1.charCodeAt(r$1.length - 1);
				if (c$1 >= 55296 && c$1 <= 56319) {
					this.lastNeed = 2;
					this.lastTotal = 4;
					this.lastChar[0] = buf[buf.length - 2];
					this.lastChar[1] = buf[buf.length - 1];
					return r$1.slice(0, -1);
				}
			}
			return r$1;
		}
		this.lastNeed = 1;
		this.lastTotal = 2;
		this.lastChar[0] = buf[buf.length - 1];
		return buf.toString("utf16le", i$2, buf.length - 1);
	}
	function utf16End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) {
			var end = this.lastTotal - this.lastNeed;
			return r$1 + this.lastChar.toString("utf16le", 0, end);
		}
		return r$1;
	}
	function base64Text(buf, i$2) {
		var n$6 = (buf.length - i$2) % 3;
		if (n$6 === 0) return buf.toString("base64", i$2);
		this.lastNeed = 3 - n$6;
		this.lastTotal = 3;
		if (n$6 === 1) this.lastChar[0] = buf[buf.length - 1];
		else {
			this.lastChar[0] = buf[buf.length - 2];
			this.lastChar[1] = buf[buf.length - 1];
		}
		return buf.toString("base64", i$2, buf.length - n$6);
	}
	function base64End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
		return r$1;
	}
	function simpleWrite(buf) {
		return buf.toString(this.encoding);
	}
	function simpleEnd(buf) {
		return buf && buf.length ? this.write(buf) : "";
	}
}));
var require_end_of_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once$1(callback) {
		var called = false;
		return function() {
			if (called) return;
			called = true;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			callback.apply(this, args);
		};
	}
	function noop$3() {}
	function isRequest$1(stream) {
		return stream.setHeader && typeof stream.abort === "function";
	}
	function eos$1(stream, opts, callback) {
		if (typeof opts === "function") return eos$1(stream, null, opts);
		if (!opts) opts = {};
		callback = once$1(callback || noop$3);
		var readable = opts.readable || opts.readable !== false && stream.readable;
		var writable = opts.writable || opts.writable !== false && stream.writable;
		var onlegacyfinish = function onlegacyfinish$1() {
			if (!stream.writable) onfinish();
		};
		var writableEnded = stream._writableState && stream._writableState.finished;
		var onfinish = function onfinish$1() {
			writable = false;
			writableEnded = true;
			if (!readable) callback.call(stream);
		};
		var readableEnded = stream._readableState && stream._readableState.endEmitted;
		var onend$1 = function onend$2() {
			readable = false;
			readableEnded = true;
			if (!writable) callback.call(stream);
		};
		var onerror = function onerror$1(err) {
			callback.call(stream, err);
		};
		var onclose = function onclose$1() {
			var err;
			if (readable && !readableEnded) {
				if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
				return callback.call(stream, err);
			}
			if (writable && !writableEnded) {
				if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
				return callback.call(stream, err);
			}
		};
		var onrequest = function onrequest$1() {
			stream.req.on("finish", onfinish);
		};
		if (isRequest$1(stream)) {
			stream.on("complete", onfinish);
			stream.on("abort", onclose);
			if (stream.req) onrequest();
			else stream.on("request", onrequest);
		} else if (writable && !stream._writableState) {
			stream.on("end", onlegacyfinish);
			stream.on("close", onlegacyfinish);
		}
		stream.on("end", onend$1);
		stream.on("finish", onfinish);
		if (opts.error !== false) stream.on("error", onerror);
		stream.on("close", onclose);
		return function() {
			stream.removeListener("complete", onfinish);
			stream.removeListener("abort", onclose);
			stream.removeListener("request", onrequest);
			if (stream.req) stream.req.removeListener("finish", onfinish);
			stream.removeListener("end", onlegacyfinish);
			stream.removeListener("close", onlegacyfinish);
			stream.removeListener("finish", onfinish);
			stream.removeListener("end", onend$1);
			stream.removeListener("error", onerror);
			stream.removeListener("close", onclose);
		};
	}
	module.exports = eos$1;
}));
var require_async_iterator = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist$1();
	var _Object$setPrototypeO;
	function _defineProperty$1(obj, key, value) {
		if (key in obj) Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
		else obj[key] = value;
		return obj;
	}
	var finished = require_end_of_stream();
	var kLastResolve = Symbol("lastResolve");
	var kLastReject = Symbol("lastReject");
	var kError = Symbol("error");
	var kEnded = Symbol("ended");
	var kLastPromise = Symbol("lastPromise");
	var kHandlePromise = Symbol("handlePromise");
	var kStream = Symbol("stream");
	function createIterResult(value, done$1) {
		return {
			value,
			done: done$1
		};
	}
	function readAndResolve(iter) {
		var resolve = iter[kLastResolve];
		if (resolve !== null) {
			var data = iter[kStream].read();
			if (data !== null) {
				iter[kLastPromise] = null;
				iter[kLastResolve] = null;
				iter[kLastReject] = null;
				resolve(createIterResult(data, false));
			}
		}
	}
	function onReadable(iter) {
		process$1.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
		return function(resolve, reject) {
			lastPromise.then(function() {
				if (iter[kEnded]) {
					resolve(createIterResult(void 0, true));
					return;
				}
				iter[kHandlePromise](resolve, reject);
			}, reject);
		};
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
		get stream() {
			return this[kStream];
		},
		next: function next() {
			var _this = this;
			var error$1 = this[kError];
			if (error$1 !== null) return Promise.reject(error$1);
			if (this[kEnded]) return Promise.resolve(createIterResult(void 0, true));
			if (this[kStream].destroyed) return new Promise(function(resolve, reject) {
				process$1.nextTick(function() {
					if (_this[kError]) reject(_this[kError]);
					else resolve(createIterResult(void 0, true));
				});
			});
			var lastPromise = this[kLastPromise];
			var promise;
			if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
			else {
				var data = this[kStream].read();
				if (data !== null) return Promise.resolve(createIterResult(data, false));
				promise = new Promise(this[kHandlePromise]);
			}
			this[kLastPromise] = promise;
			return promise;
		}
	}, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function() {
		return this;
	}), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
		var _this2 = this;
		return new Promise(function(resolve, reject) {
			_this2[kStream].destroy(null, function(err) {
				if (err) {
					reject(err);
					return;
				}
				resolve(createIterResult(void 0, true));
			});
		});
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	module.exports = function createReadableStreamAsyncIterator$2(stream) {
		var _Object$create;
		var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
			value: stream,
			writable: true
		}), _defineProperty$1(_Object$create, kLastResolve, {
			value: null,
			writable: true
		}), _defineProperty$1(_Object$create, kLastReject, {
			value: null,
			writable: true
		}), _defineProperty$1(_Object$create, kError, {
			value: null,
			writable: true
		}), _defineProperty$1(_Object$create, kEnded, {
			value: stream._readableState.endEmitted,
			writable: true
		}), _defineProperty$1(_Object$create, kHandlePromise, {
			value: function value(resolve, reject) {
				var data = iterator[kStream].read();
				if (data) {
					iterator[kLastPromise] = null;
					iterator[kLastResolve] = null;
					iterator[kLastReject] = null;
					resolve(createIterResult(data, false));
				} else {
					iterator[kLastResolve] = resolve;
					iterator[kLastReject] = reject;
				}
			},
			writable: true
		}), _Object$create));
		iterator[kLastPromise] = null;
		finished(stream, function(err) {
			if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
				var reject = iterator[kLastReject];
				if (reject !== null) {
					iterator[kLastPromise] = null;
					iterator[kLastResolve] = null;
					iterator[kLastReject] = null;
					reject(err);
				}
				iterator[kError] = err;
				return;
			}
			var resolve = iterator[kLastResolve];
			if (resolve !== null) {
				iterator[kLastPromise] = null;
				iterator[kLastResolve] = null;
				iterator[kLastReject] = null;
				resolve(createIterResult(void 0, true));
			}
			iterator[kEnded] = true;
		});
		stream.on("readable", onReadable.bind(null, iterator));
		return iterator;
	};
}));
var require_from_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function() {
		throw new Error("Readable.from is not available in the browser");
	};
}));
var require__stream_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	init_dist$1();
	module.exports = Readable;
	var Duplex$1;
	Readable.ReadableState = ReadableState;
	require_events().EventEmitter;
	var EElistenerCount = function EElistenerCount$1(emitter, type) {
		return emitter.listeners(type).length;
	};
	var Stream$1 = require_stream_browser();
	var Buffer$1 = require_buffer().Buffer;
	var OurUint8Array = global.Uint8Array || function() {};
	function _uint8ArrayToBuffer(chunk$1) {
		return Buffer$1.from(chunk$1);
	}
	function _isUint8Array(obj) {
		return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var debugUtil = require_util$2();
	var debug;
	if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
	else debug = function debug$1() {};
	var BufferList = require_buffer_list();
	var destroyImpl = require_destroy();
	var getHighWaterMark = require_state().getHighWaterMark;
	var _require$codes$3 = require_errors_browser().codes, ERR_INVALID_ARG_TYPE$2 = _require$codes$3.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	require_inherits_browser()(Readable, Stream$1);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = [
		"error",
		"close",
		"destroy",
		"pause",
		"resume"
	];
	function prependListener(emitter, event, fn$1) {
		if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn$1);
		if (!emitter._events || !emitter._events[event]) emitter.on(event, fn$1);
		else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn$1);
		else emitter._events[event] = [fn$1, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
		Duplex$1 = Duplex$1 || require__stream_duplex();
		options = options || {};
		if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex$1;
		this.objectMode = !!options.objectMode;
		if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
		this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
		this.buffer = new BufferList();
		this.length = 0;
		this.pipes = null;
		this.pipesCount = 0;
		this.flowing = null;
		this.ended = false;
		this.endEmitted = false;
		this.reading = false;
		this.sync = true;
		this.needReadable = false;
		this.emittedReadable = false;
		this.readableListening = false;
		this.resumeScheduled = false;
		this.paused = true;
		this.emitClose = options.emitClose !== false;
		this.autoDestroy = !!options.autoDestroy;
		this.destroyed = false;
		this.defaultEncoding = options.defaultEncoding || "utf8";
		this.awaitDrain = 0;
		this.readingMore = false;
		this.decoder = null;
		this.encoding = null;
		if (options.encoding) {
			if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
			this.decoder = new StringDecoder(options.encoding);
			this.encoding = options.encoding;
		}
	}
	function Readable(options) {
		Duplex$1 = Duplex$1 || require__stream_duplex();
		if (!(this instanceof Readable)) return new Readable(options);
		var isDuplex = this instanceof Duplex$1;
		this._readableState = new ReadableState(options, this, isDuplex);
		this.readable = true;
		if (options) {
			if (typeof options.read === "function") this._read = options.read;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
		}
		Stream$1.call(this);
	}
	Object.defineProperty(Readable.prototype, "destroyed", {
		enumerable: false,
		get: function get$2() {
			if (this._readableState === void 0) return false;
			return this._readableState.destroyed;
		},
		set: function set(value) {
			if (!this._readableState) return;
			this._readableState.destroyed = value;
		}
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function(err, cb) {
		cb(err);
	};
	Readable.prototype.push = function(chunk$1, encoding) {
		var state = this._readableState;
		var skipChunkCheck;
		if (!state.objectMode) {
			if (typeof chunk$1 === "string") {
				encoding = encoding || state.defaultEncoding;
				if (encoding !== state.encoding) {
					chunk$1 = Buffer$1.from(chunk$1, encoding);
					encoding = "";
				}
				skipChunkCheck = true;
			}
		} else skipChunkCheck = true;
		return readableAddChunk(this, chunk$1, encoding, false, skipChunkCheck);
	};
	Readable.prototype.unshift = function(chunk$1) {
		return readableAddChunk(this, chunk$1, null, true, false);
	};
	function readableAddChunk(stream, chunk$1, encoding, addToFront, skipChunkCheck) {
		debug("readableAddChunk", chunk$1);
		var state = stream._readableState;
		if (chunk$1 === null) {
			state.reading = false;
			onEofChunk(stream, state);
		} else {
			var er;
			if (!skipChunkCheck) er = chunkInvalid(state, chunk$1);
			if (er) errorOrDestroy(stream, er);
			else if (state.objectMode || chunk$1 && chunk$1.length > 0) {
				if (typeof chunk$1 !== "string" && !state.objectMode && Object.getPrototypeOf(chunk$1) !== Buffer$1.prototype) chunk$1 = _uint8ArrayToBuffer(chunk$1);
				if (addToFront) if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
				else addChunk(stream, state, chunk$1, true);
				else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
				else if (state.destroyed) return false;
				else {
					state.reading = false;
					if (state.decoder && !encoding) {
						chunk$1 = state.decoder.write(chunk$1);
						if (state.objectMode || chunk$1.length !== 0) addChunk(stream, state, chunk$1, false);
						else maybeReadMore(stream, state);
					} else addChunk(stream, state, chunk$1, false);
				}
			} else if (!addToFront) {
				state.reading = false;
				maybeReadMore(stream, state);
			}
		}
		return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk$1, addToFront) {
		if (state.flowing && state.length === 0 && !state.sync) {
			state.awaitDrain = 0;
			stream.emit("data", chunk$1);
		} else {
			state.length += state.objectMode ? 1 : chunk$1.length;
			if (addToFront) state.buffer.unshift(chunk$1);
			else state.buffer.push(chunk$1);
			if (state.needReadable) emitReadable(stream);
		}
		maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk$1) {
		var er;
		if (!_isUint8Array(chunk$1) && typeof chunk$1 !== "string" && chunk$1 !== void 0 && !state.objectMode) er = new ERR_INVALID_ARG_TYPE$2("chunk", [
			"string",
			"Buffer",
			"Uint8Array"
		], chunk$1);
		return er;
	}
	Readable.prototype.isPaused = function() {
		return this._readableState.flowing === false;
	};
	Readable.prototype.setEncoding = function(enc) {
		if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
		var decoder = new StringDecoder(enc);
		this._readableState.decoder = decoder;
		this._readableState.encoding = this._readableState.decoder.encoding;
		var p$1 = this._readableState.buffer.head;
		var content = "";
		while (p$1 !== null) {
			content += decoder.write(p$1.data);
			p$1 = p$1.next;
		}
		this._readableState.buffer.clear();
		if (content !== "") this._readableState.buffer.push(content);
		this._readableState.length = content.length;
		return this;
	};
	var MAX_HWM = 1073741824;
	function computeNewHighWaterMark(n$6) {
		if (n$6 >= MAX_HWM) n$6 = MAX_HWM;
		else {
			n$6--;
			n$6 |= n$6 >>> 1;
			n$6 |= n$6 >>> 2;
			n$6 |= n$6 >>> 4;
			n$6 |= n$6 >>> 8;
			n$6 |= n$6 >>> 16;
			n$6++;
		}
		return n$6;
	}
	function howMuchToRead(n$6, state) {
		if (n$6 <= 0 || state.length === 0 && state.ended) return 0;
		if (state.objectMode) return 1;
		if (n$6 !== n$6) if (state.flowing && state.length) return state.buffer.head.data.length;
		else return state.length;
		if (n$6 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n$6);
		if (n$6 <= state.length) return n$6;
		if (!state.ended) {
			state.needReadable = true;
			return 0;
		}
		return state.length;
	}
	Readable.prototype.read = function(n$6) {
		debug("read", n$6);
		n$6 = parseInt(n$6, 10);
		var state = this._readableState;
		var nOrig = n$6;
		if (n$6 !== 0) state.emittedReadable = false;
		if (n$6 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
			debug("read: emitReadable", state.length, state.ended);
			if (state.length === 0 && state.ended) endReadable(this);
			else emitReadable(this);
			return null;
		}
		n$6 = howMuchToRead(n$6, state);
		if (n$6 === 0 && state.ended) {
			if (state.length === 0) endReadable(this);
			return null;
		}
		var doRead = state.needReadable;
		debug("need readable", doRead);
		if (state.length === 0 || state.length - n$6 < state.highWaterMark) {
			doRead = true;
			debug("length less than watermark", doRead);
		}
		if (state.ended || state.reading) {
			doRead = false;
			debug("reading or ended", doRead);
		} else if (doRead) {
			debug("do read");
			state.reading = true;
			state.sync = true;
			if (state.length === 0) state.needReadable = true;
			this._read(state.highWaterMark);
			state.sync = false;
			if (!state.reading) n$6 = howMuchToRead(nOrig, state);
		}
		var ret;
		if (n$6 > 0) ret = fromList(n$6, state);
		else ret = null;
		if (ret === null) {
			state.needReadable = state.length <= state.highWaterMark;
			n$6 = 0;
		} else {
			state.length -= n$6;
			state.awaitDrain = 0;
		}
		if (state.length === 0) {
			if (!state.ended) state.needReadable = true;
			if (nOrig !== n$6 && state.ended) endReadable(this);
		}
		if (ret !== null) this.emit("data", ret);
		return ret;
	};
	function onEofChunk(stream, state) {
		debug("onEofChunk");
		if (state.ended) return;
		if (state.decoder) {
			var chunk$1 = state.decoder.end();
			if (chunk$1 && chunk$1.length) {
				state.buffer.push(chunk$1);
				state.length += state.objectMode ? 1 : chunk$1.length;
			}
		}
		state.ended = true;
		if (state.sync) emitReadable(stream);
		else {
			state.needReadable = false;
			if (!state.emittedReadable) {
				state.emittedReadable = true;
				emitReadable_(stream);
			}
		}
	}
	function emitReadable(stream) {
		var state = stream._readableState;
		debug("emitReadable", state.needReadable, state.emittedReadable);
		state.needReadable = false;
		if (!state.emittedReadable) {
			debug("emitReadable", state.flowing);
			state.emittedReadable = true;
			process$1.nextTick(emitReadable_, stream);
		}
	}
	function emitReadable_(stream) {
		var state = stream._readableState;
		debug("emitReadable_", state.destroyed, state.length, state.ended);
		if (!state.destroyed && (state.length || state.ended)) {
			stream.emit("readable");
			state.emittedReadable = false;
		}
		state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
		flow(stream);
	}
	function maybeReadMore(stream, state) {
		if (!state.readingMore) {
			state.readingMore = true;
			process$1.nextTick(maybeReadMore_, stream, state);
		}
	}
	function maybeReadMore_(stream, state) {
		while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
			var len$1 = state.length;
			debug("maybeReadMore read 0");
			stream.read(0);
			if (len$1 === state.length) break;
		}
		state.readingMore = false;
	}
	Readable.prototype._read = function(n$6) {
		errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1("_read()"));
	};
	Readable.prototype.pipe = function(dest, pipeOpts) {
		var src = this;
		var state = this._readableState;
		switch (state.pipesCount) {
			case 0:
				state.pipes = dest;
				break;
			case 1:
				state.pipes = [state.pipes, dest];
				break;
			default:
				state.pipes.push(dest);
				break;
		}
		state.pipesCount += 1;
		debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
		var endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr ? onend$1 : unpipe;
		if (state.endEmitted) process$1.nextTick(endFn);
		else src.once("end", endFn);
		dest.on("unpipe", onunpipe);
		function onunpipe(readable, unpipeInfo) {
			debug("onunpipe");
			if (readable === src) {
				if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
					unpipeInfo.hasUnpiped = true;
					cleanup();
				}
			}
		}
		function onend$1() {
			debug("onend");
			dest.end();
		}
		var ondrain = pipeOnDrain(src);
		dest.on("drain", ondrain);
		var cleanedUp = false;
		function cleanup() {
			debug("cleanup");
			dest.removeListener("close", onclose);
			dest.removeListener("finish", onfinish);
			dest.removeListener("drain", ondrain);
			dest.removeListener("error", onerror);
			dest.removeListener("unpipe", onunpipe);
			src.removeListener("end", onend$1);
			src.removeListener("end", unpipe);
			src.removeListener("data", ondata);
			cleanedUp = true;
			if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		}
		src.on("data", ondata);
		function ondata(chunk$1) {
			debug("ondata");
			var ret = dest.write(chunk$1);
			debug("dest.write", ret);
			if (ret === false) {
				if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
					debug("false write response, pause", state.awaitDrain);
					state.awaitDrain++;
				}
				src.pause();
			}
		}
		function onerror(er) {
			debug("onerror", er);
			unpipe();
			dest.removeListener("error", onerror);
			if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
		}
		prependListener(dest, "error", onerror);
		function onclose() {
			dest.removeListener("finish", onfinish);
			unpipe();
		}
		dest.once("close", onclose);
		function onfinish() {
			debug("onfinish");
			dest.removeListener("close", onclose);
			unpipe();
		}
		dest.once("finish", onfinish);
		function unpipe() {
			debug("unpipe");
			src.unpipe(dest);
		}
		dest.emit("pipe", src);
		if (!state.flowing) {
			debug("pipe resume");
			src.resume();
		}
		return dest;
	};
	function pipeOnDrain(src) {
		return function pipeOnDrainFunctionResult() {
			var state = src._readableState;
			debug("pipeOnDrain", state.awaitDrain);
			if (state.awaitDrain) state.awaitDrain--;
			if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
				state.flowing = true;
				flow(src);
			}
		};
	}
	Readable.prototype.unpipe = function(dest) {
		var state = this._readableState;
		var unpipeInfo = { hasUnpiped: false };
		if (state.pipesCount === 0) return this;
		if (state.pipesCount === 1) {
			if (dest && dest !== state.pipes) return this;
			if (!dest) dest = state.pipes;
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
			if (dest) dest.emit("unpipe", this, unpipeInfo);
			return this;
		}
		if (!dest) {
			var dests = state.pipes;
			var len$1 = state.pipesCount;
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
			for (var i$2 = 0; i$2 < len$1; i$2++) dests[i$2].emit("unpipe", this, { hasUnpiped: false });
			return this;
		}
		var index = indexOf(state.pipes, dest);
		if (index === -1) return this;
		state.pipes.splice(index, 1);
		state.pipesCount -= 1;
		if (state.pipesCount === 1) state.pipes = state.pipes[0];
		dest.emit("unpipe", this, unpipeInfo);
		return this;
	};
	Readable.prototype.on = function(ev, fn$1) {
		var res = Stream$1.prototype.on.call(this, ev, fn$1);
		var state = this._readableState;
		if (ev === "data") {
			state.readableListening = this.listenerCount("readable") > 0;
			if (state.flowing !== false) this.resume();
		} else if (ev === "readable") {
			if (!state.endEmitted && !state.readableListening) {
				state.readableListening = state.needReadable = true;
				state.flowing = false;
				state.emittedReadable = false;
				debug("on readable", state.length, state.reading);
				if (state.length) emitReadable(this);
				else if (!state.reading) process$1.nextTick(nReadingNextTick, this);
			}
		}
		return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function(ev, fn$1) {
		var res = Stream$1.prototype.removeListener.call(this, ev, fn$1);
		if (ev === "readable") process$1.nextTick(updateReadableListening, this);
		return res;
	};
	Readable.prototype.removeAllListeners = function(ev) {
		var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
		if (ev === "readable" || ev === void 0) process$1.nextTick(updateReadableListening, this);
		return res;
	};
	function updateReadableListening(self$1) {
		var state = self$1._readableState;
		state.readableListening = self$1.listenerCount("readable") > 0;
		if (state.resumeScheduled && !state.paused) state.flowing = true;
		else if (self$1.listenerCount("data") > 0) self$1.resume();
	}
	function nReadingNextTick(self$1) {
		debug("readable nexttick read 0");
		self$1.read(0);
	}
	Readable.prototype.resume = function() {
		var state = this._readableState;
		if (!state.flowing) {
			debug("resume");
			state.flowing = !state.readableListening;
			resume(this, state);
		}
		state.paused = false;
		return this;
	};
	function resume(stream, state) {
		if (!state.resumeScheduled) {
			state.resumeScheduled = true;
			process$1.nextTick(resume_, stream, state);
		}
	}
	function resume_(stream, state) {
		debug("resume", state.reading);
		if (!state.reading) stream.read(0);
		state.resumeScheduled = false;
		stream.emit("resume");
		flow(stream);
		if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function() {
		debug("call pause flowing=%j", this._readableState.flowing);
		if (this._readableState.flowing !== false) {
			debug("pause");
			this._readableState.flowing = false;
			this.emit("pause");
		}
		this._readableState.paused = true;
		return this;
	};
	function flow(stream) {
		var state = stream._readableState;
		debug("flow", state.flowing);
		while (state.flowing && stream.read() !== null);
	}
	Readable.prototype.wrap = function(stream) {
		var _this = this;
		var state = this._readableState;
		var paused = false;
		stream.on("end", function() {
			debug("wrapped end");
			if (state.decoder && !state.ended) {
				var chunk$1 = state.decoder.end();
				if (chunk$1 && chunk$1.length) _this.push(chunk$1);
			}
			_this.push(null);
		});
		stream.on("data", function(chunk$1) {
			debug("wrapped data");
			if (state.decoder) chunk$1 = state.decoder.write(chunk$1);
			if (state.objectMode && (chunk$1 === null || chunk$1 === void 0)) return;
			else if (!state.objectMode && (!chunk$1 || !chunk$1.length)) return;
			if (!_this.push(chunk$1)) {
				paused = true;
				stream.pause();
			}
		});
		for (var i$2 in stream) if (this[i$2] === void 0 && typeof stream[i$2] === "function") this[i$2] = function methodWrap(method$1) {
			return function methodWrapReturnFunction() {
				return stream[method$1].apply(stream, arguments);
			};
		}(i$2);
		for (var n$6 = 0; n$6 < kProxyEvents.length; n$6++) stream.on(kProxyEvents[n$6], this.emit.bind(this, kProxyEvents[n$6]));
		this._read = function(n$7) {
			debug("wrapped _read", n$7);
			if (paused) {
				paused = false;
				stream.resume();
			}
		};
		return this;
	};
	if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
		if (createReadableStreamAsyncIterator === void 0) createReadableStreamAsyncIterator = require_async_iterator();
		return createReadableStreamAsyncIterator(this);
	};
	Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
		enumerable: false,
		get: function get$2() {
			return this._readableState.highWaterMark;
		}
	});
	Object.defineProperty(Readable.prototype, "readableBuffer", {
		enumerable: false,
		get: function get$2() {
			return this._readableState && this._readableState.buffer;
		}
	});
	Object.defineProperty(Readable.prototype, "readableFlowing", {
		enumerable: false,
		get: function get$2() {
			return this._readableState.flowing;
		},
		set: function set(state) {
			if (this._readableState) this._readableState.flowing = state;
		}
	});
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, "readableLength", {
		enumerable: false,
		get: function get$2() {
			return this._readableState.length;
		}
	});
	function fromList(n$6, state) {
		if (state.length === 0) return null;
		var ret;
		if (state.objectMode) ret = state.buffer.shift();
		else if (!n$6 || n$6 >= state.length) {
			if (state.decoder) ret = state.buffer.join("");
			else if (state.buffer.length === 1) ret = state.buffer.first();
			else ret = state.buffer.concat(state.length);
			state.buffer.clear();
		} else ret = state.buffer.consume(n$6, state.decoder);
		return ret;
	}
	function endReadable(stream) {
		var state = stream._readableState;
		debug("endReadable", state.endEmitted);
		if (!state.endEmitted) {
			state.ended = true;
			process$1.nextTick(endReadableNT, state, stream);
		}
	}
	function endReadableNT(state, stream) {
		debug("endReadableNT", state.endEmitted, state.length);
		if (!state.endEmitted && state.length === 0) {
			state.endEmitted = true;
			stream.readable = false;
			stream.emit("end");
			if (state.autoDestroy) {
				var wState = stream._writableState;
				if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
			}
		}
	}
	if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
		if (from === void 0) from = require_from_browser();
		return from(Readable, iterable, opts);
	};
	function indexOf(xs, x$1) {
		for (var i$2 = 0, l$2 = xs.length; i$2 < l$2; i$2++) if (xs[i$2] === x$1) return i$2;
		return -1;
	}
}));
var require__stream_transform = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Transform$1;
	var _require$codes$2 = require_errors_browser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$2.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$2.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$2.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require__stream_duplex();
	require_inherits_browser()(Transform$1, Duplex);
	function afterTransform(er, data) {
		var ts = this._transformState;
		ts.transforming = false;
		var cb = ts.writecb;
		if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
		ts.writechunk = null;
		ts.writecb = null;
		if (data != null) this.push(data);
		cb(er);
		var rs = this._readableState;
		rs.reading = false;
		if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	}
	function Transform$1(options) {
		if (!(this instanceof Transform$1)) return new Transform$1(options);
		Duplex.call(this, options);
		this._transformState = {
			afterTransform: afterTransform.bind(this),
			needTransform: false,
			transforming: false,
			writecb: null,
			writechunk: null,
			writeencoding: null
		};
		this._readableState.needReadable = true;
		this._readableState.sync = false;
		if (options) {
			if (typeof options.transform === "function") this._transform = options.transform;
			if (typeof options.flush === "function") this._flush = options.flush;
		}
		this.on("prefinish", prefinish);
	}
	function prefinish() {
		var _this = this;
		if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
			done(_this, er, data);
		});
		else done(this, null, null);
	}
	Transform$1.prototype.push = function(chunk$1, encoding) {
		this._transformState.needTransform = false;
		return Duplex.prototype.push.call(this, chunk$1, encoding);
	};
	Transform$1.prototype._transform = function(chunk$1, encoding, cb) {
		cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
	};
	Transform$1.prototype._write = function(chunk$1, encoding, cb) {
		var ts = this._transformState;
		ts.writecb = cb;
		ts.writechunk = chunk$1;
		ts.writeencoding = encoding;
		if (!ts.transforming) {
			var rs = this._readableState;
			if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
		}
	};
	Transform$1.prototype._read = function(n$6) {
		var ts = this._transformState;
		if (ts.writechunk !== null && !ts.transforming) {
			ts.transforming = true;
			this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
		} else ts.needTransform = true;
	};
	Transform$1.prototype._destroy = function(err, cb) {
		Duplex.prototype._destroy.call(this, err, function(err2) {
			cb(err2);
		});
	};
	function done(stream, er, data) {
		if (er) return stream.emit("error", er);
		if (data != null) stream.push(data);
		if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
		if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
		return stream.push(null);
	}
}));
var require__stream_passthrough = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = PassThrough;
	var Transform = require__stream_transform();
	require_inherits_browser()(PassThrough, Transform);
	function PassThrough(options) {
		if (!(this instanceof PassThrough)) return new PassThrough(options);
		Transform.call(this, options);
	}
	PassThrough.prototype._transform = function(chunk$1, encoding, cb) {
		cb(null, chunk$1);
	};
}));
var require_pipeline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eos;
	function once(callback) {
		var called = false;
		return function() {
			if (called) return;
			called = true;
			callback.apply(void 0, arguments);
		};
	}
	var _require$codes$1 = require_errors_browser().codes, ERR_MISSING_ARGS$1 = _require$codes$1.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes$1.ERR_STREAM_DESTROYED;
	function noop$2(err) {
		if (err) throw err;
	}
	function isRequest(stream) {
		return stream.setHeader && typeof stream.abort === "function";
	}
	function destroyer(stream, reading, writing, callback) {
		callback = once(callback);
		var closed = false;
		stream.on("close", function() {
			closed = true;
		});
		if (eos === void 0) eos = require_end_of_stream();
		eos(stream, {
			readable: reading,
			writable: writing
		}, function(err) {
			if (err) return callback(err);
			closed = true;
			callback();
		});
		var destroyed = false;
		return function(err) {
			if (closed) return;
			if (destroyed) return;
			destroyed = true;
			if (isRequest(stream)) return stream.abort();
			if (typeof stream.destroy === "function") return stream.destroy();
			callback(err || new ERR_STREAM_DESTROYED("pipe"));
		};
	}
	function call(fn$1) {
		fn$1();
	}
	function pipe(from$2, to) {
		return from$2.pipe(to);
	}
	function popCallback(streams) {
		if (!streams.length) return noop$2;
		if (typeof streams[streams.length - 1] !== "function") return noop$2;
		return streams.pop();
	}
	function pipeline() {
		for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) streams[_key] = arguments[_key];
		var callback = popCallback(streams);
		if (Array.isArray(streams[0])) streams = streams[0];
		if (streams.length < 2) throw new ERR_MISSING_ARGS$1("streams");
		var error$1;
		var destroys = streams.map(function(stream, i$2) {
			var reading = i$2 < streams.length - 1;
			return destroyer(stream, reading, i$2 > 0, function(err) {
				if (!error$1) error$1 = err;
				if (err) destroys.forEach(call);
				if (reading) return;
				destroys.forEach(call);
				callback(error$1);
			});
		});
		return streams.reduce(pipe);
	}
	module.exports = pipeline;
}));
var require_stream_browserify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Stream;
	var EE = require_events().EventEmitter;
	require_inherits_browser()(Stream, EE);
	Stream.Readable = require__stream_readable();
	Stream.Writable = require__stream_writable();
	Stream.Duplex = require__stream_duplex();
	Stream.Transform = require__stream_transform();
	Stream.PassThrough = require__stream_passthrough();
	Stream.finished = require_end_of_stream();
	Stream.pipeline = require_pipeline();
	Stream.Stream = Stream;
	function Stream() {
		EE.call(this);
	}
	Stream.prototype.pipe = function(dest, options) {
		var source = this;
		function ondata(chunk$1) {
			if (dest.writable) {
				if (false === dest.write(chunk$1) && source.pause) source.pause();
			}
		}
		source.on("data", ondata);
		function ondrain() {
			if (source.readable && source.resume) source.resume();
		}
		dest.on("drain", ondrain);
		if (!dest._isStdio && (!options || options.end !== false)) {
			source.on("end", onend$1);
			source.on("close", onclose);
		}
		var didOnEnd = false;
		function onend$1() {
			if (didOnEnd) return;
			didOnEnd = true;
			dest.end();
		}
		function onclose() {
			if (didOnEnd) return;
			didOnEnd = true;
			if (typeof dest.destroy === "function") dest.destroy();
		}
		function onerror(er) {
			cleanup();
			if (EE.listenerCount(this, "error") === 0) throw er;
		}
		source.on("error", onerror);
		dest.on("error", onerror);
		function cleanup() {
			source.removeListener("data", ondata);
			dest.removeListener("drain", ondrain);
			source.removeListener("end", onend$1);
			source.removeListener("close", onclose);
			source.removeListener("error", onerror);
			dest.removeListener("error", onerror);
			source.removeListener("end", cleanup);
			source.removeListener("close", cleanup);
			dest.removeListener("close", cleanup);
		}
		source.on("end", cleanup);
		source.on("close", cleanup);
		dest.on("close", cleanup);
		dest.emit("pipe", source);
		return dest;
	};
}));
var require_sax = /* @__PURE__ */ __commonJSMin(((exports) => {
	init_dist$2();
	(function(sax) {
		sax.parser = function(strict$1, opt) {
			return new SAXParser(strict$1, opt);
		};
		sax.SAXParser = SAXParser;
		sax.SAXStream = SAXStream;
		sax.createStream = createStream;
		sax.MAX_BUFFER_LENGTH = 64 * 1024;
		var buffers = [
			"comment",
			"sgmlDecl",
			"textNode",
			"tagName",
			"doctype",
			"procInstName",
			"procInstBody",
			"entity",
			"attribName",
			"attribValue",
			"cdata",
			"script"
		];
		sax.EVENTS = [
			"text",
			"processinginstruction",
			"sgmldeclaration",
			"doctype",
			"comment",
			"opentagstart",
			"attribute",
			"opentag",
			"closetag",
			"opencdata",
			"cdata",
			"closecdata",
			"error",
			"end",
			"ready",
			"script",
			"opennamespace",
			"closenamespace"
		];
		function SAXParser(strict$1, opt) {
			if (!(this instanceof SAXParser)) return new SAXParser(strict$1, opt);
			var parser = this;
			clearBuffers(parser);
			parser.q = parser.c = "";
			parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
			parser.opt = opt || {};
			parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
			parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
			parser.tags = [];
			parser.closed = parser.closedRoot = parser.sawRoot = false;
			parser.tag = parser.error = null;
			parser.strict = !!strict$1;
			parser.noscript = !!(strict$1 || parser.opt.noscript);
			parser.state = S$1.BEGIN;
			parser.strictEntities = parser.opt.strictEntities;
			parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
			parser.attribList = [];
			if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
			parser.trackPosition = parser.opt.position !== false;
			if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
			emit(parser, "onready");
		}
		if (!Object.create) Object.create = function(o$1) {
			function F$1() {}
			F$1.prototype = o$1;
			return new F$1();
		};
		if (!Object.keys) Object.keys = function(o$1) {
			var a$1 = [];
			for (var i$2 in o$1) if (o$1.hasOwnProperty(i$2)) a$1.push(i$2);
			return a$1;
		};
		function checkBufferLength(parser) {
			var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
			var maxActual = 0;
			for (var i$2 = 0, l$2 = buffers.length; i$2 < l$2; i$2++) {
				var len$1 = parser[buffers[i$2]].length;
				if (len$1 > maxAllowed) switch (buffers[i$2]) {
					case "textNode":
						closeText(parser);
						break;
					case "cdata":
						emitNode(parser, "oncdata", parser.cdata);
						parser.cdata = "";
						break;
					case "script":
						emitNode(parser, "onscript", parser.script);
						parser.script = "";
						break;
					default: error$1(parser, "Max buffer length exceeded: " + buffers[i$2]);
				}
				maxActual = Math.max(maxActual, len$1);
			}
			parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH - maxActual + parser.position;
		}
		function clearBuffers(parser) {
			for (var i$2 = 0, l$2 = buffers.length; i$2 < l$2; i$2++) parser[buffers[i$2]] = "";
		}
		function flushBuffers(parser) {
			closeText(parser);
			if (parser.cdata !== "") {
				emitNode(parser, "oncdata", parser.cdata);
				parser.cdata = "";
			}
			if (parser.script !== "") {
				emitNode(parser, "onscript", parser.script);
				parser.script = "";
			}
		}
		SAXParser.prototype = {
			end: function() {
				end(this);
			},
			write,
			resume: function() {
				this.error = null;
				return this;
			},
			close: function() {
				return this.write(null);
			},
			flush: function() {
				flushBuffers(this);
			}
		};
		var Stream$3;
		try {
			Stream$3 = require_stream_browserify().Stream;
		} catch (ex) {
			Stream$3 = function() {};
		}
		var streamWraps = sax.EVENTS.filter(function(ev) {
			return ev !== "error" && ev !== "end";
		});
		function createStream(strict$1, opt) {
			return new SAXStream(strict$1, opt);
		}
		function SAXStream(strict$1, opt) {
			if (!(this instanceof SAXStream)) return new SAXStream(strict$1, opt);
			Stream$3.apply(this);
			this._parser = new SAXParser(strict$1, opt);
			this.writable = true;
			this.readable = true;
			var me = this;
			this._parser.onend = function() {
				me.emit("end");
			};
			this._parser.onerror = function(er) {
				me.emit("error", er);
				me._parser.error = null;
			};
			this._decoder = null;
			streamWraps.forEach(function(ev) {
				Object.defineProperty(me, "on" + ev, {
					get: function() {
						return me._parser["on" + ev];
					},
					set: function(h$1) {
						if (!h$1) {
							me.removeAllListeners(ev);
							me._parser["on" + ev] = h$1;
							return h$1;
						}
						me.on(ev, h$1);
					},
					enumerable: true,
					configurable: false
				});
			});
		}
		SAXStream.prototype = Object.create(Stream$3.prototype, { constructor: { value: SAXStream } });
		SAXStream.prototype.write = function(data) {
			if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
				if (!this._decoder) {
					var SD = require_string_decoder().StringDecoder;
					this._decoder = new SD("utf8");
				}
				data = this._decoder.write(data);
			}
			this._parser.write(data.toString());
			this.emit("data", data);
			return true;
		};
		SAXStream.prototype.end = function(chunk$1) {
			if (chunk$1 && chunk$1.length) this.write(chunk$1);
			this._parser.end();
			return true;
		};
		SAXStream.prototype.on = function(ev, handler) {
			var me = this;
			if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
				var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
				args.splice(0, 0, ev);
				me.emit.apply(me, args);
			};
			return Stream$3.prototype.on.call(me, ev, handler);
		};
		var CDATA = "[CDATA[";
		var DOCTYPE = "DOCTYPE";
		var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
		var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
		var rootNS = {
			xml: XML_NAMESPACE,
			xmlns: XMLNS_NAMESPACE
		};
		var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
		var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
		function isWhitespace(c$1) {
			return c$1 === " " || c$1 === "\n" || c$1 === "\r" || c$1 === "	";
		}
		function isQuote(c$1) {
			return c$1 === "\"" || c$1 === "'";
		}
		function isAttribEnd(c$1) {
			return c$1 === ">" || isWhitespace(c$1);
		}
		function isMatch(regex, c$1) {
			return regex.test(c$1);
		}
		function notMatch(regex, c$1) {
			return !isMatch(regex, c$1);
		}
		var S$1 = 0;
		sax.STATE = {
			BEGIN: S$1++,
			BEGIN_WHITESPACE: S$1++,
			TEXT: S$1++,
			TEXT_ENTITY: S$1++,
			OPEN_WAKA: S$1++,
			SGML_DECL: S$1++,
			SGML_DECL_QUOTED: S$1++,
			DOCTYPE: S$1++,
			DOCTYPE_QUOTED: S$1++,
			DOCTYPE_DTD: S$1++,
			DOCTYPE_DTD_QUOTED: S$1++,
			COMMENT_STARTING: S$1++,
			COMMENT: S$1++,
			COMMENT_ENDING: S$1++,
			COMMENT_ENDED: S$1++,
			CDATA: S$1++,
			CDATA_ENDING: S$1++,
			CDATA_ENDING_2: S$1++,
			PROC_INST: S$1++,
			PROC_INST_BODY: S$1++,
			PROC_INST_ENDING: S$1++,
			OPEN_TAG: S$1++,
			OPEN_TAG_SLASH: S$1++,
			ATTRIB: S$1++,
			ATTRIB_NAME: S$1++,
			ATTRIB_NAME_SAW_WHITE: S$1++,
			ATTRIB_VALUE: S$1++,
			ATTRIB_VALUE_QUOTED: S$1++,
			ATTRIB_VALUE_CLOSED: S$1++,
			ATTRIB_VALUE_UNQUOTED: S$1++,
			ATTRIB_VALUE_ENTITY_Q: S$1++,
			ATTRIB_VALUE_ENTITY_U: S$1++,
			CLOSE_TAG: S$1++,
			CLOSE_TAG_SAW_WHITE: S$1++,
			SCRIPT: S$1++,
			SCRIPT_ENDING: S$1++
		};
		sax.XML_ENTITIES = {
			"amp": "&",
			"gt": ">",
			"lt": "<",
			"quot": "\"",
			"apos": "'"
		};
		sax.ENTITIES = {
			"amp": "&",
			"gt": ">",
			"lt": "<",
			"quot": "\"",
			"apos": "'",
			"AElig": 198,
			"Aacute": 193,
			"Acirc": 194,
			"Agrave": 192,
			"Aring": 197,
			"Atilde": 195,
			"Auml": 196,
			"Ccedil": 199,
			"ETH": 208,
			"Eacute": 201,
			"Ecirc": 202,
			"Egrave": 200,
			"Euml": 203,
			"Iacute": 205,
			"Icirc": 206,
			"Igrave": 204,
			"Iuml": 207,
			"Ntilde": 209,
			"Oacute": 211,
			"Ocirc": 212,
			"Ograve": 210,
			"Oslash": 216,
			"Otilde": 213,
			"Ouml": 214,
			"THORN": 222,
			"Uacute": 218,
			"Ucirc": 219,
			"Ugrave": 217,
			"Uuml": 220,
			"Yacute": 221,
			"aacute": 225,
			"acirc": 226,
			"aelig": 230,
			"agrave": 224,
			"aring": 229,
			"atilde": 227,
			"auml": 228,
			"ccedil": 231,
			"eacute": 233,
			"ecirc": 234,
			"egrave": 232,
			"eth": 240,
			"euml": 235,
			"iacute": 237,
			"icirc": 238,
			"igrave": 236,
			"iuml": 239,
			"ntilde": 241,
			"oacute": 243,
			"ocirc": 244,
			"ograve": 242,
			"oslash": 248,
			"otilde": 245,
			"ouml": 246,
			"szlig": 223,
			"thorn": 254,
			"uacute": 250,
			"ucirc": 251,
			"ugrave": 249,
			"uuml": 252,
			"yacute": 253,
			"yuml": 255,
			"copy": 169,
			"reg": 174,
			"nbsp": 160,
			"iexcl": 161,
			"cent": 162,
			"pound": 163,
			"curren": 164,
			"yen": 165,
			"brvbar": 166,
			"sect": 167,
			"uml": 168,
			"ordf": 170,
			"laquo": 171,
			"not": 172,
			"shy": 173,
			"macr": 175,
			"deg": 176,
			"plusmn": 177,
			"sup1": 185,
			"sup2": 178,
			"sup3": 179,
			"acute": 180,
			"micro": 181,
			"para": 182,
			"middot": 183,
			"cedil": 184,
			"ordm": 186,
			"raquo": 187,
			"frac14": 188,
			"frac12": 189,
			"frac34": 190,
			"iquest": 191,
			"times": 215,
			"divide": 247,
			"OElig": 338,
			"oelig": 339,
			"Scaron": 352,
			"scaron": 353,
			"Yuml": 376,
			"fnof": 402,
			"circ": 710,
			"tilde": 732,
			"Alpha": 913,
			"Beta": 914,
			"Gamma": 915,
			"Delta": 916,
			"Epsilon": 917,
			"Zeta": 918,
			"Eta": 919,
			"Theta": 920,
			"Iota": 921,
			"Kappa": 922,
			"Lambda": 923,
			"Mu": 924,
			"Nu": 925,
			"Xi": 926,
			"Omicron": 927,
			"Pi": 928,
			"Rho": 929,
			"Sigma": 931,
			"Tau": 932,
			"Upsilon": 933,
			"Phi": 934,
			"Chi": 935,
			"Psi": 936,
			"Omega": 937,
			"alpha": 945,
			"beta": 946,
			"gamma": 947,
			"delta": 948,
			"epsilon": 949,
			"zeta": 950,
			"eta": 951,
			"theta": 952,
			"iota": 953,
			"kappa": 954,
			"lambda": 955,
			"mu": 956,
			"nu": 957,
			"xi": 958,
			"omicron": 959,
			"pi": 960,
			"rho": 961,
			"sigmaf": 962,
			"sigma": 963,
			"tau": 964,
			"upsilon": 965,
			"phi": 966,
			"chi": 967,
			"psi": 968,
			"omega": 969,
			"thetasym": 977,
			"upsih": 978,
			"piv": 982,
			"ensp": 8194,
			"emsp": 8195,
			"thinsp": 8201,
			"zwnj": 8204,
			"zwj": 8205,
			"lrm": 8206,
			"rlm": 8207,
			"ndash": 8211,
			"mdash": 8212,
			"lsquo": 8216,
			"rsquo": 8217,
			"sbquo": 8218,
			"ldquo": 8220,
			"rdquo": 8221,
			"bdquo": 8222,
			"dagger": 8224,
			"Dagger": 8225,
			"bull": 8226,
			"hellip": 8230,
			"permil": 8240,
			"prime": 8242,
			"Prime": 8243,
			"lsaquo": 8249,
			"rsaquo": 8250,
			"oline": 8254,
			"frasl": 8260,
			"euro": 8364,
			"image": 8465,
			"weierp": 8472,
			"real": 8476,
			"trade": 8482,
			"alefsym": 8501,
			"larr": 8592,
			"uarr": 8593,
			"rarr": 8594,
			"darr": 8595,
			"harr": 8596,
			"crarr": 8629,
			"lArr": 8656,
			"uArr": 8657,
			"rArr": 8658,
			"dArr": 8659,
			"hArr": 8660,
			"forall": 8704,
			"part": 8706,
			"exist": 8707,
			"empty": 8709,
			"nabla": 8711,
			"isin": 8712,
			"notin": 8713,
			"ni": 8715,
			"prod": 8719,
			"sum": 8721,
			"minus": 8722,
			"lowast": 8727,
			"radic": 8730,
			"prop": 8733,
			"infin": 8734,
			"ang": 8736,
			"and": 8743,
			"or": 8744,
			"cap": 8745,
			"cup": 8746,
			"int": 8747,
			"there4": 8756,
			"sim": 8764,
			"cong": 8773,
			"asymp": 8776,
			"ne": 8800,
			"equiv": 8801,
			"le": 8804,
			"ge": 8805,
			"sub": 8834,
			"sup": 8835,
			"nsub": 8836,
			"sube": 8838,
			"supe": 8839,
			"oplus": 8853,
			"otimes": 8855,
			"perp": 8869,
			"sdot": 8901,
			"lceil": 8968,
			"rceil": 8969,
			"lfloor": 8970,
			"rfloor": 8971,
			"lang": 9001,
			"rang": 9002,
			"loz": 9674,
			"spades": 9824,
			"clubs": 9827,
			"hearts": 9829,
			"diams": 9830
		};
		Object.keys(sax.ENTITIES).forEach(function(key) {
			var e$1 = sax.ENTITIES[key];
			var s$3 = typeof e$1 === "number" ? String.fromCharCode(e$1) : e$1;
			sax.ENTITIES[key] = s$3;
		});
		for (var s$2 in sax.STATE) sax.STATE[sax.STATE[s$2]] = s$2;
		S$1 = sax.STATE;
		function emit(parser, event, data) {
			parser[event] && parser[event](data);
		}
		function emitNode(parser, nodeType, data) {
			if (parser.textNode) closeText(parser);
			emit(parser, nodeType, data);
		}
		function closeText(parser) {
			parser.textNode = textopts(parser.opt, parser.textNode);
			if (parser.textNode) emit(parser, "ontext", parser.textNode);
			parser.textNode = "";
		}
		function textopts(opt, text) {
			if (opt.trim) text = text.trim();
			if (opt.normalize) text = text.replace(/\s+/g, " ");
			return text;
		}
		function error$1(parser, er) {
			closeText(parser);
			if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
			er = new Error(er);
			parser.error = er;
			emit(parser, "onerror", er);
			return parser;
		}
		function end(parser) {
			if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
			if (parser.state !== S$1.BEGIN && parser.state !== S$1.BEGIN_WHITESPACE && parser.state !== S$1.TEXT) error$1(parser, "Unexpected end");
			closeText(parser);
			parser.c = "";
			parser.closed = true;
			emit(parser, "onend");
			SAXParser.call(parser, parser.strict, parser.opt);
			return parser;
		}
		function strictFail(parser, message) {
			if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
			if (parser.strict) error$1(parser, message);
		}
		function newTag(parser) {
			if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
			var parent = parser.tags[parser.tags.length - 1] || parser;
			var tag = parser.tag = {
				name: parser.tagName,
				attributes: {}
			};
			if (parser.opt.xmlns) tag.ns = parent.ns;
			parser.attribList.length = 0;
			emitNode(parser, "onopentagstart", tag);
		}
		function qname(name, attribute) {
			var qualName = name.indexOf(":") < 0 ? ["", name] : name.split(":");
			var prefix = qualName[0];
			var local = qualName[1];
			if (attribute && name === "xmlns") {
				prefix = "xmlns";
				local = "";
			}
			return {
				prefix,
				local
			};
		}
		function attrib(parser) {
			if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
			if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
				parser.attribName = parser.attribValue = "";
				return;
			}
			if (parser.opt.xmlns) {
				var qn = qname(parser.attribName, true);
				var prefix = qn.prefix;
				var local = qn.local;
				if (prefix === "xmlns") if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
				else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
				else {
					var tag = parser.tag;
					var parent = parser.tags[parser.tags.length - 1] || parser;
					if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
					tag.ns[local] = parser.attribValue;
				}
				parser.attribList.push([parser.attribName, parser.attribValue]);
			} else {
				parser.tag.attributes[parser.attribName] = parser.attribValue;
				emitNode(parser, "onattribute", {
					name: parser.attribName,
					value: parser.attribValue
				});
			}
			parser.attribName = parser.attribValue = "";
		}
		function openTag(parser, selfClosing) {
			if (parser.opt.xmlns) {
				var tag = parser.tag;
				var qn = qname(parser.tagName);
				tag.prefix = qn.prefix;
				tag.local = qn.local;
				tag.uri = tag.ns[qn.prefix] || "";
				if (tag.prefix && !tag.uri) {
					strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
					tag.uri = qn.prefix;
				}
				var parent = parser.tags[parser.tags.length - 1] || parser;
				if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p$1) {
					emitNode(parser, "onopennamespace", {
						prefix: p$1,
						uri: tag.ns[p$1]
					});
				});
				for (var i$2 = 0, l$2 = parser.attribList.length; i$2 < l$2; i$2++) {
					var nv = parser.attribList[i$2];
					var name = nv[0];
					var value = nv[1];
					var qualName = qname(name, true);
					var prefix = qualName.prefix;
					var local = qualName.local;
					var uri = prefix === "" ? "" : tag.ns[prefix] || "";
					var a$1 = {
						name,
						value,
						prefix,
						local,
						uri
					};
					if (prefix && prefix !== "xmlns" && !uri) {
						strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
						a$1.uri = prefix;
					}
					parser.tag.attributes[name] = a$1;
					emitNode(parser, "onattribute", a$1);
				}
				parser.attribList.length = 0;
			}
			parser.tag.isSelfClosing = !!selfClosing;
			parser.sawRoot = true;
			parser.tags.push(parser.tag);
			emitNode(parser, "onopentag", parser.tag);
			if (!selfClosing) {
				if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S$1.SCRIPT;
				else parser.state = S$1.TEXT;
				parser.tag = null;
				parser.tagName = "";
			}
			parser.attribName = parser.attribValue = "";
			parser.attribList.length = 0;
		}
		function closeTag(parser) {
			if (!parser.tagName) {
				strictFail(parser, "Weird empty close tag.");
				parser.textNode += "</>";
				parser.state = S$1.TEXT;
				return;
			}
			if (parser.script) {
				if (parser.tagName !== "script") {
					parser.script += "</" + parser.tagName + ">";
					parser.tagName = "";
					parser.state = S$1.SCRIPT;
					return;
				}
				emitNode(parser, "onscript", parser.script);
				parser.script = "";
			}
			var t$1 = parser.tags.length;
			var tagName = parser.tagName;
			if (!parser.strict) tagName = tagName[parser.looseCase]();
			var closeTo = tagName;
			while (t$1--) if (parser.tags[t$1].name !== closeTo) strictFail(parser, "Unexpected close tag");
			else break;
			if (t$1 < 0) {
				strictFail(parser, "Unmatched closing tag: " + parser.tagName);
				parser.textNode += "</" + parser.tagName + ">";
				parser.state = S$1.TEXT;
				return;
			}
			parser.tagName = tagName;
			var s$3 = parser.tags.length;
			while (s$3-- > t$1) {
				var tag = parser.tag = parser.tags.pop();
				parser.tagName = parser.tag.name;
				emitNode(parser, "onclosetag", parser.tagName);
				var x$1 = {};
				for (var i$2 in tag.ns) x$1[i$2] = tag.ns[i$2];
				var parent = parser.tags[parser.tags.length - 1] || parser;
				if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p$1) {
					var n$6 = tag.ns[p$1];
					emitNode(parser, "onclosenamespace", {
						prefix: p$1,
						uri: n$6
					});
				});
			}
			if (t$1 === 0) parser.closedRoot = true;
			parser.tagName = parser.attribValue = parser.attribName = "";
			parser.attribList.length = 0;
			parser.state = S$1.TEXT;
		}
		function parseEntity(parser) {
			var entity = parser.entity;
			var entityLC = entity.toLowerCase();
			var num;
			var numStr = "";
			if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
			if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
			entity = entityLC;
			if (entity.charAt(0) === "#") if (entity.charAt(1) === "x") {
				entity = entity.slice(2);
				num = parseInt(entity, 16);
				numStr = num.toString(16);
			} else {
				entity = entity.slice(1);
				num = parseInt(entity, 10);
				numStr = num.toString(10);
			}
			entity = entity.replace(/^0+/, "");
			if (isNaN(num) || numStr.toLowerCase() !== entity) {
				strictFail(parser, "Invalid character entity");
				return "&" + parser.entity + ";";
			}
			return String.fromCodePoint(num);
		}
		function beginWhiteSpace(parser, c$1) {
			if (c$1 === "<") {
				parser.state = S$1.OPEN_WAKA;
				parser.startTagPosition = parser.position;
			} else if (!isWhitespace(c$1)) {
				strictFail(parser, "Non-whitespace before first tag.");
				parser.textNode = c$1;
				parser.state = S$1.TEXT;
			}
		}
		function charAt(chunk$1, i$2) {
			var result = "";
			if (i$2 < chunk$1.length) result = chunk$1.charAt(i$2);
			return result;
		}
		function write(chunk$1) {
			var parser = this;
			if (this.error) throw this.error;
			if (parser.closed) return error$1(parser, "Cannot write after close. Assign an onready handler.");
			if (chunk$1 === null) return end(parser);
			if (typeof chunk$1 === "object") chunk$1 = chunk$1.toString();
			var i$2 = 0;
			var c$1 = "";
			while (true) {
				c$1 = charAt(chunk$1, i$2++);
				parser.c = c$1;
				if (!c$1) break;
				if (parser.trackPosition) {
					parser.position++;
					if (c$1 === "\n") {
						parser.line++;
						parser.column = 0;
					} else parser.column++;
				}
				switch (parser.state) {
					case S$1.BEGIN:
						parser.state = S$1.BEGIN_WHITESPACE;
						if (c$1 === "﻿") continue;
						beginWhiteSpace(parser, c$1);
						continue;
					case S$1.BEGIN_WHITESPACE:
						beginWhiteSpace(parser, c$1);
						continue;
					case S$1.TEXT:
						if (parser.sawRoot && !parser.closedRoot) {
							var starti = i$2 - 1;
							while (c$1 && c$1 !== "<" && c$1 !== "&") {
								c$1 = charAt(chunk$1, i$2++);
								if (c$1 && parser.trackPosition) {
									parser.position++;
									if (c$1 === "\n") {
										parser.line++;
										parser.column = 0;
									} else parser.column++;
								}
							}
							parser.textNode += chunk$1.substring(starti, i$2 - 1);
						}
						if (c$1 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
							parser.state = S$1.OPEN_WAKA;
							parser.startTagPosition = parser.position;
						} else {
							if (!isWhitespace(c$1) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
							if (c$1 === "&") parser.state = S$1.TEXT_ENTITY;
							else parser.textNode += c$1;
						}
						continue;
					case S$1.SCRIPT:
						if (c$1 === "<") parser.state = S$1.SCRIPT_ENDING;
						else parser.script += c$1;
						continue;
					case S$1.SCRIPT_ENDING:
						if (c$1 === "/") parser.state = S$1.CLOSE_TAG;
						else {
							parser.script += "<" + c$1;
							parser.state = S$1.SCRIPT;
						}
						continue;
					case S$1.OPEN_WAKA:
						if (c$1 === "!") {
							parser.state = S$1.SGML_DECL;
							parser.sgmlDecl = "";
						} else if (isWhitespace(c$1)) {} else if (isMatch(nameStart, c$1)) {
							parser.state = S$1.OPEN_TAG;
							parser.tagName = c$1;
						} else if (c$1 === "/") {
							parser.state = S$1.CLOSE_TAG;
							parser.tagName = "";
						} else if (c$1 === "?") {
							parser.state = S$1.PROC_INST;
							parser.procInstName = parser.procInstBody = "";
						} else {
							strictFail(parser, "Unencoded <");
							if (parser.startTagPosition + 1 < parser.position) {
								var pad$1 = parser.position - parser.startTagPosition;
								c$1 = new Array(pad$1).join(" ") + c$1;
							}
							parser.textNode += "<" + c$1;
							parser.state = S$1.TEXT;
						}
						continue;
					case S$1.SGML_DECL:
						if ((parser.sgmlDecl + c$1).toUpperCase() === CDATA) {
							emitNode(parser, "onopencdata");
							parser.state = S$1.CDATA;
							parser.sgmlDecl = "";
							parser.cdata = "";
						} else if (parser.sgmlDecl + c$1 === "--") {
							parser.state = S$1.COMMENT;
							parser.comment = "";
							parser.sgmlDecl = "";
						} else if ((parser.sgmlDecl + c$1).toUpperCase() === DOCTYPE) {
							parser.state = S$1.DOCTYPE;
							if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
							parser.doctype = "";
							parser.sgmlDecl = "";
						} else if (c$1 === ">") {
							emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
							parser.sgmlDecl = "";
							parser.state = S$1.TEXT;
						} else if (isQuote(c$1)) {
							parser.state = S$1.SGML_DECL_QUOTED;
							parser.sgmlDecl += c$1;
						} else parser.sgmlDecl += c$1;
						continue;
					case S$1.SGML_DECL_QUOTED:
						if (c$1 === parser.q) {
							parser.state = S$1.SGML_DECL;
							parser.q = "";
						}
						parser.sgmlDecl += c$1;
						continue;
					case S$1.DOCTYPE:
						if (c$1 === ">") {
							parser.state = S$1.TEXT;
							emitNode(parser, "ondoctype", parser.doctype);
							parser.doctype = true;
						} else {
							parser.doctype += c$1;
							if (c$1 === "[") parser.state = S$1.DOCTYPE_DTD;
							else if (isQuote(c$1)) {
								parser.state = S$1.DOCTYPE_QUOTED;
								parser.q = c$1;
							}
						}
						continue;
					case S$1.DOCTYPE_QUOTED:
						parser.doctype += c$1;
						if (c$1 === parser.q) {
							parser.q = "";
							parser.state = S$1.DOCTYPE;
						}
						continue;
					case S$1.DOCTYPE_DTD:
						parser.doctype += c$1;
						if (c$1 === "]") parser.state = S$1.DOCTYPE;
						else if (isQuote(c$1)) {
							parser.state = S$1.DOCTYPE_DTD_QUOTED;
							parser.q = c$1;
						}
						continue;
					case S$1.DOCTYPE_DTD_QUOTED:
						parser.doctype += c$1;
						if (c$1 === parser.q) {
							parser.state = S$1.DOCTYPE_DTD;
							parser.q = "";
						}
						continue;
					case S$1.COMMENT:
						if (c$1 === "-") parser.state = S$1.COMMENT_ENDING;
						else parser.comment += c$1;
						continue;
					case S$1.COMMENT_ENDING:
						if (c$1 === "-") {
							parser.state = S$1.COMMENT_ENDED;
							parser.comment = textopts(parser.opt, parser.comment);
							if (parser.comment) emitNode(parser, "oncomment", parser.comment);
							parser.comment = "";
						} else {
							parser.comment += "-" + c$1;
							parser.state = S$1.COMMENT;
						}
						continue;
					case S$1.COMMENT_ENDED:
						if (c$1 !== ">") {
							strictFail(parser, "Malformed comment");
							parser.comment += "--" + c$1;
							parser.state = S$1.COMMENT;
						} else parser.state = S$1.TEXT;
						continue;
					case S$1.CDATA:
						if (c$1 === "]") parser.state = S$1.CDATA_ENDING;
						else parser.cdata += c$1;
						continue;
					case S$1.CDATA_ENDING:
						if (c$1 === "]") parser.state = S$1.CDATA_ENDING_2;
						else {
							parser.cdata += "]" + c$1;
							parser.state = S$1.CDATA;
						}
						continue;
					case S$1.CDATA_ENDING_2:
						if (c$1 === ">") {
							if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
							emitNode(parser, "onclosecdata");
							parser.cdata = "";
							parser.state = S$1.TEXT;
						} else if (c$1 === "]") parser.cdata += "]";
						else {
							parser.cdata += "]]" + c$1;
							parser.state = S$1.CDATA;
						}
						continue;
					case S$1.PROC_INST:
						if (c$1 === "?") parser.state = S$1.PROC_INST_ENDING;
						else if (isWhitespace(c$1)) parser.state = S$1.PROC_INST_BODY;
						else parser.procInstName += c$1;
						continue;
					case S$1.PROC_INST_BODY:
						if (!parser.procInstBody && isWhitespace(c$1)) continue;
						else if (c$1 === "?") parser.state = S$1.PROC_INST_ENDING;
						else parser.procInstBody += c$1;
						continue;
					case S$1.PROC_INST_ENDING:
						if (c$1 === ">") {
							emitNode(parser, "onprocessinginstruction", {
								name: parser.procInstName,
								body: parser.procInstBody
							});
							parser.procInstName = parser.procInstBody = "";
							parser.state = S$1.TEXT;
						} else {
							parser.procInstBody += "?" + c$1;
							parser.state = S$1.PROC_INST_BODY;
						}
						continue;
					case S$1.OPEN_TAG:
						if (isMatch(nameBody, c$1)) parser.tagName += c$1;
						else {
							newTag(parser);
							if (c$1 === ">") openTag(parser);
							else if (c$1 === "/") parser.state = S$1.OPEN_TAG_SLASH;
							else {
								if (!isWhitespace(c$1)) strictFail(parser, "Invalid character in tag name");
								parser.state = S$1.ATTRIB;
							}
						}
						continue;
					case S$1.OPEN_TAG_SLASH:
						if (c$1 === ">") {
							openTag(parser, true);
							closeTag(parser);
						} else {
							strictFail(parser, "Forward-slash in opening tag not followed by >");
							parser.state = S$1.ATTRIB;
						}
						continue;
					case S$1.ATTRIB:
						if (isWhitespace(c$1)) continue;
						else if (c$1 === ">") openTag(parser);
						else if (c$1 === "/") parser.state = S$1.OPEN_TAG_SLASH;
						else if (isMatch(nameStart, c$1)) {
							parser.attribName = c$1;
							parser.attribValue = "";
							parser.state = S$1.ATTRIB_NAME;
						} else strictFail(parser, "Invalid attribute name");
						continue;
					case S$1.ATTRIB_NAME:
						if (c$1 === "=") parser.state = S$1.ATTRIB_VALUE;
						else if (c$1 === ">") {
							strictFail(parser, "Attribute without value");
							parser.attribValue = parser.attribName;
							attrib(parser);
							openTag(parser);
						} else if (isWhitespace(c$1)) parser.state = S$1.ATTRIB_NAME_SAW_WHITE;
						else if (isMatch(nameBody, c$1)) parser.attribName += c$1;
						else strictFail(parser, "Invalid attribute name");
						continue;
					case S$1.ATTRIB_NAME_SAW_WHITE:
						if (c$1 === "=") parser.state = S$1.ATTRIB_VALUE;
						else if (isWhitespace(c$1)) continue;
						else {
							strictFail(parser, "Attribute without value");
							parser.tag.attributes[parser.attribName] = "";
							parser.attribValue = "";
							emitNode(parser, "onattribute", {
								name: parser.attribName,
								value: ""
							});
							parser.attribName = "";
							if (c$1 === ">") openTag(parser);
							else if (isMatch(nameStart, c$1)) {
								parser.attribName = c$1;
								parser.state = S$1.ATTRIB_NAME;
							} else {
								strictFail(parser, "Invalid attribute name");
								parser.state = S$1.ATTRIB;
							}
						}
						continue;
					case S$1.ATTRIB_VALUE:
						if (isWhitespace(c$1)) continue;
						else if (isQuote(c$1)) {
							parser.q = c$1;
							parser.state = S$1.ATTRIB_VALUE_QUOTED;
						} else {
							strictFail(parser, "Unquoted attribute value");
							parser.state = S$1.ATTRIB_VALUE_UNQUOTED;
							parser.attribValue = c$1;
						}
						continue;
					case S$1.ATTRIB_VALUE_QUOTED:
						if (c$1 !== parser.q) {
							if (c$1 === "&") parser.state = S$1.ATTRIB_VALUE_ENTITY_Q;
							else parser.attribValue += c$1;
							continue;
						}
						attrib(parser);
						parser.q = "";
						parser.state = S$1.ATTRIB_VALUE_CLOSED;
						continue;
					case S$1.ATTRIB_VALUE_CLOSED:
						if (isWhitespace(c$1)) parser.state = S$1.ATTRIB;
						else if (c$1 === ">") openTag(parser);
						else if (c$1 === "/") parser.state = S$1.OPEN_TAG_SLASH;
						else if (isMatch(nameStart, c$1)) {
							strictFail(parser, "No whitespace between attributes");
							parser.attribName = c$1;
							parser.attribValue = "";
							parser.state = S$1.ATTRIB_NAME;
						} else strictFail(parser, "Invalid attribute name");
						continue;
					case S$1.ATTRIB_VALUE_UNQUOTED:
						if (!isAttribEnd(c$1)) {
							if (c$1 === "&") parser.state = S$1.ATTRIB_VALUE_ENTITY_U;
							else parser.attribValue += c$1;
							continue;
						}
						attrib(parser);
						if (c$1 === ">") openTag(parser);
						else parser.state = S$1.ATTRIB;
						continue;
					case S$1.CLOSE_TAG:
						if (!parser.tagName) if (isWhitespace(c$1)) continue;
						else if (notMatch(nameStart, c$1)) if (parser.script) {
							parser.script += "</" + c$1;
							parser.state = S$1.SCRIPT;
						} else strictFail(parser, "Invalid tagname in closing tag.");
						else parser.tagName = c$1;
						else if (c$1 === ">") closeTag(parser);
						else if (isMatch(nameBody, c$1)) parser.tagName += c$1;
						else if (parser.script) {
							parser.script += "</" + parser.tagName;
							parser.tagName = "";
							parser.state = S$1.SCRIPT;
						} else {
							if (!isWhitespace(c$1)) strictFail(parser, "Invalid tagname in closing tag");
							parser.state = S$1.CLOSE_TAG_SAW_WHITE;
						}
						continue;
					case S$1.CLOSE_TAG_SAW_WHITE:
						if (isWhitespace(c$1)) continue;
						if (c$1 === ">") closeTag(parser);
						else strictFail(parser, "Invalid characters in closing tag");
						continue;
					case S$1.TEXT_ENTITY:
					case S$1.ATTRIB_VALUE_ENTITY_Q:
					case S$1.ATTRIB_VALUE_ENTITY_U:
						var returnState;
						var buffer$1;
						switch (parser.state) {
							case S$1.TEXT_ENTITY:
								returnState = S$1.TEXT;
								buffer$1 = "textNode";
								break;
							case S$1.ATTRIB_VALUE_ENTITY_Q:
								returnState = S$1.ATTRIB_VALUE_QUOTED;
								buffer$1 = "attribValue";
								break;
							case S$1.ATTRIB_VALUE_ENTITY_U:
								returnState = S$1.ATTRIB_VALUE_UNQUOTED;
								buffer$1 = "attribValue";
								break;
						}
						if (c$1 === ";") {
							parser[buffer$1] += parseEntity(parser);
							parser.entity = "";
							parser.state = returnState;
						} else if (isMatch(parser.entity.length ? entityBody : entityStart, c$1)) parser.entity += c$1;
						else {
							strictFail(parser, "Invalid character in entity name");
							parser[buffer$1] += "&" + parser.entity + c$1;
							parser.entity = "";
							parser.state = returnState;
						}
						continue;
					default: throw new Error(parser, "Unknown state: " + parser.state);
				}
			}
			if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
			return parser;
		}
		/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
		/* istanbul ignore next */
		if (!String.fromCodePoint) (function() {
			var stringFromCharCode = String.fromCharCode;
			var floor$1 = Math.floor;
			var fromCodePoint = function() {
				var MAX_SIZE = 16384;
				var codeUnits = [];
				var highSurrogate;
				var lowSurrogate;
				var index = -1;
				var length$1 = arguments.length;
				if (!length$1) return "";
				var result = "";
				while (++index < length$1) {
					var codePoint = Number(arguments[index]);
					if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor$1(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
					if (codePoint <= 65535) codeUnits.push(codePoint);
					else {
						codePoint -= 65536;
						highSurrogate = (codePoint >> 10) + 55296;
						lowSurrogate = codePoint % 1024 + 56320;
						codeUnits.push(highSurrogate, lowSurrogate);
					}
					if (index + 1 === length$1 || codeUnits.length > MAX_SIZE) {
						result += stringFromCharCode.apply(null, codeUnits);
						codeUnits.length = 0;
					}
				}
				return result;
			};
			/* istanbul ignore next */
			if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
				value: fromCodePoint,
				configurable: true,
				writable: true
			});
			else String.fromCodePoint = fromCodePoint;
		})();
	})(typeof exports === "undefined" ? exports.sax = {} : exports);
}));
var require_bom = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		exports.stripBOM = function(str) {
			if (str[0] === "﻿") return str.substring(1);
			else return str;
		};
	}).call(exports);
}));
var require_processors = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		var prefixMatch = /* @__PURE__ */ new RegExp(/(?!xmlns)^.*:/);
		exports.normalize = function(str) {
			return str.toLowerCase();
		};
		exports.firstCharLowerCase = function(str) {
			return str.charAt(0).toLowerCase() + str.slice(1);
		};
		exports.stripPrefix = function(str) {
			return str.replace(prefixMatch, "");
		};
		exports.parseNumbers = function(str) {
			if (!isNaN(str)) str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
			return str;
		};
		exports.parseBooleans = function(str) {
			if (/^(?:true|false)$/i.test(str)) str = str.toLowerCase() === "true";
			return str;
		};
	}).call(exports);
}));
var init_setImmediate = __esmMin((() => {
	init_dist();
	init_dist$1();
	(function(global$1, undefined$1) {
		if (global$1.setImmediate) return;
		var nextHandle = 1;
		var tasksByHandle = {};
		var currentlyRunningATask = false;
		var doc = global$1.document;
		var registerImmediate;
		function setImmediate(callback) {
			if (typeof callback !== "function") callback = new Function("" + callback);
			var args = new Array(arguments.length - 1);
			for (var i$2 = 0; i$2 < args.length; i$2++) args[i$2] = arguments[i$2 + 1];
			tasksByHandle[nextHandle] = {
				callback,
				args
			};
			registerImmediate(nextHandle);
			return nextHandle++;
		}
		function clearImmediate(handle) {
			delete tasksByHandle[handle];
		}
		function run$1(task) {
			var callback = task.callback;
			var args = task.args;
			switch (args.length) {
				case 0:
					callback();
					break;
				case 1:
					callback(args[0]);
					break;
				case 2:
					callback(args[0], args[1]);
					break;
				case 3:
					callback(args[0], args[1], args[2]);
					break;
				default:
					callback.apply(undefined$1, args);
					break;
			}
		}
		function runIfPresent(handle) {
			if (currentlyRunningATask) setTimeout(runIfPresent, 0, handle);
			else {
				var task = tasksByHandle[handle];
				if (task) {
					currentlyRunningATask = true;
					try {
						run$1(task);
					} finally {
						clearImmediate(handle);
						currentlyRunningATask = false;
					}
				}
			}
		}
		function installNextTickImplementation() {
			registerImmediate = function(handle) {
				process$1.nextTick(function() {
					runIfPresent(handle);
				});
			};
		}
		function canUsePostMessage() {
			if (global$1.postMessage && !global$1.importScripts) {
				var postMessageIsAsynchronous = true;
				var oldOnMessage = global$1.onmessage;
				global$1.onmessage = function() {
					postMessageIsAsynchronous = false;
				};
				global$1.postMessage("", "*");
				global$1.onmessage = oldOnMessage;
				return postMessageIsAsynchronous;
			}
		}
		function installPostMessageImplementation() {
			var messagePrefix = "setImmediate$" + Math.random() + "$";
			var onGlobalMessage = function(event) {
				if (event.source === global$1 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) runIfPresent(+event.data.slice(messagePrefix.length));
			};
			if (global$1.addEventListener) global$1.addEventListener("message", onGlobalMessage, false);
			else global$1.attachEvent("onmessage", onGlobalMessage);
			registerImmediate = function(handle) {
				global$1.postMessage(messagePrefix + handle, "*");
			};
		}
		function installMessageChannelImplementation() {
			var channel = new MessageChannel();
			channel.port1.onmessage = function(event) {
				var handle = event.data;
				runIfPresent(handle);
			};
			registerImmediate = function(handle) {
				channel.port2.postMessage(handle);
			};
		}
		function installReadyStateChangeImplementation() {
			var html = doc.documentElement;
			registerImmediate = function(handle) {
				var script = doc.createElement("script");
				script.onreadystatechange = function() {
					runIfPresent(handle);
					script.onreadystatechange = null;
					html.removeChild(script);
					script = null;
				};
				html.appendChild(script);
			};
		}
		function installSetTimeoutImplementation() {
			registerImmediate = function(handle) {
				setTimeout(runIfPresent, 0, handle);
			};
		}
		var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global$1);
		attachTo = attachTo && attachTo.setTimeout ? attachTo : global$1;
		if ({}.toString.call(global$1.process) === "[object process]") installNextTickImplementation();
		else if (canUsePostMessage()) installPostMessageImplementation();
		else if (global$1.MessageChannel) installMessageChannelImplementation();
		else if (doc && "onreadystatechange" in doc.createElement("script")) installReadyStateChangeImplementation();
		else installSetTimeoutImplementation();
		attachTo.setImmediate = setImmediate;
		attachTo.clearImmediate = clearImmediate;
	})(typeof self === "undefined" ? typeof global === "undefined" ? void 0 : global : self);
}));
var require_main$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	init_dist();
	var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
	var apply = Function.prototype.apply;
	exports.setTimeout = function() {
		return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
		return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function(timeout) {
		if (timeout) timeout.close();
	};
	function Timeout(id, clearFn) {
		this._id = id;
		this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
		this._clearFn.call(scope, this._id);
	};
	exports.enroll = function(item, msecs) {
		clearTimeout(item._idleTimeoutId);
		item._idleTimeout = msecs;
	};
	exports.unenroll = function(item) {
		clearTimeout(item._idleTimeoutId);
		item._idleTimeout = -1;
	};
	exports._unrefActive = exports.active = function(item) {
		clearTimeout(item._idleTimeoutId);
		var msecs = item._idleTimeout;
		if (msecs >= 0) item._idleTimeoutId = setTimeout(function onTimeout() {
			if (item._onTimeout) item._onTimeout();
		}, msecs);
	};
	init_setImmediate();
	exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || exports && exports.setImmediate;
	exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || exports && exports.clearImmediate;
}));
var require_parser$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		var bom, defaults$1, defineProperty$1, events, isEmpty$5, processItem, processors, sax, setImmediate, bind$1 = function(fn$1, me) {
			return function() {
				return fn$1.apply(me, arguments);
			};
		}, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		sax = require_sax();
		events = require_events();
		bom = require_bom();
		processors = require_processors();
		setImmediate = require_main$3().setImmediate;
		defaults$1 = require_defaults().defaults;
		isEmpty$5 = function(thing) {
			return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
		};
		processItem = function(processors$1, item, key) {
			var i$2, len$1, process;
			for (i$2 = 0, len$1 = processors$1.length; i$2 < len$1; i$2++) {
				process = processors$1[i$2];
				item = process(item, key);
			}
			return item;
		};
		defineProperty$1 = function(obj, key, value) {
			var descriptor = Object.create(null);
			descriptor.value = value;
			descriptor.writable = true;
			descriptor.enumerable = true;
			descriptor.configurable = true;
			return Object.defineProperty(obj, key, descriptor);
		};
		exports.Parser = (function(superClass) {
			extend$1(Parser$1, superClass);
			function Parser$1(opts) {
				this.parseStringPromise = bind$1(this.parseStringPromise, this);
				this.parseString = bind$1(this.parseString, this);
				this.reset = bind$1(this.reset, this);
				this.assignOrPush = bind$1(this.assignOrPush, this);
				this.processAsync = bind$1(this.processAsync, this);
				var key, ref, value;
				if (!(this instanceof exports.Parser)) return new exports.Parser(opts);
				this.options = {};
				ref = defaults$1["0.2"];
				for (key in ref) {
					if (!hasProp.call(ref, key)) continue;
					value = ref[key];
					this.options[key] = value;
				}
				for (key in opts) {
					if (!hasProp.call(opts, key)) continue;
					value = opts[key];
					this.options[key] = value;
				}
				if (this.options.xmlns) this.options.xmlnskey = this.options.attrkey + "ns";
				if (this.options.normalizeTags) {
					if (!this.options.tagNameProcessors) this.options.tagNameProcessors = [];
					this.options.tagNameProcessors.unshift(processors.normalize);
				}
				this.reset();
			}
			Parser$1.prototype.processAsync = function() {
				var chunk$1, err;
				try {
					if (this.remaining.length <= this.options.chunkSize) {
						chunk$1 = this.remaining;
						this.remaining = "";
						this.saxParser = this.saxParser.write(chunk$1);
						return this.saxParser.close();
					} else {
						chunk$1 = this.remaining.substr(0, this.options.chunkSize);
						this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
						this.saxParser = this.saxParser.write(chunk$1);
						return setImmediate(this.processAsync);
					}
				} catch (error1) {
					err = error1;
					if (!this.saxParser.errThrown) {
						this.saxParser.errThrown = true;
						return this.emit(err);
					}
				}
			};
			Parser$1.prototype.assignOrPush = function(obj, key, newValue) {
				if (!(key in obj)) if (!this.options.explicitArray) return defineProperty$1(obj, key, newValue);
				else return defineProperty$1(obj, key, [newValue]);
				else {
					if (!(obj[key] instanceof Array)) defineProperty$1(obj, key, [obj[key]]);
					return obj[key].push(newValue);
				}
			};
			Parser$1.prototype.reset = function() {
				var attrkey, charkey, ontext, stack;
				this.removeAllListeners();
				this.saxParser = sax.parser(this.options.strict, {
					trim: false,
					normalize: false,
					xmlns: this.options.xmlns
				});
				this.saxParser.errThrown = false;
				this.saxParser.onerror = (function(_this) {
					return function(error$1) {
						_this.saxParser.resume();
						if (!_this.saxParser.errThrown) {
							_this.saxParser.errThrown = true;
							return _this.emit("error", error$1);
						}
					};
				})(this);
				this.saxParser.onend = (function(_this) {
					return function() {
						if (!_this.saxParser.ended) {
							_this.saxParser.ended = true;
							return _this.emit("end", _this.resultObject);
						}
					};
				})(this);
				this.saxParser.ended = false;
				this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
				this.resultObject = null;
				stack = [];
				attrkey = this.options.attrkey;
				charkey = this.options.charkey;
				this.saxParser.onopentag = (function(_this) {
					return function(node) {
						var key, newValue, obj = {}, processedKey, ref;
						obj[charkey] = "";
						if (!_this.options.ignoreAttrs) {
							ref = node.attributes;
							for (key in ref) {
								if (!hasProp.call(ref, key)) continue;
								if (!(attrkey in obj) && !_this.options.mergeAttrs) obj[attrkey] = {};
								newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
								processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
								if (_this.options.mergeAttrs) _this.assignOrPush(obj, processedKey, newValue);
								else defineProperty$1(obj[attrkey], processedKey, newValue);
							}
						}
						obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
						if (_this.options.xmlns) obj[_this.options.xmlnskey] = {
							uri: node.uri,
							local: node.local
						};
						return stack.push(obj);
					};
				})(this);
				this.saxParser.onclosetag = (function(_this) {
					return function() {
						var cdata, emptyStr, key, node, nodeName, obj = stack.pop(), objClone, old, s$2, xpath;
						nodeName = obj["#name"];
						if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) delete obj["#name"];
						if (obj.cdata === true) {
							cdata = obj.cdata;
							delete obj.cdata;
						}
						s$2 = stack[stack.length - 1];
						if (obj[charkey].match(/^\s*$/) && !cdata) {
							emptyStr = obj[charkey];
							delete obj[charkey];
						} else {
							if (_this.options.trim) obj[charkey] = obj[charkey].trim();
							if (_this.options.normalize) obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
							obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
							if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
						}
						if (isEmpty$5(obj)) if (typeof _this.options.emptyTag === "function") obj = _this.options.emptyTag();
						else obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
						if (_this.options.validator != null) {
							xpath = "/" + (function() {
								var i$2, len$1, results = [];
								for (i$2 = 0, len$1 = stack.length; i$2 < len$1; i$2++) {
									node = stack[i$2];
									results.push(node["#name"]);
								}
								return results;
							})().concat(nodeName).join("/");
							(function() {
								var err;
								try {
									return obj = _this.options.validator(xpath, s$2 && s$2[nodeName], obj);
								} catch (error1) {
									err = error1;
									return _this.emit("error", err);
								}
							})();
						}
						if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
							if (!_this.options.preserveChildrenOrder) {
								node = {};
								if (_this.options.attrkey in obj) {
									node[_this.options.attrkey] = obj[_this.options.attrkey];
									delete obj[_this.options.attrkey];
								}
								if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
									node[_this.options.charkey] = obj[_this.options.charkey];
									delete obj[_this.options.charkey];
								}
								if (Object.getOwnPropertyNames(obj).length > 0) node[_this.options.childkey] = obj;
								obj = node;
							} else if (s$2) {
								s$2[_this.options.childkey] = s$2[_this.options.childkey] || [];
								objClone = {};
								for (key in obj) {
									if (!hasProp.call(obj, key)) continue;
									defineProperty$1(objClone, key, obj[key]);
								}
								s$2[_this.options.childkey].push(objClone);
								delete obj["#name"];
								if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
							}
						}
						if (stack.length > 0) return _this.assignOrPush(s$2, nodeName, obj);
						else {
							if (_this.options.explicitRoot) {
								old = obj;
								obj = {};
								defineProperty$1(obj, nodeName, old);
							}
							_this.resultObject = obj;
							_this.saxParser.ended = true;
							return _this.emit("end", _this.resultObject);
						}
					};
				})(this);
				ontext = (function(_this) {
					return function(text) {
						var charChild, s$2 = stack[stack.length - 1];
						if (s$2) {
							s$2[charkey] += text;
							if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
								s$2[_this.options.childkey] = s$2[_this.options.childkey] || [];
								charChild = { "#name": "__text__" };
								charChild[charkey] = text;
								if (_this.options.normalize) charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
								s$2[_this.options.childkey].push(charChild);
							}
							return s$2;
						}
					};
				})(this);
				this.saxParser.ontext = ontext;
				return this.saxParser.oncdata = (function(_this) {
					return function(text) {
						var s$2 = ontext(text);
						if (s$2) return s$2.cdata = true;
					};
				})(this);
			};
			Parser$1.prototype.parseString = function(str, cb) {
				var err;
				if (cb != null && typeof cb === "function") {
					this.on("end", function(result) {
						this.reset();
						return cb(null, result);
					});
					this.on("error", function(err$1) {
						this.reset();
						return cb(err$1);
					});
				}
				try {
					str = str.toString();
					if (str.trim() === "") {
						this.emit("end", null);
						return true;
					}
					str = bom.stripBOM(str);
					if (this.options.async) {
						this.remaining = str;
						setImmediate(this.processAsync);
						return this.saxParser;
					}
					return this.saxParser.write(str).close();
				} catch (error1) {
					err = error1;
					if (!(this.saxParser.errThrown || this.saxParser.ended)) {
						this.emit("error", err);
						return this.saxParser.errThrown = true;
					} else if (this.saxParser.ended) throw err;
				}
			};
			Parser$1.prototype.parseStringPromise = function(str) {
				return new Promise((function(_this) {
					return function(resolve, reject) {
						return _this.parseString(str, function(err, value) {
							if (err) return reject(err);
							else return resolve(value);
						});
					};
				})(this));
			};
			return Parser$1;
		})(events);
		exports.parseString = function(str, a$1, b$5) {
			var cb, options, parser;
			if (b$5 != null) {
				if (typeof b$5 === "function") cb = b$5;
				if (typeof a$1 === "object") options = a$1;
			} else {
				if (typeof a$1 === "function") cb = a$1;
				options = {};
			}
			parser = new exports.Parser(options);
			return parser.parseString(str, cb);
		};
		exports.parseStringPromise = function(str, a$1) {
			var options, parser;
			if (typeof a$1 === "object") options = a$1;
			parser = new exports.Parser(options);
			return parser.parseStringPromise(str);
		};
	}).call(exports);
}));
var require_xml2js = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		var builder, defaults$1, parser, processors, extend$1 = function(child, parent) {
			for (var key in parent) if (hasProp.call(parent, key)) child[key] = parent[key];
			function ctor() {
				this.constructor = child;
			}
			ctor.prototype = parent.prototype;
			child.prototype = new ctor();
			child.__super__ = parent.prototype;
			return child;
		}, hasProp = {}.hasOwnProperty;
		defaults$1 = require_defaults();
		builder = require_builder();
		parser = require_parser$1();
		processors = require_processors();
		exports.defaults = defaults$1.defaults;
		exports.processors = processors;
		exports.ValidationError = (function(superClass) {
			extend$1(ValidationError, superClass);
			function ValidationError(message) {
				this.message = message;
			}
			return ValidationError;
		})(Error);
		exports.Builder = builder.Builder;
		exports.Parser = parser.Parser;
		exports.parseString = parser.parseString;
		exports.parseStringPromise = parser.parseStringPromise;
	}).call(exports);
}));
var Syntax;
(function(Syntax$1) {
	Syntax$1["AssignmentExpression"] = "AssignmentExpression";
	Syntax$1["AssignmentPattern"] = "AssignmentPattern";
	Syntax$1["ArrayExpression"] = "ArrayExpression";
	Syntax$1["ArrayPattern"] = "ArrayPattern";
	Syntax$1["ArrowFunctionExpression"] = "ArrowFunctionExpression";
	Syntax$1["AwaitExpression"] = "AwaitExpression";
	Syntax$1["BlockStatement"] = "BlockStatement";
	Syntax$1["BinaryExpression"] = "BinaryExpression";
	Syntax$1["BreakStatement"] = "BreakStatement";
	Syntax$1["CallExpression"] = "CallExpression";
	Syntax$1["CatchClause"] = "CatchClause";
	Syntax$1["ChainExpression"] = "ChainExpression";
	Syntax$1["ClassBody"] = "ClassBody";
	Syntax$1["ClassDeclaration"] = "ClassDeclaration";
	Syntax$1["ClassExpression"] = "ClassExpression";
	Syntax$1["ConditionalExpression"] = "ConditionalExpression";
	Syntax$1["ContinueStatement"] = "ContinueStatement";
	Syntax$1["Decorator"] = "Decorator";
	Syntax$1["DoWhileStatement"] = "DoWhileStatement";
	Syntax$1["DebuggerStatement"] = "DebuggerStatement";
	Syntax$1["EmptyStatement"] = "EmptyStatement";
	Syntax$1["ExportAllDeclaration"] = "ExportAllDeclaration";
	Syntax$1["ExportDefaultDeclaration"] = "ExportDefaultDeclaration";
	Syntax$1["ExportNamedDeclaration"] = "ExportNamedDeclaration";
	Syntax$1["ExportSpecifier"] = "ExportSpecifier";
	Syntax$1["ExpressionStatement"] = "ExpressionStatement";
	Syntax$1["ForStatement"] = "ForStatement";
	Syntax$1["ForOfStatement"] = "ForOfStatement";
	Syntax$1["ForInStatement"] = "ForInStatement";
	Syntax$1["FunctionDeclaration"] = "FunctionDeclaration";
	Syntax$1["FunctionExpression"] = "FunctionExpression";
	Syntax$1["Identifier"] = "Identifier";
	Syntax$1["IfStatement"] = "IfStatement";
	Syntax$1["ImportAttribute"] = "ImportAttribute";
	Syntax$1["ImportExpression"] = "ImportExpression";
	Syntax$1["ImportDeclaration"] = "ImportDeclaration";
	Syntax$1["ImportDefaultSpecifier"] = "ImportDefaultSpecifier";
	Syntax$1["ImportNamespaceSpecifier"] = "ImportNamespaceSpecifier";
	Syntax$1["ImportSpecifier"] = "ImportSpecifier";
	Syntax$1["Literal"] = "Literal";
	Syntax$1["LabeledStatement"] = "LabeledStatement";
	Syntax$1["LogicalExpression"] = "LogicalExpression";
	Syntax$1["MemberExpression"] = "MemberExpression";
	Syntax$1["MetaProperty"] = "MetaProperty";
	Syntax$1["MethodDefinition"] = "MethodDefinition";
	Syntax$1["NewExpression"] = "NewExpression";
	Syntax$1["ObjectExpression"] = "ObjectExpression";
	Syntax$1["ObjectPattern"] = "ObjectPattern";
	Syntax$1["Program"] = "Program";
	Syntax$1["Property"] = "Property";
	Syntax$1["PrivateIdentifier"] = "PrivateIdentifier";
	Syntax$1["RestElement"] = "RestElement";
	Syntax$1["ReturnStatement"] = "ReturnStatement";
	Syntax$1["SequenceExpression"] = "SequenceExpression";
	Syntax$1["SpreadElement"] = "SpreadElement";
	Syntax$1["StaticBlock"] = "StaticBlock";
	Syntax$1["Super"] = "Super";
	Syntax$1["SwitchCase"] = "SwitchCase";
	Syntax$1["SwitchStatement"] = "SwitchStatement";
	Syntax$1["TaggedTemplateExpression"] = "TaggedTemplateExpression";
	Syntax$1["TemplateElement"] = "TemplateElement";
	Syntax$1["TemplateLiteral"] = "TemplateLiteral";
	Syntax$1["ThisExpression"] = "ThisExpression";
	Syntax$1["ThrowStatement"] = "ThrowStatement";
	Syntax$1["TryStatement"] = "TryStatement";
	Syntax$1["UnaryExpression"] = "UnaryExpression";
	Syntax$1["UpdateExpression"] = "UpdateExpression";
	Syntax$1["VariableDeclaration"] = "VariableDeclaration";
	Syntax$1["VariableDeclarator"] = "VariableDeclarator";
	Syntax$1["WhileStatement"] = "WhileStatement";
	Syntax$1["WithStatement"] = "WithStatement";
	Syntax$1["YieldExpression"] = "YieldExpression";
})(Syntax || (Syntax = {}));
var CommentHandler = class {
	constructor() {
		this.attach = false;
		this.comments = [];
		this.stack = [];
		this.leading = [];
		this.trailing = [];
	}
	insertInnerComments(node, metadata) {
		if (node.type === Syntax.BlockStatement && node.body.length === 0) {
			const innerComments = [];
			for (let i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
				const entry = this.leading[i$2];
				if (metadata.end.offset >= entry.start) {
					innerComments.unshift(entry.comment);
					this.leading.splice(i$2, 1);
					this.trailing.splice(i$2, 1);
				}
			}
			if (innerComments.length) node.innerComments = innerComments;
		}
	}
	findTrailingComments(metadata) {
		let trailingComments = [];
		if (this.trailing.length > 0) {
			for (let i$2 = this.trailing.length - 1; i$2 >= 0; --i$2) {
				const entry = this.trailing[i$2];
				if (entry.start >= metadata.end.offset) trailingComments.unshift(entry.comment);
			}
			this.trailing.length = 0;
			return trailingComments;
		}
		const last$1 = this.stack[this.stack.length - 1];
		if (last$1 && last$1.node.trailingComments) {
			const firstComment = last$1.node.trailingComments[0];
			if (firstComment && firstComment.range[0] >= metadata.end.offset) {
				trailingComments = last$1.node.trailingComments;
				delete last$1.node.trailingComments;
			}
		}
		return trailingComments;
	}
	findLeadingComments(metadata) {
		const leadingComments = [];
		let target;
		while (this.stack.length > 0) {
			const entry = this.stack[this.stack.length - 1];
			if (entry && entry.start >= metadata.start.offset) {
				target = entry.node;
				this.stack.pop();
			} else break;
		}
		if (target) {
			const count = target.leadingComments ? target.leadingComments.length : 0;
			for (let i$2 = count - 1; i$2 >= 0; --i$2) {
				const comment = target.leadingComments[i$2];
				if (comment.range[1] <= metadata.start.offset) {
					leadingComments.unshift(comment);
					target.leadingComments.splice(i$2, 1);
				}
			}
			if (target.leadingComments && target.leadingComments.length === 0) delete target.leadingComments;
			return leadingComments;
		}
		for (let i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
			const entry = this.leading[i$2];
			if (entry.start <= metadata.start.offset) {
				leadingComments.unshift(entry.comment);
				this.leading.splice(i$2, 1);
			}
		}
		return leadingComments;
	}
	visitNode(node, metadata) {
		if (node.type === Syntax.Program && node.body.length > 0) return;
		this.insertInnerComments(node, metadata);
		const trailingComments = this.findTrailingComments(metadata);
		const leadingComments = this.findLeadingComments(metadata);
		if (leadingComments.length > 0) node.leadingComments = leadingComments;
		if (trailingComments.length > 0) node.trailingComments = trailingComments;
		this.stack.push({
			node,
			start: metadata.start.offset
		});
	}
	visitComment(node, metadata) {
		const type = node.type[0] === "L" ? "Line" : "Block";
		const comment = {
			type,
			value: node.value
		};
		if (node.range) comment.range = node.range;
		if (node.loc) comment.loc = node.loc;
		this.comments.push(comment);
		if (this.attach) {
			const entry = {
				comment: {
					type,
					value: node.value,
					range: [metadata.start.offset, metadata.end.offset]
				},
				start: metadata.start.offset
			};
			if (node.loc) entry.comment.loc = node.loc;
			node.type = type;
			this.leading.push(entry);
			this.trailing.push(entry);
		}
	}
	visit(node, metadata) {
		if (node.type === "LineComment") this.visitComment(node, metadata);
		else if (node.type === "BlockComment") this.visitComment(node, metadata);
		else if (this.attach) this.visitNode(node, metadata);
	}
};
var Regex = {
	NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
	NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDF00-\uDF1C\uDF27\uDF30-\uDF50\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
};
var Character = {
	fromCodePoint(cp) {
		return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
	},
	isStringWellFormedUnicode(text) {
		for (let i$2 = 0; i$2 < text.length; i$2++) {
			let c$1 = text.charCodeAt(i$2);
			if (c$1 >= 55296 && c$1 <= 56319) {
				if (i$2 === text.length - 1) return false;
				i$2++;
				c$1 = text.charCodeAt(i$2);
				if (c$1 < 56320 && c$1 > 57343) return false;
			} else if (c$1 >= 56320 && c$1 <= 57343) return false;
		}
		return true;
	},
	isWhiteSpace(cp) {
		return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [
			5760,
			8192,
			8193,
			8194,
			8195,
			8196,
			8197,
			8198,
			8199,
			8200,
			8201,
			8202,
			8239,
			8287,
			12288,
			65279
		].indexOf(cp) >= 0;
	},
	isLineTerminator(cp) {
		return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
	},
	isIdentifierStart(cp) {
		return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(Character.fromCodePoint(cp));
	},
	isIdentifierPart(cp) {
		return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(Character.fromCodePoint(cp));
	},
	isDecimalDigit(cp) {
		return cp >= 48 && cp <= 57;
	},
	isDecimalDigitChar(ch) {
		return ch.length === 1 && Character.isDecimalDigit(ch.charCodeAt(0));
	},
	isHexDigit(cp) {
		return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
	},
	isHexDigitChar(ch) {
		return ch.length === 1 && Character.isHexDigit(ch.charCodeAt(0));
	},
	isOctalDigit(cp) {
		return cp >= 48 && cp <= 55;
	},
	isOctalDigitChar(ch) {
		return ch.length === 1 && Character.isOctalDigit(ch.charCodeAt(0));
	}
};
var JSXSyntax;
(function(JSXSyntax$1) {
	JSXSyntax$1["JSXAttribute"] = "JSXAttribute";
	JSXSyntax$1["JSXClosingElement"] = "JSXClosingElement";
	JSXSyntax$1["JSXClosingFragment"] = "JSXClosingFragment";
	JSXSyntax$1["JSXElement"] = "JSXElement";
	JSXSyntax$1["JSXEmptyExpression"] = "JSXEmptyExpression";
	JSXSyntax$1["JSXExpressionContainer"] = "JSXExpressionContainer";
	JSXSyntax$1["JSXIdentifier"] = "JSXIdentifier";
	JSXSyntax$1["JSXMemberExpression"] = "JSXMemberExpression";
	JSXSyntax$1["JSXNamespacedName"] = "JSXNamespacedName";
	JSXSyntax$1["JSXOpeningElement"] = "JSXOpeningElement";
	JSXSyntax$1["JSXOpeningFragment"] = "JSXOpeningFragment";
	JSXSyntax$1["JSXSpreadAttribute"] = "JSXSpreadAttribute";
	JSXSyntax$1["JSXText"] = "JSXText";
})(JSXSyntax || (JSXSyntax = {}));
var JSXClosingElement = class {
	constructor(name) {
		this.type = JSXSyntax.JSXClosingElement;
		this.name = name;
	}
};
var JSXClosingFragment = class {
	constructor() {
		this.type = JSXSyntax.JSXClosingFragment;
	}
};
var JSXElement = class {
	constructor(openingElement, children$1, closingElement) {
		this.type = JSXSyntax.JSXElement;
		this.openingElement = openingElement;
		this.children = children$1;
		this.closingElement = closingElement;
	}
};
var JSXEmptyExpression = class {
	constructor() {
		this.type = JSXSyntax.JSXEmptyExpression;
	}
};
var JSXExpressionContainer = class {
	constructor(expression) {
		this.type = JSXSyntax.JSXExpressionContainer;
		this.expression = expression;
	}
};
var JSXIdentifier = class {
	constructor(name) {
		this.type = JSXSyntax.JSXIdentifier;
		this.name = name;
	}
};
var JSXMemberExpression = class {
	constructor(object, property$2) {
		this.type = JSXSyntax.JSXMemberExpression;
		this.object = object;
		this.property = property$2;
	}
};
var JSXAttribute = class {
	constructor(name, value) {
		this.type = JSXSyntax.JSXAttribute;
		this.name = name;
		this.value = value;
	}
};
var JSXNamespacedName = class {
	constructor(namespace, name) {
		this.type = JSXSyntax.JSXNamespacedName;
		this.namespace = namespace;
		this.name = name;
	}
};
var JSXOpeningElement = class {
	constructor(name, selfClosing, attributes) {
		this.type = JSXSyntax.JSXOpeningElement;
		this.name = name;
		this.selfClosing = selfClosing;
		this.attributes = attributes;
	}
};
var JSXOpeningFragment = class {
	constructor(selfClosing) {
		this.type = JSXSyntax.JSXOpeningFragment;
		this.selfClosing = selfClosing;
	}
};
var JSXSpreadAttribute = class {
	constructor(argument) {
		this.type = JSXSyntax.JSXSpreadAttribute;
		this.argument = argument;
	}
};
var JSXText = class {
	constructor(value, raw) {
		this.type = JSXSyntax.JSXText;
		this.value = value;
		this.raw = raw;
	}
};
var ArrayExpression = class {
	constructor(elements) {
		this.type = Syntax.ArrayExpression;
		this.elements = elements;
	}
};
var ArrayPattern = class {
	constructor(elements) {
		this.type = Syntax.ArrayPattern;
		this.elements = elements;
	}
};
var ArrowFunctionExpression = class {
	constructor(params, body, expression, isAsync$1) {
		this.type = Syntax.ArrowFunctionExpression;
		this.id = null;
		this.params = params;
		this.body = body;
		this.generator = false;
		this.expression = expression;
		this.async = isAsync$1;
	}
};
var AssignmentExpression = class {
	constructor(operator, left, right) {
		this.type = Syntax.AssignmentExpression;
		this.operator = operator;
		this.left = left;
		this.right = right;
	}
};
var AssignmentPattern = class {
	constructor(left, right) {
		this.type = Syntax.AssignmentPattern;
		this.left = left;
		this.right = right;
	}
};
var AsyncFunctionDeclaration = class {
	constructor(id, params, body, generator) {
		this.type = Syntax.FunctionDeclaration;
		this.id = id;
		this.params = params;
		this.body = body;
		this.generator = generator;
		this.expression = false;
		this.async = true;
	}
};
var AwaitExpression = class {
	constructor(argument) {
		this.type = Syntax.AwaitExpression;
		this.argument = argument;
	}
};
var BigIntLiteral = class {
	constructor(value, raw, bigint) {
		this.type = Syntax.Literal;
		this.value = value;
		this.raw = raw;
		this.bigint = bigint;
	}
};
var BinaryExpression = class {
	constructor(operator, left, right) {
		this.type = Syntax.BinaryExpression;
		this.operator = operator;
		this.left = left;
		this.right = right;
	}
};
var BlockStatement = class {
	constructor(body) {
		this.type = Syntax.BlockStatement;
		this.body = body;
	}
};
var BreakStatement = class {
	constructor(label) {
		this.type = Syntax.BreakStatement;
		this.label = label;
	}
};
var CallExpression = class {
	constructor(callee, args, optional) {
		this.type = Syntax.CallExpression;
		this.callee = callee;
		this.arguments = args;
		this.optional = optional;
	}
};
var CatchClause = class {
	constructor(param, body) {
		this.type = Syntax.CatchClause;
		this.param = param;
		this.body = body;
	}
};
var ChainExpression = class {
	constructor(expression) {
		this.type = Syntax.ChainExpression;
		this.expression = expression;
	}
};
var ClassBody = class {
	constructor(body) {
		this.type = Syntax.ClassBody;
		this.body = body;
	}
};
var ClassDeclaration = class {
	constructor(id, superClass, body, decorators) {
		this.type = Syntax.ClassDeclaration;
		this.id = id;
		this.superClass = superClass;
		this.body = body;
		this.decorators = decorators;
	}
};
var ClassExpression = class {
	constructor(id, superClass, body, decorators) {
		this.type = Syntax.ClassExpression;
		this.id = id;
		this.superClass = superClass;
		this.body = body;
		this.decorators = decorators;
	}
};
var ConditionalExpression = class {
	constructor(test, consequent, alternate) {
		this.type = Syntax.ConditionalExpression;
		this.test = test;
		this.consequent = consequent;
		this.alternate = alternate;
	}
};
var ContinueStatement = class {
	constructor(label) {
		this.type = Syntax.ContinueStatement;
		this.label = label;
	}
};
var DebuggerStatement = class {
	constructor() {
		this.type = Syntax.DebuggerStatement;
	}
};
var Decorator = class {
	constructor(expression) {
		this.type = Syntax.Decorator;
		this.expression = expression;
	}
};
var Directive = class {
	constructor(expression, directive) {
		this.type = Syntax.ExpressionStatement;
		this.expression = expression;
		this.directive = directive;
	}
};
var DoWhileStatement = class {
	constructor(body, test) {
		this.type = Syntax.DoWhileStatement;
		this.body = body;
		this.test = test;
	}
};
var EmptyStatement = class {
	constructor() {
		this.type = Syntax.EmptyStatement;
	}
};
var ExportAllDeclaration = class {
	constructor(source, exported, assertions) {
		this.type = Syntax.ExportAllDeclaration;
		this.source = source;
		this.exported = exported;
		this.assertions = assertions;
	}
};
var ExportDefaultDeclaration = class {
	constructor(declaration) {
		this.type = Syntax.ExportDefaultDeclaration;
		this.declaration = declaration;
	}
};
var ExportNamedDeclaration = class {
	constructor(declaration, specifiers, source, assertions) {
		this.type = Syntax.ExportNamedDeclaration;
		this.declaration = declaration;
		this.specifiers = specifiers;
		this.source = source;
		this.assertions = assertions;
	}
};
var ExportSpecifier = class {
	constructor(local, exported) {
		this.type = Syntax.ExportSpecifier;
		this.exported = exported;
		this.local = local;
	}
};
var ExpressionStatement = class {
	constructor(expression) {
		this.type = Syntax.ExpressionStatement;
		this.expression = expression;
	}
};
var ForInStatement = class {
	constructor(left, right, body) {
		this.type = Syntax.ForInStatement;
		this.left = left;
		this.right = right;
		this.body = body;
		this.each = false;
	}
};
var ForOfStatement = class {
	constructor(left, right, body, _await) {
		this.type = Syntax.ForOfStatement;
		this.await = _await;
		this.left = left;
		this.right = right;
		this.body = body;
	}
};
var ForStatement = class {
	constructor(init, test, update, body) {
		this.type = Syntax.ForStatement;
		this.init = init;
		this.test = test;
		this.update = update;
		this.body = body;
	}
};
var FunctionDeclaration = class {
	constructor(id, params, body, generator) {
		this.type = Syntax.FunctionDeclaration;
		this.id = id;
		this.params = params;
		this.body = body;
		this.generator = generator;
		this.expression = false;
		this.async = false;
	}
};
var FunctionExpression = class {
	constructor(id, params, body, generator, isAsync$1) {
		this.type = Syntax.FunctionExpression;
		this.id = id;
		this.params = params;
		this.body = body;
		this.generator = generator;
		this.expression = false;
		this.async = isAsync$1;
	}
};
var Identifier = class {
	constructor(name) {
		this.type = Syntax.Identifier;
		this.name = name;
	}
};
var IfStatement = class {
	constructor(test, consequent, alternate) {
		this.type = Syntax.IfStatement;
		this.test = test;
		this.consequent = consequent;
		this.alternate = alternate;
	}
};
var ImportAttribute = class {
	constructor(key, value) {
		this.type = Syntax.ImportAttribute;
		this.key = key;
		this.value = value;
	}
};
var ImportExpression = class {
	constructor(source, attributes) {
		this.type = Syntax.ImportExpression;
		this.source = source;
		this.attributes = attributes;
	}
};
var ImportDeclaration = class {
	constructor(specifiers, source, assertions) {
		this.type = Syntax.ImportDeclaration;
		this.specifiers = specifiers;
		this.source = source;
		this.assertions = assertions;
	}
};
var ImportDefaultSpecifier = class {
	constructor(local) {
		this.type = Syntax.ImportDefaultSpecifier;
		this.local = local;
	}
};
var ImportNamespaceSpecifier = class {
	constructor(local) {
		this.type = Syntax.ImportNamespaceSpecifier;
		this.local = local;
	}
};
var ImportSpecifier = class {
	constructor(local, imported) {
		this.type = Syntax.ImportSpecifier;
		this.local = local;
		this.imported = imported;
	}
};
var LabeledStatement = class {
	constructor(label, body) {
		this.type = Syntax.LabeledStatement;
		this.label = label;
		this.body = body;
	}
};
var Literal = class {
	constructor(value, raw) {
		this.type = Syntax.Literal;
		this.value = value;
		this.raw = raw;
	}
};
var LogicalExpression = class {
	constructor(operator, left, right) {
		this.type = Syntax.LogicalExpression;
		this.operator = operator;
		this.left = left;
		this.right = right;
	}
};
var MemberExpression = class {
	constructor(computed, object, property$2, optional) {
		this.type = Syntax.MemberExpression;
		this.computed = computed;
		this.object = object;
		this.property = property$2;
		this.optional = optional;
	}
};
var MetaProperty = class {
	constructor(meta, property$2) {
		this.type = Syntax.MetaProperty;
		this.meta = meta;
		this.property = property$2;
	}
};
var MethodDefinition = class {
	constructor(key, computed, value, kind, isStatic, decorators) {
		this.type = Syntax.MethodDefinition;
		this.key = key;
		this.computed = computed;
		this.value = value;
		this.kind = kind;
		this.static = isStatic;
		this.decorators = decorators;
	}
};
var Module = class {
	constructor(body) {
		this.type = Syntax.Program;
		this.body = body;
		this.sourceType = "module";
	}
};
var NewExpression = class {
	constructor(callee, args) {
		this.type = Syntax.NewExpression;
		this.callee = callee;
		this.arguments = args;
	}
};
var ObjectExpression = class {
	constructor(properties) {
		this.type = Syntax.ObjectExpression;
		this.properties = properties;
	}
};
var ObjectPattern = class {
	constructor(properties) {
		this.type = Syntax.ObjectPattern;
		this.properties = properties;
	}
};
var PrivateIdentifier = class {
	constructor(name) {
		this.type = Syntax.PrivateIdentifier;
		this.name = name;
	}
};
var Property = class {
	constructor(kind, key, computed, value, method$1, shorthand) {
		this.type = Syntax.Property;
		this.key = key;
		this.computed = computed;
		this.value = value;
		this.kind = kind;
		this.method = method$1;
		this.shorthand = shorthand;
	}
};
var PropertyDefinition = class {
	constructor(key, computed, value, isStatic, decorators) {
		this.type = Syntax.Property;
		this.key = key;
		this.computed = computed;
		this.value = value;
		this.static = isStatic;
		this.decorators = decorators;
	}
};
var RegexLiteral = class {
	constructor(value, raw, pattern, flags) {
		this.type = Syntax.Literal;
		this.value = value;
		this.raw = raw;
		this.regex = {
			pattern,
			flags
		};
	}
};
var RestElement = class {
	constructor(argument) {
		this.type = Syntax.RestElement;
		this.argument = argument;
	}
};
var ReturnStatement$1 = class {
	constructor(argument) {
		this.type = Syntax.ReturnStatement;
		this.argument = argument;
	}
};
var Script = class {
	constructor(body) {
		this.type = Syntax.Program;
		this.body = body;
		this.sourceType = "script";
	}
};
var SequenceExpression = class {
	constructor(expressions) {
		this.type = Syntax.SequenceExpression;
		this.expressions = expressions;
	}
};
var SpreadElement = class {
	constructor(argument) {
		this.type = Syntax.SpreadElement;
		this.argument = argument;
	}
};
var StaticBlock = class {
	constructor(body) {
		this.type = Syntax.StaticBlock;
		this.body = body;
	}
};
var Super = class {
	constructor() {
		this.type = Syntax.Super;
	}
};
var SwitchCase = class {
	constructor(test, consequent) {
		this.type = Syntax.SwitchCase;
		this.test = test;
		this.consequent = consequent;
	}
};
var SwitchStatement = class {
	constructor(discriminant, cases) {
		this.type = Syntax.SwitchStatement;
		this.discriminant = discriminant;
		this.cases = cases;
	}
};
var TaggedTemplateExpression = class {
	constructor(tag, quasi) {
		this.type = Syntax.TaggedTemplateExpression;
		this.tag = tag;
		this.quasi = quasi;
	}
};
var TemplateElement = class {
	constructor(value, tail) {
		this.type = Syntax.TemplateElement;
		this.value = value;
		this.tail = tail;
	}
};
var TemplateLiteral = class {
	constructor(quasis, expressions) {
		this.type = Syntax.TemplateLiteral;
		this.quasis = quasis;
		this.expressions = expressions;
	}
};
var ThisExpression = class {
	constructor() {
		this.type = Syntax.ThisExpression;
	}
};
var ThrowStatement = class {
	constructor(argument) {
		this.type = Syntax.ThrowStatement;
		this.argument = argument;
	}
};
var TryStatement = class {
	constructor(block, handler, finalizer) {
		this.type = Syntax.TryStatement;
		this.block = block;
		this.handler = handler;
		this.finalizer = finalizer;
	}
};
var UnaryExpression = class {
	constructor(operator, argument) {
		this.type = Syntax.UnaryExpression;
		this.operator = operator;
		this.argument = argument;
		this.prefix = true;
	}
};
var UpdateExpression = class {
	constructor(operator, argument, prefix) {
		this.type = Syntax.UpdateExpression;
		this.operator = operator;
		this.argument = argument;
		this.prefix = prefix;
	}
};
var VariableDeclaration = class {
	constructor(declarations, kind) {
		this.type = Syntax.VariableDeclaration;
		this.declarations = declarations;
		this.kind = kind;
	}
};
var VariableDeclarator = class {
	constructor(id, init) {
		this.type = Syntax.VariableDeclarator;
		this.id = id;
		this.init = init;
	}
};
var WhileStatement = class {
	constructor(test, body) {
		this.type = Syntax.WhileStatement;
		this.test = test;
		this.body = body;
	}
};
var WithStatement = class {
	constructor(object, body) {
		this.type = Syntax.WithStatement;
		this.object = object;
		this.body = body;
	}
};
var YieldExpression = class {
	constructor(argument, delegate) {
		this.type = Syntax.YieldExpression;
		this.argument = argument;
		this.delegate = delegate;
	}
};
function assert$3(condition, message) {
	/* istanbul ignore if */
	if (!condition) throw new Error("ASSERT: " + message);
}
var ErrorHandler = class {
	constructor() {
		this.errors = [];
		this.tolerant = false;
	}
	recordError(error$1) {
		this.errors.push(error$1);
	}
	tolerate(error$1) {
		if (this.tolerant) this.recordError(error$1);
		else throw error$1;
	}
	constructError(msg, column) {
		let error$1 = new Error(msg);
		try {
			throw error$1;
		} catch (base) {
			/* istanbul ignore else */
			if (Object.create && Object.defineProperty) {
				error$1 = Object.create(base);
				Object.defineProperty(error$1, "column", { value: column });
			}
		}
		/* istanbul ignore next */
		return error$1;
	}
	createError(index, line, col, description) {
		const msg = "Line " + line + ": " + description;
		const _error = this.constructError(msg, col);
		_error.index = index;
		_error.lineNumber = line;
		_error.description = description;
		return _error;
	}
	throwError(index, line, col, description) {
		throw this.createError(index, line, col, description);
	}
	tolerateError(index, line, col, description) {
		const error$1 = this.createError(index, line, col, description);
		if (this.tolerant) this.recordError(error$1);
		else throw error$1;
	}
};
var Messages = {
	AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
	BadImportCallArity: "Unexpected token",
	BadGetterArity: "Getter must not have any formal parameters",
	BadSetterArity: "Setter must have exactly one formal parameter",
	BadSetterRestParameter: "Setter function argument must not be a rest parameter",
	CannotUseImportMetaOutsideAModule: "Cannot use 'import.meta' outside a module",
	ConstructorIsAsync: "Class constructor may not be an async method",
	ConstructorIsPrivate: "Class constructor may not be a private method",
	ConstructorSpecialMethod: "Class constructor may not be an accessor",
	DeclarationMissingInitializer: "Missing initializer in %0 declaration",
	DefaultRestParameter: "Unexpected token =",
	DefaultRestProperty: "Unexpected token =",
	DuplicateBinding: "Duplicate binding %0",
	DuplicateConstructor: "A class may only have one constructor",
	DuplicateParameter: "Duplicate parameter name not allowed in this context",
	DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
	ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
	GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
	IllegalBreak: "Illegal break statement",
	IllegalContinue: "Illegal continue statement",
	IllegalExportDeclaration: "Unexpected token",
	IllegalImportDeclaration: "Unexpected token",
	IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
	IllegalReturn: "Illegal return statement",
	InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
	InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
	InvalidLHSInAssignment: "Invalid left-hand side in assignment",
	InvalidLHSInForIn: "Invalid left-hand side in for-in",
	InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
	InvalidModuleSpecifier: "Unexpected token",
	InvalidRegExp: "Invalid regular expression",
	InvalidTaggedTemplateOnOptionalChain: "Invalid tagged template on optional chain",
	InvalidUnicodeEscapeSequence: "Invalid Unicode escape sequence",
	LetInLexicalBinding: "let is disallowed as a lexically bound name",
	MissingFromClause: "Unexpected token",
	MultipleDefaultsInSwitch: "More than one default clause in switch statement",
	NewlineAfterThrow: "Illegal newline after throw",
	NoAsAfterImportNamespace: "Unexpected token",
	NoAsAndFromEscapeSequences: "The `as` and `from` contextual keywords must not contain Unicode escape sequences.",
	NoCatchOrFinally: "Missing catch or finally after try",
	NoSemicolonAfterDecorator: "Decorators must not be followed by a semicolon.",
	NumericSeperatorOneUnderscore: "Numeric separator must be exactly one underscore",
	NumericSeperatorNotAllowedHere: "Numeric separator is not allowed here",
	ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
	PropertyAfterRestProperty: "Unexpected token",
	Redeclaration: "%0 '%1' has already been declared",
	StaticPrototype: "Classes may not have static property named prototype",
	StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
	StrictDelete: "Delete of an unqualified identifier in strict mode.",
	StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
	StrictFunctionName: "Function name may not be eval or arguments in strict mode",
	StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
	StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
	StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
	StrictModeWith: "Strict mode code may not include a with statement",
	StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
	StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
	StrictReservedWord: "Use of future reserved word in strict mode",
	StrictVarName: "Variable name may not be eval or arguments in strict mode",
	TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
	TemplateEscape89: "\\8 and \\9 are not allowed in template strings.",
	UnexpectedEOS: "Unexpected end of input",
	UnexpectedIdentifier: "Unexpected identifier",
	UnexpectedNumber: "Unexpected number",
	UnexpectedReserved: "Unexpected reserved word",
	UnexpectedString: "Unexpected string",
	UnexpectedSuper: "'super' keyword unexpected here",
	UnexpectedTemplate: "Unexpected quasi %0",
	UnexpectedToken: "Unexpected token %0",
	UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
	UnknownLabel: "Undefined label '%0'",
	UnterminatedRegExp: "Invalid regular expression: missing /"
};
function hexValue(ch) {
	return "0123456789abcdef".indexOf(ch.toLowerCase());
}
function octalValue(ch) {
	return "01234567".indexOf(ch);
}
var Scanner = class {
	constructor(code$1, handler) {
		this.source = code$1;
		this.errorHandler = handler;
		this.trackComment = false;
		this.isModule = false;
		this.length = code$1.length;
		this.index = 0;
		this.lineNumber = code$1.length > 0 ? 1 : 0;
		this.lineStart = 0;
		this.curlyStack = [];
	}
	saveState() {
		return {
			index: this.index,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			curlyStack: this.curlyStack.slice()
		};
	}
	restoreState(state) {
		this.index = state.index;
		this.lineNumber = state.lineNumber;
		this.lineStart = state.lineStart;
		this.curlyStack = state.curlyStack;
	}
	eof() {
		return this.index >= this.length;
	}
	throwUnexpectedToken(message = Messages.UnexpectedTokenIllegal) {
		return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	}
	tolerateUnexpectedToken(message = Messages.UnexpectedTokenIllegal) {
		this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	}
	skipSingleLineComment(offset$1) {
		let comments = [];
		let start, loc;
		if (this.trackComment) {
			comments = [];
			start = this.index - offset$1;
			loc = {
				start: {
					line: this.lineNumber,
					column: this.index - this.lineStart - offset$1
				},
				end: {}
			};
		}
		while (!this.eof()) {
			const ch = this.source.charCodeAt(this.index);
			++this.index;
			if (Character.isLineTerminator(ch)) {
				if (this.trackComment) {
					loc.end = {
						line: this.lineNumber,
						column: this.index - this.lineStart - 1
					};
					const entry = {
						multiLine: false,
						slice: [start + offset$1, this.index - 1],
						range: [start, this.index - 1],
						loc
					};
					comments.push(entry);
				}
				if (ch === 13 && this.source.charCodeAt(this.index) === 10) ++this.index;
				++this.lineNumber;
				this.lineStart = this.index;
				return comments;
			}
		}
		if (this.trackComment) {
			loc.end = {
				line: this.lineNumber,
				column: this.index - this.lineStart
			};
			const entry = {
				multiLine: false,
				slice: [start + offset$1, this.index],
				range: [start, this.index],
				loc
			};
			comments.push(entry);
		}
		return comments;
	}
	skipMultiLineComment() {
		let comments = [];
		let start, loc;
		if (this.trackComment) {
			comments = [];
			start = this.index - 2;
			loc = {
				start: {
					line: this.lineNumber,
					column: this.index - this.lineStart - 2
				},
				end: {}
			};
		}
		while (!this.eof()) {
			const ch = this.source.charCodeAt(this.index);
			if (Character.isLineTerminator(ch)) {
				if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) ++this.index;
				++this.lineNumber;
				++this.index;
				this.lineStart = this.index;
			} else if (ch === 42) {
				if (this.source.charCodeAt(this.index + 1) === 47) {
					this.index += 2;
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						const entry = {
							multiLine: true,
							slice: [start + 2, this.index - 2],
							range: [start, this.index],
							loc
						};
						comments.push(entry);
					}
					return comments;
				}
				++this.index;
			} else ++this.index;
		}
		if (this.trackComment) {
			loc.end = {
				line: this.lineNumber,
				column: this.index - this.lineStart
			};
			const entry = {
				multiLine: true,
				slice: [start + 2, this.index],
				range: [start, this.index],
				loc
			};
			comments.push(entry);
		}
		this.tolerateUnexpectedToken();
		return comments;
	}
	scanComments() {
		let comments;
		if (this.trackComment) comments = [];
		let start = this.index === 0;
		while (!this.eof()) {
			let ch = this.source.charCodeAt(this.index);
			if (Character.isWhiteSpace(ch)) ++this.index;
			else if (Character.isLineTerminator(ch)) {
				++this.index;
				if (ch === 13 && this.source.charCodeAt(this.index) === 10) ++this.index;
				++this.lineNumber;
				this.lineStart = this.index;
				start = true;
			} else if (ch === 47) {
				ch = this.source.charCodeAt(this.index + 1);
				if (ch === 47) {
					this.index += 2;
					const comment = this.skipSingleLineComment(2);
					if (this.trackComment) comments = comments.concat(comment);
					start = true;
				} else if (ch === 42) {
					this.index += 2;
					const comment = this.skipMultiLineComment();
					if (this.trackComment) comments = comments.concat(comment);
				} else break;
			} else if (start && ch === 45) if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
				this.index += 3;
				const comment = this.skipSingleLineComment(3);
				if (this.trackComment) comments = comments.concat(comment);
			} else break;
			else if (ch === 60 && !this.isModule) if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
				this.index += 4;
				const comment = this.skipSingleLineComment(4);
				if (this.trackComment) comments = comments.concat(comment);
			} else break;
			else break;
		}
		return comments;
	}
	isFutureReservedWord(id) {
		switch (id) {
			case "enum":
			case "export":
			case "import":
			case "super": return true;
			default: return false;
		}
	}
	isStrictModeReservedWord(id) {
		switch (id) {
			case "implements":
			case "interface":
			case "package":
			case "private":
			case "protected":
			case "public":
			case "static":
			case "yield":
			case "let": return true;
			default: return false;
		}
	}
	isRestrictedWord(id) {
		return id === "eval" || id === "arguments";
	}
	isKeyword(id) {
		switch (id.length) {
			case 2: return id === "if" || id === "in" || id === "do";
			case 3: return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
			case 4: return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
			case 5: return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
			case 6: return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
			case 7: return id === "default" || id === "finally" || id === "extends";
			case 8: return id === "function" || id === "continue" || id === "debugger";
			case 10: return id === "instanceof";
			default: return false;
		}
	}
	codePointAt(i$2) {
		let cp = this.source.charCodeAt(i$2);
		if (cp >= 55296 && cp <= 56319) {
			const second = this.source.charCodeAt(i$2 + 1);
			if (second >= 56320 && second <= 57343) cp = (cp - 55296) * 1024 + second - 56320 + 65536;
		}
		return cp;
	}
	scanHexEscape(prefix) {
		const len$1 = prefix === "u" ? 4 : 2;
		let code$1 = 0;
		for (let i$2 = 0; i$2 < len$1; ++i$2) if (!this.eof() && Character.isHexDigit(this.source.charCodeAt(this.index))) code$1 = code$1 * 16 + hexValue(this.source[this.index++]);
		else return null;
		return String.fromCharCode(code$1);
	}
	tryToScanUnicodeCodePointEscape() {
		let ch = this.source[this.index];
		let code$1 = 0;
		if (ch === "}") return null;
		while (!this.eof()) {
			ch = this.source[this.index++];
			if (!Character.isHexDigit(ch.charCodeAt(0))) break;
			code$1 = code$1 * 16 + hexValue(ch);
		}
		if (code$1 > 1114111 || ch !== "}") return null;
		return Character.fromCodePoint(code$1);
	}
	scanUnicodeCodePointEscape() {
		const result = this.tryToScanUnicodeCodePointEscape();
		if (result === null) return this.throwUnexpectedToken();
		return result;
	}
	getIdentifier() {
		const start = this.index++;
		while (!this.eof()) {
			const ch = this.source.charCodeAt(this.index);
			if (ch === 92) {
				this.index = start;
				return this.getComplexIdentifier();
			} else if (ch >= 55296 && ch < 57343) {
				this.index = start;
				return this.getComplexIdentifier();
			}
			if (Character.isIdentifierPart(ch)) ++this.index;
			else break;
		}
		return this.source.slice(start, this.index);
	}
	getComplexIdentifier() {
		let cp = this.codePointAt(this.index);
		let id = Character.fromCodePoint(cp);
		this.index += id.length;
		let ch;
		if (cp === 92) {
			if (this.source.charCodeAt(this.index) !== 117) this.throwUnexpectedToken();
			++this.index;
			if (this.source[this.index] === "{") {
				++this.index;
				ch = this.scanUnicodeCodePointEscape();
			} else {
				ch = this.scanHexEscape("u");
				if (ch === null || ch === "\\" || !Character.isIdentifierStart(ch.charCodeAt(0))) this.throwUnexpectedToken();
			}
			id = ch;
		}
		while (!this.eof()) {
			cp = this.codePointAt(this.index);
			if (!Character.isIdentifierPart(cp)) break;
			ch = Character.fromCodePoint(cp);
			id += ch;
			this.index += ch.length;
			if (cp === 92) {
				id = id.substr(0, id.length - 1);
				if (this.source.charCodeAt(this.index) !== 117) this.throwUnexpectedToken();
				++this.index;
				if (this.source[this.index] === "{") {
					++this.index;
					ch = this.scanUnicodeCodePointEscape();
				} else {
					ch = this.scanHexEscape("u");
					if (ch === null || ch === "\\" || !Character.isIdentifierPart(ch.charCodeAt(0))) this.throwUnexpectedToken();
				}
				id += ch;
			}
		}
		return id;
	}
	octalToDecimal(ch) {
		let octal = ch !== "0";
		let code$1 = octalValue(ch);
		if (!this.eof() && Character.isOctalDigit(this.source.charCodeAt(this.index))) {
			octal = true;
			code$1 = code$1 * 8 + octalValue(this.source[this.index++]);
			if ("0123".indexOf(ch) >= 0 && !this.eof() && Character.isOctalDigit(this.source.charCodeAt(this.index))) code$1 = code$1 * 8 + octalValue(this.source[this.index++]);
		}
		return {
			code: code$1,
			octal
		};
	}
	scanIdentifier() {
		let type;
		const start = this.index;
		const escaped = this.source.charCodeAt(start) === 92;
		const id = escaped ? this.getComplexIdentifier() : this.getIdentifier();
		if (id.length === 1) type = 3;
		else if (this.isKeyword(id)) type = 4;
		else if (id === "null") type = 5;
		else if (id === "true" || id === "false") type = 1;
		else type = 3;
		if (type !== 3 && start + id.length !== this.index) {
			const restore = this.index;
			this.index = start;
			this.tolerateUnexpectedToken(Messages.InvalidEscapedReservedWord);
			this.index = restore;
		}
		return {
			type,
			value: id,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index,
			escaped
		};
	}
	scanPunctuator() {
		const start = this.index;
		let str = this.source[this.index];
		switch (str) {
			case "(":
			case "{":
				if (str === "{") this.curlyStack.push("{");
				++this.index;
				break;
			case ".":
				++this.index;
				if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
					this.index += 2;
					str = "...";
				}
				break;
			case "}":
				++this.index;
				this.curlyStack.pop();
				break;
			case "?":
				++this.index;
				if (this.source[this.index] === "?") {
					++this.index;
					if (this.source[this.index] === "=") {
						++this.index;
						str = "??=";
					} else str = "??";
				}
				if (this.source[this.index] === "." && !/^\d$/.test(this.source[this.index + 1])) {
					++this.index;
					str = "?.";
				}
				break;
			case "#":
			case ")":
			case ";":
			case ",":
			case "[":
			case "]":
			case ":":
			case "~":
			case "@":
				++this.index;
				break;
			default:
				str = this.source.substr(this.index, 4);
				if (str === ">>>=") this.index += 4;
				else {
					str = str.substr(0, 3);
					if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=" || str === "&&=" || str === "||=") this.index += 3;
					else {
						str = str.substr(0, 2);
						if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") this.index += 2;
						else {
							str = this.source[this.index];
							if ("<>=!+-*%&|^/".indexOf(str) >= 0) ++this.index;
						}
					}
				}
		}
		if (this.index === start) this.throwUnexpectedToken();
		return {
			type: 7,
			value: str,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	scanHexLiteral(start) {
		let num = this.scanLiteralPart(Character.isHexDigitChar);
		if (num.length === 0) this.throwUnexpectedToken();
		if (this.source[this.index] === "n") {
			this.index++;
			return {
				type: 6,
				value: BigInt("0x" + num),
				lineNumber: this.lineNumber,
				lineStart: this.lineStart,
				start,
				end: this.index
			};
		}
		if (Character.isIdentifierStart(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
		return {
			type: 6,
			value: parseInt("0x" + num, 16),
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	scanBinaryLiteral(start) {
		let ch;
		let num = this.scanLiteralPart((c$1) => c$1 === "0" || c$1 === "1");
		if (num.length === 0) this.throwUnexpectedToken();
		if (this.source[this.index] === "n") {
			this.index++;
			return {
				type: 6,
				value: BigInt("0b" + num),
				lineNumber: this.lineNumber,
				lineStart: this.lineStart,
				start,
				end: this.index
			};
		}
		if (!this.eof()) {
			ch = this.source.charCodeAt(this.index);
			/* istanbul ignore else */
			if (Character.isIdentifierStart(ch) || Character.isDecimalDigit(ch)) this.throwUnexpectedToken();
		}
		return {
			type: 6,
			value: parseInt(num, 2),
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	scanOctalLiteral(prefix, start) {
		let num = "";
		let octal = false;
		if (Character.isOctalDigit(prefix.charCodeAt(0))) {
			octal = true;
			num = "0" + this.source[this.index++];
		} else ++this.index;
		num += this.scanLiteralPart(Character.isOctalDigitChar);
		if (!octal && num.length === 0) this.throwUnexpectedToken();
		if (this.source[this.index] === "n") {
			this.index++;
			return {
				type: 6,
				value: BigInt("0o" + num),
				lineNumber: this.lineNumber,
				lineStart: this.lineStart,
				start,
				end: this.index
			};
		}
		if (Character.isIdentifierStart(this.source.charCodeAt(this.index)) || Character.isDecimalDigit(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
		return {
			type: 6,
			value: parseInt(num, 8),
			octal,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	isImplicitOctalLiteral() {
		for (let i$2 = this.index + 1; i$2 < this.length; ++i$2) {
			const ch = this.source[i$2];
			if (ch === "8" || ch === "9" || ch === "n") return false;
			if (!Character.isOctalDigit(ch.charCodeAt(0))) return true;
		}
		return true;
	}
	scanLiteralPart(check) {
		let num = "";
		if (this.source[this.index] === "_") this.throwUnexpectedToken(Messages.NumericSeperatorNotAllowedHere);
		while (this.source[this.index] && (check(this.source[this.index]) || this.source[this.index] === "_")) {
			if (this.source[this.index] !== "_") num += this.source[this.index];
			this.index++;
			if (this.source[this.index - 1] === "_" && this.source[this.index] === "_") this.throwUnexpectedToken(Messages.NumericSeperatorOneUnderscore);
		}
		if (this.source[this.index - 1] === "_") this.throwUnexpectedToken(Messages.NumericSeperatorNotAllowedHere);
		return num;
	}
	scanNumericLiteral() {
		const start = this.index;
		let ch = this.source[start];
		assert$3(Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
		let num = "";
		if (ch !== ".") {
			num = this.source[this.index++];
			ch = this.source[this.index];
			if (num === "0") {
				if (ch === "x" || ch === "X") {
					++this.index;
					return this.scanHexLiteral(start);
				}
				if (ch === "b" || ch === "B") {
					++this.index;
					return this.scanBinaryLiteral(start);
				}
				if (ch === "o" || ch === "O") return this.scanOctalLiteral(ch, start);
				if (ch && Character.isOctalDigit(ch.charCodeAt(0))) {
					if (this.isImplicitOctalLiteral()) return this.scanOctalLiteral(ch, start);
				}
			}
			this.index--;
			num = this.scanLiteralPart(Character.isDecimalDigitChar);
			ch = this.source[this.index];
		}
		if (ch === ".") {
			num += this.source[this.index++];
			num += this.scanLiteralPart(Character.isDecimalDigitChar);
			ch = this.source[this.index];
		}
		if (ch === "e" || ch === "E") {
			num += this.source[this.index++];
			ch = this.source[this.index];
			if (ch === "+" || ch === "-") num += this.source[this.index++];
			if (Character.isDecimalDigit(this.source.charCodeAt(this.index))) num += this.scanLiteralPart(Character.isDecimalDigitChar);
			else this.throwUnexpectedToken();
		} else if (ch === "n") {
			if (num.length > 1 && num[0] === "0") this.throwUnexpectedToken();
			this.index++;
			return {
				type: 6,
				value: BigInt(num),
				lineNumber: this.lineNumber,
				lineStart: this.lineStart,
				start,
				end: this.index
			};
		}
		if (Character.isIdentifierStart(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
		return {
			type: 6,
			value: parseFloat(num),
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	scanStringLiteral() {
		const start = this.index;
		let quote$1 = this.source[start];
		assert$3(quote$1 === "'" || quote$1 === "\"", "String literal must starts with a quote");
		++this.index;
		let octal = false;
		let str = "";
		while (!this.eof()) {
			let ch = this.source[this.index++];
			if (ch === quote$1) {
				quote$1 = "";
				break;
			} else if (ch === "\\") {
				ch = this.source[this.index++];
				if (!ch || !Character.isLineTerminator(ch.charCodeAt(0))) switch (ch) {
					case "u":
						if (this.source[this.index] === "{") {
							++this.index;
							str += this.scanUnicodeCodePointEscape();
						} else {
							const unescapedChar = this.scanHexEscape(ch);
							if (unescapedChar === null) this.throwUnexpectedToken();
							str += unescapedChar;
						}
						break;
					case "x":
						const unescaped = this.scanHexEscape(ch);
						if (unescaped === null) this.throwUnexpectedToken(Messages.InvalidHexEscapeSequence);
						str += unescaped;
						break;
					case "n":
						str += "\n";
						break;
					case "r":
						str += "\r";
						break;
					case "t":
						str += "	";
						break;
					case "b":
						str += "\b";
						break;
					case "f":
						str += "\f";
						break;
					case "v":
						str += "\v";
						break;
					case "8":
					case "9":
						str += ch;
						this.tolerateUnexpectedToken();
						break;
					default:
						if (ch && Character.isOctalDigit(ch.charCodeAt(0))) {
							const octToDec = this.octalToDecimal(ch);
							octal = octToDec.octal || octal;
							str += String.fromCharCode(octToDec.code);
						} else str += ch;
						break;
				}
				else {
					++this.lineNumber;
					if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
					this.lineStart = this.index;
				}
			} else if (Character.isLineTerminator(ch.charCodeAt(0))) break;
			else str += ch;
		}
		if (quote$1 !== "") {
			this.index = start;
			this.throwUnexpectedToken();
		}
		return {
			type: 8,
			value: str,
			octal,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	scanTemplate() {
		let cooked = "";
		let terminated = false;
		const start = this.index;
		const head = this.source[start] === "`";
		let tail = false;
		let notEscapeSequenceHead = null;
		let rawOffset = 2;
		++this.index;
		while (!this.eof()) {
			let ch = this.source[this.index++];
			if (ch === "`") {
				rawOffset = 1;
				tail = true;
				terminated = true;
				break;
			} else if (ch === "$") {
				if (this.source[this.index] === "{") {
					this.curlyStack.push("${");
					++this.index;
					terminated = true;
					break;
				}
				cooked += ch;
			} else if (notEscapeSequenceHead !== null) continue;
			else if (ch === "\\") {
				ch = this.source[this.index++];
				if (!Character.isLineTerminator(ch.charCodeAt(0))) switch (ch) {
					case "n":
						cooked += "\n";
						break;
					case "r":
						cooked += "\r";
						break;
					case "t":
						cooked += "	";
						break;
					case "u":
						if (this.source[this.index] === "{") {
							++this.index;
							const unicodeCodePointEscape = this.tryToScanUnicodeCodePointEscape();
							if (unicodeCodePointEscape === null) notEscapeSequenceHead = "u";
							else cooked += unicodeCodePointEscape;
						} else {
							const unescapedChar = this.scanHexEscape(ch);
							if (unescapedChar === null) notEscapeSequenceHead = "u";
							else cooked += unescapedChar;
						}
						break;
					case "x":
						const unescaped = this.scanHexEscape(ch);
						if (unescaped === null) notEscapeSequenceHead = "x";
						else cooked += unescaped;
						break;
					case "b":
						cooked += "\b";
						break;
					case "f":
						cooked += "\f";
						break;
					case "v":
						cooked += "\v";
						break;
					default:
						if (ch === "0") if (Character.isDecimalDigit(this.source.charCodeAt(this.index))) notEscapeSequenceHead = "0";
						else cooked += "\0";
						else if (Character.isDecimalDigitChar(ch)) notEscapeSequenceHead = ch;
						else cooked += ch;
						break;
				}
				else {
					++this.lineNumber;
					if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
					this.lineStart = this.index;
				}
			} else if (Character.isLineTerminator(ch.charCodeAt(0))) {
				++this.lineNumber;
				if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
				this.lineStart = this.index;
				cooked += "\n";
			} else cooked += ch;
		}
		if (!terminated) this.throwUnexpectedToken();
		if (!head) this.curlyStack.pop();
		return {
			type: 10,
			value: this.source.slice(start + 1, this.index - rawOffset),
			cooked: notEscapeSequenceHead === null ? cooked : null,
			head,
			tail,
			notEscapeSequenceHead,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	testRegExp(pattern, flags) {
		const astralSubstitute = "￿";
		let tmp = pattern;
		if (flags.indexOf("u") >= 0) tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, ($0, $1, $2) => {
			const codePoint = parseInt($1 || $2, 16);
			if (codePoint > 1114111) this.throwUnexpectedToken(Messages.InvalidRegExp);
			if (codePoint <= 65535) return String.fromCharCode(codePoint);
			return astralSubstitute;
		}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
		try {
			return new RegExp(pattern, flags);
		} catch (exception) {
			/* istanbul ignore next */
			return null;
		}
	}
	scanRegExpBody() {
		let ch = this.source[this.index];
		assert$3(ch === "/", "Regular expression literal must start with a slash");
		let str = this.source[this.index++];
		let classMarker = false;
		let terminated = false;
		while (!this.eof()) {
			ch = this.source[this.index++];
			str += ch;
			if (ch === "\\") {
				ch = this.source[this.index++];
				if (Character.isLineTerminator(ch.charCodeAt(0))) this.throwUnexpectedToken(Messages.UnterminatedRegExp);
				str += ch;
			} else if (Character.isLineTerminator(ch.charCodeAt(0))) this.throwUnexpectedToken(Messages.UnterminatedRegExp);
			else if (classMarker) {
				if (ch === "]") classMarker = false;
			} else if (ch === "/") {
				terminated = true;
				break;
			} else if (ch === "[") classMarker = true;
		}
		if (!terminated) this.throwUnexpectedToken(Messages.UnterminatedRegExp);
		return str.substr(1, str.length - 2);
	}
	scanRegExpFlags() {
		let str = "";
		let flags = "";
		while (!this.eof()) {
			let ch = this.source[this.index];
			if (!Character.isIdentifierPart(ch.charCodeAt(0))) break;
			++this.index;
			if (ch === "\\" && !this.eof()) {
				ch = this.source[this.index];
				if (ch === "u") {
					++this.index;
					let restore = this.index;
					const char = this.scanHexEscape("u");
					if (char !== null) {
						flags += char;
						for (str += "\\u"; restore < this.index; ++restore) str += this.source[restore];
					} else {
						this.index = restore;
						flags += "u";
						str += "\\u";
					}
					this.tolerateUnexpectedToken();
				} else {
					str += "\\";
					this.tolerateUnexpectedToken();
				}
			} else {
				flags += ch;
				str += ch;
			}
		}
		return flags;
	}
	scanRegExp() {
		const start = this.index;
		const pattern = this.scanRegExpBody();
		const flags = this.scanRegExpFlags();
		return {
			type: 9,
			value: "",
			pattern,
			flags,
			regex: this.testRegExp(pattern, flags),
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start,
			end: this.index
		};
	}
	lex() {
		if (this.eof()) return {
			type: 2,
			value: "",
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start: this.index,
			end: this.index
		};
		const cp = this.source.charCodeAt(this.index);
		if (Character.isIdentifierStart(cp)) return this.scanIdentifier();
		if (cp === 40 || cp === 41 || cp === 59) return this.scanPunctuator();
		if (cp === 39 || cp === 34) return this.scanStringLiteral();
		if (cp === 46) {
			if (Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) return this.scanNumericLiteral();
			return this.scanPunctuator();
		}
		if (Character.isDecimalDigit(cp)) return this.scanNumericLiteral();
		if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") return this.scanTemplate();
		if (cp >= 55296 && cp < 57343) {
			if (Character.isIdentifierStart(this.codePointAt(this.index))) return this.scanIdentifier();
		}
		return this.scanPunctuator();
	}
};
var TokenName = {};
TokenName[1] = "Boolean";
TokenName[2] = "<end>";
TokenName[3] = "Identifier";
TokenName[4] = "Keyword";
TokenName[5] = "Null";
TokenName[6] = "Numeric";
TokenName[7] = "Punctuator";
TokenName[8] = "String";
TokenName[9] = "RegularExpression";
TokenName[10] = "Template";
var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
var Parser = class {
	constructor(code$1, options = {}, delegate) {
		this.config = {
			range: typeof options.range === "boolean" && options.range,
			loc: typeof options.loc === "boolean" && options.loc,
			source: null,
			tokens: typeof options.tokens === "boolean" && options.tokens,
			comment: typeof options.comment === "boolean" && options.comment,
			tolerant: typeof options.tolerant === "boolean" && options.tolerant
		};
		if (this.config.loc && options.source && options.source !== null) this.config.source = String(options.source);
		this.delegate = delegate;
		this.errorHandler = new ErrorHandler();
		this.errorHandler.tolerant = this.config.tolerant == true;
		this.scanner = new Scanner(code$1, this.errorHandler);
		this.scanner.trackComment = this.config.comment == true;
		this.operatorPrecedence = {
			")": 0,
			";": 0,
			",": 0,
			"=": 0,
			"]": 0,
			"??": 5,
			"||": 6,
			"&&": 7,
			"|": 8,
			"^": 9,
			"&": 10,
			"==": 11,
			"!=": 11,
			"===": 11,
			"!==": 11,
			"<": 12,
			">": 12,
			"<=": 12,
			">=": 12,
			"<<": 13,
			">>": 13,
			">>>": 13,
			"+": 14,
			"-": 14,
			"*": 15,
			"/": 15,
			"%": 15
		};
		this.lookahead = {
			type: 2,
			value: "",
			lineNumber: this.scanner.lineNumber,
			lineStart: 0,
			start: 0,
			end: 0
		};
		this.hasLineTerminator = false;
		this.context = {
			isModule: false,
			isAsync: false,
			allowIn: true,
			allowStrictDirective: true,
			allowSuper: false,
			allowYield: true,
			firstCoverInitializedNameError: null,
			isAssignmentTarget: false,
			isBindingElement: false,
			inConstructor: false,
			inFunctionBody: false,
			inIteration: false,
			inSwitch: false,
			inClassConstructor: false,
			labelSet: {},
			strict: false,
			decorators: null
		};
		this.tokens = [];
		this.startMarker = {
			index: 0,
			line: this.scanner.lineNumber,
			column: 0
		};
		this.lastMarker = {
			index: 0,
			line: this.scanner.lineNumber,
			column: 0
		};
		this.nextToken();
		this.lastMarker = {
			index: this.scanner.index,
			line: this.scanner.lineNumber,
			column: this.scanner.index - this.scanner.lineStart
		};
	}
	throwError(messageFormat, ...values$1) {
		const args = values$1.slice();
		const msg = messageFormat.replace(/%(\d)/g, (whole, idx) => {
			assert$3(idx < args.length, "Message reference must be in range");
			return args[idx];
		});
		const index = this.lastMarker.index;
		const line = this.lastMarker.line;
		const column = this.lastMarker.column + 1;
		throw this.errorHandler.createError(index, line, column, msg);
	}
	tolerateError(messageFormat, ...values$1) {
		const args = values$1.slice();
		const msg = messageFormat.replace(/%(\d)/g, (whole, idx) => {
			assert$3(idx < args.length, "Message reference must be in range");
			return args[idx];
		});
		const index = this.lastMarker.index;
		const line = this.scanner.lineNumber;
		const column = this.lastMarker.column + 1;
		this.errorHandler.tolerateError(index, line, column, msg);
	}
	unexpectedTokenError(token, message) {
		let msg = message || Messages.UnexpectedToken;
		let value;
		if (token) {
			if (!message) {
				msg = token.type === 2 ? Messages.UnexpectedEOS : token.type === 3 ? Messages.UnexpectedIdentifier : token.type === 6 ? Messages.UnexpectedNumber : token.type === 8 ? Messages.UnexpectedString : token.type === 10 ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;
				if (token.type === 4) {
					if (this.scanner.isFutureReservedWord(token.value)) msg = Messages.UnexpectedReserved;
					else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) msg = Messages.StrictReservedWord;
				}
			}
			value = token.value;
		} else value = "ILLEGAL";
		msg = msg.replace("%0", value);
		if (token && typeof token.lineNumber === "number") {
			const index = token.start;
			const line = token.lineNumber;
			const lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
			const column = token.start - lastMarkerLineStart + 1;
			return this.errorHandler.createError(index, line, column, msg);
		} else {
			const index = this.lastMarker.index;
			const line = this.lastMarker.line;
			const column = this.lastMarker.column + 1;
			return this.errorHandler.createError(index, line, column, msg);
		}
	}
	throwUnexpectedToken(token, message) {
		throw this.unexpectedTokenError(token, message);
	}
	tolerateUnexpectedToken(token, message) {
		this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	}
	tolerateInvalidLoopStatement() {
		if (this.matchKeyword("class") || this.matchKeyword("function")) this.tolerateError(Messages.UnexpectedToken, this.lookahead);
	}
	collectComments() {
		if (!this.config.comment) this.scanner.scanComments();
		else {
			const comments = this.scanner.scanComments();
			if (comments.length > 0 && this.delegate) for (let i$2 = 0; i$2 < comments.length; ++i$2) {
				const e$1 = comments[i$2];
				const node = {
					type: e$1.multiLine ? "BlockComment" : "LineComment",
					value: this.scanner.source.slice(e$1.slice[0], e$1.slice[1])
				};
				if (this.config.range) node.range = e$1.range;
				if (this.config.loc) node.loc = e$1.loc;
				const metadata = {
					start: {
						line: e$1.loc.start.line,
						column: e$1.loc.start.column,
						offset: e$1.range[0]
					},
					end: {
						line: e$1.loc.end.line,
						column: e$1.loc.end.column,
						offset: e$1.range[1]
					}
				};
				this.delegate(node, metadata);
			}
		}
	}
	getTokenRaw(token) {
		return this.scanner.source.slice(token.start, token.end);
	}
	convertToken(token) {
		const t$1 = {
			type: TokenName[token.type],
			value: this.getTokenRaw(token)
		};
		if (this.config.range) t$1.range = [token.start, token.end];
		if (this.config.loc) t$1.loc = {
			start: {
				line: this.startMarker.line,
				column: this.startMarker.column
			},
			end: {
				line: this.scanner.lineNumber,
				column: this.scanner.index - this.scanner.lineStart
			}
		};
		if (token.type === 9) t$1.regex = {
			pattern: token.pattern,
			flags: token.flags
		};
		return t$1;
	}
	nextToken() {
		const token = this.lookahead;
		this.lastMarker.index = this.scanner.index;
		this.lastMarker.line = this.scanner.lineNumber;
		this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
		this.collectComments();
		if (this.scanner.index !== this.startMarker.index) {
			this.startMarker.index = this.scanner.index;
			this.startMarker.line = this.scanner.lineNumber;
			this.startMarker.column = this.scanner.index - this.scanner.lineStart;
		}
		const next = this.scanner.lex();
		this.hasLineTerminator = token.lineNumber !== next.lineNumber;
		if (next && this.context.strict && next.type === 3) {
			if (this.scanner.isStrictModeReservedWord(next.value)) next.type = 4;
		}
		this.lookahead = next;
		if (this.config.tokens && next.type !== 2) this.tokens.push(this.convertToken(next));
		return token;
	}
	nextRegexToken() {
		this.collectComments();
		const token = this.scanner.scanRegExp();
		if (this.config.tokens) {
			this.tokens.pop();
			this.tokens.push(this.convertToken(token));
		}
		this.lookahead = token;
		this.nextToken();
		return token;
	}
	createNode() {
		return {
			index: this.startMarker.index,
			line: this.startMarker.line,
			column: this.startMarker.column
		};
	}
	startNode(token, lastLineStart = 0) {
		let column = token.start - token.lineStart;
		let line = token.lineNumber;
		if (column < 0) {
			column += lastLineStart;
			line--;
		}
		return {
			index: token.start,
			line,
			column
		};
	}
	finalize(marker, node) {
		if (this.config.range) node.range = [marker.index, this.lastMarker.index];
		if (this.config.loc) {
			node.loc = {
				start: {
					line: marker.line,
					column: marker.column
				},
				end: {
					line: this.lastMarker.line,
					column: this.lastMarker.column
				}
			};
			if (this.config.source) node.loc.source = this.config.source;
		}
		if (this.delegate) {
			const metadata = {
				start: {
					line: marker.line,
					column: marker.column,
					offset: marker.index
				},
				end: {
					line: this.lastMarker.line,
					column: this.lastMarker.column,
					offset: this.lastMarker.index
				}
			};
			this.delegate(node, metadata);
		}
		return node;
	}
	expect(value) {
		const token = this.nextToken();
		if (token.type !== 7 || token.value !== value) this.throwUnexpectedToken(token);
	}
	expectCommaSeparator() {
		if (this.config.tolerant) {
			const token = this.lookahead;
			if (token.type === 7 && token.value === ",") this.nextToken();
			else if (token.type === 7 && token.value === ";") {
				this.nextToken();
				this.tolerateUnexpectedToken(token);
			} else this.tolerateUnexpectedToken(token, Messages.UnexpectedToken);
		} else this.expect(",");
	}
	expectKeyword(keyword) {
		const token = this.nextToken();
		if (token.type !== 4 || token.value !== keyword) this.throwUnexpectedToken(token);
	}
	match(value) {
		return this.lookahead.type === 7 && this.lookahead.value === value;
	}
	matchKeyword(keyword) {
		return this.lookahead.type === 4 && this.lookahead.value === keyword;
	}
	matchContextualKeyword(keyword) {
		return this.lookahead.type === 3 && this.lookahead.value === keyword;
	}
	matchAssign() {
		if (this.lookahead.type !== 7) return false;
		const op = this.lookahead.value;
		return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=" || op === "&&=" || op === "||=" || op === "??=";
	}
	isolateCoverGrammar(parseFunction) {
		const previousIsBindingElement = this.context.isBindingElement;
		const previousIsAssignmentTarget = this.context.isAssignmentTarget;
		const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
		this.context.isBindingElement = true;
		this.context.isAssignmentTarget = true;
		this.context.firstCoverInitializedNameError = null;
		const result = parseFunction.call(this);
		if (this.context.firstCoverInitializedNameError !== null) this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
		this.context.isBindingElement = previousIsBindingElement;
		this.context.isAssignmentTarget = previousIsAssignmentTarget;
		this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
		return result;
	}
	inheritCoverGrammar(parseFunction) {
		const previousIsBindingElement = this.context.isBindingElement;
		const previousIsAssignmentTarget = this.context.isAssignmentTarget;
		const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
		this.context.isBindingElement = true;
		this.context.isAssignmentTarget = true;
		this.context.firstCoverInitializedNameError = null;
		const result = parseFunction.call(this);
		this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
		this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
		this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
		return result;
	}
	consumeSemicolon() {
		if (this.match(";")) this.nextToken();
		else if (!this.hasLineTerminator) {
			if (this.lookahead.type !== 2 && !this.match("}")) this.throwUnexpectedToken(this.lookahead);
			this.lastMarker.index = this.startMarker.index;
			this.lastMarker.line = this.startMarker.line;
			this.lastMarker.column = this.startMarker.column;
		}
	}
	parsePrimaryExpression() {
		const node = this.createNode();
		let expr;
		let token, raw;
		switch (this.lookahead.type) {
			case 3:
				if ((this.context.isModule || this.context.isAsync) && this.lookahead.value === "await") this.tolerateUnexpectedToken(this.lookahead);
				expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Identifier(this.nextToken().value));
				break;
			case 6:
			case 8:
				if (this.context.strict && this.lookahead.octal) this.tolerateUnexpectedToken(this.lookahead, Messages.StrictOctalLiteral);
				this.context.isAssignmentTarget = false;
				this.context.isBindingElement = false;
				token = this.nextToken();
				raw = this.getTokenRaw(token);
				if (typeof token.value === "bigint") expr = this.finalize(node, new BigIntLiteral(token.value, raw, token.value.toString()));
				else expr = this.finalize(node, new Literal(token.value, raw));
				break;
			case 1:
				this.context.isAssignmentTarget = false;
				this.context.isBindingElement = false;
				token = this.nextToken();
				raw = this.getTokenRaw(token);
				expr = this.finalize(node, new Literal(token.value === "true", raw));
				break;
			case 5:
				this.context.isAssignmentTarget = false;
				this.context.isBindingElement = false;
				token = this.nextToken();
				raw = this.getTokenRaw(token);
				expr = this.finalize(node, new Literal(null, raw));
				break;
			case 10:
				expr = this.parseTemplateLiteral({ isTagged: false });
				break;
			case 7:
				switch (this.lookahead.value) {
					case "(":
						this.context.isBindingElement = false;
						expr = this.inheritCoverGrammar(this.parseGroupExpression);
						break;
					case "[":
						expr = this.inheritCoverGrammar(this.parseArrayInitializer);
						break;
					case "{":
						expr = this.inheritCoverGrammar(this.parseObjectInitializer);
						break;
					case "/":
					case "/=":
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						this.scanner.index = this.startMarker.index;
						token = this.nextRegexToken();
						raw = this.getTokenRaw(token);
						expr = this.finalize(node, new RegexLiteral(token.regex, raw, token.pattern, token.flags));
						break;
					case "#":
						this.nextToken();
						expr = this.finalize(node, new PrivateIdentifier(this.nextToken().value));
						break;
					case "@":
						let decorators = this.parseDecorators();
						this.context.decorators = decorators;
						this.parsePrimaryExpression();
						this.context.decorators = null;
						expr = this.finalize(node, new PrivateIdentifier(this.nextToken().value));
						break;
					default: expr = this.throwUnexpectedToken(this.nextToken());
				}
				break;
			case 4:
				if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) expr = this.parseIdentifierName();
				else if (!this.context.strict && this.matchKeyword("let")) expr = this.finalize(node, new Identifier(this.nextToken().value));
				else {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					if (this.matchKeyword("function")) expr = this.parseFunctionExpression();
					else if (this.matchKeyword("this")) {
						this.nextToken();
						expr = this.finalize(node, new ThisExpression());
					} else if (this.matchKeyword("class")) expr = this.parseClassExpression();
					else if (this.matchKeyword("new")) expr = this.parseNewExpression();
					else if (this.matchImportCall()) expr = this.parseImportCall();
					else if (this.matchImportMeta()) {
						if (!this.context.isModule) this.tolerateUnexpectedToken(this.lookahead, Messages.CannotUseImportMetaOutsideAModule);
						expr = this.parseImportMeta();
					} else expr = this.throwUnexpectedToken(this.nextToken());
				}
				break;
			default: expr = this.throwUnexpectedToken(this.nextToken());
		}
		return expr;
	}
	parseSpreadElement() {
		const node = this.createNode();
		this.expect("...");
		const arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
		return this.finalize(node, new SpreadElement(arg));
	}
	parseArrayInitializer() {
		const node = this.createNode();
		const elements = [];
		this.expect("[");
		while (!this.match("]")) if (this.match(",")) {
			this.nextToken();
			elements.push(null);
		} else if (this.match("...")) {
			const element = this.parseSpreadElement();
			if (!this.match("]")) {
				this.context.isAssignmentTarget = false;
				this.context.isBindingElement = false;
				this.expect(",");
			}
			elements.push(element);
		} else {
			elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
			if (!this.match("]")) this.expect(",");
		}
		this.expect("]");
		return this.finalize(node, new ArrayExpression(elements));
	}
	parsePropertyMethod(params) {
		this.context.isAssignmentTarget = false;
		this.context.isBindingElement = false;
		const previousStrict = this.context.strict;
		const previousAllowStrictDirective = this.context.allowStrictDirective;
		this.context.allowStrictDirective = params.simple;
		const body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
		if (this.context.strict && params.firstRestricted) this.tolerateUnexpectedToken(params.firstRestricted, params.message);
		if (this.context.strict && params.stricted) this.tolerateUnexpectedToken(params.stricted, params.message);
		this.context.strict = previousStrict;
		this.context.allowStrictDirective = previousAllowStrictDirective;
		return body;
	}
	parsePropertyMethodFunction(isGenerator) {
		const node = this.createNode();
		const previousAllowYield = this.context.allowYield;
		this.context.allowYield = true;
		const params = this.parseFormalParameters();
		const method$1 = this.parsePropertyMethod(params);
		this.context.allowYield = previousAllowYield;
		return this.finalize(node, new FunctionExpression(null, params.params, method$1, isGenerator, false));
	}
	parsePropertyMethodAsyncFunction(isGenerator) {
		const node = this.createNode();
		const previousAllowYield = this.context.allowYield;
		const previousIsAsync = this.context.isAsync;
		this.context.allowYield = false;
		this.context.isAsync = true;
		const params = this.parseFormalParameters();
		const method$1 = this.parsePropertyMethod(params);
		this.context.allowYield = previousAllowYield;
		this.context.isAsync = previousIsAsync;
		return this.finalize(node, new FunctionExpression(null, params.params, method$1, isGenerator, true));
	}
	parseObjectPropertyKey(isPrivate = false) {
		const node = this.createNode();
		const token = this.nextToken();
		let key;
		switch (token.type) {
			case 8:
			case 6:
				if (this.context.strict && token.octal) this.tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
				const raw = this.getTokenRaw(token);
				if (typeof token.value === "bigint") key = this.finalize(node, new BigIntLiteral(token.value, raw, token.value.toString()));
				else key = this.finalize(node, new Literal(token.value, raw));
				break;
			case 3:
			case 1:
			case 5:
			case 4:
				key = this.finalize(node, isPrivate ? new PrivateIdentifier(token.value) : new Identifier(token.value));
				break;
			case 7:
				if (token.value === "[") {
					key = this.isolateCoverGrammar(this.parseAssignmentExpression);
					this.expect("]");
				} else key = this.throwUnexpectedToken(token);
				break;
			default: key = this.throwUnexpectedToken(token);
		}
		return key;
	}
	isPropertyKey(key, value) {
		return key.type === Syntax.Identifier && key.name === value || key.type === Syntax.Literal && key.value === value;
	}
	parseObjectProperty(hasProto) {
		const node = this.createNode();
		const token = this.lookahead;
		let kind;
		let key = null;
		let value = null;
		let computed = false;
		let method$1 = false;
		let shorthand = false;
		let isAsync$1 = false;
		let isGenerator = false;
		if (token.type === 3) {
			const id = token.value;
			this.nextToken();
			computed = this.match("[");
			isAsync$1 = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match(",");
			isGenerator = this.match("*");
			if (isGenerator) this.nextToken();
			key = isAsync$1 ? this.parseObjectPropertyKey() : this.finalize(node, new Identifier(id));
		} else if (this.match("*")) this.nextToken();
		else {
			computed = this.match("[");
			key = this.parseObjectPropertyKey();
		}
		const lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
		if (token.type === 3 && !isAsync$1 && token.value === "get" && lookaheadPropertyKey) {
			kind = "get";
			computed = this.match("[");
			key = this.parseObjectPropertyKey();
			this.context.allowYield = false;
			value = this.parseGetterMethod();
		} else if (token.type === 3 && !isAsync$1 && token.value === "set" && lookaheadPropertyKey) {
			kind = "set";
			computed = this.match("[");
			key = this.parseObjectPropertyKey();
			value = this.parseSetterMethod();
		} else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
			kind = "init";
			computed = this.match("[");
			key = this.parseObjectPropertyKey();
			value = this.parseGeneratorMethod(false);
			method$1 = true;
		} else {
			if (!key) this.throwUnexpectedToken(this.lookahead);
			kind = "init";
			if (this.match(":") && !isAsync$1) {
				if (!computed && this.isPropertyKey(key, "__proto__")) {
					if (hasProto.value) this.tolerateError(Messages.DuplicateProtoProperty);
					hasProto.value = true;
				}
				this.nextToken();
				value = this.inheritCoverGrammar(this.parseAssignmentExpression);
			} else if (this.match("(")) {
				value = isAsync$1 ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);
				method$1 = true;
			} else if (token.type === 3) {
				const id = this.finalize(node, new Identifier(token.value));
				if (this.match("=")) {
					this.context.firstCoverInitializedNameError = this.lookahead;
					this.nextToken();
					shorthand = true;
					const init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					value = this.finalize(node, new AssignmentPattern(id, init));
				} else {
					shorthand = true;
					value = id;
				}
			} else this.throwUnexpectedToken(this.nextToken());
		}
		return this.finalize(node, new Property(kind, key, computed, value, method$1, shorthand));
	}
	parseObjectInitializer() {
		const node = this.createNode();
		this.expect("{");
		const properties = [];
		const hasProto = { value: false };
		while (!this.match("}")) {
			const property$2 = this.match("...") ? this.parseSpreadElement() : this.parseObjectProperty(hasProto);
			properties.push(property$2);
			if (!this.match("}") && (!property$2.method || this.match(","))) this.expectCommaSeparator();
		}
		this.expect("}");
		return this.finalize(node, new ObjectExpression(properties));
	}
	throwTemplateLiteralEarlyErrors(token) {
		switch (token.notEscapeSequenceHead) {
			case "u": return this.throwUnexpectedToken(token, Messages.InvalidUnicodeEscapeSequence);
			case "x": return this.throwUnexpectedToken(token, Messages.InvalidHexEscapeSequence);
			case "8":
			case "9": return this.throwUnexpectedToken(token, Messages.TemplateEscape89);
			default: return this.throwUnexpectedToken(token, Messages.TemplateOctalLiteral);
		}
	}
	parseTemplateHead(options) {
		assert$3(this.lookahead.head, "Template literal must start with a template head");
		const node = this.createNode();
		const token = this.nextToken();
		if (!options.isTagged && token.notEscapeSequenceHead !== null) this.throwTemplateLiteralEarlyErrors(token);
		const raw = token.value;
		const cooked = token.cooked;
		return this.finalize(node, new TemplateElement({
			raw,
			cooked
		}, token.tail));
	}
	parseTemplateElement(options) {
		if (this.lookahead.type !== 10) this.throwUnexpectedToken();
		const node = this.createNode();
		const token = this.nextToken();
		if (!options.isTagged && token.notEscapeSequenceHead !== null) this.throwTemplateLiteralEarlyErrors(token);
		const raw = token.value;
		const cooked = token.cooked;
		return this.finalize(node, new TemplateElement({
			raw,
			cooked
		}, token.tail));
	}
	parseTemplateLiteral(options) {
		const node = this.createNode();
		const expressions = [];
		const quasis = [];
		let quasi = this.parseTemplateHead(options);
		quasis.push(quasi);
		while (!quasi.tail) {
			expressions.push(this.parseExpression());
			quasi = this.parseTemplateElement(options);
			quasis.push(quasi);
		}
		return this.finalize(node, new TemplateLiteral(quasis, expressions));
	}
	reinterpretExpressionAsPattern(expr) {
		switch (expr.type) {
			case Syntax.Identifier:
			case Syntax.MemberExpression:
			case Syntax.RestElement:
			case Syntax.AssignmentPattern: break;
			case Syntax.SpreadElement:
				expr.type = Syntax.RestElement;
				this.reinterpretExpressionAsPattern(expr.argument);
				break;
			case Syntax.ArrayExpression:
				expr.type = Syntax.ArrayPattern;
				for (let i$2 = 0; i$2 < expr.elements.length; i$2++) if (expr.elements[i$2] !== null) this.reinterpretExpressionAsPattern(expr.elements[i$2]);
				break;
			case Syntax.ObjectExpression:
				expr.type = Syntax.ObjectPattern;
				for (let i$2 = 0; i$2 < expr.properties.length; i$2++) {
					const property$2 = expr.properties[i$2];
					this.reinterpretExpressionAsPattern(property$2.type === Syntax.SpreadElement ? property$2 : property$2.value);
				}
				break;
			case Syntax.AssignmentExpression:
				expr.type = Syntax.AssignmentPattern;
				delete expr.operator;
				this.reinterpretExpressionAsPattern(expr.left);
				break;
		}
	}
	parseGroupExpression() {
		let expr;
		this.expect("(");
		if (this.match(")")) {
			this.nextToken();
			if (!this.match("=>")) this.expect("=>");
			expr = {
				type: ArrowParameterPlaceHolder,
				params: [],
				async: false
			};
		} else {
			const startToken = this.lookahead;
			const params = [];
			if (this.match("...")) {
				expr = this.parseRestElement(params);
				this.expect(")");
				if (!this.match("=>")) this.expect("=>");
				expr = {
					type: ArrowParameterPlaceHolder,
					params: [expr],
					async: false
				};
			} else {
				let arrow = false;
				this.context.isBindingElement = true;
				expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
				if (this.match(",")) {
					const expressions = [];
					this.context.isAssignmentTarget = false;
					expressions.push(expr);
					while (this.lookahead.type !== 2) {
						if (!this.match(",")) break;
						this.nextToken();
						if (this.match(")")) {
							this.nextToken();
							for (let i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
							arrow = true;
							expr = {
								type: ArrowParameterPlaceHolder,
								params: expressions,
								async: false
							};
						} else if (this.match("...")) {
							if (!this.context.isBindingElement) this.throwUnexpectedToken(this.lookahead);
							expressions.push(this.parseRestElement(params));
							this.expect(")");
							if (!this.match("=>")) this.expect("=>");
							this.context.isBindingElement = false;
							for (let i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
							arrow = true;
							expr = {
								type: ArrowParameterPlaceHolder,
								params: expressions,
								async: false
							};
						} else expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
						if (arrow) break;
					}
					if (!arrow) expr = this.finalize(this.startNode(startToken), new SequenceExpression(expressions));
				}
				if (!arrow) {
					this.expect(")");
					if (this.match("=>")) {
						if (expr.type === Syntax.Identifier && expr.name === "yield") {
							arrow = true;
							expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: false
							};
						}
						if (!arrow) {
							if (!this.context.isBindingElement) this.throwUnexpectedToken(this.lookahead);
							if (expr.type === Syntax.SequenceExpression) for (let i$2 = 0; i$2 < expr.expressions.length; i$2++) this.reinterpretExpressionAsPattern(expr.expressions[i$2]);
							else this.reinterpretExpressionAsPattern(expr);
							expr = {
								type: ArrowParameterPlaceHolder,
								params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr],
								async: false
							};
						}
					}
					this.context.isBindingElement = false;
				}
			}
		}
		return expr;
	}
	parseArguments() {
		this.expect("(");
		const args = [];
		if (!this.match(")")) while (true) {
			const expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
			args.push(expr);
			if (this.match(")")) break;
			this.expectCommaSeparator();
			if (this.match(")")) break;
		}
		this.expect(")");
		return args;
	}
	isIdentifierName(token) {
		return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
	}
	parseIdentifierName(allowPrivateField = false) {
		let isPrivateField = false;
		let node = this.createNode();
		let token = this.nextToken();
		if (token.value === "#" && allowPrivateField) {
			token = this.nextToken();
			isPrivateField = true;
		}
		if (!this.isIdentifierName(token)) this.throwUnexpectedToken(token);
		return this.finalize(node, isPrivateField ? new PrivateIdentifier(token.value) : new Identifier(token.value));
	}
	parseNewExpression() {
		const node = this.createNode();
		const id = this.parseIdentifierName();
		assert$3(id.name === "new", "New expression must start with `new`");
		let expr;
		if (this.match(".")) {
			this.nextToken();
			if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") expr = new MetaProperty(id, this.parseIdentifierName());
			else this.throwUnexpectedToken(this.lookahead);
		} else if (this.matchKeyword("import")) this.throwUnexpectedToken(this.lookahead);
		else {
			expr = new NewExpression(this.isolateCoverGrammar(this.parseLeftHandSideExpression), this.match("(") ? this.parseArguments() : []);
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
		}
		return this.finalize(node, expr);
	}
	parseAsyncArgument() {
		const arg = this.parseAssignmentExpression();
		this.context.firstCoverInitializedNameError = null;
		return arg;
	}
	parseAsyncArguments() {
		this.expect("(");
		const args = [];
		if (!this.match(")")) while (true) {
			const expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
			args.push(expr);
			if (this.match(")")) break;
			this.expectCommaSeparator();
			if (this.match(")")) break;
		}
		this.expect(")");
		return args;
	}
	matchImportCall() {
		let match$1 = this.matchKeyword("import");
		if (match$1) {
			const state = this.scanner.saveState();
			this.scanner.scanComments();
			const next = this.scanner.lex();
			this.scanner.restoreState(state);
			match$1 = next.type === 7 && next.value === "(";
		}
		return match$1;
	}
	parseImportCall() {
		const node = this.createNode();
		this.expectKeyword("import");
		this.expect("(");
		const source = this.parseAssignmentExpression();
		let attributes = null;
		if (this.match(",")) {
			this.nextToken();
			attributes = this.parseObjectInitializer();
		}
		if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken());
		else {
			this.expect(")");
			if (this.match(";")) this.nextToken();
		}
		return this.finalize(node, new ImportExpression(source, attributes));
	}
	matchImportMeta() {
		let match$1 = this.matchKeyword("import");
		if (match$1) {
			const state = this.scanner.saveState();
			this.scanner.scanComments();
			const dot = this.scanner.lex();
			if (dot.type === 7 && dot.value === ".") {
				this.scanner.scanComments();
				const meta = this.scanner.lex();
				match$1 = meta.type === 3 && meta.value === "meta";
				if (match$1) {
					if (meta.end - meta.start !== 4) this.tolerateUnexpectedToken(meta, Messages.InvalidEscapedReservedWord);
				}
			} else match$1 = false;
			this.scanner.restoreState(state);
		}
		return match$1;
	}
	parseImportMeta() {
		const node = this.createNode();
		const id = this.parseIdentifierName();
		this.expect(".");
		const property$2 = this.parseIdentifierName();
		this.context.isAssignmentTarget = false;
		return this.finalize(node, new MetaProperty(id, property$2));
	}
	parseLeftHandSideExpressionAllowCall() {
		const startToken = this.lookahead;
		const maybeAsync = this.matchContextualKeyword("async");
		const previousAllowIn = this.context.allowIn;
		this.context.allowIn = true;
		let expr;
		const isSuper = this.matchKeyword("super");
		if (isSuper && this.context.inFunctionBody) {
			expr = this.createNode();
			this.nextToken();
			expr = this.finalize(expr, new Super());
			if (!this.match("(") && !this.match(".") && !this.match("[")) this.throwUnexpectedToken(this.lookahead);
		} else expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
		if (isSuper && this.match("(") && (!this.context.inClassConstructor || !this.context.allowSuper)) this.tolerateError(Messages.UnexpectedSuper);
		let hasOptional = false;
		while (true) {
			let optional = false;
			if (this.match("?.")) {
				optional = true;
				hasOptional = true;
				this.expect("?.");
			}
			if (this.match("(")) {
				const asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
				this.context.isBindingElement = false;
				this.context.isAssignmentTarget = false;
				const args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
				if (expr.type === Syntax.ImportExpression && args.length !== 1) this.tolerateError(Messages.BadImportCallArity);
				expr = this.finalize(this.startNode(startToken), new CallExpression(expr, args, optional));
				if (asyncArrow && this.match("=>")) {
					for (let i$2 = 0; i$2 < args.length; ++i$2) this.reinterpretExpressionAsPattern(args[i$2]);
					expr = {
						type: ArrowParameterPlaceHolder,
						params: args,
						async: true
					};
				}
			} else if (this.match("[")) {
				this.context.isBindingElement = false;
				this.context.isAssignmentTarget = !optional;
				this.expect("[");
				const property$2 = this.isolateCoverGrammar(this.parseExpression);
				this.expect("]");
				expr = this.finalize(this.startNode(startToken), new MemberExpression(true, expr, property$2, optional));
			} else if (this.lookahead.type === 10 && this.lookahead.head) {
				if (optional) this.throwUnexpectedToken(this.lookahead);
				if (hasOptional) this.throwError(Messages.InvalidTaggedTemplateOnOptionalChain);
				const quasi = this.parseTemplateLiteral({ isTagged: true });
				expr = this.finalize(this.startNode(startToken), new TaggedTemplateExpression(expr, quasi));
			} else if (this.match(".") || optional) {
				this.context.isBindingElement = false;
				this.context.isAssignmentTarget = !optional;
				if (!optional) this.expect(".");
				const property$2 = this.parseIdentifierName(true);
				expr = this.finalize(this.startNode(startToken), new MemberExpression(false, expr, property$2, optional));
			} else break;
		}
		this.context.allowIn = previousAllowIn;
		if (hasOptional) return new ChainExpression(expr);
		return expr;
	}
	parseSuper() {
		const node = this.createNode();
		this.expectKeyword("super");
		if (!this.match("[") && !this.match(".")) this.throwUnexpectedToken(this.lookahead);
		return this.finalize(node, new Super());
	}
	parseLeftHandSideExpression() {
		assert$3(this.context.allowIn, "callee of new expression always allow in keyword.");
		const node = this.startNode(this.lookahead);
		let expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
		let hasOptional = false;
		while (true) {
			let optional = false;
			if (this.match("?.")) {
				optional = true;
				hasOptional = true;
				this.expect("?.");
			}
			if (this.match("[")) {
				this.context.isBindingElement = false;
				this.context.isAssignmentTarget = !optional;
				this.expect("[");
				const property$2 = this.isolateCoverGrammar(this.parseExpression);
				this.expect("]");
				expr = this.finalize(node, new MemberExpression(true, expr, property$2, optional));
			} else if (this.lookahead.type === 10 && this.lookahead.head) {
				if (optional) this.throwUnexpectedToken(this.lookahead);
				if (hasOptional) this.throwError(Messages.InvalidTaggedTemplateOnOptionalChain);
				const quasi = this.parseTemplateLiteral({ isTagged: true });
				expr = this.finalize(node, new TaggedTemplateExpression(expr, quasi));
			} else if (this.match(".") || optional) {
				this.context.isBindingElement = false;
				this.context.isAssignmentTarget = !optional;
				if (!optional) this.expect(".");
				const property$2 = this.parseIdentifierName();
				expr = this.finalize(node, new MemberExpression(false, expr, property$2, optional));
			} else break;
		}
		if (hasOptional) return new ChainExpression(expr);
		return expr;
	}
	parseUpdateExpression() {
		let expr;
		const startToken = this.lookahead;
		if (this.match("++") || this.match("--")) {
			const node = this.startNode(startToken);
			const token = this.nextToken();
			expr = this.inheritCoverGrammar(this.parseUnaryExpression);
			if (this.context.strict && expr.type === Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) this.tolerateError(Messages.StrictLHSPrefix);
			if (!this.context.isAssignmentTarget) this.tolerateError(Messages.InvalidLHSInAssignment);
			expr = this.finalize(node, new UpdateExpression(token.value, expr, true));
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
		} else {
			expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			if (!this.hasLineTerminator && this.lookahead.type === 7) {
				if (this.match("++") || this.match("--")) {
					if (this.context.strict && expr.type === Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) this.tolerateError(Messages.StrictLHSPostfix);
					if (!this.context.isAssignmentTarget) this.tolerateError(Messages.InvalidLHSInAssignment);
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					const operator = this.nextToken().value;
					expr = this.finalize(this.startNode(startToken), new UpdateExpression(operator, expr, false));
				}
			}
		}
		return expr;
	}
	parseAwaitExpression() {
		const node = this.createNode();
		this.nextToken();
		const argument = this.parseUnaryExpression();
		return this.finalize(node, new AwaitExpression(argument));
	}
	parseUnaryExpression() {
		let expr;
		if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
			const node = this.startNode(this.lookahead);
			const token = this.nextToken();
			expr = this.inheritCoverGrammar(this.parseUnaryExpression);
			expr = this.finalize(node, new UnaryExpression(token.value, expr));
			if (this.context.strict && expr.operator === "delete" && expr.argument.type === Syntax.Identifier) this.tolerateError(Messages.StrictDelete);
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
		} else if ((this.context.isModule && !this.context.inFunctionBody || this.context.isAsync) && this.matchContextualKeyword("await")) expr = this.parseAwaitExpression();
		else expr = this.parseUpdateExpression();
		return expr;
	}
	parseExponentiationExpression() {
		const startToken = this.lookahead;
		const isLeftParenthesized = this.match("(");
		let expr = this.inheritCoverGrammar(this.parseUnaryExpression);
		if ((expr.type !== Syntax.UnaryExpression || isLeftParenthesized) && this.match("**")) {
			this.nextToken();
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
			const left = expr;
			const right = this.isolateCoverGrammar(this.parseExponentiationExpression);
			expr = this.finalize(this.startNode(startToken), new BinaryExpression("**", left, right));
		}
		return expr;
	}
	binaryPrecedence(token) {
		const op = token.value;
		let precedence;
		if (token.type === 7) precedence = this.operatorPrecedence[op] || 0;
		else if (token.type === 4) precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 12 : 0;
		else precedence = 0;
		return precedence;
	}
	parseBinaryExpression() {
		const startToken = this.lookahead;
		let expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
		let allowAndOr = true;
		let allowNullishCoalescing = true;
		const updateNullishCoalescingRestrictions = (token$1) => {
			if (token$1.value === "&&" || token$1.value === "||") allowNullishCoalescing = false;
			if (token$1.value === "??") allowAndOr = false;
		};
		const token = this.lookahead;
		let prec = this.binaryPrecedence(token);
		if (prec > 0) {
			updateNullishCoalescingRestrictions(token);
			this.nextToken();
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
			const markers = [startToken, this.lookahead];
			let left = expr;
			let right = this.isolateCoverGrammar(this.parseExponentiationExpression);
			const stack = [
				left,
				token.value,
				right
			];
			const precedences = [prec];
			while (true) {
				prec = this.binaryPrecedence(this.lookahead);
				if (prec <= 0) break;
				if (!allowAndOr && (this.lookahead.value === "&&" || this.lookahead.value === "||") || !allowNullishCoalescing && this.lookahead.value === "??") this.throwUnexpectedToken(this.lookahead);
				updateNullishCoalescingRestrictions(this.lookahead);
				while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
					right = stack.pop();
					const operator = stack.pop();
					precedences.pop();
					left = stack.pop();
					markers.pop();
					const marker = markers[markers.length - 1];
					const node = this.startNode(marker, marker.lineStart);
					const logical = operator === "||" || operator === "&&" || operator === "??";
					stack.push(this.finalize(node, logical ? new LogicalExpression(operator, left, right) : new BinaryExpression(operator, left, right)));
				}
				stack.push(this.nextToken().value);
				precedences.push(prec);
				markers.push(this.lookahead);
				stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
			}
			let i$2 = stack.length - 1;
			expr = stack[i$2];
			let lastMarker = markers.pop();
			while (i$2 > 1) {
				const marker = markers.pop();
				const lastLineStart = lastMarker && lastMarker.lineStart;
				const node = this.startNode(marker, lastLineStart);
				const operator = stack[i$2 - 1];
				const logical = operator === "||" || operator === "&&" || operator === "??";
				expr = this.finalize(node, logical ? new LogicalExpression(operator, stack[i$2 - 2], expr) : new BinaryExpression(operator, stack[i$2 - 2], expr));
				i$2 -= 2;
				lastMarker = marker;
			}
		}
		return expr;
	}
	parseConditionalExpression() {
		const startToken = this.lookahead;
		let expr = this.inheritCoverGrammar(this.parseBinaryExpression);
		if (this.match("?")) {
			this.nextToken();
			const previousAllowIn = this.context.allowIn;
			this.context.allowIn = true;
			const consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
			this.context.allowIn = previousAllowIn;
			this.expect(":");
			const alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
			expr = this.finalize(this.startNode(startToken), new ConditionalExpression(expr, consequent, alternate));
			this.context.isAssignmentTarget = false;
			this.context.isBindingElement = false;
		}
		return expr;
	}
	checkPatternParam(options, param) {
		switch (param.type) {
			case Syntax.Identifier:
				this.validateParam(options, param, param.name);
				break;
			case Syntax.RestElement:
				this.checkPatternParam(options, param.argument);
				break;
			case Syntax.AssignmentPattern:
				this.checkPatternParam(options, param.left);
				break;
			case Syntax.ArrayPattern:
				for (let i$2 = 0; i$2 < param.elements.length; i$2++) if (param.elements[i$2] !== null) this.checkPatternParam(options, param.elements[i$2]);
				break;
			case Syntax.ObjectPattern:
				for (let i$2 = 0; i$2 < param.properties.length; i$2++) {
					const property$2 = param.properties[i$2];
					this.checkPatternParam(options, property$2.type === Syntax.RestElement ? property$2 : property$2.value);
				}
				break;
		}
		options.simple = options.simple && param instanceof Identifier;
	}
	reinterpretAsCoverFormalsList(expr) {
		let params = [expr];
		const options = {
			simple: true,
			paramSet: {}
		};
		let asyncArrow = false;
		switch (expr.type) {
			case Syntax.Identifier: break;
			case ArrowParameterPlaceHolder:
				params = expr.params;
				asyncArrow = expr.async;
				break;
			default: return null;
		}
		for (let i$2 = 0; i$2 < params.length; ++i$2) {
			const param = params[i$2];
			if (param.type === Syntax.AssignmentPattern) {
				if (param.right.type === Syntax.YieldExpression) {
					if (param.right.argument) this.throwUnexpectedToken(this.lookahead);
					param.right.type = Syntax.Identifier;
					param.right.name = "yield";
					delete param.right.argument;
					delete param.right.delegate;
				}
			} else if (asyncArrow && param.type === Syntax.Identifier && param.name === "await") this.throwUnexpectedToken(this.lookahead);
			this.checkPatternParam(options, param);
			params[i$2] = param;
		}
		if (this.context.strict || !this.context.allowYield) {
			for (let i$2 = 0; i$2 < params.length; ++i$2) if (params[i$2].type === Syntax.YieldExpression) this.throwUnexpectedToken(this.lookahead);
		}
		if (options.hasDuplicateParameterNames) {
			const token = this.context.strict ? options.stricted : options.firstRestricted;
			this.throwUnexpectedToken(token, Messages.DuplicateParameter);
		}
		return {
			simple: options.simple,
			params,
			stricted: options.stricted,
			firstRestricted: options.firstRestricted,
			message: options.message
		};
	}
	parseAssignmentExpression() {
		let expr;
		if (!this.context.allowYield && this.matchKeyword("yield")) expr = this.parseYieldExpression();
		else {
			const startToken = this.lookahead;
			let token = startToken;
			expr = this.parseConditionalExpression();
			if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
				if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
					const arg = this.parsePrimaryExpression();
					this.reinterpretExpressionAsPattern(arg);
					expr = {
						type: ArrowParameterPlaceHolder,
						params: [arg],
						async: true
					};
				}
			}
			if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
				this.context.isAssignmentTarget = false;
				this.context.isBindingElement = false;
				const isAsync$1 = expr.async;
				const list = this.reinterpretAsCoverFormalsList(expr);
				if (list) {
					if (this.hasLineTerminator) this.tolerateUnexpectedToken(this.lookahead);
					this.context.firstCoverInitializedNameError = null;
					const previousStrict = this.context.strict;
					const previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = list.simple;
					const previousAllowYield = this.context.allowYield;
					const previousIsAsync = this.context.isAsync;
					this.context.allowYield = true;
					this.context.isAsync = isAsync$1;
					const node = this.startNode(startToken);
					this.expect("=>");
					let body;
					if (this.match("{")) {
						const previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						body = this.parseFunctionSourceElements();
						this.context.allowIn = previousAllowIn;
					} else body = this.isolateCoverGrammar(this.parseAssignmentExpression);
					const expression = body.type !== Syntax.BlockStatement;
					if (this.context.strict && list.firstRestricted) this.throwUnexpectedToken(list.firstRestricted, list.message);
					if (this.context.strict && list.stricted) this.tolerateUnexpectedToken(list.stricted, list.message);
					expr = this.finalize(node, new ArrowFunctionExpression(list.params, body, expression, isAsync$1));
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.allowYield = previousAllowYield;
					this.context.isAsync = previousIsAsync;
				}
			} else if (this.matchAssign()) {
				if (!this.context.isAssignmentTarget) this.tolerateError(Messages.InvalidLHSInAssignment);
				if (this.context.strict && expr.type === Syntax.Identifier) {
					const id = expr;
					if (this.scanner.isRestrictedWord(id.name)) this.tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
					if (this.scanner.isStrictModeReservedWord(id.name)) this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);
				}
				if (!this.match("=")) {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
				} else this.reinterpretExpressionAsPattern(expr);
				token = this.nextToken();
				const operator = token.value;
				const right = this.isolateCoverGrammar(this.parseAssignmentExpression);
				expr = this.finalize(this.startNode(startToken), new AssignmentExpression(operator, expr, right));
				this.context.firstCoverInitializedNameError = null;
			}
		}
		return expr;
	}
	parseExpression() {
		const startToken = this.lookahead;
		let expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
		if (this.match(",")) {
			const expressions = [];
			expressions.push(expr);
			while (this.lookahead.type !== 2) {
				if (!this.match(",")) break;
				this.nextToken();
				expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
			}
			expr = this.finalize(this.startNode(startToken), new SequenceExpression(expressions));
		}
		return expr;
	}
	parseStatementListItem() {
		let statement;
		this.context.isAssignmentTarget = true;
		this.context.isBindingElement = true;
		if (this.lookahead.type === 4) switch (this.lookahead.value) {
			case "export":
				if (!this.context.isModule) this.tolerateUnexpectedToken(this.lookahead, Messages.IllegalExportDeclaration);
				statement = this.parseExportDeclaration();
				break;
			case "import":
				if (this.matchImportCall()) statement = this.parseExpressionStatement();
				else if (this.matchImportMeta()) statement = this.parseStatement();
				else {
					if (!this.context.isModule) this.tolerateUnexpectedToken(this.lookahead, Messages.IllegalImportDeclaration);
					statement = this.parseImportDeclaration();
				}
				break;
			case "const":
				statement = this.parseLexicalDeclaration({ inFor: false });
				break;
			case "function":
				statement = this.parseFunctionDeclaration();
				break;
			case "class":
				statement = this.parseClassDeclaration();
				break;
			case "let":
				statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
				break;
			default:
				statement = this.parseStatement();
				break;
		}
		else statement = this.parseStatement();
		return statement;
	}
	parseBlock() {
		const node = this.createNode();
		this.expect("{");
		const block = [];
		while (true) {
			if (this.match("}")) break;
			block.push(this.parseStatementListItem());
		}
		this.expect("}");
		return this.finalize(node, new BlockStatement(block));
	}
	parseLexicalBinding(kind, options) {
		const node = this.createNode();
		const id = this.parsePattern([], kind);
		if (this.context.strict && id.type === Syntax.Identifier) {
			if (this.scanner.isRestrictedWord(id.name)) this.tolerateError(Messages.StrictVarName);
		}
		let init = null;
		if (kind === "const") {
			if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) if (this.match("=")) {
				this.nextToken();
				init = this.isolateCoverGrammar(this.parseAssignmentExpression);
			} else this.throwError(Messages.DeclarationMissingInitializer, "const");
		} else if (!options.inFor && id.type !== Syntax.Identifier || this.match("=")) {
			this.expect("=");
			init = this.isolateCoverGrammar(this.parseAssignmentExpression);
		}
		return this.finalize(node, new VariableDeclarator(id, init));
	}
	parseBindingList(kind, options) {
		const list = [this.parseLexicalBinding(kind, options)];
		while (this.match(",")) {
			this.nextToken();
			list.push(this.parseLexicalBinding(kind, options));
		}
		return list;
	}
	isLexicalDeclaration() {
		const state = this.scanner.saveState();
		this.scanner.scanComments();
		const next = this.scanner.lex();
		this.scanner.restoreState(state);
		return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
	}
	parseLexicalDeclaration(options) {
		const node = this.createNode();
		const kind = this.nextToken().value;
		assert$3(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
		const declarations = this.parseBindingList(kind, options);
		this.consumeSemicolon();
		return this.finalize(node, new VariableDeclaration(declarations, kind));
	}
	isInitializedProperty() {
		let state = this.scanner.saveState();
		this.scanner.scanComments();
		let next = this.scanner.lex();
		this.scanner.restoreState(state);
		return this.lookahead.type === 3 && next.value === "=";
	}
	isDeclaredProperty() {
		let state = this.scanner.saveState();
		this.scanner.scanComments();
		let next = this.scanner.lex();
		this.scanner.restoreState(state);
		return this.lookahead.type === 3 && next.value === ";" || this.lookahead.type === 3 && next.lineNumber !== this.startMarker.line;
	}
	parseBindingRestElement(params, kind) {
		const node = this.createNode();
		this.expect("...");
		const arg = this.parsePattern(params, kind);
		return this.finalize(node, new RestElement(arg));
	}
	parseArrayPattern(params, kind) {
		const node = this.createNode();
		this.expect("[");
		const elements = [];
		while (!this.match("]")) if (this.match(",")) {
			this.nextToken();
			elements.push(null);
		} else {
			if (this.match("...")) {
				elements.push(this.parseBindingRestElement(params, kind));
				break;
			} else elements.push(this.parsePatternWithDefault(params, kind));
			if (!this.match("]")) this.expect(",");
		}
		this.expect("]");
		return this.finalize(node, new ArrayPattern(elements));
	}
	parsePropertyPattern(params, kind) {
		const node = this.createNode();
		let computed = false;
		let shorthand = false;
		const method$1 = false;
		let key;
		let value;
		if (this.lookahead.type === 3) {
			const keyToken = this.lookahead;
			key = this.parseVariableIdentifier();
			const init = this.finalize(node, new Identifier(keyToken.value));
			if (this.match("=")) {
				params.push(keyToken);
				shorthand = true;
				this.nextToken();
				const expr = this.parseAssignmentExpression();
				value = this.finalize(this.startNode(keyToken), new AssignmentPattern(init, expr));
			} else if (!this.match(":")) {
				params.push(keyToken);
				shorthand = true;
				value = init;
			} else {
				this.expect(":");
				value = this.parsePatternWithDefault(params, kind);
			}
		} else {
			computed = this.match("[");
			key = this.parseObjectPropertyKey();
			this.expect(":");
			value = this.parsePatternWithDefault(params, kind);
		}
		return this.finalize(node, new Property("init", key, computed, value, method$1, shorthand));
	}
	parseRestProperty(params) {
		const node = this.createNode();
		this.expect("...");
		const arg = this.parsePattern(params);
		if (this.match("=")) this.throwError(Messages.DefaultRestProperty);
		if (!this.match("}")) this.throwError(Messages.PropertyAfterRestProperty);
		return this.finalize(node, new RestElement(arg));
	}
	parseObjectPattern(params, kind) {
		const node = this.createNode();
		const properties = [];
		this.expect("{");
		while (!this.match("}")) {
			properties.push(this.match("...") ? this.parseRestProperty(params) : this.parsePropertyPattern(params, kind));
			if (!this.match("}")) this.expect(",");
		}
		this.expect("}");
		return this.finalize(node, new ObjectPattern(properties));
	}
	parsePattern(params, kind) {
		let pattern;
		if (this.match("[")) pattern = this.parseArrayPattern(params, kind);
		else if (this.match("{")) pattern = this.parseObjectPattern(params, kind);
		else {
			if (this.matchKeyword("let") && (kind === "const" || kind === "let")) this.tolerateUnexpectedToken(this.lookahead, Messages.LetInLexicalBinding);
			params.push(this.lookahead);
			pattern = this.parseVariableIdentifier(kind);
		}
		return pattern;
	}
	parsePatternWithDefault(params, kind) {
		const startToken = this.lookahead;
		let pattern = this.parsePattern(params, kind);
		if (this.match("=")) {
			this.nextToken();
			const previousAllowYield = this.context.allowYield;
			this.context.allowYield = true;
			const right = this.isolateCoverGrammar(this.parseAssignmentExpression);
			this.context.allowYield = previousAllowYield;
			pattern = this.finalize(this.startNode(startToken), new AssignmentPattern(pattern, right));
		}
		return pattern;
	}
	parseVariableIdentifier(kind) {
		const node = this.createNode();
		const token = this.nextToken();
		if (token.type === 4 && token.value === "yield") {
			if (this.context.strict) this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);
			else if (!this.context.allowYield) this.throwUnexpectedToken(token);
		} else if (token.type !== 3) {
			if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);
			else if (this.context.strict || token.value !== "let" || kind !== "var") this.throwUnexpectedToken(token);
		} else if ((this.context.isModule || this.context.isAsync) && token.type === 3 && token.value === "await") this.tolerateUnexpectedToken(token);
		return this.finalize(node, new Identifier(token.value));
	}
	parseVariableDeclaration(options) {
		const node = this.createNode();
		const id = this.parsePattern([], "var");
		if (this.context.strict && id.type === Syntax.Identifier) {
			if (this.scanner.isRestrictedWord(id.name)) this.tolerateError(Messages.StrictVarName);
		}
		let init = null;
		if (this.match("=")) {
			this.nextToken();
			init = this.isolateCoverGrammar(this.parseAssignmentExpression);
		} else if (id.type !== Syntax.Identifier && !options.inFor) this.expect("=");
		return this.finalize(node, new VariableDeclarator(id, init));
	}
	parseVariableDeclarationList(options) {
		const opt = { inFor: options.inFor };
		const list = [];
		list.push(this.parseVariableDeclaration(opt));
		while (this.match(",")) {
			this.nextToken();
			list.push(this.parseVariableDeclaration(opt));
		}
		return list;
	}
	parseVariableStatement() {
		const node = this.createNode();
		this.expectKeyword("var");
		const declarations = this.parseVariableDeclarationList({ inFor: false });
		this.consumeSemicolon();
		return this.finalize(node, new VariableDeclaration(declarations, "var"));
	}
	parseEmptyStatement() {
		const node = this.createNode();
		this.expect(";");
		return this.finalize(node, new EmptyStatement());
	}
	parseExpressionStatement() {
		const node = this.createNode();
		const expr = this.parseExpression();
		this.consumeSemicolon();
		return this.finalize(node, new ExpressionStatement(expr));
	}
	parseIfClause() {
		if (this.context.strict && this.matchKeyword("function")) this.tolerateError(Messages.StrictFunction);
		return this.parseStatement();
	}
	parseIfStatement() {
		const node = this.createNode();
		let consequent;
		let alternate = null;
		this.expectKeyword("if");
		this.expect("(");
		const test = this.parseExpression();
		if (!this.match(")") && this.config.tolerant) {
			this.tolerateUnexpectedToken(this.nextToken());
			consequent = this.finalize(this.createNode(), new EmptyStatement());
		} else {
			this.expect(")");
			consequent = this.parseIfClause();
			if (this.matchKeyword("else")) {
				this.nextToken();
				alternate = this.parseIfClause();
			}
		}
		return this.finalize(node, new IfStatement(test, consequent, alternate));
	}
	parseDoWhileStatement() {
		const node = this.createNode();
		this.expectKeyword("do");
		this.tolerateInvalidLoopStatement();
		const previousInIteration = this.context.inIteration;
		this.context.inIteration = true;
		const body = this.parseStatement();
		this.context.inIteration = previousInIteration;
		this.expectKeyword("while");
		this.expect("(");
		const test = this.parseExpression();
		if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken());
		else {
			this.expect(")");
			if (this.match(";")) this.nextToken();
		}
		return this.finalize(node, new DoWhileStatement(body, test));
	}
	parseWhileStatement() {
		const node = this.createNode();
		let body;
		this.expectKeyword("while");
		this.expect("(");
		const test = this.parseExpression();
		if (!this.match(")") && this.config.tolerant) {
			this.tolerateUnexpectedToken(this.nextToken());
			body = this.finalize(this.createNode(), new EmptyStatement());
		} else {
			this.expect(")");
			const previousInIteration = this.context.inIteration;
			this.context.inIteration = true;
			body = this.parseStatement();
			this.context.inIteration = previousInIteration;
		}
		return this.finalize(node, new WhileStatement(test, body));
	}
	parseForStatement() {
		let init = null;
		let test = null;
		let update = null;
		let forIn = true;
		let left, right;
		let _await = false;
		const node = this.createNode();
		this.expectKeyword("for");
		if (this.matchContextualKeyword("await")) {
			if (!this.context.isAsync) this.tolerateUnexpectedToken(this.lookahead);
			_await = true;
			this.nextToken();
		}
		this.expect("(");
		if (this.match(";")) this.nextToken();
		else if (this.matchKeyword("var")) {
			init = this.createNode();
			this.nextToken();
			const previousAllowIn = this.context.allowIn;
			this.context.allowIn = false;
			const declarations = this.parseVariableDeclarationList({ inFor: true });
			this.context.allowIn = previousAllowIn;
			if (!_await && declarations.length === 1 && this.matchKeyword("in")) {
				const decl = declarations[0];
				if (decl.init && (decl.id.type === Syntax.ArrayPattern || decl.id.type === Syntax.ObjectPattern || this.context.strict)) this.tolerateError(Messages.ForInOfLoopInitializer, "for-in");
				init = this.finalize(init, new VariableDeclaration(declarations, "var"));
				this.nextToken();
				left = init;
				right = this.parseExpression();
				init = null;
			} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
				init = this.finalize(init, new VariableDeclaration(declarations, "var"));
				this.nextToken();
				left = init;
				right = this.parseAssignmentExpression();
				init = null;
				forIn = false;
			} else {
				init = this.finalize(init, new VariableDeclaration(declarations, "var"));
				this.expect(";");
			}
		} else if (this.matchKeyword("const") || this.matchKeyword("let")) {
			init = this.createNode();
			const kind = this.nextToken().value;
			if (!this.context.strict && this.lookahead.value === "in") {
				init = this.finalize(init, new Identifier(kind));
				this.nextToken();
				left = init;
				right = this.parseExpression();
				init = null;
			} else {
				const previousAllowIn = this.context.allowIn;
				this.context.allowIn = false;
				const declarations = this.parseBindingList(kind, { inFor: true });
				this.context.allowIn = previousAllowIn;
				if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
					init = this.finalize(init, new VariableDeclaration(declarations, kind));
					this.nextToken();
					left = init;
					right = this.parseExpression();
					init = null;
				} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
					init = this.finalize(init, new VariableDeclaration(declarations, kind));
					this.nextToken();
					left = init;
					right = this.parseAssignmentExpression();
					init = null;
					forIn = false;
				} else {
					this.consumeSemicolon();
					init = this.finalize(init, new VariableDeclaration(declarations, kind));
				}
			}
		} else {
			const initStartToken = this.lookahead;
			const previousIsBindingElement = this.context.isBindingElement;
			const previousIsAssignmentTarget = this.context.isAssignmentTarget;
			const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
			const previousAllowIn = this.context.allowIn;
			this.context.allowIn = false;
			init = this.inheritCoverGrammar(this.parseAssignmentExpression);
			this.context.allowIn = previousAllowIn;
			if (this.matchKeyword("in")) {
				if (!this.context.isAssignmentTarget || init.type === Syntax.AssignmentExpression) this.tolerateError(Messages.InvalidLHSInForIn);
				this.nextToken();
				this.reinterpretExpressionAsPattern(init);
				left = init;
				right = this.parseExpression();
				init = null;
			} else if (this.matchContextualKeyword("of")) {
				if (!this.context.isAssignmentTarget || init.type === Syntax.AssignmentExpression) this.tolerateError(Messages.InvalidLHSInForLoop);
				this.nextToken();
				this.reinterpretExpressionAsPattern(init);
				left = init;
				right = this.parseAssignmentExpression();
				init = null;
				forIn = false;
			} else {
				this.context.isBindingElement = previousIsBindingElement;
				this.context.isAssignmentTarget = previousIsAssignmentTarget;
				this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
				if (this.match(",")) {
					const initSeq = [init];
					while (this.match(",")) {
						this.nextToken();
						initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
					}
					init = this.finalize(this.startNode(initStartToken), new SequenceExpression(initSeq));
				}
				this.expect(";");
			}
		}
		if (typeof left === "undefined") {
			if (!this.match(";")) test = this.isolateCoverGrammar(this.parseExpression);
			this.expect(";");
			if (!this.match(")")) update = this.isolateCoverGrammar(this.parseExpression);
		}
		let body;
		if (!this.match(")") && this.config.tolerant) {
			this.tolerateUnexpectedToken(this.nextToken());
			body = this.finalize(this.createNode(), new EmptyStatement());
		} else {
			this.expect(")");
			this.tolerateInvalidLoopStatement();
			const previousInIteration = this.context.inIteration;
			this.context.inIteration = true;
			body = this.isolateCoverGrammar(this.parseStatement);
			this.context.inIteration = previousInIteration;
		}
		return typeof left === "undefined" ? this.finalize(node, new ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new ForInStatement(left, right, body)) : this.finalize(node, new ForOfStatement(left, right, body, _await));
	}
	parseContinueStatement() {
		const node = this.createNode();
		this.expectKeyword("continue");
		let label = null;
		if (this.lookahead.type === 3 && !this.hasLineTerminator) {
			const id = this.parseVariableIdentifier();
			label = id;
			const key = "$" + id.name;
			if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(Messages.UnknownLabel, id.name);
		}
		this.consumeSemicolon();
		if (label === null && !this.context.inIteration) this.throwError(Messages.IllegalContinue);
		return this.finalize(node, new ContinueStatement(label));
	}
	parseBreakStatement() {
		const node = this.createNode();
		this.expectKeyword("break");
		let label = null;
		if (this.lookahead.type === 3 && !this.hasLineTerminator) {
			const id = this.parseVariableIdentifier();
			const key = "$" + id.name;
			if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(Messages.UnknownLabel, id.name);
			label = id;
		}
		this.consumeSemicolon();
		if (label === null && !this.context.inIteration && !this.context.inSwitch) this.throwError(Messages.IllegalBreak);
		return this.finalize(node, new BreakStatement(label));
	}
	parseReturnStatement() {
		if (!this.context.inFunctionBody) this.tolerateError(Messages.IllegalReturn);
		const node = this.createNode();
		this.expectKeyword("return");
		const argument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10 ? this.parseExpression() : null;
		this.consumeSemicolon();
		return this.finalize(node, new ReturnStatement$1(argument));
	}
	parseWithStatement() {
		if (this.context.strict) this.tolerateError(Messages.StrictModeWith);
		const node = this.createNode();
		let body;
		this.expectKeyword("with");
		this.expect("(");
		const object = this.parseExpression();
		if (!this.match(")") && this.config.tolerant) {
			this.tolerateUnexpectedToken(this.nextToken());
			body = this.finalize(this.createNode(), new EmptyStatement());
		} else {
			this.expect(")");
			body = this.parseStatement();
		}
		return this.finalize(node, new WithStatement(object, body));
	}
	parseSwitchCase() {
		const node = this.createNode();
		let test;
		if (this.matchKeyword("default")) {
			this.nextToken();
			test = null;
		} else {
			this.expectKeyword("case");
			test = this.parseExpression();
		}
		this.expect(":");
		const consequent = [];
		while (true) {
			if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) break;
			consequent.push(this.parseStatementListItem());
		}
		return this.finalize(node, new SwitchCase(test, consequent));
	}
	parseSwitchStatement() {
		const node = this.createNode();
		this.expectKeyword("switch");
		this.expect("(");
		const discriminant = this.parseExpression();
		this.expect(")");
		const previousInSwitch = this.context.inSwitch;
		this.context.inSwitch = true;
		const cases = [];
		let defaultFound = false;
		this.expect("{");
		while (true) {
			if (this.match("}")) break;
			const clause = this.parseSwitchCase();
			if (clause.test === null) {
				if (defaultFound) this.throwError(Messages.MultipleDefaultsInSwitch);
				defaultFound = true;
			}
			cases.push(clause);
		}
		this.expect("}");
		this.context.inSwitch = previousInSwitch;
		return this.finalize(node, new SwitchStatement(discriminant, cases));
	}
	parseLabelledStatement() {
		const node = this.createNode();
		const expr = this.parseExpression();
		let statement;
		if (expr.type === Syntax.Identifier && this.match(":")) {
			this.nextToken();
			const id = expr;
			const key = "$" + id.name;
			if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(Messages.Redeclaration, "Label", id.name);
			this.context.labelSet[key] = true;
			let body;
			if (this.matchKeyword("class")) {
				this.tolerateUnexpectedToken(this.lookahead);
				body = this.parseClassDeclaration();
			} else if (this.matchKeyword("function")) {
				const token = this.lookahead;
				const declaration = this.parseFunctionDeclaration();
				if (this.context.strict) this.tolerateUnexpectedToken(token, Messages.StrictFunction);
				else if (declaration.generator) this.tolerateUnexpectedToken(token, Messages.GeneratorInLegacyContext);
				body = declaration;
			} else body = this.parseStatement();
			delete this.context.labelSet[key];
			statement = new LabeledStatement(id, body);
		} else {
			this.consumeSemicolon();
			statement = new ExpressionStatement(expr);
		}
		return this.finalize(node, statement);
	}
	parseThrowStatement() {
		const node = this.createNode();
		this.expectKeyword("throw");
		if (this.hasLineTerminator) this.throwError(Messages.NewlineAfterThrow);
		const argument = this.parseExpression();
		this.consumeSemicolon();
		return this.finalize(node, new ThrowStatement(argument));
	}
	parseCatchClause() {
		const node = this.createNode();
		this.expectKeyword("catch");
		let param = null;
		if (this.match("(")) {
			this.expect("(");
			if (this.match(")")) this.throwUnexpectedToken(this.lookahead);
			const params = [];
			param = this.parsePattern(params);
			const paramMap = {};
			for (let i$2 = 0; i$2 < params.length; i$2++) {
				const key = "$" + params[i$2].value;
				if (Object.prototype.hasOwnProperty.call(paramMap, key)) this.tolerateError(Messages.DuplicateBinding, params[i$2].value);
				paramMap[key] = true;
			}
			if (this.context.strict && param.type === Syntax.Identifier) {
				if (this.scanner.isRestrictedWord(param.name)) this.tolerateError(Messages.StrictCatchVariable);
			}
			this.expect(")");
		}
		const body = this.parseBlock();
		return this.finalize(node, new CatchClause(param, body));
	}
	parseFinallyClause() {
		this.expectKeyword("finally");
		return this.parseBlock();
	}
	parseTryStatement() {
		const node = this.createNode();
		this.expectKeyword("try");
		const block = this.parseBlock();
		const handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
		const finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
		if (!handler && !finalizer) this.throwError(Messages.NoCatchOrFinally);
		return this.finalize(node, new TryStatement(block, handler, finalizer));
	}
	parseDebuggerStatement() {
		const node = this.createNode();
		this.expectKeyword("debugger");
		this.consumeSemicolon();
		return this.finalize(node, new DebuggerStatement());
	}
	parseStatement() {
		let statement;
		switch (this.lookahead.type) {
			case 1:
			case 5:
			case 6:
			case 8:
			case 10:
			case 9:
				statement = this.parseExpressionStatement();
				break;
			case 7:
				const value = this.lookahead.value;
				if (value === "{") statement = this.parseBlock();
				else if (value === "(") statement = this.parseExpressionStatement();
				else if (value === ";") statement = this.parseEmptyStatement();
				else statement = this.parseExpressionStatement();
				break;
			case 3:
				statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
				break;
			case 4:
				switch (this.lookahead.value) {
					case "break":
						statement = this.parseBreakStatement();
						break;
					case "continue":
						statement = this.parseContinueStatement();
						break;
					case "debugger":
						statement = this.parseDebuggerStatement();
						break;
					case "do":
						statement = this.parseDoWhileStatement();
						break;
					case "for":
						statement = this.parseForStatement();
						break;
					case "function":
						statement = this.parseFunctionDeclaration();
						break;
					case "if":
						statement = this.parseIfStatement();
						break;
					case "return":
						statement = this.parseReturnStatement();
						break;
					case "switch":
						statement = this.parseSwitchStatement();
						break;
					case "throw":
						statement = this.parseThrowStatement();
						break;
					case "try":
						statement = this.parseTryStatement();
						break;
					case "var":
						statement = this.parseVariableStatement();
						break;
					case "while":
						statement = this.parseWhileStatement();
						break;
					case "with":
						statement = this.parseWithStatement();
						break;
					default:
						statement = this.parseExpressionStatement();
						break;
				}
				break;
			default: statement = this.throwUnexpectedToken(this.lookahead);
		}
		return statement;
	}
	parseFunctionSourceElements() {
		const node = this.createNode();
		this.expect("{");
		const body = this.parseDirectivePrologues();
		const previousLabelSet = this.context.labelSet;
		const previousInIteration = this.context.inIteration;
		const previousInSwitch = this.context.inSwitch;
		const previousInFunctionBody = this.context.inFunctionBody;
		this.context.labelSet = {};
		this.context.inIteration = false;
		this.context.inSwitch = false;
		this.context.inFunctionBody = true;
		while (this.lookahead.type !== 2) {
			if (this.match("}")) break;
			body.push(this.parseStatementListItem());
		}
		this.expect("}");
		this.context.labelSet = previousLabelSet;
		this.context.inIteration = previousInIteration;
		this.context.inSwitch = previousInSwitch;
		this.context.inFunctionBody = previousInFunctionBody;
		return this.finalize(node, new BlockStatement(body));
	}
	validateParam(options, param, name) {
		const key = "$" + name;
		if (this.context.strict) {
			if (this.scanner.isRestrictedWord(name)) {
				options.stricted = param;
				options.message = Messages.StrictParamName;
			}
			if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
				options.stricted = param;
				options.hasDuplicateParameterNames = true;
			}
		} else if (!options.firstRestricted) {
			if (this.scanner.isRestrictedWord(name)) {
				options.firstRestricted = param;
				options.message = Messages.StrictParamName;
			} else if (this.scanner.isStrictModeReservedWord(name)) {
				options.firstRestricted = param;
				options.message = Messages.StrictReservedWord;
			} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
				options.stricted = param;
				options.hasDuplicateParameterNames = true;
			}
		}
		/* istanbul ignore next */
		if (typeof Object.defineProperty === "function") Object.defineProperty(options.paramSet, key, {
			value: true,
			enumerable: true,
			writable: true,
			configurable: true
		});
		else options.paramSet[key] = true;
	}
	parseRestElement(params) {
		const node = this.createNode();
		this.expect("...");
		const arg = this.parsePattern(params);
		if (this.match("=")) this.throwError(Messages.DefaultRestParameter);
		if (!this.match(")")) this.throwError(Messages.ParameterAfterRestParameter);
		return this.finalize(node, new RestElement(arg));
	}
	parseFormalParameter(options) {
		const params = [];
		const param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
		for (let i$2 = 0; i$2 < params.length; i$2++) this.validateParam(options, params[i$2], params[i$2].value);
		options.simple = options.simple && param instanceof Identifier;
		options.params.push(param);
	}
	parseFormalParameters(firstRestricted) {
		const options = {
			simple: true,
			hasDuplicateParameterNames: false,
			params: [],
			firstRestricted
		};
		this.expect("(");
		if (!this.match(")")) {
			options.paramSet = {};
			while (this.lookahead.type !== 2) {
				this.parseFormalParameter(options);
				if (this.match(")")) break;
				this.expect(",");
				if (this.match(")")) break;
			}
		}
		this.expect(")");
		if (options.hasDuplicateParameterNames) {
			if (this.context.strict || this.context.isAsync || !options.simple) this.throwError(Messages.DuplicateParameter);
		}
		return {
			simple: options.simple,
			params: options.params,
			stricted: options.stricted,
			firstRestricted: options.firstRestricted,
			message: options.message
		};
	}
	matchAsyncFunction() {
		let match$1 = this.matchContextualKeyword("async");
		if (match$1) {
			const state = this.scanner.saveState();
			this.scanner.scanComments();
			const next = this.scanner.lex();
			this.scanner.restoreState(state);
			match$1 = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
		}
		return match$1;
	}
	parseFunctionDeclaration(identifierIsOptional) {
		const node = this.createNode();
		const isAsync$1 = this.matchContextualKeyword("async");
		if (isAsync$1) {
			if (this.context.inIteration) this.tolerateError(Messages.AsyncFunctionInSingleStatementContext);
			this.nextToken();
		}
		this.expectKeyword("function");
		const isGenerator = this.match("*");
		if (isGenerator) this.nextToken();
		let message;
		let id = null;
		let firstRestricted = null;
		if (!identifierIsOptional || !this.match("(")) {
			const token = this.lookahead;
			id = this.parseVariableIdentifier();
			if (this.context.strict) {
				if (this.scanner.isRestrictedWord(token.value)) this.tolerateUnexpectedToken(token, Messages.StrictFunctionName);
			} else if (this.scanner.isRestrictedWord(token.value)) {
				firstRestricted = token;
				message = Messages.StrictFunctionName;
			} else if (this.scanner.isStrictModeReservedWord(token.value)) {
				firstRestricted = token;
				message = Messages.StrictReservedWord;
			}
		}
		const previousIsAsync = this.context.isAsync;
		const previousAllowYield = this.context.allowYield;
		this.context.isAsync = isAsync$1;
		this.context.allowYield = !isGenerator;
		const formalParameters = this.parseFormalParameters(firstRestricted);
		const params = formalParameters.params;
		const stricted = formalParameters.stricted;
		firstRestricted = formalParameters.firstRestricted;
		if (formalParameters.message) message = formalParameters.message;
		const previousStrict = this.context.strict;
		const previousAllowStrictDirective = this.context.allowStrictDirective;
		this.context.allowStrictDirective = formalParameters.simple;
		const body = this.parseFunctionSourceElements();
		if (this.context.strict && firstRestricted) this.throwUnexpectedToken(firstRestricted, message);
		if (this.context.strict && stricted) this.tolerateUnexpectedToken(stricted, message);
		this.context.strict = previousStrict;
		this.context.allowStrictDirective = previousAllowStrictDirective;
		this.context.isAsync = previousIsAsync;
		this.context.allowYield = previousAllowYield;
		return isAsync$1 ? this.finalize(node, new AsyncFunctionDeclaration(id, params, body, isGenerator)) : this.finalize(node, new FunctionDeclaration(id, params, body, isGenerator));
	}
	parseFunctionExpression() {
		const node = this.createNode();
		const isAsync$1 = this.matchContextualKeyword("async");
		if (isAsync$1) this.nextToken();
		this.expectKeyword("function");
		const isGenerator = this.match("*");
		if (isGenerator) this.nextToken();
		let message;
		let id = null;
		let firstRestricted;
		const previousIsAsync = this.context.isAsync;
		const previousAllowYield = this.context.allowYield;
		this.context.isAsync = isAsync$1;
		this.context.allowYield = !isGenerator;
		if (!this.match("(")) {
			const token = this.lookahead;
			id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
			if (this.context.strict) {
				if (this.scanner.isRestrictedWord(token.value)) this.tolerateUnexpectedToken(token, Messages.StrictFunctionName);
			} else if (this.scanner.isRestrictedWord(token.value)) {
				firstRestricted = token;
				message = Messages.StrictFunctionName;
			} else if (this.scanner.isStrictModeReservedWord(token.value)) {
				firstRestricted = token;
				message = Messages.StrictReservedWord;
			}
		}
		const formalParameters = this.parseFormalParameters(firstRestricted);
		const params = formalParameters.params;
		const stricted = formalParameters.stricted;
		firstRestricted = formalParameters.firstRestricted;
		if (formalParameters.message) message = formalParameters.message;
		const previousStrict = this.context.strict;
		const previousAllowStrictDirective = this.context.allowStrictDirective;
		this.context.allowStrictDirective = formalParameters.simple;
		const body = this.parseFunctionSourceElements();
		if (this.context.strict && firstRestricted) this.throwUnexpectedToken(firstRestricted, message);
		if (this.context.strict && stricted) this.tolerateUnexpectedToken(stricted, message);
		this.context.strict = previousStrict;
		this.context.allowStrictDirective = previousAllowStrictDirective;
		this.context.isAsync = previousIsAsync;
		this.context.allowYield = previousAllowYield;
		return this.finalize(node, new FunctionExpression(id, params, body, isGenerator, isAsync$1));
	}
	parseDirective() {
		const token = this.lookahead;
		const node = this.createNode();
		const expr = this.parseExpression();
		const directive = expr.type === Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
		this.consumeSemicolon();
		return this.finalize(node, directive ? new Directive(expr, directive) : new ExpressionStatement(expr));
	}
	parseDirectivePrologues() {
		let firstRestricted = null;
		const body = [];
		while (true) {
			const token = this.lookahead;
			if (token.type !== 8) break;
			const statement = this.parseDirective();
			body.push(statement);
			const directive = statement.directive;
			if (typeof directive !== "string") break;
			if (directive === "use strict") {
				this.context.strict = true;
				if (firstRestricted) this.tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
				if (!this.context.allowStrictDirective) this.tolerateUnexpectedToken(token, Messages.IllegalLanguageModeDirective);
			} else if (!firstRestricted && token.octal) firstRestricted = token;
		}
		return body;
	}
	qualifiedPropertyName(token) {
		switch (token.type) {
			case 3:
			case 8:
			case 1:
			case 5:
			case 6:
			case 4: return true;
			case 7: return token.value === "[" || token.value === "#";
		}
		return false;
	}
	parseGetterMethod() {
		const node = this.createNode();
		const isGenerator = false;
		const previousAllowYield = this.context.allowYield;
		this.context.allowYield = true;
		const formalParameters = this.parseFormalParameters();
		if (formalParameters.params.length > 0) this.tolerateError(Messages.BadGetterArity);
		const method$1 = this.parsePropertyMethod(formalParameters);
		this.context.allowYield = previousAllowYield;
		return this.finalize(node, new FunctionExpression(null, formalParameters.params, method$1, isGenerator, false));
	}
	parseSetterMethod() {
		const node = this.createNode();
		const isGenerator = false;
		const previousAllowYield = this.context.allowYield;
		this.context.allowYield = true;
		const formalParameters = this.parseFormalParameters();
		if (formalParameters.params.length !== 1) this.tolerateError(Messages.BadSetterArity);
		else if (formalParameters.params[0] instanceof RestElement) this.tolerateError(Messages.BadSetterRestParameter);
		const method$1 = this.parsePropertyMethod(formalParameters);
		this.context.allowYield = previousAllowYield;
		return this.finalize(node, new FunctionExpression(null, formalParameters.params, method$1, isGenerator, false));
	}
	parseGeneratorMethod(isAsync$1) {
		const node = this.createNode();
		const isGenerator = true;
		const previousAllowYield = this.context.allowYield;
		this.context.allowYield = true;
		const params = this.parseFormalParameters();
		this.context.allowYield = false;
		const method$1 = this.parsePropertyMethod(params);
		this.context.allowYield = previousAllowYield;
		return this.finalize(node, new FunctionExpression(null, params.params, method$1, isGenerator, isAsync$1));
	}
	isStartOfExpression() {
		let start = true;
		const value = this.lookahead.value;
		switch (this.lookahead.type) {
			case 7:
				start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
				break;
			case 4:
				start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
				break;
		}
		return start;
	}
	parseYieldExpression() {
		const node = this.createNode();
		this.expectKeyword("yield");
		let argument = null;
		let delegate = false;
		if (!this.hasLineTerminator) {
			const previousAllowYield = this.context.allowYield;
			this.context.allowYield = false;
			delegate = this.match("*");
			if (delegate) {
				this.nextToken();
				argument = this.parseAssignmentExpression();
			} else if (this.isStartOfExpression()) argument = this.parseAssignmentExpression();
			this.context.allowYield = previousAllowYield;
		}
		return this.finalize(node, new YieldExpression(argument, delegate));
	}
	parseStaticBlock() {
		const node = this.createNode();
		this.expect("{");
		const block = [];
		while (true) {
			if (this.match("}")) break;
			block.push(this.parseStatementListItem());
		}
		this.expect("}");
		return this.finalize(node, new StaticBlock(block));
	}
	parseDecorator() {
		const node = this.createNode();
		this.expect("@");
		const previousStrict = this.context.strict;
		const previousAllowYield = this.context.allowYield;
		const previousIsAsync = this.context.isAsync;
		this.context.strict = false;
		this.context.allowYield = true;
		this.context.isAsync = false;
		const expression = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
		this.context.strict = previousStrict;
		this.context.allowYield = previousAllowYield;
		this.context.isAsync = previousIsAsync;
		if (this.match(";")) this.throwError(Messages.NoSemicolonAfterDecorator);
		return this.finalize(node, new Decorator(expression));
	}
	parseDecorators() {
		let decorators = null;
		while (this.match("@")) {
			if (decorators == null) decorators = [];
			decorators.push(this.parseDecorator());
		}
		return decorators;
	}
	parseClassElement(hasConstructor) {
		let token = this.lookahead;
		const node = this.createNode();
		const previousInConstructor = this.context.inConstructor;
		let kind = "";
		let key = null;
		let value = null;
		let computed = false;
		let method$1 = false;
		let isStatic = false;
		let isAsync$1 = false;
		let isGenerator = false;
		let isPrivate = false;
		const decorators = this.parseDecorators();
		if (decorators) token = this.lookahead;
		if (this.match("*")) this.nextToken();
		else {
			computed = this.match("[");
			if (this.match("#")) {
				isPrivate = true;
				this.nextToken();
				token = this.lookahead;
			}
			key = this.parseObjectPropertyKey(isPrivate);
			const id = key;
			this.context.inConstructor = token.type === 3 && token.value === "constructor";
			if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
				token = this.lookahead;
				isStatic = true;
				computed = this.match("[");
				if (this.match("*")) {
					this.nextToken();
					if (this.match("#")) {
						isPrivate = true;
						this.nextToken();
						token = this.lookahead;
					}
				} else {
					if (this.match("#")) {
						isPrivate = true;
						this.nextToken();
						token = this.lookahead;
					}
					key = this.parseObjectPropertyKey(isPrivate);
				}
			}
			if (id.name === "static" && this.match("{")) return this.parseStaticBlock();
			if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
				const punctuator = this.lookahead.value;
				if (punctuator !== ":" && punctuator !== "(") {
					isAsync$1 = true;
					isGenerator = this.match("*");
					if (isGenerator) this.nextToken();
					token = this.lookahead;
					computed = this.match("[");
					if (this.match("*")) {
						this.nextToken();
						if (this.match("#")) {
							isPrivate = true;
							this.nextToken();
						}
					} else {
						if (this.match("#")) {
							isPrivate = true;
							this.nextToken();
							token = this.lookahead;
						}
						key = this.parseObjectPropertyKey(isPrivate);
					}
					if (token.type === 3 && token.value === "constructor" && !isStatic) this.tolerateUnexpectedToken(token, Messages.ConstructorIsAsync);
				}
			}
		}
		if (token.type === 3 && token.value === "constructor" && isPrivate) this.tolerateUnexpectedToken(token, Messages.ConstructorIsPrivate);
		const lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
		if (token.type === 3 || token.type === 8) {
			if (token.value === "get" && lookaheadPropertyKey) {
				kind = "get";
				if (this.match("#")) {
					isPrivate = true;
					this.nextToken();
					token = this.lookahead;
				}
				computed = this.match("[");
				key = this.parseObjectPropertyKey(isPrivate);
				this.context.allowYield = false;
				value = this.parseGetterMethod();
			} else if (token.value === "set" && lookaheadPropertyKey) {
				kind = "set";
				if (this.match("#")) {
					isPrivate = true;
					this.nextToken();
					token = this.lookahead;
				}
				computed = this.match("[");
				key = this.parseObjectPropertyKey(isPrivate);
				value = this.parseSetterMethod();
			} else if (!this.match("(")) {
				kind = "property";
				computed = false;
				if (this.match("=")) {
					this.nextToken();
					value = this.isolateCoverGrammar(this.parseAssignmentExpression);
				}
			}
		} else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
			kind = "init";
			computed = this.match("[");
			key = this.parseObjectPropertyKey(isPrivate);
			value = this.parseGeneratorMethod(isAsync$1);
			method$1 = true;
		} else if (token.type === 7 && token.value === "[" && !this.match("(")) {
			kind = "property";
			computed = true;
			if (this.match("=")) {
				this.nextToken();
				value = this.isolateCoverGrammar(this.parseAssignmentExpression);
			}
		}
		if (!kind && key && this.match("(")) {
			const previousInClassConstructor = this.context.inClassConstructor;
			this.context.inClassConstructor = token.value === "constructor";
			kind = "init";
			value = isAsync$1 ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);
			this.context.inClassConstructor = previousInClassConstructor;
			method$1 = true;
		}
		if (!kind) this.throwUnexpectedToken(this.lookahead);
		if (kind === "init") kind = "method";
		if (!computed) {
			if (isStatic && this.isPropertyKey(key, "prototype")) this.throwUnexpectedToken(token, Messages.StaticPrototype);
			if (!isStatic && this.isPropertyKey(key, "constructor")) {
				if (kind !== "method" || !method$1 || value && value.generator) this.throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
				if (hasConstructor.value) this.throwUnexpectedToken(token, Messages.DuplicateConstructor);
				else hasConstructor.value = true;
				kind = "constructor";
			}
		}
		this.context.inConstructor = previousInConstructor;
		if (kind === "property") {
			this.consumeSemicolon();
			return this.finalize(node, new PropertyDefinition(key, computed, value, isStatic, decorators));
		} else return this.finalize(node, new MethodDefinition(key, computed, value, kind, isStatic, decorators));
	}
	parseClassElementList() {
		const body = [];
		const hasConstructor = { value: false };
		this.expect("{");
		while (!this.match("}")) if (this.match(";")) this.nextToken();
		else body.push(this.parseClassElement(hasConstructor));
		this.expect("}");
		return body;
	}
	parseClassBody() {
		const node = this.createNode();
		const elementList = this.parseClassElementList();
		return this.finalize(node, new ClassBody(elementList));
	}
	parseClassDeclaration(identifierIsOptional) {
		const node = this.createNode();
		const previousStrict = this.context.strict;
		const previousAllowSuper = this.context.allowSuper;
		this.context.strict = true;
		this.expectKeyword("class");
		const id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
		let superClass = null;
		if (this.matchKeyword("extends")) {
			this.nextToken();
			superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			this.context.allowSuper = true;
		}
		const classBody = this.parseClassBody();
		this.context.allowSuper = previousAllowSuper;
		this.context.strict = previousStrict;
		return this.finalize(node, new ClassDeclaration(id, superClass, classBody, this.context.decorators));
	}
	parseClassExpression() {
		const node = this.createNode();
		const previousStrict = this.context.strict;
		this.context.strict = true;
		this.expectKeyword("class");
		const id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
		let superClass = null;
		if (this.matchKeyword("extends")) {
			this.nextToken();
			superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			this.context.allowSuper = true;
		}
		const classBody = this.parseClassBody();
		this.context.strict = previousStrict;
		return this.finalize(node, new ClassExpression(id, superClass, classBody, this.context.decorators));
	}
	parseModule() {
		this.context.strict = true;
		this.context.isModule = true;
		this.scanner.isModule = true;
		const node = this.createNode();
		const body = this.parseDirectivePrologues();
		while (this.lookahead.type !== 2) body.push(this.parseStatementListItem());
		return this.finalize(node, new Module(body));
	}
	parseScript() {
		const node = this.createNode();
		const body = this.parseDirectivePrologues();
		while (this.lookahead.type !== 2) body.push(this.parseStatementListItem());
		return this.finalize(node, new Script(body));
	}
	parseImportAttributes() {
		if (this.lookahead.value === "assert") {
			this.nextToken();
			this.expect("{");
			const attributes = [];
			while (!this.match("}")) {
				attributes.push(this.parseImportAttribute());
				if (!this.match("}")) this.expectCommaSeparator();
			}
			this.expect("}");
			return attributes;
		}
		return null;
	}
	parseImportAttribute() {
		const node = this.createNode();
		if (this.lookahead.type !== 3) this.throwUnexpectedToken(this.nextToken());
		const key = this.parseIdentifierName();
		if (!this.match(":")) this.throwUnexpectedToken(this.nextToken());
		this.nextToken();
		const literalToken = this.nextToken();
		const raw = this.getTokenRaw(literalToken);
		const value = this.finalize(node, new Literal(literalToken.value, raw));
		return this.finalize(node, new ImportAttribute(key, value));
	}
	parseModuleSpecifier() {
		const node = this.createNode();
		if (this.lookahead.type !== 8) this.throwError(Messages.InvalidModuleSpecifier);
		const token = this.nextToken();
		const raw = this.getTokenRaw(token);
		if (!Character.isStringWellFormedUnicode(token.value)) this.throwError(Messages.InvalidModuleSpecifier);
		return this.finalize(node, new Literal(token.value, raw));
	}
	parseImportSpecifier() {
		const node = this.createNode();
		let imported;
		let local;
		if (this.lookahead.type === 3) {
			imported = this.parseVariableIdentifier();
			local = imported;
			if (this.matchContextualKeyword("as")) {
				this.nextToken();
				local = this.parseVariableIdentifier();
			}
		} else {
			imported = this.lookahead.type == 8 ? this.parseModuleSpecifier() : this.parseIdentifierName();
			local = imported;
			if (this.matchContextualKeyword("as")) {
				this.nextToken();
				local = this.parseVariableIdentifier();
			} else this.throwUnexpectedToken(this.nextToken());
		}
		return this.finalize(node, new ImportSpecifier(local, imported));
	}
	parseNamedImports() {
		this.expect("{");
		const specifiers = [];
		while (!this.match("}")) {
			specifiers.push(this.parseImportSpecifier());
			if (!this.match("}")) this.expect(",");
		}
		this.expect("}");
		return specifiers;
	}
	parseImportDefaultSpecifier() {
		const node = this.createNode();
		const local = this.parseIdentifierName();
		return this.finalize(node, new ImportDefaultSpecifier(local));
	}
	parseImportNamespaceSpecifier() {
		const node = this.createNode();
		this.expect("*");
		if (!this.matchContextualKeyword("as")) this.throwError(Messages.NoAsAfterImportNamespace);
		if (this.lookahead.escaped) this.throwError(Messages.NoAsAndFromEscapeSequences);
		this.nextToken();
		const local = this.parseIdentifierName();
		return this.finalize(node, new ImportNamespaceSpecifier(local));
	}
	parseImportDeclaration() {
		if (this.context.inFunctionBody) this.throwError(Messages.IllegalImportDeclaration);
		const node = this.createNode();
		this.expectKeyword("import");
		let src;
		let specifiers = [];
		if (this.lookahead.type === 8) src = this.parseModuleSpecifier();
		else {
			if (this.match("{")) specifiers = specifiers.concat(this.parseNamedImports());
			else if (this.match("*")) specifiers.push(this.parseImportNamespaceSpecifier());
			else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
				specifiers.push(this.parseImportDefaultSpecifier());
				if (this.match(",")) {
					this.nextToken();
					if (this.match("*")) specifiers.push(this.parseImportNamespaceSpecifier());
					else if (this.match("{")) specifiers = specifiers.concat(this.parseNamedImports());
					else this.throwUnexpectedToken(this.lookahead);
				}
			} else this.throwUnexpectedToken(this.nextToken());
			if (!this.matchContextualKeyword("from")) {
				const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;
				this.throwError(message, this.lookahead.value);
			}
			this.nextToken();
			src = this.parseModuleSpecifier();
		}
		const attributes = this.parseImportAttributes();
		this.consumeSemicolon();
		return this.finalize(node, new ImportDeclaration(specifiers, src, attributes));
	}
	parseExportSpecifier() {
		const node = this.createNode();
		const local = this.lookahead.type == 8 ? this.parseModuleSpecifier() : this.parseIdentifierName();
		let exported = local;
		if (this.matchContextualKeyword("as")) {
			if (this.lookahead.escaped) this.throwError(Messages.NoAsAndFromEscapeSequences);
			this.nextToken();
			exported = this.lookahead.type == 8 ? this.parseModuleSpecifier() : this.parseIdentifierName();
		}
		return this.finalize(node, new ExportSpecifier(local, exported));
	}
	parseExportDeclaration() {
		if (this.context.inFunctionBody) this.throwError(Messages.IllegalExportDeclaration);
		const node = this.createNode();
		this.expectKeyword("export");
		let exportDeclaration;
		if (this.matchKeyword("default")) {
			this.nextToken();
			if (this.matchKeyword("function")) {
				const declaration = this.parseFunctionDeclaration(true);
				exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));
			} else if (this.matchKeyword("class")) {
				const declaration = this.parseClassDeclaration(true);
				exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));
			} else if (this.matchContextualKeyword("async")) {
				const declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
				exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));
			} else {
				if (this.matchContextualKeyword("from")) this.throwError(Messages.UnexpectedToken, this.lookahead.value);
				const declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
				this.consumeSemicolon();
				exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));
			}
		} else if (this.match("*")) {
			this.nextToken();
			let exported = null;
			if (this.matchContextualKeyword("as")) {
				if (this.lookahead.escaped) this.throwError(Messages.NoAsAndFromEscapeSequences);
				this.nextToken();
				exported = this.lookahead.type == 8 ? this.parseModuleSpecifier() : this.parseIdentifierName();
			}
			if (!this.matchContextualKeyword("from")) {
				const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;
				this.throwError(message, this.lookahead.value);
			}
			if (this.lookahead.escaped) this.throwError(Messages.NoAsAndFromEscapeSequences);
			this.nextToken();
			const src = this.parseModuleSpecifier();
			const attributes = this.parseImportAttributes();
			this.consumeSemicolon();
			exportDeclaration = this.finalize(node, new ExportAllDeclaration(src, exported, attributes));
		} else if (this.lookahead.type === 4) {
			let declaration;
			switch (this.lookahead.value) {
				case "let":
				case "const":
					declaration = this.parseLexicalDeclaration({ inFor: false });
					break;
				case "var":
				case "class":
				case "function":
					declaration = this.parseStatementListItem();
					break;
				default: this.throwUnexpectedToken(this.lookahead);
			}
			exportDeclaration = this.finalize(node, new ExportNamedDeclaration(declaration, [], null, null));
		} else if (this.matchAsyncFunction()) {
			const declaration = this.parseFunctionDeclaration();
			exportDeclaration = this.finalize(node, new ExportNamedDeclaration(declaration, [], null, null));
		} else {
			const specifiers = [];
			let source = null;
			let isExportFromIdentifier = false;
			let attributes = null;
			this.expect("{");
			while (!this.match("}")) {
				isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
				specifiers.push(this.parseExportSpecifier());
				if (!this.match("}")) this.expect(",");
			}
			this.expect("}");
			if (this.matchContextualKeyword("from")) {
				if (this.lookahead.escaped) this.throwError(Messages.NoAsAndFromEscapeSequences);
				this.nextToken();
				source = this.parseModuleSpecifier();
				attributes = this.parseImportAttributes();
				this.consumeSemicolon();
			} else if (isExportFromIdentifier) {
				const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;
				this.throwError(message, this.lookahead.value);
			} else {
				attributes = this.parseImportAttributes();
				this.consumeSemicolon();
			}
			exportDeclaration = this.finalize(node, new ExportNamedDeclaration(null, specifiers, source, attributes));
		}
		return exportDeclaration;
	}
};
var XHTMLEntities = {
	quot: "\"",
	amp: "&",
	apos: "'",
	gt: ">",
	nbsp: "\xA0",
	iexcl: "¡",
	cent: "¢",
	pound: "£",
	curren: "¤",
	yen: "¥",
	brvbar: "¦",
	sect: "§",
	uml: "¨",
	copy: "©",
	ordf: "ª",
	laquo: "«",
	not: "¬",
	shy: "­",
	reg: "®",
	macr: "¯",
	deg: "°",
	plusmn: "±",
	sup2: "²",
	sup3: "³",
	acute: "´",
	micro: "µ",
	para: "¶",
	middot: "·",
	cedil: "¸",
	sup1: "¹",
	ordm: "º",
	raquo: "»",
	frac14: "¼",
	frac12: "½",
	frac34: "¾",
	iquest: "¿",
	Agrave: "À",
	Aacute: "Á",
	Acirc: "Â",
	Atilde: "Ã",
	Auml: "Ä",
	Aring: "Å",
	AElig: "Æ",
	Ccedil: "Ç",
	Egrave: "È",
	Eacute: "É",
	Ecirc: "Ê",
	Euml: "Ë",
	Igrave: "Ì",
	Iacute: "Í",
	Icirc: "Î",
	Iuml: "Ï",
	ETH: "Ð",
	Ntilde: "Ñ",
	Ograve: "Ò",
	Oacute: "Ó",
	Ocirc: "Ô",
	Otilde: "Õ",
	Ouml: "Ö",
	times: "×",
	Oslash: "Ø",
	Ugrave: "Ù",
	Uacute: "Ú",
	Ucirc: "Û",
	Uuml: "Ü",
	Yacute: "Ý",
	THORN: "Þ",
	szlig: "ß",
	agrave: "à",
	aacute: "á",
	acirc: "â",
	atilde: "ã",
	auml: "ä",
	aring: "å",
	aelig: "æ",
	ccedil: "ç",
	egrave: "è",
	eacute: "é",
	ecirc: "ê",
	euml: "ë",
	igrave: "ì",
	iacute: "í",
	icirc: "î",
	iuml: "ï",
	eth: "ð",
	ntilde: "ñ",
	ograve: "ò",
	oacute: "ó",
	ocirc: "ô",
	otilde: "õ",
	ouml: "ö",
	divide: "÷",
	oslash: "ø",
	ugrave: "ù",
	uacute: "ú",
	ucirc: "û",
	uuml: "ü",
	yacute: "ý",
	thorn: "þ",
	yuml: "ÿ",
	OElig: "Œ",
	oelig: "œ",
	Scaron: "Š",
	scaron: "š",
	Yuml: "Ÿ",
	fnof: "ƒ",
	circ: "ˆ",
	tilde: "˜",
	Alpha: "Α",
	Beta: "Β",
	Gamma: "Γ",
	Delta: "Δ",
	Epsilon: "Ε",
	Zeta: "Ζ",
	Eta: "Η",
	Theta: "Θ",
	Iota: "Ι",
	Kappa: "Κ",
	Lambda: "Λ",
	Mu: "Μ",
	Nu: "Ν",
	Xi: "Ξ",
	Omicron: "Ο",
	Pi: "Π",
	Rho: "Ρ",
	Sigma: "Σ",
	Tau: "Τ",
	Upsilon: "Υ",
	Phi: "Φ",
	Chi: "Χ",
	Psi: "Ψ",
	Omega: "Ω",
	alpha: "α",
	beta: "β",
	gamma: "γ",
	delta: "δ",
	epsilon: "ε",
	zeta: "ζ",
	eta: "η",
	theta: "θ",
	iota: "ι",
	kappa: "κ",
	lambda: "λ",
	mu: "μ",
	nu: "ν",
	xi: "ξ",
	omicron: "ο",
	pi: "π",
	rho: "ρ",
	sigmaf: "ς",
	sigma: "σ",
	tau: "τ",
	upsilon: "υ",
	phi: "φ",
	chi: "χ",
	psi: "ψ",
	omega: "ω",
	thetasym: "ϑ",
	upsih: "ϒ",
	piv: "ϖ",
	ensp: " ",
	emsp: " ",
	thinsp: " ",
	zwnj: "‌",
	zwj: "‍",
	lrm: "‎",
	rlm: "‏",
	ndash: "–",
	mdash: "—",
	lsquo: "‘",
	rsquo: "’",
	sbquo: "‚",
	ldquo: "“",
	rdquo: "”",
	bdquo: "„",
	dagger: "†",
	Dagger: "‡",
	bull: "•",
	hellip: "…",
	permil: "‰",
	prime: "′",
	Prime: "″",
	lsaquo: "‹",
	rsaquo: "›",
	oline: "‾",
	frasl: "⁄",
	euro: "€",
	image: "ℑ",
	weierp: "℘",
	real: "ℜ",
	trade: "™",
	alefsym: "ℵ",
	larr: "←",
	uarr: "↑",
	rarr: "→",
	darr: "↓",
	harr: "↔",
	crarr: "↵",
	lArr: "⇐",
	uArr: "⇑",
	rArr: "⇒",
	dArr: "⇓",
	hArr: "⇔",
	forall: "∀",
	part: "∂",
	exist: "∃",
	empty: "∅",
	nabla: "∇",
	isin: "∈",
	notin: "∉",
	ni: "∋",
	prod: "∏",
	sum: "∑",
	minus: "−",
	lowast: "∗",
	radic: "√",
	prop: "∝",
	infin: "∞",
	ang: "∠",
	and: "∧",
	or: "∨",
	cap: "∩",
	cup: "∪",
	int: "∫",
	there4: "∴",
	sim: "∼",
	cong: "≅",
	asymp: "≈",
	ne: "≠",
	equiv: "≡",
	le: "≤",
	ge: "≥",
	sub: "⊂",
	sup: "⊃",
	nsub: "⊄",
	sube: "⊆",
	supe: "⊇",
	oplus: "⊕",
	otimes: "⊗",
	perp: "⊥",
	sdot: "⋅",
	lceil: "⌈",
	rceil: "⌉",
	lfloor: "⌊",
	rfloor: "⌋",
	loz: "◊",
	spades: "♠",
	clubs: "♣",
	hearts: "♥",
	diams: "♦",
	lang: "⟨",
	rang: "⟩"
};
TokenName[100] = "JSXIdentifier";
TokenName[101] = "JSXText";
function getQualifiedElementName(elementName) {
	let qualifiedName;
	switch (elementName.type) {
		case JSXSyntax.JSXIdentifier:
			qualifiedName = elementName.name;
			break;
		case JSXSyntax.JSXNamespacedName:
			const ns = elementName;
			qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
			break;
		case JSXSyntax.JSXMemberExpression:
			const expr = elementName;
			qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
			break;
	}
	return qualifiedName;
}
var JSXParser = class extends Parser {
	constructor(code$1, options, delegate) {
		super(code$1, options, delegate);
	}
	parsePrimaryExpression() {
		return this.match("<") ? this.parseJSXRoot() : super.parsePrimaryExpression();
	}
	startJSX() {
		this.scanner.index = this.startMarker.index;
		this.scanner.lineNumber = this.startMarker.line;
		this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	}
	finishJSX() {
		this.nextToken();
	}
	reenterJSX() {
		this.startJSX();
		this.expectJSX("}");
		if (this.config.tokens) this.tokens.pop();
	}
	createJSXNode() {
		this.collectComments();
		return {
			index: this.scanner.index,
			line: this.scanner.lineNumber,
			column: this.scanner.index - this.scanner.lineStart
		};
	}
	createJSXChildNode() {
		return {
			index: this.scanner.index,
			line: this.scanner.lineNumber,
			column: this.scanner.index - this.scanner.lineStart
		};
	}
	scanXHTMLEntity(quote$1) {
		let result = "&";
		let valid = true;
		let terminated = false;
		let numeric = false;
		let hex = false;
		while (!this.scanner.eof() && valid && !terminated) {
			const ch = this.scanner.source[this.scanner.index];
			if (ch === quote$1) break;
			terminated = ch === ";";
			result += ch;
			++this.scanner.index;
			if (!terminated) switch (result.length) {
				case 2:
					numeric = ch === "#";
					break;
				case 3:
					if (numeric) {
						hex = ch === "x";
						valid = hex || Character.isDecimalDigit(ch.charCodeAt(0));
						numeric = numeric && !hex;
					}
					break;
				default:
					valid = valid && !(numeric && !Character.isDecimalDigit(ch.charCodeAt(0)));
					valid = valid && !(hex && !Character.isHexDigit(ch.charCodeAt(0)));
					break;
			}
		}
		if (valid && terminated && result.length > 2) {
			const str = result.substr(1, result.length - 2);
			if (numeric && str.length > 1) result = String.fromCharCode(parseInt(str.substr(1), 10));
			else if (hex && str.length > 2) result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
			else if (!numeric && !hex && XHTMLEntities[str]) result = XHTMLEntities[str];
		}
		return result;
	}
	lexJSX() {
		const cp = this.scanner.source.charCodeAt(this.scanner.index);
		if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) return {
			type: 7,
			value: this.scanner.source[this.scanner.index++],
			lineNumber: this.scanner.lineNumber,
			lineStart: this.scanner.lineStart,
			start: this.scanner.index - 1,
			end: this.scanner.index
		};
		if (cp === 34 || cp === 39) {
			const start = this.scanner.index;
			const quote$1 = this.scanner.source[this.scanner.index++];
			let str = "";
			while (!this.scanner.eof()) {
				const ch = this.scanner.source[this.scanner.index++];
				if (ch === quote$1) break;
				else if (ch === "&") str += this.scanXHTMLEntity(quote$1);
				else str += ch;
			}
			return {
				type: 8,
				value: str,
				lineNumber: this.scanner.lineNumber,
				lineStart: this.scanner.lineStart,
				start,
				end: this.scanner.index
			};
		}
		if (cp === 46) {
			const n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
			const n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
			const value = n1 === 46 && n2 === 46 ? "..." : ".";
			const start = this.scanner.index;
			this.scanner.index += value.length;
			return {
				type: 7,
				value,
				lineNumber: this.scanner.lineNumber,
				lineStart: this.scanner.lineStart,
				start,
				end: this.scanner.index
			};
		}
		if (cp === 96) return {
			type: 10,
			value: "",
			lineNumber: this.scanner.lineNumber,
			lineStart: this.scanner.lineStart,
			start: this.scanner.index,
			end: this.scanner.index
		};
		if (Character.isIdentifierStart(cp) && cp !== 92) {
			const start = this.scanner.index;
			++this.scanner.index;
			while (!this.scanner.eof()) {
				const ch = this.scanner.source.charCodeAt(this.scanner.index);
				if (Character.isIdentifierPart(ch) && ch !== 92) ++this.scanner.index;
				else if (ch === 45) ++this.scanner.index;
				else break;
			}
			return {
				type: 100,
				value: this.scanner.source.slice(start, this.scanner.index),
				lineNumber: this.scanner.lineNumber,
				lineStart: this.scanner.lineStart,
				start,
				end: this.scanner.index
			};
		}
		return this.scanner.lex();
	}
	nextJSXToken() {
		this.collectComments();
		this.startMarker.index = this.scanner.index;
		this.startMarker.line = this.scanner.lineNumber;
		this.startMarker.column = this.scanner.index - this.scanner.lineStart;
		const token = this.lexJSX();
		this.lastMarker.index = this.scanner.index;
		this.lastMarker.line = this.scanner.lineNumber;
		this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
		if (this.config.tokens) this.tokens.push(this.convertToken(token));
		return token;
	}
	nextJSXText() {
		this.startMarker.index = this.scanner.index;
		this.startMarker.line = this.scanner.lineNumber;
		this.startMarker.column = this.scanner.index - this.scanner.lineStart;
		const start = this.scanner.index;
		let text = "";
		while (!this.scanner.eof()) {
			const ch = this.scanner.source[this.scanner.index];
			if (ch === "{" || ch === "<") break;
			++this.scanner.index;
			text += ch;
			if (Character.isLineTerminator(ch.charCodeAt(0))) {
				++this.scanner.lineNumber;
				if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") ++this.scanner.index;
				this.scanner.lineStart = this.scanner.index;
			}
		}
		this.lastMarker.index = this.scanner.index;
		this.lastMarker.line = this.scanner.lineNumber;
		this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
		const token = {
			type: 101,
			value: text,
			lineNumber: this.scanner.lineNumber,
			lineStart: this.scanner.lineStart,
			start,
			end: this.scanner.index
		};
		if (text.length > 0 && this.config.tokens) this.tokens.push(this.convertToken(token));
		return token;
	}
	peekJSXToken() {
		const state = this.scanner.saveState();
		this.scanner.scanComments();
		const next = this.lexJSX();
		this.scanner.restoreState(state);
		return next;
	}
	expectJSX(value) {
		const token = this.nextJSXToken();
		if (token.type !== 7 || token.value !== value) this.throwUnexpectedToken(token);
	}
	matchJSX(value) {
		const next = this.peekJSXToken();
		return next.type === 7 && next.value === value;
	}
	parseJSXIdentifier() {
		const node = this.createJSXNode();
		const token = this.nextJSXToken();
		if (token.type !== 100) this.throwUnexpectedToken(token);
		return this.finalize(node, new JSXIdentifier(token.value));
	}
	parseJSXElementName() {
		const node = this.createJSXNode();
		let elementName = this.parseJSXIdentifier();
		if (this.matchJSX(":")) {
			const namespace = elementName;
			this.expectJSX(":");
			const name = this.parseJSXIdentifier();
			elementName = this.finalize(node, new JSXNamespacedName(namespace, name));
		} else if (this.matchJSX(".")) while (this.matchJSX(".")) {
			const object = elementName;
			this.expectJSX(".");
			const property$2 = this.parseJSXIdentifier();
			elementName = this.finalize(node, new JSXMemberExpression(object, property$2));
		}
		return elementName;
	}
	parseJSXAttributeName() {
		const node = this.createJSXNode();
		let attributeName;
		const identifier = this.parseJSXIdentifier();
		if (this.matchJSX(":")) {
			const namespace = identifier;
			this.expectJSX(":");
			const name = this.parseJSXIdentifier();
			attributeName = this.finalize(node, new JSXNamespacedName(namespace, name));
		} else attributeName = identifier;
		return attributeName;
	}
	parseJSXStringLiteralAttribute() {
		const node = this.createJSXNode();
		const token = this.nextJSXToken();
		if (token.type !== 8) this.throwUnexpectedToken(token);
		const raw = this.getTokenRaw(token);
		return this.finalize(node, new Literal(token.value, raw));
	}
	parseJSXExpressionAttribute() {
		const node = this.createJSXNode();
		this.expectJSX("{");
		this.finishJSX();
		if (this.match("}")) this.tolerateError("JSX attributes must only be assigned a non-empty expression");
		const expression = this.parseAssignmentExpression();
		this.reenterJSX();
		return this.finalize(node, new JSXExpressionContainer(expression));
	}
	parseJSXAttributeValue() {
		return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	}
	parseJSXNameValueAttribute() {
		const node = this.createJSXNode();
		const name = this.parseJSXAttributeName();
		let value = null;
		if (this.matchJSX("=")) {
			this.expectJSX("=");
			value = this.parseJSXAttributeValue();
		}
		return this.finalize(node, new JSXAttribute(name, value));
	}
	parseJSXSpreadAttribute() {
		const node = this.createJSXNode();
		this.expectJSX("{");
		this.expectJSX("...");
		this.finishJSX();
		const argument = this.parseAssignmentExpression();
		this.reenterJSX();
		return this.finalize(node, new JSXSpreadAttribute(argument));
	}
	parseJSXAttributes() {
		const attributes = [];
		while (!this.matchJSX("/") && !this.matchJSX(">")) {
			const attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
			attributes.push(attribute);
		}
		return attributes;
	}
	parseJSXOpeningElement() {
		const node = this.createJSXNode();
		this.expectJSX("<");
		if (this.matchJSX(">")) {
			this.expectJSX(">");
			return this.finalize(node, new JSXOpeningFragment(false));
		}
		const name = this.parseJSXElementName();
		const attributes = this.parseJSXAttributes();
		const selfClosing = this.matchJSX("/");
		if (selfClosing) this.expectJSX("/");
		this.expectJSX(">");
		return this.finalize(node, new JSXOpeningElement(name, selfClosing, attributes));
	}
	parseJSXBoundaryElement() {
		const node = this.createJSXNode();
		this.expectJSX("<");
		if (this.matchJSX("/")) {
			this.expectJSX("/");
			if (this.matchJSX(">")) {
				this.expectJSX(">");
				return this.finalize(node, new JSXClosingFragment());
			}
			const elementName = this.parseJSXElementName();
			this.expectJSX(">");
			return this.finalize(node, new JSXClosingElement(elementName));
		}
		const name = this.parseJSXElementName();
		const attributes = this.parseJSXAttributes();
		const selfClosing = this.matchJSX("/");
		if (selfClosing) this.expectJSX("/");
		this.expectJSX(">");
		return this.finalize(node, new JSXOpeningElement(name, selfClosing, attributes));
	}
	parseJSXEmptyExpression() {
		const node = this.createJSXChildNode();
		this.collectComments();
		this.lastMarker.index = this.scanner.index;
		this.lastMarker.line = this.scanner.lineNumber;
		this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
		return this.finalize(node, new JSXEmptyExpression());
	}
	parseJSXExpressionContainer() {
		const node = this.createJSXNode();
		this.expectJSX("{");
		let expression;
		if (this.matchJSX("}")) {
			expression = this.parseJSXEmptyExpression();
			this.expectJSX("}");
		} else {
			this.finishJSX();
			expression = this.parseAssignmentExpression();
			this.reenterJSX();
		}
		return this.finalize(node, new JSXExpressionContainer(expression));
	}
	parseJSXChildren() {
		const children$1 = [];
		while (!this.scanner.eof()) {
			const node = this.createJSXChildNode();
			const token = this.nextJSXText();
			if (token.start < token.end) {
				const raw = this.getTokenRaw(token);
				const child = this.finalize(node, new JSXText(token.value, raw));
				children$1.push(child);
			}
			if (this.scanner.source[this.scanner.index] === "{") {
				const container = this.parseJSXExpressionContainer();
				children$1.push(container);
			} else break;
		}
		return children$1;
	}
	parseComplexJSXElement(el) {
		const stack = [];
		while (!this.scanner.eof()) {
			el.children = el.children.concat(this.parseJSXChildren());
			const node = this.createJSXChildNode();
			const element = this.parseJSXBoundaryElement();
			if (element.type === JSXSyntax.JSXOpeningElement) {
				const opening = element;
				if (opening.selfClosing) {
					const child = this.finalize(node, new JSXElement(opening, [], null));
					el.children.push(child);
				} else {
					stack.push(el);
					el = {
						node,
						opening,
						closing: null,
						children: []
					};
				}
			}
			if (element.type === JSXSyntax.JSXClosingElement) {
				el.closing = element;
				const open = getQualifiedElementName(el.opening.name);
				if (open !== getQualifiedElementName(el.closing.name)) this.tolerateError("Expected corresponding JSX closing tag for %0", open);
				if (stack.length > 0) {
					const child = this.finalize(el.node, new JSXElement(el.opening, el.children, el.closing));
					el = stack[stack.length - 1];
					el.children.push(child);
					stack.pop();
				} else break;
			}
			if (element.type === JSXSyntax.JSXClosingFragment) {
				el.closing = element;
				if (el.opening.type !== JSXSyntax.JSXOpeningFragment) this.tolerateError("Expected corresponding JSX closing tag for jsx fragment");
				else break;
			}
		}
		return el;
	}
	parseJSXElement() {
		const node = this.createJSXNode();
		const opening = this.parseJSXOpeningElement();
		let children$1 = [];
		let closing = null;
		if (!opening.selfClosing) {
			const el = this.parseComplexJSXElement({
				node,
				opening,
				closing,
				children: children$1
			});
			children$1 = el.children;
			closing = el.closing;
		}
		return this.finalize(node, new JSXElement(opening, children$1, closing));
	}
	parseJSXRoot() {
		if (this.config.tokens) this.tokens.pop();
		this.startJSX();
		const element = this.parseJSXElement();
		this.finishJSX();
		return element;
	}
	isStartOfExpression() {
		return super.isStartOfExpression() || this.match("<");
	}
};
function parse(code$1, options, delegate) {
	let commentHandler = null;
	const proxyDelegate = (node, metadata) => {
		if (delegate) delegate(node, metadata);
		if (commentHandler) commentHandler.visit(node, metadata);
	};
	let parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
	let collectComment = false;
	if (options) {
		collectComment = typeof options.comment === "boolean" && options.comment;
		const attachComment = typeof options.attachComment === "boolean" && options.attachComment;
		if (collectComment || attachComment) {
			commentHandler = new CommentHandler();
			commentHandler.attach = attachComment;
			options.comment = true;
			parserDelegate = proxyDelegate;
		}
	}
	let isModule = false;
	if (options && typeof options.sourceType === "string") isModule = options.sourceType === "module";
	let parser;
	if (options && typeof options.jsx === "boolean" && options.jsx) parser = new JSXParser(code$1, options, parserDelegate);
	else parser = new Parser(code$1, options, parserDelegate);
	const ast = isModule ? parser.parseModule() : parser.parseScript();
	if (collectComment && commentHandler) ast.comments = commentHandler.comments;
	if (parser.config.tokens) ast.tokens = parser.tokens;
	if (parser.config.tolerant) ast.errors = parser.errorHandler.errors;
	return ast;
}
function parseScript(code$1, options, delegate) {
	const parsingOptions = options || {};
	parsingOptions.sourceType = "script";
	return parse(code$1, parsingOptions, delegate);
}
var import_browser = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = typeof self === "object" ? self.FormData : window.FormData;
})))());
require_merge();
var readStreamClasses = new Set([
	"ReadStream",
	"Readable",
	"ReadableStream"
]);
BigInt.prototype.toJSON = function() {
	return this.toString();
};
const isObjectEmpty = (obj) => {
	if (obj === void 0 || obj === null) return true;
	if (typeof obj === "object") {
		if (obj instanceof import_browser.default) return obj.getLengthSync() === 0;
		if (Array.isArray(obj)) return obj.length === 0;
		if (obj instanceof Set || obj instanceof Map) return obj.size === 0;
		if (ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer) return obj.byteLength === 0;
		if (Symbol.iterator in obj || readStreamClasses.has(obj.constructor.name)) return false;
		return Object.keys(obj).length === 0;
	}
	return true;
};
const deepCopy = (source, hash$1 = /* @__PURE__ */ new WeakMap(), path = "") => {
	const hasOwnProp = Object.prototype.hasOwnProperty.bind(source);
	if (typeof source !== "object" || source === null || typeof source === "function") return source;
	if (typeof source.toJSON === "function") return source.toJSON();
	if (hash$1.has(source)) return hash$1.get(source);
	if (Array.isArray(source)) {
		const clone$3 = [];
		const len$1 = source.length;
		for (let i$2 = 0; i$2 < len$1; i$2++) clone$3[i$2] = deepCopy(source[i$2], hash$1, path + `[${i$2}]`);
		return clone$3;
	}
	const clone$2 = Object.create(Object.getPrototypeOf({}));
	hash$1.set(source, clone$2);
	for (const i$2 in source) if (hasOwnProp(i$2)) clone$2[i$2] = deepCopy(source[i$2], hash$1, path + `.${i$2}`);
	return clone$2;
};
function syntaxNodeToValue(expression) {
	switch (expression?.type) {
		case Syntax.ObjectExpression: return Object.fromEntries(expression.properties.filter((prop) => prop.type === Syntax.Property).map(({ key, value }) => [syntaxNodeToValue(key), syntaxNodeToValue(value)]));
		case Syntax.Identifier: return expression.name;
		case Syntax.Literal: return expression.value;
		case Syntax.ArrayExpression: return expression.elements.map((exp) => syntaxNodeToValue(exp));
		default: return;
	}
}
function parseJSObject(objectAsString) {
	return syntaxNodeToValue(parse(`(${objectAsString})`).body.find((node) => node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.ObjectExpression)?.expression);
}
const jsonParse = (jsonString, options) => {
	try {
		return JSON.parse(jsonString);
	} catch (error$1) {
		if (options?.acceptJSObject) try {
			return parseJSObject(jsonString);
		} catch (e$1) {}
		if (options?.fallbackValue !== void 0) {
			if (options.fallbackValue instanceof Function) return options.fallbackValue();
			return options.fallbackValue;
		} else if (options?.errorMessage) throw new ApplicationError(options.errorMessage);
		throw error$1;
	}
};
const base64DecodeUTF8 = (str) => {
	try {
		const bytes = new Uint8Array(atob(str).split("").map((char) => char.charCodeAt(0)));
		return new TextDecoder("utf-8").decode(bytes);
	} catch (error$1) {
		console.warn("TextDecoder not available, using fallback method");
		return atob(str);
	}
};
const replaceCircularReferences = (value, knownObjects = /* @__PURE__ */ new WeakSet()) => {
	if (typeof value !== "object" || value === null || value instanceof RegExp) return value;
	if ("toJSON" in value && typeof value.toJSON === "function") return value.toJSON();
	if (knownObjects.has(value)) return "[Circular Reference]";
	knownObjects.add(value);
	const copy = Array.isArray(value) ? [] : {};
	for (const key in value) try {
		copy[key] = replaceCircularReferences(value[key], knownObjects);
	} catch (error$1) {
		if (error$1 instanceof TypeError && error$1.message.includes("Cannot assign to read only property")) {
			error("Error while replacing circular references: " + error$1.message, { error: error$1 });
			continue;
		}
		throw error$1;
	}
	knownObjects.delete(value);
	return copy;
};
const jsonStringify = (obj, options = {}) => {
	return JSON.stringify(options?.replaceCircularRefs ? replaceCircularReferences(obj) : obj);
};
const sleep = async (ms) => await new Promise((resolve) => {
	setTimeout(resolve, ms);
});
function randomInt(min$2, max$2) {
	if (max$2 === void 0) {
		max$2 = min$2;
		min$2 = 0;
	}
	return min$2 + crypto.getRandomValues(new Uint32Array(1))[0] % (max$2 - min$2);
}
function randomString(minLength$1, maxLength$1) {
	const length$1 = maxLength$1 === void 0 ? minLength$1 : randomInt(minLength$1, maxLength$1 + 1);
	return [...crypto.getRandomValues(new Uint32Array(length$1))].map((byte) => ALPHABET[byte % ALPHABET.length]).join("");
}
function hasKey(value, key) {
	return value !== null && typeof value === "object" && value.hasOwnProperty(key);
}
var unsafeObjectProperties = new Set([
	"__proto__",
	"prototype",
	"constructor",
	"getPrototypeOf"
]);
function isSafeObjectProperty(property$2) {
	return !unsafeObjectProperties.has(property$2);
}
var COMMUNITY_PACKAGE_NAME_REGEX = /^(?!@n8n\/)(@[\w.-]+\/)?n8n-nodes-(?!base\b)\b\w+/g;
function isCommunityPackageName(packageName) {
	COMMUNITY_PACKAGE_NAME_REGEX.lastIndex = 0;
	return !!COMMUNITY_PACKAGE_NAME_REGEX.exec(packageName);
}
require_xml2js();
var ExpressionExtensionError = class extends ExpressionError {};
var import_isObject = /* @__PURE__ */ __toESM(require_isObject());
const tryToParseNumber = (value) => {
	if (!!isNaN(Number(value))) throw new ApplicationError("Failed to parse value to number", { extra: { value } });
	return Number(value);
};
const tryToParseString = (value) => {
	if (typeof value === "object") return JSON.stringify(value);
	if (typeof value === "undefined") return "";
	if (typeof value === "string" || typeof value === "bigint" || typeof value === "boolean" || typeof value === "number") return value.toString();
	return String(value);
};
const tryToParseAlphanumericString = (value) => {
	const parsed = tryToParseString(value);
	if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(parsed)) throw new ApplicationError("Value is not a valid alphanumeric string", { extra: { value } });
	return parsed;
};
const tryToParseBoolean = (value) => {
	if (typeof value === "boolean") return value;
	if (typeof value === "string" && ["true", "false"].includes(value.toLowerCase())) return value.toLowerCase() === "true";
	if (!(typeof value === "string" && value.trim() === "")) {
		const num = Number(value);
		if (num === 0) return false;
		else if (num === 1) return true;
	}
	throw new ApplicationError("Failed to parse value as boolean", { extra: { value } });
};
const tryToParseDateTime = (value, defaultZone$1) => {
	if (DateTime.isDateTime(value) && value.isValid) return value;
	if (value instanceof Date) {
		const fromJSDate = DateTime.fromJSDate(value, { zone: defaultZone$1 });
		if (fromJSDate.isValid) return fromJSDate;
	}
	const dateString = String(value).trim();
	const isoDate = DateTime.fromISO(dateString, {
		zone: defaultZone$1,
		setZone: true
	});
	if (isoDate.isValid) return isoDate;
	const httpDate = DateTime.fromHTTP(dateString, {
		zone: defaultZone$1,
		setZone: true
	});
	if (httpDate.isValid) return httpDate;
	const rfc2822Date = DateTime.fromRFC2822(dateString, {
		zone: defaultZone$1,
		setZone: true
	});
	if (rfc2822Date.isValid) return rfc2822Date;
	const sqlDate = DateTime.fromSQL(dateString, {
		zone: defaultZone$1,
		setZone: true
	});
	if (sqlDate.isValid) return sqlDate;
	const parsedDateTime = DateTime.fromMillis(Date.parse(dateString), { zone: defaultZone$1 });
	if (parsedDateTime.isValid) return parsedDateTime;
	throw new ApplicationError("Value is not a valid date", { extra: { dateString } });
};
const tryToParseTime = (value) => {
	if (!/^\d{2}:\d{2}(:\d{2})?((\-|\+)\d{4})?((\-|\+)\d{1,2}(:\d{2})?)?$/s.test(String(value))) throw new ApplicationError("Value is not a valid time", { extra: { value } });
	return String(value);
};
const tryToParseArray = (value) => {
	try {
		if (typeof value === "object" && Array.isArray(value)) return value;
		let parsed;
		try {
			parsed = JSON.parse(String(value));
		} catch (e$1) {
			parsed = JSON.parse(String(value).replace(/'/g, "\""));
		}
		if (!Array.isArray(parsed)) throw new ApplicationError("Value is not a valid array", { extra: { value } });
		return parsed;
	} catch (e$1) {
		throw new ApplicationError("Value is not a valid array", { extra: { value } });
	}
};
const tryToParseObject = (value) => {
	if (value && typeof value === "object" && !Array.isArray(value)) return value;
	try {
		const o$1 = jsonParse(String(value), { acceptJSObject: true });
		if (typeof o$1 !== "object" || Array.isArray(o$1)) throw new ApplicationError("Value is not a valid object", { extra: { value } });
		return o$1;
	} catch (e$1) {
		throw new ApplicationError("Value is not a valid object", { extra: { value } });
	}
};
var ALLOWED_FORM_FIELDS_KEYS = [
	"fieldLabel",
	"fieldType",
	"placeholder",
	"fieldOptions",
	"multiselect",
	"multipleFiles",
	"acceptFileTypes",
	"formatDate",
	"requiredField",
	"fieldValue",
	"elementName",
	"html"
];
var ALLOWED_FIELD_TYPES = [
	"date",
	"dropdown",
	"email",
	"file",
	"number",
	"password",
	"text",
	"textarea",
	"checkbox",
	"radio",
	"html",
	"hiddenField"
];
const tryToParseJsonToFormFields = (value) => {
	const fields = [];
	try {
		const rawFields = jsonParse(value, { acceptJSObject: true });
		for (const [index, field] of rawFields.entries()) {
			for (const key of Object.keys(field)) {
				if (!ALLOWED_FORM_FIELDS_KEYS.includes(key)) throw new ApplicationError(`Key '${key}' in field ${index} is not valid for form fields`);
				if (key !== "fieldOptions" && ![
					"string",
					"number",
					"boolean"
				].includes(typeof field[key])) field[key] = String(field[key]);
				else if (typeof field[key] === "string" && key !== "html") field[key] = field[key].replace(/</g, "&lt;").replace(/>/g, "&gt;");
				if (key === "fieldType" && !ALLOWED_FIELD_TYPES.includes(field[key])) throw new ApplicationError(`Field type '${field[key]}' in field ${index} is not valid for form fields`);
				if (key === "fieldOptions") {
					if (Array.isArray(field[key])) field[key] = { values: field[key] };
					if (typeof field[key] !== "object" || !field[key].values) throw new ApplicationError(`Field dropdown in field ${index} does has no 'values' property that contain an array of options`);
					for (const [optionIndex, option] of field[key].values.entries()) if (Object.keys(option).length !== 1 || typeof option.option !== "string") throw new ApplicationError(`Field dropdown in field ${index} has an invalid option ${optionIndex}`);
				}
			}
			fields.push(field);
		}
	} catch (error$1) {
		if (error$1 instanceof ApplicationError) throw error$1;
		throw new ApplicationError("Value is not valid JSON");
	}
	return fields;
};
const getValueDescription = (value) => {
	if (typeof value === "object") {
		if (value === null) return "'null'";
		if (Array.isArray(value)) return "array";
		return "object";
	}
	return `'${String(value)}'`;
};
const tryToParseUrl = (value) => {
	if (typeof value === "string" && !value.includes("://")) value = `http://${value}`;
	if (!/^(https?|ftp|file):\/\/\S+|www\.\S+/.test(String(value))) throw new ApplicationError(`The value "${String(value)}" is not a valid url.`, { extra: { value } });
	return String(value);
};
const tryToParseJwt = (value) => {
	const error$1 = new ApplicationError(`The value "${String(value)}" is not a valid JWT token.`, { extra: { value } });
	if (!value) throw error$1;
	if (!/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_.+/=]*$/.test(String(value))) throw error$1;
	return String(value);
};
function validateFieldType(fieldName, value, type, options = {}) {
	if (value === null || value === void 0) return { valid: true };
	const strict$1 = options.strict ?? false;
	const valueOptions = options.valueOptions ?? [];
	const parseStrings = options.parseStrings ?? false;
	const defaultErrorMessage = `'${fieldName}' expects a ${type} but we got ${getValueDescription(value)}`;
	switch (type.toLowerCase()) {
		case "string":
			if (!parseStrings) return {
				valid: true,
				newValue: value
			};
			try {
				if (strict$1 && typeof value !== "string") return {
					valid: false,
					errorMessage: defaultErrorMessage
				};
				return {
					valid: true,
					newValue: tryToParseString(value)
				};
			} catch (e$1) {
				return {
					valid: false,
					errorMessage: defaultErrorMessage
				};
			}
		case "string-alphanumeric": try {
			return {
				valid: true,
				newValue: tryToParseAlphanumericString(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: "Value is not a valid alphanumeric string, only letters, numbers and underscore allowed"
			};
		}
		case "number": try {
			if (strict$1 && typeof value !== "number") return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
			return {
				valid: true,
				newValue: tryToParseNumber(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
		}
		case "boolean": try {
			if (strict$1 && typeof value !== "boolean") return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
			return {
				valid: true,
				newValue: tryToParseBoolean(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
		}
		case "datetime": try {
			return {
				valid: true,
				newValue: tryToParseDateTime(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: `${defaultErrorMessage} <br/><br/> Consider using <a href="https://moment.github.io/luxon/api-docs/index.html#datetimefromformat" target="_blank"><code>DateTime.fromFormat</code></a> to work with custom date formats.`
			};
		}
		case "time": try {
			return {
				valid: true,
				newValue: tryToParseTime(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: `'${fieldName}' expects time (hh:mm:(:ss)) but we got ${getValueDescription(value)}.`
			};
		}
		case "object": try {
			if (strict$1 && !(0, import_isObject.default)(value)) return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
			return {
				valid: true,
				newValue: tryToParseObject(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
		}
		case "array":
			if (strict$1 && !Array.isArray(value)) return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
			try {
				return {
					valid: true,
					newValue: tryToParseArray(value)
				};
			} catch (e$1) {
				return {
					valid: false,
					errorMessage: defaultErrorMessage
				};
			}
		case "options": {
			const validOptions = valueOptions.map((option) => option.value).join(", ");
			if (!valueOptions.some((option) => option.value === value)) return {
				valid: false,
				errorMessage: `'${fieldName}' expects one of the following values: [${validOptions}] but we got ${getValueDescription(value)}`
			};
			return {
				valid: true,
				newValue: value
			};
		}
		case "url": try {
			return {
				valid: true,
				newValue: tryToParseUrl(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: defaultErrorMessage
			};
		}
		case "jwt": try {
			return {
				valid: true,
				newValue: tryToParseJwt(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: "Value is not a valid JWT token"
			};
		}
		case "form-fields": try {
			return {
				valid: true,
				newValue: tryToParseJsonToFormFields(value)
			};
		} catch (e$1) {
			return {
				valid: false,
				errorMessage: e$1.message
			};
		}
		default: return {
			valid: true,
			newValue: value
		};
	}
}
var FilterError = class extends ApplicationError {
	description;
	constructor(message, description) {
		super(message, { level: "warning" });
		this.description = description;
	}
};
function parseSingleFilterValue(value, type, strict$1 = false, version = 1) {
	if (type === "any" || value === null || value === void 0) return {
		valid: true,
		newValue: value
	};
	if (type === "boolean" && !strict$1) {
		if (version >= 2) {
			const result = validateFieldType("filter", value, type);
			if (result.valid) return result;
		}
		return {
			valid: true,
			newValue: Boolean(value)
		};
	}
	if (type === "number" && Number.isNaN(value)) return {
		valid: true,
		newValue: value
	};
	return validateFieldType("filter", value, type, {
		strict: strict$1,
		parseStrings: true
	});
}
var withIndefiniteArticle = (noun) => {
	return `${"aeiou".includes(noun.charAt(0)) ? "an" : "a"} ${noun}`;
};
function parseFilterConditionValues(condition, options, metadata) {
	const index = metadata.index ?? 0;
	const itemIndex = metadata.itemIndex ?? 0;
	const errorFormat = metadata.errorFormat ?? "full";
	const strict$1 = options.typeValidation === "strict";
	const version = options.version ?? 1;
	const { operator } = condition;
	const rightType = operator.rightType ?? operator.type;
	const parsedLeftValue = parseSingleFilterValue(condition.leftValue, operator.type, strict$1, version);
	const parsedRightValue = parseSingleFilterValue(condition.rightValue, rightType, strict$1, version);
	const leftValid = parsedLeftValue.valid || metadata.unresolvedExpressions && typeof condition.leftValue === "string" && condition.leftValue.startsWith("=");
	const rightValid = parsedRightValue.valid || !!operator.singleValue || metadata.unresolvedExpressions && typeof condition.rightValue === "string" && condition.rightValue.startsWith("=");
	const leftValueString = String(condition.leftValue);
	const rightValueString = String(condition.rightValue);
	const suffix = errorFormat === "full" ? `[condition ${index}, item ${itemIndex}]` : `[item ${itemIndex}]`;
	const composeInvalidTypeMessage = (type, fromType, value) => {
		fromType = fromType.toLocaleLowerCase();
		if (strict$1) return `Wrong type: '${value}' is ${withIndefiniteArticle(fromType)} but was expecting ${withIndefiniteArticle(type)} ${suffix}`;
		return `Conversion error: the ${fromType} '${value}' can't be converted to ${withIndefiniteArticle(type)} ${suffix}`;
	};
	const getTypeDescription = (isStrict) => {
		if (isStrict) return "Try changing the type of comparison. Alternatively you can enable 'Convert types where required'.";
		return "Try changing the type of the comparison.";
	};
	const composeInvalidTypeDescription = (type, fromType, valuePosition) => {
		fromType = fromType.toLocaleLowerCase();
		const expectedType = withIndefiniteArticle(type);
		let convertionFunction = "";
		if (type === "string") convertionFunction = ".toString()";
		else if (type === "number") convertionFunction = ".toNumber()";
		else if (type === "boolean") convertionFunction = ".toBoolean()";
		if (strict$1 && convertionFunction) return `
<p>Try either:</p>
<ol>
  <li>Enabling 'Convert types where required'</li>
  <li>Converting the ${valuePosition} field to ${expectedType}${` by adding <code>${convertionFunction}</code>`}</li>
</ol>
			`;
		return getTypeDescription(strict$1);
	};
	if (!leftValid && !rightValid && typeof condition.leftValue === typeof condition.rightValue) return {
		ok: false,
		error: new FilterError(`Comparison type expects ${withIndefiniteArticle(operator.type)} but both fields are ${withIndefiniteArticle(typeof condition.leftValue)}`, getTypeDescription(strict$1))
	};
	if (!leftValid) return {
		ok: false,
		error: new FilterError(composeInvalidTypeMessage(operator.type, typeof condition.leftValue, leftValueString), composeInvalidTypeDescription(operator.type, typeof condition.leftValue, "first"))
	};
	if (!rightValid) return {
		ok: false,
		error: new FilterError(composeInvalidTypeMessage(rightType, typeof condition.rightValue, rightValueString), composeInvalidTypeDescription(rightType, typeof condition.rightValue, "second"))
	};
	return {
		ok: true,
		result: {
			left: parsedLeftValue.valid ? parsedLeftValue.newValue : void 0,
			right: parsedRightValue.valid ? parsedRightValue.newValue : void 0
		}
	};
}
function parseRegexPattern(pattern) {
	const regexMatch = (pattern || "").match(/* @__PURE__ */ new RegExp("^/(.*?)/([gimusy]*)$"));
	let regex;
	if (!regexMatch) regex = new RegExp((pattern || "").toString());
	else regex = new RegExp(regexMatch[1], regexMatch[2]);
	return regex;
}
function arrayContainsValue(array, value, ignoreCase) {
	if (ignoreCase && typeof value === "string") return array.some((item) => {
		if (typeof item !== "string") return false;
		return item.toString().toLocaleLowerCase() === value.toLocaleLowerCase();
	});
	return array.includes(value);
}
function executeFilterCondition(condition, filterOptions, metadata = {}) {
	const ignoreCase = !filterOptions.caseSensitive;
	const { operator } = condition;
	const parsedValues = parseFilterConditionValues(condition, filterOptions, metadata);
	if (!parsedValues.ok) throw parsedValues.error;
	let { left: leftValue, right: rightValue } = parsedValues.result;
	const exists = leftValue !== void 0 && leftValue !== null && !Number.isNaN(leftValue);
	if (condition.operator.operation === "exists") return exists;
	else if (condition.operator.operation === "notExists") return !exists;
	switch (operator.type) {
		case "string": {
			if (ignoreCase) {
				if (typeof leftValue === "string") leftValue = leftValue.toLocaleLowerCase();
				if (typeof rightValue === "string" && !(condition.operator.operation === "regex" || condition.operator.operation === "notRegex")) rightValue = rightValue.toLocaleLowerCase();
			}
			const left = leftValue ?? "";
			const right = rightValue ?? "";
			switch (condition.operator.operation) {
				case "empty": return left.length === 0;
				case "notEmpty": return left.length !== 0;
				case "equals": return left === right;
				case "notEquals": return left !== right;
				case "contains": return left.includes(right);
				case "notContains": return !left.includes(right);
				case "startsWith": return left.startsWith(right);
				case "notStartsWith": return !left.startsWith(right);
				case "endsWith": return left.endsWith(right);
				case "notEndsWith": return !left.endsWith(right);
				case "regex": return parseRegexPattern(right).test(left);
				case "notRegex": return !parseRegexPattern(right).test(left);
			}
			break;
		}
		case "number": {
			const left = leftValue;
			const right = rightValue;
			switch (condition.operator.operation) {
				case "empty": return !exists;
				case "notEmpty": return exists;
				case "equals": return left === right;
				case "notEquals": return left !== right;
				case "gt": return left > right;
				case "lt": return left < right;
				case "gte": return left >= right;
				case "lte": return left <= right;
			}
		}
		case "dateTime": {
			const left = leftValue;
			const right = rightValue;
			if (condition.operator.operation === "empty") return !exists;
			else if (condition.operator.operation === "notEmpty") return exists;
			if (!left || !right) return false;
			switch (condition.operator.operation) {
				case "equals": return left.toMillis() === right.toMillis();
				case "notEquals": return left.toMillis() !== right.toMillis();
				case "after": return left.toMillis() > right.toMillis();
				case "before": return left.toMillis() < right.toMillis();
				case "afterOrEquals": return left.toMillis() >= right.toMillis();
				case "beforeOrEquals": return left.toMillis() <= right.toMillis();
			}
		}
		case "boolean": {
			const left = leftValue;
			const right = rightValue;
			switch (condition.operator.operation) {
				case "empty": return !exists;
				case "notEmpty": return exists;
				case "true": return left;
				case "false": return !left;
				case "equals": return left === right;
				case "notEquals": return left !== right;
			}
		}
		case "array": {
			const left = leftValue ?? [];
			const rightNumber = rightValue;
			switch (condition.operator.operation) {
				case "contains": return arrayContainsValue(left, rightValue, ignoreCase);
				case "notContains": return !arrayContainsValue(left, rightValue, ignoreCase);
				case "lengthEquals": return left.length === rightNumber;
				case "lengthNotEquals": return left.length !== rightNumber;
				case "lengthGt": return left.length > rightNumber;
				case "lengthLt": return left.length < rightNumber;
				case "lengthGte": return left.length >= rightNumber;
				case "lengthLte": return left.length <= rightNumber;
				case "empty": return left.length === 0;
				case "notEmpty": return left.length !== 0;
			}
		}
		case "object": {
			const left = leftValue;
			switch (condition.operator.operation) {
				case "empty": return !left || Object.keys(left).length === 0;
				case "notEmpty": return !!left && Object.keys(left).length !== 0;
			}
		}
	}
	warn(`Unknown filter parameter operator "${operator.type}:${operator.operation}"`);
	return false;
}
const validateFilterParameter = (nodeProperties, value) => {
	return value.conditions.reduce((issues, condition, index) => {
		const key = `${nodeProperties.name}.${index}`;
		try {
			parseFilterConditionValues(condition, value.options, {
				index,
				unresolvedExpressions: true,
				errorFormat: "inline"
			});
		} catch (error$1) {
			if (error$1 instanceof FilterError) issues[key].push(error$1.message);
		}
		return issues;
	}, {});
};
function isResourceLocatorValue(value) {
	return Boolean(typeof value === "object" && value && "mode" in value && "value" in value && "__rl" in value);
}
const isINodeProperties = (item) => "name" in item && "type" in item && !("value" in item);
const isINodePropertyOptions = (item) => "value" in item && "name" in item && !("displayName" in item);
const isINodePropertyCollection = (item) => "values" in item && "name" in item && "displayName" in item;
const isINodePropertiesList = (items) => Array.isArray(items) && items.every(isINodeProperties);
const isINodePropertyOptionsList = (items) => Array.isArray(items) && items.every(isINodePropertyOptions);
const isINodePropertyCollectionList = (items) => {
	return Array.isArray(items) && items.every(isINodePropertyCollection);
};
const isValidResourceLocatorParameterValue = (value) => {
	if (typeof value === "object") {
		if (typeof value.value === "number") return true;
		return !!value.value;
	} else return !!value;
};
const isResourceMapperValue = (value) => {
	return typeof value === "object" && value !== null && "mappingMode" in value && "schema" in value && "value" in value;
};
const isFilterValue = (value) => {
	return typeof value === "object" && value !== null && "conditions" in value && "combinator" in value;
};
var import_get = /* @__PURE__ */ __toESM(require_get());
var import_isEqual$2 = /* @__PURE__ */ __toESM(require_isEqual());
function isSubNodeType(typeDescription) {
	if (!typeDescription?.outputs || typeof typeDescription.outputs === "string") return false;
	const outputTypes = getConnectionTypes(typeDescription.outputs);
	return outputTypes ? outputTypes.filter((output) => output !== NodeConnectionTypes.Main).length > 0 : false;
}
var getPropertyValues = (nodeValues, propertyName, node, nodeTypeDescription, nodeValuesRoot) => {
	let value;
	if (propertyName.charAt(0) === "/") value = (0, import_get.default)(nodeValuesRoot, propertyName.slice(1));
	else if (propertyName === "@version") value = node?.typeVersion || 0;
	else if (propertyName === "@tool") value = nodeTypeDescription?.name.endsWith("Tool") ?? false;
	else value = (0, import_get.default)(nodeValues, propertyName);
	if (value && typeof value === "object" && "__rl" in value && value.__rl) value = value.value;
	if (!Array.isArray(value)) return [value];
	else return value;
};
var checkConditions = (conditions, actualValues) => {
	return conditions.some((condition) => {
		if (condition && typeof condition === "object" && condition._cnd && Object.keys(condition).length === 1) {
			const [key, targetValue] = Object.entries(condition._cnd)[0];
			return actualValues.every((propertyValue) => {
				if (key === "eq") return (0, import_isEqual$2.default)(propertyValue, targetValue);
				if (key === "not") return !(0, import_isEqual$2.default)(propertyValue, targetValue);
				if (key === "gte") return propertyValue >= targetValue;
				if (key === "lte") return propertyValue <= targetValue;
				if (key === "gt") return propertyValue > targetValue;
				if (key === "lt") return propertyValue < targetValue;
				if (key === "between") {
					const { from: from$2, to } = targetValue;
					return propertyValue >= from$2 && propertyValue <= to;
				}
				if (key === "includes") return propertyValue.includes(targetValue);
				if (key === "startsWith") return propertyValue.startsWith(targetValue);
				if (key === "endsWith") return propertyValue.endsWith(targetValue);
				if (key === "regex") return new RegExp(targetValue).test(propertyValue);
				if (key === "exists") return propertyValue !== null && propertyValue !== void 0 && propertyValue !== "";
				return false;
			});
		}
		return actualValues.includes(condition);
	});
};
function displayParameter(nodeValues, parameter, node, nodeTypeDescription, nodeValuesRoot, displayKey = "displayOptions") {
	if (!parameter[displayKey]) return true;
	const { show, hide } = parameter[displayKey];
	nodeValuesRoot = nodeValuesRoot || nodeValues;
	if (show) for (const propertyName of Object.keys(show)) {
		const values$1 = getPropertyValues(nodeValues, propertyName, node, nodeTypeDescription, nodeValuesRoot);
		if (values$1.some((v$3) => typeof v$3 === "string" && v$3.charAt(0) === "=")) return true;
		if (values$1.length === 0 || !checkConditions(show[propertyName], values$1)) return false;
	}
	if (hide) for (const propertyName of Object.keys(hide)) {
		const values$1 = getPropertyValues(nodeValues, propertyName, node, nodeTypeDescription, nodeValuesRoot);
		if (values$1.length !== 0 && checkConditions(hide[propertyName], values$1)) return false;
	}
	return true;
}
function displayParameterPath(nodeValues, parameter, path, node, nodeTypeDescription, displayKey = "displayOptions") {
	let resolvedNodeValues = nodeValues;
	if (path !== "") resolvedNodeValues = (0, import_get.default)(nodeValues, path);
	let nodeValuesRoot = nodeValues;
	if (path && path.split(".").indexOf("parameters") === 0) nodeValuesRoot = (0, import_get.default)(nodeValues, "parameters");
	return displayParameter(resolvedNodeValues, parameter, node, nodeTypeDescription, nodeValuesRoot, displayKey);
}
function getContext(runExecutionData, type, node) {
	if (runExecutionData.executionData === void 0) throw new ApplicationError("`executionData` is not initialized");
	let key;
	if (type === "flow") key = "flow";
	else if (type === "node") {
		if (node === void 0) throw new ApplicationError("The request data of context type \"node\" the node parameter has to be set!");
		key = `node:${node.name}`;
	} else throw new ApplicationError("Unknown context type. Only `flow` and `node` are supported.", { extra: { contextType: type } });
	if (runExecutionData.executionData.contextData[key] === void 0) runExecutionData.executionData.contextData[key] = {};
	return runExecutionData.executionData.contextData[key];
}
function getParameterDependencies(nodePropertiesArray) {
	const dependencies = {};
	for (const nodeProperties of nodePropertiesArray) {
		const { name, displayOptions } = nodeProperties;
		if (!dependencies[name]) dependencies[name] = [];
		if (!displayOptions) continue;
		for (const displayRule of Object.values(displayOptions)) for (const parameterName of Object.keys(displayRule)) if (!dependencies[name].includes(parameterName)) {
			if (parameterName.charAt(0) === "@") continue;
			dependencies[name].push(parameterName);
		}
	}
	return dependencies;
}
function getParameterResolveOrder(nodePropertiesArray, parameterDependencies) {
	const executionOrder = [];
	const indexToResolve = Array.from({ length: nodePropertiesArray.length }, (_$1, k$1) => k$1);
	const resolvedParameters = [];
	let index;
	let property$2;
	let lastIndexLength = indexToResolve.length;
	let lastIndexReduction = -1;
	let iterations = 0;
	while (indexToResolve.length !== 0) {
		iterations += 1;
		index = indexToResolve.shift();
		property$2 = nodePropertiesArray[index];
		if (parameterDependencies[property$2.name].length === 0) {
			executionOrder.push(index);
			resolvedParameters.push(property$2.name);
			continue;
		}
		for (const dependency of parameterDependencies[property$2.name]) if (!resolvedParameters.includes(dependency)) {
			if (dependency.charAt(0) === "/") continue;
			indexToResolve.push(index);
			continue;
		}
		executionOrder.push(index);
		resolvedParameters.push(property$2.name);
		if (indexToResolve.length < lastIndexLength) lastIndexReduction = iterations;
		if (iterations > lastIndexReduction + nodePropertiesArray.length) throw new ApplicationError("Could not resolve parameter dependencies. Max iterations reached! Hint: If `displayOptions` are specified in any child parameter of a parent `collection` or `fixedCollection`, remove the `displayOptions` from the child parameter.");
		lastIndexLength = indexToResolve.length;
	}
	return executionOrder;
}
function getNodeParameters(nodePropertiesArray, nodeValues, returnDefaults, returnNoneDisplayed, node, nodeTypeDescription, options) {
	let { nodeValuesRoot, parameterDependencies } = options ?? {};
	const { onlySimpleTypes = false, dataIsResolved = false, parentType } = options ?? {};
	if (parameterDependencies === void 0) parameterDependencies = getParameterDependencies(nodePropertiesArray);
	const duplicateParameterNames = [];
	const parameterNames = [];
	for (const nodeProperties of nodePropertiesArray) if (parameterNames.includes(nodeProperties.name)) {
		if (!duplicateParameterNames.includes(nodeProperties.name)) duplicateParameterNames.push(nodeProperties.name);
	} else parameterNames.push(nodeProperties.name);
	const nodeParameters = {};
	const nodeParametersFull = {};
	let nodeValuesDisplayCheck = nodeParametersFull;
	if (!dataIsResolved && !returnNoneDisplayed) nodeValuesDisplayCheck = getNodeParameters(nodePropertiesArray, nodeValues, true, true, node, nodeTypeDescription, {
		onlySimpleTypes: true,
		dataIsResolved: true,
		nodeValuesRoot,
		parentType,
		parameterDependencies
	});
	nodeValuesRoot = nodeValuesRoot || nodeValuesDisplayCheck;
	const parameterIterationOrderIndex = getParameterResolveOrder(nodePropertiesArray, parameterDependencies);
	for (const parameterIndex of parameterIterationOrderIndex) {
		const nodeProperties = nodePropertiesArray[parameterIndex];
		if (!nodeValues || nodeValues[nodeProperties.name] === void 0 && (!returnDefaults || parentType === "collection")) continue;
		if (!returnNoneDisplayed && !displayParameter(nodeValuesDisplayCheck, nodeProperties, node, nodeTypeDescription, nodeValuesRoot)) {
			if (!returnNoneDisplayed || !returnDefaults) continue;
		}
		if (!["collection", "fixedCollection"].includes(nodeProperties.type)) {
			if (duplicateParameterNames.includes(nodeProperties.name)) {
				if (!displayParameter(nodeValuesDisplayCheck, nodeProperties, node, nodeTypeDescription, nodeValuesRoot)) continue;
			}
			if (returnDefaults) {
				if ([
					"boolean",
					"number",
					"options"
				].includes(nodeProperties.type)) nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name] !== void 0 ? nodeValues[nodeProperties.name] : nodeProperties.default;
				else if (nodeProperties.type === "resourceLocator" && typeof nodeProperties.default === "object") nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name] !== void 0 ? nodeValues[nodeProperties.name] : {
					__rl: true,
					...nodeProperties.default
				};
				else nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name] ?? nodeProperties.default;
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			} else if (nodeValues[nodeProperties.name] !== nodeProperties.default && typeof nodeValues[nodeProperties.name] !== "object" || typeof nodeValues[nodeProperties.name] === "object" && !(0, import_isEqual$2.default)(nodeValues[nodeProperties.name], nodeProperties.default) || nodeValues[nodeProperties.name] !== void 0 && parentType === "collection") {
				nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				continue;
			}
		}
		if (onlySimpleTypes) continue;
		let tempValue;
		if (nodeProperties.type === "collection") {
			if (nodeProperties.typeOptions !== void 0 && nodeProperties.typeOptions.multipleValues === true) {
				if (nodeValues[nodeProperties.name] !== void 0) nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
				else if (returnDefaults) if (Array.isArray(nodeProperties.default)) nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
				else nodeParameters[nodeProperties.name] = [];
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			} else if (nodeValues[nodeProperties.name] !== void 0) {
				const tempNodeParameters = getNodeParameters(nodeProperties.options, nodeValues[nodeProperties.name], returnDefaults, returnNoneDisplayed, node, nodeTypeDescription, {
					onlySimpleTypes: false,
					dataIsResolved: false,
					nodeValuesRoot,
					parentType: nodeProperties.type
				});
				if (tempNodeParameters !== null) {
					nodeParameters[nodeProperties.name] = tempNodeParameters;
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				}
			} else if (returnDefaults) {
				nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			}
		} else if (nodeProperties.type === "fixedCollection") {
			const collectionValues = {};
			let tempNodeParameters;
			let tempNodePropertiesArray;
			let nodePropertyOptions;
			let propertyValues = nodeValues[nodeProperties.name];
			if (returnDefaults) {
				if (propertyValues === void 0) propertyValues = deepCopy(nodeProperties.default);
			}
			if (!returnDefaults && nodeProperties.typeOptions?.multipleValues === false && propertyValues && Object.keys(propertyValues).length === 0) return nodeValues;
			for (const itemName of Object.keys(propertyValues || {})) if (nodeProperties.typeOptions !== void 0 && nodeProperties.typeOptions.multipleValues === true) {
				const tempArrayValue = [];
				if (typeof propertyValues !== "object" || Array.isArray(propertyValues)) continue;
				for (const nodeValue of propertyValues[itemName]) {
					nodePropertyOptions = nodeProperties.options.find((nodePropertyOptions$1) => nodePropertyOptions$1.name === itemName);
					if (nodePropertyOptions === void 0) throw new ApplicationError("Could not find property option", { extra: {
						propertyOption: itemName,
						property: nodeProperties.name
					} });
					tempNodePropertiesArray = nodePropertyOptions.values;
					tempValue = getNodeParameters(tempNodePropertiesArray, nodeValue, returnDefaults, returnNoneDisplayed, node, nodeTypeDescription, {
						onlySimpleTypes: false,
						dataIsResolved: false,
						nodeValuesRoot,
						parentType: nodeProperties.type
					});
					if (tempValue !== null) tempArrayValue.push(tempValue);
				}
				collectionValues[itemName] = tempArrayValue;
			} else {
				tempNodeParameters = {};
				const nodePropertyOptions$1 = nodeProperties.options.find((data) => data.name === itemName);
				if (nodePropertyOptions$1 !== void 0) {
					tempNodePropertiesArray = nodePropertyOptions$1.values;
					tempValue = getNodeParameters(tempNodePropertiesArray, nodeValues[nodeProperties.name][itemName], returnDefaults, returnNoneDisplayed, node, nodeTypeDescription, {
						onlySimpleTypes: false,
						dataIsResolved: false,
						nodeValuesRoot,
						parentType: nodeProperties.type
					});
					if (tempValue !== null) Object.assign(tempNodeParameters, tempValue);
				}
				if (Object.keys(tempNodeParameters).length !== 0) collectionValues[itemName] = tempNodeParameters;
			}
			if (!returnDefaults && nodeProperties.typeOptions?.multipleValues === false && collectionValues && Object.keys(collectionValues).length === 0 && propertyValues && propertyValues?.constructor.name === "Object" && Object.keys(propertyValues).length !== 0) {
				const returnValue = {};
				Object.keys(propertyValues || {}).forEach((value) => {
					returnValue[value] = {};
				});
				nodeParameters[nodeProperties.name] = returnValue;
			}
			if (Object.keys(collectionValues).length !== 0 || returnDefaults) {
				if (returnDefaults) {
					if (collectionValues === void 0) nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
					else nodeParameters[nodeProperties.name] = collectionValues;
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				} else if (collectionValues !== nodeProperties.default) {
					nodeParameters[nodeProperties.name] = collectionValues;
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				}
			}
		}
	}
	return nodeParameters;
}
function getNodeWebhookPath(workflowId, node, path, isFullPath, restartWebhook) {
	let webhookPath = "";
	if (restartWebhook === true) return path;
	if (node.webhookId === void 0) webhookPath = `${workflowId}/${encodeURIComponent(node.name.toLowerCase())}/${path}`;
	else {
		if (isFullPath === true) return path || node.webhookId;
		webhookPath = `${node.webhookId}/${path}`;
	}
	return webhookPath;
}
function getNodeWebhookUrl(baseUrl, workflowId, node, path, isFullPath) {
	if ((path.startsWith(":") || path.includes("/:")) && node.webhookId) isFullPath = false;
	if (path.startsWith("/")) path = path.slice(1);
	return `${baseUrl}/${getNodeWebhookPath(workflowId, node, path, isFullPath)}`;
}
function getConnectionTypes(connections) {
	return connections.map((connection) => {
		if (typeof connection === "string") return connection;
		return connection.type;
	}).filter((connection) => connection !== void 0);
}
function getNodeInputs(workflow, node, nodeTypeData) {
	if (Array.isArray(nodeTypeData?.inputs)) return nodeTypeData.inputs;
	try {
		return workflow.expression.getSimpleParameterValue(node, nodeTypeData.inputs, "internal", {}) || [];
	} catch (e$1) {
		console.warn("Could not calculate inputs dynamically for node: ", node.name);
		return [];
	}
}
function getNodeOutputs(workflow, node, nodeTypeData) {
	let outputs = [];
	if (Array.isArray(nodeTypeData.outputs)) outputs = nodeTypeData.outputs;
	else try {
		const result = workflow.expression.getSimpleParameterValue(node, nodeTypeData.outputs, "internal", {});
		outputs = Array.isArray(result) ? result : [];
	} catch (e$1) {
		console.warn("Could not calculate outputs dynamically for node: ", node.name);
	}
	if (node.onError === "continueErrorOutput") {
		outputs = deepCopy(outputs);
		if (outputs.length === 1) {
			if (typeof outputs[0] === "string") outputs[0] = { type: outputs[0] };
			outputs[0].displayName = "Success";
		}
		return [...outputs, {
			category: "error",
			type: NodeConnectionTypes.Main,
			displayName: "Error"
		}];
	}
	return outputs;
}
function getNodeParametersIssues(nodePropertiesArray, node, nodeTypeDescription, pinDataNodeNames) {
	const foundIssues = {};
	let propertyIssues;
	if (node.disabled === true || pinDataNodeNames?.includes(node.name)) return null;
	for (const nodeProperty of nodePropertiesArray) {
		propertyIssues = getParameterIssues(nodeProperty, node.parameters, "", node, nodeTypeDescription);
		mergeIssues(foundIssues, propertyIssues);
	}
	if (Object.keys(foundIssues).length === 0) return null;
	return foundIssues;
}
var validateResourceLocatorParameter = (value, parameterMode) => {
	const valueToValidate = value?.value?.toString() || "";
	if (valueToValidate.startsWith("=")) return [];
	const validationErrors = [];
	if (parameterMode.validation) {
		for (const validation of parameterMode.validation) if (validation && validation.type === "regex") {
			const regexValidation = validation;
			if (!(/* @__PURE__ */ new RegExp(`^${regexValidation.properties.regex}$`)).test(valueToValidate)) validationErrors.push(regexValidation.properties.errorMessage);
		}
	}
	return validationErrors;
};
var validateResourceMapperParameter = (nodeProperties, value, skipRequiredCheck = false) => {
	if (value.mappingMode === "autoMapInputData") return {};
	const issues = {};
	let fieldWordSingular = nodeProperties.typeOptions?.resourceMapper?.fieldWords?.singular || "Field";
	fieldWordSingular = fieldWordSingular.charAt(0).toUpperCase() + fieldWordSingular.slice(1);
	value.schema.forEach((field) => {
		const fieldValue = value.value ? value.value[field.id] : null;
		const key = `${nodeProperties.name}.${field.id}`;
		const fieldErrors = [];
		if (field.required && !skipRequiredCheck) {
			if (value.value === null || fieldValue === void 0) {
				const error$1 = `${fieldWordSingular} "${field.id}" is required`;
				fieldErrors.push(error$1);
			}
		}
		if (!fieldValue?.toString().startsWith("=") && field.type) {
			const validationResult = validateFieldType(field.id, fieldValue, field.type, { valueOptions: field.options });
			if (!validationResult.valid && validationResult.errorMessage) fieldErrors.push(validationResult.errorMessage);
		}
		if (fieldErrors.length > 0) issues[key] = fieldErrors;
	});
	return issues;
};
var validateParameter = (nodeProperties, value, type) => {
	const nodeName = nodeProperties.name;
	const options = type === "options" ? nodeProperties.options : void 0;
	if (!value?.toString().startsWith("=")) {
		const validationResult = validateFieldType(nodeName, value, type, { valueOptions: options });
		if (!validationResult.valid && validationResult.errorMessage) return validationResult.errorMessage;
	}
};
function addToIssuesIfMissing(foundIssues, nodeProperties, value) {
	if (nodeProperties.type === "string" && (value === "" || value === void 0) || nodeProperties.type === "multiOptions" && Array.isArray(value) && value.length === 0 || nodeProperties.type === "dateTime" && (value === "" || value === void 0) || nodeProperties.type === "options" && (value === "" || value === void 0) || (nodeProperties.type === "resourceLocator" || nodeProperties.type === "workflowSelector") && !isValidResourceLocatorParameterValue(value)) {
		if (foundIssues.parameters === void 0) foundIssues.parameters = {};
		if (foundIssues.parameters[nodeProperties.name] === void 0) foundIssues.parameters[nodeProperties.name] = [];
		foundIssues.parameters[nodeProperties.name].push(`Parameter "${nodeProperties.displayName}" is required.`);
	}
}
function getParameterValueByPath(nodeValues, parameterName, path) {
	return (0, import_get.default)(nodeValues, path ? `${path}.${parameterName}` : parameterName);
}
function isINodeParameterResourceLocator(value) {
	return typeof value === "object" && value !== null && "value" in value && "mode" in value;
}
function getParameterIssues(nodeProperties, nodeValues, path, node, nodeTypeDescription) {
	const foundIssues = {};
	const isDisplayed = displayParameterPath(nodeValues, nodeProperties, path, node, nodeTypeDescription);
	if (nodeProperties.required === true) {
		if (isDisplayed) {
			const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
			if (nodeProperties.typeOptions !== void 0 && nodeProperties.typeOptions.multipleValues !== void 0) {
				if (Array.isArray(value)) for (const singleValue of value) addToIssuesIfMissing(foundIssues, nodeProperties, singleValue);
			} else addToIssuesIfMissing(foundIssues, nodeProperties, value);
		}
	}
	if ((nodeProperties.type === "resourceLocator" || nodeProperties.type === "workflowSelector") && isDisplayed) {
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isINodeParameterResourceLocator(value)) {
			const mode = nodeProperties.modes?.find((option) => option.name === value.mode);
			if (mode) validateResourceLocatorParameter(value, mode).forEach((error$1) => {
				if (foundIssues.parameters === void 0) foundIssues.parameters = {};
				if (foundIssues.parameters[nodeProperties.name] === void 0) foundIssues.parameters[nodeProperties.name] = [];
				foundIssues.parameters[nodeProperties.name].push(error$1);
			});
		}
	} else if (nodeProperties.type === "resourceMapper" && isDisplayed) {
		const skipRequiredCheck = nodeProperties.typeOptions?.resourceMapper?.mode !== "add";
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isResourceMapperValue(value)) {
			const issues = validateResourceMapperParameter(nodeProperties, value, skipRequiredCheck);
			if (Object.keys(issues).length > 0) {
				if (foundIssues.parameters === void 0) foundIssues.parameters = {};
				if (foundIssues.parameters[nodeProperties.name] === void 0) foundIssues.parameters[nodeProperties.name] = [];
				foundIssues.parameters = {
					...foundIssues.parameters,
					...issues
				};
			}
		}
	} else if (nodeProperties.type === "filter" && isDisplayed) {
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isFilterValue(value)) {
			const issues = validateFilterParameter(nodeProperties, value);
			if (Object.keys(issues).length > 0) foundIssues.parameters = {
				...foundIssues.parameters,
				...issues
			};
		}
	} else if (nodeProperties.validateType) {
		const error$1 = validateParameter(nodeProperties, getParameterValueByPath(nodeValues, nodeProperties.name, path), nodeProperties.validateType);
		if (error$1) {
			if (foundIssues.parameters === void 0) foundIssues.parameters = {};
			if (foundIssues.parameters[nodeProperties.name] === void 0) foundIssues.parameters[nodeProperties.name] = [];
			foundIssues.parameters[nodeProperties.name].push(error$1);
		}
	}
	if (nodeProperties.options === void 0) return foundIssues;
	let basePath = path ? `${path}.` : "";
	const checkChildNodeProperties = [];
	if (nodeProperties.type === "collection") for (const option of nodeProperties.options) checkChildNodeProperties.push({
		basePath,
		data: option
	});
	else if (nodeProperties.type === "fixedCollection" && isDisplayed) {
		basePath = basePath ? `${basePath}.` : `${nodeProperties.name}.`;
		let propertyOptions;
		for (propertyOptions of nodeProperties.options) {
			const value = getParameterValueByPath(nodeValues, propertyOptions.name, basePath.slice(0, -1));
			const valueArray = Array.isArray(value) ? value : [];
			const { minRequiredFields, maxAllowedFields } = nodeProperties.typeOptions ?? {};
			let error$1 = "";
			if (minRequiredFields && valueArray.length < minRequiredFields) error$1 = `At least ${minRequiredFields} ${minRequiredFields === 1 ? "field is" : "fields are"} required.`;
			if (maxAllowedFields && valueArray.length > maxAllowedFields) error$1 = `At most ${maxAllowedFields} ${maxAllowedFields === 1 ? "field is" : "fields are"} allowed.`;
			if (error$1) {
				foundIssues.parameters ??= {};
				foundIssues.parameters[nodeProperties.name] ??= [];
				foundIssues.parameters[nodeProperties.name].push(error$1);
			}
			if (value === void 0) continue;
			if (nodeProperties.typeOptions !== void 0 && nodeProperties.typeOptions.multipleValues !== void 0) {
				if (Array.isArray(value)) for (let i$2 = 0; i$2 < value.length; i$2++) for (const option of propertyOptions.values) checkChildNodeProperties.push({
					basePath: `${basePath}${propertyOptions.name}[${i$2}]`,
					data: option
				});
			} else for (const option of propertyOptions.values) checkChildNodeProperties.push({
				basePath: basePath + propertyOptions.name,
				data: option
			});
		}
	} else return foundIssues;
	let propertyIssues;
	for (const optionData of checkChildNodeProperties) {
		propertyIssues = getParameterIssues(optionData.data, nodeValues, optionData.basePath, node, nodeTypeDescription);
		mergeIssues(foundIssues, propertyIssues);
	}
	return foundIssues;
}
function mergeIssues(destination, source) {
	if (source === null) return;
	if (source.execution === true) destination.execution = true;
	const objectProperties = ["parameters", "credentials"];
	let destinationProperty;
	for (const propertyName of objectProperties) if (source[propertyName] !== void 0) {
		if (destination[propertyName] === void 0) destination[propertyName] = {};
		let parameterName;
		for (parameterName of Object.keys(source[propertyName])) {
			destinationProperty = destination[propertyName];
			if (destinationProperty[parameterName] === void 0) destinationProperty[parameterName] = [];
			destinationProperty[parameterName].push.apply(destinationProperty[parameterName], source[propertyName][parameterName]);
		}
	}
	if (source.typeUnknown === true) destination.typeUnknown = true;
}
function mergeNodeProperties(mainProperties, addProperties) {
	let existingIndex;
	for (const property$2 of addProperties) {
		if (property$2.doNotInherit) continue;
		existingIndex = mainProperties.findIndex((element) => element.name === property$2.name);
		if (existingIndex === -1) mainProperties.push(property$2);
		else mainProperties[existingIndex] = property$2;
	}
}
function isTriggerNode(nodeTypeData) {
	return nodeTypeData.group.includes("trigger");
}
function isExecutable(workflow, node, nodeTypeData) {
	const outputNames = getConnectionTypes(getNodeOutputs(workflow, node, nodeTypeData));
	return outputNames.includes(NodeConnectionTypes.Main) || outputNames.includes(NodeConnectionTypes.AiTool) || isTriggerNode(nodeTypeData);
}
function isNodeWithWorkflowSelector(node) {
	return [EXECUTE_WORKFLOW_NODE_TYPE$1, WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE].includes(node.type);
}
function resolveResourceAndOperation(nodeParameters, nodeTypeDescription) {
	if (nodeTypeDescription.name === "n8n-nodes-base.code") {
		const language = nodeParameters.language;
		const langProp = nodeTypeDescription.properties.find((p$1) => p$1.name === "language");
		if (langProp?.options && isINodePropertyOptionsList(langProp.options)) {
			const found = langProp.options.find((o$1) => o$1.value === language);
			if (found?.action) return { action: found.action };
		}
	}
	const resource = nodeParameters.resource;
	const operation = nodeParameters.operation;
	const nodeTypeOperation = nodeTypeDescription.properties.find((p$1) => p$1.name === "operation" && p$1.displayOptions?.show?.resource?.includes(resource));
	if (nodeTypeOperation?.options && isINodePropertyOptionsList(nodeTypeOperation.options)) {
		const foundOperation = nodeTypeOperation.options.find((option) => option.value === operation);
		if (foundOperation?.action) return { action: foundOperation.action };
	}
	if (resource && operation) return {
		operation,
		resource
	};
	else return {};
}
function makeDescription(nodeParameters, nodeTypeDescription) {
	const { action, operation, resource } = resolveResourceAndOperation(nodeParameters, nodeTypeDescription);
	if (action) return `${action} in ${nodeTypeDescription.defaults.name}`;
	if (resource && operation) return `${operation} ${resource} in ${nodeTypeDescription.defaults.name}`;
	return nodeTypeDescription.description;
}
function isTool(nodeTypeDescription, parameters) {
	if (nodeTypeDescription.name.includes("vectorStore")) return parameters.mode === "retrieve-as-tool";
	if (Array.isArray(nodeTypeDescription.outputs)) {
		for (const output of nodeTypeDescription.outputs) if (typeof output === "string") return output === NodeConnectionTypes.AiTool;
		else if (output?.type && output.type === NodeConnectionTypes.AiTool) return true;
	}
	return false;
}
function makeNodeName(nodeParameters, nodeTypeDescription) {
	const { action, operation, resource } = resolveResourceAndOperation(nodeParameters, nodeTypeDescription);
	const postfix = isTool(nodeTypeDescription, nodeParameters) ? ` in ${nodeTypeDescription.defaults.name}` : "";
	if (action) return `${action}${postfix}`;
	if (resource && operation) return `${operation[0].toUpperCase() + operation.slice(1)} ${resource}${postfix}`;
	return nodeTypeDescription.defaults.name ?? nodeTypeDescription.displayName;
}
function isDefaultNodeName(name, nodeType, parameters) {
	const currentDefaultName = makeNodeName(parameters, nodeType);
	return name.startsWith(currentDefaultName) && /^\d*$/.test(name.slice(currentDefaultName.length));
}
const getUpdatedToolDescription = (currentNodeType, newParameters, currentParameters) => {
	if (!currentNodeType) return;
	if (newParameters?.descriptionType === "manual" && currentParameters) {
		const previousDescription = makeDescription(currentParameters, currentNodeType);
		const newDescription = makeDescription(newParameters, currentNodeType);
		if (newParameters.toolDescription === previousDescription || !newParameters.toolDescription?.toString().trim() || newParameters.toolDescription === currentNodeType.description) return newDescription;
	}
};
function getSubworkflowId(node) {
	if (isNodeWithWorkflowSelector(node) && isResourceLocatorValue(node.parameters.workflowId)) return node.parameters.workflowId.value;
}
function create(target, parent, option, depth) {
	depth = depth || 0;
	for (const key in target) if (typeof target[key] === "object" && target[key] !== null) target[key] = create(target[key], parent || target, option, depth + 1);
	Object.defineProperty(target, "__dataChanged", {
		value: false,
		writable: true
	});
	return new Proxy(target, {
		deleteProperty(target$1, name) {
			if (parent === void 0) target$1.__dataChanged = true;
			else parent.__dataChanged = true;
			return Reflect.deleteProperty(target$1, name);
		},
		get(target$1, name, receiver) {
			return Reflect.get(target$1, name, receiver);
		},
		has(target$1, key) {
			return Reflect.has(target$1, key);
		},
		set(target$1, name, value) {
			if (parent === void 0) if (option !== void 0 && option.ignoreEmptyOnFirstChild === true && depth === 0 && target$1[name.toString()] === void 0 && typeof value === "object" && Object.keys(value).length === 0) {} else target$1.__dataChanged = true;
			else parent.__dataChanged = true;
			return Reflect.set(target$1, name, value);
		}
	});
}
var countPlaceholders = (text) => {
	const placeholder = /(\{[a-zA-Z0-9_]+\})/g;
	let returnData = 0;
	try {
		const matches = text.matchAll(placeholder);
		for (const _$1 of matches) returnData++;
	} catch (error$1) {}
	return returnData;
};
var countPlaceholdersInParameters = (parameters) => {
	let returnData = 0;
	for (const parameter of parameters) if (!parameter.value) returnData++;
	else returnData += countPlaceholders(String(parameter.value));
	return returnData;
};
function areOverlapping(topLeft, bottomRight, targetPos) {
	return targetPos[0] > topLeft[0] && targetPos[1] > topLeft[1] && targetPos[0] < bottomRight[0] && targetPos[1] < bottomRight[1];
}
var URL_PARTS_REGEX = /(?<protocolPlusDomain>.*?\..*?)(?<pathname>\/.*)/;
function getDomainBase(raw, urlParts = URL_PARTS_REGEX) {
	try {
		const url = new URL(raw);
		return [url.protocol, url.hostname].join("//");
	} catch {
		const match$1 = urlParts.exec(raw);
		if (!match$1?.groups?.protocolPlusDomain) return "";
		return match$1.groups.protocolPlusDomain;
	}
}
function isSensitive(segment) {
	if (/^v\d+$/.test(segment)) return false;
	return /%40/.test(segment) || /\d/.test(segment) || /^[0-9A-F]{8}/i.test(segment);
}
function sanitizeRoute(raw, check = isSensitive, char = "*") {
	return raw.split("/").map((segment) => check(segment) ? char.repeat(segment.length) : segment).join("/");
}
function getDomainPath(raw, urlParts = URL_PARTS_REGEX) {
	try {
		const url = new URL(raw);
		if (!url.hostname) throw new ApplicationError("Malformed URL");
		return sanitizeRoute(url.pathname);
	} catch {
		const match$1 = urlParts.exec(raw);
		if (!match$1?.groups?.pathname) return "";
		return sanitizeRoute(match$1.groups.pathname.split("?").shift());
	}
}
function getNumberOfItemsInRuns(runs) {
	return runs.reduce((total, run$1) => {
		const data = run$1.data ?? {};
		let count = 0;
		Object.keys(data).forEach((type) => {
			(data[type] ?? []).forEach((branch) => {
				count += (branch ?? []).length;
			});
		});
		return total + count;
	}, 0);
}
function generateNodesGraph(workflow, nodeTypes, options) {
	const { runData } = options ?? {};
	const nodeGraph = {
		node_types: [],
		node_connections: [],
		nodes: {},
		notes: {},
		is_pinned: Object.keys(workflow.pinData ?? {}).length > 0
	};
	const nameIndices = {};
	const webhookNodeNames = [];
	const evaluationTriggerNodeNames = [];
	const nodes = (workflow.nodes ?? []).filter((node) => node.type === STICKY_NODE_TYPE$1);
	const otherNodes = (workflow.nodes ?? []).filter((node) => node.type !== STICKY_NODE_TYPE$1);
	nodes.forEach((stickyNote, index) => {
		const stickyType = nodeTypes.getByNameAndVersion(STICKY_NODE_TYPE$1, stickyNote.typeVersion);
		if (!stickyType) return;
		let nodeParameters = {};
		try {
			nodeParameters = getNodeParameters(stickyType.description.properties, stickyNote.parameters, true, false, stickyNote, stickyType.description) ?? {};
		} catch {}
		const height = typeof nodeParameters.height === "number" ? nodeParameters.height : 0;
		const width = typeof nodeParameters.width === "number" ? nodeParameters.width : 0;
		const topLeft = stickyNote.position;
		const bottomRight = [topLeft[0] + width, topLeft[1] + height];
		const overlapping = Boolean(otherNodes.find((node) => areOverlapping(topLeft, bottomRight, node.position)));
		nodeGraph.notes[index] = {
			overlapping,
			position: topLeft,
			height,
			width
		};
	});
	otherNodes.forEach((node, index) => {
		nodeGraph.node_types.push(node.type);
		const nodeItem = {
			id: node.id,
			type: node.type,
			version: node.typeVersion,
			position: node.position
		};
		const nodeType = nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
		if (nodeType?.description?.communityNodePackageVersion) nodeItem.package_version = nodeType.description.communityNodePackageVersion;
		if (runData?.[node.name]) {
			const runs = runData[node.name] ?? [];
			nodeItem.runs = runs.length;
			nodeItem.items_total = getNumberOfItemsInRuns(runs);
		}
		if (options?.sourceInstanceId) nodeItem.src_instance_id = options.sourceInstanceId;
		if (node.id && options?.nodeIdMap?.[node.id]) nodeItem.src_node_id = options.nodeIdMap[node.id];
		if (node.type === "n8n-nodes-base.aiTransform" && options?.isCloudDeployment) nodeItem.prompts = { instructions: node.parameters.instructions };
		else if (node.type === "@n8n/n8n-nodes-langchain.agent") {
			nodeItem.agent = node.parameters.agent ?? "toolsAgent";
			if (node.typeVersion >= 2.1) {
				const options$1 = node.parameters?.options;
				if (typeof options$1 === "object" && options$1 && "enableStreaming" in options$1 && options$1.enableStreaming === false) nodeItem.is_streaming = false;
				else nodeItem.is_streaming = true;
			}
		} else if (node.type === "n8n-nodes-base.merge") {
			nodeItem.operation = node.parameters.mode;
			if (options?.isCloudDeployment && node.parameters.mode === "combineBySql") nodeItem.sql = node.parameters.query;
		} else if (node.type === "n8n-nodes-base.httpRequest" && node.typeVersion === 1) try {
			nodeItem.domain = new URL(node.parameters.url).hostname;
		} catch {
			nodeItem.domain = getDomainBase(node.parameters.url);
		}
		else if (node.type === "n8n-nodes-base.httpRequest" && node.typeVersion > 1) {
			const { authentication } = node.parameters;
			nodeItem.credential_type = {
				none: "none",
				genericCredentialType: node.parameters.genericAuthType,
				predefinedCredentialType: node.parameters.nodeCredentialType
			}[authentication];
			nodeItem.credential_set = node.credentials ? Object.keys(node.credentials).length > 0 : false;
			const { url } = node.parameters;
			nodeItem.domain_base = getDomainBase(url);
			nodeItem.domain_path = getDomainPath(url);
			nodeItem.method = node.parameters.requestMethod;
		} else if ("@n8n/n8n-nodes-langchain.toolHttpRequest" === node.type) {
			if (!nodeItem.toolSettings) nodeItem.toolSettings = {};
			nodeItem.toolSettings.url_type = "other";
			nodeItem.toolSettings.uses_auth = false;
			nodeItem.toolSettings.placeholders = 0;
			nodeItem.toolSettings.query_from_model_only = false;
			nodeItem.toolSettings.headers_from_model_only = false;
			nodeItem.toolSettings.body_from_model_only = false;
			const toolUrl = node.parameters?.url ?? "";
			nodeItem.toolSettings.placeholders += countPlaceholders(toolUrl);
			const authType = node.parameters?.authentication ?? "";
			if (authType && authType !== "none") nodeItem.toolSettings.uses_auth = true;
			if (toolUrl.startsWith("{") && toolUrl.endsWith("}")) nodeItem.toolSettings.url_type = "any";
			else if (toolUrl.includes("google.com")) nodeItem.toolSettings.url_type = "google";
			if (node.parameters?.sendBody) {
				if (node.parameters?.specifyBody === "model") nodeItem.toolSettings.body_from_model_only = true;
				if (node.parameters?.jsonBody) nodeItem.toolSettings.placeholders += countPlaceholders(node.parameters?.jsonBody);
				if (node.parameters?.parametersBody) {
					const parameters = (node.parameters?.parametersBody).values;
					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}
			if (node.parameters?.sendHeaders) {
				if (node.parameters?.specifyHeaders === "model") nodeItem.toolSettings.headers_from_model_only = true;
				if (node.parameters?.jsonHeaders) nodeItem.toolSettings.placeholders += countPlaceholders(node.parameters?.jsonHeaders);
				if (node.parameters?.parametersHeaders) {
					const parameters = (node.parameters?.parametersHeaders).values;
					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}
			if (node.parameters?.sendQuery) {
				if (node.parameters?.specifyQuery === "model") nodeItem.toolSettings.query_from_model_only = true;
				if (node.parameters?.jsonQuery) nodeItem.toolSettings.placeholders += countPlaceholders(node.parameters?.jsonQuery);
				if (node.parameters?.parametersQuery) {
					const parameters = (node.parameters?.parametersQuery).values;
					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}
		} else if (node.type === "n8n-nodes-base.webhook") {
			webhookNodeNames.push(node.name);
			const responseMode = node.parameters?.responseMode;
			nodeItem.response_mode = typeof responseMode === "string" ? responseMode : "onReceived";
		} else if (node.type === "@n8n/n8n-nodes-langchain.chatTrigger") {
			const options$1 = node.parameters?.options;
			if (typeof options$1 === "object" && options$1 && "responseMode" in options$1 && typeof options$1.responseMode === "string") nodeItem.response_mode = options$1.responseMode;
			const isPublic = node.parameters?.public;
			if (typeof isPublic === "boolean") nodeItem.public_chat = isPublic;
		} else if (node.type === "n8n-nodes-base.executeWorkflow" || node.type === "@n8n/n8n-nodes-langchain.toolWorkflow") {
			if (node.parameters?.workflowId) nodeItem.workflow_id = node.parameters?.workflowId;
		} else if (node.type === "n8n-nodes-base.evaluationTrigger") evaluationTriggerNodeNames.push(node.name);
		else if (node.type === "n8n-nodes-base.evaluation" && options?.isCloudDeployment && node.parameters?.operation === "setMetrics") {
			const metrics = node.parameters?.metrics;
			if (!metrics) nodeItem.metric_names = [node.parameters?.metric ?? "correctness"];
			else nodeItem.metric_names = metrics.assignments?.map((metric) => metric.name);
		} else if (node.type === "n8n-nodes-base.code") {
			const { language } = node.parameters;
			nodeItem.language = language === void 0 ? "javascript" : language === "python" ? "python" : language === "pythonNative" ? "pythonNative" : "unknown";
		} else try {
			const nodeType$1 = nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (nodeType$1) {
				const nodeParameters = getNodeParameters(nodeType$1.description.properties, node.parameters, true, false, node, nodeType$1.description);
				if (nodeParameters) [
					"operation",
					"resource",
					"mode"
				].forEach((key) => {
					if (nodeParameters.hasOwnProperty(key)) nodeItem[key] = nodeParameters[key]?.toString();
				});
			}
		} catch (e$1) {
			if (!(e$1 instanceof Error && typeof e$1.message === "string" && e$1.message.includes("Unrecognized node type"))) throw e$1;
		}
		if (options?.isCloudDeployment === true) {
			if (node.type === "@n8n/n8n-nodes-langchain.openAi") nodeItem.prompts = (node.parameters?.messages ?? {}).values ?? [];
			if (node.type === "@n8n/n8n-nodes-langchain.agent" || node.type === "@n8n/n8n-nodes-langchain.agentTool") {
				const prompts = {};
				if (node.parameters?.text) prompts.text = node.parameters.text;
				const nodeOptions = node.parameters?.options;
				if (nodeOptions) {
					for (const key of [
						"humanMessage",
						"systemMessage",
						"humanMessageTemplate",
						"prefix",
						"suffixChat",
						"suffix",
						"prefixPrompt",
						"suffixPrompt"
					]) if (nodeOptions[key]) prompts[key] = nodeOptions[key];
				}
				if (Object.keys(prompts).length) nodeItem.prompts = prompts;
			}
			if (node.type === "@n8n/n8n-nodes-langchain.chainSummarization") nodeItem.prompts = ((node.parameters?.options ?? {}).summarizationMethodAndPrompts ?? {}).values;
			if (LANGCHAIN_CUSTOM_TOOLS.includes(node.type)) nodeItem.prompts = { description: node.parameters?.description ?? "" };
			if (node.type === "@n8n/n8n-nodes-langchain.chainLlm") nodeItem.prompts = (node.parameters?.messages ?? {}).messageValues ?? [];
			if (node.type === "n8n-nodes-base.merge" && node.parameters?.operation === "combineBySql") nodeItem.sql = node.parameters?.query;
		}
		nodeGraph.nodes[index.toString()] = nodeItem;
		nameIndices[node.name] = index.toString();
	});
	const getGraphConnectionItem = (startNode, connectionItem) => {
		return {
			start: nameIndices[startNode],
			end: nameIndices[connectionItem.node]
		};
	};
	Object.keys(workflow.connections ?? []).forEach((nodeName) => {
		const connections = workflow.connections?.[nodeName];
		if (!connections) return;
		Object.keys(connections).forEach((key) => {
			connections[key].forEach((element) => {
				(element ?? []).forEach((element2) => {
					nodeGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
				});
			});
		});
	});
	return {
		nodeGraph,
		nameIndices,
		webhookNodeNames,
		evaluationTriggerNodeNames
	};
}
function getConnectedNodes(connections, nodeName, connectionType = NodeConnectionTypes.Main, depth = -1, checkedNodesIncoming) {
	const newDepth = depth === -1 ? depth : depth - 1;
	if (depth === 0) return [];
	if (!connections.hasOwnProperty(nodeName)) return [];
	let types$8;
	if (connectionType === "ALL") types$8 = Object.keys(connections[nodeName]);
	else if (connectionType === "ALL_NON_MAIN") types$8 = Object.keys(connections[nodeName]).filter((type) => type !== "main");
	else types$8 = [connectionType];
	let addNodes;
	let nodeIndex;
	let i$2;
	let parentNodeName;
	const returnNodes = [];
	types$8.forEach((type) => {
		if (!connections[nodeName].hasOwnProperty(type)) return;
		const checkedNodes = checkedNodesIncoming ? [...checkedNodesIncoming] : [];
		if (checkedNodes.includes(nodeName)) return;
		checkedNodes.push(nodeName);
		connections[nodeName][type].forEach((connectionsByIndex) => {
			connectionsByIndex?.forEach((connection) => {
				if (checkedNodes.includes(connection.node)) return;
				returnNodes.unshift(connection.node);
				addNodes = getConnectedNodes(connections, connection.node, connectionType, newDepth, checkedNodes);
				for (i$2 = addNodes.length; i$2--;) {
					parentNodeName = addNodes[i$2];
					nodeIndex = returnNodes.indexOf(parentNodeName);
					if (nodeIndex !== -1) returnNodes.splice(nodeIndex, 1);
					returnNodes.unshift(parentNodeName);
				}
			});
		});
	});
	return returnNodes;
}
function getChildNodes(connectionsBySourceNode, nodeName, type = NodeConnectionTypes.Main, depth = -1) {
	return getConnectedNodes(connectionsBySourceNode, nodeName, type, depth);
}
function getNodeByName(nodes, name) {
	if (Array.isArray(nodes)) return nodes.find((node) => node.name === name) || null;
	if (nodes.hasOwnProperty(name)) return nodes[name];
	return null;
}
function getParentNodes(connectionsByDestinationNode, nodeName, type = NodeConnectionTypes.Main, depth = -1) {
	return getConnectedNodes(connectionsByDestinationNode, nodeName, type, depth);
}
function mapConnectionsByDestination(connections) {
	const returnConnection = {};
	let connectionInfo;
	let maxIndex;
	for (const sourceNode in connections) {
		if (!connections.hasOwnProperty(sourceNode)) continue;
		for (const type of Object.keys(connections[sourceNode])) {
			if (!connections[sourceNode].hasOwnProperty(type)) continue;
			for (const inputIndex in connections[sourceNode][type]) {
				if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) continue;
				for (connectionInfo of connections[sourceNode][type][inputIndex] ?? []) {
					if (!returnConnection.hasOwnProperty(connectionInfo.node)) returnConnection[connectionInfo.node] = {};
					if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) returnConnection[connectionInfo.node][connectionInfo.type] = [];
					maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
					for (let j$1 = maxIndex; j$1 < connectionInfo.index; j$1++) returnConnection[connectionInfo.node][connectionInfo.type].push([]);
					returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index]?.push({
						node: sourceNode,
						type,
						index: parseInt(inputIndex, 10)
					});
				}
			}
		}
	}
	return returnConnection;
}
var globalState = { defaultTimezone: "America/New_York" };
function setGlobalState(state) {
	globalState = state;
}
function getGlobalState() {
	return deepCopy(globalState);
}
var EventMessageTypeNames;
(function(EventMessageTypeNames$1) {
	EventMessageTypeNames$1["generic"] = "$$EventMessage";
	EventMessageTypeNames$1["audit"] = "$$EventMessageAudit";
	EventMessageTypeNames$1["confirm"] = "$$EventMessageConfirm";
	EventMessageTypeNames$1["workflow"] = "$$EventMessageWorkflow";
	EventMessageTypeNames$1["node"] = "$$EventMessageNode";
	EventMessageTypeNames$1["execution"] = "$$EventMessageExecution";
	EventMessageTypeNames$1["aiNode"] = "$$EventMessageAiNode";
	EventMessageTypeNames$1["runner"] = "$$EventMessageRunner";
	EventMessageTypeNames$1["queue"] = "$$EventMessageQueue";
})(EventMessageTypeNames || (EventMessageTypeNames = {}));
var MessageEventBusDestinationTypeNames;
(function(MessageEventBusDestinationTypeNames$1) {
	MessageEventBusDestinationTypeNames$1["abstract"] = "$$AbstractMessageEventBusDestination";
	MessageEventBusDestinationTypeNames$1["webhook"] = "$$MessageEventBusDestinationWebhook";
	MessageEventBusDestinationTypeNames$1["sentry"] = "$$MessageEventBusDestinationSentry";
	MessageEventBusDestinationTypeNames$1["syslog"] = "$$MessageEventBusDestinationSyslog";
})(MessageEventBusDestinationTypeNames || (MessageEventBusDestinationTypeNames = {}));
const messageEventBusDestinationTypeNames = [
	MessageEventBusDestinationTypeNames.abstract,
	MessageEventBusDestinationTypeNames.webhook,
	MessageEventBusDestinationTypeNames.sentry,
	MessageEventBusDestinationTypeNames.syslog
];
const defaultMessageEventBusDestinationOptions = {
	__type: MessageEventBusDestinationTypeNames.abstract,
	id: "",
	label: "New Event Destination",
	enabled: true,
	subscribedEvents: ["n8n.audit", "n8n.workflow"],
	credentials: {},
	anonymizeAuditMessages: false
};
const defaultMessageEventBusDestinationSyslogOptions = {
	...defaultMessageEventBusDestinationOptions,
	__type: MessageEventBusDestinationTypeNames.syslog,
	label: "Syslog Server",
	expectedStatusCode: 200,
	host: "127.0.0.1",
	port: 514,
	protocol: "tcp",
	facility: 16,
	app_name: "n8n",
	eol: "\n"
};
const defaultMessageEventBusDestinationWebhookOptions = {
	...defaultMessageEventBusDestinationOptions,
	__type: MessageEventBusDestinationTypeNames.webhook,
	credentials: {},
	label: "Webhook Endpoint",
	expectedStatusCode: 200,
	responseCodeMustMatch: false,
	url: "https://",
	method: "POST",
	authentication: "none",
	sendQuery: false,
	sendHeaders: false,
	genericAuthType: "",
	nodeCredentialType: "",
	specifyHeaders: "",
	specifyQuery: "",
	jsonQuery: "",
	jsonHeaders: "",
	headerParameters: { parameters: [] },
	queryParameters: { parameters: [] },
	sendPayload: true,
	options: {}
};
const defaultMessageEventBusDestinationSentryOptions = {
	...defaultMessageEventBusDestinationOptions,
	__type: MessageEventBusDestinationTypeNames.sentry,
	label: "Sentry DSN",
	dsn: "https://",
	sendPayload: true
};
var tslib_es6_exports$1 = /* @__PURE__ */ __export({
	__addDisposableResource: () => __addDisposableResource$1,
	__assign: () => __assign$1,
	__asyncDelegator: () => __asyncDelegator$1,
	__asyncGenerator: () => __asyncGenerator$1,
	__asyncValues: () => __asyncValues$1,
	__await: () => __await$1,
	__awaiter: () => __awaiter$1,
	__classPrivateFieldGet: () => __classPrivateFieldGet$1,
	__classPrivateFieldIn: () => __classPrivateFieldIn$1,
	__classPrivateFieldSet: () => __classPrivateFieldSet$1,
	__createBinding: () => __createBinding$1,
	__decorate: () => __decorate$1,
	__disposeResources: () => __disposeResources$1,
	__esDecorate: () => __esDecorate$1,
	__exportStar: () => __exportStar$1,
	__extends: () => __extends$1,
	__generator: () => __generator$1,
	__importDefault: () => __importDefault$1,
	__importStar: () => __importStar$1,
	__makeTemplateObject: () => __makeTemplateObject$1,
	__metadata: () => __metadata$1,
	__param: () => __param$1,
	__propKey: () => __propKey$1,
	__read: () => __read$1,
	__rest: () => __rest$1,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers$1,
	__setFunctionName: () => __setFunctionName$2,
	__spread: () => __spread$1,
	__spreadArray: () => __spreadArray$1,
	__spreadArrays: () => __spreadArrays$1,
	__values: () => __values$1,
	default: () => tslib_es6_default$1
});
function __extends$1(d$1, b$5) {
	if (typeof b$5 !== "function" && b$5 !== null) throw new TypeError("Class extends value " + String(b$5) + " is not a constructor or null");
	extendStatics$1(d$1, b$5);
	function __() {
		this.constructor = d$1;
	}
	d$1.prototype = b$5 === null ? Object.create(b$5) : (__.prototype = b$5.prototype, new __());
}
function __rest$1(s$2, e$1) {
	var t$1 = {};
	for (var p$1 in s$2) if (Object.prototype.hasOwnProperty.call(s$2, p$1) && e$1.indexOf(p$1) < 0) t$1[p$1] = s$2[p$1];
	if (s$2 != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i$2 = 0, p$1 = Object.getOwnPropertySymbols(s$2); i$2 < p$1.length; i$2++) if (e$1.indexOf(p$1[i$2]) < 0 && Object.prototype.propertyIsEnumerable.call(s$2, p$1[i$2])) t$1[p$1[i$2]] = s$2[p$1[i$2]];
	}
	return t$1;
}
function __decorate$1(decorators, target, key, desc) {
	var c$1 = arguments.length, r$1 = c$1 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d$1;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r$1 = Reflect.decorate(decorators, target, key, desc);
	else for (var i$2 = decorators.length - 1; i$2 >= 0; i$2--) if (d$1 = decorators[i$2]) r$1 = (c$1 < 3 ? d$1(r$1) : c$1 > 3 ? d$1(target, key, r$1) : d$1(target, key)) || r$1;
	return c$1 > 3 && r$1 && Object.defineProperty(target, key, r$1), r$1;
}
function __param$1(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate$1(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f$1) {
		if (f$1 !== void 0 && typeof f$1 !== "function") throw new TypeError("Function expected");
		return f$1;
	}
	var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _$1, done$1 = false;
	for (var i$2 = decorators.length - 1; i$2 >= 0; i$2--) {
		var context = {};
		for (var p$1 in contextIn) context[p$1] = p$1 === "access" ? {} : contextIn[p$1];
		for (var p$1 in contextIn.access) context.access[p$1] = contextIn.access[p$1];
		context.addInitializer = function(f$1) {
			if (done$1) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f$1 || null));
		};
		var result = (0, decorators[i$2])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_$1 = accept(result.get)) descriptor.get = _$1;
			if (_$1 = accept(result.set)) descriptor.set = _$1;
			if (_$1 = accept(result.init)) initializers.unshift(_$1);
		} else if (_$1 = accept(result)) if (kind === "field") initializers.unshift(_$1);
		else descriptor[key] = _$1;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done$1 = true;
}
function __runInitializers$1(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i$2 = 0; i$2 < initializers.length; i$2++) value = useValue ? initializers[i$2].call(thisArg, value) : initializers[i$2].call(thisArg);
	return useValue ? value : void 0;
}
function __propKey$1(x$1) {
	return typeof x$1 === "symbol" ? x$1 : "".concat(x$1);
}
function __setFunctionName$2(f$1, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f$1, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name
	});
}
function __metadata$1(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$1(thisArg, _arguments, P$1, generator) {
	function adopt(value) {
		return value instanceof P$1 ? value : new P$1(function(resolve) {
			resolve(value);
		});
	}
	return new (P$1 || (P$1 = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e$1) {
				reject(e$1);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e$1) {
				reject(e$1);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator$1(thisArg, body) {
	var _$1 = {
		label: 0,
		sent: function() {
			if (t$1[0] & 1) throw t$1[1];
			return t$1[1];
		},
		trys: [],
		ops: []
	}, f$1, y$1, t$1, g$3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return g$3.next = verb(0), g$3["throw"] = verb(1), g$3["return"] = verb(2), typeof Symbol === "function" && (g$3[Symbol.iterator] = function() {
		return this;
	}), g$3;
	function verb(n$6) {
		return function(v$3) {
			return step([n$6, v$3]);
		};
	}
	function step(op) {
		if (f$1) throw new TypeError("Generator is already executing.");
		while (g$3 && (g$3 = 0, op[0] && (_$1 = 0)), _$1) try {
			if (f$1 = 1, y$1 && (t$1 = op[0] & 2 ? y$1["return"] : op[0] ? y$1["throw"] || ((t$1 = y$1["return"]) && t$1.call(y$1), 0) : y$1.next) && !(t$1 = t$1.call(y$1, op[1])).done) return t$1;
			if (y$1 = 0, t$1) op = [op[0] & 2, t$1.value];
			switch (op[0]) {
				case 0:
				case 1:
					t$1 = op;
					break;
				case 4:
					_$1.label++;
					return {
						value: op[1],
						done: false
					};
				case 5:
					_$1.label++;
					y$1 = op[1];
					op = [0];
					continue;
				case 7:
					op = _$1.ops.pop();
					_$1.trys.pop();
					continue;
				default:
					if (!(t$1 = _$1.trys, t$1 = t$1.length > 0 && t$1[t$1.length - 1]) && (op[0] === 6 || op[0] === 2)) {
						_$1 = 0;
						continue;
					}
					if (op[0] === 3 && (!t$1 || op[1] > t$1[0] && op[1] < t$1[3])) {
						_$1.label = op[1];
						break;
					}
					if (op[0] === 6 && _$1.label < t$1[1]) {
						_$1.label = t$1[1];
						t$1 = op;
						break;
					}
					if (t$1 && _$1.label < t$1[2]) {
						_$1.label = t$1[2];
						_$1.ops.push(op);
						break;
					}
					if (t$1[2]) _$1.ops.pop();
					_$1.trys.pop();
					continue;
			}
			op = body.call(thisArg, _$1);
		} catch (e$1) {
			op = [6, e$1];
			y$1 = 0;
		} finally {
			f$1 = t$1 = 0;
		}
		if (op[0] & 5) throw op[1];
		return {
			value: op[0] ? op[1] : void 0,
			done: true
		};
	}
}
function __exportStar$1(m$1, o$1) {
	for (var p$1 in m$1) if (p$1 !== "default" && !Object.prototype.hasOwnProperty.call(o$1, p$1)) __createBinding$1(o$1, m$1, p$1);
}
function __values$1(o$1) {
	var s$2 = typeof Symbol === "function" && Symbol.iterator, m$1 = s$2 && o$1[s$2], i$2 = 0;
	if (m$1) return m$1.call(o$1);
	if (o$1 && typeof o$1.length === "number") return { next: function() {
		if (o$1 && i$2 >= o$1.length) o$1 = void 0;
		return {
			value: o$1 && o$1[i$2++],
			done: !o$1
		};
	} };
	throw new TypeError(s$2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o$1, n$6) {
	var m$1 = typeof Symbol === "function" && o$1[Symbol.iterator];
	if (!m$1) return o$1;
	var i$2 = m$1.call(o$1), r$1, ar = [], e$1;
	try {
		while ((n$6 === void 0 || n$6-- > 0) && !(r$1 = i$2.next()).done) ar.push(r$1.value);
	} catch (error$1) {
		e$1 = { error: error$1 };
	} finally {
		try {
			if (r$1 && !r$1.done && (m$1 = i$2["return"])) m$1.call(i$2);
		} finally {
			if (e$1) throw e$1.error;
		}
	}
	return ar;
}
function __spread$1() {
	for (var ar = [], i$2 = 0; i$2 < arguments.length; i$2++) ar = ar.concat(__read$1(arguments[i$2]));
	return ar;
}
function __spreadArrays$1() {
	for (var s$2 = 0, i$2 = 0, il = arguments.length; i$2 < il; i$2++) s$2 += arguments[i$2].length;
	for (var r$1 = Array(s$2), k$1 = 0, i$2 = 0; i$2 < il; i$2++) for (var a$1 = arguments[i$2], j$1 = 0, jl = a$1.length; j$1 < jl; j$1++, k$1++) r$1[k$1] = a$1[j$1];
	return r$1;
}
function __spreadArray$1(to, from$2, pack) {
	if (pack || arguments.length === 2) {
		for (var i$2 = 0, l$2 = from$2.length, ar; i$2 < l$2; i$2++) if (ar || !(i$2 in from$2)) {
			if (!ar) ar = Array.prototype.slice.call(from$2, 0, i$2);
			ar[i$2] = from$2[i$2];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from$2));
}
function __await$1(v$3) {
	return this instanceof __await$1 ? (this.v = v$3, this) : new __await$1(v$3);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g$3 = generator.apply(thisArg, _arguments || []), i$2, q$1 = [];
	return i$2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2;
	function awaitReturn(f$1) {
		return function(v$3) {
			return Promise.resolve(v$3).then(f$1, reject);
		};
	}
	function verb(n$6, f$1) {
		if (g$3[n$6]) {
			i$2[n$6] = function(v$3) {
				return new Promise(function(a$1, b$5) {
					q$1.push([
						n$6,
						v$3,
						a$1,
						b$5
					]) > 1 || resume$1(n$6, v$3);
				});
			};
			if (f$1) i$2[n$6] = f$1(i$2[n$6]);
		}
	}
	function resume$1(n$6, v$3) {
		try {
			step(g$3[n$6](v$3));
		} catch (e$1) {
			settle(q$1[0][3], e$1);
		}
	}
	function step(r$1) {
		r$1.value instanceof __await$1 ? Promise.resolve(r$1.value.v).then(fulfill, reject) : settle(q$1[0][2], r$1);
	}
	function fulfill(value) {
		resume$1("next", value);
	}
	function reject(value) {
		resume$1("throw", value);
	}
	function settle(f$1, v$3) {
		if (f$1(v$3), q$1.shift(), q$1.length) resume$1(q$1[0][0], q$1[0][1]);
	}
}
function __asyncDelegator$1(o$1) {
	var i$2, p$1;
	return i$2 = {}, verb("next"), verb("throw", function(e$1) {
		throw e$1;
	}), verb("return"), i$2[Symbol.iterator] = function() {
		return this;
	}, i$2;
	function verb(n$6, f$1) {
		i$2[n$6] = o$1[n$6] ? function(v$3) {
			return (p$1 = !p$1) ? {
				value: __await$1(o$1[n$6](v$3)),
				done: false
			} : f$1 ? f$1(v$3) : v$3;
		} : f$1;
	}
}
function __asyncValues$1(o$1) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m$1 = o$1[Symbol.asyncIterator], i$2;
	return m$1 ? m$1.call(o$1) : (o$1 = typeof __values$1 === "function" ? __values$1(o$1) : o$1[Symbol.iterator](), i$2 = {}, verb("next"), verb("throw"), verb("return"), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2);
	function verb(n$6) {
		i$2[n$6] = o$1[n$6] && function(v$3) {
			return new Promise(function(resolve, reject) {
				v$3 = o$1[n$6](v$3), settle(resolve, reject, v$3.done, v$3.value);
			});
		};
	}
	function settle(resolve, reject, d$1, v$3) {
		Promise.resolve(v$3).then(function(v$4) {
			resolve({
				value: v$4,
				done: d$1
			});
		}, reject);
	}
}
function __makeTemplateObject$1(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar$1(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k$1 = ownKeys$1(mod), i$2 = 0; i$2 < k$1.length; i$2++) if (k$1[i$2] !== "default") __createBinding$1(result, mod, k$1[i$2]);
	}
	__setModuleDefault$1(result, mod);
	return result;
}
function __importDefault$1(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet$1(receiver, state, kind, f$1) {
	if (kind === "a" && !f$1) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f$1 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f$1 : kind === "a" ? f$1.call(receiver) : f$1 ? f$1.value : state.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state, value, kind, f$1) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f$1) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f$1 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f$1.call(receiver, value) : f$1 ? f$1.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn$1(state, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource$1(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		var dispose, inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e$1) {
				return Promise.reject(e$1);
			}
		};
		env.stack.push({
			value,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value;
}
function __disposeResources$1(env) {
	function fail$1(e$1) {
		env.error = env.hasError ? new _SuppressedError$1(e$1, env.error, "An error was suppressed during disposal.") : e$1;
		env.hasError = true;
	}
	var r$1, s$2 = 0;
	function next() {
		while (r$1 = env.stack.pop()) try {
			if (!r$1.async && s$2 === 1) return s$2 = 0, env.stack.push(r$1), Promise.resolve().then(next);
			if (r$1.dispose) {
				var result = r$1.dispose.call(r$1.value);
				if (r$1.async) return s$2 |= 2, Promise.resolve(result).then(next, function(e$1) {
					fail$1(e$1);
					return next();
				});
			} else s$2 |= 1;
		} catch (e$1) {
			fail$1(e$1);
		}
		if (s$2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
	if (typeof path === "string" && /^\.\.?\//.test(path)) return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m$1, tsx, d$1, ext, cm) {
		return tsx ? preserveJsx ? ".jsx" : ".js" : d$1 && (!ext || !cm) ? m$1 : d$1 + ext + "." + cm.toLowerCase() + "js";
	});
	return path;
}
var extendStatics$1, __assign$1, __createBinding$1, __setModuleDefault$1, ownKeys$1, _SuppressedError$1, tslib_es6_default$1;
var init_tslib_es6$1 = __esmMin((() => {
	extendStatics$1 = function(d$1, b$5) {
		extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$6) {
			d$2.__proto__ = b$6;
		} || function(d$2, b$6) {
			for (var p$1 in b$6) if (Object.prototype.hasOwnProperty.call(b$6, p$1)) d$2[p$1] = b$6[p$1];
		};
		return extendStatics$1(d$1, b$5);
	};
	__assign$1 = function() {
		__assign$1 = Object.assign || function __assign$2(t$1) {
			for (var s$2, i$2 = 1, n$6 = arguments.length; i$2 < n$6; i$2++) {
				s$2 = arguments[i$2];
				for (var p$1 in s$2) if (Object.prototype.hasOwnProperty.call(s$2, p$1)) t$1[p$1] = s$2[p$1];
			}
			return t$1;
		};
		return __assign$1.apply(this, arguments);
	};
	__createBinding$1 = Object.create ? (function(o$1, m$1, k$1, k2) {
		if (k2 === void 0) k2 = k$1;
		var desc = Object.getOwnPropertyDescriptor(m$1, k$1);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k$1];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$1, k$1, k2) {
		if (k2 === void 0) k2 = k$1;
		o$1[k2] = m$1[k$1];
	});
	__setModuleDefault$1 = Object.create ? (function(o$1, v$3) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v$3
		});
	}) : function(o$1, v$3) {
		o$1["default"] = v$3;
	};
	ownKeys$1 = function(o$1) {
		ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
			var ar = [];
			for (var k$1 in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k$1)) ar[ar.length] = k$1;
			return ar;
		};
		return ownKeys$1(o$1);
	};
	_SuppressedError$1 = typeof SuppressedError === "function" ? SuppressedError : function(error$1, suppressed, message) {
		var e$1 = new Error(message);
		return e$1.name = "SuppressedError", e$1.error = error$1, e$1.suppressed = suppressed, e$1;
	};
	tslib_es6_default$1 = {
		__extends: __extends$1,
		__assign: __assign$1,
		__rest: __rest$1,
		__decorate: __decorate$1,
		__param: __param$1,
		__esDecorate: __esDecorate$1,
		__runInitializers: __runInitializers$1,
		__propKey: __propKey$1,
		__setFunctionName: __setFunctionName$2,
		__metadata: __metadata$1,
		__awaiter: __awaiter$1,
		__generator: __generator$1,
		__createBinding: __createBinding$1,
		__exportStar: __exportStar$1,
		__values: __values$1,
		__read: __read$1,
		__spread: __spread$1,
		__spreadArrays: __spreadArrays$1,
		__spreadArray: __spreadArray$1,
		__await: __await$1,
		__asyncGenerator: __asyncGenerator$1,
		__asyncDelegator: __asyncDelegator$1,
		__asyncValues: __asyncValues$1,
		__makeTemplateObject: __makeTemplateObject$1,
		__importStar: __importStar$1,
		__importDefault: __importDefault$1,
		__classPrivateFieldGet: __classPrivateFieldGet$1,
		__classPrivateFieldSet: __classPrivateFieldSet$1,
		__classPrivateFieldIn: __classPrivateFieldIn$1,
		__addDisposableResource: __addDisposableResource$1,
		__disposeResources: __disposeResources$1,
		__rewriteRelativeImportExtension
	};
}));
var tslib_es6_exports = /* @__PURE__ */ __export({
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName$1,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default
});
function __extends(d$1, b$5) {
	if (typeof b$5 !== "function" && b$5 !== null) throw new TypeError("Class extends value " + String(b$5) + " is not a constructor or null");
	extendStatics(d$1, b$5);
	function __() {
		this.constructor = d$1;
	}
	d$1.prototype = b$5 === null ? Object.create(b$5) : (__.prototype = b$5.prototype, new __());
}
function __rest(s$2, e$1) {
	var t$1 = {};
	for (var p$1 in s$2) if (Object.prototype.hasOwnProperty.call(s$2, p$1) && e$1.indexOf(p$1) < 0) t$1[p$1] = s$2[p$1];
	if (s$2 != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i$2 = 0, p$1 = Object.getOwnPropertySymbols(s$2); i$2 < p$1.length; i$2++) if (e$1.indexOf(p$1[i$2]) < 0 && Object.prototype.propertyIsEnumerable.call(s$2, p$1[i$2])) t$1[p$1[i$2]] = s$2[p$1[i$2]];
	}
	return t$1;
}
function __decorate(decorators, target, key, desc) {
	var c$1 = arguments.length, r$1 = c$1 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d$1;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r$1 = Reflect.decorate(decorators, target, key, desc);
	else for (var i$2 = decorators.length - 1; i$2 >= 0; i$2--) if (d$1 = decorators[i$2]) r$1 = (c$1 < 3 ? d$1(r$1) : c$1 > 3 ? d$1(target, key, r$1) : d$1(target, key)) || r$1;
	return c$1 > 3 && r$1 && Object.defineProperty(target, key, r$1), r$1;
}
function __param(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f$1) {
		if (f$1 !== void 0 && typeof f$1 !== "function") throw new TypeError("Function expected");
		return f$1;
	}
	var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _$1, done$1 = false;
	for (var i$2 = decorators.length - 1; i$2 >= 0; i$2--) {
		var context = {};
		for (var p$1 in contextIn) context[p$1] = p$1 === "access" ? {} : contextIn[p$1];
		for (var p$1 in contextIn.access) context.access[p$1] = contextIn.access[p$1];
		context.addInitializer = function(f$1) {
			if (done$1) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f$1 || null));
		};
		var result = (0, decorators[i$2])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_$1 = accept(result.get)) descriptor.get = _$1;
			if (_$1 = accept(result.set)) descriptor.set = _$1;
			if (_$1 = accept(result.init)) initializers.unshift(_$1);
		} else if (_$1 = accept(result)) if (kind === "field") initializers.unshift(_$1);
		else descriptor[key] = _$1;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done$1 = true;
}
function __runInitializers(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i$2 = 0; i$2 < initializers.length; i$2++) value = useValue ? initializers[i$2].call(thisArg, value) : initializers[i$2].call(thisArg);
	return useValue ? value : void 0;
}
function __propKey(x$1) {
	return typeof x$1 === "symbol" ? x$1 : "".concat(x$1);
}
function __setFunctionName$1(f$1, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f$1, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P$1, generator) {
	function adopt(value) {
		return value instanceof P$1 ? value : new P$1(function(resolve) {
			resolve(value);
		});
	}
	return new (P$1 || (P$1 = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e$1) {
				reject(e$1);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e$1) {
				reject(e$1);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _$1 = {
		label: 0,
		sent: function() {
			if (t$1[0] & 1) throw t$1[1];
			return t$1[1];
		},
		trys: [],
		ops: []
	}, f$1, y$1, t$1, g$3;
	return g$3 = {
		next: verb(0),
		"throw": verb(1),
		"return": verb(2)
	}, typeof Symbol === "function" && (g$3[Symbol.iterator] = function() {
		return this;
	}), g$3;
	function verb(n$6) {
		return function(v$3) {
			return step([n$6, v$3]);
		};
	}
	function step(op) {
		if (f$1) throw new TypeError("Generator is already executing.");
		while (g$3 && (g$3 = 0, op[0] && (_$1 = 0)), _$1) try {
			if (f$1 = 1, y$1 && (t$1 = op[0] & 2 ? y$1["return"] : op[0] ? y$1["throw"] || ((t$1 = y$1["return"]) && t$1.call(y$1), 0) : y$1.next) && !(t$1 = t$1.call(y$1, op[1])).done) return t$1;
			if (y$1 = 0, t$1) op = [op[0] & 2, t$1.value];
			switch (op[0]) {
				case 0:
				case 1:
					t$1 = op;
					break;
				case 4:
					_$1.label++;
					return {
						value: op[1],
						done: false
					};
				case 5:
					_$1.label++;
					y$1 = op[1];
					op = [0];
					continue;
				case 7:
					op = _$1.ops.pop();
					_$1.trys.pop();
					continue;
				default:
					if (!(t$1 = _$1.trys, t$1 = t$1.length > 0 && t$1[t$1.length - 1]) && (op[0] === 6 || op[0] === 2)) {
						_$1 = 0;
						continue;
					}
					if (op[0] === 3 && (!t$1 || op[1] > t$1[0] && op[1] < t$1[3])) {
						_$1.label = op[1];
						break;
					}
					if (op[0] === 6 && _$1.label < t$1[1]) {
						_$1.label = t$1[1];
						t$1 = op;
						break;
					}
					if (t$1 && _$1.label < t$1[2]) {
						_$1.label = t$1[2];
						_$1.ops.push(op);
						break;
					}
					if (t$1[2]) _$1.ops.pop();
					_$1.trys.pop();
					continue;
			}
			op = body.call(thisArg, _$1);
		} catch (e$1) {
			op = [6, e$1];
			y$1 = 0;
		} finally {
			f$1 = t$1 = 0;
		}
		if (op[0] & 5) throw op[1];
		return {
			value: op[0] ? op[1] : void 0,
			done: true
		};
	}
}
function __exportStar(m$1, o$1) {
	for (var p$1 in m$1) if (p$1 !== "default" && !Object.prototype.hasOwnProperty.call(o$1, p$1)) __createBinding(o$1, m$1, p$1);
}
function __values(o$1) {
	var s$2 = typeof Symbol === "function" && Symbol.iterator, m$1 = s$2 && o$1[s$2], i$2 = 0;
	if (m$1) return m$1.call(o$1);
	if (o$1 && typeof o$1.length === "number") return { next: function() {
		if (o$1 && i$2 >= o$1.length) o$1 = void 0;
		return {
			value: o$1 && o$1[i$2++],
			done: !o$1
		};
	} };
	throw new TypeError(s$2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o$1, n$6) {
	var m$1 = typeof Symbol === "function" && o$1[Symbol.iterator];
	if (!m$1) return o$1;
	var i$2 = m$1.call(o$1), r$1, ar = [], e$1;
	try {
		while ((n$6 === void 0 || n$6-- > 0) && !(r$1 = i$2.next()).done) ar.push(r$1.value);
	} catch (error$1) {
		e$1 = { error: error$1 };
	} finally {
		try {
			if (r$1 && !r$1.done && (m$1 = i$2["return"])) m$1.call(i$2);
		} finally {
			if (e$1) throw e$1.error;
		}
	}
	return ar;
}
function __spread() {
	for (var ar = [], i$2 = 0; i$2 < arguments.length; i$2++) ar = ar.concat(__read(arguments[i$2]));
	return ar;
}
function __spreadArrays() {
	for (var s$2 = 0, i$2 = 0, il = arguments.length; i$2 < il; i$2++) s$2 += arguments[i$2].length;
	for (var r$1 = Array(s$2), k$1 = 0, i$2 = 0; i$2 < il; i$2++) for (var a$1 = arguments[i$2], j$1 = 0, jl = a$1.length; j$1 < jl; j$1++, k$1++) r$1[k$1] = a$1[j$1];
	return r$1;
}
function __spreadArray(to, from$2, pack) {
	if (pack || arguments.length === 2) {
		for (var i$2 = 0, l$2 = from$2.length, ar; i$2 < l$2; i$2++) if (ar || !(i$2 in from$2)) {
			if (!ar) ar = Array.prototype.slice.call(from$2, 0, i$2);
			ar[i$2] = from$2[i$2];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from$2));
}
function __await(v$3) {
	return this instanceof __await ? (this.v = v$3, this) : new __await(v$3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g$3 = generator.apply(thisArg, _arguments || []), i$2, q$1 = [];
	return i$2 = {}, verb("next"), verb("throw"), verb("return"), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2;
	function verb(n$6) {
		if (g$3[n$6]) i$2[n$6] = function(v$3) {
			return new Promise(function(a$1, b$5) {
				q$1.push([
					n$6,
					v$3,
					a$1,
					b$5
				]) > 1 || resume$1(n$6, v$3);
			});
		};
	}
	function resume$1(n$6, v$3) {
		try {
			step(g$3[n$6](v$3));
		} catch (e$1) {
			settle(q$1[0][3], e$1);
		}
	}
	function step(r$1) {
		r$1.value instanceof __await ? Promise.resolve(r$1.value.v).then(fulfill, reject) : settle(q$1[0][2], r$1);
	}
	function fulfill(value) {
		resume$1("next", value);
	}
	function reject(value) {
		resume$1("throw", value);
	}
	function settle(f$1, v$3) {
		if (f$1(v$3), q$1.shift(), q$1.length) resume$1(q$1[0][0], q$1[0][1]);
	}
}
function __asyncDelegator(o$1) {
	var i$2, p$1;
	return i$2 = {}, verb("next"), verb("throw", function(e$1) {
		throw e$1;
	}), verb("return"), i$2[Symbol.iterator] = function() {
		return this;
	}, i$2;
	function verb(n$6, f$1) {
		i$2[n$6] = o$1[n$6] ? function(v$3) {
			return (p$1 = !p$1) ? {
				value: __await(o$1[n$6](v$3)),
				done: false
			} : f$1 ? f$1(v$3) : v$3;
		} : f$1;
	}
}
function __asyncValues(o$1) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m$1 = o$1[Symbol.asyncIterator], i$2;
	return m$1 ? m$1.call(o$1) : (o$1 = typeof __values === "function" ? __values(o$1) : o$1[Symbol.iterator](), i$2 = {}, verb("next"), verb("throw"), verb("return"), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2);
	function verb(n$6) {
		i$2[n$6] = o$1[n$6] && function(v$3) {
			return new Promise(function(resolve, reject) {
				v$3 = o$1[n$6](v$3), settle(resolve, reject, v$3.done, v$3.value);
			});
		};
	}
	function settle(resolve, reject, d$1, v$3) {
		Promise.resolve(v$3).then(function(v$4) {
			resolve({
				value: v$4,
				done: d$1
			});
		}, reject);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k$1 in mod) if (k$1 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$1)) __createBinding(result, mod, k$1);
	}
	__setModuleDefault(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f$1) {
	if (kind === "a" && !f$1) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f$1 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f$1 : kind === "a" ? f$1.call(receiver) : f$1 ? f$1.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f$1) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f$1) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f$1 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f$1.call(receiver, value) : f$1 ? f$1.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		var dispose;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		env.stack.push({
			value,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value;
}
function __disposeResources(env) {
	function fail$1(e$1) {
		env.error = env.hasError ? new _SuppressedError(e$1, env.error, "An error was suppressed during disposal.") : e$1;
		env.hasError = true;
	}
	function next() {
		while (env.stack.length) {
			var rec = env.stack.pop();
			try {
				var result = rec.dispose && rec.dispose.call(rec.value);
				if (rec.async) return Promise.resolve(result).then(next, function(e$1) {
					fail$1(e$1);
					return next();
				});
			} catch (e$1) {
				fail$1(e$1);
			}
		}
		if (env.hasError) throw env.error;
	}
	return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esmMin((() => {
	extendStatics = function(d$1, b$5) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$6) {
			d$2.__proto__ = b$6;
		} || function(d$2, b$6) {
			for (var p$1 in b$6) if (Object.prototype.hasOwnProperty.call(b$6, p$1)) d$2[p$1] = b$6[p$1];
		};
		return extendStatics(d$1, b$5);
	};
	__assign = function() {
		__assign = Object.assign || function __assign$2(t$1) {
			for (var s$2, i$2 = 1, n$6 = arguments.length; i$2 < n$6; i$2++) {
				s$2 = arguments[i$2];
				for (var p$1 in s$2) if (Object.prototype.hasOwnProperty.call(s$2, p$1)) t$1[p$1] = s$2[p$1];
			}
			return t$1;
		};
		return __assign.apply(this, arguments);
	};
	__createBinding = Object.create ? (function(o$1, m$1, k$1, k2) {
		if (k2 === void 0) k2 = k$1;
		var desc = Object.getOwnPropertyDescriptor(m$1, k$1);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k$1];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m$1, k$1, k2) {
		if (k2 === void 0) k2 = k$1;
		o$1[k2] = m$1[k$1];
	});
	__setModuleDefault = Object.create ? (function(o$1, v$3) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v$3
		});
	}) : function(o$1, v$3) {
		o$1["default"] = v$3;
	};
	_SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error$1, suppressed, message) {
		var e$1 = new Error(message);
		return e$1.name = "SuppressedError", e$1.error = error$1, e$1.suppressed = suppressed, e$1;
	};
	tslib_es6_default = {
		__extends,
		__assign,
		__rest,
		__decorate,
		__param,
		__metadata,
		__awaiter,
		__generator,
		__createBinding,
		__exportStar,
		__values,
		__read,
		__spread,
		__spreadArrays,
		__spreadArray,
		__await,
		__asyncGenerator,
		__asyncDelegator,
		__asyncValues,
		__makeTemplateObject,
		__importStar,
		__importDefault,
		__classPrivateFieldGet,
		__classPrivateFieldSet,
		__classPrivateFieldIn,
		__addDisposableResource,
		__disposeResources
	};
}));
var require_types$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$57 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var Op$1 = Object.prototype;
	var objToStr$1 = Op$1.toString;
	var hasOwn$10 = Op$1.hasOwnProperty;
	var BaseType$1 = function() {
		function BaseType$2() {}
		BaseType$2.prototype.assert = function(value, deep) {
			if (!this.check(value, deep)) {
				var str = shallowStringify$1(value);
				throw new Error(str + " does not match type " + this);
			}
			return true;
		};
		BaseType$2.prototype.arrayOf = function() {
			return new ArrayType$1(this);
		};
		return BaseType$2;
	}();
	var ArrayType$1 = function(_super) {
		(0, tslib_1$57.__extends)(ArrayType$2, _super);
		function ArrayType$2(elemType) {
			var _this = _super.call(this) || this;
			_this.elemType = elemType;
			_this.kind = "ArrayType";
			return _this;
		}
		ArrayType$2.prototype.toString = function() {
			return "[" + this.elemType + "]";
		};
		ArrayType$2.prototype.check = function(value, deep) {
			var _this = this;
			return Array.isArray(value) && value.every(function(elem) {
				return _this.elemType.check(elem, deep);
			});
		};
		return ArrayType$2;
	}(BaseType$1);
	var IdentityType$1 = function(_super) {
		(0, tslib_1$57.__extends)(IdentityType$2, _super);
		function IdentityType$2(value) {
			var _this = _super.call(this) || this;
			_this.value = value;
			_this.kind = "IdentityType";
			return _this;
		}
		IdentityType$2.prototype.toString = function() {
			return String(this.value);
		};
		IdentityType$2.prototype.check = function(value, deep) {
			var result = value === this.value;
			if (!result && typeof deep === "function") deep(this, value);
			return result;
		};
		return IdentityType$2;
	}(BaseType$1);
	var ObjectType$1 = function(_super) {
		(0, tslib_1$57.__extends)(ObjectType$2, _super);
		function ObjectType$2(fields) {
			var _this = _super.call(this) || this;
			_this.fields = fields;
			_this.kind = "ObjectType";
			return _this;
		}
		ObjectType$2.prototype.toString = function() {
			return "{ " + this.fields.join(", ") + " }";
		};
		ObjectType$2.prototype.check = function(value, deep) {
			return objToStr$1.call(value) === objToStr$1.call({}) && this.fields.every(function(field) {
				return field.type.check(value[field.name], deep);
			});
		};
		return ObjectType$2;
	}(BaseType$1);
	var OrType$1 = function(_super) {
		(0, tslib_1$57.__extends)(OrType$2, _super);
		function OrType$2(types$8) {
			var _this = _super.call(this) || this;
			_this.types = types$8;
			_this.kind = "OrType";
			return _this;
		}
		OrType$2.prototype.toString = function() {
			return this.types.join(" | ");
		};
		OrType$2.prototype.check = function(value, deep) {
			return this.types.some(function(type) {
				return type.check(value, deep);
			});
		};
		return OrType$2;
	}(BaseType$1);
	var PredicateType$1 = function(_super) {
		(0, tslib_1$57.__extends)(PredicateType$2, _super);
		function PredicateType$2(name, predicate) {
			var _this = _super.call(this) || this;
			_this.name = name;
			_this.predicate = predicate;
			_this.kind = "PredicateType";
			return _this;
		}
		PredicateType$2.prototype.toString = function() {
			return this.name;
		};
		PredicateType$2.prototype.check = function(value, deep) {
			var result = this.predicate(value, deep);
			if (!result && typeof deep === "function") deep(this, value);
			return result;
		};
		return PredicateType$2;
	}(BaseType$1);
	var Def$1 = function() {
		function Def$2(type, typeName) {
			this.type = type;
			this.typeName = typeName;
			this.baseNames = [];
			this.ownFields = Object.create(null);
			this.allSupertypes = Object.create(null);
			this.supertypeList = [];
			this.allFields = Object.create(null);
			this.fieldNames = [];
			this.finalized = false;
			this.buildable = false;
			this.buildParams = [];
		}
		Def$2.prototype.isSupertypeOf = function(that) {
			if (that instanceof Def$2) {
				if (this.finalized !== true || that.finalized !== true) throw new Error("");
				return hasOwn$10.call(that.allSupertypes, this.typeName);
			} else throw new Error(that + " is not a Def");
		};
		Def$2.prototype.checkAllFields = function(value, deep) {
			var allFields = this.allFields;
			if (this.finalized !== true) throw new Error("" + this.typeName);
			function checkFieldByName(name) {
				var field = allFields[name];
				var type = field.type;
				var child = field.getValue(value);
				return type.check(child, deep);
			}
			return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
		};
		Def$2.prototype.bases = function() {
			var supertypeNames = [];
			for (var _i = 0; _i < arguments.length; _i++) supertypeNames[_i] = arguments[_i];
			var bases = this.baseNames;
			if (this.finalized) {
				if (supertypeNames.length !== bases.length) throw new Error("");
				for (var i$2 = 0; i$2 < supertypeNames.length; i$2++) if (supertypeNames[i$2] !== bases[i$2]) throw new Error("");
				return this;
			}
			supertypeNames.forEach(function(baseName) {
				if (bases.indexOf(baseName) < 0) bases.push(baseName);
			});
			return this;
		};
		return Def$2;
	}();
	exports.Def = Def$1;
	var Field$1 = function() {
		function Field$2(name, type, defaultFn, hidden) {
			this.name = name;
			this.type = type;
			this.defaultFn = defaultFn;
			this.hidden = !!hidden;
		}
		Field$2.prototype.toString = function() {
			return JSON.stringify(this.name) + ": " + this.type;
		};
		Field$2.prototype.getValue = function(obj) {
			var value = obj[this.name];
			if (typeof value !== "undefined") return value;
			if (typeof this.defaultFn === "function") value = this.defaultFn.call(obj);
			return value;
		};
		return Field$2;
	}();
	function shallowStringify$1(value) {
		if (Array.isArray(value)) return "[" + value.map(shallowStringify$1).join(", ") + "]";
		if (value && typeof value === "object") return "{ " + Object.keys(value).map(function(key) {
			return key + ": " + value[key];
		}).join(", ") + " }";
		return JSON.stringify(value);
	}
	function typesPlugin$1(_fork) {
		var Type$2 = {
			or: function() {
				var types$8 = [];
				for (var _i = 0; _i < arguments.length; _i++) types$8[_i] = arguments[_i];
				return new OrType$1(types$8.map(function(type) {
					return Type$2.from(type);
				}));
			},
			from: function(value, name) {
				if (value instanceof ArrayType$1 || value instanceof IdentityType$1 || value instanceof ObjectType$1 || value instanceof OrType$1 || value instanceof PredicateType$1) return value;
				if (value instanceof Def$1) return value.type;
				if (isArray$11.check(value)) {
					if (value.length !== 1) throw new Error("only one element type is permitted for typed arrays");
					return new ArrayType$1(Type$2.from(value[0]));
				}
				if (isObject$8.check(value)) return new ObjectType$1(Object.keys(value).map(function(name$1) {
					return new Field$1(name$1, Type$2.from(value[name$1], name$1));
				}));
				if (typeof value === "function") {
					var bicfIndex = builtInCtorFns.indexOf(value);
					if (bicfIndex >= 0) return builtInCtorTypes[bicfIndex];
					if (typeof name !== "string") throw new Error("missing name");
					return new PredicateType$1(name, value);
				}
				return new IdentityType$1(value);
			},
			def: function(typeName) {
				return hasOwn$10.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
			},
			hasDef: function(typeName) {
				return hasOwn$10.call(defCache, typeName);
			}
		};
		var builtInCtorFns = [];
		var builtInCtorTypes = [];
		function defBuiltInType(name, example) {
			var objStr = objToStr$1.call(example);
			var type = new PredicateType$1(name, function(value) {
				return objToStr$1.call(value) === objStr;
			});
			if (example && typeof example.constructor === "function") {
				builtInCtorFns.push(example.constructor);
				builtInCtorTypes.push(type);
			}
			return type;
		}
		var isString$4 = defBuiltInType("string", "truthy");
		var isFunction$2 = defBuiltInType("function", function() {});
		var isArray$11 = defBuiltInType("array", []);
		var isObject$8 = defBuiltInType("object", {});
		var isRegExp$3 = defBuiltInType("RegExp", /./);
		var isDate$4 = defBuiltInType("Date", /* @__PURE__ */ new Date());
		var isNumber$3 = defBuiltInType("number", 3);
		var isBoolean$1 = defBuiltInType("boolean", true);
		var isNull$1 = defBuiltInType("null", null);
		var isUndefined$2 = defBuiltInType("undefined", void 0);
		var builtInTypes$2 = {
			string: isString$4,
			function: isFunction$2,
			array: isArray$11,
			object: isObject$8,
			RegExp: isRegExp$3,
			Date: isDate$4,
			number: isNumber$3,
			boolean: isBoolean$1,
			null: isNull$1,
			undefined: isUndefined$2,
			BigInt: typeof BigInt === "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType$1("BigInt", function() {
				return false;
			})
		};
		var defCache = Object.create(null);
		function defFromValue(value) {
			if (value && typeof value === "object") {
				var type = value.type;
				if (typeof type === "string" && hasOwn$10.call(defCache, type)) {
					var d$1 = defCache[type];
					if (d$1.finalized) return d$1;
				}
			}
			return null;
		}
		var DefImpl = function(_super) {
			(0, tslib_1$57.__extends)(DefImpl$1, _super);
			function DefImpl$1(typeName) {
				var _this = _super.call(this, new PredicateType$1(typeName, function(value, deep) {
					return _this.check(value, deep);
				}), typeName) || this;
				return _this;
			}
			DefImpl$1.prototype.check = function(value, deep) {
				if (this.finalized !== true) throw new Error("prematurely checking unfinalized type " + this.typeName);
				if (value === null || typeof value !== "object") return false;
				var vDef = defFromValue(value);
				if (!vDef) {
					if (this.typeName === "SourceLocation" || this.typeName === "Position") return this.checkAllFields(value, deep);
					return false;
				}
				if (deep && vDef === this) return this.checkAllFields(value, deep);
				if (!this.isSupertypeOf(vDef)) return false;
				if (!deep) return true;
				return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
			};
			DefImpl$1.prototype.build = function() {
				var _this = this;
				var buildParams = [];
				for (var _i = 0; _i < arguments.length; _i++) buildParams[_i] = arguments[_i];
				this.buildParams = buildParams;
				if (this.buildable) return this;
				this.field("type", String, function() {
					return _this.typeName;
				});
				this.buildable = true;
				var addParam = function(built, param, arg, isArgAvailable) {
					if (hasOwn$10.call(built, param)) return;
					var all$1 = _this.allFields;
					if (!hasOwn$10.call(all$1, param)) throw new Error("" + param);
					var field = all$1[param];
					var type = field.type;
					var value;
					if (isArgAvailable) value = arg;
					else if (field.defaultFn) value = field.defaultFn.call(built);
					else {
						var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
							return all$1[name];
						}).join(", ") + ")";
						throw new Error(message);
					}
					if (!type.check(value)) throw new Error(shallowStringify$1(value) + " does not match field " + field + " of type " + _this.typeName);
					built[param] = value;
				};
				var builder = function() {
					var args = [];
					for (var _i$1 = 0; _i$1 < arguments.length; _i$1++) args[_i$1] = arguments[_i$1];
					var argc = args.length;
					if (!_this.finalized) throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
					var built = Object.create(nodePrototype);
					_this.buildParams.forEach(function(param, i$2) {
						if (i$2 < argc) addParam(built, param, args[i$2], true);
						else addParam(built, param, null, false);
					});
					Object.keys(_this.allFields).forEach(function(param) {
						addParam(built, param, null, false);
					});
					if (built.type !== _this.typeName) throw new Error("");
					return built;
				};
				builder.from = function(obj) {
					if (!_this.finalized) throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
					var built = Object.create(nodePrototype);
					Object.keys(_this.allFields).forEach(function(param) {
						if (hasOwn$10.call(obj, param)) addParam(built, param, obj[param], true);
						else addParam(built, param, null, false);
					});
					if (built.type !== _this.typeName) throw new Error("");
					return built;
				};
				Object.defineProperty(builders$2, getBuilderName$2(this.typeName), {
					enumerable: true,
					value: builder
				});
				return this;
			};
			DefImpl$1.prototype.field = function(name, type, defaultFn, hidden) {
				if (this.finalized) {
					console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
					return this;
				}
				this.ownFields[name] = new Field$1(name, Type$2.from(type), defaultFn, hidden);
				return this;
			};
			DefImpl$1.prototype.finalize = function() {
				var _this = this;
				if (!this.finalized) {
					var allFields = this.allFields;
					var allSupertypes = this.allSupertypes;
					this.baseNames.forEach(function(name) {
						var def = defCache[name];
						if (def instanceof Def$1) {
							def.finalize();
							extend$1(allFields, def.allFields);
							extend$1(allSupertypes, def.allSupertypes);
						} else {
							var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
							throw new Error(message);
						}
					});
					extend$1(allFields, this.ownFields);
					allSupertypes[this.typeName] = this;
					this.fieldNames.length = 0;
					for (var fieldName in allFields) if (hasOwn$10.call(allFields, fieldName) && !allFields[fieldName].hidden) this.fieldNames.push(fieldName);
					Object.defineProperty(namedTypes$1, this.typeName, {
						enumerable: true,
						value: this.type
					});
					this.finalized = true;
					populateSupertypeList(this.typeName, this.supertypeList);
					if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) wrapExpressionBuilderWithStatement(this.typeName);
				}
			};
			return DefImpl$1;
		}(Def$1);
		function getSupertypeNames$2(typeName) {
			if (!hasOwn$10.call(defCache, typeName)) throw new Error("");
			var d$1 = defCache[typeName];
			if (d$1.finalized !== true) throw new Error("");
			return d$1.supertypeList.slice(1);
		}
		function computeSupertypeLookupTable(candidates) {
			var table = {};
			var typeNames = Object.keys(defCache);
			var typeNameCount = typeNames.length;
			for (var i$2 = 0; i$2 < typeNameCount; ++i$2) {
				var typeName = typeNames[i$2];
				var d$1 = defCache[typeName];
				if (d$1.finalized !== true) throw new Error("" + typeName);
				for (var j$1 = 0; j$1 < d$1.supertypeList.length; ++j$1) {
					var superTypeName = d$1.supertypeList[j$1];
					if (hasOwn$10.call(candidates, superTypeName)) {
						table[typeName] = superTypeName;
						break;
					}
				}
			}
			return table;
		}
		var builders$2 = Object.create(null);
		var nodePrototype = {};
		function defineMethod$2(name, func) {
			var old = nodePrototype[name];
			if (isUndefined$2.check(func)) delete nodePrototype[name];
			else {
				isFunction$2.assert(func);
				Object.defineProperty(nodePrototype, name, {
					enumerable: true,
					configurable: true,
					value: func
				});
			}
			return old;
		}
		function getBuilderName$2(typeName) {
			return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
				var len$1 = upperCasePrefix.length;
				switch (len$1) {
					case 0: return "";
					case 1: return upperCasePrefix.toLowerCase();
					default: return upperCasePrefix.slice(0, len$1 - 1).toLowerCase() + upperCasePrefix.charAt(len$1 - 1);
				}
			});
		}
		function getStatementBuilderName(typeName) {
			typeName = getBuilderName$2(typeName);
			return typeName.replace(/(Expression)?$/, "Statement");
		}
		var namedTypes$1 = {};
		function getFieldNames$2(object) {
			var d$1 = defFromValue(object);
			if (d$1) return d$1.fieldNames.slice(0);
			if ("type" in object) throw new Error("did not recognize object of type " + JSON.stringify(object.type));
			return Object.keys(object);
		}
		function getFieldValue$2(object, fieldName) {
			var d$1 = defFromValue(object);
			if (d$1) {
				var field = d$1.allFields[fieldName];
				if (field) return field.getValue(object);
			}
			return object && object[fieldName];
		}
		function eachField$2(object, callback, context) {
			getFieldNames$2(object).forEach(function(name) {
				callback.call(this, name, getFieldValue$2(object, name));
			}, context);
		}
		function someField$2(object, callback, context) {
			return getFieldNames$2(object).some(function(name) {
				return callback.call(this, name, getFieldValue$2(object, name));
			}, context);
		}
		function wrapExpressionBuilderWithStatement(typeName) {
			var wrapperName = getStatementBuilderName(typeName);
			if (builders$2[wrapperName]) return;
			var wrapped = builders$2[getBuilderName$2(typeName)];
			if (!wrapped) return;
			var builder = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return builders$2.expressionStatement(wrapped.apply(builders$2, args));
			};
			builder.from = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return builders$2.expressionStatement(wrapped.from.apply(builders$2, args));
			};
			builders$2[wrapperName] = builder;
		}
		function populateSupertypeList(typeName, list) {
			list.length = 0;
			list.push(typeName);
			var lastSeen = Object.create(null);
			for (var pos = 0; pos < list.length; ++pos) {
				typeName = list[pos];
				var d$1 = defCache[typeName];
				if (d$1.finalized !== true) throw new Error("");
				if (hasOwn$10.call(lastSeen, typeName)) delete list[lastSeen[typeName]];
				lastSeen[typeName] = pos;
				list.push.apply(list, d$1.baseNames);
			}
			for (var to = 0, from$2 = to, len$1 = list.length; from$2 < len$1; ++from$2) if (hasOwn$10.call(list, from$2)) list[to++] = list[from$2];
			list.length = to;
		}
		function extend$1(into, from$2) {
			Object.keys(from$2).forEach(function(name) {
				into[name] = from$2[name];
			});
			return into;
		}
		function finalize$2() {
			Object.keys(defCache).forEach(function(name) {
				defCache[name].finalize();
			});
		}
		return {
			Type: Type$2,
			builtInTypes: builtInTypes$2,
			getSupertypeNames: getSupertypeNames$2,
			computeSupertypeLookupTable,
			builders: builders$2,
			defineMethod: defineMethod$2,
			getBuilderName: getBuilderName$2,
			getStatementBuilderName,
			namedTypes: namedTypes$1,
			getFieldNames: getFieldNames$2,
			getFieldValue: getFieldValue$2,
			eachField: eachField$2,
			someField: someField$2,
			finalize: finalize$2
		};
	}
	exports.default = typesPlugin$1;
}));
var require_path$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var types_1$43 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_types$1());
	var hasOwn$9 = Object.prototype.hasOwnProperty;
	function pathPlugin$1(fork) {
		var types$8 = fork.use(types_1$43.default);
		var isArray$11 = types$8.builtInTypes.array;
		var isNumber$3 = types$8.builtInTypes.number;
		var Path$2 = function Path$3(value, parentPath, name) {
			if (!(this instanceof Path$3)) throw new Error("Path constructor cannot be invoked without 'new'");
			if (parentPath) {
				if (!(parentPath instanceof Path$3)) throw new Error("");
			} else {
				parentPath = null;
				name = null;
			}
			this.value = value;
			this.parentPath = parentPath;
			this.name = name;
			this.__childCache = null;
		};
		var Pp$1 = Path$2.prototype;
		function getChildCache(path) {
			return path.__childCache || (path.__childCache = Object.create(null));
		}
		function getChildPath(path, name) {
			var cache$1 = getChildCache(path);
			var actualChildValue = path.getValueProperty(name);
			var childPath = cache$1[name];
			if (!hasOwn$9.call(cache$1, name) || childPath.value !== actualChildValue) childPath = cache$1[name] = new path.constructor(actualChildValue, path, name);
			return childPath;
		}
		Pp$1.getValueProperty = function getValueProperty(name) {
			return this.value[name];
		};
		Pp$1.get = function get$2() {
			var names = [];
			for (var _i = 0; _i < arguments.length; _i++) names[_i] = arguments[_i];
			var path = this;
			var count = names.length;
			for (var i$2 = 0; i$2 < count; ++i$2) path = getChildPath(path, names[i$2]);
			return path;
		};
		Pp$1.each = function each(callback, context) {
			var childPaths = [];
			var len$1 = this.value.length;
			var i$2 = 0;
			for (var i$2 = 0; i$2 < len$1; ++i$2) if (hasOwn$9.call(this.value, i$2)) childPaths[i$2] = this.get(i$2);
			context = context || this;
			for (i$2 = 0; i$2 < len$1; ++i$2) if (hasOwn$9.call(childPaths, i$2)) callback.call(context, childPaths[i$2]);
		};
		Pp$1.map = function map(callback, context) {
			var result = [];
			this.each(function(childPath) {
				result.push(callback.call(this, childPath));
			}, context);
			return result;
		};
		Pp$1.filter = function filter(callback, context) {
			var result = [];
			this.each(function(childPath) {
				if (callback.call(this, childPath)) result.push(childPath);
			}, context);
			return result;
		};
		function emptyMoves() {}
		function getMoves(path, offset$1, start, end) {
			isArray$11.assert(path.value);
			if (offset$1 === 0) return emptyMoves;
			var length$1 = path.value.length;
			if (length$1 < 1) return emptyMoves;
			var argc = arguments.length;
			if (argc === 2) {
				start = 0;
				end = length$1;
			} else if (argc === 3) {
				start = Math.max(start, 0);
				end = length$1;
			} else {
				start = Math.max(start, 0);
				end = Math.min(end, length$1);
			}
			isNumber$3.assert(start);
			isNumber$3.assert(end);
			var moves = Object.create(null);
			var cache$1 = getChildCache(path);
			for (var i$2 = start; i$2 < end; ++i$2) if (hasOwn$9.call(path.value, i$2)) {
				var childPath = path.get(i$2);
				if (childPath.name !== i$2) throw new Error("");
				var newIndex = i$2 + offset$1;
				childPath.name = newIndex;
				moves[newIndex] = childPath;
				delete cache$1[i$2];
			}
			delete cache$1.length;
			return function() {
				for (var newIndex$1 in moves) {
					var childPath$1 = moves[newIndex$1];
					if (childPath$1.name !== +newIndex$1) throw new Error("");
					cache$1[newIndex$1] = childPath$1;
					path.value[newIndex$1] = childPath$1.value;
				}
			};
		}
		Pp$1.shift = function shift() {
			var move = getMoves(this, -1);
			var result = this.value.shift();
			move();
			return result;
		};
		Pp$1.unshift = function unshift() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var move = getMoves(this, args.length);
			var result = this.value.unshift.apply(this.value, args);
			move();
			return result;
		};
		Pp$1.push = function push() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			isArray$11.assert(this.value);
			delete getChildCache(this).length;
			return this.value.push.apply(this.value, args);
		};
		Pp$1.pop = function pop() {
			isArray$11.assert(this.value);
			var cache$1 = getChildCache(this);
			delete cache$1[this.value.length - 1];
			delete cache$1.length;
			return this.value.pop();
		};
		Pp$1.insertAt = function insertAt(index) {
			var argc = arguments.length;
			var move = getMoves(this, argc - 1, index);
			if (move === emptyMoves && argc <= 1) return this;
			index = Math.max(index, 0);
			for (var i$2 = 1; i$2 < argc; ++i$2) this.value[index + i$2 - 1] = arguments[i$2];
			move();
			return this;
		};
		Pp$1.insertBefore = function insertBefore() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var pp = this.parentPath;
			var argc = args.length;
			var insertAtArgs = [this.name];
			for (var i$2 = 0; i$2 < argc; ++i$2) insertAtArgs.push(args[i$2]);
			return pp.insertAt.apply(pp, insertAtArgs);
		};
		Pp$1.insertAfter = function insertAfter() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var pp = this.parentPath;
			var argc = args.length;
			var insertAtArgs = [this.name + 1];
			for (var i$2 = 0; i$2 < argc; ++i$2) insertAtArgs.push(args[i$2]);
			return pp.insertAt.apply(pp, insertAtArgs);
		};
		function repairRelationshipWithParent(path) {
			if (!(path instanceof Path$2)) throw new Error("");
			var pp = path.parentPath;
			if (!pp) return path;
			var parentValue = pp.value;
			var parentCache = getChildCache(pp);
			if (parentValue[path.name] === path.value) parentCache[path.name] = path;
			else if (isArray$11.check(parentValue)) {
				var i$2 = parentValue.indexOf(path.value);
				if (i$2 >= 0) parentCache[path.name = i$2] = path;
			} else {
				parentValue[path.name] = path.value;
				parentCache[path.name] = path;
			}
			if (parentValue[path.name] !== path.value) throw new Error("");
			if (path.parentPath.get(path.name) !== path) throw new Error("");
			return path;
		}
		Pp$1.replace = function replace(replacement) {
			var results = [];
			var parentValue = this.parentPath.value;
			var parentCache = getChildCache(this.parentPath);
			var count = arguments.length;
			repairRelationshipWithParent(this);
			if (isArray$11.check(parentValue)) {
				var originalLength = parentValue.length;
				var move = getMoves(this.parentPath, count - 1, this.name + 1);
				var spliceArgs = [this.name, 1];
				for (var i$2 = 0; i$2 < count; ++i$2) spliceArgs.push(arguments[i$2]);
				if (parentValue.splice.apply(parentValue, spliceArgs)[0] !== this.value) throw new Error("");
				if (parentValue.length !== originalLength - 1 + count) throw new Error("");
				move();
				if (count === 0) {
					delete this.value;
					delete parentCache[this.name];
					this.__childCache = null;
				} else {
					if (parentValue[this.name] !== replacement) throw new Error("");
					if (this.value !== replacement) {
						this.value = replacement;
						this.__childCache = null;
					}
					for (i$2 = 0; i$2 < count; ++i$2) results.push(this.parentPath.get(this.name + i$2));
					if (results[0] !== this) throw new Error("");
				}
			} else if (count === 1) {
				if (this.value !== replacement) this.__childCache = null;
				this.value = parentValue[this.name] = replacement;
				results.push(this);
			} else if (count === 0) {
				delete parentValue[this.name];
				delete this.value;
				this.__childCache = null;
			} else throw new Error("Could not replace path");
			return results;
		};
		return Path$2;
	}
	exports.default = pathPlugin$1;
	module.exports = exports["default"];
}));
var require_scope$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var types_1$42 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_types$1());
	var hasOwn$8 = Object.prototype.hasOwnProperty;
	function scopePlugin$1(fork) {
		var types$8 = fork.use(types_1$42.default);
		var Type$2 = types$8.Type;
		var namedTypes$1 = types$8.namedTypes;
		var Node = namedTypes$1.Node;
		var Expression$2 = namedTypes$1.Expression;
		var isArray$11 = types$8.builtInTypes.array;
		var b$5 = types$8.builders;
		var Scope = function Scope$1(path, parentScope) {
			if (!(this instanceof Scope$1)) throw new Error("Scope constructor cannot be invoked without 'new'");
			if (!TypeParameterScopeType.check(path.value)) ScopeType.assert(path.value);
			var depth;
			if (parentScope) {
				if (!(parentScope instanceof Scope$1)) throw new Error("");
				depth = parentScope.depth + 1;
			} else {
				parentScope = null;
				depth = 0;
			}
			Object.defineProperties(this, {
				path: { value: path },
				node: { value: path.value },
				isGlobal: {
					value: !parentScope,
					enumerable: true
				},
				depth: { value: depth },
				parent: { value: parentScope },
				bindings: { value: {} },
				types: { value: {} }
			});
		};
		var ScopeType = Type$2.or(namedTypes$1.Program, namedTypes$1.Function, namedTypes$1.CatchClause);
		var TypeParameterScopeType = Type$2.or(namedTypes$1.Function, namedTypes$1.ClassDeclaration, namedTypes$1.ClassExpression, namedTypes$1.InterfaceDeclaration, namedTypes$1.TSInterfaceDeclaration, namedTypes$1.TypeAlias, namedTypes$1.TSTypeAliasDeclaration);
		var FlowOrTSTypeParameterType = Type$2.or(namedTypes$1.TypeParameter, namedTypes$1.TSTypeParameter);
		Scope.isEstablishedBy = function(node) {
			return ScopeType.check(node) || TypeParameterScopeType.check(node);
		};
		var Sp = Scope.prototype;
		Sp.didScan = false;
		Sp.declares = function(name) {
			this.scan();
			return hasOwn$8.call(this.bindings, name);
		};
		Sp.declaresType = function(name) {
			this.scan();
			return hasOwn$8.call(this.types, name);
		};
		Sp.declareTemporary = function(prefix) {
			if (prefix) {
				if (!/^[a-z$_]/i.test(prefix)) throw new Error("");
			} else prefix = "t$";
			prefix += this.depth.toString(36) + "$";
			this.scan();
			var index = 0;
			while (this.declares(prefix + index)) ++index;
			var name = prefix + index;
			return this.bindings[name] = types$8.builders.identifier(name);
		};
		Sp.injectTemporary = function(identifier, init) {
			identifier || (identifier = this.declareTemporary());
			var bodyPath = this.path.get("body");
			if (namedTypes$1.BlockStatement.check(bodyPath.value)) bodyPath = bodyPath.get("body");
			bodyPath.unshift(b$5.variableDeclaration("var", [b$5.variableDeclarator(identifier, init || null)]));
			return identifier;
		};
		Sp.scan = function(force) {
			if (force || !this.didScan) {
				for (var name in this.bindings) delete this.bindings[name];
				for (var name in this.types) delete this.types[name];
				scanScope(this.path, this.bindings, this.types);
				this.didScan = true;
			}
		};
		Sp.getBindings = function() {
			this.scan();
			return this.bindings;
		};
		Sp.getTypes = function() {
			this.scan();
			return this.types;
		};
		function scanScope(path, bindings, scopeTypes) {
			var node = path.value;
			if (TypeParameterScopeType.check(node)) {
				var params = path.get("typeParameters", "params");
				if (isArray$11.check(params.value)) params.each(function(childPath) {
					addTypeParameter(childPath, scopeTypes);
				});
			}
			if (ScopeType.check(node)) if (namedTypes$1.CatchClause.check(node)) addPattern(path.get("param"), bindings);
			else recursiveScanScope(path, bindings, scopeTypes);
		}
		function recursiveScanScope(path, bindings, scopeTypes) {
			var node = path.value;
			if (path.parent && namedTypes$1.FunctionExpression.check(path.parent.node) && path.parent.node.id) addPattern(path.parent.get("id"), bindings);
			if (!node) {} else if (isArray$11.check(node)) path.each(function(childPath) {
				recursiveScanChild(childPath, bindings, scopeTypes);
			});
			else if (namedTypes$1.Function.check(node)) {
				path.get("params").each(function(paramPath) {
					addPattern(paramPath, bindings);
				});
				recursiveScanChild(path.get("body"), bindings, scopeTypes);
				recursiveScanScope(path.get("typeParameters"), bindings, scopeTypes);
			} else if (namedTypes$1.TypeAlias && namedTypes$1.TypeAlias.check(node) || namedTypes$1.InterfaceDeclaration && namedTypes$1.InterfaceDeclaration.check(node) || namedTypes$1.TSTypeAliasDeclaration && namedTypes$1.TSTypeAliasDeclaration.check(node) || namedTypes$1.TSInterfaceDeclaration && namedTypes$1.TSInterfaceDeclaration.check(node)) addTypePattern(path.get("id"), scopeTypes);
			else if (namedTypes$1.VariableDeclarator.check(node)) {
				addPattern(path.get("id"), bindings);
				recursiveScanChild(path.get("init"), bindings, scopeTypes);
			} else if (node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier") addPattern(path.get(node.local ? "local" : node.name ? "name" : "id"), bindings);
			else if (Node.check(node) && !Expression$2.check(node)) types$8.eachField(node, function(name, child) {
				var childPath = path.get(name);
				if (!pathHasValue(childPath, child)) throw new Error("");
				recursiveScanChild(childPath, bindings, scopeTypes);
			});
		}
		function pathHasValue(path, value) {
			if (path.value === value) return true;
			if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) return true;
			return false;
		}
		function recursiveScanChild(path, bindings, scopeTypes) {
			var node = path.value;
			if (!node || Expression$2.check(node)) {} else if (namedTypes$1.FunctionDeclaration.check(node) && node.id !== null) addPattern(path.get("id"), bindings);
			else if (namedTypes$1.ClassDeclaration && namedTypes$1.ClassDeclaration.check(node) && node.id !== null) {
				addPattern(path.get("id"), bindings);
				recursiveScanScope(path.get("typeParameters"), bindings, scopeTypes);
			} else if (namedTypes$1.InterfaceDeclaration && namedTypes$1.InterfaceDeclaration.check(node) || namedTypes$1.TSInterfaceDeclaration && namedTypes$1.TSInterfaceDeclaration.check(node)) addTypePattern(path.get("id"), scopeTypes);
			else if (ScopeType.check(node)) {
				if (namedTypes$1.CatchClause.check(node) && namedTypes$1.Identifier.check(node.param)) {
					var catchParamName = node.param.name;
					var hadBinding = hasOwn$8.call(bindings, catchParamName);
					recursiveScanScope(path.get("body"), bindings, scopeTypes);
					if (!hadBinding) delete bindings[catchParamName];
				}
			} else recursiveScanScope(path, bindings, scopeTypes);
		}
		function addPattern(patternPath, bindings) {
			var pattern = patternPath.value;
			namedTypes$1.Pattern.assert(pattern);
			if (namedTypes$1.Identifier.check(pattern)) if (hasOwn$8.call(bindings, pattern.name)) bindings[pattern.name].push(patternPath);
			else bindings[pattern.name] = [patternPath];
			else if (namedTypes$1.AssignmentPattern && namedTypes$1.AssignmentPattern.check(pattern)) addPattern(patternPath.get("left"), bindings);
			else if (namedTypes$1.ObjectPattern && namedTypes$1.ObjectPattern.check(pattern)) patternPath.get("properties").each(function(propertyPath) {
				var property$2 = propertyPath.value;
				if (namedTypes$1.Pattern.check(property$2)) addPattern(propertyPath, bindings);
				else if (namedTypes$1.Property.check(property$2) || namedTypes$1.ObjectProperty && namedTypes$1.ObjectProperty.check(property$2)) addPattern(propertyPath.get("value"), bindings);
				else if (namedTypes$1.SpreadProperty && namedTypes$1.SpreadProperty.check(property$2)) addPattern(propertyPath.get("argument"), bindings);
			});
			else if (namedTypes$1.ArrayPattern && namedTypes$1.ArrayPattern.check(pattern)) patternPath.get("elements").each(function(elementPath) {
				var element = elementPath.value;
				if (namedTypes$1.Pattern.check(element)) addPattern(elementPath, bindings);
				else if (namedTypes$1.SpreadElement && namedTypes$1.SpreadElement.check(element)) addPattern(elementPath.get("argument"), bindings);
			});
			else if (namedTypes$1.PropertyPattern && namedTypes$1.PropertyPattern.check(pattern)) addPattern(patternPath.get("pattern"), bindings);
			else if (namedTypes$1.SpreadElementPattern && namedTypes$1.SpreadElementPattern.check(pattern) || namedTypes$1.RestElement && namedTypes$1.RestElement.check(pattern) || namedTypes$1.SpreadPropertyPattern && namedTypes$1.SpreadPropertyPattern.check(pattern)) addPattern(patternPath.get("argument"), bindings);
		}
		function addTypePattern(patternPath, types$9) {
			var pattern = patternPath.value;
			namedTypes$1.Pattern.assert(pattern);
			if (namedTypes$1.Identifier.check(pattern)) if (hasOwn$8.call(types$9, pattern.name)) types$9[pattern.name].push(patternPath);
			else types$9[pattern.name] = [patternPath];
		}
		function addTypeParameter(parameterPath, types$9) {
			var parameter = parameterPath.value;
			FlowOrTSTypeParameterType.assert(parameter);
			if (hasOwn$8.call(types$9, parameter.name)) types$9[parameter.name].push(parameterPath);
			else types$9[parameter.name] = [parameterPath];
		}
		Sp.lookup = function(name) {
			for (var scope$1 = this; scope$1; scope$1 = scope$1.parent) if (scope$1.declares(name)) break;
			return scope$1;
		};
		Sp.lookupType = function(name) {
			for (var scope$1 = this; scope$1; scope$1 = scope$1.parent) if (scope$1.declaresType(name)) break;
			return scope$1;
		};
		Sp.getGlobalScope = function() {
			var scope$1 = this;
			while (!scope$1.isGlobal) scope$1 = scope$1.parent;
			return scope$1;
		};
		return Scope;
	}
	exports.default = scopePlugin$1;
	module.exports = exports["default"];
}));
var require_node_path$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$56 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$41 = (0, tslib_1$56.__importDefault)(require_types$1());
	var path_1$3 = (0, tslib_1$56.__importDefault)(require_path$1());
	var scope_1$1 = (0, tslib_1$56.__importDefault)(require_scope$1());
	function nodePathPlugin$1(fork) {
		var types$8 = fork.use(types_1$41.default);
		var n$6 = types$8.namedTypes;
		var b$5 = types$8.builders;
		var isNumber$3 = types$8.builtInTypes.number;
		var isArray$11 = types$8.builtInTypes.array;
		var Path$2 = fork.use(path_1$3.default);
		var Scope = fork.use(scope_1$1.default);
		var NodePath$2 = function NodePath$3(value, parentPath, name) {
			if (!(this instanceof NodePath$3)) throw new Error("NodePath constructor cannot be invoked without 'new'");
			Path$2.call(this, value, parentPath, name);
		};
		var NPp = NodePath$2.prototype = Object.create(Path$2.prototype, { constructor: {
			value: NodePath$2,
			enumerable: false,
			writable: true,
			configurable: true
		} });
		Object.defineProperties(NPp, {
			node: { get: function() {
				Object.defineProperty(this, "node", {
					configurable: true,
					value: this._computeNode()
				});
				return this.node;
			} },
			parent: { get: function() {
				Object.defineProperty(this, "parent", {
					configurable: true,
					value: this._computeParent()
				});
				return this.parent;
			} },
			scope: { get: function() {
				Object.defineProperty(this, "scope", {
					configurable: true,
					value: this._computeScope()
				});
				return this.scope;
			} }
		});
		NPp.replace = function() {
			delete this.node;
			delete this.parent;
			delete this.scope;
			return Path$2.prototype.replace.apply(this, arguments);
		};
		NPp.prune = function() {
			var remainingNodePath = this.parent;
			this.replace();
			return cleanUpNodesAfterPrune(remainingNodePath);
		};
		NPp._computeNode = function() {
			var value = this.value;
			if (n$6.Node.check(value)) return value;
			var pp = this.parentPath;
			return pp && pp.node || null;
		};
		NPp._computeParent = function() {
			var value = this.value;
			var pp = this.parentPath;
			if (!n$6.Node.check(value)) {
				while (pp && !n$6.Node.check(pp.value)) pp = pp.parentPath;
				if (pp) pp = pp.parentPath;
			}
			while (pp && !n$6.Node.check(pp.value)) pp = pp.parentPath;
			return pp || null;
		};
		NPp._computeScope = function() {
			var value = this.value;
			var pp = this.parentPath;
			var scope$1 = pp && pp.scope;
			if (n$6.Node.check(value) && Scope.isEstablishedBy(value)) scope$1 = new Scope(this, scope$1);
			return scope$1 || null;
		};
		NPp.getValueProperty = function(name) {
			return types$8.getFieldValue(this.value, name);
		};
		NPp.needsParens = function(assumeExpressionContext) {
			var pp = this.parentPath;
			if (!pp) return false;
			var node = this.value;
			if (!n$6.Expression.check(node)) return false;
			if (node.type === "Identifier") return false;
			while (!n$6.Node.check(pp.value)) {
				pp = pp.parentPath;
				if (!pp) return false;
			}
			var parent = pp.value;
			switch (node.type) {
				case "UnaryExpression":
				case "SpreadElement":
				case "SpreadProperty": return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
				case "BinaryExpression":
				case "LogicalExpression": switch (parent.type) {
					case "CallExpression": return this.name === "callee" && parent.callee === node;
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty": return true;
					case "MemberExpression": return this.name === "object" && parent.object === node;
					case "BinaryExpression":
					case "LogicalExpression":
						var n_1 = node;
						var pp_1 = PRECEDENCE$1[parent.operator];
						var np = PRECEDENCE$1[n_1.operator];
						if (pp_1 > np) return true;
						if (pp_1 === np && this.name === "right") {
							if (parent.right !== n_1) throw new Error("Nodes must be equal");
							return true;
						}
					default: return false;
				}
				case "SequenceExpression": switch (parent.type) {
					case "ForStatement": return false;
					case "ExpressionStatement": return this.name !== "expression";
					default: return true;
				}
				case "YieldExpression": switch (parent.type) {
					case "BinaryExpression":
					case "LogicalExpression":
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty":
					case "CallExpression":
					case "MemberExpression":
					case "NewExpression":
					case "ConditionalExpression":
					case "YieldExpression": return true;
					default: return false;
				}
				case "Literal": return parent.type === "MemberExpression" && isNumber$3.check(node.value) && this.name === "object" && parent.object === node;
				case "AssignmentExpression":
				case "ConditionalExpression": switch (parent.type) {
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty":
					case "BinaryExpression":
					case "LogicalExpression": return true;
					case "CallExpression": return this.name === "callee" && parent.callee === node;
					case "ConditionalExpression": return this.name === "test" && parent.test === node;
					case "MemberExpression": return this.name === "object" && parent.object === node;
					default: return false;
				}
				default: if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node) return containsCallExpression$1(node);
			}
			if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
			return false;
		};
		function isBinary$1(node) {
			return n$6.BinaryExpression.check(node) || n$6.LogicalExpression.check(node);
		}
		var PRECEDENCE$1 = {};
		[
			["||"],
			["&&"],
			["|"],
			["^"],
			["&"],
			[
				"==",
				"===",
				"!=",
				"!=="
			],
			[
				"<",
				">",
				"<=",
				">=",
				"in",
				"instanceof"
			],
			[
				">>",
				"<<",
				">>>"
			],
			["+", "-"],
			[
				"*",
				"/",
				"%"
			]
		].forEach(function(tier, i$2) {
			tier.forEach(function(op) {
				PRECEDENCE$1[op] = i$2;
			});
		});
		function containsCallExpression$1(node) {
			if (n$6.CallExpression.check(node)) return true;
			if (isArray$11.check(node)) return node.some(containsCallExpression$1);
			if (n$6.Node.check(node)) return types$8.someField(node, function(_name, child) {
				return containsCallExpression$1(child);
			});
			return false;
		}
		NPp.canBeFirstInStatement = function() {
			var node = this.node;
			return !n$6.FunctionExpression.check(node) && !n$6.ObjectExpression.check(node);
		};
		NPp.firstInStatement = function() {
			return firstInStatement(this);
		};
		function firstInStatement(path) {
			for (var node, parent; path.parent; path = path.parent) {
				node = path.node;
				parent = path.parent.node;
				if (n$6.BlockStatement.check(parent) && path.parent.name === "body" && path.name === 0) {
					if (parent.body[0] !== node) throw new Error("Nodes must be equal");
					return true;
				}
				if (n$6.ExpressionStatement.check(parent) && path.name === "expression") {
					if (parent.expression !== node) throw new Error("Nodes must be equal");
					return true;
				}
				if (n$6.SequenceExpression.check(parent) && path.parent.name === "expressions" && path.name === 0) {
					if (parent.expressions[0] !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.CallExpression.check(parent) && path.name === "callee") {
					if (parent.callee !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.MemberExpression.check(parent) && path.name === "object") {
					if (parent.object !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.ConditionalExpression.check(parent) && path.name === "test") {
					if (parent.test !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (isBinary$1(parent) && path.name === "left") {
					if (parent.left !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.UnaryExpression.check(parent) && !parent.prefix && path.name === "argument") {
					if (parent.argument !== node) throw new Error("Nodes must be equal");
					continue;
				}
				return false;
			}
			return true;
		}
		function cleanUpNodesAfterPrune(remainingNodePath) {
			if (n$6.VariableDeclaration.check(remainingNodePath.node)) {
				var declarations = remainingNodePath.get("declarations").value;
				if (!declarations || declarations.length === 0) return remainingNodePath.prune();
			} else if (n$6.ExpressionStatement.check(remainingNodePath.node)) {
				if (!remainingNodePath.get("expression").value) return remainingNodePath.prune();
			} else if (n$6.IfStatement.check(remainingNodePath.node)) cleanUpIfStatementAfterPrune(remainingNodePath);
			return remainingNodePath;
		}
		function cleanUpIfStatementAfterPrune(ifStatement) {
			var testExpression = ifStatement.get("test").value;
			var alternate = ifStatement.get("alternate").value;
			var consequent = ifStatement.get("consequent").value;
			if (!consequent && !alternate) {
				var testExpressionStatement = b$5.expressionStatement(testExpression);
				ifStatement.replace(testExpressionStatement);
			} else if (!consequent && alternate) {
				var negatedTestExpression = b$5.unaryExpression("!", testExpression, true);
				if (n$6.UnaryExpression.check(testExpression) && testExpression.operator === "!") negatedTestExpression = testExpression.argument;
				ifStatement.get("test").replace(negatedTestExpression);
				ifStatement.get("consequent").replace(alternate);
				ifStatement.get("alternate").replace();
			}
		}
		return NodePath$2;
	}
	exports.default = nodePathPlugin$1;
	module.exports = exports["default"];
}));
var require_path_visitor$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$55 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$40 = (0, tslib_1$55.__importDefault)(require_types$1());
	var node_path_1$3 = (0, tslib_1$55.__importDefault)(require_node_path$1());
	var hasOwn$7 = Object.prototype.hasOwnProperty;
	function pathVisitorPlugin$1(fork) {
		var types$8 = fork.use(types_1$40.default);
		var NodePath$2 = fork.use(node_path_1$3.default);
		var isArray$11 = types$8.builtInTypes.array;
		var isObject$8 = types$8.builtInTypes.object;
		var isFunction$2 = types$8.builtInTypes.function;
		var undefined$1;
		var PathVisitor$2 = function PathVisitor$3() {
			if (!(this instanceof PathVisitor$3)) throw new Error("PathVisitor constructor cannot be invoked without 'new'");
			this._reusableContextStack = [];
			this._methodNameTable = computeMethodNameTable(this);
			this._shouldVisitComments = hasOwn$7.call(this._methodNameTable, "Block") || hasOwn$7.call(this._methodNameTable, "Line");
			this.Context = makeContextConstructor(this);
			this._visiting = false;
			this._changeReported = false;
		};
		function computeMethodNameTable(visitor) {
			var typeNames = Object.create(null);
			for (var methodName in visitor) if (/^visit[A-Z]/.test(methodName)) typeNames[methodName.slice(5)] = true;
			var supertypeTable = types$8.computeSupertypeLookupTable(typeNames);
			var methodNameTable = Object.create(null);
			var typeNameKeys = Object.keys(supertypeTable);
			var typeNameCount = typeNameKeys.length;
			for (var i$2 = 0; i$2 < typeNameCount; ++i$2) {
				var typeName = typeNameKeys[i$2];
				methodName = "visit" + supertypeTable[typeName];
				if (isFunction$2.check(visitor[methodName])) methodNameTable[typeName] = methodName;
			}
			return methodNameTable;
		}
		PathVisitor$2.fromMethodsObject = function fromMethodsObject(methods) {
			if (methods instanceof PathVisitor$2) return methods;
			if (!isObject$8.check(methods)) return new PathVisitor$2();
			var Visitor = function Visitor$1() {
				if (!(this instanceof Visitor$1)) throw new Error("Visitor constructor cannot be invoked without 'new'");
				PathVisitor$2.call(this);
			};
			var Vp = Visitor.prototype = Object.create(PVp);
			Vp.constructor = Visitor;
			extend$1(Vp, methods);
			extend$1(Visitor, PathVisitor$2);
			isFunction$2.assert(Visitor.fromMethodsObject);
			isFunction$2.assert(Visitor.visit);
			return new Visitor();
		};
		function extend$1(target, source) {
			for (var property$2 in source) if (hasOwn$7.call(source, property$2)) target[property$2] = source[property$2];
			return target;
		}
		PathVisitor$2.visit = function visit$6(node, methods) {
			return PathVisitor$2.fromMethodsObject(methods).visit(node);
		};
		var PVp = PathVisitor$2.prototype;
		PVp.visit = function() {
			if (this._visiting) throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
			this._visiting = true;
			this._changeReported = false;
			this._abortRequested = false;
			var argc = arguments.length;
			var args = new Array(argc);
			for (var i$2 = 0; i$2 < argc; ++i$2) args[i$2] = arguments[i$2];
			if (!(args[0] instanceof NodePath$2)) args[0] = new NodePath$2({ root: args[0] }).get("root");
			this.reset.apply(this, args);
			var didNotThrow;
			try {
				var root = this.visitWithoutReset(args[0]);
				didNotThrow = true;
			} finally {
				this._visiting = false;
				if (!didNotThrow && this._abortRequested) return args[0].value;
			}
			return root;
		};
		PVp.AbortRequest = function AbortRequest() {};
		PVp.abort = function() {
			var visitor = this;
			visitor._abortRequested = true;
			var request = new visitor.AbortRequest();
			request.cancel = function() {
				visitor._abortRequested = false;
			};
			throw request;
		};
		PVp.reset = function(_path) {};
		PVp.visitWithoutReset = function(path) {
			if (this instanceof this.Context) return this.visitor.visitWithoutReset(path);
			if (!(path instanceof NodePath$2)) throw new Error("");
			var value = path.value;
			var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
			if (methodName) {
				var context = this.acquireContext(path);
				try {
					return context.invokeVisitorMethod(methodName);
				} finally {
					this.releaseContext(context);
				}
			} else return visitChildren(path, this);
		};
		function visitChildren(path, visitor) {
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(visitor instanceof PathVisitor$2)) throw new Error("");
			var value = path.value;
			if (isArray$11.check(value)) path.each(visitor.visitWithoutReset, visitor);
			else if (!isObject$8.check(value)) {} else {
				var childNames = types$8.getFieldNames(value);
				if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) childNames.push("comments");
				var childCount = childNames.length;
				var childPaths = [];
				for (var i$2 = 0; i$2 < childCount; ++i$2) {
					var childName = childNames[i$2];
					if (!hasOwn$7.call(value, childName)) value[childName] = types$8.getFieldValue(value, childName);
					childPaths.push(path.get(childName));
				}
				for (var i$2 = 0; i$2 < childCount; ++i$2) visitor.visitWithoutReset(childPaths[i$2]);
			}
			return path.value;
		}
		PVp.acquireContext = function(path) {
			if (this._reusableContextStack.length === 0) return new this.Context(path);
			return this._reusableContextStack.pop().reset(path);
		};
		PVp.releaseContext = function(context) {
			if (!(context instanceof this.Context)) throw new Error("");
			this._reusableContextStack.push(context);
			context.currentPath = null;
		};
		PVp.reportChanged = function() {
			this._changeReported = true;
		};
		PVp.wasChangeReported = function() {
			return this._changeReported;
		};
		function makeContextConstructor(visitor) {
			function Context(path) {
				if (!(this instanceof Context)) throw new Error("");
				if (!(this instanceof PathVisitor$2)) throw new Error("");
				if (!(path instanceof NodePath$2)) throw new Error("");
				Object.defineProperty(this, "visitor", {
					value: visitor,
					writable: false,
					enumerable: true,
					configurable: false
				});
				this.currentPath = path;
				this.needToCallTraverse = true;
				Object.seal(this);
			}
			if (!(visitor instanceof PathVisitor$2)) throw new Error("");
			var Cp = Context.prototype = Object.create(visitor);
			Cp.constructor = Context;
			extend$1(Cp, sharedContextProtoMethods);
			return Context;
		}
		var sharedContextProtoMethods = Object.create(null);
		sharedContextProtoMethods.reset = function reset(path) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			this.currentPath = path;
			this.needToCallTraverse = true;
			return this;
		};
		sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			var result = this.visitor[methodName].call(this, this.currentPath);
			if (result === false) this.needToCallTraverse = false;
			else if (result !== undefined$1) {
				this.currentPath = this.currentPath.replace(result)[0];
				if (this.needToCallTraverse) this.traverse(this.currentPath);
			}
			if (this.needToCallTraverse !== false) throw new Error("Must either call this.traverse or return false in " + methodName);
			var path = this.currentPath;
			return path && path.value;
		};
		sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			this.needToCallTraverse = false;
			return visitChildren(path, PathVisitor$2.fromMethodsObject(newVisitor || this.visitor));
		};
		sharedContextProtoMethods.visit = function visit$6(path, newVisitor) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			this.needToCallTraverse = false;
			return PathVisitor$2.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);
		};
		sharedContextProtoMethods.reportChanged = function reportChanged() {
			this.visitor.reportChanged();
		};
		sharedContextProtoMethods.abort = function abort() {
			this.needToCallTraverse = false;
			this.visitor.abort();
		};
		return PathVisitor$2;
	}
	exports.default = pathVisitorPlugin$1;
	module.exports = exports["default"];
}));
var require_equiv$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var types_1$39 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_types$1());
	function default_1$47(fork) {
		var types$8 = fork.use(types_1$39.default);
		var getFieldNames$2 = types$8.getFieldNames;
		var getFieldValue$2 = types$8.getFieldValue;
		var isArray$11 = types$8.builtInTypes.array;
		var isObject$8 = types$8.builtInTypes.object;
		var isDate$4 = types$8.builtInTypes.Date;
		var isRegExp$3 = types$8.builtInTypes.RegExp;
		var hasOwn$12 = Object.prototype.hasOwnProperty;
		function astNodesAreEquivalent$2(a$1, b$5, problemPath) {
			if (isArray$11.check(problemPath)) problemPath.length = 0;
			else problemPath = null;
			return areEquivalent(a$1, b$5, problemPath);
		}
		astNodesAreEquivalent$2.assert = function(a$1, b$5) {
			var problemPath = [];
			if (!astNodesAreEquivalent$2(a$1, b$5, problemPath)) if (problemPath.length === 0) {
				if (a$1 !== b$5) throw new Error("Nodes must be equal");
			} else throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
		};
		function subscriptForProperty(property$2) {
			if (/[_$a-z][_$a-z0-9]*/i.test(property$2)) return "." + property$2;
			return "[" + JSON.stringify(property$2) + "]";
		}
		function areEquivalent(a$1, b$5, problemPath) {
			if (a$1 === b$5) return true;
			if (isArray$11.check(a$1)) return arraysAreEquivalent(a$1, b$5, problemPath);
			if (isObject$8.check(a$1)) return objectsAreEquivalent(a$1, b$5, problemPath);
			if (isDate$4.check(a$1)) return isDate$4.check(b$5) && +a$1 === +b$5;
			if (isRegExp$3.check(a$1)) return isRegExp$3.check(b$5) && a$1.source === b$5.source && a$1.global === b$5.global && a$1.multiline === b$5.multiline && a$1.ignoreCase === b$5.ignoreCase;
			return a$1 == b$5;
		}
		function arraysAreEquivalent(a$1, b$5, problemPath) {
			isArray$11.assert(a$1);
			var aLength = a$1.length;
			if (!isArray$11.check(b$5) || b$5.length !== aLength) {
				if (problemPath) problemPath.push("length");
				return false;
			}
			for (var i$2 = 0; i$2 < aLength; ++i$2) {
				if (problemPath) problemPath.push(i$2);
				if (i$2 in a$1 !== i$2 in b$5) return false;
				if (!areEquivalent(a$1[i$2], b$5[i$2], problemPath)) return false;
				if (problemPath) {
					var problemPathTail = problemPath.pop();
					if (problemPathTail !== i$2) throw new Error("" + problemPathTail);
				}
			}
			return true;
		}
		function objectsAreEquivalent(a$1, b$5, problemPath) {
			isObject$8.assert(a$1);
			if (!isObject$8.check(b$5)) return false;
			if (a$1.type !== b$5.type) {
				if (problemPath) problemPath.push("type");
				return false;
			}
			var aNames = getFieldNames$2(a$1);
			var aNameCount = aNames.length;
			var bNames = getFieldNames$2(b$5);
			var bNameCount = bNames.length;
			if (aNameCount === bNameCount) {
				for (var i$2 = 0; i$2 < aNameCount; ++i$2) {
					var name = aNames[i$2];
					var aChild = getFieldValue$2(a$1, name);
					var bChild = getFieldValue$2(b$5, name);
					if (problemPath) problemPath.push(name);
					if (!areEquivalent(aChild, bChild, problemPath)) return false;
					if (problemPath) {
						var problemPathTail = problemPath.pop();
						if (problemPathTail !== name) throw new Error("" + problemPathTail);
					}
				}
				return true;
			}
			if (!problemPath) return false;
			var seenNames = Object.create(null);
			for (i$2 = 0; i$2 < aNameCount; ++i$2) seenNames[aNames[i$2]] = true;
			for (i$2 = 0; i$2 < bNameCount; ++i$2) {
				name = bNames[i$2];
				if (!hasOwn$12.call(seenNames, name)) {
					problemPath.push(name);
					return false;
				}
				delete seenNames[name];
			}
			for (name in seenNames) {
				problemPath.push(name);
				break;
			}
			return false;
		}
		return astNodesAreEquivalent$2;
	}
	exports.default = default_1$47;
	module.exports = exports["default"];
}));
var require_fork$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$54 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$38 = (0, tslib_1$54.__importDefault)(require_types$1());
	var path_visitor_1$1 = (0, tslib_1$54.__importDefault)(require_path_visitor$1());
	var equiv_1$1 = (0, tslib_1$54.__importDefault)(require_equiv$1());
	var path_1$2 = (0, tslib_1$54.__importDefault)(require_path$1());
	var node_path_1$2 = (0, tslib_1$54.__importDefault)(require_node_path$1());
	function default_1$46(plugins) {
		var fork = createFork$1();
		var types$8 = fork.use(types_1$38.default);
		plugins.forEach(fork.use);
		types$8.finalize();
		var PathVisitor$2 = fork.use(path_visitor_1$1.default);
		return {
			Type: types$8.Type,
			builtInTypes: types$8.builtInTypes,
			namedTypes: types$8.namedTypes,
			builders: types$8.builders,
			defineMethod: types$8.defineMethod,
			getFieldNames: types$8.getFieldNames,
			getFieldValue: types$8.getFieldValue,
			eachField: types$8.eachField,
			someField: types$8.someField,
			getSupertypeNames: types$8.getSupertypeNames,
			getBuilderName: types$8.getBuilderName,
			astNodesAreEquivalent: fork.use(equiv_1$1.default),
			finalize: types$8.finalize,
			Path: fork.use(path_1$2.default),
			NodePath: fork.use(node_path_1$2.default),
			PathVisitor: PathVisitor$2,
			use: fork.use,
			visit: PathVisitor$2.visit
		};
	}
	exports.default = default_1$46;
	function createFork$1() {
		var used = [];
		var usedResult = [];
		function use$2(plugin) {
			var idx = used.indexOf(plugin);
			if (idx === -1) {
				idx = used.length;
				used.push(plugin);
				usedResult[idx] = plugin(fork);
			}
			return usedResult[idx];
		}
		var fork = { use: use$2 };
		return fork;
	}
	module.exports = exports["default"];
}));
var require_shared$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var types_1$37 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_types$1());
	function default_1$45(fork) {
		var types$8 = fork.use(types_1$37.default);
		var Type$2 = types$8.Type;
		var builtin = types$8.builtInTypes;
		var isNumber$3 = builtin.number;
		function geq(than) {
			return Type$2.from(function(value) {
				return isNumber$3.check(value) && value >= than;
			}, isNumber$3 + " >= " + than);
		}
		var defaults$1 = {
			"null": function() {
				return null;
			},
			"emptyArray": function() {
				return [];
			},
			"false": function() {
				return false;
			},
			"true": function() {
				return true;
			},
			"undefined": function() {},
			"use strict": function() {
				return "use strict";
			}
		};
		var naiveIsPrimitive = Type$2.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
		return {
			geq,
			defaults: defaults$1,
			isPrimitive: Type$2.from(function(value) {
				if (value === null) return true;
				var type = typeof value;
				if (type === "object" || type === "function") return false;
				return true;
			}, naiveIsPrimitive.toString())
		};
	}
	exports.default = default_1$45;
	module.exports = exports["default"];
}));
var require_core$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function default_1$44() {
		return {
			BinaryOperators: [
				"==",
				"!=",
				"===",
				"!==",
				"<",
				"<=",
				">",
				">=",
				"<<",
				">>",
				">>>",
				"+",
				"-",
				"*",
				"/",
				"%",
				"&",
				"|",
				"^",
				"in",
				"instanceof"
			],
			AssignmentOperators: [
				"=",
				"+=",
				"-=",
				"*=",
				"/=",
				"%=",
				"<<=",
				">>=",
				">>>=",
				"|=",
				"^=",
				"&="
			],
			LogicalOperators: ["||", "&&"]
		};
	}
	exports.default = default_1$44;
	module.exports = exports["default"];
}));
var require_es2016$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1$5 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_core$3());
	function default_1$43(fork) {
		var result = fork.use(core_1$5.default);
		if (result.BinaryOperators.indexOf("**") < 0) result.BinaryOperators.push("**");
		if (result.AssignmentOperators.indexOf("**=") < 0) result.AssignmentOperators.push("**=");
		return result;
	}
	exports.default = default_1$43;
	module.exports = exports["default"];
}));
var require_es2020$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var es2016_1$5 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_es2016$3());
	function default_1$42(fork) {
		var result = fork.use(es2016_1$5.default);
		if (result.LogicalOperators.indexOf("??") < 0) result.LogicalOperators.push("??");
		return result;
	}
	exports.default = default_1$42;
	module.exports = exports["default"];
}));
var require_es2021$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var es2020_1$5 = (0, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault)(require_es2020$3());
	function default_1$41(fork) {
		var result = fork.use(es2020_1$5.default);
		result.LogicalOperators.forEach(function(op) {
			var assignOp = op + "=";
			if (result.AssignmentOperators.indexOf(assignOp) < 0) result.AssignmentOperators.push(assignOp);
		});
		return result;
	}
	exports.default = default_1$41;
	module.exports = exports["default"];
}));
var require_core$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$53 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var core_1$4 = (0, tslib_1$53.__importDefault)(require_core$3());
	var types_1$36 = (0, tslib_1$53.__importDefault)(require_types$1());
	var shared_1$40 = (0, tslib_1$53.__importDefault)(require_shared$1());
	function default_1$40(fork) {
		var Type$2 = fork.use(types_1$36.default).Type;
		var def = Type$2.def;
		var or = Type$2.or;
		var shared = fork.use(shared_1$40.default);
		var defaults$1 = shared.defaults;
		var geq = shared.geq;
		var _a$2 = fork.use(core_1$4.default), BinaryOperators = _a$2.BinaryOperators, AssignmentOperators = _a$2.AssignmentOperators, LogicalOperators = _a$2.LogicalOperators;
		def("Printable").field("loc", or(def("SourceLocation"), null), defaults$1["null"], true);
		def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults$1["null"], true);
		def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults$1["null"]);
		def("Position").field("line", geq(1)).field("column", geq(0));
		def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults$1["null"]);
		def("Program").bases("Node").build("body").field("body", [def("Statement")]);
		def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults$1["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]);
		def("Statement").bases("Node");
		def("EmptyStatement").bases("Statement").build();
		def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
		def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
		def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults$1["null"]);
		def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
		def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults$1["null"]);
		def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults$1["null"]);
		def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
		def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults$1["false"]);
		def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
		def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
		def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
			return this.handlers && this.handlers[0] || null;
		}).field("handlers", [def("CatchClause")], function() {
			return this.handler ? [this.handler] : [];
		}, true).field("guardedHandlers", [def("CatchClause")], defaults$1.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults$1["null"]);
		def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults$1["null"]).field("body", def("BlockStatement"));
		def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
		def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
		def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
		def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
		def("DebuggerStatement").bases("Statement").build();
		def("Declaration").bases("Statement");
		def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
		def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
		def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
		def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults$1["null"]);
		def("Expression").bases("Node");
		def("ThisExpression").bases("Expression").build();
		def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
		def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
		def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
		def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
		var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
		def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults$1["true"]);
		var BinaryOperator = or.apply(void 0, BinaryOperators);
		def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
		var AssignmentOperator = or.apply(void 0, AssignmentOperators);
		def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
		var UpdateOperator = or("++", "--");
		def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
		var LogicalOperator = or.apply(void 0, LogicalOperators);
		def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
		def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
		def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
		def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
		def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
			var type = this.property.type;
			if (type === "Literal" || type === "MemberExpression" || type === "BinaryExpression") return true;
			return false;
		});
		def("Pattern").bases("Node");
		def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
		def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults$1["false"]);
		def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt));
		def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults$1["true"]).field("trailing", Boolean, defaults$1["false"]);
	}
	exports.default = default_1$40;
	module.exports = exports["default"];
}));
var require_es6$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$52 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var core_1$3 = (0, tslib_1$52.__importDefault)(require_core$2());
	var types_1$35 = (0, tslib_1$52.__importDefault)(require_types$1());
	var shared_1$39 = (0, tslib_1$52.__importDefault)(require_shared$1());
	function default_1$39(fork) {
		fork.use(core_1$3.default);
		var types$8 = fork.use(types_1$35.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$39.default).defaults;
		def("Function").field("generator", Boolean, defaults$1["false"]).field("expression", Boolean, defaults$1["false"]).field("defaults", [or(def("Expression"), null)], defaults$1.emptyArray).field("rest", or(def("Identifier"), null), defaults$1["null"]);
		def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field("typeAnnotation", or(def("TypeAnnotation"), def("TSTypeAnnotation"), null), defaults$1["null"]);
		def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
		def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null));
		def("FunctionExpression").build("id", "params", "body", "generator", "expression");
		def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults$1["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults$1["false"]);
		def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
		def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults$1["false"]);
		def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
		def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
		def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
		def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults$1["false"]).field("shorthand", Boolean, defaults$1["false"]).field("computed", Boolean, defaults$1["false"]);
		def("ObjectProperty").field("shorthand", Boolean, defaults$1["false"]);
		def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults$1["false"]);
		def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
		def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
		def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
		def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
		def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
		def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults$1["false"]).field("static", Boolean, defaults$1["false"]);
		var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
		def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults$1["false"]);
		def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
		def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
		def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults$1["null"]);
		def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults$1["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults$1["null"]);
		def("Super").bases("Expression").build();
		def("Specifier").bases("Node");
		def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults$1["null"]).field("id", or(def("Identifier"), null), defaults$1["null"]).field("name", or(def("Identifier"), null), defaults$1["null"]);
		def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
		def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
		def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
		def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults$1.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
			return "value";
		});
		def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
		def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
		def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal"));
		def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
		def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
		def("TemplateElement").bases("Node").build("value", "tail").field("value", {
			"cooked": String,
			"raw": String
		}).field("tail", Boolean);
		def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
	}
	exports.default = default_1$39;
	module.exports = exports["default"];
}));
var require_es2016$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$51 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2016_1$4 = (0, tslib_1$51.__importDefault)(require_es2016$3());
	var es6_1$1 = (0, tslib_1$51.__importDefault)(require_es6$1());
	function default_1$38(fork) {
		fork.use(es2016_1$4.default);
		fork.use(es6_1$1.default);
	}
	exports.default = default_1$38;
	module.exports = exports["default"];
}));
var require_es2017$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$50 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2016_1$3 = (0, tslib_1$50.__importDefault)(require_es2016$2());
	var types_1$34 = (0, tslib_1$50.__importDefault)(require_types$1());
	var shared_1$38 = (0, tslib_1$50.__importDefault)(require_shared$1());
	function default_1$37(fork) {
		fork.use(es2016_1$3.default);
		var def = fork.use(types_1$34.default).Type.def;
		var defaults$1 = fork.use(shared_1$38.default).defaults;
		def("Function").field("async", Boolean, defaults$1["false"]);
		def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
	}
	exports.default = default_1$37;
	module.exports = exports["default"];
}));
var require_es2018$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$49 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2017_1$1 = (0, tslib_1$49.__importDefault)(require_es2017$1());
	var types_1$33 = (0, tslib_1$49.__importDefault)(require_types$1());
	var shared_1$37 = (0, tslib_1$49.__importDefault)(require_shared$1());
	function default_1$36(fork) {
		fork.use(es2017_1$1.default);
		var types$8 = fork.use(types_1$33.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$37.default).defaults;
		def("ForOfStatement").field("await", Boolean, defaults$1["false"]);
		def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
		def("TemplateElement").field("value", {
			"cooked": or(String, null),
			"raw": String
		});
		def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
		def("ObjectPattern").field("properties", [or(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
	}
	exports.default = default_1$36;
	module.exports = exports["default"];
}));
var require_es2019$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$48 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2018_1$1 = (0, tslib_1$48.__importDefault)(require_es2018$1());
	var types_1$32 = (0, tslib_1$48.__importDefault)(require_types$1());
	var shared_1$36 = (0, tslib_1$48.__importDefault)(require_shared$1());
	function default_1$35(fork) {
		fork.use(es2018_1$1.default);
		var types$8 = fork.use(types_1$32.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$36.default).defaults;
		def("CatchClause").field("param", or(def("Pattern"), null), defaults$1["null"]);
	}
	exports.default = default_1$35;
	module.exports = exports["default"];
}));
var require_es2020$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$47 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2020_1$4 = (0, tslib_1$47.__importDefault)(require_es2020$3());
	var es2019_1$1 = (0, tslib_1$47.__importDefault)(require_es2019$1());
	var types_1$31 = (0, tslib_1$47.__importDefault)(require_types$1());
	var shared_1$35 = (0, tslib_1$47.__importDefault)(require_shared$1());
	function default_1$34(fork) {
		fork.use(es2020_1$4.default);
		fork.use(es2019_1$1.default);
		var types$8 = fork.use(types_1$31.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$35.default).defaults;
		def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
		def("ExportAllDeclaration").build("source", "exported").field("source", def("Literal")).field("exported", or(def("Identifier"), null));
		def("ChainElement").bases("Node").field("optional", Boolean, defaults$1["false"]);
		def("CallExpression").bases("Expression", "ChainElement");
		def("MemberExpression").bases("Expression", "ChainElement");
		def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement"));
		def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults$1["true"]);
		def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults$1["true"]);
	}
	exports.default = default_1$34;
	module.exports = exports["default"];
}));
var require_es2021$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$46 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2021_1$3 = (0, tslib_1$46.__importDefault)(require_es2021$3());
	var es2020_1$3 = (0, tslib_1$46.__importDefault)(require_es2020$2());
	function default_1$33(fork) {
		fork.use(es2021_1$3.default);
		fork.use(es2020_1$3.default);
	}
	exports.default = default_1$33;
	module.exports = exports["default"];
}));
var require_es2022$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$45 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es2021_1$2 = (0, tslib_1$45.__importDefault)(require_es2021$2());
	var types_1$30 = (0, tslib_1$45.__importDefault)(require_types$1());
	function default_1$32(fork) {
		fork.use(es2021_1$2.default);
		var def = fork.use(types_1$30.default).Type.def;
		def("StaticBlock").bases("Declaration").build("body").field("body", [def("Statement")]);
	}
	exports.default = default_1$32;
	module.exports = exports["default"];
}));
var require_es_proposals$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$44 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$29 = (0, tslib_1$44.__importDefault)(require_types$1());
	var shared_1$34 = (0, tslib_1$44.__importDefault)(require_shared$1());
	var es2022_1$1 = (0, tslib_1$44.__importDefault)(require_es2022$1());
	function default_1$31(fork) {
		fork.use(es2022_1$1.default);
		var types$8 = fork.use(types_1$29.default);
		var Type$2 = types$8.Type;
		var def = types$8.Type.def;
		var or = Type$2.or;
		var defaults$1 = fork.use(shared_1$34.default).defaults;
		def("AwaitExpression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults$1["false"]);
		def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
		def("Property").field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
		def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults$1["null"]);
		def("ImportAttribute").bases("Node").build("key", "value").field("key", or(def("Identifier"), def("Literal"))).field("value", def("Expression"));
		[
			"ImportDeclaration",
			"ExportAllDeclaration",
			"ExportNamedDeclaration"
		].forEach(function(decl) {
			def(decl).field("assertions", [def("ImportAttribute")], defaults$1.emptyArray);
		});
		def("RecordExpression").bases("Expression").build("properties").field("properties", [or(def("ObjectProperty"), def("ObjectMethod"), def("SpreadElement"))]);
		def("TupleExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), def("SpreadElement"), null)]);
		def("ModuleExpression").bases("Node").build("body").field("body", def("Program"));
	}
	exports.default = default_1$31;
	module.exports = exports["default"];
}));
var require_jsx$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$43 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es_proposals_1$9 = (0, tslib_1$43.__importDefault)(require_es_proposals$1());
	var types_1$28 = (0, tslib_1$43.__importDefault)(require_types$1());
	var shared_1$33 = (0, tslib_1$43.__importDefault)(require_shared$1());
	function default_1$30(fork) {
		fork.use(es_proposals_1$9.default);
		var types$8 = fork.use(types_1$28.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$33.default).defaults;
		def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(def("Literal"), def("JSXExpressionContainer"), def("JSXElement"), def("JSXFragment"), null), defaults$1["null"]);
		def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
		def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
		def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults$1.false);
		var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
		def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
		var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
		def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def("Expression"), def("JSXEmptyExpression")));
		var JSXChildren = [or(def("JSXText"), def("JSXExpressionContainer"), def("JSXSpreadChild"), def("JSXElement"), def("JSXFragment"), def("Literal"))];
		def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults$1["null"]).field("children", JSXChildren, defaults$1.emptyArray).field("name", JSXElementName, function() {
			return this.openingElement.name;
		}, true).field("selfClosing", Boolean, function() {
			return this.openingElement.selfClosing;
		}, true).field("attributes", JSXAttributes, function() {
			return this.openingElement.attributes;
		}, true);
		def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults$1.emptyArray).field("selfClosing", Boolean, defaults$1["false"]);
		def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
		def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults$1.emptyArray);
		def("JSXOpeningFragment").bases("Node").build();
		def("JSXClosingFragment").bases("Node").build();
		def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
			return this.value;
		});
		def("JSXEmptyExpression").bases("Node").build();
		def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
	}
	exports.default = default_1$30;
	module.exports = exports["default"];
}));
var require_type_annotations$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$42 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$27 = (0, tslib_1$42.__importDefault)(require_types$1());
	var shared_1$32 = (0, tslib_1$42.__importDefault)(require_shared$1());
	function default_1$29(fork) {
		var types$8 = fork.use(types_1$27.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$32.default).defaults;
		var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
		var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
		def("Identifier").field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		def("Function").field("returnType", TypeAnnotation, defaults$1["null"]).field("typeParameters", TypeParamDecl, defaults$1["null"]);
		def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults$1["false"]).field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		["ClassDeclaration", "ClassExpression"].forEach(function(typeName) {
			def(typeName).field("typeParameters", TypeParamDecl, defaults$1["null"]).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults$1["null"]).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults$1.emptyArray);
		});
	}
	exports.default = default_1$29;
	module.exports = exports["default"];
}));
var require_flow$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$41 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es_proposals_1$8 = (0, tslib_1$41.__importDefault)(require_es_proposals$1());
	var type_annotations_1$3 = (0, tslib_1$41.__importDefault)(require_type_annotations$1());
	var types_1$26 = (0, tslib_1$41.__importDefault)(require_types$1());
	var shared_1$31 = (0, tslib_1$41.__importDefault)(require_shared$1());
	function default_1$28(fork) {
		fork.use(es_proposals_1$8.default);
		fork.use(type_annotations_1$3.default);
		var types$8 = fork.use(types_1$26.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$31.default).defaults;
		def("Flow").bases("Node");
		def("FlowType").bases("Flow");
		def("AnyTypeAnnotation").bases("FlowType").build();
		def("EmptyTypeAnnotation").bases("FlowType").build();
		def("MixedTypeAnnotation").bases("FlowType").build();
		def("VoidTypeAnnotation").bases("FlowType").build();
		def("SymbolTypeAnnotation").bases("FlowType").build();
		def("NumberTypeAnnotation").bases("FlowType").build();
		def("BigIntTypeAnnotation").bases("FlowType").build();
		def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
		def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
		def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
		def("StringTypeAnnotation").bases("FlowType").build();
		def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
		def("BooleanTypeAnnotation").bases("FlowType").build();
		def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
		def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
		def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
		def("NullLiteralTypeAnnotation").bases("FlowType").build();
		def("NullTypeAnnotation").bases("FlowType").build();
		def("ThisTypeAnnotation").bases("FlowType").build();
		def("ExistsTypeAnnotation").bases("FlowType").build();
		def("ExistentialTypeParam").bases("FlowType").build();
		def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
		def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
		def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
		def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))]).field("indexers", [def("ObjectTypeIndexer")], defaults$1.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults$1.emptyArray).field("inexact", or(Boolean, void 0), defaults$1["undefined"]).field("exact", Boolean, defaults$1["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults$1.emptyArray);
		def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
		var LegacyVariance = or(def("Variance"), "plus", "minus", null);
		def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults$1["null"]);
		def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults$1["null"]).field("static", Boolean, defaults$1["false"]);
		def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults$1["false"]);
		def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
		def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
		def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
		def("IndexedAccessType").bases("FlowType").build("objectType", "indexType").field("objectType", def("FlowType")).field("indexType", def("FlowType"));
		def("OptionalIndexedAccessType").bases("FlowType").build("objectType", "indexType", "optional").field("objectType", def("FlowType")).field("indexType", def("FlowType")).field("optional", Boolean);
		def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
		def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
		def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
		def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
		def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
		def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults$1["null"]).field("bound", or(def("TypeAnnotation"), null), defaults$1["null"]).field("default", or(def("FlowType"), null), defaults$1["null"]);
		def("ClassProperty").field("variance", LegacyVariance, defaults$1["null"]);
		def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults$1["null"]).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults$1["null"]);
		def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults$1["null"]);
		def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults$1["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
		def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
		def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults$1["null"]);
		def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
		def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
		def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or(def("FlowType"), null));
		def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def("FlowType"), null));
		def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
		def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
		def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or(def("FlowPredicate"), null), defaults$1["null"]);
		def("DeclareClass").bases("InterfaceDeclaration").build("id");
		def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
		def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
		def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("FlowType"), def("TypeAlias"), def("DeclareOpaqueType"), def("InterfaceDeclaration"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults$1["null"]);
		def("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
			return "value";
		});
		def("FlowPredicate").bases("Flow");
		def("InferredPredicate").bases("FlowPredicate").build();
		def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
		def("Function").field("predicate", or(def("FlowPredicate"), null), defaults$1["null"]);
		def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults$1["null"]);
		def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults$1["null"]);
		def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody")));
		def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean);
		def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean);
		def("EnumStringBody").build("members", "explicitType").field("members", or([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean);
		def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]);
		def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or(def("Literal"), Boolean));
		def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
		def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
		def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
	}
	exports.default = default_1$28;
	module.exports = exports["default"];
}));
var require_esprima$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$40 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es_proposals_1$7 = (0, tslib_1$40.__importDefault)(require_es_proposals$1());
	var types_1$25 = (0, tslib_1$40.__importDefault)(require_types$1());
	var shared_1$30 = (0, tslib_1$40.__importDefault)(require_shared$1());
	function default_1$27(fork) {
		fork.use(es_proposals_1$7.default);
		var types$8 = fork.use(types_1$25.default);
		var defaults$1 = fork.use(shared_1$30.default).defaults;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		def("VariableDeclaration").field("declarations", [or(def("VariableDeclarator"), def("Identifier"))]);
		def("Property").field("value", or(def("Expression"), def("Pattern")));
		def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
		def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
		def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
		def("ExportBatchSpecifier").bases("Specifier").build();
		def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("Declaration"), def("Expression"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("Block").bases("Comment").build("value", "leading", "trailing");
		def("Line").bases("Comment").build("value", "leading", "trailing");
	}
	exports.default = default_1$27;
	module.exports = exports["default"];
}));
var require_babel_core$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$39 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var es_proposals_1$6 = (0, tslib_1$39.__importDefault)(require_es_proposals$1());
	var types_1$24 = (0, tslib_1$39.__importDefault)(require_types$1());
	var shared_1$29 = (0, tslib_1$39.__importDefault)(require_shared$1());
	function default_1$26(fork) {
		var _a$2, _b, _c, _d, _e;
		fork.use(es_proposals_1$6.default);
		var types$8 = fork.use(types_1$24.default);
		var defaults$1 = fork.use(shared_1$29.default).defaults;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var isUndefined$2 = types$8.builtInTypes.undefined;
		def("Noop").bases("Statement").build();
		def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
		def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
		def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
		def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
		def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
		def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
		def("CommentLine").bases("Comment").build("value", "leading", "trailing");
		def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
		def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults$1["use strict"]);
		def("InterpreterDirective").bases("Node").build("value").field("value", String);
		def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults$1.emptyArray);
		def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults$1.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults$1["null"]);
		function makeLiteralExtra(rawValueType, toRaw) {
			if (rawValueType === void 0) rawValueType = String;
			return [
				"extra",
				{
					rawValue: rawValueType,
					raw: String
				},
				function getDefault() {
					var value = types$8.getFieldValue(this, "value");
					return {
						rawValue: value,
						raw: toRaw ? toRaw(value) : String(value)
					};
				}
			];
		}
		(_a$2 = def("StringLiteral").bases("Literal").build("value").field("value", String)).field.apply(_a$2, makeLiteralExtra(String, function(val) {
			return JSON.stringify(val);
		}));
		(_b = def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults$1["null"])).field.apply(_b, makeLiteralExtra(Number));
		(_c = def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number))).field.apply(_c, makeLiteralExtra(String, function(val) {
			return val + "n";
		}));
		(_d = def("DecimalLiteral").bases("Literal").build("value").field("value", String)).field.apply(_d, makeLiteralExtra(String, function(val) {
			return val + "m";
		}));
		def("NullLiteral").bases("Literal").build().field("value", null, defaults$1["null"]);
		def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
		(_e = def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
			return new RegExp(this.pattern, this.flags);
		})).field.apply(_e, makeLiteralExtra(or(RegExp, isUndefined$2), function(exp) {
			return "/".concat(exp.pattern, "/").concat(exp.flags || "");
		})).field("regex", {
			pattern: String,
			flags: String
		}, function() {
			return {
				pattern: this.pattern,
				flags: this.flags
			};
		});
		var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
		def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
		def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]).field("accessibility", or(def("Literal"), null), defaults$1["null"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("accessibility", or(def("Literal"), null), defaults$1["null"]).field("computed", Boolean, defaults$1["false"]);
		var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
		def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
		def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression")));
		def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
		["ClassMethod", "ClassPrivateMethod"].forEach(function(typeName) {
			def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
				return "method";
			}).field("body", def("BlockStatement")).field("computed", Boolean, defaults$1["false"]).field("static", or(Boolean, null), defaults$1["null"]).field("abstract", or(Boolean, null), defaults$1["null"]).field("access", or("public", "private", "protected", null), defaults$1["null"]).field("accessibility", or("public", "private", "protected", null), defaults$1["null"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]).field("optional", or(Boolean, null), defaults$1["null"]);
		});
		var ObjectPatternProperty = or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"), def("ObjectProperty"), def("RestProperty"));
		def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
		def("Import").bases("Expression").build();
	}
	exports.default = default_1$26;
	module.exports = exports["default"];
}));
var require_babel$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$38 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var types_1$23 = (0, tslib_1$38.__importDefault)(require_types$1());
	var babel_core_1$3 = (0, tslib_1$38.__importDefault)(require_babel_core$1());
	var flow_1$3 = (0, tslib_1$38.__importDefault)(require_flow$1());
	function default_1$25(fork) {
		var def = fork.use(types_1$23.default).Type.def;
		fork.use(babel_core_1$3.default);
		fork.use(flow_1$3.default);
		def("V8IntrinsicIdentifier").bases("Expression").build("name").field("name", String);
		def("TopicReference").bases("Expression").build();
	}
	exports.default = default_1$25;
	module.exports = exports["default"];
}));
var require_typescript$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$37 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var babel_core_1$2 = (0, tslib_1$37.__importDefault)(require_babel_core$1());
	var type_annotations_1$2 = (0, tslib_1$37.__importDefault)(require_type_annotations$1());
	var types_1$22 = (0, tslib_1$37.__importDefault)(require_types$1());
	var shared_1$28 = (0, tslib_1$37.__importDefault)(require_shared$1());
	function default_1$24(fork) {
		fork.use(babel_core_1$2.default);
		fork.use(type_annotations_1$2.default);
		var types$8 = fork.use(types_1$22.default);
		var n$6 = types$8.namedTypes;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$28.default).defaults;
		var StringLiteral = types$8.Type.from(function(value, deep) {
			if (n$6.StringLiteral && n$6.StringLiteral.check(value, deep)) return true;
			if (n$6.Literal && n$6.Literal.check(value, deep) && typeof value.value === "string") return true;
			return false;
		}, "StringLiteral");
		def("TSType").bases("Node");
		var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
		def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
		def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults$1["null"]);
		def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults$1["null"]);
		def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults$1["null"]);
		def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
		def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults$1["null"]);
		def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
		[
			"TSAnyKeyword",
			"TSBigIntKeyword",
			"TSBooleanKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSIntrinsicKeyword",
			"TSThisType"
		].forEach(function(keywordType) {
			def(keywordType).bases("TSType").build();
		});
		def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
		def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
		def("TemplateLiteral").field("expressions", or([def("Expression")], [def("TSType")]));
		["TSUnionType", "TSIntersectionType"].forEach(function(typeName) {
			def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
		});
		def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
		def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
		def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
		["TSFunctionType", "TSConstructorType"].forEach(function(typeName) {
			def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
		});
		def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("id", or(def("Identifier"), null), defaults$1["null"]).field("params", [def("Pattern")]).field("returnType", or(def("TSTypeAnnotation"), def("Noop"), null), defaults$1["null"]);
		def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults$1["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("static", Boolean, defaults$1["false"]).field("computed", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("key", or(def("Identifier"), def("StringLiteral"), def("NumericLiteral"), def("Expression"))).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
			return "method";
		}).field("access", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]).field("returnType", or(def("TSTypeAnnotation"), def("Noop"), null), defaults$1["null"]);
		def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults$1["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults$1["false"]).field("typeAnnotation", or(def("TSType"), null), defaults$1["null"]);
		def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
		def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults$1["false"]).field("elementType", def("TSType"));
		def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
		def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
		def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
		def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults$1["false"]);
		def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults$1["false"]).field("readonly", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("parameters", ParametersType);
		def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults$1["null"]).field("asserts", Boolean, defaults$1["false"]);
		["TSCallSignatureDeclaration", "TSConstructSignatureDeclaration"].forEach(function(typeName) {
			def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
		});
		def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
		var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
		def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
		def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or(def("TSType"), void 0), defaults$1["undefined"]).field("default", or(def("TSType"), void 0), defaults$1["undefined"]);
		def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults$1["null"]);
		def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
		def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
		def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults$1["false"]).field("declare", Boolean, defaults$1["false"]).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults$1["false"]).field("typeAnnotation", def("TSType"));
		def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
		def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults$1["false"]).field("global", Boolean, defaults$1["false"]).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults$1["null"]);
		def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults$1["undefined"]);
		def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults$1["false"]).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
		def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
		def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
		def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
		def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
		def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
		def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults$1["false"]).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults$1["null"]).field("body", def("TSInterfaceBody"));
		def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("readonly", Boolean, defaults$1["false"]).field("parameter", or(def("Identifier"), def("AssignmentPattern")));
		def("ClassProperty").field("access", or("public", "private", "protected", void 0), defaults$1["undefined"]);
		def("ClassBody").field("body", [or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("TSDeclareMethod"), TSTypeMember)]);
	}
	exports.default = default_1$24;
	module.exports = exports["default"];
}));
var require_namedTypes$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.namedTypes = void 0;
	(function(namedTypes$1) {})(exports.namedTypes || (exports.namedTypes = {}));
}));
var require_main$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.visit = exports.use = exports.Type = exports.someField = exports.PathVisitor = exports.Path = exports.NodePath = exports.namedTypes = exports.getSupertypeNames = exports.getFieldValue = exports.getFieldNames = exports.getBuilderName = exports.finalize = exports.eachField = exports.defineMethod = exports.builtInTypes = exports.builders = exports.astNodesAreEquivalent = void 0;
	var tslib_1$36 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var fork_1$1 = (0, tslib_1$36.__importDefault)(require_fork$1());
	var es_proposals_1$5 = (0, tslib_1$36.__importDefault)(require_es_proposals$1());
	var jsx_1$1 = (0, tslib_1$36.__importDefault)(require_jsx$1());
	var flow_1$2 = (0, tslib_1$36.__importDefault)(require_flow$1());
	var esprima_1$1 = (0, tslib_1$36.__importDefault)(require_esprima$3());
	var babel_1$1 = (0, tslib_1$36.__importDefault)(require_babel$1());
	var typescript_1$1 = (0, tslib_1$36.__importDefault)(require_typescript$1());
	var namedTypes_1$1 = require_namedTypes$1();
	Object.defineProperty(exports, "namedTypes", {
		enumerable: true,
		get: function() {
			return namedTypes_1$1.namedTypes;
		}
	});
	var _a$1 = (0, fork_1$1.default)([
		es_proposals_1$5.default,
		jsx_1$1.default,
		flow_1$2.default,
		esprima_1$1.default,
		babel_1$1.default,
		typescript_1$1.default
	]), astNodesAreEquivalent$1 = _a$1.astNodesAreEquivalent, builders$1 = _a$1.builders, builtInTypes$1 = _a$1.builtInTypes, defineMethod$1 = _a$1.defineMethod, eachField$1 = _a$1.eachField, finalize$1 = _a$1.finalize, getBuilderName$1 = _a$1.getBuilderName, getFieldNames$1 = _a$1.getFieldNames, getFieldValue$1 = _a$1.getFieldValue, getSupertypeNames$1 = _a$1.getSupertypeNames, n$4 = _a$1.namedTypes, NodePath$1 = _a$1.NodePath, Path$1 = _a$1.Path, PathVisitor$1 = _a$1.PathVisitor, someField$1 = _a$1.someField, Type$1 = _a$1.Type, use$1 = _a$1.use, visit$5 = _a$1.visit;
	exports.astNodesAreEquivalent = astNodesAreEquivalent$1;
	exports.builders = builders$1;
	exports.builtInTypes = builtInTypes$1;
	exports.defineMethod = defineMethod$1;
	exports.eachField = eachField$1;
	exports.finalize = finalize$1;
	exports.getBuilderName = getBuilderName$1;
	exports.getFieldNames = getFieldNames$1;
	exports.getFieldValue = getFieldValue$1;
	exports.getSupertypeNames = getSupertypeNames$1;
	exports.NodePath = NodePath$1;
	exports.Path = Path$1;
	exports.PathVisitor = PathVisitor$1;
	exports.someField = someField$1;
	exports.Type = Type$1;
	exports.use = use$1;
	exports.visit = visit$5;
	Object.assign(namedTypes_1$1.namedTypes, n$4);
}));
var require_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _typeof$3(o$1) {
		"@babel/helpers - typeof";
		return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
			return typeof o$2;
		} : function(o$2) {
			return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
		}, _typeof$3(o$1);
	}
	function _defineProperties$2(target, props) {
		for (var i$2 = 0; i$2 < props.length; i$2++) {
			var descriptor = props[i$2];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
		}
	}
	function _createClass$2(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties$2(Constructor, staticProps);
		Object.defineProperty(Constructor, "prototype", { writable: false });
		return Constructor;
	}
	function _toPropertyKey$2(arg) {
		var key = _toPrimitive$2(arg, "string");
		return _typeof$3(key) === "symbol" ? key : String(key);
	}
	function _toPrimitive$2(input, hint) {
		if (_typeof$3(input) !== "object" || input === null) return input;
		var prim = input[Symbol.toPrimitive];
		if (prim !== void 0) {
			var res = prim.call(input, hint || "default");
			if (_typeof$3(res) !== "object") return res;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return (hint === "string" ? String : Number)(input);
	}
	function _classCallCheck$2(instance, Constructor) {
		if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	}
	function _inherits$1(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
		subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
			value: subClass,
			writable: true,
			configurable: true
		} });
		Object.defineProperty(subClass, "prototype", { writable: false });
		if (superClass) _setPrototypeOf$1(subClass, superClass);
	}
	function _setPrototypeOf$1(o$1, p$1) {
		_setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$2(o$2, p$2) {
			o$2.__proto__ = p$2;
			return o$2;
		};
		return _setPrototypeOf$1(o$1, p$1);
	}
	function _createSuper$1(Derived) {
		var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
		return function _createSuperInternal() {
			var Super$1 = _getPrototypeOf$1(Derived), result;
			if (hasNativeReflectConstruct) {
				var NewTarget = _getPrototypeOf$1(this).constructor;
				result = Reflect.construct(Super$1, arguments, NewTarget);
			} else result = Super$1.apply(this, arguments);
			return _possibleConstructorReturn$1(this, result);
		};
	}
	function _possibleConstructorReturn$1(self$1, call$1) {
		if (call$1 && (_typeof$3(call$1) === "object" || typeof call$1 === "function")) return call$1;
		else if (call$1 !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
		return _assertThisInitialized$1(self$1);
	}
	function _assertThisInitialized$1(self$1) {
		if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return self$1;
	}
	function _isNativeReflectConstruct$1() {
		if (typeof Reflect === "undefined" || !Reflect.construct) return false;
		if (Reflect.construct.sham) return false;
		if (typeof Proxy === "function") return true;
		try {
			Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
			return true;
		} catch (e$1) {
			return false;
		}
	}
	function _getPrototypeOf$1(o$1) {
		_getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$2(o$2) {
			return o$2.__proto__ || Object.getPrototypeOf(o$2);
		};
		return _getPrototypeOf$1(o$1);
	}
	var codes = {};
	var assert$2;
	var util$9;
	function createErrorType(code$1, message, Base) {
		if (!Base) Base = Error;
		function getMessage(arg1, arg2, arg3) {
			if (typeof message === "string") return message;
			else return message(arg1, arg2, arg3);
		}
		codes[code$1] = /* @__PURE__ */ function(_Base) {
			_inherits$1(NodeError, _Base);
			var _super = _createSuper$1(NodeError);
			function NodeError(arg1, arg2, arg3) {
				var _this;
				_classCallCheck$2(this, NodeError);
				_this = _super.call(this, getMessage(arg1, arg2, arg3));
				_this.code = code$1;
				return _this;
			}
			return _createClass$2(NodeError);
		}(Base);
	}
	function oneOf(expected, thing) {
		if (Array.isArray(expected)) {
			var len$1 = expected.length;
			expected = expected.map(function(i$2) {
				return String(i$2);
			});
			if (len$1 > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len$1 - 1).join(", "), ", or ") + expected[len$1 - 1];
			else if (len$1 === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
			else return "of ".concat(thing, " ").concat(expected[0]);
		} else return "of ".concat(thing, " ").concat(String(expected));
	}
	function startsWith(str, search, pos) {
		return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	}
	function endsWith$1(str, search, this_len) {
		if (this_len === void 0 || this_len > str.length) this_len = str.length;
		return str.substring(this_len - search.length, this_len) === search;
	}
	function includes(str, search, start) {
		if (typeof start !== "number") start = 0;
		if (start + search.length > str.length) return false;
		else return str.indexOf(search, start) !== -1;
	}
	createErrorType("ERR_AMBIGUOUS_ARGUMENT", "The \"%s\" argument is ambiguous. %s", TypeError);
	createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
		if (assert$2 === void 0) assert$2 = require_assert();
		assert$2(typeof name === "string", "'name' must be a string");
		var determiner;
		if (typeof expected === "string" && startsWith(expected, "not ")) {
			determiner = "must not be";
			expected = expected.replace(/^not /, "");
		} else determiner = "must be";
		var msg;
		if (endsWith$1(name, " argument")) msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
		else {
			var type = includes(name, ".") ? "property" : "argument";
			msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
		}
		msg += ". Received type ".concat(_typeof$3(actual));
		return msg;
	}, TypeError);
	createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
		var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
		if (util$9 === void 0) util$9 = require_util$2();
		var inspected = util$9.inspect(value);
		if (inspected.length > 128) inspected = "".concat(inspected.slice(0, 128), "...");
		return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
	}, TypeError, RangeError);
	createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
		var type;
		if (value && value.constructor && value.constructor.name) type = "instance of ".concat(value.constructor.name);
		else type = "type ".concat(_typeof$3(value));
		return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
	}, TypeError);
	createErrorType("ERR_MISSING_ARGS", function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		if (assert$2 === void 0) assert$2 = require_assert();
		assert$2(args.length > 0, "At least one arg needs to be specified");
		var msg = "The ";
		var len$1 = args.length;
		args = args.map(function(a$1) {
			return "\"".concat(a$1, "\"");
		});
		switch (len$1) {
			case 1:
				msg += "".concat(args[0], " argument");
				break;
			case 2:
				msg += "".concat(args[0], " and ").concat(args[1], " arguments");
				break;
			default:
				msg += args.slice(0, len$1 - 1).join(", ");
				msg += ", and ".concat(args[len$1 - 1], " arguments");
				break;
		}
		return "".concat(msg, " must be specified");
	}, TypeError);
	module.exports.codes = codes;
}));
var require_assertion_error = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist$1();
	function ownKeys(e$1, r$1) {
		var t$1 = Object.keys(e$1);
		if (Object.getOwnPropertySymbols) {
			var o$1 = Object.getOwnPropertySymbols(e$1);
			r$1 && (o$1 = o$1.filter(function(r$2) {
				return Object.getOwnPropertyDescriptor(e$1, r$2).enumerable;
			})), t$1.push.apply(t$1, o$1);
		}
		return t$1;
	}
	function _objectSpread(e$1) {
		for (var r$1 = 1; r$1 < arguments.length; r$1++) {
			var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
			r$1 % 2 ? ownKeys(Object(t$1), !0).forEach(function(r$2) {
				_defineProperty(e$1, r$2, t$1[r$2]);
			}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$1, Object.getOwnPropertyDescriptors(t$1)) : ownKeys(Object(t$1)).forEach(function(r$2) {
				Object.defineProperty(e$1, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
			});
		}
		return e$1;
	}
	function _defineProperty(obj, key, value) {
		key = _toPropertyKey$1(key);
		if (key in obj) Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
		else obj[key] = value;
		return obj;
	}
	function _classCallCheck$1(instance, Constructor) {
		if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	}
	function _defineProperties$1(target, props) {
		for (var i$2 = 0; i$2 < props.length; i$2++) {
			var descriptor = props[i$2];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
		}
	}
	function _createClass$1(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties$1(Constructor, staticProps);
		Object.defineProperty(Constructor, "prototype", { writable: false });
		return Constructor;
	}
	function _toPropertyKey$1(arg) {
		var key = _toPrimitive$1(arg, "string");
		return _typeof$2(key) === "symbol" ? key : String(key);
	}
	function _toPrimitive$1(input, hint) {
		if (_typeof$2(input) !== "object" || input === null) return input;
		var prim = input[Symbol.toPrimitive];
		if (prim !== void 0) {
			var res = prim.call(input, hint || "default");
			if (_typeof$2(res) !== "object") return res;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return (hint === "string" ? String : Number)(input);
	}
	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
		subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
			value: subClass,
			writable: true,
			configurable: true
		} });
		Object.defineProperty(subClass, "prototype", { writable: false });
		if (superClass) _setPrototypeOf(subClass, superClass);
	}
	function _createSuper(Derived) {
		var hasNativeReflectConstruct = _isNativeReflectConstruct();
		return function _createSuperInternal() {
			var Super$1 = _getPrototypeOf(Derived), result;
			if (hasNativeReflectConstruct) {
				var NewTarget = _getPrototypeOf(this).constructor;
				result = Reflect.construct(Super$1, arguments, NewTarget);
			} else result = Super$1.apply(this, arguments);
			return _possibleConstructorReturn(this, result);
		};
	}
	function _possibleConstructorReturn(self$1, call$1) {
		if (call$1 && (_typeof$2(call$1) === "object" || typeof call$1 === "function")) return call$1;
		else if (call$1 !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
		return _assertThisInitialized(self$1);
	}
	function _assertThisInitialized(self$1) {
		if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return self$1;
	}
	function _wrapNativeSuper(Class) {
		var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
		_wrapNativeSuper = function _wrapNativeSuper$1(Class$1) {
			if (Class$1 === null || !_isNativeFunction(Class$1)) return Class$1;
			if (typeof Class$1 !== "function") throw new TypeError("Super expression must either be null or a function");
			if (typeof _cache !== "undefined") {
				if (_cache.has(Class$1)) return _cache.get(Class$1);
				_cache.set(Class$1, Wrapper);
			}
			function Wrapper() {
				return _construct(Class$1, arguments, _getPrototypeOf(this).constructor);
			}
			Wrapper.prototype = Object.create(Class$1.prototype, { constructor: {
				value: Wrapper,
				enumerable: false,
				writable: true,
				configurable: true
			} });
			return _setPrototypeOf(Wrapper, Class$1);
		};
		return _wrapNativeSuper(Class);
	}
	function _construct(Parent, args, Class) {
		if (_isNativeReflectConstruct()) _construct = Reflect.construct.bind();
		else _construct = function _construct$1(Parent$1, args$1, Class$1) {
			var a$1 = [null];
			a$1.push.apply(a$1, args$1);
			var instance = new (Function.bind.apply(Parent$1, a$1))();
			if (Class$1) _setPrototypeOf(instance, Class$1.prototype);
			return instance;
		};
		return _construct.apply(null, arguments);
	}
	function _isNativeReflectConstruct() {
		if (typeof Reflect === "undefined" || !Reflect.construct) return false;
		if (Reflect.construct.sham) return false;
		if (typeof Proxy === "function") return true;
		try {
			Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
			return true;
		} catch (e$1) {
			return false;
		}
	}
	function _isNativeFunction(fn$1) {
		return Function.toString.call(fn$1).indexOf("[native code]") !== -1;
	}
	function _setPrototypeOf(o$1, p$1) {
		_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$2(o$2, p$2) {
			o$2.__proto__ = p$2;
			return o$2;
		};
		return _setPrototypeOf(o$1, p$1);
	}
	function _getPrototypeOf(o$1) {
		_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$2(o$2) {
			return o$2.__proto__ || Object.getPrototypeOf(o$2);
		};
		return _getPrototypeOf(o$1);
	}
	function _typeof$2(o$1) {
		"@babel/helpers - typeof";
		return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
			return typeof o$2;
		} : function(o$2) {
			return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
		}, _typeof$2(o$1);
	}
	var inspect$1 = require_util$2().inspect;
	var ERR_INVALID_ARG_TYPE$1 = require_errors().codes.ERR_INVALID_ARG_TYPE;
	function endsWith(str, search, this_len) {
		if (this_len === void 0 || this_len > str.length) this_len = str.length;
		return str.substring(this_len - search.length, this_len) === search;
	}
	function repeat(str, count) {
		count = Math.floor(count);
		if (str.length == 0 || count == 0) return "";
		var maxCount = str.length * count;
		count = Math.floor(Math.log(count) / Math.log(2));
		while (count) {
			str += str;
			count--;
		}
		str += str.substring(0, maxCount - str.length);
		return str;
	}
	var blue = "";
	var green = "";
	var red = "";
	var white = "";
	var kReadableOperator = {
		deepStrictEqual: "Expected values to be strictly deep-equal:",
		strictEqual: "Expected values to be strictly equal:",
		strictEqualObject: "Expected \"actual\" to be reference-equal to \"expected\":",
		deepEqual: "Expected values to be loosely deep-equal:",
		equal: "Expected values to be loosely equal:",
		notDeepStrictEqual: "Expected \"actual\" not to be strictly deep-equal to:",
		notStrictEqual: "Expected \"actual\" to be strictly unequal to:",
		notStrictEqualObject: "Expected \"actual\" not to be reference-equal to \"expected\":",
		notDeepEqual: "Expected \"actual\" not to be loosely deep-equal to:",
		notEqual: "Expected \"actual\" to be loosely unequal to:",
		notIdentical: "Values identical but not reference-equal:"
	};
	var kMaxShortLength = 10;
	function copyError(source) {
		var keys$9 = Object.keys(source);
		var target = Object.create(Object.getPrototypeOf(source));
		keys$9.forEach(function(key) {
			target[key] = source[key];
		});
		Object.defineProperty(target, "message", { value: source.message });
		return target;
	}
	function inspectValue(val) {
		return inspect$1(val, {
			compact: false,
			customInspect: false,
			depth: 1e3,
			maxArrayLength: Infinity,
			showHidden: false,
			breakLength: Infinity,
			showProxy: false,
			sorted: true,
			getters: true
		});
	}
	function createErrDiff(actual, expected, operator) {
		var other = "";
		var res = "";
		var lastPos = 0;
		var end = "";
		var skipped = false;
		var actualInspected = inspectValue(actual);
		var actualLines = actualInspected.split("\n");
		var expectedLines = inspectValue(expected).split("\n");
		var i$2 = 0;
		var indicator = "";
		if (operator === "strictEqual" && _typeof$2(actual) === "object" && _typeof$2(expected) === "object" && actual !== null && expected !== null) operator = "strictEqualObject";
		if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
			var inputLength = actualLines[0].length + expectedLines[0].length;
			if (inputLength <= kMaxShortLength) {
				if ((_typeof$2(actual) !== "object" || actual === null) && (_typeof$2(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
			} else if (operator !== "strictEqualObject") {
				if (inputLength < (process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80)) {
					while (actualLines[0][i$2] === expectedLines[0][i$2]) i$2++;
					if (i$2 > 2) {
						indicator = "\n  ".concat(repeat(" ", i$2), "^");
						i$2 = 0;
					}
				}
			}
		}
		var a$1 = actualLines[actualLines.length - 1];
		var b$5 = expectedLines[expectedLines.length - 1];
		while (a$1 === b$5) {
			if (i$2++ < 2) end = "\n  ".concat(a$1).concat(end);
			else other = a$1;
			actualLines.pop();
			expectedLines.pop();
			if (actualLines.length === 0 || expectedLines.length === 0) break;
			a$1 = actualLines[actualLines.length - 1];
			b$5 = expectedLines[expectedLines.length - 1];
		}
		var maxLines = Math.max(actualLines.length, expectedLines.length);
		if (maxLines === 0) {
			var _actualLines = actualInspected.split("\n");
			if (_actualLines.length > 30) {
				_actualLines[26] = "".concat(blue, "...").concat(white);
				while (_actualLines.length > 27) _actualLines.pop();
			}
			return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
		}
		if (i$2 > 3) {
			end = "\n".concat(blue, "...").concat(white).concat(end);
			skipped = true;
		}
		if (other !== "") {
			end = "\n  ".concat(other).concat(end);
			other = "";
		}
		var printedLines = 0;
		var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
		var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
		for (i$2 = 0; i$2 < maxLines; i$2++) {
			var cur = i$2 - lastPos;
			if (actualLines.length < i$2 + 1) {
				if (cur > 1 && i$2 > 2) {
					if (cur > 4) {
						res += "\n".concat(blue, "...").concat(white);
						skipped = true;
					} else if (cur > 3) {
						res += "\n  ".concat(expectedLines[i$2 - 2]);
						printedLines++;
					}
					res += "\n  ".concat(expectedLines[i$2 - 1]);
					printedLines++;
				}
				lastPos = i$2;
				other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i$2]);
				printedLines++;
			} else if (expectedLines.length < i$2 + 1) {
				if (cur > 1 && i$2 > 2) {
					if (cur > 4) {
						res += "\n".concat(blue, "...").concat(white);
						skipped = true;
					} else if (cur > 3) {
						res += "\n  ".concat(actualLines[i$2 - 2]);
						printedLines++;
					}
					res += "\n  ".concat(actualLines[i$2 - 1]);
					printedLines++;
				}
				lastPos = i$2;
				res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i$2]);
				printedLines++;
			} else {
				var expectedLine = expectedLines[i$2];
				var actualLine = actualLines[i$2];
				var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
				if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
					divergingLines = false;
					actualLine += ",";
				}
				if (divergingLines) {
					if (cur > 1 && i$2 > 2) {
						if (cur > 4) {
							res += "\n".concat(blue, "...").concat(white);
							skipped = true;
						} else if (cur > 3) {
							res += "\n  ".concat(actualLines[i$2 - 2]);
							printedLines++;
						}
						res += "\n  ".concat(actualLines[i$2 - 1]);
						printedLines++;
					}
					lastPos = i$2;
					res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
					other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
					printedLines += 2;
				} else {
					res += other;
					other = "";
					if (cur === 1 || i$2 === 0) {
						res += "\n  ".concat(actualLine);
						printedLines++;
					}
				}
			}
			if (printedLines > 20 && i$2 < maxLines - 2) return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
		}
		return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
	}
	module.exports = /* @__PURE__ */ function(_Error, _inspect$custom) {
		_inherits(AssertionError$2, _Error);
		var _super = _createSuper(AssertionError$2);
		function AssertionError$2(options) {
			var _this;
			_classCallCheck$1(this, AssertionError$2);
			if (_typeof$2(options) !== "object" || options === null) throw new ERR_INVALID_ARG_TYPE$1("options", "Object", options);
			var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
			var actual = options.actual, expected = options.expected;
			var limit = Error.stackTraceLimit;
			Error.stackTraceLimit = 0;
			if (message != null) _this = _super.call(this, String(message));
			else {
				if (process$1.stderr && process$1.stderr.isTTY) if (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1) {
					blue = "\x1B[34m";
					green = "\x1B[32m";
					white = "\x1B[39m";
					red = "\x1B[31m";
				} else {
					blue = "";
					green = "";
					white = "";
					red = "";
				}
				if (_typeof$2(actual) === "object" && actual !== null && _typeof$2(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
					actual = copyError(actual);
					expected = copyError(expected);
				}
				if (operator === "deepStrictEqual" || operator === "strictEqual") _this = _super.call(this, createErrDiff(actual, expected, operator));
				else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
					var base = kReadableOperator[operator];
					var res = inspectValue(actual).split("\n");
					if (operator === "notStrictEqual" && _typeof$2(actual) === "object" && actual !== null) base = kReadableOperator.notStrictEqualObject;
					if (res.length > 30) {
						res[26] = "".concat(blue, "...").concat(white);
						while (res.length > 27) res.pop();
					}
					if (res.length === 1) _this = _super.call(this, "".concat(base, " ").concat(res[0]));
					else _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
				} else {
					var _res = inspectValue(actual);
					var other = "";
					var knownOperators = kReadableOperator[operator];
					if (operator === "notDeepEqual" || operator === "notEqual") {
						_res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
						if (_res.length > 1024) _res = "".concat(_res.slice(0, 1021), "...");
					} else {
						other = "".concat(inspectValue(expected));
						if (_res.length > 512) _res = "".concat(_res.slice(0, 509), "...");
						if (other.length > 512) other = "".concat(other.slice(0, 509), "...");
						if (operator === "deepEqual" || operator === "equal") _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
						else other = " ".concat(operator, " ").concat(other);
					}
					_this = _super.call(this, "".concat(_res).concat(other));
				}
			}
			Error.stackTraceLimit = limit;
			_this.generatedMessage = !message;
			Object.defineProperty(_assertThisInitialized(_this), "name", {
				value: "AssertionError [ERR_ASSERTION]",
				enumerable: false,
				writable: true,
				configurable: true
			});
			_this.code = "ERR_ASSERTION";
			_this.actual = actual;
			_this.expected = expected;
			_this.operator = operator;
			if (Error.captureStackTrace) Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
			_this.stack;
			_this.name = "AssertionError";
			return _possibleConstructorReturn(_this);
		}
		_createClass$1(AssertionError$2, [{
			key: "toString",
			value: function toString$1() {
				return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
			}
		}, {
			key: _inspect$custom,
			value: function value(recurseTimes, ctx) {
				return inspect$1(this, _objectSpread(_objectSpread({}, ctx), {}, {
					customInspect: false,
					depth: 0
				}));
			}
		}]);
		return AssertionError$2;
	}(/* @__PURE__ */ _wrapNativeSuper(Error), inspect$1.custom);
}));
var require_implementation$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var objectKeys = require_object_keys();
	var hasSymbols = require_shams$1()();
	var callBound = require_callBound();
	var toObject = Object;
	var $push = callBound("Array.prototype.push");
	var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
	var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
	module.exports = function assign(target, source1) {
		if (target == null) throw new TypeError("target must be an object");
		var to = toObject(target);
		if (arguments.length === 1) return to;
		for (var s$2 = 1; s$2 < arguments.length; ++s$2) {
			var from$2 = toObject(arguments[s$2]);
			var keys$9 = objectKeys(from$2);
			var getSymbols$4 = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
			if (getSymbols$4) {
				var syms = getSymbols$4(from$2);
				for (var j$1 = 0; j$1 < syms.length; ++j$1) {
					var key = syms[j$1];
					if ($propIsEnumerable(from$2, key)) $push(keys$9, key);
				}
			}
			for (var i$2 = 0; i$2 < keys$9.length; ++i$2) {
				var nextKey = keys$9[i$2];
				if ($propIsEnumerable(from$2, nextKey)) to[nextKey] = from$2[nextKey];
			}
		}
		return to;
	};
}));
var require_polyfill$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var implementation$4 = require_implementation$2();
	var lacksProperEnumerationOrder = function() {
		if (!Object.assign) return false;
		var str = "abcdefghijklmnopqrst";
		var letters = str.split("");
		var map = {};
		for (var i$2 = 0; i$2 < letters.length; ++i$2) map[letters[i$2]] = letters[i$2];
		var obj = Object.assign({}, map);
		var actual = "";
		for (var k$1 in obj) actual += k$1;
		return str !== actual;
	};
	var assignHasPendingExceptions = function() {
		if (!Object.assign || !Object.preventExtensions) return false;
		var thrower = Object.preventExtensions({ 1: 2 });
		try {
			Object.assign(thrower, "xy");
		} catch (e$1) {
			return thrower[1] === "y";
		}
		return false;
	};
	module.exports = function getPolyfill$4() {
		if (!Object.assign) return implementation$4;
		if (lacksProperEnumerationOrder()) return implementation$4;
		if (assignHasPendingExceptions()) return implementation$4;
		return Object.assign;
	};
}));
var require_implementation$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var numberIsNaN$1 = function(value) {
		return value !== value;
	};
	module.exports = function is(a$1, b$5) {
		if (a$1 === 0 && b$5 === 0) return 1 / a$1 === 1 / b$5;
		if (a$1 === b$5) return true;
		if (numberIsNaN$1(a$1) && numberIsNaN$1(b$5)) return true;
		return false;
	};
}));
var require_polyfill$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var implementation$3 = require_implementation$1();
	module.exports = function getPolyfill$4() {
		return typeof Object.is === "function" ? Object.is : implementation$3;
	};
}));
var require_shim$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getPolyfill$3 = require_polyfill$1();
	var define$4 = require_define_properties();
	module.exports = function shimObjectIs() {
		var polyfill$2 = getPolyfill$3();
		define$4(Object, { is: polyfill$2 }, { is: function testObjectIs() {
			return Object.is !== polyfill$2;
		} });
		return polyfill$2;
	};
}));
var require_object_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var define$3 = require_define_properties();
	var callBind$1 = require_call_bind();
	var implementation$2 = require_implementation$1();
	var getPolyfill$2 = require_polyfill$1();
	var shim$1 = require_shim$1();
	var polyfill$1 = callBind$1(getPolyfill$2(), Object);
	define$3(polyfill$1, {
		getPolyfill: getPolyfill$2,
		implementation: implementation$2,
		shim: shim$1
	});
	module.exports = polyfill$1;
}));
var require_implementation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function isNaN$1(value) {
		return value !== value;
	};
}));
var require_polyfill = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var implementation$1 = require_implementation();
	module.exports = function getPolyfill$4() {
		if (Number.isNaN && !Number.isNaN("a")) return Number.isNaN;
		return implementation$1;
	};
}));
var require_shim = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var define$2 = require_define_properties();
	var getPolyfill$1 = require_polyfill();
	module.exports = function shimNumberIsNaN() {
		var polyfill$2 = getPolyfill$1();
		define$2(Number, { isNaN: polyfill$2 }, { isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill$2;
		} });
		return polyfill$2;
	};
}));
var require_is_nan = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBind = require_call_bind();
	var define$1 = require_define_properties();
	var implementation = require_implementation();
	var getPolyfill = require_polyfill();
	var shim = require_shim();
	var polyfill = callBind(getPolyfill(), Number);
	define$1(polyfill, {
		getPolyfill,
		implementation,
		shim
	});
	module.exports = polyfill;
}));
var require_comparisons = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _slicedToArray(arr, i$2) {
		return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i$2) || _unsupportedIterableToArray(arr, i$2) || _nonIterableRest();
	}
	function _nonIterableRest() {
		throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _unsupportedIterableToArray(o$1, minLen) {
		if (!o$1) return;
		if (typeof o$1 === "string") return _arrayLikeToArray(o$1, minLen);
		var n$6 = Object.prototype.toString.call(o$1).slice(8, -1);
		if (n$6 === "Object" && o$1.constructor) n$6 = o$1.constructor.name;
		if (n$6 === "Map" || n$6 === "Set") return Array.from(o$1);
		if (n$6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$6)) return _arrayLikeToArray(o$1, minLen);
	}
	function _arrayLikeToArray(arr, len$1) {
		if (len$1 == null || len$1 > arr.length) len$1 = arr.length;
		for (var i$2 = 0, arr2 = new Array(len$1); i$2 < len$1; i$2++) arr2[i$2] = arr[i$2];
		return arr2;
	}
	function _iterableToArrayLimit(r$1, l$2) {
		var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
		if (null != t$1) {
			var e$1, n$6, i$2, u$1, a$1 = [], f$1 = !0, o$1 = !1;
			try {
				if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l$2) {
					if (Object(t$1) !== t$1) return;
					f$1 = !1;
				} else for (; !(f$1 = (e$1 = i$2.call(t$1)).done) && (a$1.push(e$1.value), a$1.length !== l$2); f$1 = !0);
			} catch (r$2) {
				o$1 = !0, n$6 = r$2;
			} finally {
				try {
					if (!f$1 && null != t$1.return && (u$1 = t$1.return(), Object(u$1) !== u$1)) return;
				} finally {
					if (o$1) throw n$6;
				}
			}
			return a$1;
		}
	}
	function _arrayWithHoles(arr) {
		if (Array.isArray(arr)) return arr;
	}
	function _typeof$1(o$1) {
		"@babel/helpers - typeof";
		return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
			return typeof o$2;
		} : function(o$2) {
			return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
		}, _typeof$1(o$1);
	}
	var regexFlagsSupported = /a/g.flags !== void 0;
	var arrayFromSet = function arrayFromSet$1(set) {
		var array = [];
		set.forEach(function(value) {
			return array.push(value);
		});
		return array;
	};
	var arrayFromMap = function arrayFromMap$1(map) {
		var array = [];
		map.forEach(function(value, key) {
			return array.push([key, value]);
		});
		return array;
	};
	var objectIs$1 = Object.is ? Object.is : require_object_is();
	var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
		return [];
	};
	var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
	function uncurryThis(f$1) {
		return f$1.call.bind(f$1);
	}
	var hasOwnProperty$3 = uncurryThis(Object.prototype.hasOwnProperty);
	var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
	var objectToString = uncurryThis(Object.prototype.toString);
	var _require$types$1 = require_util$2().types, isAnyArrayBuffer = _require$types$1.isAnyArrayBuffer, isArrayBufferView = _require$types$1.isArrayBufferView, isDate$1 = _require$types$1.isDate, isMap$2 = _require$types$1.isMap, isRegExp$1 = _require$types$1.isRegExp, isSet$2 = _require$types$1.isSet, isNativeError = _require$types$1.isNativeError, isBoxedPrimitive = _require$types$1.isBoxedPrimitive, isNumberObject = _require$types$1.isNumberObject, isStringObject = _require$types$1.isStringObject, isBooleanObject = _require$types$1.isBooleanObject, isBigIntObject = _require$types$1.isBigIntObject, isSymbolObject = _require$types$1.isSymbolObject, isFloat32Array = _require$types$1.isFloat32Array, isFloat64Array = _require$types$1.isFloat64Array;
	function isNonIndex(key) {
		if (key.length === 0 || key.length > 10) return true;
		for (var i$2 = 0; i$2 < key.length; i$2++) {
			var code$1 = key.charCodeAt(i$2);
			if (code$1 < 48 || code$1 > 57) return true;
		}
		return key.length === 10 && key >= Math.pow(2, 32);
	}
	function getOwnNonIndexProperties(value) {
		return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
	}
	/*!
	* The buffer module from node.js, for the browser.
	*
	* @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	* @license  MIT
	*/
	function compare(a$1, b$5) {
		if (a$1 === b$5) return 0;
		var x$1 = a$1.length;
		var y$1 = b$5.length;
		for (var i$2 = 0, len$1 = Math.min(x$1, y$1); i$2 < len$1; ++i$2) if (a$1[i$2] !== b$5[i$2]) {
			x$1 = a$1[i$2];
			y$1 = b$5[i$2];
			break;
		}
		if (x$1 < y$1) return -1;
		if (y$1 < x$1) return 1;
		return 0;
	}
	var ONLY_ENUMERABLE = void 0;
	var kStrict = true;
	var kLoose = false;
	var kNoIterator = 0;
	var kIsArray = 1;
	var kIsSet = 2;
	var kIsMap = 3;
	function areSimilarRegExps(a$1, b$5) {
		return regexFlagsSupported ? a$1.source === b$5.source && a$1.flags === b$5.flags : RegExp.prototype.toString.call(a$1) === RegExp.prototype.toString.call(b$5);
	}
	function areSimilarFloatArrays(a$1, b$5) {
		if (a$1.byteLength !== b$5.byteLength) return false;
		for (var offset$1 = 0; offset$1 < a$1.byteLength; offset$1++) if (a$1[offset$1] !== b$5[offset$1]) return false;
		return true;
	}
	function areSimilarTypedArrays(a$1, b$5) {
		if (a$1.byteLength !== b$5.byteLength) return false;
		return compare(new Uint8Array(a$1.buffer, a$1.byteOffset, a$1.byteLength), new Uint8Array(b$5.buffer, b$5.byteOffset, b$5.byteLength)) === 0;
	}
	function areEqualArrayBuffers(buf1, buf2) {
		return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
	}
	function isEqualBoxedPrimitive(val1, val2) {
		if (isNumberObject(val1)) return isNumberObject(val2) && objectIs$1(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
		if (isStringObject(val1)) return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
		if (isBooleanObject(val1)) return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
		if (isBigIntObject(val1)) return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
		return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
	}
	function innerDeepEqual(val1, val2, strict$1, memos) {
		if (val1 === val2) {
			if (val1 !== 0) return true;
			return strict$1 ? objectIs$1(val1, val2) : true;
		}
		if (strict$1) {
			if (_typeof$1(val1) !== "object") return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
			if (_typeof$1(val2) !== "object" || val1 === null || val2 === null) return false;
			if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) return false;
		} else {
			if (val1 === null || _typeof$1(val1) !== "object") {
				if (val2 === null || _typeof$1(val2) !== "object") return val1 == val2;
				return false;
			}
			if (val2 === null || _typeof$1(val2) !== "object") return false;
		}
		var val1Tag = objectToString(val1);
		if (val1Tag !== objectToString(val2)) return false;
		if (Array.isArray(val1)) {
			if (val1.length !== val2.length) return false;
			var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
			var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
			if (keys1.length !== keys2.length) return false;
			return keyCheck(val1, val2, strict$1, memos, kIsArray, keys1);
		}
		if (val1Tag === "[object Object]") {
			if (!isMap$2(val1) && isMap$2(val2) || !isSet$2(val1) && isSet$2(val2)) return false;
		}
		if (isDate$1(val1)) {
			if (!isDate$1(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) return false;
		} else if (isRegExp$1(val1)) {
			if (!isRegExp$1(val2) || !areSimilarRegExps(val1, val2)) return false;
		} else if (isNativeError(val1) || val1 instanceof Error) {
			if (val1.message !== val2.message || val1.name !== val2.name) return false;
		} else if (isArrayBufferView(val1)) {
			if (!strict$1 && (isFloat32Array(val1) || isFloat64Array(val1))) {
				if (!areSimilarFloatArrays(val1, val2)) return false;
			} else if (!areSimilarTypedArrays(val1, val2)) return false;
			var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
			var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
			if (_keys.length !== _keys2.length) return false;
			return keyCheck(val1, val2, strict$1, memos, kNoIterator, _keys);
		} else if (isSet$2(val1)) {
			if (!isSet$2(val2) || val1.size !== val2.size) return false;
			return keyCheck(val1, val2, strict$1, memos, kIsSet);
		} else if (isMap$2(val1)) {
			if (!isMap$2(val2) || val1.size !== val2.size) return false;
			return keyCheck(val1, val2, strict$1, memos, kIsMap);
		} else if (isAnyArrayBuffer(val1)) {
			if (!areEqualArrayBuffers(val1, val2)) return false;
		} else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) return false;
		return keyCheck(val1, val2, strict$1, memos, kNoIterator);
	}
	function getEnumerables(val, keys$9) {
		return keys$9.filter(function(k$1) {
			return propertyIsEnumerable(val, k$1);
		});
	}
	function keyCheck(val1, val2, strict$1, memos, iterationType, aKeys) {
		if (arguments.length === 5) {
			aKeys = Object.keys(val1);
			var bKeys = Object.keys(val2);
			if (aKeys.length !== bKeys.length) return false;
		}
		var i$2 = 0;
		for (; i$2 < aKeys.length; i$2++) if (!hasOwnProperty$3(val2, aKeys[i$2])) return false;
		if (strict$1 && arguments.length === 5) {
			var symbolKeysA = objectGetOwnPropertySymbols(val1);
			if (symbolKeysA.length !== 0) {
				var count = 0;
				for (i$2 = 0; i$2 < symbolKeysA.length; i$2++) {
					var key = symbolKeysA[i$2];
					if (propertyIsEnumerable(val1, key)) {
						if (!propertyIsEnumerable(val2, key)) return false;
						aKeys.push(key);
						count++;
					} else if (propertyIsEnumerable(val2, key)) return false;
				}
				var symbolKeysB = objectGetOwnPropertySymbols(val2);
				if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) return false;
			} else {
				var _symbolKeysB = objectGetOwnPropertySymbols(val2);
				if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) return false;
			}
		}
		if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) return true;
		if (memos === void 0) memos = {
			val1: /* @__PURE__ */ new Map(),
			val2: /* @__PURE__ */ new Map(),
			position: 0
		};
		else {
			var val2MemoA = memos.val1.get(val1);
			if (val2MemoA !== void 0) {
				var val2MemoB = memos.val2.get(val2);
				if (val2MemoB !== void 0) return val2MemoA === val2MemoB;
			}
			memos.position++;
		}
		memos.val1.set(val1, memos.position);
		memos.val2.set(val2, memos.position);
		var areEq = objEquiv(val1, val2, strict$1, aKeys, memos, iterationType);
		memos.val1.delete(val1);
		memos.val2.delete(val2);
		return areEq;
	}
	function setHasEqualElement(set, val1, strict$1, memo) {
		var setValues = arrayFromSet(set);
		for (var i$2 = 0; i$2 < setValues.length; i$2++) {
			var val2 = setValues[i$2];
			if (innerDeepEqual(val1, val2, strict$1, memo)) {
				set.delete(val2);
				return true;
			}
		}
		return false;
	}
	function findLooseMatchingPrimitives(prim) {
		switch (_typeof$1(prim)) {
			case "undefined": return null;
			case "object": return;
			case "symbol": return false;
			case "string": prim = +prim;
			case "number": if (numberIsNaN(prim)) return false;
		}
		return true;
	}
	function setMightHaveLoosePrim(a$1, b$5, prim) {
		var altValue = findLooseMatchingPrimitives(prim);
		if (altValue != null) return altValue;
		return b$5.has(altValue) && !a$1.has(altValue);
	}
	function mapMightHaveLoosePrim(a$1, b$5, prim, item, memo) {
		var altValue = findLooseMatchingPrimitives(prim);
		if (altValue != null) return altValue;
		var curB = b$5.get(altValue);
		if (curB === void 0 && !b$5.has(altValue) || !innerDeepEqual(item, curB, false, memo)) return false;
		return !a$1.has(altValue) && innerDeepEqual(item, curB, false, memo);
	}
	function setEquiv(a$1, b$5, strict$1, memo) {
		var set = null;
		var aValues = arrayFromSet(a$1);
		for (var i$2 = 0; i$2 < aValues.length; i$2++) {
			var val = aValues[i$2];
			if (_typeof$1(val) === "object" && val !== null) {
				if (set === null) set = /* @__PURE__ */ new Set();
				set.add(val);
			} else if (!b$5.has(val)) {
				if (strict$1) return false;
				if (!setMightHaveLoosePrim(a$1, b$5, val)) return false;
				if (set === null) set = /* @__PURE__ */ new Set();
				set.add(val);
			}
		}
		if (set !== null) {
			var bValues = arrayFromSet(b$5);
			for (var _i = 0; _i < bValues.length; _i++) {
				var _val = bValues[_i];
				if (_typeof$1(_val) === "object" && _val !== null) {
					if (!setHasEqualElement(set, _val, strict$1, memo)) return false;
				} else if (!strict$1 && !a$1.has(_val) && !setHasEqualElement(set, _val, strict$1, memo)) return false;
			}
			return set.size === 0;
		}
		return true;
	}
	function mapHasEqualEntry(set, map, key1, item1, strict$1, memo) {
		var setValues = arrayFromSet(set);
		for (var i$2 = 0; i$2 < setValues.length; i$2++) {
			var key2 = setValues[i$2];
			if (innerDeepEqual(key1, key2, strict$1, memo) && innerDeepEqual(item1, map.get(key2), strict$1, memo)) {
				set.delete(key2);
				return true;
			}
		}
		return false;
	}
	function mapEquiv(a$1, b$5, strict$1, memo) {
		var set = null;
		var aEntries = arrayFromMap(a$1);
		for (var i$2 = 0; i$2 < aEntries.length; i$2++) {
			var _aEntries$i = _slicedToArray(aEntries[i$2], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
			if (_typeof$1(key) === "object" && key !== null) {
				if (set === null) set = /* @__PURE__ */ new Set();
				set.add(key);
			} else {
				var item2 = b$5.get(key);
				if (item2 === void 0 && !b$5.has(key) || !innerDeepEqual(item1, item2, strict$1, memo)) {
					if (strict$1) return false;
					if (!mapMightHaveLoosePrim(a$1, b$5, key, item1, memo)) return false;
					if (set === null) set = /* @__PURE__ */ new Set();
					set.add(key);
				}
			}
		}
		if (set !== null) {
			var bEntries = arrayFromMap(b$5);
			for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
				var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
				if (_typeof$1(_key) === "object" && _key !== null) {
					if (!mapHasEqualEntry(set, a$1, _key, item, strict$1, memo)) return false;
				} else if (!strict$1 && (!a$1.has(_key) || !innerDeepEqual(a$1.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a$1, _key, item, false, memo)) return false;
			}
			return set.size === 0;
		}
		return true;
	}
	function objEquiv(a$1, b$5, strict$1, keys$9, memos, iterationType) {
		var i$2 = 0;
		if (iterationType === kIsSet) {
			if (!setEquiv(a$1, b$5, strict$1, memos)) return false;
		} else if (iterationType === kIsMap) {
			if (!mapEquiv(a$1, b$5, strict$1, memos)) return false;
		} else if (iterationType === kIsArray) for (; i$2 < a$1.length; i$2++) if (hasOwnProperty$3(a$1, i$2)) {
			if (!hasOwnProperty$3(b$5, i$2) || !innerDeepEqual(a$1[i$2], b$5[i$2], strict$1, memos)) return false;
		} else if (hasOwnProperty$3(b$5, i$2)) return false;
		else {
			var keysA = Object.keys(a$1);
			for (; i$2 < keysA.length; i$2++) {
				var key = keysA[i$2];
				if (!hasOwnProperty$3(b$5, key) || !innerDeepEqual(a$1[key], b$5[key], strict$1, memos)) return false;
			}
			if (keysA.length !== Object.keys(b$5).length) return false;
			return true;
		}
		for (i$2 = 0; i$2 < keys$9.length; i$2++) {
			var _key2 = keys$9[i$2];
			if (!innerDeepEqual(a$1[_key2], b$5[_key2], strict$1, memos)) return false;
		}
		return true;
	}
	function isDeepEqual$1(val1, val2) {
		return innerDeepEqual(val1, val2, kLoose);
	}
	function isDeepStrictEqual$1(val1, val2) {
		return innerDeepEqual(val1, val2, kStrict);
	}
	module.exports = {
		isDeepEqual: isDeepEqual$1,
		isDeepStrictEqual: isDeepStrictEqual$1
	};
}));
var require_assert = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist$1();
	function _typeof(o$1) {
		"@babel/helpers - typeof";
		return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
			return typeof o$2;
		} : function(o$2) {
			return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
		}, _typeof(o$1);
	}
	function _defineProperties(target, props) {
		for (var i$2 = 0; i$2 < props.length; i$2++) {
			var descriptor = props[i$2];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
		}
	}
	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		Object.defineProperty(Constructor, "prototype", { writable: false });
		return Constructor;
	}
	function _toPropertyKey(arg) {
		var key = _toPrimitive(arg, "string");
		return _typeof(key) === "symbol" ? key : String(key);
	}
	function _toPrimitive(input, hint) {
		if (_typeof(input) !== "object" || input === null) return input;
		var prim = input[Symbol.toPrimitive];
		if (prim !== void 0) {
			var res = prim.call(input, hint || "default");
			if (_typeof(res) !== "object") return res;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return (hint === "string" ? String : Number)(input);
	}
	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	}
	var _require$codes = require_errors().codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
	var AssertionError = require_assertion_error();
	var inspect = require_util$2().inspect;
	var _require$types = require_util$2().types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
	var objectAssign = require_polyfill$2()();
	var objectIs = require_polyfill$1()();
	var RegExpPrototypeTest = require_callBound$1()("RegExp.prototype.test");
	var isDeepEqual;
	var isDeepStrictEqual;
	function lazyLoadComparison() {
		var comparison = require_comparisons();
		isDeepEqual = comparison.isDeepEqual;
		isDeepStrictEqual = comparison.isDeepStrictEqual;
	}
	var warned = false;
	var assert$1 = module.exports = ok;
	var NO_EXCEPTION_SENTINEL = {};
	function innerFail(obj) {
		if (obj.message instanceof Error) throw obj.message;
		throw new AssertionError(obj);
	}
	function fail(actual, expected, message, operator, stackStartFn) {
		var argsLen = arguments.length;
		var internalMessage;
		if (argsLen === 0) internalMessage = "Failed";
		else if (argsLen === 1) {
			message = actual;
			actual = void 0;
		} else {
			if (warned === false) {
				warned = true;
				(process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
			}
			if (argsLen === 2) operator = "!=";
		}
		if (message instanceof Error) throw message;
		var errArgs = {
			actual,
			expected,
			operator: operator === void 0 ? "fail" : operator,
			stackStartFn: stackStartFn || fail
		};
		if (message !== void 0) errArgs.message = message;
		var err = new AssertionError(errArgs);
		if (internalMessage) {
			err.message = internalMessage;
			err.generatedMessage = true;
		}
		throw err;
	}
	assert$1.fail = fail;
	assert$1.AssertionError = AssertionError;
	function innerOk(fn$1, argLen, value, message) {
		if (!value) {
			var generatedMessage = false;
			if (argLen === 0) {
				generatedMessage = true;
				message = "No value argument passed to `assert.ok()`";
			} else if (message instanceof Error) throw message;
			var err = new AssertionError({
				actual: value,
				expected: true,
				message,
				operator: "==",
				stackStartFn: fn$1
			});
			err.generatedMessage = generatedMessage;
			throw err;
		}
	}
	function ok() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		innerOk.apply(void 0, [ok, args.length].concat(args));
	}
	assert$1.ok = ok;
	assert$1.equal = function equal(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (actual != expected) innerFail({
			actual,
			expected,
			message,
			operator: "==",
			stackStartFn: equal
		});
	};
	assert$1.notEqual = function notEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (actual == expected) innerFail({
			actual,
			expected,
			message,
			operator: "!=",
			stackStartFn: notEqual
		});
	};
	assert$1.deepEqual = function deepEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (isDeepEqual === void 0) lazyLoadComparison();
		if (!isDeepEqual(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "deepEqual",
			stackStartFn: deepEqual
		});
	};
	assert$1.notDeepEqual = function notDeepEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (isDeepEqual === void 0) lazyLoadComparison();
		if (isDeepEqual(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "notDeepEqual",
			stackStartFn: notDeepEqual
		});
	};
	assert$1.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (isDeepEqual === void 0) lazyLoadComparison();
		if (!isDeepStrictEqual(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "deepStrictEqual",
			stackStartFn: deepStrictEqual
		});
	};
	assert$1.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (isDeepEqual === void 0) lazyLoadComparison();
		if (isDeepStrictEqual(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "notDeepStrictEqual",
			stackStartFn: notDeepStrictEqual
		});
	}
	assert$1.strictEqual = function strictEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (!objectIs(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "strictEqual",
			stackStartFn: strictEqual
		});
	};
	assert$1.notStrictEqual = function notStrictEqual(actual, expected, message) {
		if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
		if (objectIs(actual, expected)) innerFail({
			actual,
			expected,
			message,
			operator: "notStrictEqual",
			stackStartFn: notStrictEqual
		});
	};
	var Comparison = /* @__PURE__ */ _createClass(function Comparison$1(obj, keys$9, actual) {
		var _this = this;
		_classCallCheck(this, Comparison$1);
		keys$9.forEach(function(key) {
			if (key in obj) if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) _this[key] = actual[key];
			else _this[key] = obj[key];
		});
	});
	function compareExceptionKey(actual, expected, key, message, keys$9, fn$1) {
		if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
			if (!message) {
				var err = new AssertionError({
					actual: new Comparison(actual, keys$9),
					expected: new Comparison(expected, keys$9, actual),
					operator: "deepStrictEqual",
					stackStartFn: fn$1
				});
				err.actual = actual;
				err.expected = expected;
				err.operator = fn$1.name;
				throw err;
			}
			innerFail({
				actual,
				expected,
				message,
				operator: fn$1.name,
				stackStartFn: fn$1
			});
		}
	}
	function expectedException(actual, expected, msg, fn$1) {
		if (typeof expected !== "function") {
			if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
			if (arguments.length === 2) throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
			if (_typeof(actual) !== "object" || actual === null) {
				var err = new AssertionError({
					actual,
					expected,
					message: msg,
					operator: "deepStrictEqual",
					stackStartFn: fn$1
				});
				err.operator = fn$1.name;
				throw err;
			}
			var keys$9 = Object.keys(expected);
			if (expected instanceof Error) keys$9.push("name", "message");
			else if (keys$9.length === 0) throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
			if (isDeepEqual === void 0) lazyLoadComparison();
			keys$9.forEach(function(key) {
				if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) return;
				compareExceptionKey(actual, expected, key, msg, keys$9, fn$1);
			});
			return true;
		}
		if (expected.prototype !== void 0 && actual instanceof expected) return true;
		if (Error.isPrototypeOf(expected)) return false;
		return expected.call({}, actual) === true;
	}
	function getActual(fn$1) {
		if (typeof fn$1 !== "function") throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn$1);
		try {
			fn$1();
		} catch (e$1) {
			return e$1;
		}
		return NO_EXCEPTION_SENTINEL;
	}
	function checkIsPromise(obj) {
		return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
	}
	function waitForActual(promiseFn) {
		return Promise.resolve().then(function() {
			var resultPromise;
			if (typeof promiseFn === "function") {
				resultPromise = promiseFn();
				if (!checkIsPromise(resultPromise)) throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
			} else if (checkIsPromise(promiseFn)) resultPromise = promiseFn;
			else throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
			return Promise.resolve().then(function() {
				return resultPromise;
			}).then(function() {
				return NO_EXCEPTION_SENTINEL;
			}).catch(function(e$1) {
				return e$1;
			});
		});
	}
	function expectsError(stackStartFn, actual, error$1, message) {
		if (typeof error$1 === "string") {
			if (arguments.length === 4) throw new ERR_INVALID_ARG_TYPE("error", [
				"Object",
				"Error",
				"Function",
				"RegExp"
			], error$1);
			if (_typeof(actual) === "object" && actual !== null) {
				if (actual.message === error$1) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", "The error message \"".concat(actual.message, "\" is identical to the message."));
			} else if (actual === error$1) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", "The error \"".concat(actual, "\" is identical to the message."));
			message = error$1;
			error$1 = void 0;
		} else if (error$1 != null && _typeof(error$1) !== "object" && typeof error$1 !== "function") throw new ERR_INVALID_ARG_TYPE("error", [
			"Object",
			"Error",
			"Function",
			"RegExp"
		], error$1);
		if (actual === NO_EXCEPTION_SENTINEL) {
			var details = "";
			if (error$1 && error$1.name) details += " (".concat(error$1.name, ")");
			details += message ? ": ".concat(message) : ".";
			var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
			innerFail({
				actual: void 0,
				expected: error$1,
				operator: stackStartFn.name,
				message: "Missing expected ".concat(fnType).concat(details),
				stackStartFn
			});
		}
		if (error$1 && !expectedException(actual, error$1, message, stackStartFn)) throw actual;
	}
	function expectsNoError(stackStartFn, actual, error$1, message) {
		if (actual === NO_EXCEPTION_SENTINEL) return;
		if (typeof error$1 === "string") {
			message = error$1;
			error$1 = void 0;
		}
		if (!error$1 || expectedException(actual, error$1)) {
			var details = message ? ": ".concat(message) : ".";
			var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
			innerFail({
				actual,
				expected: error$1,
				operator: stackStartFn.name,
				message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
				stackStartFn
			});
		}
		throw actual;
	}
	assert$1.throws = function throws(promiseFn) {
		for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
		expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
	};
	assert$1.rejects = function rejects(promiseFn) {
		for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
		return waitForActual(promiseFn).then(function(result) {
			return expectsError.apply(void 0, [rejects, result].concat(args));
		});
	};
	assert$1.doesNotThrow = function doesNotThrow(fn$1) {
		for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
		expectsNoError.apply(void 0, [doesNotThrow, getActual(fn$1)].concat(args));
	};
	assert$1.doesNotReject = function doesNotReject(fn$1) {
		for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) args[_key5 - 1] = arguments[_key5];
		return waitForActual(fn$1).then(function(result) {
			return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
		});
	};
	assert$1.ifError = function ifError(err) {
		if (err !== null && err !== void 0) {
			var message = "ifError got unwanted exception: ";
			if (_typeof(err) === "object" && typeof err.message === "string") if (err.message.length === 0 && err.constructor) message += err.constructor.name;
			else message += err.message;
			else message += inspect(err);
			var newErr = new AssertionError({
				actual: err,
				expected: null,
				operator: "ifError",
				message,
				stackStartFn: ifError
			});
			var origStack = err.stack;
			if (typeof origStack === "string") {
				var tmp2 = origStack.split("\n");
				tmp2.shift();
				var tmp1 = newErr.stack.split("\n");
				for (var i$2 = 0; i$2 < tmp2.length; i$2++) {
					var pos = tmp1.indexOf(tmp2[i$2]);
					if (pos !== -1) {
						tmp1 = tmp1.slice(0, pos);
						break;
					}
				}
				newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
			}
			throw newErr;
		}
	};
	function internalMatch(string, regexp, message, fn$1, fnName) {
		if (!isRegExp(regexp)) throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
		var match$1 = fnName === "match";
		if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match$1) {
			if (message instanceof Error) throw message;
			var generatedMessage = !message;
			message = message || (typeof string !== "string" ? "The \"string\" argument must be of type string. Received type " + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match$1 ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
			var err = new AssertionError({
				actual: string,
				expected: regexp,
				message,
				operator: fnName,
				stackStartFn: fn$1
			});
			err.generatedMessage = generatedMessage;
			throw err;
		}
	}
	assert$1.match = function match$1(string, regexp, message) {
		internalMatch(string, regexp, message, match$1, "match");
	};
	assert$1.doesNotMatch = function doesNotMatch(string, regexp, message) {
		internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
	};
	function strict() {
		for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
		innerOk.apply(void 0, [strict, args.length].concat(args));
	}
	assert$1.strict = objectAssign(strict, assert$1, {
		equal: assert$1.strictEqual,
		deepEqual: assert$1.deepStrictEqual,
		notEqual: assert$1.notStrictEqual,
		notDeepEqual: assert$1.notDeepStrictEqual
	});
	assert$1.strict.strict = assert$1.strict;
}));
var require_base64 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	exports.encode = function(number) {
		if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
		throw new TypeError("Must be between 0 and 63: " + number);
	};
	exports.decode = function(charCode) {
		var bigA = 65;
		var bigZ = 90;
		var littleA = 97;
		var littleZ = 122;
		var zero = 48;
		var nine = 57;
		var plus$1 = 43;
		var slash = 47;
		var littleOffset = 26;
		var numberOffset = 52;
		if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
		if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
		if (zero <= charCode && charCode <= nine) return charCode - zero + numberOffset;
		if (charCode == plus$1) return 62;
		if (charCode == slash) return 63;
		return -1;
	};
}));
var require_base64_vlq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var base64 = require_base64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	function toVLQSigned(aValue) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	function fromVLQSigned(aValue) {
		var isNegative = (aValue & 1) === 1;
		var shifted = aValue >> 1;
		return isNegative ? -shifted : shifted;
	}
	exports.encode = function base64VLQ_encode(aValue) {
		var encoded = "";
		var digit;
		var vlq = toVLQSigned(aValue);
		do {
			digit = vlq & VLQ_BASE_MASK;
			vlq >>>= VLQ_BASE_SHIFT;
			if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
			encoded += base64.encode(digit);
		} while (vlq > 0);
		return encoded;
	};
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		var strLen = aStr.length;
		var result = 0;
		var shift = 0;
		var continuation, digit;
		do {
			if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
			digit = base64.decode(aStr.charCodeAt(aIndex++));
			if (digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			continuation = !!(digit & VLQ_CONTINUATION_BIT);
			digit &= VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += VLQ_BASE_SHIFT;
		} while (continuation);
		aOutParam.value = fromVLQSigned(result);
		aOutParam.rest = aIndex;
	};
}));
var require_util$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	function getArg(aArgs, aName, aDefaultValue) {
		if (aName in aArgs) return aArgs[aName];
		else if (arguments.length === 3) return aDefaultValue;
		else throw new Error("\"" + aName + "\" is a required argument.");
	}
	exports.getArg = getArg;
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	function urlParse(aUrl) {
		var match$1 = aUrl.match(urlRegexp);
		if (!match$1) return null;
		return {
			scheme: match$1[1],
			auth: match$1[2],
			host: match$1[3],
			port: match$1[4],
			path: match$1[5]
		};
	}
	exports.urlParse = urlParse;
	function urlGenerate(aParsedUrl) {
		var url = "";
		if (aParsedUrl.scheme) url += aParsedUrl.scheme + ":";
		url += "//";
		if (aParsedUrl.auth) url += aParsedUrl.auth + "@";
		if (aParsedUrl.host) url += aParsedUrl.host;
		if (aParsedUrl.port) url += ":" + aParsedUrl.port;
		if (aParsedUrl.path) url += aParsedUrl.path;
		return url;
	}
	exports.urlGenerate = urlGenerate;
	function normalize$1(aPath) {
		var path = aPath;
		var url = urlParse(aPath);
		if (url) {
			if (!url.path) return aPath;
			path = url.path;
		}
		var isAbsolute = exports.isAbsolute(path);
		var parts = path.split(/\/+/);
		for (var part, up = 0, i$2 = parts.length - 1; i$2 >= 0; i$2--) {
			part = parts[i$2];
			if (part === ".") parts.splice(i$2, 1);
			else if (part === "..") up++;
			else if (up > 0) if (part === "") {
				parts.splice(i$2 + 1, up);
				up = 0;
			} else {
				parts.splice(i$2, 2);
				up--;
			}
		}
		path = parts.join("/");
		if (path === "") path = isAbsolute ? "/" : ".";
		if (url) {
			url.path = path;
			return urlGenerate(url);
		}
		return path;
	}
	exports.normalize = normalize$1;
	function join(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		if (aPath === "") aPath = ".";
		var aPathUrl = urlParse(aPath);
		var aRootUrl = urlParse(aRoot);
		if (aRootUrl) aRoot = aRootUrl.path || "/";
		if (aPathUrl && !aPathUrl.scheme) {
			if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
			return urlGenerate(aPathUrl);
		}
		if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
		if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			aRootUrl.host = aPath;
			return urlGenerate(aRootUrl);
		}
		var joined = aPath.charAt(0) === "/" ? aPath : normalize$1(aRoot.replace(/\/+$/, "") + "/" + aPath);
		if (aRootUrl) {
			aRootUrl.path = joined;
			return urlGenerate(aRootUrl);
		}
		return joined;
	}
	exports.join = join;
	exports.isAbsolute = function(aPath) {
		return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
	};
	function relative(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		aRoot = aRoot.replace(/\/$/, "");
		var level = 0;
		while (aPath.indexOf(aRoot + "/") !== 0) {
			var index = aRoot.lastIndexOf("/");
			if (index < 0) return aPath;
			aRoot = aRoot.slice(0, index);
			if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
			++level;
		}
		return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	var supportsNullProto = function() {
		return !("__proto__" in Object.create(null));
	}();
	function identity$1(s$2) {
		return s$2;
	}
	function toSetString(aStr) {
		if (isProtoString(aStr)) return "$" + aStr;
		return aStr;
	}
	exports.toSetString = supportsNullProto ? identity$1 : toSetString;
	function fromSetString(aStr) {
		if (isProtoString(aStr)) return aStr.slice(1);
		return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity$1 : fromSetString;
	function isProtoString(s$2) {
		if (!s$2) return false;
		var length$1 = s$2.length;
		if (length$1 < 9) return false;
		if (s$2.charCodeAt(length$1 - 1) !== 95 || s$2.charCodeAt(length$1 - 2) !== 95 || s$2.charCodeAt(length$1 - 3) !== 111 || s$2.charCodeAt(length$1 - 4) !== 116 || s$2.charCodeAt(length$1 - 5) !== 111 || s$2.charCodeAt(length$1 - 6) !== 114 || s$2.charCodeAt(length$1 - 7) !== 112 || s$2.charCodeAt(length$1 - 8) !== 95 || s$2.charCodeAt(length$1 - 9) !== 95) return false;
		for (var i$2 = length$1 - 10; i$2 >= 0; i$2--) if (s$2.charCodeAt(i$2) !== 36) return false;
		return true;
	}
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	function strcmp(aStr1, aStr2) {
		if (aStr1 === aStr2) return 0;
		if (aStr1 === null) return 1;
		if (aStr2 === null) return -1;
		if (aStr1 > aStr2) return 1;
		return -1;
	}
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	function parseSourceMapInput(str) {
		return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		sourceURL = sourceURL || "";
		if (sourceRoot) {
			if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") sourceRoot += "/";
			sourceURL = sourceRoot + sourceURL;
		}
		if (sourceMapURL) {
			var parsed = urlParse(sourceMapURL);
			if (!parsed) throw new Error("sourceMapURL could not be parsed");
			if (parsed.path) {
				var index = parsed.path.lastIndexOf("/");
				if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
			}
			sourceURL = join(urlGenerate(parsed), sourceURL);
		}
		return normalize$1(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
}));
var require_array_set = /* @__PURE__ */ __commonJSMin(((exports) => {
	var util$8 = require_util$1();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	function ArraySet$2() {
		this._array = [];
		this._set = hasNativeMap ? /* @__PURE__ */ new Map() : Object.create(null);
	}
	ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		var set = new ArraySet$2();
		for (var i$2 = 0, len$1 = aArray.length; i$2 < len$1; i$2++) set.add(aArray[i$2], aAllowDuplicates);
		return set;
	};
	ArraySet$2.prototype.size = function ArraySet_size() {
		return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		var sStr = hasNativeMap ? aStr : util$8.toSetString(aStr);
		var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		var idx = this._array.length;
		if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
		if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
		else this._set[sStr] = idx;
	};
	ArraySet$2.prototype.has = function ArraySet_has(aStr) {
		if (hasNativeMap) return this._set.has(aStr);
		else {
			var sStr = util$8.toSetString(aStr);
			return has.call(this._set, sStr);
		}
	};
	ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
		if (hasNativeMap) {
			var idx = this._set.get(aStr);
			if (idx >= 0) return idx;
		} else {
			var sStr = util$8.toSetString(aStr);
			if (has.call(this._set, sStr)) return this._set[sStr];
		}
		throw new Error("\"" + aStr + "\" is not in the set.");
	};
	ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
		if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
		throw new Error("No element indexed by " + aIdx);
	};
	ArraySet$2.prototype.toArray = function ArraySet_toArray() {
		return this._array.slice();
	};
	exports.ArraySet = ArraySet$2;
}));
var require_mapping_list = /* @__PURE__ */ __commonJSMin(((exports) => {
	var util$7 = require_util$1();
	function generatedPositionAfter(mappingA, mappingB) {
		var lineA = mappingA.generatedLine;
		var lineB = mappingB.generatedLine;
		var columnA = mappingA.generatedColumn;
		var columnB = mappingB.generatedColumn;
		return lineB > lineA || lineB == lineA && columnB >= columnA || util$7.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	function MappingList$1() {
		this._array = [];
		this._sorted = true;
		this._last = {
			generatedLine: -1,
			generatedColumn: 0
		};
	}
	MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};
	MappingList$1.prototype.add = function MappingList_add(aMapping) {
		if (generatedPositionAfter(this._last, aMapping)) {
			this._last = aMapping;
			this._array.push(aMapping);
		} else {
			this._sorted = false;
			this._array.push(aMapping);
		}
	};
	MappingList$1.prototype.toArray = function MappingList_toArray() {
		if (!this._sorted) {
			this._array.sort(util$7.compareByGeneratedPositionsInflated);
			this._sorted = true;
		}
		return this._array;
	};
	exports.MappingList = MappingList$1;
}));
var require_source_map_generator = /* @__PURE__ */ __commonJSMin(((exports) => {
	var base64VLQ$1 = require_base64_vlq();
	var util$6 = require_util$1();
	var ArraySet$1 = require_array_set().ArraySet;
	var MappingList = require_mapping_list().MappingList;
	function SourceMapGenerator$2(aArgs) {
		if (!aArgs) aArgs = {};
		this._file = util$6.getArg(aArgs, "file", null);
		this._sourceRoot = util$6.getArg(aArgs, "sourceRoot", null);
		this._skipValidation = util$6.getArg(aArgs, "skipValidation", false);
		this._sources = new ArraySet$1();
		this._names = new ArraySet$1();
		this._mappings = new MappingList();
		this._sourcesContents = null;
	}
	SourceMapGenerator$2.prototype._version = 3;
	SourceMapGenerator$2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator$2({
			file: aSourceMapConsumer.file,
			sourceRoot
		});
		aSourceMapConsumer.eachMapping(function(mapping) {
			var newMapping = { generated: {
				line: mapping.generatedLine,
				column: mapping.generatedColumn
			} };
			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) newMapping.source = util$6.relative(sourceRoot, newMapping.source);
				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn
				};
				if (mapping.name != null) newMapping.name = mapping.name;
			}
			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) sourceRelative = util$6.relative(sourceRoot, sourceFile);
			if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) generator.setSourceContent(sourceFile, content);
		});
		return generator;
	};
	SourceMapGenerator$2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
		var generated = util$6.getArg(aArgs, "generated");
		var original = util$6.getArg(aArgs, "original", null);
		var source = util$6.getArg(aArgs, "source", null);
		var name = util$6.getArg(aArgs, "name", null);
		if (!this._skipValidation) this._validateMapping(generated, original, source, name);
		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) this._sources.add(source);
		}
		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) this._names.add(name);
		}
		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source,
			name
		});
	};
	SourceMapGenerator$2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		var source = aSourceFile;
		if (this._sourceRoot != null) source = util$6.relative(this._sourceRoot, source);
		if (aSourceContent != null) {
			if (!this._sourcesContents) this._sourcesContents = Object.create(null);
			this._sourcesContents[util$6.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			delete this._sourcesContents[util$6.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
		}
	};
	SourceMapGenerator$2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		var sourceFile = aSourceFile;
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's \"file\" property. Both were omitted.");
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		if (sourceRoot != null) sourceFile = util$6.relative(sourceRoot, sourceFile);
		var newSources = new ArraySet$1();
		var newNames = new ArraySet$1();
		this._mappings.unsortedForEach(function(mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn
				});
				if (original.source != null) {
					mapping.source = original.source;
					if (aSourceMapPath != null) mapping.source = util$6.join(aSourceMapPath, mapping.source);
					if (sourceRoot != null) mapping.source = util$6.relative(sourceRoot, mapping.source);
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) mapping.name = original.name;
				}
			}
			var source = mapping.source;
			if (source != null && !newSources.has(source)) newSources.add(source);
			var name = mapping.name;
			if (name != null && !newNames.has(name)) newNames.add(name);
		}, this);
		this._sources = newSources;
		this._names = newNames;
		aSourceMapConsumer.sources.forEach(function(sourceFile$1) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile$1);
			if (content != null) {
				if (aSourceMapPath != null) sourceFile$1 = util$6.join(aSourceMapPath, sourceFile$1);
				if (sourceRoot != null) sourceFile$1 = util$6.relative(sourceRoot, sourceFile$1);
				this.setSourceContent(sourceFile$1, content);
			}
		}, this);
	};
	SourceMapGenerator$2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
		if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
		if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
		else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
		else throw new Error("Invalid mapping: " + JSON.stringify({
			generated: aGenerated,
			source: aSource,
			original: aOriginal,
			name: aName
		}));
	};
	SourceMapGenerator$2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
		var previousGeneratedColumn = 0;
		var previousGeneratedLine = 1;
		var previousOriginalColumn = 0;
		var previousOriginalLine = 0;
		var previousName = 0;
		var previousSource = 0;
		var result = "";
		var next;
		var mapping;
		var nameIdx;
		var sourceIdx;
		var mappings = this._mappings.toArray();
		for (var i$2 = 0, len$1 = mappings.length; i$2 < len$1; i$2++) {
			mapping = mappings[i$2];
			next = "";
			if (mapping.generatedLine !== previousGeneratedLine) {
				previousGeneratedColumn = 0;
				while (mapping.generatedLine !== previousGeneratedLine) {
					next += ";";
					previousGeneratedLine++;
				}
			} else if (i$2 > 0) {
				if (!util$6.compareByGeneratedPositionsInflated(mapping, mappings[i$2 - 1])) continue;
				next += ",";
			}
			next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
			previousGeneratedColumn = mapping.generatedColumn;
			if (mapping.source != null) {
				sourceIdx = this._sources.indexOf(mapping.source);
				next += base64VLQ$1.encode(sourceIdx - previousSource);
				previousSource = sourceIdx;
				next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
				previousOriginalLine = mapping.originalLine - 1;
				next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
				previousOriginalColumn = mapping.originalColumn;
				if (mapping.name != null) {
					nameIdx = this._names.indexOf(mapping.name);
					next += base64VLQ$1.encode(nameIdx - previousName);
					previousName = nameIdx;
				}
			}
			result += next;
		}
		return result;
	};
	SourceMapGenerator$2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		return aSources.map(function(source) {
			if (!this._sourcesContents) return null;
			if (aSourceRoot != null) source = util$6.relative(aSourceRoot, source);
			var key = util$6.toSetString(source);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
		}, this);
	};
	SourceMapGenerator$2.prototype.toJSON = function SourceMapGenerator_toJSON() {
		var map = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._file != null) map.file = this._file;
		if (this._sourceRoot != null) map.sourceRoot = this._sourceRoot;
		if (this._sourcesContents) map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
		return map;
	};
	SourceMapGenerator$2.prototype.toString = function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};
	exports.SourceMapGenerator = SourceMapGenerator$2;
}));
var require_binary_search = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		var cmp = aCompare(aNeedle, aHaystack[mid], true);
		if (cmp === 0) return mid;
		else if (cmp > 0) {
			if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
			else return mid;
		} else {
			if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports.LEAST_UPPER_BOUND) return mid;
			else return aLow < 0 ? -1 : aLow;
		}
	}
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		if (aHaystack.length === 0) return -1;
		var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		if (index < 0) return -1;
		while (index - 1 >= 0) {
			if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) break;
			--index;
		}
		return index;
	};
}));
var require_quick_sort = /* @__PURE__ */ __commonJSMin(((exports) => {
	function swap(ary, x$1, y$1) {
		var temp = ary[x$1];
		ary[x$1] = ary[y$1];
		ary[y$1] = temp;
	}
	function randomIntInRange(low, high) {
		return Math.round(low + Math.random() * (high - low));
	}
	function doQuickSort(ary, comparator, p$1, r$1) {
		if (p$1 < r$1) {
			var pivotIndex = randomIntInRange(p$1, r$1);
			var i$2 = p$1 - 1;
			swap(ary, pivotIndex, r$1);
			var pivot = ary[r$1];
			for (var j$1 = p$1; j$1 < r$1; j$1++) if (comparator(ary[j$1], pivot) <= 0) {
				i$2 += 1;
				swap(ary, i$2, j$1);
			}
			swap(ary, i$2 + 1, j$1);
			var q$1 = i$2 + 1;
			doQuickSort(ary, comparator, p$1, q$1 - 1);
			doQuickSort(ary, comparator, q$1 + 1, r$1);
		}
	}
	exports.quickSort = function(ary, comparator) {
		doQuickSort(ary, comparator, 0, ary.length - 1);
	};
}));
var require_source_map_consumer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var util$5 = require_util$1();
	var binarySearch = require_binary_search();
	var ArraySet = require_array_set().ArraySet;
	var base64VLQ = require_base64_vlq();
	var quickSort = require_quick_sort().quickSort;
	function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$5.parseSourceMapInput(aSourceMap);
		return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
		return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	SourceMapConsumer$1.prototype._version = 3;
	SourceMapConsumer$1.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__generatedMappings;
		}
	});
	SourceMapConsumer$1.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__originalMappings;
		}
	});
	SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		var c$1 = aStr.charAt(index);
		return c$1 === ";" || c$1 === ",";
	};
	SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		throw new Error("Subclasses must implement _parseMappings");
	};
	SourceMapConsumer$1.GENERATED_ORDER = 1;
	SourceMapConsumer$1.ORIGINAL_ORDER = 2;
	SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
	SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
		var mappings;
		switch (order) {
			case SourceMapConsumer$1.GENERATED_ORDER:
				mappings = this._generatedMappings;
				break;
			case SourceMapConsumer$1.ORIGINAL_ORDER:
				mappings = this._originalMappings;
				break;
			default: throw new Error("Unknown order of iteration.");
		}
		var sourceRoot = this.sourceRoot;
		mappings.map(function(mapping) {
			var source = mapping.source === null ? null : this._sources.at(mapping.source);
			source = util$5.computeSourceURL(sourceRoot, source, this._sourceMapURL);
			return {
				source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : this._names.at(mapping.name)
			};
		}, this).forEach(aCallback, context);
	};
	SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		var line = util$5.getArg(aArgs, "line");
		var needle = {
			source: util$5.getArg(aArgs, "source"),
			originalLine: line,
			originalColumn: util$5.getArg(aArgs, "column", 0)
		};
		needle.source = this._findSourceIndex(needle.source);
		if (needle.source < 0) return [];
		var mappings = [];
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$5.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (aArgs.column === void 0) {
				var originalLine = mapping.originalLine;
				while (mapping && mapping.originalLine === originalLine) {
					mappings.push({
						line: util$5.getArg(mapping, "generatedLine", null),
						column: util$5.getArg(mapping, "generatedColumn", null),
						lastColumn: util$5.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			} else {
				var originalColumn = mapping.originalColumn;
				while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
					mappings.push({
						line: util$5.getArg(mapping, "generatedLine", null),
						column: util$5.getArg(mapping, "generatedColumn", null),
						lastColumn: util$5.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			}
		}
		return mappings;
	};
	exports.SourceMapConsumer = SourceMapConsumer$1;
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$5.parseSourceMapInput(aSourceMap);
		var version = util$5.getArg(sourceMap, "version");
		var sources = util$5.getArg(sourceMap, "sources");
		var names = util$5.getArg(sourceMap, "names", []);
		var sourceRoot = util$5.getArg(sourceMap, "sourceRoot", null);
		var sourcesContent = util$5.getArg(sourceMap, "sourcesContent", null);
		var mappings = util$5.getArg(sourceMap, "mappings");
		var file = util$5.getArg(sourceMap, "file", null);
		if (version != this._version) throw new Error("Unsupported version: " + version);
		if (sourceRoot) sourceRoot = util$5.normalize(sourceRoot);
		sources = sources.map(String).map(util$5.normalize).map(function(source) {
			return sourceRoot && util$5.isAbsolute(sourceRoot) && util$5.isAbsolute(source) ? util$5.relative(sourceRoot, source) : source;
		});
		this._names = ArraySet.fromArray(names.map(String), true);
		this._sources = ArraySet.fromArray(sources, true);
		this._absoluteSources = this._sources.toArray().map(function(s$2) {
			return util$5.computeSourceURL(sourceRoot, s$2, aSourceMapURL);
		});
		this.sourceRoot = sourceRoot;
		this.sourcesContent = sourcesContent;
		this._mappings = mappings;
		this._sourceMapURL = aSourceMapURL;
		this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$5.relative(this.sourceRoot, relativeSource);
		if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
		var i$2;
		for (i$2 = 0; i$2 < this._absoluteSources.length; ++i$2) if (this._absoluteSources[i$2] == aSource) return i$2;
		return -1;
	};
	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);
		var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function(s$2) {
			return util$5.computeSourceURL(smc.sourceRoot, s$2, aSourceMapURL);
		});
		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = smc.__generatedMappings = [];
		var destOriginalMappings = smc.__originalMappings = [];
		for (var i$2 = 0, length$1 = generatedMappings.length; i$2 < length$1; i$2++) {
			var srcMapping = generatedMappings[i$2];
			var destMapping = new Mapping$1();
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;
			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;
				if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
				destOriginalMappings.push(destMapping);
			}
			destGeneratedMappings.push(destMapping);
		}
		quickSort(smc.__originalMappings, util$5.compareByOriginalPositions);
		return smc;
	};
	BasicSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
		return this._absoluteSources.slice();
	} });
	function Mapping$1() {
		this.generatedLine = 0;
		this.generatedColumn = 0;
		this.source = null;
		this.originalLine = null;
		this.originalColumn = null;
		this.name = null;
	}
	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length$1 = aStr.length;
		var index = 0;
		var cachedSegments = {};
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [];
		var mapping, str, segment, end, value;
		while (index < length$1) if (aStr.charAt(index) === ";") {
			generatedLine++;
			index++;
			previousGeneratedColumn = 0;
		} else if (aStr.charAt(index) === ",") index++;
		else {
			mapping = new Mapping$1();
			mapping.generatedLine = generatedLine;
			for (end = index; end < length$1; end++) if (this._charIsMappingSeparator(aStr, end)) break;
			str = aStr.slice(index, end);
			segment = cachedSegments[str];
			if (segment) index += str.length;
			else {
				segment = [];
				while (index < end) {
					base64VLQ.decode(aStr, index, temp);
					value = temp.value;
					index = temp.rest;
					segment.push(value);
				}
				if (segment.length === 2) throw new Error("Found a source, but no line and column");
				if (segment.length === 3) throw new Error("Found a source and line, but no column");
				cachedSegments[str] = segment;
			}
			mapping.generatedColumn = previousGeneratedColumn + segment[0];
			previousGeneratedColumn = mapping.generatedColumn;
			if (segment.length > 1) {
				mapping.source = previousSource + segment[1];
				previousSource += segment[1];
				mapping.originalLine = previousOriginalLine + segment[2];
				previousOriginalLine = mapping.originalLine;
				mapping.originalLine += 1;
				mapping.originalColumn = previousOriginalColumn + segment[3];
				previousOriginalColumn = mapping.originalColumn;
				if (segment.length > 4) {
					mapping.name = previousName + segment[4];
					previousName += segment[4];
				}
			}
			generatedMappings.push(mapping);
			if (typeof mapping.originalLine === "number") originalMappings.push(mapping);
		}
		quickSort(generatedMappings, util$5.compareByGeneratedPositionsDeflated);
		this.__generatedMappings = generatedMappings;
		quickSort(originalMappings, util$5.compareByOriginalPositions);
		this.__originalMappings = originalMappings;
	};
	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
		if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
		if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
		return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};
	BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
		for (var index = 0; index < this._generatedMappings.length; ++index) {
			var mapping = this._generatedMappings[index];
			if (index + 1 < this._generatedMappings.length) {
				var nextMapping = this._generatedMappings[index + 1];
				if (mapping.generatedLine === nextMapping.generatedLine) {
					mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
					continue;
				}
			}
			mapping.lastGeneratedColumn = Infinity;
		}
	};
	BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$5.getArg(aArgs, "line"),
			generatedColumn: util$5.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$5.compareByGeneratedPositionsDeflated, util$5.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._generatedMappings[index];
			if (mapping.generatedLine === needle.generatedLine) {
				var source = util$5.getArg(mapping, "source", null);
				if (source !== null) {
					source = this._sources.at(source);
					source = util$5.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
				}
				var name = util$5.getArg(mapping, "name", null);
				if (name !== null) name = this._names.at(name);
				return {
					source,
					line: util$5.getArg(mapping, "originalLine", null),
					column: util$5.getArg(mapping, "originalColumn", null),
					name
				};
			}
		}
		return {
			source: null,
			line: null,
			column: null,
			name: null
		};
	};
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
		if (!this.sourcesContent) return false;
		return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
			return sc == null;
		});
	};
	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		if (!this.sourcesContent) return null;
		var index = this._findSourceIndex(aSource);
		if (index >= 0) return this.sourcesContent[index];
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$5.relative(this.sourceRoot, relativeSource);
		var url;
		if (this.sourceRoot != null && (url = util$5.urlParse(this.sourceRoot))) {
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
			if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + relativeSource + "\" is not in the SourceMap.");
	};
	BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
		var source = util$5.getArg(aArgs, "source");
		source = this._findSourceIndex(source);
		if (source < 0) return {
			line: null,
			column: null,
			lastColumn: null
		};
		var needle = {
			source,
			originalLine: util$5.getArg(aArgs, "line"),
			originalColumn: util$5.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$5.compareByOriginalPositions, util$5.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (mapping.source === needle.source) return {
				line: util$5.getArg(mapping, "generatedLine", null),
				column: util$5.getArg(mapping, "generatedColumn", null),
				lastColumn: util$5.getArg(mapping, "lastGeneratedColumn", null)
			};
		}
		return {
			line: null,
			column: null,
			lastColumn: null
		};
	};
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$5.parseSourceMapInput(aSourceMap);
		var version = util$5.getArg(sourceMap, "version");
		var sections = util$5.getArg(sourceMap, "sections");
		if (version != this._version) throw new Error("Unsupported version: " + version);
		this._sources = new ArraySet();
		this._names = new ArraySet();
		var lastOffset = {
			line: -1,
			column: 0
		};
		this._sections = sections.map(function(s$2) {
			if (s$2.url) throw new Error("Support for url field in sections not implemented.");
			var offset$1 = util$5.getArg(s$2, "offset");
			var offsetLine = util$5.getArg(offset$1, "line");
			var offsetColumn = util$5.getArg(offset$1, "column");
			if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
			lastOffset = offset$1;
			return {
				generatedOffset: {
					generatedLine: offsetLine + 1,
					generatedColumn: offsetColumn + 1
				},
				consumer: new SourceMapConsumer$1(util$5.getArg(s$2, "map"), aSourceMapURL)
			};
		});
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
	IndexedSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
		var sources = [];
		for (var i$2 = 0; i$2 < this._sections.length; i$2++) for (var j$1 = 0; j$1 < this._sections[i$2].consumer.sources.length; j$1++) sources.push(this._sections[i$2].consumer.sources[j$1]);
		return sources;
	} });
	IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$5.getArg(aArgs, "line"),
			generatedColumn: util$5.getArg(aArgs, "column")
		};
		var sectionIndex = binarySearch.search(needle, this._sections, function(needle$1, section$1) {
			var cmp = needle$1.generatedLine - section$1.generatedOffset.generatedLine;
			if (cmp) return cmp;
			return needle$1.generatedColumn - section$1.generatedOffset.generatedColumn;
		});
		var section = this._sections[sectionIndex];
		if (!section) return {
			source: null,
			line: null,
			column: null,
			name: null
		};
		return section.consumer.originalPositionFor({
			line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
			column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
			bias: aArgs.bias
		});
	};
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		return this._sections.every(function(s$2) {
			return s$2.consumer.hasContentsOfAllSources();
		});
	};
	IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		for (var i$2 = 0; i$2 < this._sections.length; i$2++) {
			var content = this._sections[i$2].consumer.sourceContentFor(aSource, true);
			if (content) return content;
		}
		if (nullOnMissing) return null;
		else throw new Error("\"" + aSource + "\" is not in the SourceMap.");
	};
	IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		for (var i$2 = 0; i$2 < this._sections.length; i$2++) {
			var section = this._sections[i$2];
			if (section.consumer._findSourceIndex(util$5.getArg(aArgs, "source")) === -1) continue;
			var generatedPosition = section.consumer.generatedPositionFor(aArgs);
			if (generatedPosition) return {
				line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
				column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
			};
		}
		return {
			line: null,
			column: null
		};
	};
	IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		this.__generatedMappings = [];
		this.__originalMappings = [];
		for (var i$2 = 0; i$2 < this._sections.length; i$2++) {
			var section = this._sections[i$2];
			var sectionMappings = section.consumer._generatedMappings;
			for (var j$1 = 0; j$1 < sectionMappings.length; j$1++) {
				var mapping = sectionMappings[j$1];
				var source = section.consumer._sources.at(mapping.source);
				source = util$5.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
				this._sources.add(source);
				source = this._sources.indexOf(source);
				var name = null;
				if (mapping.name) {
					name = section.consumer._names.at(mapping.name);
					this._names.add(name);
					name = this._names.indexOf(name);
				}
				var adjustedMapping = {
					source,
					generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
					generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name
				};
				this.__generatedMappings.push(adjustedMapping);
				if (typeof adjustedMapping.originalLine === "number") this.__originalMappings.push(adjustedMapping);
			}
		}
		quickSort(this.__generatedMappings, util$5.compareByGeneratedPositionsDeflated);
		quickSort(this.__originalMappings, util$5.compareByOriginalPositions);
	};
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}));
var require_source_node = /* @__PURE__ */ __commonJSMin(((exports) => {
	var SourceMapGenerator$1 = require_source_map_generator().SourceMapGenerator;
	var util$4 = require_util$1();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		this.children = [];
		this.sourceContents = {};
		this.line = aLine == null ? null : aLine;
		this.column = aColumn == null ? null : aColumn;
		this.source = aSource == null ? null : aSource;
		this.name = aName == null ? null : aName;
		this[isSourceNode] = true;
		if (aChunks != null) this.add(aChunks);
	}
	SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		var node = new SourceNode();
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function() {
			return getNextLine() + (getNextLine() || "");
			function getNextLine() {
				return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
			}
		};
		var lastGeneratedLine = 1, lastGeneratedColumn = 0;
		var lastMapping = null;
		aSourceMapConsumer.eachMapping(function(mapping) {
			if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) {
				addMappingWithCode(lastMapping, shiftNextLine());
				lastGeneratedLine++;
				lastGeneratedColumn = 0;
			} else {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				var code$1 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
				addMappingWithCode(lastMapping, code$1);
				lastMapping = mapping;
				return;
			}
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) sourceFile = util$4.join(aRelativePath, sourceFile);
				node.setSourceContent(sourceFile, content);
			}
		});
		return node;
		function addMappingWithCode(mapping, code$1) {
			if (mapping === null || mapping.source === void 0) node.add(code$1);
			else {
				var source = aRelativePath ? util$4.join(aRelativePath, mapping.source) : mapping.source;
				node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code$1, mapping.name));
			}
		}
	};
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
		if (Array.isArray(aChunk)) aChunk.forEach(function(chunk$1) {
			this.add(chunk$1);
		}, this);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			if (aChunk) this.children.push(aChunk);
		} else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		if (Array.isArray(aChunk)) for (var i$2 = aChunk.length - 1; i$2 >= 0; i$2--) this.prepend(aChunk[i$2]);
		else if (aChunk[isSourceNode] || typeof aChunk === "string") this.children.unshift(aChunk);
		else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		var chunk$1;
		for (var i$2 = 0, len$1 = this.children.length; i$2 < len$1; i$2++) {
			chunk$1 = this.children[i$2];
			if (chunk$1[isSourceNode]) chunk$1.walk(aFn);
			else if (chunk$1 !== "") aFn(chunk$1, {
				source: this.source,
				line: this.line,
				column: this.column,
				name: this.name
			});
		}
	};
	SourceNode.prototype.join = function SourceNode_join(aSep) {
		var newChildren;
		var i$2;
		var len$1 = this.children.length;
		if (len$1 > 0) {
			newChildren = [];
			for (i$2 = 0; i$2 < len$1 - 1; i$2++) {
				newChildren.push(this.children[i$2]);
				newChildren.push(aSep);
			}
			newChildren.push(this.children[i$2]);
			this.children = newChildren;
		}
		return this;
	};
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		var lastChild = this.children[this.children.length - 1];
		if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
		else if (typeof lastChild === "string") this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
		else this.children.push("".replace(aPattern, aReplacement));
		return this;
	};
	SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		this.sourceContents[util$4.toSetString(aSourceFile)] = aSourceContent;
	};
	SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
		for (var i$2 = 0, len$1 = this.children.length; i$2 < len$1; i$2++) if (this.children[i$2][isSourceNode]) this.children[i$2].walkSourceContents(aFn);
		var sources = Object.keys(this.sourceContents);
		for (var i$2 = 0, len$1 = sources.length; i$2 < len$1; i$2++) aFn(util$4.fromSetString(sources[i$2]), this.sourceContents[sources[i$2]]);
	};
	SourceNode.prototype.toString = function SourceNode_toString() {
		var str = "";
		this.walk(function(chunk$1) {
			str += chunk$1;
		});
		return str;
	};
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		var generated = {
			code: "",
			line: 1,
			column: 0
		};
		var map = new SourceMapGenerator$1(aArgs);
		var sourceMappingActive = false;
		var lastOriginalSource = null;
		var lastOriginalLine = null;
		var lastOriginalColumn = null;
		var lastOriginalName = null;
		this.walk(function(chunk$1, original) {
			generated.code += chunk$1;
			if (original.source !== null && original.line !== null && original.column !== null) {
				if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
				lastOriginalSource = original.source;
				lastOriginalLine = original.line;
				lastOriginalColumn = original.column;
				lastOriginalName = original.name;
				sourceMappingActive = true;
			} else if (sourceMappingActive) {
				map.addMapping({ generated: {
					line: generated.line,
					column: generated.column
				} });
				lastOriginalSource = null;
				sourceMappingActive = false;
			}
			for (var idx = 0, length$1 = chunk$1.length; idx < length$1; idx++) if (chunk$1.charCodeAt(idx) === NEWLINE_CODE) {
				generated.line++;
				generated.column = 0;
				if (idx + 1 === length$1) {
					lastOriginalSource = null;
					sourceMappingActive = false;
				} else if (sourceMappingActive) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
			} else generated.column++;
		});
		this.walkSourceContents(function(sourceFile, sourceContent) {
			map.setSourceContent(sourceFile, sourceContent);
		});
		return {
			code: generated.code,
			map
		};
	};
	exports.SourceNode = SourceNode;
}));
var require_source_map = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
	exports.SourceNode = require_source_node().SourceNode;
}));
var require_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$35 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$7 = tslib_1$35.__importDefault(require_assert());
	var n$3 = tslib_1$35.__importStar(require_main$2()).namedTypes;
	var source_map_1$1 = tslib_1$35.__importDefault(require_source_map());
	var SourceMapConsumer = source_map_1$1.default.SourceMapConsumer;
	var SourceMapGenerator = source_map_1$1.default.SourceMapGenerator;
	var hasOwn$6 = Object.prototype.hasOwnProperty;
	function getLineTerminator() {
		return isBrowser() ? "\n" : require___vite_browser_external().EOL || "\n";
	}
	exports.getLineTerminator = getLineTerminator;
	function isBrowser() {
		return typeof window !== "undefined" && typeof window.document !== "undefined";
	}
	exports.isBrowser = isBrowser;
	function getOption$2(options, key, defaultValue) {
		if (options && hasOwn$6.call(options, key)) return options[key];
		return defaultValue;
	}
	exports.getOption = getOption$2;
	function getUnionOfKeys() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var result = {};
		var argc = args.length;
		for (var i$2 = 0; i$2 < argc; ++i$2) {
			var keys$9 = Object.keys(args[i$2]);
			var keyCount = keys$9.length;
			for (var j$1 = 0; j$1 < keyCount; ++j$1) result[keys$9[j$1]] = true;
		}
		return result;
	}
	exports.getUnionOfKeys = getUnionOfKeys;
	function comparePos(pos1, pos2) {
		return pos1.line - pos2.line || pos1.column - pos2.column;
	}
	exports.comparePos = comparePos;
	function copyPos(pos) {
		return {
			line: pos.line,
			column: pos.column
		};
	}
	exports.copyPos = copyPos;
	function composeSourceMaps(formerMap, latterMap) {
		if (formerMap) {
			if (!latterMap) return formerMap;
		} else return latterMap || null;
		var smcFormer = new SourceMapConsumer(formerMap);
		var smcLatter = new SourceMapConsumer(latterMap);
		var smg = new SourceMapGenerator({
			file: latterMap.file,
			sourceRoot: latterMap.sourceRoot
		});
		var sourcesToContents = {};
		smcLatter.eachMapping(function(mapping) {
			var origPos = smcFormer.originalPositionFor({
				line: mapping.originalLine,
				column: mapping.originalColumn
			});
			var sourceName = origPos.source;
			if (sourceName === null) return;
			smg.addMapping({
				source: sourceName,
				original: copyPos(origPos),
				generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn
				},
				name: mapping.name
			});
			var sourceContent = smcFormer.sourceContentFor(sourceName);
			if (sourceContent && !hasOwn$6.call(sourcesToContents, sourceName)) {
				sourcesToContents[sourceName] = sourceContent;
				smg.setSourceContent(sourceName, sourceContent);
			}
		});
		return smg.toJSON();
	}
	exports.composeSourceMaps = composeSourceMaps;
	function getTrueLoc(node, lines) {
		if (!node.loc) return null;
		var result = {
			start: node.loc.start,
			end: node.loc.end
		};
		function include(node$1) {
			expandLoc(result, node$1.loc);
		}
		if (node.declaration && node.declaration.decorators && isExportDeclaration(node)) node.declaration.decorators.forEach(include);
		if (comparePos(result.start, result.end) < 0) {
			result.start = copyPos(result.start);
			lines.skipSpaces(result.start, false, true);
			if (comparePos(result.start, result.end) < 0) {
				result.end = copyPos(result.end);
				lines.skipSpaces(result.end, true, true);
			}
		}
		if (node.comments) node.comments.forEach(include);
		return result;
	}
	exports.getTrueLoc = getTrueLoc;
	function expandLoc(parentLoc, childLoc) {
		if (parentLoc && childLoc) {
			if (comparePos(childLoc.start, parentLoc.start) < 0) parentLoc.start = childLoc.start;
			if (comparePos(parentLoc.end, childLoc.end) < 0) parentLoc.end = childLoc.end;
		}
	}
	function fixFaultyLocations(node, lines) {
		var loc = node.loc;
		if (loc) {
			if (loc.start.line < 1) loc.start.line = 1;
			if (loc.end.line < 1) loc.end.line = 1;
		}
		if (node.type === "File") {
			loc.start = lines.firstPos();
			loc.end = lines.lastPos();
		}
		fixForLoopHead(node, lines);
		fixTemplateLiteral(node, lines);
		if (loc && node.decorators) node.decorators.forEach(function(decorator) {
			expandLoc(loc, decorator.loc);
		});
		else if (node.declaration && isExportDeclaration(node)) {
			node.declaration.loc = null;
			var decorators = node.declaration.decorators;
			if (decorators) decorators.forEach(function(decorator) {
				expandLoc(loc, decorator.loc);
			});
		} else if (n$3.MethodDefinition && n$3.MethodDefinition.check(node) || n$3.Property.check(node) && (node.method || node.shorthand)) {
			node.value.loc = null;
			if (n$3.FunctionExpression.check(node.value)) node.value.id = null;
		} else if (node.type === "ObjectTypeProperty") {
			var loc_1 = node.loc;
			var end = loc_1 && loc_1.end;
			if (end) {
				end = copyPos(end);
				if (lines.prevPos(end) && lines.charAt(end) === ",") {
					if (end = lines.skipSpaces(end, true, true)) loc_1.end = end;
				}
			}
		}
	}
	exports.fixFaultyLocations = fixFaultyLocations;
	function fixForLoopHead(node, lines) {
		if (node.type !== "ForStatement") return;
		function fix(child) {
			var loc = child && child.loc;
			var start = loc && loc.start;
			var end = loc && copyPos(loc.end);
			while (start && end && comparePos(start, end) < 0) {
				lines.prevPos(end);
				if (lines.charAt(end) === ";") {
					loc.end.line = end.line;
					loc.end.column = end.column;
				} else break;
			}
		}
		fix(node.init);
		fix(node.test);
		fix(node.update);
	}
	function fixTemplateLiteral(node, lines) {
		if (node.type !== "TemplateLiteral") return;
		if (node.quasis.length === 0) return;
		if (node.loc) {
			var afterLeftBackTickPos = copyPos(node.loc.start);
			assert_1$7.default.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
			assert_1$7.default.ok(lines.nextPos(afterLeftBackTickPos));
			var firstQuasi = node.quasis[0];
			if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) firstQuasi.loc.start = afterLeftBackTickPos;
			var rightBackTickPos = copyPos(node.loc.end);
			assert_1$7.default.ok(lines.prevPos(rightBackTickPos));
			assert_1$7.default.strictEqual(lines.charAt(rightBackTickPos), "`");
			var lastQuasi = node.quasis[node.quasis.length - 1];
			if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) lastQuasi.loc.end = rightBackTickPos;
		}
		node.expressions.forEach(function(expr, i$2) {
			var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
			if (lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "{" && lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "$") {
				var quasiBefore = node.quasis[i$2];
				if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) quasiBefore.loc.end = dollarCurlyPos;
			}
			var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
			if (lines.charAt(rightCurlyPos) === "}") {
				assert_1$7.default.ok(lines.nextPos(rightCurlyPos));
				var quasiAfter = node.quasis[i$2 + 1];
				if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) quasiAfter.loc.start = rightCurlyPos;
			}
		});
	}
	function isExportDeclaration(node) {
		if (node) switch (node.type) {
			case "ExportDeclaration":
			case "ExportDefaultDeclaration":
			case "ExportDefaultSpecifier":
			case "DeclareExportDeclaration":
			case "ExportNamedDeclaration":
			case "ExportAllDeclaration": return true;
		}
		return false;
	}
	exports.isExportDeclaration = isExportDeclaration;
	function getParentExportDeclaration(path) {
		var parentNode = path.getParentNode();
		if (path.getName() === "declaration" && isExportDeclaration(parentNode)) return parentNode;
		return null;
	}
	exports.getParentExportDeclaration = getParentExportDeclaration;
	function isTrailingCommaEnabled(options, context) {
		var trailingComma = options.trailingComma;
		if (typeof trailingComma === "object") return !!trailingComma[context];
		return !!trailingComma;
	}
	exports.isTrailingCommaEnabled = isTrailingCommaEnabled;
}));
var require_esprima$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function webpackUniversalModuleDefinition(root, factory) {
		/* istanbul ignore next */
		if (typeof exports === "object" && typeof module === "object") module.exports = factory();
		else if (typeof define === "function" && define.amd) define([], factory);
		else if (typeof exports === "object") exports["esprima"] = factory();
		else root["esprima"] = factory();
	})(exports, function() {
		return (function(modules) {
			var installedModules = {};
			function __webpack_require__(moduleId) {
				/* istanbul ignore if */
				if (installedModules[moduleId]) return installedModules[moduleId].exports;
				var module$1 = installedModules[moduleId] = {
					exports: {},
					id: moduleId,
					loaded: false
				};
				modules[moduleId].call(module$1.exports, module$1, module$1.exports, __webpack_require__);
				module$1.loaded = true;
				return module$1.exports;
			}
			__webpack_require__.m = modules;
			__webpack_require__.c = installedModules;
			__webpack_require__.p = "";
			return __webpack_require__(0);
		})([
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var comment_handler_1 = __webpack_require__(1);
				var jsx_parser_1 = __webpack_require__(3);
				var parser_1$1 = __webpack_require__(8);
				var tokenizer_1 = __webpack_require__(15);
				function parse$7(code$1, options, delegate) {
					var commentHandler = null;
					var proxyDelegate = function(node, metadata) {
						if (delegate) delegate(node, metadata);
						if (commentHandler) commentHandler.visit(node, metadata);
					};
					var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
					var collectComment = false;
					if (options) {
						collectComment = typeof options.comment === "boolean" && options.comment;
						var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
						if (collectComment || attachComment) {
							commentHandler = new comment_handler_1.CommentHandler();
							commentHandler.attach = attachComment;
							options.comment = true;
							parserDelegate = proxyDelegate;
						}
					}
					var isModule = false;
					if (options && typeof options.sourceType === "string") isModule = options.sourceType === "module";
					var parser;
					if (options && typeof options.jsx === "boolean" && options.jsx) parser = new jsx_parser_1.JSXParser(code$1, options, parserDelegate);
					else parser = new parser_1$1.Parser(code$1, options, parserDelegate);
					var ast = isModule ? parser.parseModule() : parser.parseScript();
					if (collectComment && commentHandler) ast.comments = commentHandler.comments;
					if (parser.config.tokens) ast.tokens = parser.tokens;
					if (parser.config.tolerant) ast.errors = parser.errorHandler.errors;
					return ast;
				}
				exports$1.parse = parse$7;
				function parseModule(code$1, options, delegate) {
					var parsingOptions = options || {};
					parsingOptions.sourceType = "module";
					return parse$7(code$1, parsingOptions, delegate);
				}
				exports$1.parseModule = parseModule;
				function parseScript$1(code$1, options, delegate) {
					var parsingOptions = options || {};
					parsingOptions.sourceType = "script";
					return parse$7(code$1, parsingOptions, delegate);
				}
				exports$1.parseScript = parseScript$1;
				function tokenize(code$1, options, delegate) {
					var tokenizer = new tokenizer_1.Tokenizer(code$1, options);
					var tokens = [];
					try {
						while (true) {
							var token = tokenizer.getNextToken();
							if (!token) break;
							if (delegate) token = delegate(token);
							tokens.push(token);
						}
					} catch (e$1) {
						tokenizer.errorHandler.tolerate(e$1);
					}
					if (tokenizer.errorHandler.tolerant) tokens.errors = tokenizer.errors();
					return tokens;
				}
				exports$1.tokenize = tokenize;
				exports$1.Syntax = __webpack_require__(2).Syntax;
				exports$1.version = "4.0.1";
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var syntax_1 = __webpack_require__(2);
				exports$1.CommentHandler = function() {
					function CommentHandler$1() {
						this.attach = false;
						this.comments = [];
						this.stack = [];
						this.leading = [];
						this.trailing = [];
					}
					CommentHandler$1.prototype.insertInnerComments = function(node, metadata) {
						if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
							var innerComments = [];
							for (var i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
								var entry = this.leading[i$2];
								if (metadata.end.offset >= entry.start) {
									innerComments.unshift(entry.comment);
									this.leading.splice(i$2, 1);
									this.trailing.splice(i$2, 1);
								}
							}
							if (innerComments.length) node.innerComments = innerComments;
						}
					};
					CommentHandler$1.prototype.findTrailingComments = function(metadata) {
						var trailingComments = [];
						if (this.trailing.length > 0) {
							for (var i$2 = this.trailing.length - 1; i$2 >= 0; --i$2) {
								var entry_1 = this.trailing[i$2];
								if (entry_1.start >= metadata.end.offset) trailingComments.unshift(entry_1.comment);
							}
							this.trailing.length = 0;
							return trailingComments;
						}
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.node.trailingComments) {
							var firstComment = entry.node.trailingComments[0];
							if (firstComment && firstComment.range[0] >= metadata.end.offset) {
								trailingComments = entry.node.trailingComments;
								delete entry.node.trailingComments;
							}
						}
						return trailingComments;
					};
					CommentHandler$1.prototype.findLeadingComments = function(metadata) {
						var leadingComments = [];
						var target;
						while (this.stack.length > 0) {
							var entry = this.stack[this.stack.length - 1];
							if (entry && entry.start >= metadata.start.offset) {
								target = entry.node;
								this.stack.pop();
							} else break;
						}
						if (target) {
							for (var i$2 = (target.leadingComments ? target.leadingComments.length : 0) - 1; i$2 >= 0; --i$2) {
								var comment = target.leadingComments[i$2];
								if (comment.range[1] <= metadata.start.offset) {
									leadingComments.unshift(comment);
									target.leadingComments.splice(i$2, 1);
								}
							}
							if (target.leadingComments && target.leadingComments.length === 0) delete target.leadingComments;
							return leadingComments;
						}
						for (var i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
							var entry = this.leading[i$2];
							if (entry.start <= metadata.start.offset) {
								leadingComments.unshift(entry.comment);
								this.leading.splice(i$2, 1);
							}
						}
						return leadingComments;
					};
					CommentHandler$1.prototype.visitNode = function(node, metadata) {
						if (node.type === syntax_1.Syntax.Program && node.body.length > 0) return;
						this.insertInnerComments(node, metadata);
						var trailingComments = this.findTrailingComments(metadata);
						var leadingComments = this.findLeadingComments(metadata);
						if (leadingComments.length > 0) node.leadingComments = leadingComments;
						if (trailingComments.length > 0) node.trailingComments = trailingComments;
						this.stack.push({
							node,
							start: metadata.start.offset
						});
					};
					CommentHandler$1.prototype.visitComment = function(node, metadata) {
						var type = node.type[0] === "L" ? "Line" : "Block";
						var comment = {
							type,
							value: node.value
						};
						if (node.range) comment.range = node.range;
						if (node.loc) comment.loc = node.loc;
						this.comments.push(comment);
						if (this.attach) {
							var entry = {
								comment: {
									type,
									value: node.value,
									range: [metadata.start.offset, metadata.end.offset]
								},
								start: metadata.start.offset
							};
							if (node.loc) entry.comment.loc = node.loc;
							node.type = type;
							this.leading.push(entry);
							this.trailing.push(entry);
						}
					};
					CommentHandler$1.prototype.visit = function(node, metadata) {
						if (node.type === "LineComment") this.visitComment(node, metadata);
						else if (node.type === "BlockComment") this.visitComment(node, metadata);
						else if (this.attach) this.visitNode(node, metadata);
					};
					return CommentHandler$1;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.Syntax = {
					AssignmentExpression: "AssignmentExpression",
					AssignmentPattern: "AssignmentPattern",
					ArrayExpression: "ArrayExpression",
					ArrayPattern: "ArrayPattern",
					ArrowFunctionExpression: "ArrowFunctionExpression",
					AwaitExpression: "AwaitExpression",
					BlockStatement: "BlockStatement",
					BinaryExpression: "BinaryExpression",
					BreakStatement: "BreakStatement",
					CallExpression: "CallExpression",
					CatchClause: "CatchClause",
					ClassBody: "ClassBody",
					ClassDeclaration: "ClassDeclaration",
					ClassExpression: "ClassExpression",
					ConditionalExpression: "ConditionalExpression",
					ContinueStatement: "ContinueStatement",
					DoWhileStatement: "DoWhileStatement",
					DebuggerStatement: "DebuggerStatement",
					EmptyStatement: "EmptyStatement",
					ExportAllDeclaration: "ExportAllDeclaration",
					ExportDefaultDeclaration: "ExportDefaultDeclaration",
					ExportNamedDeclaration: "ExportNamedDeclaration",
					ExportSpecifier: "ExportSpecifier",
					ExpressionStatement: "ExpressionStatement",
					ForStatement: "ForStatement",
					ForOfStatement: "ForOfStatement",
					ForInStatement: "ForInStatement",
					FunctionDeclaration: "FunctionDeclaration",
					FunctionExpression: "FunctionExpression",
					Identifier: "Identifier",
					IfStatement: "IfStatement",
					ImportDeclaration: "ImportDeclaration",
					ImportDefaultSpecifier: "ImportDefaultSpecifier",
					ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
					ImportSpecifier: "ImportSpecifier",
					Literal: "Literal",
					LabeledStatement: "LabeledStatement",
					LogicalExpression: "LogicalExpression",
					MemberExpression: "MemberExpression",
					MetaProperty: "MetaProperty",
					MethodDefinition: "MethodDefinition",
					NewExpression: "NewExpression",
					ObjectExpression: "ObjectExpression",
					ObjectPattern: "ObjectPattern",
					Program: "Program",
					Property: "Property",
					RestElement: "RestElement",
					ReturnStatement: "ReturnStatement",
					SequenceExpression: "SequenceExpression",
					SpreadElement: "SpreadElement",
					Super: "Super",
					SwitchCase: "SwitchCase",
					SwitchStatement: "SwitchStatement",
					TaggedTemplateExpression: "TaggedTemplateExpression",
					TemplateElement: "TemplateElement",
					TemplateLiteral: "TemplateLiteral",
					ThisExpression: "ThisExpression",
					ThrowStatement: "ThrowStatement",
					TryStatement: "TryStatement",
					UnaryExpression: "UnaryExpression",
					UpdateExpression: "UpdateExpression",
					VariableDeclaration: "VariableDeclaration",
					VariableDeclarator: "VariableDeclarator",
					WhileStatement: "WhileStatement",
					WithStatement: "WithStatement",
					YieldExpression: "YieldExpression"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				/* istanbul ignore next */
				var __extends$2 = this && this.__extends || (function() {
					var extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$5) {
						d$1.__proto__ = b$5;
					} || function(d$1, b$5) {
						for (var p$1 in b$5) if (b$5.hasOwnProperty(p$1)) d$1[p$1] = b$5[p$1];
					};
					return function(d$1, b$5) {
						extendStatics$2(d$1, b$5);
						function __() {
							this.constructor = d$1;
						}
						d$1.prototype = b$5 === null ? Object.create(b$5) : (__.prototype = b$5.prototype, new __());
					};
				})();
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var character_1 = __webpack_require__(4);
				var JSXNode = __webpack_require__(5);
				var jsx_syntax_1 = __webpack_require__(6);
				var Node = __webpack_require__(7);
				var parser_1$1 = __webpack_require__(8);
				var token_1 = __webpack_require__(13);
				var xhtml_entities_1 = __webpack_require__(14);
				token_1.TokenName[100] = "JSXIdentifier";
				token_1.TokenName[101] = "JSXText";
				function getQualifiedElementName$1(elementName) {
					var qualifiedName;
					switch (elementName.type) {
						case jsx_syntax_1.JSXSyntax.JSXIdentifier:
							qualifiedName = elementName.name;
							break;
						case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
							var ns = elementName;
							qualifiedName = getQualifiedElementName$1(ns.namespace) + ":" + getQualifiedElementName$1(ns.name);
							break;
						case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
							var expr = elementName;
							qualifiedName = getQualifiedElementName$1(expr.object) + "." + getQualifiedElementName$1(expr.property);
							break;
						default: break;
					}
					return qualifiedName;
				}
				exports$1.JSXParser = function(_super) {
					__extends$2(JSXParser$1, _super);
					function JSXParser$1(code$1, options, delegate) {
						return _super.call(this, code$1, options, delegate) || this;
					}
					JSXParser$1.prototype.parsePrimaryExpression = function() {
						return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
					};
					JSXParser$1.prototype.startJSX = function() {
						this.scanner.index = this.startMarker.index;
						this.scanner.lineNumber = this.startMarker.line;
						this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
					};
					JSXParser$1.prototype.finishJSX = function() {
						this.nextToken();
					};
					JSXParser$1.prototype.reenterJSX = function() {
						this.startJSX();
						this.expectJSX("}");
						if (this.config.tokens) this.tokens.pop();
					};
					JSXParser$1.prototype.createJSXNode = function() {
						this.collectComments();
						return {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					};
					JSXParser$1.prototype.createJSXChildNode = function() {
						return {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					};
					JSXParser$1.prototype.scanXHTMLEntity = function(quote$1) {
						var result = "&";
						var valid = true;
						var terminated = false;
						var numeric = false;
						var hex = false;
						while (!this.scanner.eof() && valid && !terminated) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === quote$1) break;
							terminated = ch === ";";
							result += ch;
							++this.scanner.index;
							if (!terminated) switch (result.length) {
								case 2:
									numeric = ch === "#";
									break;
								case 3:
									if (numeric) {
										hex = ch === "x";
										valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
										numeric = numeric && !hex;
									}
									break;
								default:
									valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
									valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
						if (valid && terminated && result.length > 2) {
							var str = result.substr(1, result.length - 2);
							if (numeric && str.length > 1) result = String.fromCharCode(parseInt(str.substr(1), 10));
							else if (hex && str.length > 2) result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
							else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) result = xhtml_entities_1.XHTMLEntities[str];
						}
						return result;
					};
					JSXParser$1.prototype.lexJSX = function() {
						var cp = this.scanner.source.charCodeAt(this.scanner.index);
						if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
							var value = this.scanner.source[this.scanner.index++];
							return {
								type: 7,
								value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: this.scanner.index - 1,
								end: this.scanner.index
							};
						}
						if (cp === 34 || cp === 39) {
							var start = this.scanner.index;
							var quote$1 = this.scanner.source[this.scanner.index++];
							var str = "";
							while (!this.scanner.eof()) {
								var ch = this.scanner.source[this.scanner.index++];
								if (ch === quote$1) break;
								else if (ch === "&") str += this.scanXHTMLEntity(quote$1);
								else str += ch;
							}
							return {
								type: 8,
								value: str,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						if (cp === 46) {
							var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
							var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
							var value = n1 === 46 && n2 === 46 ? "..." : ".";
							var start = this.scanner.index;
							this.scanner.index += value.length;
							return {
								type: 7,
								value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						if (cp === 96) return {
							type: 10,
							value: "",
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
						if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
							var start = this.scanner.index;
							++this.scanner.index;
							while (!this.scanner.eof()) {
								var ch = this.scanner.source.charCodeAt(this.scanner.index);
								if (character_1.Character.isIdentifierPart(ch) && ch !== 92) ++this.scanner.index;
								else if (ch === 45) ++this.scanner.index;
								else break;
							}
							return {
								type: 100,
								value: this.scanner.source.slice(start, this.scanner.index),
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						return this.scanner.lex();
					};
					JSXParser$1.prototype.nextJSXToken = function() {
						this.collectComments();
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
						var token = this.lexJSX();
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.line = this.scanner.lineNumber;
						this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
						if (this.config.tokens) this.tokens.push(this.convertToken(token));
						return token;
					};
					JSXParser$1.prototype.nextJSXText = function() {
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
						var start = this.scanner.index;
						var text = "";
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === "{" || ch === "<") break;
							++this.scanner.index;
							text += ch;
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								++this.scanner.lineNumber;
								if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") ++this.scanner.index;
								this.scanner.lineStart = this.scanner.index;
							}
						}
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.line = this.scanner.lineNumber;
						this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
						var token = {
							type: 101,
							value: text,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start,
							end: this.scanner.index
						};
						if (text.length > 0 && this.config.tokens) this.tokens.push(this.convertToken(token));
						return token;
					};
					JSXParser$1.prototype.peekJSXToken = function() {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.lexJSX();
						this.scanner.restoreState(state);
						return next;
					};
					JSXParser$1.prototype.expectJSX = function(value) {
						var token = this.nextJSXToken();
						if (token.type !== 7 || token.value !== value) this.throwUnexpectedToken(token);
					};
					JSXParser$1.prototype.matchJSX = function(value) {
						var next = this.peekJSXToken();
						return next.type === 7 && next.value === value;
					};
					JSXParser$1.prototype.parseJSXIdentifier = function() {
						var node = this.createJSXNode();
						var token = this.nextJSXToken();
						if (token.type !== 100) this.throwUnexpectedToken(token);
						return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
					};
					JSXParser$1.prototype.parseJSXElementName = function() {
						var node = this.createJSXNode();
						var elementName = this.parseJSXIdentifier();
						if (this.matchJSX(":")) {
							var namespace = elementName;
							this.expectJSX(":");
							var name_1 = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
						} else if (this.matchJSX(".")) while (this.matchJSX(".")) {
							var object = elementName;
							this.expectJSX(".");
							var property$2 = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property$2));
						}
						return elementName;
					};
					JSXParser$1.prototype.parseJSXAttributeName = function() {
						var node = this.createJSXNode();
						var attributeName;
						var identifier = this.parseJSXIdentifier();
						if (this.matchJSX(":")) {
							var namespace = identifier;
							this.expectJSX(":");
							var name_2 = this.parseJSXIdentifier();
							attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
						} else attributeName = identifier;
						return attributeName;
					};
					JSXParser$1.prototype.parseJSXStringLiteralAttribute = function() {
						var node = this.createJSXNode();
						var token = this.nextJSXToken();
						if (token.type !== 8) this.throwUnexpectedToken(token);
						var raw = this.getTokenRaw(token);
						return this.finalize(node, new Node.Literal(token.value, raw));
					};
					JSXParser$1.prototype.parseJSXExpressionAttribute = function() {
						var node = this.createJSXNode();
						this.expectJSX("{");
						this.finishJSX();
						if (this.match("}")) this.tolerateError("JSX attributes must only be assigned a non-empty expression");
						var expression = this.parseAssignmentExpression();
						this.reenterJSX();
						return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
					};
					JSXParser$1.prototype.parseJSXAttributeValue = function() {
						return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
					};
					JSXParser$1.prototype.parseJSXNameValueAttribute = function() {
						var node = this.createJSXNode();
						var name = this.parseJSXAttributeName();
						var value = null;
						if (this.matchJSX("=")) {
							this.expectJSX("=");
							value = this.parseJSXAttributeValue();
						}
						return this.finalize(node, new JSXNode.JSXAttribute(name, value));
					};
					JSXParser$1.prototype.parseJSXSpreadAttribute = function() {
						var node = this.createJSXNode();
						this.expectJSX("{");
						this.expectJSX("...");
						this.finishJSX();
						var argument = this.parseAssignmentExpression();
						this.reenterJSX();
						return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
					};
					JSXParser$1.prototype.parseJSXAttributes = function() {
						var attributes = [];
						while (!this.matchJSX("/") && !this.matchJSX(">")) {
							var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
							attributes.push(attribute);
						}
						return attributes;
					};
					JSXParser$1.prototype.parseJSXOpeningElement = function() {
						var node = this.createJSXNode();
						this.expectJSX("<");
						var name = this.parseJSXElementName();
						var attributes = this.parseJSXAttributes();
						var selfClosing = this.matchJSX("/");
						if (selfClosing) this.expectJSX("/");
						this.expectJSX(">");
						return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
					};
					JSXParser$1.prototype.parseJSXBoundaryElement = function() {
						var node = this.createJSXNode();
						this.expectJSX("<");
						if (this.matchJSX("/")) {
							this.expectJSX("/");
							var name_3 = this.parseJSXElementName();
							this.expectJSX(">");
							return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
						}
						var name = this.parseJSXElementName();
						var attributes = this.parseJSXAttributes();
						var selfClosing = this.matchJSX("/");
						if (selfClosing) this.expectJSX("/");
						this.expectJSX(">");
						return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
					};
					JSXParser$1.prototype.parseJSXEmptyExpression = function() {
						var node = this.createJSXChildNode();
						this.collectComments();
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.line = this.scanner.lineNumber;
						this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
						return this.finalize(node, new JSXNode.JSXEmptyExpression());
					};
					JSXParser$1.prototype.parseJSXExpressionContainer = function() {
						var node = this.createJSXNode();
						this.expectJSX("{");
						var expression;
						if (this.matchJSX("}")) {
							expression = this.parseJSXEmptyExpression();
							this.expectJSX("}");
						} else {
							this.finishJSX();
							expression = this.parseAssignmentExpression();
							this.reenterJSX();
						}
						return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
					};
					JSXParser$1.prototype.parseJSXChildren = function() {
						var children$1 = [];
						while (!this.scanner.eof()) {
							var node = this.createJSXChildNode();
							var token = this.nextJSXText();
							if (token.start < token.end) {
								var raw = this.getTokenRaw(token);
								var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
								children$1.push(child);
							}
							if (this.scanner.source[this.scanner.index] === "{") {
								var container = this.parseJSXExpressionContainer();
								children$1.push(container);
							} else break;
						}
						return children$1;
					};
					JSXParser$1.prototype.parseComplexJSXElement = function(el) {
						var stack = [];
						while (!this.scanner.eof()) {
							el.children = el.children.concat(this.parseJSXChildren());
							var node = this.createJSXChildNode();
							var element = this.parseJSXBoundaryElement();
							if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
								var opening = element;
								if (opening.selfClosing) {
									var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
									el.children.push(child);
								} else {
									stack.push(el);
									el = {
										node,
										opening,
										closing: null,
										children: []
									};
								}
							}
							if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
								el.closing = element;
								var open_1 = getQualifiedElementName$1(el.opening.name);
								if (open_1 !== getQualifiedElementName$1(el.closing.name)) this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
								if (stack.length > 0) {
									var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
									el = stack[stack.length - 1];
									el.children.push(child);
									stack.pop();
								} else break;
							}
						}
						return el;
					};
					JSXParser$1.prototype.parseJSXElement = function() {
						var node = this.createJSXNode();
						var opening = this.parseJSXOpeningElement();
						var children$1 = [];
						var closing = null;
						if (!opening.selfClosing) {
							var el = this.parseComplexJSXElement({
								node,
								opening,
								closing,
								children: children$1
							});
							children$1 = el.children;
							closing = el.closing;
						}
						return this.finalize(node, new JSXNode.JSXElement(opening, children$1, closing));
					};
					JSXParser$1.prototype.parseJSXRoot = function() {
						if (this.config.tokens) this.tokens.pop();
						this.startJSX();
						var element = this.parseJSXElement();
						this.finishJSX();
						return element;
					};
					JSXParser$1.prototype.isStartOfExpression = function() {
						return _super.prototype.isStartOfExpression.call(this) || this.match("<");
					};
					return JSXParser$1;
				}(parser_1$1.Parser);
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var Regex$1 = {
					NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
					NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
				};
				exports$1.Character = {
					fromCodePoint: function(cp) {
						return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
					},
					isWhiteSpace: function(cp) {
						return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [
							5760,
							8192,
							8193,
							8194,
							8195,
							8196,
							8197,
							8198,
							8199,
							8200,
							8201,
							8202,
							8239,
							8287,
							12288,
							65279
						].indexOf(cp) >= 0;
					},
					isLineTerminator: function(cp) {
						return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
					},
					isIdentifierStart: function(cp) {
						return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex$1.NonAsciiIdentifierStart.test(exports$1.Character.fromCodePoint(cp));
					},
					isIdentifierPart: function(cp) {
						return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex$1.NonAsciiIdentifierPart.test(exports$1.Character.fromCodePoint(cp));
					},
					isDecimalDigit: function(cp) {
						return cp >= 48 && cp <= 57;
					},
					isHexDigit: function(cp) {
						return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
					},
					isOctalDigit: function(cp) {
						return cp >= 48 && cp <= 55;
					}
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var jsx_syntax_1 = __webpack_require__(6);
				exports$1.JSXClosingElement = function() {
					function JSXClosingElement$1(name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
						this.name = name;
					}
					return JSXClosingElement$1;
				}();
				exports$1.JSXElement = function() {
					function JSXElement$1(openingElement, children$1, closingElement) {
						this.type = jsx_syntax_1.JSXSyntax.JSXElement;
						this.openingElement = openingElement;
						this.children = children$1;
						this.closingElement = closingElement;
					}
					return JSXElement$1;
				}();
				exports$1.JSXEmptyExpression = function() {
					function JSXEmptyExpression$1() {
						this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
					}
					return JSXEmptyExpression$1;
				}();
				exports$1.JSXExpressionContainer = function() {
					function JSXExpressionContainer$1(expression) {
						this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
						this.expression = expression;
					}
					return JSXExpressionContainer$1;
				}();
				exports$1.JSXIdentifier = function() {
					function JSXIdentifier$1(name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
						this.name = name;
					}
					return JSXIdentifier$1;
				}();
				exports$1.JSXMemberExpression = function() {
					function JSXMemberExpression$1(object, property$2) {
						this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
						this.object = object;
						this.property = property$2;
					}
					return JSXMemberExpression$1;
				}();
				exports$1.JSXAttribute = function() {
					function JSXAttribute$1(name, value) {
						this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
						this.name = name;
						this.value = value;
					}
					return JSXAttribute$1;
				}();
				exports$1.JSXNamespacedName = function() {
					function JSXNamespacedName$1(namespace, name) {
						this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
						this.namespace = namespace;
						this.name = name;
					}
					return JSXNamespacedName$1;
				}();
				exports$1.JSXOpeningElement = function() {
					function JSXOpeningElement$1(name, selfClosing, attributes) {
						this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
						this.name = name;
						this.selfClosing = selfClosing;
						this.attributes = attributes;
					}
					return JSXOpeningElement$1;
				}();
				exports$1.JSXSpreadAttribute = function() {
					function JSXSpreadAttribute$1(argument) {
						this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
						this.argument = argument;
					}
					return JSXSpreadAttribute$1;
				}();
				exports$1.JSXText = function() {
					function JSXText$1(value, raw) {
						this.type = jsx_syntax_1.JSXSyntax.JSXText;
						this.value = value;
						this.raw = raw;
					}
					return JSXText$1;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.JSXSyntax = {
					JSXAttribute: "JSXAttribute",
					JSXClosingElement: "JSXClosingElement",
					JSXElement: "JSXElement",
					JSXEmptyExpression: "JSXEmptyExpression",
					JSXExpressionContainer: "JSXExpressionContainer",
					JSXIdentifier: "JSXIdentifier",
					JSXMemberExpression: "JSXMemberExpression",
					JSXNamespacedName: "JSXNamespacedName",
					JSXOpeningElement: "JSXOpeningElement",
					JSXSpreadAttribute: "JSXSpreadAttribute",
					JSXText: "JSXText"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var syntax_1 = __webpack_require__(2);
				exports$1.ArrayExpression = function() {
					function ArrayExpression$1(elements) {
						this.type = syntax_1.Syntax.ArrayExpression;
						this.elements = elements;
					}
					return ArrayExpression$1;
				}();
				exports$1.ArrayPattern = function() {
					function ArrayPattern$1(elements) {
						this.type = syntax_1.Syntax.ArrayPattern;
						this.elements = elements;
					}
					return ArrayPattern$1;
				}();
				exports$1.ArrowFunctionExpression = function() {
					function ArrowFunctionExpression$1(params, body, expression) {
						this.type = syntax_1.Syntax.ArrowFunctionExpression;
						this.id = null;
						this.params = params;
						this.body = body;
						this.generator = false;
						this.expression = expression;
						this.async = false;
					}
					return ArrowFunctionExpression$1;
				}();
				exports$1.AssignmentExpression = function() {
					function AssignmentExpression$1(operator, left, right) {
						this.type = syntax_1.Syntax.AssignmentExpression;
						this.operator = operator;
						this.left = left;
						this.right = right;
					}
					return AssignmentExpression$1;
				}();
				exports$1.AssignmentPattern = function() {
					function AssignmentPattern$1(left, right) {
						this.type = syntax_1.Syntax.AssignmentPattern;
						this.left = left;
						this.right = right;
					}
					return AssignmentPattern$1;
				}();
				exports$1.AsyncArrowFunctionExpression = function() {
					function AsyncArrowFunctionExpression(params, body, expression) {
						this.type = syntax_1.Syntax.ArrowFunctionExpression;
						this.id = null;
						this.params = params;
						this.body = body;
						this.generator = false;
						this.expression = expression;
						this.async = true;
					}
					return AsyncArrowFunctionExpression;
				}();
				exports$1.AsyncFunctionDeclaration = function() {
					function AsyncFunctionDeclaration$1(id, params, body) {
						this.type = syntax_1.Syntax.FunctionDeclaration;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = false;
						this.expression = false;
						this.async = true;
					}
					return AsyncFunctionDeclaration$1;
				}();
				exports$1.AsyncFunctionExpression = function() {
					function AsyncFunctionExpression(id, params, body) {
						this.type = syntax_1.Syntax.FunctionExpression;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = false;
						this.expression = false;
						this.async = true;
					}
					return AsyncFunctionExpression;
				}();
				exports$1.AwaitExpression = function() {
					function AwaitExpression$1(argument) {
						this.type = syntax_1.Syntax.AwaitExpression;
						this.argument = argument;
					}
					return AwaitExpression$1;
				}();
				exports$1.BinaryExpression = function() {
					function BinaryExpression$1(operator, left, right) {
						this.type = operator === "||" || operator === "&&" ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
						this.operator = operator;
						this.left = left;
						this.right = right;
					}
					return BinaryExpression$1;
				}();
				exports$1.BlockStatement = function() {
					function BlockStatement$1(body) {
						this.type = syntax_1.Syntax.BlockStatement;
						this.body = body;
					}
					return BlockStatement$1;
				}();
				exports$1.BreakStatement = function() {
					function BreakStatement$1(label) {
						this.type = syntax_1.Syntax.BreakStatement;
						this.label = label;
					}
					return BreakStatement$1;
				}();
				exports$1.CallExpression = function() {
					function CallExpression$1(callee, args) {
						this.type = syntax_1.Syntax.CallExpression;
						this.callee = callee;
						this.arguments = args;
					}
					return CallExpression$1;
				}();
				exports$1.CatchClause = function() {
					function CatchClause$1(param, body) {
						this.type = syntax_1.Syntax.CatchClause;
						this.param = param;
						this.body = body;
					}
					return CatchClause$1;
				}();
				exports$1.ClassBody = function() {
					function ClassBody$1(body) {
						this.type = syntax_1.Syntax.ClassBody;
						this.body = body;
					}
					return ClassBody$1;
				}();
				exports$1.ClassDeclaration = function() {
					function ClassDeclaration$1(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassDeclaration;
						this.id = id;
						this.superClass = superClass;
						this.body = body;
					}
					return ClassDeclaration$1;
				}();
				exports$1.ClassExpression = function() {
					function ClassExpression$1(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassExpression;
						this.id = id;
						this.superClass = superClass;
						this.body = body;
					}
					return ClassExpression$1;
				}();
				exports$1.ComputedMemberExpression = function() {
					function ComputedMemberExpression(object, property$2) {
						this.type = syntax_1.Syntax.MemberExpression;
						this.computed = true;
						this.object = object;
						this.property = property$2;
					}
					return ComputedMemberExpression;
				}();
				exports$1.ConditionalExpression = function() {
					function ConditionalExpression$1(test, consequent, alternate) {
						this.type = syntax_1.Syntax.ConditionalExpression;
						this.test = test;
						this.consequent = consequent;
						this.alternate = alternate;
					}
					return ConditionalExpression$1;
				}();
				exports$1.ContinueStatement = function() {
					function ContinueStatement$1(label) {
						this.type = syntax_1.Syntax.ContinueStatement;
						this.label = label;
					}
					return ContinueStatement$1;
				}();
				exports$1.DebuggerStatement = function() {
					function DebuggerStatement$1() {
						this.type = syntax_1.Syntax.DebuggerStatement;
					}
					return DebuggerStatement$1;
				}();
				exports$1.Directive = function() {
					function Directive$1(expression, directive) {
						this.type = syntax_1.Syntax.ExpressionStatement;
						this.expression = expression;
						this.directive = directive;
					}
					return Directive$1;
				}();
				exports$1.DoWhileStatement = function() {
					function DoWhileStatement$1(body, test) {
						this.type = syntax_1.Syntax.DoWhileStatement;
						this.body = body;
						this.test = test;
					}
					return DoWhileStatement$1;
				}();
				exports$1.EmptyStatement = function() {
					function EmptyStatement$1() {
						this.type = syntax_1.Syntax.EmptyStatement;
					}
					return EmptyStatement$1;
				}();
				exports$1.ExportAllDeclaration = function() {
					function ExportAllDeclaration$1(source) {
						this.type = syntax_1.Syntax.ExportAllDeclaration;
						this.source = source;
					}
					return ExportAllDeclaration$1;
				}();
				exports$1.ExportDefaultDeclaration = function() {
					function ExportDefaultDeclaration$1(declaration) {
						this.type = syntax_1.Syntax.ExportDefaultDeclaration;
						this.declaration = declaration;
					}
					return ExportDefaultDeclaration$1;
				}();
				exports$1.ExportNamedDeclaration = function() {
					function ExportNamedDeclaration$1(declaration, specifiers, source) {
						this.type = syntax_1.Syntax.ExportNamedDeclaration;
						this.declaration = declaration;
						this.specifiers = specifiers;
						this.source = source;
					}
					return ExportNamedDeclaration$1;
				}();
				exports$1.ExportSpecifier = function() {
					function ExportSpecifier$1(local, exported) {
						this.type = syntax_1.Syntax.ExportSpecifier;
						this.exported = exported;
						this.local = local;
					}
					return ExportSpecifier$1;
				}();
				exports$1.ExpressionStatement = function() {
					function ExpressionStatement$1(expression) {
						this.type = syntax_1.Syntax.ExpressionStatement;
						this.expression = expression;
					}
					return ExpressionStatement$1;
				}();
				exports$1.ForInStatement = function() {
					function ForInStatement$1(left, right, body) {
						this.type = syntax_1.Syntax.ForInStatement;
						this.left = left;
						this.right = right;
						this.body = body;
						this.each = false;
					}
					return ForInStatement$1;
				}();
				exports$1.ForOfStatement = function() {
					function ForOfStatement$1(left, right, body) {
						this.type = syntax_1.Syntax.ForOfStatement;
						this.left = left;
						this.right = right;
						this.body = body;
					}
					return ForOfStatement$1;
				}();
				exports$1.ForStatement = function() {
					function ForStatement$1(init, test, update, body) {
						this.type = syntax_1.Syntax.ForStatement;
						this.init = init;
						this.test = test;
						this.update = update;
						this.body = body;
					}
					return ForStatement$1;
				}();
				exports$1.FunctionDeclaration = function() {
					function FunctionDeclaration$1(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionDeclaration;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = generator;
						this.expression = false;
						this.async = false;
					}
					return FunctionDeclaration$1;
				}();
				exports$1.FunctionExpression = function() {
					function FunctionExpression$1(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionExpression;
						this.id = id;
						this.params = params;
						this.body = body;
						this.generator = generator;
						this.expression = false;
						this.async = false;
					}
					return FunctionExpression$1;
				}();
				exports$1.Identifier = function() {
					function Identifier$1(name) {
						this.type = syntax_1.Syntax.Identifier;
						this.name = name;
					}
					return Identifier$1;
				}();
				exports$1.IfStatement = function() {
					function IfStatement$1(test, consequent, alternate) {
						this.type = syntax_1.Syntax.IfStatement;
						this.test = test;
						this.consequent = consequent;
						this.alternate = alternate;
					}
					return IfStatement$1;
				}();
				exports$1.ImportDeclaration = function() {
					function ImportDeclaration$1(specifiers, source) {
						this.type = syntax_1.Syntax.ImportDeclaration;
						this.specifiers = specifiers;
						this.source = source;
					}
					return ImportDeclaration$1;
				}();
				exports$1.ImportDefaultSpecifier = function() {
					function ImportDefaultSpecifier$1(local) {
						this.type = syntax_1.Syntax.ImportDefaultSpecifier;
						this.local = local;
					}
					return ImportDefaultSpecifier$1;
				}();
				exports$1.ImportNamespaceSpecifier = function() {
					function ImportNamespaceSpecifier$1(local) {
						this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
						this.local = local;
					}
					return ImportNamespaceSpecifier$1;
				}();
				exports$1.ImportSpecifier = function() {
					function ImportSpecifier$1(local, imported) {
						this.type = syntax_1.Syntax.ImportSpecifier;
						this.local = local;
						this.imported = imported;
					}
					return ImportSpecifier$1;
				}();
				exports$1.LabeledStatement = function() {
					function LabeledStatement$1(label, body) {
						this.type = syntax_1.Syntax.LabeledStatement;
						this.label = label;
						this.body = body;
					}
					return LabeledStatement$1;
				}();
				exports$1.Literal = function() {
					function Literal$1(value, raw) {
						this.type = syntax_1.Syntax.Literal;
						this.value = value;
						this.raw = raw;
					}
					return Literal$1;
				}();
				exports$1.MetaProperty = function() {
					function MetaProperty$1(meta, property$2) {
						this.type = syntax_1.Syntax.MetaProperty;
						this.meta = meta;
						this.property = property$2;
					}
					return MetaProperty$1;
				}();
				exports$1.MethodDefinition = function() {
					function MethodDefinition$1(key, computed, value, kind, isStatic) {
						this.type = syntax_1.Syntax.MethodDefinition;
						this.key = key;
						this.computed = computed;
						this.value = value;
						this.kind = kind;
						this.static = isStatic;
					}
					return MethodDefinition$1;
				}();
				exports$1.Module = function() {
					function Module$1(body) {
						this.type = syntax_1.Syntax.Program;
						this.body = body;
						this.sourceType = "module";
					}
					return Module$1;
				}();
				exports$1.NewExpression = function() {
					function NewExpression$1(callee, args) {
						this.type = syntax_1.Syntax.NewExpression;
						this.callee = callee;
						this.arguments = args;
					}
					return NewExpression$1;
				}();
				exports$1.ObjectExpression = function() {
					function ObjectExpression$1(properties) {
						this.type = syntax_1.Syntax.ObjectExpression;
						this.properties = properties;
					}
					return ObjectExpression$1;
				}();
				exports$1.ObjectPattern = function() {
					function ObjectPattern$1(properties) {
						this.type = syntax_1.Syntax.ObjectPattern;
						this.properties = properties;
					}
					return ObjectPattern$1;
				}();
				exports$1.Property = function() {
					function Property$1(kind, key, computed, value, method$1, shorthand) {
						this.type = syntax_1.Syntax.Property;
						this.key = key;
						this.computed = computed;
						this.value = value;
						this.kind = kind;
						this.method = method$1;
						this.shorthand = shorthand;
					}
					return Property$1;
				}();
				exports$1.RegexLiteral = function() {
					function RegexLiteral$1(value, raw, pattern, flags) {
						this.type = syntax_1.Syntax.Literal;
						this.value = value;
						this.raw = raw;
						this.regex = {
							pattern,
							flags
						};
					}
					return RegexLiteral$1;
				}();
				exports$1.RestElement = function() {
					function RestElement$1(argument) {
						this.type = syntax_1.Syntax.RestElement;
						this.argument = argument;
					}
					return RestElement$1;
				}();
				exports$1.ReturnStatement = function() {
					function ReturnStatement$2(argument) {
						this.type = syntax_1.Syntax.ReturnStatement;
						this.argument = argument;
					}
					return ReturnStatement$2;
				}();
				exports$1.Script = function() {
					function Script$1(body) {
						this.type = syntax_1.Syntax.Program;
						this.body = body;
						this.sourceType = "script";
					}
					return Script$1;
				}();
				exports$1.SequenceExpression = function() {
					function SequenceExpression$1(expressions) {
						this.type = syntax_1.Syntax.SequenceExpression;
						this.expressions = expressions;
					}
					return SequenceExpression$1;
				}();
				exports$1.SpreadElement = function() {
					function SpreadElement$1(argument) {
						this.type = syntax_1.Syntax.SpreadElement;
						this.argument = argument;
					}
					return SpreadElement$1;
				}();
				exports$1.StaticMemberExpression = function() {
					function StaticMemberExpression(object, property$2) {
						this.type = syntax_1.Syntax.MemberExpression;
						this.computed = false;
						this.object = object;
						this.property = property$2;
					}
					return StaticMemberExpression;
				}();
				exports$1.Super = function() {
					function Super$1() {
						this.type = syntax_1.Syntax.Super;
					}
					return Super$1;
				}();
				exports$1.SwitchCase = function() {
					function SwitchCase$1(test, consequent) {
						this.type = syntax_1.Syntax.SwitchCase;
						this.test = test;
						this.consequent = consequent;
					}
					return SwitchCase$1;
				}();
				exports$1.SwitchStatement = function() {
					function SwitchStatement$1(discriminant, cases) {
						this.type = syntax_1.Syntax.SwitchStatement;
						this.discriminant = discriminant;
						this.cases = cases;
					}
					return SwitchStatement$1;
				}();
				exports$1.TaggedTemplateExpression = function() {
					function TaggedTemplateExpression$1(tag, quasi) {
						this.type = syntax_1.Syntax.TaggedTemplateExpression;
						this.tag = tag;
						this.quasi = quasi;
					}
					return TaggedTemplateExpression$1;
				}();
				exports$1.TemplateElement = function() {
					function TemplateElement$1(value, tail) {
						this.type = syntax_1.Syntax.TemplateElement;
						this.value = value;
						this.tail = tail;
					}
					return TemplateElement$1;
				}();
				exports$1.TemplateLiteral = function() {
					function TemplateLiteral$1(quasis, expressions) {
						this.type = syntax_1.Syntax.TemplateLiteral;
						this.quasis = quasis;
						this.expressions = expressions;
					}
					return TemplateLiteral$1;
				}();
				exports$1.ThisExpression = function() {
					function ThisExpression$1() {
						this.type = syntax_1.Syntax.ThisExpression;
					}
					return ThisExpression$1;
				}();
				exports$1.ThrowStatement = function() {
					function ThrowStatement$1(argument) {
						this.type = syntax_1.Syntax.ThrowStatement;
						this.argument = argument;
					}
					return ThrowStatement$1;
				}();
				exports$1.TryStatement = function() {
					function TryStatement$1(block, handler, finalizer) {
						this.type = syntax_1.Syntax.TryStatement;
						this.block = block;
						this.handler = handler;
						this.finalizer = finalizer;
					}
					return TryStatement$1;
				}();
				exports$1.UnaryExpression = function() {
					function UnaryExpression$1(operator, argument) {
						this.type = syntax_1.Syntax.UnaryExpression;
						this.operator = operator;
						this.argument = argument;
						this.prefix = true;
					}
					return UnaryExpression$1;
				}();
				exports$1.UpdateExpression = function() {
					function UpdateExpression$1(operator, argument, prefix) {
						this.type = syntax_1.Syntax.UpdateExpression;
						this.operator = operator;
						this.argument = argument;
						this.prefix = prefix;
					}
					return UpdateExpression$1;
				}();
				exports$1.VariableDeclaration = function() {
					function VariableDeclaration$1(declarations, kind) {
						this.type = syntax_1.Syntax.VariableDeclaration;
						this.declarations = declarations;
						this.kind = kind;
					}
					return VariableDeclaration$1;
				}();
				exports$1.VariableDeclarator = function() {
					function VariableDeclarator$1(id, init) {
						this.type = syntax_1.Syntax.VariableDeclarator;
						this.id = id;
						this.init = init;
					}
					return VariableDeclarator$1;
				}();
				exports$1.WhileStatement = function() {
					function WhileStatement$1(test, body) {
						this.type = syntax_1.Syntax.WhileStatement;
						this.test = test;
						this.body = body;
					}
					return WhileStatement$1;
				}();
				exports$1.WithStatement = function() {
					function WithStatement$1(object, body) {
						this.type = syntax_1.Syntax.WithStatement;
						this.object = object;
						this.body = body;
					}
					return WithStatement$1;
				}();
				exports$1.YieldExpression = function() {
					function YieldExpression$1(argument, delegate) {
						this.type = syntax_1.Syntax.YieldExpression;
						this.argument = argument;
						this.delegate = delegate;
					}
					return YieldExpression$1;
				}();
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var assert_1$8 = __webpack_require__(9);
				var error_handler_1 = __webpack_require__(10);
				var messages_1 = __webpack_require__(11);
				var Node = __webpack_require__(7);
				var scanner_1 = __webpack_require__(12);
				var syntax_1 = __webpack_require__(2);
				var token_1 = __webpack_require__(13);
				var ArrowParameterPlaceHolder$1 = "ArrowParameterPlaceHolder";
				exports$1.Parser = function() {
					function Parser$1(code$1, options, delegate) {
						if (options === void 0) options = {};
						this.config = {
							range: typeof options.range === "boolean" && options.range,
							loc: typeof options.loc === "boolean" && options.loc,
							source: null,
							tokens: typeof options.tokens === "boolean" && options.tokens,
							comment: typeof options.comment === "boolean" && options.comment,
							tolerant: typeof options.tolerant === "boolean" && options.tolerant
						};
						if (this.config.loc && options.source && options.source !== null) this.config.source = String(options.source);
						this.delegate = delegate;
						this.errorHandler = new error_handler_1.ErrorHandler();
						this.errorHandler.tolerant = this.config.tolerant;
						this.scanner = new scanner_1.Scanner(code$1, this.errorHandler);
						this.scanner.trackComment = this.config.comment;
						this.operatorPrecedence = {
							")": 0,
							";": 0,
							",": 0,
							"=": 0,
							"]": 0,
							"||": 1,
							"&&": 2,
							"|": 3,
							"^": 4,
							"&": 5,
							"==": 6,
							"!=": 6,
							"===": 6,
							"!==": 6,
							"<": 7,
							">": 7,
							"<=": 7,
							">=": 7,
							"<<": 8,
							">>": 8,
							">>>": 8,
							"+": 9,
							"-": 9,
							"*": 11,
							"/": 11,
							"%": 11
						};
						this.lookahead = {
							type: 2,
							value: "",
							lineNumber: this.scanner.lineNumber,
							lineStart: 0,
							start: 0,
							end: 0
						};
						this.hasLineTerminator = false;
						this.context = {
							isModule: false,
							await: false,
							allowIn: true,
							allowStrictDirective: true,
							allowYield: true,
							firstCoverInitializedNameError: null,
							isAssignmentTarget: false,
							isBindingElement: false,
							inFunctionBody: false,
							inIteration: false,
							inSwitch: false,
							labelSet: {},
							strict: false
						};
						this.tokens = [];
						this.startMarker = {
							index: 0,
							line: this.scanner.lineNumber,
							column: 0
						};
						this.lastMarker = {
							index: 0,
							line: this.scanner.lineNumber,
							column: 0
						};
						this.nextToken();
						this.lastMarker = {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					}
					Parser$1.prototype.throwError = function(messageFormat) {
						var values$1 = [];
						for (var _i = 1; _i < arguments.length; _i++) values$1[_i - 1] = arguments[_i];
						var args = Array.prototype.slice.call(arguments, 1);
						var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
							assert_1$8.assert(idx < args.length, "Message reference must be in range");
							return args[idx];
						});
						var index = this.lastMarker.index;
						var line = this.lastMarker.line;
						var column = this.lastMarker.column + 1;
						throw this.errorHandler.createError(index, line, column, msg);
					};
					Parser$1.prototype.tolerateError = function(messageFormat) {
						var values$1 = [];
						for (var _i = 1; _i < arguments.length; _i++) values$1[_i - 1] = arguments[_i];
						var args = Array.prototype.slice.call(arguments, 1);
						var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
							assert_1$8.assert(idx < args.length, "Message reference must be in range");
							return args[idx];
						});
						var index = this.lastMarker.index;
						var line = this.scanner.lineNumber;
						var column = this.lastMarker.column + 1;
						this.errorHandler.tolerateError(index, line, column, msg);
					};
					Parser$1.prototype.unexpectedTokenError = function(token, message) {
						var msg = message || messages_1.Messages.UnexpectedToken;
						var value;
						if (token) {
							if (!message) {
								msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
								if (token.type === 4) {
									if (this.scanner.isFutureReservedWord(token.value)) msg = messages_1.Messages.UnexpectedReserved;
									else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) msg = messages_1.Messages.StrictReservedWord;
								}
							}
							value = token.value;
						} else value = "ILLEGAL";
						msg = msg.replace("%0", value);
						if (token && typeof token.lineNumber === "number") {
							var index = token.start;
							var line = token.lineNumber;
							var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
							var column = token.start - lastMarkerLineStart + 1;
							return this.errorHandler.createError(index, line, column, msg);
						} else {
							var index = this.lastMarker.index;
							var line = this.lastMarker.line;
							var column = this.lastMarker.column + 1;
							return this.errorHandler.createError(index, line, column, msg);
						}
					};
					Parser$1.prototype.throwUnexpectedToken = function(token, message) {
						throw this.unexpectedTokenError(token, message);
					};
					Parser$1.prototype.tolerateUnexpectedToken = function(token, message) {
						this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
					};
					Parser$1.prototype.collectComments = function() {
						if (!this.config.comment) this.scanner.scanComments();
						else {
							var comments = this.scanner.scanComments();
							if (comments.length > 0 && this.delegate) for (var i$2 = 0; i$2 < comments.length; ++i$2) {
								var e$1 = comments[i$2];
								var node = void 0;
								node = {
									type: e$1.multiLine ? "BlockComment" : "LineComment",
									value: this.scanner.source.slice(e$1.slice[0], e$1.slice[1])
								};
								if (this.config.range) node.range = e$1.range;
								if (this.config.loc) node.loc = e$1.loc;
								var metadata = {
									start: {
										line: e$1.loc.start.line,
										column: e$1.loc.start.column,
										offset: e$1.range[0]
									},
									end: {
										line: e$1.loc.end.line,
										column: e$1.loc.end.column,
										offset: e$1.range[1]
									}
								};
								this.delegate(node, metadata);
							}
						}
					};
					Parser$1.prototype.getTokenRaw = function(token) {
						return this.scanner.source.slice(token.start, token.end);
					};
					Parser$1.prototype.convertToken = function(token) {
						var t$1 = {
							type: token_1.TokenName[token.type],
							value: this.getTokenRaw(token)
						};
						if (this.config.range) t$1.range = [token.start, token.end];
						if (this.config.loc) t$1.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						};
						if (token.type === 9) t$1.regex = {
							pattern: token.pattern,
							flags: token.flags
						};
						return t$1;
					};
					Parser$1.prototype.nextToken = function() {
						var token = this.lookahead;
						this.lastMarker.index = this.scanner.index;
						this.lastMarker.line = this.scanner.lineNumber;
						this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
						this.collectComments();
						if (this.scanner.index !== this.startMarker.index) {
							this.startMarker.index = this.scanner.index;
							this.startMarker.line = this.scanner.lineNumber;
							this.startMarker.column = this.scanner.index - this.scanner.lineStart;
						}
						var next = this.scanner.lex();
						this.hasLineTerminator = token.lineNumber !== next.lineNumber;
						if (next && this.context.strict && next.type === 3) {
							if (this.scanner.isStrictModeReservedWord(next.value)) next.type = 4;
						}
						this.lookahead = next;
						if (this.config.tokens && next.type !== 2) this.tokens.push(this.convertToken(next));
						return token;
					};
					Parser$1.prototype.nextRegexToken = function() {
						this.collectComments();
						var token = this.scanner.scanRegExp();
						if (this.config.tokens) {
							this.tokens.pop();
							this.tokens.push(this.convertToken(token));
						}
						this.lookahead = token;
						this.nextToken();
						return token;
					};
					Parser$1.prototype.createNode = function() {
						return {
							index: this.startMarker.index,
							line: this.startMarker.line,
							column: this.startMarker.column
						};
					};
					Parser$1.prototype.startNode = function(token, lastLineStart) {
						if (lastLineStart === void 0) lastLineStart = 0;
						var column = token.start - token.lineStart;
						var line = token.lineNumber;
						if (column < 0) {
							column += lastLineStart;
							line--;
						}
						return {
							index: token.start,
							line,
							column
						};
					};
					Parser$1.prototype.finalize = function(marker, node) {
						if (this.config.range) node.range = [marker.index, this.lastMarker.index];
						if (this.config.loc) {
							node.loc = {
								start: {
									line: marker.line,
									column: marker.column
								},
								end: {
									line: this.lastMarker.line,
									column: this.lastMarker.column
								}
							};
							if (this.config.source) node.loc.source = this.config.source;
						}
						if (this.delegate) {
							var metadata = {
								start: {
									line: marker.line,
									column: marker.column,
									offset: marker.index
								},
								end: {
									line: this.lastMarker.line,
									column: this.lastMarker.column,
									offset: this.lastMarker.index
								}
							};
							this.delegate(node, metadata);
						}
						return node;
					};
					Parser$1.prototype.expect = function(value) {
						var token = this.nextToken();
						if (token.type !== 7 || token.value !== value) this.throwUnexpectedToken(token);
					};
					Parser$1.prototype.expectCommaSeparator = function() {
						if (this.config.tolerant) {
							var token = this.lookahead;
							if (token.type === 7 && token.value === ",") this.nextToken();
							else if (token.type === 7 && token.value === ";") {
								this.nextToken();
								this.tolerateUnexpectedToken(token);
							} else this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						} else this.expect(",");
					};
					Parser$1.prototype.expectKeyword = function(keyword) {
						var token = this.nextToken();
						if (token.type !== 4 || token.value !== keyword) this.throwUnexpectedToken(token);
					};
					Parser$1.prototype.match = function(value) {
						return this.lookahead.type === 7 && this.lookahead.value === value;
					};
					Parser$1.prototype.matchKeyword = function(keyword) {
						return this.lookahead.type === 4 && this.lookahead.value === keyword;
					};
					Parser$1.prototype.matchContextualKeyword = function(keyword) {
						return this.lookahead.type === 3 && this.lookahead.value === keyword;
					};
					Parser$1.prototype.matchAssign = function() {
						if (this.lookahead.type !== 7) return false;
						var op = this.lookahead.value;
						return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
					};
					Parser$1.prototype.isolateCoverGrammar = function(parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement;
						var previousIsAssignmentTarget = this.context.isAssignmentTarget;
						var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = true;
						this.context.isAssignmentTarget = true;
						this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						if (this.context.firstCoverInitializedNameError !== null) this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
						this.context.isBindingElement = previousIsBindingElement;
						this.context.isAssignmentTarget = previousIsAssignmentTarget;
						this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
						return result;
					};
					Parser$1.prototype.inheritCoverGrammar = function(parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement;
						var previousIsAssignmentTarget = this.context.isAssignmentTarget;
						var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = true;
						this.context.isAssignmentTarget = true;
						this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
						this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
						this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
						return result;
					};
					Parser$1.prototype.consumeSemicolon = function() {
						if (this.match(";")) this.nextToken();
						else if (!this.hasLineTerminator) {
							if (this.lookahead.type !== 2 && !this.match("}")) this.throwUnexpectedToken(this.lookahead);
							this.lastMarker.index = this.startMarker.index;
							this.lastMarker.line = this.startMarker.line;
							this.lastMarker.column = this.startMarker.column;
						}
					};
					Parser$1.prototype.parsePrimaryExpression = function() {
						var node = this.createNode();
						var expr;
						var token, raw;
						switch (this.lookahead.type) {
							case 3:
								if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") this.tolerateUnexpectedToken(this.lookahead);
								expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
								break;
							case 6:
							case 8:
								if (this.context.strict && this.lookahead.octal) this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case 1:
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
								break;
							case 5:
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								token = this.nextToken();
								raw = this.getTokenRaw(token);
								expr = this.finalize(node, new Node.Literal(null, raw));
								break;
							case 10:
								expr = this.parseTemplateLiteral();
								break;
							case 7:
								switch (this.lookahead.value) {
									case "(":
										this.context.isBindingElement = false;
										expr = this.inheritCoverGrammar(this.parseGroupExpression);
										break;
									case "[":
										expr = this.inheritCoverGrammar(this.parseArrayInitializer);
										break;
									case "{":
										expr = this.inheritCoverGrammar(this.parseObjectInitializer);
										break;
									case "/":
									case "/=":
										this.context.isAssignmentTarget = false;
										this.context.isBindingElement = false;
										this.scanner.index = this.startMarker.index;
										token = this.nextRegexToken();
										raw = this.getTokenRaw(token);
										expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
										break;
									default: expr = this.throwUnexpectedToken(this.nextToken());
								}
								break;
							case 4:
								if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) expr = this.parseIdentifierName();
								else if (!this.context.strict && this.matchKeyword("let")) expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
								else {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									if (this.matchKeyword("function")) expr = this.parseFunctionExpression();
									else if (this.matchKeyword("this")) {
										this.nextToken();
										expr = this.finalize(node, new Node.ThisExpression());
									} else if (this.matchKeyword("class")) expr = this.parseClassExpression();
									else expr = this.throwUnexpectedToken(this.nextToken());
								}
								break;
							default: expr = this.throwUnexpectedToken(this.nextToken());
						}
						return expr;
					};
					Parser$1.prototype.parseSpreadElement = function() {
						var node = this.createNode();
						this.expect("...");
						var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
						return this.finalize(node, new Node.SpreadElement(arg));
					};
					Parser$1.prototype.parseArrayInitializer = function() {
						var node = this.createNode();
						var elements = [];
						this.expect("[");
						while (!this.match("]")) if (this.match(",")) {
							this.nextToken();
							elements.push(null);
						} else if (this.match("...")) {
							var element = this.parseSpreadElement();
							if (!this.match("]")) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								this.expect(",");
							}
							elements.push(element);
						} else {
							elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
							if (!this.match("]")) this.expect(",");
						}
						this.expect("]");
						return this.finalize(node, new Node.ArrayExpression(elements));
					};
					Parser$1.prototype.parsePropertyMethod = function(params) {
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var previousStrict = this.context.strict;
						var previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = params.simple;
						var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
						if (this.context.strict && params.firstRestricted) this.tolerateUnexpectedToken(params.firstRestricted, params.message);
						if (this.context.strict && params.stricted) this.tolerateUnexpectedToken(params.stricted, params.message);
						this.context.strict = previousStrict;
						this.context.allowStrictDirective = previousAllowStrictDirective;
						return body;
					};
					Parser$1.prototype.parsePropertyMethodFunction = function() {
						var isGenerator = false;
						var node = this.createNode();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var params = this.parseFormalParameters();
						var method$1 = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, params.params, method$1, isGenerator));
					};
					Parser$1.prototype.parsePropertyMethodAsyncFunction = function() {
						var node = this.createNode();
						var previousAllowYield = this.context.allowYield;
						var previousAwait = this.context.await;
						this.context.allowYield = false;
						this.context.await = true;
						var params = this.parseFormalParameters();
						var method$1 = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						this.context.await = previousAwait;
						return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method$1));
					};
					Parser$1.prototype.parseObjectPropertyKey = function() {
						var node = this.createNode();
						var token = this.nextToken();
						var key;
						switch (token.type) {
							case 8:
							case 6:
								if (this.context.strict && token.octal) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
								var raw = this.getTokenRaw(token);
								key = this.finalize(node, new Node.Literal(token.value, raw));
								break;
							case 3:
							case 1:
							case 5:
							case 4:
								key = this.finalize(node, new Node.Identifier(token.value));
								break;
							case 7:
								if (token.value === "[") {
									key = this.isolateCoverGrammar(this.parseAssignmentExpression);
									this.expect("]");
								} else key = this.throwUnexpectedToken(token);
								break;
							default: key = this.throwUnexpectedToken(token);
						}
						return key;
					};
					Parser$1.prototype.isPropertyKey = function(key, value) {
						return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
					};
					Parser$1.prototype.parseObjectProperty = function(hasProto) {
						var node = this.createNode();
						var token = this.lookahead;
						var kind;
						var key = null;
						var value = null;
						var computed = false;
						var method$1 = false;
						var shorthand = false;
						var isAsync$1 = false;
						if (token.type === 3) {
							var id = token.value;
							this.nextToken();
							computed = this.match("[");
							isAsync$1 = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
							key = isAsync$1 ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
						} else if (this.match("*")) this.nextToken();
						else {
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
						}
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						if (token.type === 3 && !isAsync$1 && token.value === "get" && lookaheadPropertyKey) {
							kind = "get";
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							this.context.allowYield = false;
							value = this.parseGetterMethod();
						} else if (token.type === 3 && !isAsync$1 && token.value === "set" && lookaheadPropertyKey) {
							kind = "set";
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							value = this.parseSetterMethod();
						} else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
							kind = "init";
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							value = this.parseGeneratorMethod();
							method$1 = true;
						} else {
							if (!key) this.throwUnexpectedToken(this.lookahead);
							kind = "init";
							if (this.match(":") && !isAsync$1) {
								if (!computed && this.isPropertyKey(key, "__proto__")) {
									if (hasProto.value) this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
									hasProto.value = true;
								}
								this.nextToken();
								value = this.inheritCoverGrammar(this.parseAssignmentExpression);
							} else if (this.match("(")) {
								value = isAsync$1 ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
								method$1 = true;
							} else if (token.type === 3) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match("=")) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else this.throwUnexpectedToken(this.nextToken());
						}
						return this.finalize(node, new Node.Property(kind, key, computed, value, method$1, shorthand));
					};
					Parser$1.prototype.parseObjectInitializer = function() {
						var node = this.createNode();
						this.expect("{");
						var properties = [];
						var hasProto = { value: false };
						while (!this.match("}")) {
							properties.push(this.parseObjectProperty(hasProto));
							if (!this.match("}")) this.expectCommaSeparator();
						}
						this.expect("}");
						return this.finalize(node, new Node.ObjectExpression(properties));
					};
					Parser$1.prototype.parseTemplateHead = function() {
						assert_1$8.assert(this.lookahead.head, "Template literal must start with a template head");
						var node = this.createNode();
						var token = this.nextToken();
						var raw = token.value;
						var cooked = token.cooked;
						return this.finalize(node, new Node.TemplateElement({
							raw,
							cooked
						}, token.tail));
					};
					Parser$1.prototype.parseTemplateElement = function() {
						if (this.lookahead.type !== 10) this.throwUnexpectedToken();
						var node = this.createNode();
						var token = this.nextToken();
						var raw = token.value;
						var cooked = token.cooked;
						return this.finalize(node, new Node.TemplateElement({
							raw,
							cooked
						}, token.tail));
					};
					Parser$1.prototype.parseTemplateLiteral = function() {
						var node = this.createNode();
						var expressions = [];
						var quasis = [];
						var quasi = this.parseTemplateHead();
						quasis.push(quasi);
						while (!quasi.tail) {
							expressions.push(this.parseExpression());
							quasi = this.parseTemplateElement();
							quasis.push(quasi);
						}
						return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
					};
					Parser$1.prototype.reinterpretExpressionAsPattern = function(expr) {
						switch (expr.type) {
							case syntax_1.Syntax.Identifier:
							case syntax_1.Syntax.MemberExpression:
							case syntax_1.Syntax.RestElement:
							case syntax_1.Syntax.AssignmentPattern: break;
							case syntax_1.Syntax.SpreadElement:
								expr.type = syntax_1.Syntax.RestElement;
								this.reinterpretExpressionAsPattern(expr.argument);
								break;
							case syntax_1.Syntax.ArrayExpression:
								expr.type = syntax_1.Syntax.ArrayPattern;
								for (var i$2 = 0; i$2 < expr.elements.length; i$2++) if (expr.elements[i$2] !== null) this.reinterpretExpressionAsPattern(expr.elements[i$2]);
								break;
							case syntax_1.Syntax.ObjectExpression:
								expr.type = syntax_1.Syntax.ObjectPattern;
								for (var i$2 = 0; i$2 < expr.properties.length; i$2++) this.reinterpretExpressionAsPattern(expr.properties[i$2].value);
								break;
							case syntax_1.Syntax.AssignmentExpression:
								expr.type = syntax_1.Syntax.AssignmentPattern;
								delete expr.operator;
								this.reinterpretExpressionAsPattern(expr.left);
								break;
							default: break;
						}
					};
					Parser$1.prototype.parseGroupExpression = function() {
						var expr;
						this.expect("(");
						if (this.match(")")) {
							this.nextToken();
							if (!this.match("=>")) this.expect("=>");
							expr = {
								type: ArrowParameterPlaceHolder$1,
								params: [],
								async: false
							};
						} else {
							var startToken = this.lookahead;
							var params = [];
							if (this.match("...")) {
								expr = this.parseRestElement(params);
								this.expect(")");
								if (!this.match("=>")) this.expect("=>");
								expr = {
									type: ArrowParameterPlaceHolder$1,
									params: [expr],
									async: false
								};
							} else {
								var arrow = false;
								this.context.isBindingElement = true;
								expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
								if (this.match(",")) {
									var expressions = [];
									this.context.isAssignmentTarget = false;
									expressions.push(expr);
									while (this.lookahead.type !== 2) {
										if (!this.match(",")) break;
										this.nextToken();
										if (this.match(")")) {
											this.nextToken();
											for (var i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
											arrow = true;
											expr = {
												type: ArrowParameterPlaceHolder$1,
												params: expressions,
												async: false
											};
										} else if (this.match("...")) {
											if (!this.context.isBindingElement) this.throwUnexpectedToken(this.lookahead);
											expressions.push(this.parseRestElement(params));
											this.expect(")");
											if (!this.match("=>")) this.expect("=>");
											this.context.isBindingElement = false;
											for (var i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
											arrow = true;
											expr = {
												type: ArrowParameterPlaceHolder$1,
												params: expressions,
												async: false
											};
										} else expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
										if (arrow) break;
									}
									if (!arrow) expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
								}
								if (!arrow) {
									this.expect(")");
									if (this.match("=>")) {
										if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
											arrow = true;
											expr = {
												type: ArrowParameterPlaceHolder$1,
												params: [expr],
												async: false
											};
										}
										if (!arrow) {
											if (!this.context.isBindingElement) this.throwUnexpectedToken(this.lookahead);
											if (expr.type === syntax_1.Syntax.SequenceExpression) for (var i$2 = 0; i$2 < expr.expressions.length; i$2++) this.reinterpretExpressionAsPattern(expr.expressions[i$2]);
											else this.reinterpretExpressionAsPattern(expr);
											expr = {
												type: ArrowParameterPlaceHolder$1,
												params: expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr],
												async: false
											};
										}
									}
									this.context.isBindingElement = false;
								}
							}
						}
						return expr;
					};
					Parser$1.prototype.parseArguments = function() {
						this.expect("(");
						var args = [];
						if (!this.match(")")) while (true) {
							var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							args.push(expr);
							if (this.match(")")) break;
							this.expectCommaSeparator();
							if (this.match(")")) break;
						}
						this.expect(")");
						return args;
					};
					Parser$1.prototype.isIdentifierName = function(token) {
						return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
					};
					Parser$1.prototype.parseIdentifierName = function() {
						var node = this.createNode();
						var token = this.nextToken();
						if (!this.isIdentifierName(token)) this.throwUnexpectedToken(token);
						return this.finalize(node, new Node.Identifier(token.value));
					};
					Parser$1.prototype.parseNewExpression = function() {
						var node = this.createNode();
						var id = this.parseIdentifierName();
						assert_1$8.assert(id.name === "new", "New expression must start with `new`");
						var expr;
						if (this.match(".")) {
							this.nextToken();
							if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
								var property$2 = this.parseIdentifierName();
								expr = new Node.MetaProperty(id, property$2);
							} else this.throwUnexpectedToken(this.lookahead);
						} else {
							var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
							var args = this.match("(") ? this.parseArguments() : [];
							expr = new Node.NewExpression(callee, args);
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						}
						return this.finalize(node, expr);
					};
					Parser$1.prototype.parseAsyncArgument = function() {
						var arg = this.parseAssignmentExpression();
						this.context.firstCoverInitializedNameError = null;
						return arg;
					};
					Parser$1.prototype.parseAsyncArguments = function() {
						this.expect("(");
						var args = [];
						if (!this.match(")")) while (true) {
							var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							args.push(expr);
							if (this.match(")")) break;
							this.expectCommaSeparator();
							if (this.match(")")) break;
						}
						this.expect(")");
						return args;
					};
					Parser$1.prototype.parseLeftHandSideExpressionAllowCall = function() {
						var startToken = this.lookahead;
						var maybeAsync = this.matchContextualKeyword("async");
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var expr;
						if (this.matchKeyword("super") && this.context.inFunctionBody) {
							expr = this.createNode();
							this.nextToken();
							expr = this.finalize(expr, new Node.Super());
							if (!this.match("(") && !this.match(".") && !this.match("[")) this.throwUnexpectedToken(this.lookahead);
						} else expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
						while (true) if (this.match(".")) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect(".");
							var property$2 = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property$2));
						} else if (this.match("(")) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = false;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							if (asyncArrow && this.match("=>")) {
								for (var i$2 = 0; i$2 < args.length; ++i$2) this.reinterpretExpressionAsPattern(args[i$2]);
								expr = {
									type: ArrowParameterPlaceHolder$1,
									params: args,
									async: true
								};
							}
						} else if (this.match("[")) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect("[");
							var property$2 = this.isolateCoverGrammar(this.parseExpression);
							this.expect("]");
							expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property$2));
						} else if (this.lookahead.type === 10 && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else break;
						this.context.allowIn = previousAllowIn;
						return expr;
					};
					Parser$1.prototype.parseSuper = function() {
						var node = this.createNode();
						this.expectKeyword("super");
						if (!this.match("[") && !this.match(".")) this.throwUnexpectedToken(this.lookahead);
						return this.finalize(node, new Node.Super());
					};
					Parser$1.prototype.parseLeftHandSideExpression = function() {
						assert_1$8.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
						var node = this.startNode(this.lookahead);
						var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
						while (true) if (this.match("[")) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect("[");
							var property$2 = this.isolateCoverGrammar(this.parseExpression);
							this.expect("]");
							expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property$2));
						} else if (this.match(".")) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect(".");
							var property$2 = this.parseIdentifierName();
							expr = this.finalize(node, new Node.StaticMemberExpression(expr, property$2));
						} else if (this.lookahead.type === 10 && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
						} else break;
						return expr;
					};
					Parser$1.prototype.parseUpdateExpression = function() {
						var expr;
						var startToken = this.lookahead;
						if (this.match("++") || this.match("--")) {
							var node = this.startNode(startToken);
							var token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression);
							if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) this.tolerateError(messages_1.Messages.StrictLHSPrefix);
							if (!this.context.isAssignmentTarget) this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
							var prefix = true;
							expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						} else {
							expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
							if (!this.hasLineTerminator && this.lookahead.type === 7) {
								if (this.match("++") || this.match("--")) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									if (!this.context.isAssignmentTarget) this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
						}
						return expr;
					};
					Parser$1.prototype.parseAwaitExpression = function() {
						var node = this.createNode();
						this.nextToken();
						var argument = this.parseUnaryExpression();
						return this.finalize(node, new Node.AwaitExpression(argument));
					};
					Parser$1.prototype.parseUnaryExpression = function() {
						var expr;
						if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
							var node = this.startNode(this.lookahead);
							var token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression);
							expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
							if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) this.tolerateError(messages_1.Messages.StrictDelete);
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						} else if (this.context.await && this.matchContextualKeyword("await")) expr = this.parseAwaitExpression();
						else expr = this.parseUpdateExpression();
						return expr;
					};
					Parser$1.prototype.parseExponentiationExpression = function() {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
							this.nextToken();
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var left = expr;
							var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
							expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
						}
						return expr;
					};
					Parser$1.prototype.binaryPrecedence = function(token) {
						var op = token.value;
						var precedence;
						if (token.type === 7) precedence = this.operatorPrecedence[op] || 0;
						else if (token.type === 4) precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
						else precedence = 0;
						return precedence;
					};
					Parser$1.prototype.parseBinaryExpression = function() {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
						var token = this.lookahead;
						var prec = this.binaryPrecedence(token);
						if (prec > 0) {
							this.nextToken();
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var markers = [startToken, this.lookahead];
							var left = expr;
							var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
							var stack = [
								left,
								token.value,
								right
							];
							var precedences = [prec];
							while (true) {
								prec = this.binaryPrecedence(this.lookahead);
								if (prec <= 0) break;
								while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
									right = stack.pop();
									var operator = stack.pop();
									precedences.pop();
									left = stack.pop();
									markers.pop();
									var node = this.startNode(markers[markers.length - 1]);
									stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
								}
								stack.push(this.nextToken().value);
								precedences.push(prec);
								markers.push(this.lookahead);
								stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
							}
							var i$2 = stack.length - 1;
							expr = stack[i$2];
							var lastMarker = markers.pop();
							while (i$2 > 1) {
								var marker = markers.pop();
								var lastLineStart = lastMarker && lastMarker.lineStart;
								var node = this.startNode(marker, lastLineStart);
								var operator = stack[i$2 - 1];
								expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i$2 - 2], expr));
								i$2 -= 2;
								lastMarker = marker;
							}
						}
						return expr;
					};
					Parser$1.prototype.parseConditionalExpression = function() {
						var startToken = this.lookahead;
						var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
						if (this.match("?")) {
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = true;
							var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							this.expect(":");
							var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
							expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
						}
						return expr;
					};
					Parser$1.prototype.checkPatternParam = function(options, param) {
						switch (param.type) {
							case syntax_1.Syntax.Identifier:
								this.validateParam(options, param, param.name);
								break;
							case syntax_1.Syntax.RestElement:
								this.checkPatternParam(options, param.argument);
								break;
							case syntax_1.Syntax.AssignmentPattern:
								this.checkPatternParam(options, param.left);
								break;
							case syntax_1.Syntax.ArrayPattern:
								for (var i$2 = 0; i$2 < param.elements.length; i$2++) if (param.elements[i$2] !== null) this.checkPatternParam(options, param.elements[i$2]);
								break;
							case syntax_1.Syntax.ObjectPattern:
								for (var i$2 = 0; i$2 < param.properties.length; i$2++) this.checkPatternParam(options, param.properties[i$2].value);
								break;
							default: break;
						}
						options.simple = options.simple && param instanceof Node.Identifier;
					};
					Parser$1.prototype.reinterpretAsCoverFormalsList = function(expr) {
						var params = [expr];
						var options;
						var asyncArrow = false;
						switch (expr.type) {
							case syntax_1.Syntax.Identifier: break;
							case ArrowParameterPlaceHolder$1:
								params = expr.params;
								asyncArrow = expr.async;
								break;
							default: return null;
						}
						options = {
							simple: true,
							paramSet: {}
						};
						for (var i$2 = 0; i$2 < params.length; ++i$2) {
							var param = params[i$2];
							if (param.type === syntax_1.Syntax.AssignmentPattern) {
								if (param.right.type === syntax_1.Syntax.YieldExpression) {
									if (param.right.argument) this.throwUnexpectedToken(this.lookahead);
									param.right.type = syntax_1.Syntax.Identifier;
									param.right.name = "yield";
									delete param.right.argument;
									delete param.right.delegate;
								}
							} else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") this.throwUnexpectedToken(this.lookahead);
							this.checkPatternParam(options, param);
							params[i$2] = param;
						}
						if (this.context.strict || !this.context.allowYield) for (var i$2 = 0; i$2 < params.length; ++i$2) {
							var param = params[i$2];
							if (param.type === syntax_1.Syntax.YieldExpression) this.throwUnexpectedToken(this.lookahead);
						}
						if (options.message === messages_1.Messages.StrictParamDupe) {
							var token = this.context.strict ? options.stricted : options.firstRestricted;
							this.throwUnexpectedToken(token, options.message);
						}
						return {
							simple: options.simple,
							params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					};
					Parser$1.prototype.parseAssignmentExpression = function() {
						var expr;
						if (!this.context.allowYield && this.matchKeyword("yield")) expr = this.parseYieldExpression();
						else {
							var startToken = this.lookahead;
							var token = startToken;
							expr = this.parseConditionalExpression();
							if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
								if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
									var arg = this.parsePrimaryExpression();
									this.reinterpretExpressionAsPattern(arg);
									expr = {
										type: ArrowParameterPlaceHolder$1,
										params: [arg],
										async: true
									};
								}
							}
							if (expr.type === ArrowParameterPlaceHolder$1 || this.match("=>")) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								var isAsync$1 = expr.async;
								var list = this.reinterpretAsCoverFormalsList(expr);
								if (list) {
									if (this.hasLineTerminator) this.tolerateUnexpectedToken(this.lookahead);
									this.context.firstCoverInitializedNameError = null;
									var previousStrict = this.context.strict;
									var previousAllowStrictDirective = this.context.allowStrictDirective;
									this.context.allowStrictDirective = list.simple;
									var previousAllowYield = this.context.allowYield;
									var previousAwait = this.context.await;
									this.context.allowYield = true;
									this.context.await = isAsync$1;
									var node = this.startNode(startToken);
									this.expect("=>");
									var body = void 0;
									if (this.match("{")) {
										var previousAllowIn = this.context.allowIn;
										this.context.allowIn = true;
										body = this.parseFunctionSourceElements();
										this.context.allowIn = previousAllowIn;
									} else body = this.isolateCoverGrammar(this.parseAssignmentExpression);
									var expression = body.type !== syntax_1.Syntax.BlockStatement;
									if (this.context.strict && list.firstRestricted) this.throwUnexpectedToken(list.firstRestricted, list.message);
									if (this.context.strict && list.stricted) this.tolerateUnexpectedToken(list.stricted, list.message);
									expr = isAsync$1 ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
									this.context.strict = previousStrict;
									this.context.allowStrictDirective = previousAllowStrictDirective;
									this.context.allowYield = previousAllowYield;
									this.context.await = previousAwait;
								}
							} else if (this.matchAssign()) {
								if (!this.context.isAssignmentTarget) this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
								if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									if (this.scanner.isRestrictedWord(id.name)) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
									if (this.scanner.isStrictModeReservedWord(id.name)) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
								}
								if (!this.match("=")) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
								} else this.reinterpretExpressionAsPattern(expr);
								token = this.nextToken();
								var operator = token.value;
								var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
								this.context.firstCoverInitializedNameError = null;
							}
						}
						return expr;
					};
					Parser$1.prototype.parseExpression = function() {
						var startToken = this.lookahead;
						var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
						if (this.match(",")) {
							var expressions = [];
							expressions.push(expr);
							while (this.lookahead.type !== 2) {
								if (!this.match(",")) break;
								this.nextToken();
								expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
							}
							expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
						}
						return expr;
					};
					Parser$1.prototype.parseStatementListItem = function() {
						var statement;
						this.context.isAssignmentTarget = true;
						this.context.isBindingElement = true;
						if (this.lookahead.type === 4) switch (this.lookahead.value) {
							case "export":
								if (!this.context.isModule) this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
								statement = this.parseExportDeclaration();
								break;
							case "import":
								if (!this.context.isModule) this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
								statement = this.parseImportDeclaration();
								break;
							case "const":
								statement = this.parseLexicalDeclaration({ inFor: false });
								break;
							case "function":
								statement = this.parseFunctionDeclaration();
								break;
							case "class":
								statement = this.parseClassDeclaration();
								break;
							case "let":
								statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
								break;
							default:
								statement = this.parseStatement();
								break;
						}
						else statement = this.parseStatement();
						return statement;
					};
					Parser$1.prototype.parseBlock = function() {
						var node = this.createNode();
						this.expect("{");
						var block = [];
						while (true) {
							if (this.match("}")) break;
							block.push(this.parseStatementListItem());
						}
						this.expect("}");
						return this.finalize(node, new Node.BlockStatement(block));
					};
					Parser$1.prototype.parseLexicalBinding = function(kind, options) {
						var node = this.createNode();
						var id = this.parsePattern([], kind);
						if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(id.name)) this.tolerateError(messages_1.Messages.StrictVarName);
						}
						var init = null;
						if (kind === "const") {
							if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) if (this.match("=")) {
								this.nextToken();
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							} else this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
						} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
							this.expect("=");
							init = this.isolateCoverGrammar(this.parseAssignmentExpression);
						}
						return this.finalize(node, new Node.VariableDeclarator(id, init));
					};
					Parser$1.prototype.parseBindingList = function(kind, options) {
						var list = [this.parseLexicalBinding(kind, options)];
						while (this.match(",")) {
							this.nextToken();
							list.push(this.parseLexicalBinding(kind, options));
						}
						return list;
					};
					Parser$1.prototype.isLexicalDeclaration = function() {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						this.scanner.restoreState(state);
						return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
					};
					Parser$1.prototype.parseLexicalDeclaration = function(options) {
						var node = this.createNode();
						var kind = this.nextToken().value;
						assert_1$8.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
						var declarations = this.parseBindingList(kind, options);
						this.consumeSemicolon();
						return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
					};
					Parser$1.prototype.parseBindingRestElement = function(params, kind) {
						var node = this.createNode();
						this.expect("...");
						var arg = this.parsePattern(params, kind);
						return this.finalize(node, new Node.RestElement(arg));
					};
					Parser$1.prototype.parseArrayPattern = function(params, kind) {
						var node = this.createNode();
						this.expect("[");
						var elements = [];
						while (!this.match("]")) if (this.match(",")) {
							this.nextToken();
							elements.push(null);
						} else {
							if (this.match("...")) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else elements.push(this.parsePatternWithDefault(params, kind));
							if (!this.match("]")) this.expect(",");
						}
						this.expect("]");
						return this.finalize(node, new Node.ArrayPattern(elements));
					};
					Parser$1.prototype.parsePropertyPattern = function(params, kind) {
						var node = this.createNode();
						var computed = false;
						var shorthand = false;
						var method$1 = false;
						var key;
						var value;
						if (this.lookahead.type === 3) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match("=")) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(":")) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(":");
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							this.expect(":");
							value = this.parsePatternWithDefault(params, kind);
						}
						return this.finalize(node, new Node.Property("init", key, computed, value, method$1, shorthand));
					};
					Parser$1.prototype.parseObjectPattern = function(params, kind) {
						var node = this.createNode();
						var properties = [];
						this.expect("{");
						while (!this.match("}")) {
							properties.push(this.parsePropertyPattern(params, kind));
							if (!this.match("}")) this.expect(",");
						}
						this.expect("}");
						return this.finalize(node, new Node.ObjectPattern(properties));
					};
					Parser$1.prototype.parsePattern = function(params, kind) {
						var pattern;
						if (this.match("[")) pattern = this.parseArrayPattern(params, kind);
						else if (this.match("{")) pattern = this.parseObjectPattern(params, kind);
						else {
							if (this.matchKeyword("let") && (kind === "const" || kind === "let")) this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
							params.push(this.lookahead);
							pattern = this.parseVariableIdentifier(kind);
						}
						return pattern;
					};
					Parser$1.prototype.parsePatternWithDefault = function(params, kind) {
						var startToken = this.lookahead;
						var pattern = this.parsePattern(params, kind);
						if (this.match("=")) {
							this.nextToken();
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = true;
							var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowYield = previousAllowYield;
							pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
						}
						return pattern;
					};
					Parser$1.prototype.parseVariableIdentifier = function(kind) {
						var node = this.createNode();
						var token = this.nextToken();
						if (token.type === 4 && token.value === "yield") {
							if (this.context.strict) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							else if (!this.context.allowYield) this.throwUnexpectedToken(token);
						} else if (token.type !== 3) {
							if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							else if (this.context.strict || token.value !== "let" || kind !== "var") this.throwUnexpectedToken(token);
						} else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") this.tolerateUnexpectedToken(token);
						return this.finalize(node, new Node.Identifier(token.value));
					};
					Parser$1.prototype.parseVariableDeclaration = function(options) {
						var node = this.createNode();
						var id = this.parsePattern([], "var");
						if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(id.name)) this.tolerateError(messages_1.Messages.StrictVarName);
						}
						var init = null;
						if (this.match("=")) {
							this.nextToken();
							init = this.isolateCoverGrammar(this.parseAssignmentExpression);
						} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) this.expect("=");
						return this.finalize(node, new Node.VariableDeclarator(id, init));
					};
					Parser$1.prototype.parseVariableDeclarationList = function(options) {
						var opt = { inFor: options.inFor };
						var list = [];
						list.push(this.parseVariableDeclaration(opt));
						while (this.match(",")) {
							this.nextToken();
							list.push(this.parseVariableDeclaration(opt));
						}
						return list;
					};
					Parser$1.prototype.parseVariableStatement = function() {
						var node = this.createNode();
						this.expectKeyword("var");
						var declarations = this.parseVariableDeclarationList({ inFor: false });
						this.consumeSemicolon();
						return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
					};
					Parser$1.prototype.parseEmptyStatement = function() {
						var node = this.createNode();
						this.expect(";");
						return this.finalize(node, new Node.EmptyStatement());
					};
					Parser$1.prototype.parseExpressionStatement = function() {
						var node = this.createNode();
						var expr = this.parseExpression();
						this.consumeSemicolon();
						return this.finalize(node, new Node.ExpressionStatement(expr));
					};
					Parser$1.prototype.parseIfClause = function() {
						if (this.context.strict && this.matchKeyword("function")) this.tolerateError(messages_1.Messages.StrictFunction);
						return this.parseStatement();
					};
					Parser$1.prototype.parseIfStatement = function() {
						var node = this.createNode();
						var consequent;
						var alternate = null;
						this.expectKeyword("if");
						this.expect("(");
						var test = this.parseExpression();
						if (!this.match(")") && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(")");
							consequent = this.parseIfClause();
							if (this.matchKeyword("else")) {
								this.nextToken();
								alternate = this.parseIfClause();
							}
						}
						return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
					};
					Parser$1.prototype.parseDoWhileStatement = function() {
						var node = this.createNode();
						this.expectKeyword("do");
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						var body = this.parseStatement();
						this.context.inIteration = previousInIteration;
						this.expectKeyword("while");
						this.expect("(");
						var test = this.parseExpression();
						if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken());
						else {
							this.expect(")");
							if (this.match(";")) this.nextToken();
						}
						return this.finalize(node, new Node.DoWhileStatement(body, test));
					};
					Parser$1.prototype.parseWhileStatement = function() {
						var node = this.createNode();
						var body;
						this.expectKeyword("while");
						this.expect("(");
						var test = this.parseExpression();
						if (!this.match(")") && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							body = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(")");
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = true;
							body = this.parseStatement();
							this.context.inIteration = previousInIteration;
						}
						return this.finalize(node, new Node.WhileStatement(test, body));
					};
					Parser$1.prototype.parseForStatement = function() {
						var init = null;
						var test = null;
						var update = null;
						var forIn = true;
						var left, right;
						var node = this.createNode();
						this.expectKeyword("for");
						this.expect("(");
						if (this.match(";")) this.nextToken();
						else if (this.matchKeyword("var")) {
							init = this.createNode();
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							var declarations = this.parseVariableDeclarationList({ inFor: true });
							this.context.allowIn = previousAllowIn;
							if (declarations.length === 1 && this.matchKeyword("in")) {
								var decl = declarations[0];
								if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
								init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
								this.nextToken();
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
								this.expect(";");
							}
						} else if (this.matchKeyword("const") || this.matchKeyword("let")) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === "in") {
								init = this.finalize(init, new Node.Identifier(kind));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseBindingList(kind, { inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									this.consumeSemicolon();
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
								}
							}
						} else {
							var initStartToken = this.lookahead;
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							init = this.inheritCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							if (this.matchKeyword("in")) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (this.matchContextualKeyword("of")) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								if (this.match(",")) {
									var initSeq = [init];
									while (this.match(",")) {
										this.nextToken();
										initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									}
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(";");
							}
						}
						if (typeof left === "undefined") {
							if (!this.match(";")) test = this.parseExpression();
							this.expect(";");
							if (!this.match(")")) update = this.parseExpression();
						}
						var body;
						if (!this.match(")") && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							body = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(")");
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = true;
							body = this.isolateCoverGrammar(this.parseStatement);
							this.context.inIteration = previousInIteration;
						}
						return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
					};
					Parser$1.prototype.parseContinueStatement = function() {
						var node = this.createNode();
						this.expectKeyword("continue");
						var label = null;
						if (this.lookahead.type === 3 && !this.hasLineTerminator) {
							var id = this.parseVariableIdentifier();
							label = id;
							var key = "$" + id.name;
							if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						this.consumeSemicolon();
						if (label === null && !this.context.inIteration) this.throwError(messages_1.Messages.IllegalContinue);
						return this.finalize(node, new Node.ContinueStatement(label));
					};
					Parser$1.prototype.parseBreakStatement = function() {
						var node = this.createNode();
						this.expectKeyword("break");
						var label = null;
						if (this.lookahead.type === 3 && !this.hasLineTerminator) {
							var id = this.parseVariableIdentifier();
							var key = "$" + id.name;
							if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(messages_1.Messages.UnknownLabel, id.name);
							label = id;
						}
						this.consumeSemicolon();
						if (label === null && !this.context.inIteration && !this.context.inSwitch) this.throwError(messages_1.Messages.IllegalBreak);
						return this.finalize(node, new Node.BreakStatement(label));
					};
					Parser$1.prototype.parseReturnStatement = function() {
						if (!this.context.inFunctionBody) this.tolerateError(messages_1.Messages.IllegalReturn);
						var node = this.createNode();
						this.expectKeyword("return");
						var argument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10 ? this.parseExpression() : null;
						this.consumeSemicolon();
						return this.finalize(node, new Node.ReturnStatement(argument));
					};
					Parser$1.prototype.parseWithStatement = function() {
						if (this.context.strict) this.tolerateError(messages_1.Messages.StrictModeWith);
						var node = this.createNode();
						var body;
						this.expectKeyword("with");
						this.expect("(");
						var object = this.parseExpression();
						if (!this.match(")") && this.config.tolerant) {
							this.tolerateUnexpectedToken(this.nextToken());
							body = this.finalize(this.createNode(), new Node.EmptyStatement());
						} else {
							this.expect(")");
							body = this.parseStatement();
						}
						return this.finalize(node, new Node.WithStatement(object, body));
					};
					Parser$1.prototype.parseSwitchCase = function() {
						var node = this.createNode();
						var test;
						if (this.matchKeyword("default")) {
							this.nextToken();
							test = null;
						} else {
							this.expectKeyword("case");
							test = this.parseExpression();
						}
						this.expect(":");
						var consequent = [];
						while (true) {
							if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) break;
							consequent.push(this.parseStatementListItem());
						}
						return this.finalize(node, new Node.SwitchCase(test, consequent));
					};
					Parser$1.prototype.parseSwitchStatement = function() {
						var node = this.createNode();
						this.expectKeyword("switch");
						this.expect("(");
						var discriminant = this.parseExpression();
						this.expect(")");
						var previousInSwitch = this.context.inSwitch;
						this.context.inSwitch = true;
						var cases = [];
						var defaultFound = false;
						this.expect("{");
						while (true) {
							if (this.match("}")) break;
							var clause = this.parseSwitchCase();
							if (clause.test === null) {
								if (defaultFound) this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
								defaultFound = true;
							}
							cases.push(clause);
						}
						this.expect("}");
						this.context.inSwitch = previousInSwitch;
						return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
					};
					Parser$1.prototype.parseLabelledStatement = function() {
						var node = this.createNode();
						var expr = this.parseExpression();
						var statement;
						if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
							this.nextToken();
							var id = expr;
							var key = "$" + id.name;
							if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
							this.context.labelSet[key] = true;
							var body = void 0;
							if (this.matchKeyword("class")) {
								this.tolerateUnexpectedToken(this.lookahead);
								body = this.parseClassDeclaration();
							} else if (this.matchKeyword("function")) {
								var token = this.lookahead;
								var declaration = this.parseFunctionDeclaration();
								if (this.context.strict) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
								else if (declaration.generator) this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
								body = declaration;
							} else body = this.parseStatement();
							delete this.context.labelSet[key];
							statement = new Node.LabeledStatement(id, body);
						} else {
							this.consumeSemicolon();
							statement = new Node.ExpressionStatement(expr);
						}
						return this.finalize(node, statement);
					};
					Parser$1.prototype.parseThrowStatement = function() {
						var node = this.createNode();
						this.expectKeyword("throw");
						if (this.hasLineTerminator) this.throwError(messages_1.Messages.NewlineAfterThrow);
						var argument = this.parseExpression();
						this.consumeSemicolon();
						return this.finalize(node, new Node.ThrowStatement(argument));
					};
					Parser$1.prototype.parseCatchClause = function() {
						var node = this.createNode();
						this.expectKeyword("catch");
						this.expect("(");
						if (this.match(")")) this.throwUnexpectedToken(this.lookahead);
						var params = [];
						var param = this.parsePattern(params);
						var paramMap = {};
						for (var i$2 = 0; i$2 < params.length; i$2++) {
							var key = "$" + params[i$2].value;
							if (Object.prototype.hasOwnProperty.call(paramMap, key)) this.tolerateError(messages_1.Messages.DuplicateBinding, params[i$2].value);
							paramMap[key] = true;
						}
						if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
							if (this.scanner.isRestrictedWord(param.name)) this.tolerateError(messages_1.Messages.StrictCatchVariable);
						}
						this.expect(")");
						var body = this.parseBlock();
						return this.finalize(node, new Node.CatchClause(param, body));
					};
					Parser$1.prototype.parseFinallyClause = function() {
						this.expectKeyword("finally");
						return this.parseBlock();
					};
					Parser$1.prototype.parseTryStatement = function() {
						var node = this.createNode();
						this.expectKeyword("try");
						var block = this.parseBlock();
						var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
						var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
						if (!handler && !finalizer) this.throwError(messages_1.Messages.NoCatchOrFinally);
						return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
					};
					Parser$1.prototype.parseDebuggerStatement = function() {
						var node = this.createNode();
						this.expectKeyword("debugger");
						this.consumeSemicolon();
						return this.finalize(node, new Node.DebuggerStatement());
					};
					Parser$1.prototype.parseStatement = function() {
						var statement;
						switch (this.lookahead.type) {
							case 1:
							case 5:
							case 6:
							case 8:
							case 10:
							case 9:
								statement = this.parseExpressionStatement();
								break;
							case 7:
								var value = this.lookahead.value;
								if (value === "{") statement = this.parseBlock();
								else if (value === "(") statement = this.parseExpressionStatement();
								else if (value === ";") statement = this.parseEmptyStatement();
								else statement = this.parseExpressionStatement();
								break;
							case 3:
								statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
								break;
							case 4:
								switch (this.lookahead.value) {
									case "break":
										statement = this.parseBreakStatement();
										break;
									case "continue":
										statement = this.parseContinueStatement();
										break;
									case "debugger":
										statement = this.parseDebuggerStatement();
										break;
									case "do":
										statement = this.parseDoWhileStatement();
										break;
									case "for":
										statement = this.parseForStatement();
										break;
									case "function":
										statement = this.parseFunctionDeclaration();
										break;
									case "if":
										statement = this.parseIfStatement();
										break;
									case "return":
										statement = this.parseReturnStatement();
										break;
									case "switch":
										statement = this.parseSwitchStatement();
										break;
									case "throw":
										statement = this.parseThrowStatement();
										break;
									case "try":
										statement = this.parseTryStatement();
										break;
									case "var":
										statement = this.parseVariableStatement();
										break;
									case "while":
										statement = this.parseWhileStatement();
										break;
									case "with":
										statement = this.parseWithStatement();
										break;
									default:
										statement = this.parseExpressionStatement();
										break;
								}
								break;
							default: statement = this.throwUnexpectedToken(this.lookahead);
						}
						return statement;
					};
					Parser$1.prototype.parseFunctionSourceElements = function() {
						var node = this.createNode();
						this.expect("{");
						var body = this.parseDirectivePrologues();
						var previousLabelSet = this.context.labelSet;
						var previousInIteration = this.context.inIteration;
						var previousInSwitch = this.context.inSwitch;
						var previousInFunctionBody = this.context.inFunctionBody;
						this.context.labelSet = {};
						this.context.inIteration = false;
						this.context.inSwitch = false;
						this.context.inFunctionBody = true;
						while (this.lookahead.type !== 2) {
							if (this.match("}")) break;
							body.push(this.parseStatementListItem());
						}
						this.expect("}");
						this.context.labelSet = previousLabelSet;
						this.context.inIteration = previousInIteration;
						this.context.inSwitch = previousInSwitch;
						this.context.inFunctionBody = previousInFunctionBody;
						return this.finalize(node, new Node.BlockStatement(body));
					};
					Parser$1.prototype.validateParam = function(options, param, name) {
						var key = "$" + name;
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(name)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamName;
							}
							if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamDupe;
							}
						} else if (!options.firstRestricted) {
							if (this.scanner.isRestrictedWord(name)) {
								options.firstRestricted = param;
								options.message = messages_1.Messages.StrictParamName;
							} else if (this.scanner.isStrictModeReservedWord(name)) {
								options.firstRestricted = param;
								options.message = messages_1.Messages.StrictReservedWord;
							} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
								options.stricted = param;
								options.message = messages_1.Messages.StrictParamDupe;
							}
						}
						/* istanbul ignore next */
						if (typeof Object.defineProperty === "function") Object.defineProperty(options.paramSet, key, {
							value: true,
							enumerable: true,
							writable: true,
							configurable: true
						});
						else options.paramSet[key] = true;
					};
					Parser$1.prototype.parseRestElement = function(params) {
						var node = this.createNode();
						this.expect("...");
						var arg = this.parsePattern(params);
						if (this.match("=")) this.throwError(messages_1.Messages.DefaultRestParameter);
						if (!this.match(")")) this.throwError(messages_1.Messages.ParameterAfterRestParameter);
						return this.finalize(node, new Node.RestElement(arg));
					};
					Parser$1.prototype.parseFormalParameter = function(options) {
						var params = [];
						var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
						for (var i$2 = 0; i$2 < params.length; i$2++) this.validateParam(options, params[i$2], params[i$2].value);
						options.simple = options.simple && param instanceof Node.Identifier;
						options.params.push(param);
					};
					Parser$1.prototype.parseFormalParameters = function(firstRestricted) {
						var options = {
							simple: true,
							params: [],
							firstRestricted
						};
						this.expect("(");
						if (!this.match(")")) {
							options.paramSet = {};
							while (this.lookahead.type !== 2) {
								this.parseFormalParameter(options);
								if (this.match(")")) break;
								this.expect(",");
								if (this.match(")")) break;
							}
						}
						this.expect(")");
						return {
							simple: options.simple,
							params: options.params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					};
					Parser$1.prototype.matchAsyncFunction = function() {
						var match$1 = this.matchContextualKeyword("async");
						if (match$1) {
							var state = this.scanner.saveState();
							this.scanner.scanComments();
							var next = this.scanner.lex();
							this.scanner.restoreState(state);
							match$1 = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
						}
						return match$1;
					};
					Parser$1.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
						var node = this.createNode();
						var isAsync$1 = this.matchContextualKeyword("async");
						if (isAsync$1) this.nextToken();
						this.expectKeyword("function");
						var isGenerator = isAsync$1 ? false : this.match("*");
						if (isGenerator) this.nextToken();
						var message;
						var id = null;
						var firstRestricted = null;
						if (!identifierIsOptional || !this.match("(")) {
							var token = this.lookahead;
							id = this.parseVariableIdentifier();
							if (this.context.strict) {
								if (this.scanner.isRestrictedWord(token.value)) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							} else if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
						var previousAllowAwait = this.context.await;
						var previousAllowYield = this.context.allowYield;
						this.context.await = isAsync$1;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters(firstRestricted);
						var params = formalParameters.params;
						var stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted;
						if (formalParameters.message) message = formalParameters.message;
						var previousStrict = this.context.strict;
						var previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = formalParameters.simple;
						var body = this.parseFunctionSourceElements();
						if (this.context.strict && firstRestricted) this.throwUnexpectedToken(firstRestricted, message);
						if (this.context.strict && stricted) this.tolerateUnexpectedToken(stricted, message);
						this.context.strict = previousStrict;
						this.context.allowStrictDirective = previousAllowStrictDirective;
						this.context.await = previousAllowAwait;
						this.context.allowYield = previousAllowYield;
						return isAsync$1 ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
					};
					Parser$1.prototype.parseFunctionExpression = function() {
						var node = this.createNode();
						var isAsync$1 = this.matchContextualKeyword("async");
						if (isAsync$1) this.nextToken();
						this.expectKeyword("function");
						var isGenerator = isAsync$1 ? false : this.match("*");
						if (isGenerator) this.nextToken();
						var message;
						var id = null;
						var firstRestricted;
						var previousAllowAwait = this.context.await;
						var previousAllowYield = this.context.allowYield;
						this.context.await = isAsync$1;
						this.context.allowYield = !isGenerator;
						if (!this.match("(")) {
							var token = this.lookahead;
							id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
							if (this.context.strict) {
								if (this.scanner.isRestrictedWord(token.value)) this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							} else if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
						var formalParameters = this.parseFormalParameters(firstRestricted);
						var params = formalParameters.params;
						var stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted;
						if (formalParameters.message) message = formalParameters.message;
						var previousStrict = this.context.strict;
						var previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = formalParameters.simple;
						var body = this.parseFunctionSourceElements();
						if (this.context.strict && firstRestricted) this.throwUnexpectedToken(firstRestricted, message);
						if (this.context.strict && stricted) this.tolerateUnexpectedToken(stricted, message);
						this.context.strict = previousStrict;
						this.context.allowStrictDirective = previousAllowStrictDirective;
						this.context.await = previousAllowAwait;
						this.context.allowYield = previousAllowYield;
						return isAsync$1 ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
					};
					Parser$1.prototype.parseDirective = function() {
						var token = this.lookahead;
						var node = this.createNode();
						var expr = this.parseExpression();
						var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
						this.consumeSemicolon();
						return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
					};
					Parser$1.prototype.parseDirectivePrologues = function() {
						var firstRestricted = null;
						var body = [];
						while (true) {
							var token = this.lookahead;
							if (token.type !== 8) break;
							var statement = this.parseDirective();
							body.push(statement);
							var directive = statement.directive;
							if (typeof directive !== "string") break;
							if (directive === "use strict") {
								this.context.strict = true;
								if (firstRestricted) this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
								if (!this.context.allowStrictDirective) this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
							} else if (!firstRestricted && token.octal) firstRestricted = token;
						}
						return body;
					};
					Parser$1.prototype.qualifiedPropertyName = function(token) {
						switch (token.type) {
							case 3:
							case 8:
							case 1:
							case 5:
							case 6:
							case 4: return true;
							case 7: return token.value === "[";
							default: break;
						}
						return false;
					};
					Parser$1.prototype.parseGetterMethod = function() {
						var node = this.createNode();
						var isGenerator = false;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters();
						if (formalParameters.params.length > 0) this.tolerateError(messages_1.Messages.BadGetterArity);
						var method$1 = this.parsePropertyMethod(formalParameters);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method$1, isGenerator));
					};
					Parser$1.prototype.parseSetterMethod = function() {
						var node = this.createNode();
						var isGenerator = false;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters();
						if (formalParameters.params.length !== 1) this.tolerateError(messages_1.Messages.BadSetterArity);
						else if (formalParameters.params[0] instanceof Node.RestElement) this.tolerateError(messages_1.Messages.BadSetterRestParameter);
						var method$1 = this.parsePropertyMethod(formalParameters);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method$1, isGenerator));
					};
					Parser$1.prototype.parseGeneratorMethod = function() {
						var node = this.createNode();
						var isGenerator = true;
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var params = this.parseFormalParameters();
						this.context.allowYield = false;
						var method$1 = this.parsePropertyMethod(params);
						this.context.allowYield = previousAllowYield;
						return this.finalize(node, new Node.FunctionExpression(null, params.params, method$1, isGenerator));
					};
					Parser$1.prototype.isStartOfExpression = function() {
						var start = true;
						var value = this.lookahead.value;
						switch (this.lookahead.type) {
							case 7:
								start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
								break;
							case 4:
								start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
								break;
							default: break;
						}
						return start;
					};
					Parser$1.prototype.parseYieldExpression = function() {
						var node = this.createNode();
						this.expectKeyword("yield");
						var argument = null;
						var delegate = false;
						if (!this.hasLineTerminator) {
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = false;
							delegate = this.match("*");
							if (delegate) {
								this.nextToken();
								argument = this.parseAssignmentExpression();
							} else if (this.isStartOfExpression()) argument = this.parseAssignmentExpression();
							this.context.allowYield = previousAllowYield;
						}
						return this.finalize(node, new Node.YieldExpression(argument, delegate));
					};
					Parser$1.prototype.parseClassElement = function(hasConstructor) {
						var token = this.lookahead;
						var node = this.createNode();
						var kind = "";
						var key = null;
						var value = null;
						var computed = false;
						var method$1 = false;
						var isStatic = false;
						var isAsync$1 = false;
						if (this.match("*")) this.nextToken();
						else {
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							if (key.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
								token = this.lookahead;
								isStatic = true;
								computed = this.match("[");
								if (this.match("*")) this.nextToken();
								else key = this.parseObjectPropertyKey();
							}
							if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
								var punctuator = this.lookahead.value;
								if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
									isAsync$1 = true;
									token = this.lookahead;
									key = this.parseObjectPropertyKey();
									if (token.type === 3 && token.value === "constructor") this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
								}
							}
						}
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						if (token.type === 3) {
							if (token.value === "get" && lookaheadPropertyKey) {
								kind = "get";
								computed = this.match("[");
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === "set" && lookaheadPropertyKey) {
								kind = "set";
								computed = this.match("[");
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
							kind = "init";
							computed = this.match("[");
							key = this.parseObjectPropertyKey();
							value = this.parseGeneratorMethod();
							method$1 = true;
						}
						if (!kind && key && this.match("(")) {
							kind = "init";
							value = isAsync$1 ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
							method$1 = true;
						}
						if (!kind) this.throwUnexpectedToken(this.lookahead);
						if (kind === "init") kind = "method";
						if (!computed) {
							if (isStatic && this.isPropertyKey(key, "prototype")) this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
							if (!isStatic && this.isPropertyKey(key, "constructor")) {
								if (kind !== "method" || !method$1 || value && value.generator) this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
								if (hasConstructor.value) this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
								else hasConstructor.value = true;
								kind = "constructor";
							}
						}
						return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
					};
					Parser$1.prototype.parseClassElementList = function() {
						var body = [];
						var hasConstructor = { value: false };
						this.expect("{");
						while (!this.match("}")) if (this.match(";")) this.nextToken();
						else body.push(this.parseClassElement(hasConstructor));
						this.expect("}");
						return body;
					};
					Parser$1.prototype.parseClassBody = function() {
						var node = this.createNode();
						var elementList = this.parseClassElementList();
						return this.finalize(node, new Node.ClassBody(elementList));
					};
					Parser$1.prototype.parseClassDeclaration = function(identifierIsOptional) {
						var node = this.createNode();
						var previousStrict = this.context.strict;
						this.context.strict = true;
						this.expectKeyword("class");
						var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
						var superClass = null;
						if (this.matchKeyword("extends")) {
							this.nextToken();
							superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						}
						var classBody = this.parseClassBody();
						this.context.strict = previousStrict;
						return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
					};
					Parser$1.prototype.parseClassExpression = function() {
						var node = this.createNode();
						var previousStrict = this.context.strict;
						this.context.strict = true;
						this.expectKeyword("class");
						var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
						var superClass = null;
						if (this.matchKeyword("extends")) {
							this.nextToken();
							superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						}
						var classBody = this.parseClassBody();
						this.context.strict = previousStrict;
						return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
					};
					Parser$1.prototype.parseModule = function() {
						this.context.strict = true;
						this.context.isModule = true;
						this.scanner.isModule = true;
						var node = this.createNode();
						var body = this.parseDirectivePrologues();
						while (this.lookahead.type !== 2) body.push(this.parseStatementListItem());
						return this.finalize(node, new Node.Module(body));
					};
					Parser$1.prototype.parseScript = function() {
						var node = this.createNode();
						var body = this.parseDirectivePrologues();
						while (this.lookahead.type !== 2) body.push(this.parseStatementListItem());
						return this.finalize(node, new Node.Script(body));
					};
					Parser$1.prototype.parseModuleSpecifier = function() {
						var node = this.createNode();
						if (this.lookahead.type !== 8) this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						var token = this.nextToken();
						var raw = this.getTokenRaw(token);
						return this.finalize(node, new Node.Literal(token.value, raw));
					};
					Parser$1.prototype.parseImportSpecifier = function() {
						var node = this.createNode();
						var imported;
						var local;
						if (this.lookahead.type === 3) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword("as")) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
							imported = this.parseIdentifierName();
							local = imported;
							if (this.matchContextualKeyword("as")) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							} else this.throwUnexpectedToken(this.nextToken());
						}
						return this.finalize(node, new Node.ImportSpecifier(local, imported));
					};
					Parser$1.prototype.parseNamedImports = function() {
						this.expect("{");
						var specifiers = [];
						while (!this.match("}")) {
							specifiers.push(this.parseImportSpecifier());
							if (!this.match("}")) this.expect(",");
						}
						this.expect("}");
						return specifiers;
					};
					Parser$1.prototype.parseImportDefaultSpecifier = function() {
						var node = this.createNode();
						var local = this.parseIdentifierName();
						return this.finalize(node, new Node.ImportDefaultSpecifier(local));
					};
					Parser$1.prototype.parseImportNamespaceSpecifier = function() {
						var node = this.createNode();
						this.expect("*");
						if (!this.matchContextualKeyword("as")) this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
						this.nextToken();
						var local = this.parseIdentifierName();
						return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
					};
					Parser$1.prototype.parseImportDeclaration = function() {
						if (this.context.inFunctionBody) this.throwError(messages_1.Messages.IllegalImportDeclaration);
						var node = this.createNode();
						this.expectKeyword("import");
						var src;
						var specifiers = [];
						if (this.lookahead.type === 8) src = this.parseModuleSpecifier();
						else {
							if (this.match("{")) specifiers = specifiers.concat(this.parseNamedImports());
							else if (this.match("*")) specifiers.push(this.parseImportNamespaceSpecifier());
							else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
								specifiers.push(this.parseImportDefaultSpecifier());
								if (this.match(",")) {
									this.nextToken();
									if (this.match("*")) specifiers.push(this.parseImportNamespaceSpecifier());
									else if (this.match("{")) specifiers = specifiers.concat(this.parseNamedImports());
									else this.throwUnexpectedToken(this.lookahead);
								}
							} else this.throwUnexpectedToken(this.nextToken());
							if (!this.matchContextualKeyword("from")) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken();
							src = this.parseModuleSpecifier();
						}
						this.consumeSemicolon();
						return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
					};
					Parser$1.prototype.parseExportSpecifier = function() {
						var node = this.createNode();
						var local = this.parseIdentifierName();
						var exported = local;
						if (this.matchContextualKeyword("as")) {
							this.nextToken();
							exported = this.parseIdentifierName();
						}
						return this.finalize(node, new Node.ExportSpecifier(local, exported));
					};
					Parser$1.prototype.parseExportDeclaration = function() {
						if (this.context.inFunctionBody) this.throwError(messages_1.Messages.IllegalExportDeclaration);
						var node = this.createNode();
						this.expectKeyword("export");
						var exportDeclaration;
						if (this.matchKeyword("default")) {
							this.nextToken();
							if (this.matchKeyword("function")) {
								var declaration = this.parseFunctionDeclaration(true);
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							} else if (this.matchKeyword("class")) {
								var declaration = this.parseClassDeclaration(true);
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							} else if (this.matchContextualKeyword("async")) {
								var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							} else {
								if (this.matchContextualKeyword("from")) this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
								var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
								this.consumeSemicolon();
								exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
							}
						} else if (this.match("*")) {
							this.nextToken();
							if (!this.matchContextualKeyword("from")) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken();
							var src = this.parseModuleSpecifier();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
						} else if (this.lookahead.type === 4) {
							var declaration = void 0;
							switch (this.lookahead.value) {
								case "let":
								case "const":
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case "var":
								case "class":
								case "function":
									declaration = this.parseStatementListItem();
									break;
								default: this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
							var declaration = this.parseFunctionDeclaration();
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else {
							var specifiers = [];
							var source = null;
							var isExportFromIdentifier = false;
							this.expect("{");
							while (!this.match("}")) {
								isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
								specifiers.push(this.parseExportSpecifier());
								if (!this.match("}")) this.expect(",");
							}
							this.expect("}");
							if (this.matchContextualKeyword("from")) {
								this.nextToken();
								source = this.parseModuleSpecifier();
								this.consumeSemicolon();
							} else if (isExportFromIdentifier) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							} else this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
						}
						return exportDeclaration;
					};
					return Parser$1;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				function assert$4(condition, message) {
					/* istanbul ignore if */
					if (!condition) throw new Error("ASSERT: " + message);
				}
				exports$1.assert = assert$4;
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.ErrorHandler = function() {
					function ErrorHandler$1() {
						this.errors = [];
						this.tolerant = false;
					}
					ErrorHandler$1.prototype.recordError = function(error$1) {
						this.errors.push(error$1);
					};
					ErrorHandler$1.prototype.tolerate = function(error$1) {
						if (this.tolerant) this.recordError(error$1);
						else throw error$1;
					};
					ErrorHandler$1.prototype.constructError = function(msg, column) {
						var error$1 = new Error(msg);
						try {
							throw error$1;
						} catch (base) {
							/* istanbul ignore else */
							if (Object.create && Object.defineProperty) {
								error$1 = Object.create(base);
								Object.defineProperty(error$1, "column", { value: column });
							}
						}
						/* istanbul ignore next */
						return error$1;
					};
					ErrorHandler$1.prototype.createError = function(index, line, col, description) {
						var msg = "Line " + line + ": " + description;
						var error$1 = this.constructError(msg, col);
						error$1.index = index;
						error$1.lineNumber = line;
						error$1.description = description;
						return error$1;
					};
					ErrorHandler$1.prototype.throwError = function(index, line, col, description) {
						throw this.createError(index, line, col, description);
					};
					ErrorHandler$1.prototype.tolerateError = function(index, line, col, description) {
						var error$1 = this.createError(index, line, col, description);
						if (this.tolerant) this.recordError(error$1);
						else throw error$1;
					};
					return ErrorHandler$1;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.Messages = {
					BadGetterArity: "Getter must not have any formal parameters",
					BadSetterArity: "Setter must have exactly one formal parameter",
					BadSetterRestParameter: "Setter function argument must not be a rest parameter",
					ConstructorIsAsync: "Class constructor may not be an async method",
					ConstructorSpecialMethod: "Class constructor may not be an accessor",
					DeclarationMissingInitializer: "Missing initializer in %0 declaration",
					DefaultRestParameter: "Unexpected token =",
					DuplicateBinding: "Duplicate binding %0",
					DuplicateConstructor: "A class may only have one constructor",
					DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
					ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
					GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
					IllegalBreak: "Illegal break statement",
					IllegalContinue: "Illegal continue statement",
					IllegalExportDeclaration: "Unexpected token",
					IllegalImportDeclaration: "Unexpected token",
					IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
					IllegalReturn: "Illegal return statement",
					InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
					InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
					InvalidLHSInAssignment: "Invalid left-hand side in assignment",
					InvalidLHSInForIn: "Invalid left-hand side in for-in",
					InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
					InvalidModuleSpecifier: "Unexpected token",
					InvalidRegExp: "Invalid regular expression",
					LetInLexicalBinding: "let is disallowed as a lexically bound name",
					MissingFromClause: "Unexpected token",
					MultipleDefaultsInSwitch: "More than one default clause in switch statement",
					NewlineAfterThrow: "Illegal newline after throw",
					NoAsAfterImportNamespace: "Unexpected token",
					NoCatchOrFinally: "Missing catch or finally after try",
					ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
					Redeclaration: "%0 '%1' has already been declared",
					StaticPrototype: "Classes may not have static property named prototype",
					StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
					StrictDelete: "Delete of an unqualified identifier in strict mode.",
					StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
					StrictFunctionName: "Function name may not be eval or arguments in strict mode",
					StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
					StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
					StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
					StrictModeWith: "Strict mode code may not include a with statement",
					StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
					StrictParamDupe: "Strict mode function may not have duplicate parameter names",
					StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
					StrictReservedWord: "Use of future reserved word in strict mode",
					StrictVarName: "Variable name may not be eval or arguments in strict mode",
					TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
					UnexpectedEOS: "Unexpected end of input",
					UnexpectedIdentifier: "Unexpected identifier",
					UnexpectedNumber: "Unexpected number",
					UnexpectedReserved: "Unexpected reserved word",
					UnexpectedString: "Unexpected string",
					UnexpectedTemplate: "Unexpected quasi %0",
					UnexpectedToken: "Unexpected token %0",
					UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
					UnknownLabel: "Undefined label '%0'",
					UnterminatedRegExp: "Invalid regular expression: missing /"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var assert_1$8 = __webpack_require__(9);
				var character_1 = __webpack_require__(4);
				var messages_1 = __webpack_require__(11);
				function hexValue$1(ch) {
					return "0123456789abcdef".indexOf(ch.toLowerCase());
				}
				function octalValue$1(ch) {
					return "01234567".indexOf(ch);
				}
				exports$1.Scanner = function() {
					function Scanner$1(code$1, handler) {
						this.source = code$1;
						this.errorHandler = handler;
						this.trackComment = false;
						this.isModule = false;
						this.length = code$1.length;
						this.index = 0;
						this.lineNumber = code$1.length > 0 ? 1 : 0;
						this.lineStart = 0;
						this.curlyStack = [];
					}
					Scanner$1.prototype.saveState = function() {
						return {
							index: this.index,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart
						};
					};
					Scanner$1.prototype.restoreState = function(state) {
						this.index = state.index;
						this.lineNumber = state.lineNumber;
						this.lineStart = state.lineStart;
					};
					Scanner$1.prototype.eof = function() {
						return this.index >= this.length;
					};
					Scanner$1.prototype.throwUnexpectedToken = function(message) {
						if (message === void 0) message = messages_1.Messages.UnexpectedTokenIllegal;
						return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
					};
					Scanner$1.prototype.tolerateUnexpectedToken = function(message) {
						if (message === void 0) message = messages_1.Messages.UnexpectedTokenIllegal;
						this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
					};
					Scanner$1.prototype.skipSingleLineComment = function(offset$1) {
						var comments = [];
						var start, loc;
						if (this.trackComment) {
							comments = [];
							start = this.index - offset$1;
							loc = {
								start: {
									line: this.lineNumber,
									column: this.index - this.lineStart - offset$1
								},
								end: {}
							};
						}
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							++this.index;
							if (character_1.Character.isLineTerminator(ch)) {
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart - 1
									};
									var entry = {
										multiLine: false,
										slice: [start + offset$1, this.index - 1],
										range: [start, this.index - 1],
										loc
									};
									comments.push(entry);
								}
								if (ch === 13 && this.source.charCodeAt(this.index) === 10) ++this.index;
								++this.lineNumber;
								this.lineStart = this.index;
								return comments;
							}
						}
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: false,
								slice: [start + offset$1, this.index],
								range: [start, this.index],
								loc
							};
							comments.push(entry);
						}
						return comments;
					};
					Scanner$1.prototype.skipMultiLineComment = function() {
						var comments = [];
						var start, loc;
						if (this.trackComment) {
							comments = [];
							start = this.index - 2;
							loc = {
								start: {
									line: this.lineNumber,
									column: this.index - this.lineStart - 2
								},
								end: {}
							};
						}
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isLineTerminator(ch)) {
								if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) ++this.index;
								++this.lineNumber;
								++this.index;
								this.lineStart = this.index;
							} else if (ch === 42) {
								if (this.source.charCodeAt(this.index + 1) === 47) {
									this.index += 2;
									if (this.trackComment) {
										loc.end = {
											line: this.lineNumber,
											column: this.index - this.lineStart
										};
										var entry = {
											multiLine: true,
											slice: [start + 2, this.index - 2],
											range: [start, this.index],
											loc
										};
										comments.push(entry);
									}
									return comments;
								}
								++this.index;
							} else ++this.index;
						}
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: true,
								slice: [start + 2, this.index],
								range: [start, this.index],
								loc
							};
							comments.push(entry);
						}
						this.tolerateUnexpectedToken();
						return comments;
					};
					Scanner$1.prototype.scanComments = function() {
						var comments;
						if (this.trackComment) comments = [];
						var start = this.index === 0;
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isWhiteSpace(ch)) ++this.index;
							else if (character_1.Character.isLineTerminator(ch)) {
								++this.index;
								if (ch === 13 && this.source.charCodeAt(this.index) === 10) ++this.index;
								++this.lineNumber;
								this.lineStart = this.index;
								start = true;
							} else if (ch === 47) {
								ch = this.source.charCodeAt(this.index + 1);
								if (ch === 47) {
									this.index += 2;
									var comment = this.skipSingleLineComment(2);
									if (this.trackComment) comments = comments.concat(comment);
									start = true;
								} else if (ch === 42) {
									this.index += 2;
									var comment = this.skipMultiLineComment();
									if (this.trackComment) comments = comments.concat(comment);
								} else break;
							} else if (start && ch === 45) if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								if (this.trackComment) comments = comments.concat(comment);
							} else break;
							else if (ch === 60 && !this.isModule) if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
								this.index += 4;
								var comment = this.skipSingleLineComment(4);
								if (this.trackComment) comments = comments.concat(comment);
							} else break;
							else break;
						}
						return comments;
					};
					Scanner$1.prototype.isFutureReservedWord = function(id) {
						switch (id) {
							case "enum":
							case "export":
							case "import":
							case "super": return true;
							default: return false;
						}
					};
					Scanner$1.prototype.isStrictModeReservedWord = function(id) {
						switch (id) {
							case "implements":
							case "interface":
							case "package":
							case "private":
							case "protected":
							case "public":
							case "static":
							case "yield":
							case "let": return true;
							default: return false;
						}
					};
					Scanner$1.prototype.isRestrictedWord = function(id) {
						return id === "eval" || id === "arguments";
					};
					Scanner$1.prototype.isKeyword = function(id) {
						switch (id.length) {
							case 2: return id === "if" || id === "in" || id === "do";
							case 3: return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
							case 4: return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
							case 5: return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
							case 6: return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
							case 7: return id === "default" || id === "finally" || id === "extends";
							case 8: return id === "function" || id === "continue" || id === "debugger";
							case 10: return id === "instanceof";
							default: return false;
						}
					};
					Scanner$1.prototype.codePointAt = function(i$2) {
						var cp = this.source.charCodeAt(i$2);
						if (cp >= 55296 && cp <= 56319) {
							var second = this.source.charCodeAt(i$2 + 1);
							if (second >= 56320 && second <= 57343) cp = (cp - 55296) * 1024 + second - 56320 + 65536;
						}
						return cp;
					};
					Scanner$1.prototype.scanHexEscape = function(prefix) {
						var len$1 = prefix === "u" ? 4 : 2;
						var code$1 = 0;
						for (var i$2 = 0; i$2 < len$1; ++i$2) if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) code$1 = code$1 * 16 + hexValue$1(this.source[this.index++]);
						else return null;
						return String.fromCharCode(code$1);
					};
					Scanner$1.prototype.scanUnicodeCodePointEscape = function() {
						var ch = this.source[this.index];
						var code$1 = 0;
						if (ch === "}") this.throwUnexpectedToken();
						while (!this.eof()) {
							ch = this.source[this.index++];
							if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) break;
							code$1 = code$1 * 16 + hexValue$1(ch);
						}
						if (code$1 > 1114111 || ch !== "}") this.throwUnexpectedToken();
						return character_1.Character.fromCodePoint(code$1);
					};
					Scanner$1.prototype.getIdentifier = function() {
						var start = this.index++;
						while (!this.eof()) {
							var ch = this.source.charCodeAt(this.index);
							if (ch === 92) {
								this.index = start;
								return this.getComplexIdentifier();
							} else if (ch >= 55296 && ch < 57343) {
								this.index = start;
								return this.getComplexIdentifier();
							}
							if (character_1.Character.isIdentifierPart(ch)) ++this.index;
							else break;
						}
						return this.source.slice(start, this.index);
					};
					Scanner$1.prototype.getComplexIdentifier = function() {
						var cp = this.codePointAt(this.index);
						var id = character_1.Character.fromCodePoint(cp);
						this.index += id.length;
						var ch;
						if (cp === 92) {
							if (this.source.charCodeAt(this.index) !== 117) this.throwUnexpectedToken();
							++this.index;
							if (this.source[this.index] === "{") {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape("u");
								if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) this.throwUnexpectedToken();
							}
							id = ch;
						}
						while (!this.eof()) {
							cp = this.codePointAt(this.index);
							if (!character_1.Character.isIdentifierPart(cp)) break;
							ch = character_1.Character.fromCodePoint(cp);
							id += ch;
							this.index += ch.length;
							if (cp === 92) {
								id = id.substr(0, id.length - 1);
								if (this.source.charCodeAt(this.index) !== 117) this.throwUnexpectedToken();
								++this.index;
								if (this.source[this.index] === "{") {
									++this.index;
									ch = this.scanUnicodeCodePointEscape();
								} else {
									ch = this.scanHexEscape("u");
									if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) this.throwUnexpectedToken();
								}
								id += ch;
							}
						}
						return id;
					};
					Scanner$1.prototype.octalToDecimal = function(ch) {
						var octal = ch !== "0";
						var code$1 = octalValue$1(ch);
						if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							octal = true;
							code$1 = code$1 * 8 + octalValue$1(this.source[this.index++]);
							if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) code$1 = code$1 * 8 + octalValue$1(this.source[this.index++]);
						}
						return {
							code: code$1,
							octal
						};
					};
					Scanner$1.prototype.scanIdentifier = function() {
						var type;
						var start = this.index;
						var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
						if (id.length === 1) type = 3;
						else if (this.isKeyword(id)) type = 4;
						else if (id === "null") type = 5;
						else if (id === "true" || id === "false") type = 1;
						else type = 3;
						if (type !== 3 && start + id.length !== this.index) {
							var restore = this.index;
							this.index = start;
							this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
							this.index = restore;
						}
						return {
							type,
							value: id,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanPunctuator = function() {
						var start = this.index;
						var str = this.source[this.index];
						switch (str) {
							case "(":
							case "{":
								if (str === "{") this.curlyStack.push("{");
								++this.index;
								break;
							case ".":
								++this.index;
								if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
									this.index += 2;
									str = "...";
								}
								break;
							case "}":
								++this.index;
								this.curlyStack.pop();
								break;
							case ")":
							case ";":
							case ",":
							case "[":
							case "]":
							case ":":
							case "?":
							case "~":
								++this.index;
								break;
							default:
								str = this.source.substr(this.index, 4);
								if (str === ">>>=") this.index += 4;
								else {
									str = str.substr(0, 3);
									if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") this.index += 3;
									else {
										str = str.substr(0, 2);
										if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") this.index += 2;
										else {
											str = this.source[this.index];
											if ("<>=!+-*%&|^/".indexOf(str) >= 0) ++this.index;
										}
									}
								}
						}
						if (this.index === start) this.throwUnexpectedToken();
						return {
							type: 7,
							value: str,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanHexLiteral = function(start) {
						var num = "";
						while (!this.eof()) {
							if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) break;
							num += this.source[this.index++];
						}
						if (num.length === 0) this.throwUnexpectedToken();
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
						return {
							type: 6,
							value: parseInt("0x" + num, 16),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanBinaryLiteral = function(start) {
						var num = "";
						var ch;
						while (!this.eof()) {
							ch = this.source[this.index];
							if (ch !== "0" && ch !== "1") break;
							num += this.source[this.index++];
						}
						if (num.length === 0) this.throwUnexpectedToken();
						if (!this.eof()) {
							ch = this.source.charCodeAt(this.index);
							/* istanbul ignore else */
							if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) this.throwUnexpectedToken();
						}
						return {
							type: 6,
							value: parseInt(num, 2),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanOctalLiteral = function(prefix, start) {
						var num = "";
						var octal = false;
						if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
							octal = true;
							num = "0" + this.source[this.index++];
						} else ++this.index;
						while (!this.eof()) {
							if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) break;
							num += this.source[this.index++];
						}
						if (!octal && num.length === 0) this.throwUnexpectedToken();
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
						return {
							type: 6,
							value: parseInt(num, 8),
							octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.isImplicitOctalLiteral = function() {
						for (var i$2 = this.index + 1; i$2 < this.length; ++i$2) {
							var ch = this.source[i$2];
							if (ch === "8" || ch === "9") return false;
							if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) return true;
						}
						return true;
					};
					Scanner$1.prototype.scanNumericLiteral = function() {
						var start = this.index;
						var ch = this.source[start];
						assert_1$8.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
						var num = "";
						if (ch !== ".") {
							num = this.source[this.index++];
							ch = this.source[this.index];
							if (num === "0") {
								if (ch === "x" || ch === "X") {
									++this.index;
									return this.scanHexLiteral(start);
								}
								if (ch === "b" || ch === "B") {
									++this.index;
									return this.scanBinaryLiteral(start);
								}
								if (ch === "o" || ch === "O") return this.scanOctalLiteral(ch, start);
								if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
									if (this.isImplicitOctalLiteral()) return this.scanOctalLiteral(ch, start);
								}
							}
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) num += this.source[this.index++];
							ch = this.source[this.index];
						}
						if (ch === ".") {
							num += this.source[this.index++];
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) num += this.source[this.index++];
							ch = this.source[this.index];
						}
						if (ch === "e" || ch === "E") {
							num += this.source[this.index++];
							ch = this.source[this.index];
							if (ch === "+" || ch === "-") num += this.source[this.index++];
							if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) num += this.source[this.index++];
							else this.throwUnexpectedToken();
						}
						if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) this.throwUnexpectedToken();
						return {
							type: 6,
							value: parseFloat(num),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanStringLiteral = function() {
						var start = this.index;
						var quote$1 = this.source[start];
						assert_1$8.assert(quote$1 === "'" || quote$1 === "\"", "String literal must starts with a quote");
						++this.index;
						var octal = false;
						var str = "";
						while (!this.eof()) {
							var ch = this.source[this.index++];
							if (ch === quote$1) {
								quote$1 = "";
								break;
							} else if (ch === "\\") {
								ch = this.source[this.index++];
								if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) switch (ch) {
									case "u":
										if (this.source[this.index] === "{") {
											++this.index;
											str += this.scanUnicodeCodePointEscape();
										} else {
											var unescaped_1 = this.scanHexEscape(ch);
											if (unescaped_1 === null) this.throwUnexpectedToken();
											str += unescaped_1;
										}
										break;
									case "x":
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										str += unescaped;
										break;
									case "n":
										str += "\n";
										break;
									case "r":
										str += "\r";
										break;
									case "t":
										str += "	";
										break;
									case "b":
										str += "\b";
										break;
									case "f":
										str += "\f";
										break;
									case "v":
										str += "\v";
										break;
									case "8":
									case "9":
										str += ch;
										this.tolerateUnexpectedToken();
										break;
									default:
										if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											var octToDec = this.octalToDecimal(ch);
											octal = octToDec.octal || octal;
											str += String.fromCharCode(octToDec.code);
										} else str += ch;
										break;
								}
								else {
									++this.lineNumber;
									if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
									this.lineStart = this.index;
								}
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) break;
							else str += ch;
						}
						if (quote$1 !== "") {
							this.index = start;
							this.throwUnexpectedToken();
						}
						return {
							type: 8,
							value: str,
							octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.scanTemplate = function() {
						var cooked = "";
						var terminated = false;
						var start = this.index;
						var head = this.source[start] === "`";
						var tail = false;
						var rawOffset = 2;
						++this.index;
						while (!this.eof()) {
							var ch = this.source[this.index++];
							if (ch === "`") {
								rawOffset = 1;
								tail = true;
								terminated = true;
								break;
							} else if (ch === "$") {
								if (this.source[this.index] === "{") {
									this.curlyStack.push("${");
									++this.index;
									terminated = true;
									break;
								}
								cooked += ch;
							} else if (ch === "\\") {
								ch = this.source[this.index++];
								if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) switch (ch) {
									case "n":
										cooked += "\n";
										break;
									case "r":
										cooked += "\r";
										break;
									case "t":
										cooked += "	";
										break;
									case "u":
										if (this.source[this.index] === "{") {
											++this.index;
											cooked += this.scanUnicodeCodePointEscape();
										} else {
											var restore = this.index;
											var unescaped_2 = this.scanHexEscape(ch);
											if (unescaped_2 !== null) cooked += unescaped_2;
											else {
												this.index = restore;
												cooked += ch;
											}
										}
										break;
									case "x":
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										cooked += unescaped;
										break;
									case "b":
										cooked += "\b";
										break;
									case "f":
										cooked += "\f";
										break;
									case "v":
										cooked += "\v";
										break;
									default:
										if (ch === "0") {
											if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											cooked += "\0";
										} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
										else cooked += ch;
										break;
								}
								else {
									++this.lineNumber;
									if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
									this.lineStart = this.index;
								}
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								++this.lineNumber;
								if (ch === "\r" && this.source[this.index] === "\n") ++this.index;
								this.lineStart = this.index;
								cooked += "\n";
							} else cooked += ch;
						}
						if (!terminated) this.throwUnexpectedToken();
						if (!head) this.curlyStack.pop();
						return {
							type: 10,
							value: this.source.slice(start + 1, this.index - rawOffset),
							cooked,
							head,
							tail,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.testRegExp = function(pattern, flags) {
						var astralSubstitute = "￿";
						var tmp = pattern;
						var self$1 = this;
						if (flags.indexOf("u") >= 0) tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							if (codePoint > 1114111) self$1.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
							if (codePoint <= 65535) return String.fromCharCode(codePoint);
							return astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
						try {
							return new RegExp(pattern, flags);
						} catch (exception) {
							/* istanbul ignore next */
							return null;
						}
					};
					Scanner$1.prototype.scanRegExpBody = function() {
						var ch = this.source[this.index];
						assert_1$8.assert(ch === "/", "Regular expression literal must start with a slash");
						var str = this.source[this.index++];
						var classMarker = false;
						var terminated = false;
						while (!this.eof()) {
							ch = this.source[this.index++];
							str += ch;
							if (ch === "\\") {
								ch = this.source[this.index++];
								if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
								str += ch;
							} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							else if (classMarker) {
								if (ch === "]") classMarker = false;
							} else if (ch === "/") {
								terminated = true;
								break;
							} else if (ch === "[") classMarker = true;
						}
						if (!terminated) this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						return str.substr(1, str.length - 2);
					};
					Scanner$1.prototype.scanRegExpFlags = function() {
						var str = "";
						var flags = "";
						while (!this.eof()) {
							var ch = this.source[this.index];
							if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) break;
							++this.index;
							if (ch === "\\" && !this.eof()) {
								ch = this.source[this.index];
								if (ch === "u") {
									++this.index;
									var restore = this.index;
									var char = this.scanHexEscape("u");
									if (char !== null) {
										flags += char;
										for (str += "\\u"; restore < this.index; ++restore) str += this.source[restore];
									} else {
										this.index = restore;
										flags += "u";
										str += "\\u";
									}
									this.tolerateUnexpectedToken();
								} else {
									str += "\\";
									this.tolerateUnexpectedToken();
								}
							} else {
								flags += ch;
								str += ch;
							}
						}
						return flags;
					};
					Scanner$1.prototype.scanRegExp = function() {
						var start = this.index;
						var pattern = this.scanRegExpBody();
						var flags = this.scanRegExpFlags();
						return {
							type: 9,
							value: "",
							pattern,
							flags,
							regex: this.testRegExp(pattern, flags),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					};
					Scanner$1.prototype.lex = function() {
						if (this.eof()) return {
							type: 2,
							value: "",
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
						var cp = this.source.charCodeAt(this.index);
						if (character_1.Character.isIdentifierStart(cp)) return this.scanIdentifier();
						if (cp === 40 || cp === 41 || cp === 59) return this.scanPunctuator();
						if (cp === 39 || cp === 34) return this.scanStringLiteral();
						if (cp === 46) {
							if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) return this.scanNumericLiteral();
							return this.scanPunctuator();
						}
						if (character_1.Character.isDecimalDigit(cp)) return this.scanNumericLiteral();
						if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") return this.scanTemplate();
						if (cp >= 55296 && cp < 57343) {
							if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) return this.scanIdentifier();
						}
						return this.scanPunctuator();
					};
					return Scanner$1;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.TokenName = {};
				exports$1.TokenName[1] = "Boolean";
				exports$1.TokenName[2] = "<end>";
				exports$1.TokenName[3] = "Identifier";
				exports$1.TokenName[4] = "Keyword";
				exports$1.TokenName[5] = "Null";
				exports$1.TokenName[6] = "Numeric";
				exports$1.TokenName[7] = "Punctuator";
				exports$1.TokenName[8] = "String";
				exports$1.TokenName[9] = "RegularExpression";
				exports$1.TokenName[10] = "Template";
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				exports$1.XHTMLEntities = {
					quot: "\"",
					amp: "&",
					apos: "'",
					gt: ">",
					nbsp: "\xA0",
					iexcl: "¡",
					cent: "¢",
					pound: "£",
					curren: "¤",
					yen: "¥",
					brvbar: "¦",
					sect: "§",
					uml: "¨",
					copy: "©",
					ordf: "ª",
					laquo: "«",
					not: "¬",
					shy: "­",
					reg: "®",
					macr: "¯",
					deg: "°",
					plusmn: "±",
					sup2: "²",
					sup3: "³",
					acute: "´",
					micro: "µ",
					para: "¶",
					middot: "·",
					cedil: "¸",
					sup1: "¹",
					ordm: "º",
					raquo: "»",
					frac14: "¼",
					frac12: "½",
					frac34: "¾",
					iquest: "¿",
					Agrave: "À",
					Aacute: "Á",
					Acirc: "Â",
					Atilde: "Ã",
					Auml: "Ä",
					Aring: "Å",
					AElig: "Æ",
					Ccedil: "Ç",
					Egrave: "È",
					Eacute: "É",
					Ecirc: "Ê",
					Euml: "Ë",
					Igrave: "Ì",
					Iacute: "Í",
					Icirc: "Î",
					Iuml: "Ï",
					ETH: "Ð",
					Ntilde: "Ñ",
					Ograve: "Ò",
					Oacute: "Ó",
					Ocirc: "Ô",
					Otilde: "Õ",
					Ouml: "Ö",
					times: "×",
					Oslash: "Ø",
					Ugrave: "Ù",
					Uacute: "Ú",
					Ucirc: "Û",
					Uuml: "Ü",
					Yacute: "Ý",
					THORN: "Þ",
					szlig: "ß",
					agrave: "à",
					aacute: "á",
					acirc: "â",
					atilde: "ã",
					auml: "ä",
					aring: "å",
					aelig: "æ",
					ccedil: "ç",
					egrave: "è",
					eacute: "é",
					ecirc: "ê",
					euml: "ë",
					igrave: "ì",
					iacute: "í",
					icirc: "î",
					iuml: "ï",
					eth: "ð",
					ntilde: "ñ",
					ograve: "ò",
					oacute: "ó",
					ocirc: "ô",
					otilde: "õ",
					ouml: "ö",
					divide: "÷",
					oslash: "ø",
					ugrave: "ù",
					uacute: "ú",
					ucirc: "û",
					uuml: "ü",
					yacute: "ý",
					thorn: "þ",
					yuml: "ÿ",
					OElig: "Œ",
					oelig: "œ",
					Scaron: "Š",
					scaron: "š",
					Yuml: "Ÿ",
					fnof: "ƒ",
					circ: "ˆ",
					tilde: "˜",
					Alpha: "Α",
					Beta: "Β",
					Gamma: "Γ",
					Delta: "Δ",
					Epsilon: "Ε",
					Zeta: "Ζ",
					Eta: "Η",
					Theta: "Θ",
					Iota: "Ι",
					Kappa: "Κ",
					Lambda: "Λ",
					Mu: "Μ",
					Nu: "Ν",
					Xi: "Ξ",
					Omicron: "Ο",
					Pi: "Π",
					Rho: "Ρ",
					Sigma: "Σ",
					Tau: "Τ",
					Upsilon: "Υ",
					Phi: "Φ",
					Chi: "Χ",
					Psi: "Ψ",
					Omega: "Ω",
					alpha: "α",
					beta: "β",
					gamma: "γ",
					delta: "δ",
					epsilon: "ε",
					zeta: "ζ",
					eta: "η",
					theta: "θ",
					iota: "ι",
					kappa: "κ",
					lambda: "λ",
					mu: "μ",
					nu: "ν",
					xi: "ξ",
					omicron: "ο",
					pi: "π",
					rho: "ρ",
					sigmaf: "ς",
					sigma: "σ",
					tau: "τ",
					upsilon: "υ",
					phi: "φ",
					chi: "χ",
					psi: "ψ",
					omega: "ω",
					thetasym: "ϑ",
					upsih: "ϒ",
					piv: "ϖ",
					ensp: " ",
					emsp: " ",
					thinsp: " ",
					zwnj: "‌",
					zwj: "‍",
					lrm: "‎",
					rlm: "‏",
					ndash: "–",
					mdash: "—",
					lsquo: "‘",
					rsquo: "’",
					sbquo: "‚",
					ldquo: "“",
					rdquo: "”",
					bdquo: "„",
					dagger: "†",
					Dagger: "‡",
					bull: "•",
					hellip: "…",
					permil: "‰",
					prime: "′",
					Prime: "″",
					lsaquo: "‹",
					rsaquo: "›",
					oline: "‾",
					frasl: "⁄",
					euro: "€",
					image: "ℑ",
					weierp: "℘",
					real: "ℜ",
					trade: "™",
					alefsym: "ℵ",
					larr: "←",
					uarr: "↑",
					rarr: "→",
					darr: "↓",
					harr: "↔",
					crarr: "↵",
					lArr: "⇐",
					uArr: "⇑",
					rArr: "⇒",
					dArr: "⇓",
					hArr: "⇔",
					forall: "∀",
					part: "∂",
					exist: "∃",
					empty: "∅",
					nabla: "∇",
					isin: "∈",
					notin: "∉",
					ni: "∋",
					prod: "∏",
					sum: "∑",
					minus: "−",
					lowast: "∗",
					radic: "√",
					prop: "∝",
					infin: "∞",
					ang: "∠",
					and: "∧",
					or: "∨",
					cap: "∩",
					cup: "∪",
					int: "∫",
					there4: "∴",
					sim: "∼",
					cong: "≅",
					asymp: "≈",
					ne: "≠",
					equiv: "≡",
					le: "≤",
					ge: "≥",
					sub: "⊂",
					sup: "⊃",
					nsub: "⊄",
					sube: "⊆",
					supe: "⊇",
					oplus: "⊕",
					otimes: "⊗",
					perp: "⊥",
					sdot: "⋅",
					lceil: "⌈",
					rceil: "⌉",
					lfloor: "⌊",
					rfloor: "⌋",
					loz: "◊",
					spades: "♠",
					clubs: "♣",
					hearts: "♥",
					diams: "♦",
					lang: "⟨",
					rang: "⟩"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: true });
				var error_handler_1 = __webpack_require__(10);
				var scanner_1 = __webpack_require__(12);
				var token_1 = __webpack_require__(13);
				var Reader = function() {
					function Reader$1() {
						this.values = [];
						this.curly = this.paren = -1;
					}
					Reader$1.prototype.beforeFunctionExpression = function(t$1) {
						return [
							"(",
							"{",
							"[",
							"in",
							"typeof",
							"instanceof",
							"new",
							"return",
							"case",
							"delete",
							"throw",
							"void",
							"=",
							"+=",
							"-=",
							"*=",
							"**=",
							"/=",
							"%=",
							"<<=",
							">>=",
							">>>=",
							"&=",
							"|=",
							"^=",
							",",
							"+",
							"-",
							"*",
							"**",
							"/",
							"%",
							"++",
							"--",
							"<<",
							">>",
							">>>",
							"&",
							"|",
							"^",
							"!",
							"~",
							"&&",
							"||",
							"?",
							":",
							"===",
							"==",
							">=",
							"<=",
							"<",
							">",
							"!=",
							"!=="
						].indexOf(t$1) >= 0;
					};
					Reader$1.prototype.isRegexStart = function() {
						var previous = this.values[this.values.length - 1];
						var regex = previous !== null;
						switch (previous) {
							case "this":
							case "]":
								regex = false;
								break;
							case ")":
								var keyword = this.values[this.paren - 1];
								regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
								break;
							case "}":
								regex = false;
								if (this.values[this.curly - 3] === "function") {
									var check = this.values[this.curly - 4];
									regex = check ? !this.beforeFunctionExpression(check) : false;
								} else if (this.values[this.curly - 4] === "function") {
									var check = this.values[this.curly - 5];
									regex = check ? !this.beforeFunctionExpression(check) : true;
								}
								break;
							default: break;
						}
						return regex;
					};
					Reader$1.prototype.push = function(token) {
						if (token.type === 7 || token.type === 4) {
							if (token.value === "{") this.curly = this.values.length;
							else if (token.value === "(") this.paren = this.values.length;
							this.values.push(token.value);
						} else this.values.push(null);
					};
					return Reader$1;
				}();
				exports$1.Tokenizer = function() {
					function Tokenizer(code$1, config$1) {
						this.errorHandler = new error_handler_1.ErrorHandler();
						this.errorHandler.tolerant = config$1 ? typeof config$1.tolerant === "boolean" && config$1.tolerant : false;
						this.scanner = new scanner_1.Scanner(code$1, this.errorHandler);
						this.scanner.trackComment = config$1 ? typeof config$1.comment === "boolean" && config$1.comment : false;
						this.trackRange = config$1 ? typeof config$1.range === "boolean" && config$1.range : false;
						this.trackLoc = config$1 ? typeof config$1.loc === "boolean" && config$1.loc : false;
						this.buffer = [];
						this.reader = new Reader();
					}
					Tokenizer.prototype.errors = function() {
						return this.errorHandler.errors;
					};
					Tokenizer.prototype.getNextToken = function() {
						if (this.buffer.length === 0) {
							var comments = this.scanner.scanComments();
							if (this.scanner.trackComment) for (var i$2 = 0; i$2 < comments.length; ++i$2) {
								var e$1 = comments[i$2];
								var value = this.scanner.source.slice(e$1.slice[0], e$1.slice[1]);
								var comment = {
									type: e$1.multiLine ? "BlockComment" : "LineComment",
									value
								};
								if (this.trackRange) comment.range = e$1.range;
								if (this.trackLoc) comment.loc = e$1.loc;
								this.buffer.push(comment);
							}
							if (!this.scanner.eof()) {
								var loc = void 0;
								if (this.trackLoc) loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								};
								var token = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex();
								this.reader.push(token);
								var entry = {
									type: token_1.TokenName[token.type],
									value: this.scanner.source.slice(token.start, token.end)
								};
								if (this.trackRange) entry.range = [token.start, token.end];
								if (this.trackLoc) {
									loc.end = {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									};
									entry.loc = loc;
								}
								if (token.type === 9) entry.regex = {
									pattern: token.pattern,
									flags: token.flags
								};
								this.buffer.push(entry);
							}
						}
						return this.buffer.shift();
					};
					return Tokenizer;
				}();
			}
		]);
	});
}));
var require_esprima$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var util_1$5 = require_util();
	function parse$5(source, options) {
		var comments = [];
		var ast = require_esprima$2().parse(source, {
			loc: true,
			locations: true,
			comment: true,
			onComment: comments,
			range: util_1$5.getOption(options, "range", false),
			tolerant: util_1$5.getOption(options, "tolerant", true),
			tokens: true,
			jsx: util_1$5.getOption(options, "jsx", false),
			sourceType: util_1$5.getOption(options, "sourceType", "module")
		});
		if (!Array.isArray(ast.comments)) ast.comments = comments;
		return ast;
	}
	exports.parse = parse$5;
}));
var require_options = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var util_1$4 = require_util();
	var defaults = {
		parser: require_esprima$1(),
		tabWidth: 4,
		useTabs: false,
		reuseWhitespace: true,
		lineTerminator: util_1$4.getLineTerminator(),
		wrapColumn: 74,
		sourceFileName: null,
		sourceMapName: null,
		sourceRoot: null,
		inputSourceMap: null,
		range: false,
		tolerant: true,
		quote: null,
		trailingComma: false,
		arrayBracketSpacing: false,
		objectCurlySpacing: true,
		arrowParensAlways: false,
		flowObjectCommas: true,
		tokens: true
	};
	var hasOwn$5 = defaults.hasOwnProperty;
	function normalize(opts) {
		var options = opts || defaults;
		function get$2(key) {
			return hasOwn$5.call(options, key) ? options[key] : defaults[key];
		}
		return {
			tabWidth: +get$2("tabWidth"),
			useTabs: !!get$2("useTabs"),
			reuseWhitespace: !!get$2("reuseWhitespace"),
			lineTerminator: get$2("lineTerminator"),
			wrapColumn: Math.max(get$2("wrapColumn"), 0),
			sourceFileName: get$2("sourceFileName"),
			sourceMapName: get$2("sourceMapName"),
			sourceRoot: get$2("sourceRoot"),
			inputSourceMap: get$2("inputSourceMap"),
			parser: get$2("esprima") || get$2("parser"),
			range: get$2("range"),
			tolerant: get$2("tolerant"),
			quote: get$2("quote"),
			trailingComma: get$2("trailingComma"),
			arrayBracketSpacing: get$2("arrayBracketSpacing"),
			objectCurlySpacing: get$2("objectCurlySpacing"),
			arrowParensAlways: get$2("arrowParensAlways"),
			flowObjectCommas: get$2("flowObjectCommas"),
			tokens: !!get$2("tokens")
		};
	}
	exports.normalize = normalize;
}));
var require_mapping = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1$6 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1)).__importDefault(require_assert());
	var util_1$3 = require_util();
	exports.default = function() {
		function Mapping$2(sourceLines, sourceLoc, targetLoc) {
			if (targetLoc === void 0) targetLoc = sourceLoc;
			this.sourceLines = sourceLines;
			this.sourceLoc = sourceLoc;
			this.targetLoc = targetLoc;
		}
		Mapping$2.prototype.slice = function(lines, start, end) {
			if (end === void 0) end = lines.lastPos();
			var sourceLines = this.sourceLines;
			var sourceLoc = this.sourceLoc;
			var targetLoc = this.targetLoc;
			function skip(name) {
				var sourceFromPos = sourceLoc[name];
				var targetFromPos = targetLoc[name];
				var targetToPos = start;
				if (name === "end") targetToPos = end;
				else assert_1$6.default.strictEqual(name, "start");
				return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
			}
			if (util_1$3.comparePos(start, targetLoc.start) <= 0) if (util_1$3.comparePos(targetLoc.end, end) <= 0) targetLoc = {
				start: subtractPos(targetLoc.start, start.line, start.column),
				end: subtractPos(targetLoc.end, start.line, start.column)
			};
			else if (util_1$3.comparePos(end, targetLoc.start) <= 0) return null;
			else {
				sourceLoc = {
					start: sourceLoc.start,
					end: skip("end")
				};
				targetLoc = {
					start: subtractPos(targetLoc.start, start.line, start.column),
					end: subtractPos(end, start.line, start.column)
				};
			}
			else {
				if (util_1$3.comparePos(targetLoc.end, start) <= 0) return null;
				if (util_1$3.comparePos(targetLoc.end, end) <= 0) {
					sourceLoc = {
						start: skip("start"),
						end: sourceLoc.end
					};
					targetLoc = {
						start: {
							line: 1,
							column: 0
						},
						end: subtractPos(targetLoc.end, start.line, start.column)
					};
				} else {
					sourceLoc = {
						start: skip("start"),
						end: skip("end")
					};
					targetLoc = {
						start: {
							line: 1,
							column: 0
						},
						end: subtractPos(end, start.line, start.column)
					};
				}
			}
			return new Mapping$2(this.sourceLines, sourceLoc, targetLoc);
		};
		Mapping$2.prototype.add = function(line, column) {
			return new Mapping$2(this.sourceLines, this.sourceLoc, {
				start: addPos(this.targetLoc.start, line, column),
				end: addPos(this.targetLoc.end, line, column)
			});
		};
		Mapping$2.prototype.subtract = function(line, column) {
			return new Mapping$2(this.sourceLines, this.sourceLoc, {
				start: subtractPos(this.targetLoc.start, line, column),
				end: subtractPos(this.targetLoc.end, line, column)
			});
		};
		Mapping$2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
			if (skipFirstLine === void 0) skipFirstLine = false;
			if (noNegativeColumns === void 0) noNegativeColumns = false;
			if (by === 0) return this;
			var targetLoc = this.targetLoc;
			var startLine = targetLoc.start.line;
			var endLine = targetLoc.end.line;
			if (skipFirstLine && startLine === 1 && endLine === 1) return this;
			targetLoc = {
				start: targetLoc.start,
				end: targetLoc.end
			};
			if (!skipFirstLine || startLine > 1) {
				var startColumn = targetLoc.start.column + by;
				targetLoc.start = {
					line: startLine,
					column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
				};
			}
			if (!skipFirstLine || endLine > 1) {
				var endColumn = targetLoc.end.column + by;
				targetLoc.end = {
					line: endLine,
					column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
				};
			}
			return new Mapping$2(this.sourceLines, this.sourceLoc, targetLoc);
		};
		return Mapping$2;
	}();
	function addPos(toPos, line, column) {
		return {
			line: toPos.line + line - 1,
			column: toPos.line === 1 ? toPos.column + column : toPos.column
		};
	}
	function subtractPos(fromPos, line, column) {
		return {
			line: fromPos.line - line + 1,
			column: fromPos.line === line ? fromPos.column - column : fromPos.column
		};
	}
	function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
		var targetComparison = util_1$3.comparePos(targetFromPos, targetToPos);
		if (targetComparison === 0) return sourceFromPos;
		var sourceCursor, targetCursor;
		if (targetComparison < 0) {
			sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
			targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
			var lineDiff = targetToPos.line - targetCursor.line;
			sourceCursor.line += lineDiff;
			targetCursor.line += lineDiff;
			if (lineDiff > 0) {
				sourceCursor.column = 0;
				targetCursor.column = 0;
			} else assert_1$6.default.strictEqual(lineDiff, 0);
			while (util_1$3.comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
				assert_1$6.default.ok(sourceLines.nextPos(sourceCursor, true));
				assert_1$6.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
			}
		} else {
			sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
			targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
			var lineDiff = targetToPos.line - targetCursor.line;
			sourceCursor.line += lineDiff;
			targetCursor.line += lineDiff;
			if (lineDiff < 0) {
				sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
				targetCursor.column = targetLines.getLineLength(targetCursor.line);
			} else assert_1$6.default.strictEqual(lineDiff, 0);
			while (util_1$3.comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
				assert_1$6.default.ok(sourceLines.prevPos(sourceCursor, true));
				assert_1$6.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
			}
		}
		return sourceCursor;
	}
}));
var require_lines = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$34 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$5 = tslib_1$34.__importDefault(require_assert());
	var source_map_1 = tslib_1$34.__importDefault(require_source_map());
	var options_1$2 = require_options();
	var util_1$2 = require_util();
	var mapping_1 = tslib_1$34.__importDefault(require_mapping());
	var Lines = function() {
		function Lines$1(infos, sourceFileName) {
			if (sourceFileName === void 0) sourceFileName = null;
			this.infos = infos;
			this.mappings = [];
			this.cachedSourceMap = null;
			this.cachedTabWidth = void 0;
			assert_1$5.default.ok(infos.length > 0);
			this.length = infos.length;
			this.name = sourceFileName || null;
			if (this.name) this.mappings.push(new mapping_1.default(this, {
				start: this.firstPos(),
				end: this.lastPos()
			}));
		}
		Lines$1.prototype.toString = function(options) {
			return this.sliceString(this.firstPos(), this.lastPos(), options);
		};
		Lines$1.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
			if (!sourceMapName) return null;
			var targetLines = this;
			function updateJSON(json) {
				json = json || {};
				json.file = sourceMapName;
				if (sourceRoot) json.sourceRoot = sourceRoot;
				return json;
			}
			if (targetLines.cachedSourceMap) return updateJSON(targetLines.cachedSourceMap.toJSON());
			var smg = new source_map_1.default.SourceMapGenerator(updateJSON());
			var sourcesToContents = {};
			targetLines.mappings.forEach(function(mapping) {
				var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();
				var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();
				while (util_1$2.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && util_1$2.comparePos(targetCursor, mapping.targetLoc.end) < 0) {
					var sourceChar = mapping.sourceLines.charAt(sourceCursor);
					var targetChar = targetLines.charAt(targetCursor);
					assert_1$5.default.strictEqual(sourceChar, targetChar);
					var sourceName = mapping.sourceLines.name;
					smg.addMapping({
						source: sourceName,
						original: {
							line: sourceCursor.line,
							column: sourceCursor.column
						},
						generated: {
							line: targetCursor.line,
							column: targetCursor.column
						}
					});
					if (!hasOwn$4.call(sourcesToContents, sourceName)) {
						var sourceContent = mapping.sourceLines.toString();
						smg.setSourceContent(sourceName, sourceContent);
						sourcesToContents[sourceName] = sourceContent;
					}
					targetLines.nextPos(targetCursor, true);
					mapping.sourceLines.nextPos(sourceCursor, true);
				}
			});
			targetLines.cachedSourceMap = smg;
			return smg.toJSON();
		};
		Lines$1.prototype.bootstrapCharAt = function(pos) {
			assert_1$5.default.strictEqual(typeof pos, "object");
			assert_1$5.default.strictEqual(typeof pos.line, "number");
			assert_1$5.default.strictEqual(typeof pos.column, "number");
			var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];
			if (typeof string === "undefined") return "";
			if (column === string.length && line < strings.length) return "\n";
			if (column >= string.length) return "";
			return string.charAt(column);
		};
		Lines$1.prototype.charAt = function(pos) {
			assert_1$5.default.strictEqual(typeof pos, "object");
			assert_1$5.default.strictEqual(typeof pos.line, "number");
			assert_1$5.default.strictEqual(typeof pos.column, "number");
			var line = pos.line, column = pos.column, info = this.infos[line - 1], c$1 = column;
			if (typeof info === "undefined" || c$1 < 0) return "";
			var indent = this.getIndentAt(line);
			if (c$1 < indent) return " ";
			c$1 += info.sliceStart - indent;
			if (c$1 === info.sliceEnd && line < this.length) return "\n";
			if (c$1 >= info.sliceEnd) return "";
			return info.line.charAt(c$1);
		};
		Lines$1.prototype.stripMargin = function(width, skipFirstLine) {
			if (width === 0) return this;
			assert_1$5.default.ok(width > 0, "negative margin: " + width);
			if (skipFirstLine && this.length === 1) return this;
			var lines = new Lines$1(this.infos.map(function(info, i$2) {
				if (info.line && (i$2 > 0 || !skipFirstLine)) info = tslib_1$34.__assign(tslib_1$34.__assign({}, info), { indent: Math.max(0, info.indent - width) });
				return info;
			}));
			if (this.mappings.length > 0) {
				var newMappings_1 = lines.mappings;
				assert_1$5.default.strictEqual(newMappings_1.length, 0);
				this.mappings.forEach(function(mapping) {
					newMappings_1.push(mapping.indent(width, skipFirstLine, true));
				});
			}
			return lines;
		};
		Lines$1.prototype.indent = function(by) {
			if (by === 0) return this;
			var lines = new Lines$1(this.infos.map(function(info) {
				if (info.line && !info.locked) info = tslib_1$34.__assign(tslib_1$34.__assign({}, info), { indent: info.indent + by });
				return info;
			}));
			if (this.mappings.length > 0) {
				var newMappings_2 = lines.mappings;
				assert_1$5.default.strictEqual(newMappings_2.length, 0);
				this.mappings.forEach(function(mapping) {
					newMappings_2.push(mapping.indent(by));
				});
			}
			return lines;
		};
		Lines$1.prototype.indentTail = function(by) {
			if (by === 0) return this;
			if (this.length < 2) return this;
			var lines = new Lines$1(this.infos.map(function(info, i$2) {
				if (i$2 > 0 && info.line && !info.locked) info = tslib_1$34.__assign(tslib_1$34.__assign({}, info), { indent: info.indent + by });
				return info;
			}));
			if (this.mappings.length > 0) {
				var newMappings_3 = lines.mappings;
				assert_1$5.default.strictEqual(newMappings_3.length, 0);
				this.mappings.forEach(function(mapping) {
					newMappings_3.push(mapping.indent(by, true));
				});
			}
			return lines;
		};
		Lines$1.prototype.lockIndentTail = function() {
			if (this.length < 2) return this;
			return new Lines$1(this.infos.map(function(info, i$2) {
				return tslib_1$34.__assign(tslib_1$34.__assign({}, info), { locked: i$2 > 0 });
			}));
		};
		Lines$1.prototype.getIndentAt = function(line) {
			assert_1$5.default.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
			return Math.max(this.infos[line - 1].indent, 0);
		};
		Lines$1.prototype.guessTabWidth = function() {
			if (typeof this.cachedTabWidth === "number") return this.cachedTabWidth;
			var counts = [];
			var lastIndent = 0;
			for (var line = 1, last$1 = this.length; line <= last$1; ++line) {
				var info = this.infos[line - 1];
				if (isOnlyWhitespace(info.line.slice(info.sliceStart, info.sliceEnd))) continue;
				var diff = Math.abs(info.indent - lastIndent);
				counts[diff] = ~~counts[diff] + 1;
				lastIndent = info.indent;
			}
			var maxCount = -1;
			var result = 2;
			for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) if (hasOwn$4.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
				maxCount = counts[tabWidth];
				result = tabWidth;
			}
			return this.cachedTabWidth = result;
		};
		Lines$1.prototype.startsWithComment = function() {
			if (this.infos.length === 0) return false;
			var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
			return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
		};
		Lines$1.prototype.isOnlyWhitespace = function() {
			return isOnlyWhitespace(this.toString());
		};
		Lines$1.prototype.isPrecededOnlyByWhitespace = function(pos) {
			var info = this.infos[pos.line - 1];
			var indent = Math.max(info.indent, 0);
			var diff = pos.column - indent;
			if (diff <= 0) return true;
			var start = info.sliceStart;
			var end = Math.min(start + diff, info.sliceEnd);
			return isOnlyWhitespace(info.line.slice(start, end));
		};
		Lines$1.prototype.getLineLength = function(line) {
			var info = this.infos[line - 1];
			return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
		};
		Lines$1.prototype.nextPos = function(pos, skipSpaces) {
			if (skipSpaces === void 0) skipSpaces = false;
			var l$2 = Math.max(pos.line, 0);
			if (Math.max(pos.column, 0) < this.getLineLength(l$2)) {
				pos.column += 1;
				return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
			}
			if (l$2 < this.length) {
				pos.line += 1;
				pos.column = 0;
				return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
			}
			return false;
		};
		Lines$1.prototype.prevPos = function(pos, skipSpaces) {
			if (skipSpaces === void 0) skipSpaces = false;
			var l$2 = pos.line, c$1 = pos.column;
			if (c$1 < 1) {
				l$2 -= 1;
				if (l$2 < 1) return false;
				c$1 = this.getLineLength(l$2);
			} else c$1 = Math.min(c$1 - 1, this.getLineLength(l$2));
			pos.line = l$2;
			pos.column = c$1;
			return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
		};
		Lines$1.prototype.firstPos = function() {
			return {
				line: 1,
				column: 0
			};
		};
		Lines$1.prototype.lastPos = function() {
			return {
				line: this.length,
				column: this.getLineLength(this.length)
			};
		};
		Lines$1.prototype.skipSpaces = function(pos, backward, modifyInPlace) {
			if (backward === void 0) backward = false;
			if (modifyInPlace === void 0) modifyInPlace = false;
			if (pos) pos = modifyInPlace ? pos : {
				line: pos.line,
				column: pos.column
			};
			else if (backward) pos = this.lastPos();
			else pos = this.firstPos();
			if (backward) {
				while (this.prevPos(pos)) if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) return pos;
				return null;
			} else {
				while (isOnlyWhitespace(this.charAt(pos))) if (!this.nextPos(pos)) return null;
				return pos;
			}
		};
		Lines$1.prototype.trimLeft = function() {
			var pos = this.skipSpaces(this.firstPos(), false, true);
			return pos ? this.slice(pos) : emptyLines;
		};
		Lines$1.prototype.trimRight = function() {
			var pos = this.skipSpaces(this.lastPos(), true, true);
			return pos ? this.slice(this.firstPos(), pos) : emptyLines;
		};
		Lines$1.prototype.trim = function() {
			var start = this.skipSpaces(this.firstPos(), false, true);
			if (start === null) return emptyLines;
			var end = this.skipSpaces(this.lastPos(), true, true);
			if (end === null) return emptyLines;
			return this.slice(start, end);
		};
		Lines$1.prototype.eachPos = function(callback, startPos, skipSpaces) {
			if (startPos === void 0) startPos = this.firstPos();
			if (skipSpaces === void 0) skipSpaces = false;
			var pos = this.firstPos();
			if (startPos) pos.line = startPos.line, pos.column = startPos.column;
			if (skipSpaces && !this.skipSpaces(pos, false, true)) return;
			do
				callback.call(this, pos);
			while (this.nextPos(pos, skipSpaces));
		};
		Lines$1.prototype.bootstrapSlice = function(start, end) {
			var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
			if (strings.length > 0) {
				strings.push(strings.pop().slice(0, end.column));
				strings[0] = strings[0].slice(start.column);
			}
			return fromString(strings.join("\n"));
		};
		Lines$1.prototype.slice = function(start, end) {
			if (!end) {
				if (!start) return this;
				end = this.lastPos();
			}
			if (!start) throw new Error("cannot slice with end but not start");
			var sliced = this.infos.slice(start.line - 1, end.line);
			if (start.line === end.line) sliced[0] = sliceInfo(sliced[0], start.column, end.column);
			else {
				assert_1$5.default.ok(start.line < end.line);
				sliced[0] = sliceInfo(sliced[0], start.column);
				sliced.push(sliceInfo(sliced.pop(), 0, end.column));
			}
			var lines = new Lines$1(sliced);
			if (this.mappings.length > 0) {
				var newMappings_4 = lines.mappings;
				assert_1$5.default.strictEqual(newMappings_4.length, 0);
				this.mappings.forEach(function(mapping) {
					var sliced$1 = mapping.slice(this, start, end);
					if (sliced$1) newMappings_4.push(sliced$1);
				}, this);
			}
			return lines;
		};
		Lines$1.prototype.bootstrapSliceString = function(start, end, options) {
			return this.slice(start, end).toString(options);
		};
		Lines$1.prototype.sliceString = function(start, end, options) {
			if (start === void 0) start = this.firstPos();
			if (end === void 0) end = this.lastPos();
			var _a$2 = options_1$2.normalize(options), tabWidth = _a$2.tabWidth, useTabs = _a$2.useTabs, reuseWhitespace = _a$2.reuseWhitespace, lineTerminator = _a$2.lineTerminator;
			var parts = [];
			for (var line = start.line; line <= end.line; ++line) {
				var info = this.infos[line - 1];
				if (line === start.line) if (line === end.line) info = sliceInfo(info, start.column, end.column);
				else info = sliceInfo(info, start.column);
				else if (line === end.line) info = sliceInfo(info, 0, end.column);
				var indent = Math.max(info.indent, 0);
				var before_1 = info.line.slice(0, info.sliceStart);
				if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {
					parts.push(info.line.slice(0, info.sliceEnd));
					continue;
				}
				var tabs = 0;
				var spaces = indent;
				if (useTabs) {
					tabs = Math.floor(indent / tabWidth);
					spaces -= tabs * tabWidth;
				}
				var result = "";
				if (tabs > 0) result += new Array(tabs + 1).join("	");
				if (spaces > 0) result += new Array(spaces + 1).join(" ");
				result += info.line.slice(info.sliceStart, info.sliceEnd);
				parts.push(result);
			}
			return parts.join(lineTerminator);
		};
		Lines$1.prototype.isEmpty = function() {
			return this.length < 2 && this.getLineLength(1) < 1;
		};
		Lines$1.prototype.join = function(elements) {
			var separator = this;
			var infos = [];
			var mappings = [];
			var prevInfo;
			function appendLines(linesOrNull) {
				if (linesOrNull === null) return;
				if (prevInfo) {
					var info = linesOrNull.infos[0];
					var indent = new Array(info.indent + 1).join(" ");
					var prevLine_1 = infos.length;
					var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
					prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);
					prevInfo.locked = prevInfo.locked || info.locked;
					prevInfo.sliceEnd = prevInfo.line.length;
					if (linesOrNull.mappings.length > 0) linesOrNull.mappings.forEach(function(mapping) {
						mappings.push(mapping.add(prevLine_1, prevColumn_1));
					});
				} else if (linesOrNull.mappings.length > 0) mappings.push.apply(mappings, linesOrNull.mappings);
				linesOrNull.infos.forEach(function(info$1, i$2) {
					if (!prevInfo || i$2 > 0) {
						prevInfo = tslib_1$34.__assign({}, info$1);
						infos.push(prevInfo);
					}
				});
			}
			function appendWithSeparator(linesOrNull, i$2) {
				if (i$2 > 0) appendLines(separator);
				appendLines(linesOrNull);
			}
			elements.map(function(elem) {
				var lines$1 = fromString(elem);
				if (lines$1.isEmpty()) return null;
				return lines$1;
			}).forEach(function(linesOrNull, i$2) {
				if (separator.isEmpty()) appendLines(linesOrNull);
				else appendWithSeparator(linesOrNull, i$2);
			});
			if (infos.length < 1) return emptyLines;
			var lines = new Lines$1(infos);
			lines.mappings = mappings;
			return lines;
		};
		Lines$1.prototype.concat = function() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var list = [this];
			list.push.apply(list, args);
			assert_1$5.default.strictEqual(list.length, args.length + 1);
			return emptyLines.join(list);
		};
		return Lines$1;
	}();
	exports.Lines = Lines;
	var fromStringCache = {};
	var hasOwn$4 = fromStringCache.hasOwnProperty;
	var maxCacheKeyLen = 10;
	function countSpaces(spaces, tabWidth) {
		var count = 0;
		var len$1 = spaces.length;
		for (var i$2 = 0; i$2 < len$1; ++i$2) switch (spaces.charCodeAt(i$2)) {
			case 9:
				assert_1$5.default.strictEqual(typeof tabWidth, "number");
				assert_1$5.default.ok(tabWidth > 0);
				var next = Math.ceil(count / tabWidth) * tabWidth;
				if (next === count) count += tabWidth;
				else count = next;
				break;
			case 11:
			case 12:
			case 13:
			case 65279: break;
			case 32:
			default:
				count += 1;
				break;
		}
		return count;
	}
	exports.countSpaces = countSpaces;
	var leadingSpaceExp = /^\s*/;
	var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
	function fromString(string, options) {
		if (string instanceof Lines) return string;
		string += "";
		var tabWidth = options && options.tabWidth;
		var tabless = string.indexOf("	") < 0;
		var cacheable = !options && tabless && string.length <= maxCacheKeyLen;
		assert_1$5.default.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
		if (cacheable && hasOwn$4.call(fromStringCache, string)) return fromStringCache[string];
		var lines = new Lines(string.split(lineTerminatorSeqExp).map(function(line) {
			var spaces = leadingSpaceExp.exec(line)[0];
			return {
				line,
				indent: countSpaces(spaces, tabWidth),
				locked: false,
				sliceStart: spaces.length,
				sliceEnd: line.length
			};
		}), options_1$2.normalize(options).sourceFileName);
		if (cacheable) fromStringCache[string] = lines;
		return lines;
	}
	exports.fromString = fromString;
	function isOnlyWhitespace(string) {
		return !/\S/.test(string);
	}
	function sliceInfo(info, startCol, endCol) {
		var sliceStart = info.sliceStart;
		var sliceEnd = info.sliceEnd;
		var indent = Math.max(info.indent, 0);
		var lineLength = indent + sliceEnd - sliceStart;
		if (typeof endCol === "undefined") endCol = lineLength;
		startCol = Math.max(startCol, 0);
		endCol = Math.min(endCol, lineLength);
		endCol = Math.max(endCol, startCol);
		if (endCol < indent) {
			indent = endCol;
			sliceEnd = sliceStart;
		} else sliceEnd -= lineLength - endCol;
		lineLength = endCol;
		lineLength -= startCol;
		if (startCol < indent) indent -= startCol;
		else {
			startCol -= indent;
			indent = 0;
			sliceStart += startCol;
		}
		assert_1$5.default.ok(indent >= 0);
		assert_1$5.default.ok(sliceStart <= sliceEnd);
		assert_1$5.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);
		if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) return info;
		return {
			line: info.line,
			indent,
			locked: false,
			sliceStart,
			sliceEnd
		};
	}
	function concat(elements) {
		return emptyLines.join(elements);
	}
	exports.concat = concat;
	var emptyLines = fromString("");
}));
var require_comments = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$33 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$4 = tslib_1$33.__importDefault(require_assert());
	var types$7 = tslib_1$33.__importStar(require_main$2());
	var n$2 = types$7.namedTypes;
	var isArray$6 = types$7.builtInTypes.array;
	var isObject$5 = types$7.builtInTypes.object;
	var lines_1$2 = require_lines();
	var util_1$1 = require_util();
	var childNodesCache = /* @__PURE__ */ new WeakMap();
	function getSortedChildNodes(node, lines, resultArray) {
		if (!node) return resultArray;
		util_1$1.fixFaultyLocations(node, lines);
		if (resultArray) {
			if (n$2.Node.check(node) && n$2.SourceLocation.check(node.loc)) {
				var i$2 = resultArray.length - 1;
				for (; i$2 >= 0; --i$2) {
					var child = resultArray[i$2];
					if (child && child.loc && util_1$1.comparePos(child.loc.end, node.loc.start) <= 0) break;
				}
				resultArray.splice(i$2 + 1, 0, node);
				return resultArray;
			}
		} else {
			var childNodes = childNodesCache.get(node);
			if (childNodes) return childNodes;
		}
		var names;
		if (isArray$6.check(node)) names = Object.keys(node);
		else if (isObject$5.check(node)) names = types$7.getFieldNames(node);
		else return resultArray;
		if (!resultArray) childNodesCache.set(node, resultArray = []);
		for (var i$2 = 0, nameCount = names.length; i$2 < nameCount; ++i$2) getSortedChildNodes(node[names[i$2]], lines, resultArray);
		return resultArray;
	}
	function decorateComment(node, comment, lines) {
		var childNodes = getSortedChildNodes(node, lines);
		var left = 0;
		var right = childNodes && childNodes.length;
		var precedingNode;
		var followingNode;
		while (typeof right === "number" && left < right) {
			var middle = left + right >> 1;
			var child = childNodes[middle];
			if (util_1$1.comparePos(child.loc.start, comment.loc.start) <= 0 && util_1$1.comparePos(comment.loc.end, child.loc.end) <= 0) {
				decorateComment(comment.enclosingNode = child, comment, lines);
				return;
			}
			if (util_1$1.comparePos(child.loc.end, comment.loc.start) <= 0) {
				precedingNode = child;
				left = middle + 1;
				continue;
			}
			if (util_1$1.comparePos(comment.loc.end, child.loc.start) <= 0) {
				followingNode = child;
				right = middle;
				continue;
			}
			throw new Error("Comment location overlaps with node location");
		}
		if (precedingNode) comment.precedingNode = precedingNode;
		if (followingNode) comment.followingNode = followingNode;
	}
	function attach(comments, ast, lines) {
		if (!isArray$6.check(comments)) return;
		var tiesToBreak = [];
		comments.forEach(function(comment) {
			comment.loc.lines = lines;
			decorateComment(ast, comment, lines);
			var pn = comment.precedingNode;
			var en = comment.enclosingNode;
			var fn$1 = comment.followingNode;
			if (pn && fn$1) {
				var tieCount = tiesToBreak.length;
				if (tieCount > 0) {
					var lastTie = tiesToBreak[tieCount - 1];
					assert_1$4.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);
					if (lastTie.followingNode !== comment.followingNode) breakTies(tiesToBreak, lines);
				}
				tiesToBreak.push(comment);
			} else if (pn) {
				breakTies(tiesToBreak, lines);
				addTrailingComment(pn, comment);
			} else if (fn$1) {
				breakTies(tiesToBreak, lines);
				addLeadingComment(fn$1, comment);
			} else if (en) {
				breakTies(tiesToBreak, lines);
				addDanglingComment(en, comment);
			} else throw new Error("AST contains no nodes at all?");
		});
		breakTies(tiesToBreak, lines);
		comments.forEach(function(comment) {
			delete comment.precedingNode;
			delete comment.enclosingNode;
			delete comment.followingNode;
		});
	}
	exports.attach = attach;
	function breakTies(tiesToBreak, lines) {
		var tieCount = tiesToBreak.length;
		if (tieCount === 0) return;
		var pn = tiesToBreak[0].precedingNode;
		var fn$1 = tiesToBreak[0].followingNode;
		var gapEndPos = fn$1.loc.start;
		var indexOfFirstLeadingComment = tieCount;
		var comment;
		for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
			comment = tiesToBreak[indexOfFirstLeadingComment - 1];
			assert_1$4.default.strictEqual(comment.precedingNode, pn);
			assert_1$4.default.strictEqual(comment.followingNode, fn$1);
			var gap = lines.sliceString(comment.loc.end, gapEndPos);
			if (/\S/.test(gap)) break;
			gapEndPos = comment.loc.start;
		}
		while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && (comment.type === "Line" || comment.type === "CommentLine") && comment.loc.start.column > fn$1.loc.start.column) ++indexOfFirstLeadingComment;
		tiesToBreak.forEach(function(comment$1, i$2) {
			if (i$2 < indexOfFirstLeadingComment) addTrailingComment(pn, comment$1);
			else addLeadingComment(fn$1, comment$1);
		});
		tiesToBreak.length = 0;
	}
	function addCommentHelper(node, comment) {
		(node.comments || (node.comments = [])).push(comment);
	}
	function addLeadingComment(node, comment) {
		comment.leading = true;
		comment.trailing = false;
		addCommentHelper(node, comment);
	}
	function addDanglingComment(node, comment) {
		comment.leading = false;
		comment.trailing = false;
		addCommentHelper(node, comment);
	}
	function addTrailingComment(node, comment) {
		comment.leading = false;
		comment.trailing = true;
		addCommentHelper(node, comment);
	}
	function printLeadingComment(commentPath, print$4) {
		var comment = commentPath.getValue();
		n$2.Comment.assert(comment);
		var loc = comment.loc;
		var lines = loc && loc.lines;
		var parts = [print$4(commentPath)];
		if (comment.trailing) parts.push("\n");
		else if (lines instanceof lines_1$2.Lines) {
			var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());
			if (trailingSpace.length === 1) parts.push(trailingSpace);
			else parts.push(new Array(trailingSpace.length).join("\n"));
		} else parts.push("\n");
		return lines_1$2.concat(parts);
	}
	function printTrailingComment(commentPath, print$4) {
		var comment = commentPath.getValue(commentPath);
		n$2.Comment.assert(comment);
		var loc = comment.loc;
		var lines = loc && loc.lines;
		var parts = [];
		if (lines instanceof lines_1$2.Lines) {
			var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
			var leadingSpace = lines.slice(fromPos, loc.start);
			if (leadingSpace.length === 1) parts.push(leadingSpace);
			else parts.push(new Array(leadingSpace.length).join("\n"));
		}
		parts.push(print$4(commentPath));
		return lines_1$2.concat(parts);
	}
	function printComments(path, print$4) {
		var value = path.getValue();
		var innerLines = print$4(path);
		var comments = n$2.Node.check(value) && types$7.getFieldValue(value, "comments");
		if (!comments || comments.length === 0) return innerLines;
		var leadingParts = [];
		var trailingParts = [innerLines];
		path.each(function(commentPath) {
			var comment = commentPath.getValue();
			var leading = types$7.getFieldValue(comment, "leading");
			var trailing = types$7.getFieldValue(comment, "trailing");
			if (leading || trailing && !(n$2.Statement.check(value) || comment.type === "Block" || comment.type === "CommentBlock")) leadingParts.push(printLeadingComment(commentPath, print$4));
			else if (trailing) trailingParts.push(printTrailingComment(commentPath, print$4));
		}, "comments");
		leadingParts.push.apply(leadingParts, trailingParts);
		return lines_1$2.concat(leadingParts);
	}
	exports.printComments = printComments;
}));
var require_parser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$32 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$3 = tslib_1$32.__importDefault(require_assert());
	var types$6 = tslib_1$32.__importStar(require_main$2());
	var b$4 = types$6.builders;
	var isObject$4 = types$6.builtInTypes.object;
	var isArray$5 = types$6.builtInTypes.array;
	var options_1$1 = require_options();
	var lines_1$1 = require_lines();
	var comments_1$1 = require_comments();
	var util$3 = tslib_1$32.__importStar(require_util());
	function parse$4(source, options) {
		options = options_1$1.normalize(options);
		var lines = lines_1$1.fromString(source, options);
		var sourceWithoutTabs = lines.toString({
			tabWidth: options.tabWidth,
			reuseWhitespace: false,
			useTabs: false
		});
		var comments = [];
		var ast = options.parser.parse(sourceWithoutTabs, {
			jsx: true,
			loc: true,
			locations: true,
			range: options.range,
			comment: true,
			onComment: comments,
			tolerant: util$3.getOption(options, "tolerant", true),
			ecmaVersion: 6,
			sourceType: util$3.getOption(options, "sourceType", "module")
		});
		var tokens = Array.isArray(ast.tokens) ? ast.tokens : require_esprima$2().tokenize(sourceWithoutTabs, { loc: true });
		delete ast.tokens;
		tokens.forEach(function(token) {
			if (typeof token.value !== "string") token.value = lines.sliceString(token.loc.start, token.loc.end);
		});
		if (Array.isArray(ast.comments)) {
			comments = ast.comments;
			delete ast.comments;
		}
		if (ast.loc) util$3.fixFaultyLocations(ast, lines);
		else ast.loc = {
			start: lines.firstPos(),
			end: lines.lastPos()
		};
		ast.loc.lines = lines;
		ast.loc.indent = 0;
		var file;
		var program;
		if (ast.type === "Program") {
			program = ast;
			file = b$4.file(ast, options.sourceFileName || null);
			file.loc = {
				start: lines.firstPos(),
				end: lines.lastPos(),
				lines,
				indent: 0
			};
		} else if (ast.type === "File") {
			file = ast;
			program = file.program;
		}
		if (options.tokens) file.tokens = tokens;
		var trueProgramLoc = util$3.getTrueLoc({
			type: program.type,
			loc: program.loc,
			body: [],
			comments
		}, lines);
		program.loc.start = trueProgramLoc.start;
		program.loc.end = trueProgramLoc.end;
		comments_1$1.attach(comments, program.body.length ? file.program : file, lines);
		return new TreeCopier(lines, tokens).copy(file);
	}
	exports.parse = parse$4;
	var TreeCopier = function TreeCopier$1(lines, tokens) {
		assert_1$3.default.ok(this instanceof TreeCopier$1);
		this.lines = lines;
		this.tokens = tokens;
		this.startTokenIndex = 0;
		this.endTokenIndex = tokens.length;
		this.indent = 0;
		this.seen = /* @__PURE__ */ new Map();
	};
	var TCp = TreeCopier.prototype;
	TCp.copy = function(node) {
		if (this.seen.has(node)) return this.seen.get(node);
		if (isArray$5.check(node)) {
			var copy_1 = new Array(node.length);
			this.seen.set(node, copy_1);
			node.forEach(function(item, i$3) {
				copy_1[i$3] = this.copy(item);
			}, this);
			return copy_1;
		}
		if (!isObject$4.check(node)) return node;
		util$3.fixFaultyLocations(node, this.lines);
		var copy = Object.create(Object.getPrototypeOf(node), { original: {
			value: node,
			configurable: false,
			enumerable: false,
			writable: true
		} });
		this.seen.set(node, copy);
		var loc = node.loc;
		var oldIndent = this.indent;
		var newIndent = oldIndent;
		var oldStartTokenIndex = this.startTokenIndex;
		var oldEndTokenIndex = this.endTokenIndex;
		if (loc) {
			if (node.type === "Block" || node.type === "Line" || node.type === "CommentBlock" || node.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) newIndent = this.indent = loc.start.column;
			loc.lines = this.lines;
			loc.tokens = this.tokens;
			loc.indent = newIndent;
			this.findTokenRange(loc);
		}
		var keys$9 = Object.keys(node);
		var keyCount = keys$9.length;
		for (var i$2 = 0; i$2 < keyCount; ++i$2) {
			var key = keys$9[i$2];
			if (key === "loc") copy[key] = node[key];
			else if (key === "tokens" && node.type === "File") copy[key] = node[key];
			else copy[key] = this.copy(node[key]);
		}
		this.indent = oldIndent;
		this.startTokenIndex = oldStartTokenIndex;
		this.endTokenIndex = oldEndTokenIndex;
		return copy;
	};
	TCp.findTokenRange = function(loc) {
		while (this.startTokenIndex > 0) {
			var token = loc.tokens[this.startTokenIndex];
			if (util$3.comparePos(loc.start, token.loc.start) < 0) --this.startTokenIndex;
			else break;
		}
		while (this.endTokenIndex < loc.tokens.length) {
			var token = loc.tokens[this.endTokenIndex];
			if (util$3.comparePos(token.loc.end, loc.end) < 0) ++this.endTokenIndex;
			else break;
		}
		while (this.startTokenIndex < this.endTokenIndex) {
			var token = loc.tokens[this.startTokenIndex];
			if (util$3.comparePos(token.loc.start, loc.start) < 0) ++this.startTokenIndex;
			else break;
		}
		loc.start.token = this.startTokenIndex;
		while (this.endTokenIndex > this.startTokenIndex) {
			var token = loc.tokens[this.endTokenIndex - 1];
			if (util$3.comparePos(loc.end, token.loc.end) < 0) --this.endTokenIndex;
			else break;
		}
		loc.end.token = this.endTokenIndex;
	};
}));
var require_fast_path = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$31 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$2 = tslib_1$31.__importDefault(require_assert());
	var types$5 = tslib_1$31.__importStar(require_main$2());
	var util$2 = tslib_1$31.__importStar(require_util());
	var n$1 = types$5.namedTypes;
	var isArray$4 = types$5.builtInTypes.array;
	var isNumber = types$5.builtInTypes.number;
	var PRECEDENCE = {};
	[
		["??"],
		["||"],
		["&&"],
		["|"],
		["^"],
		["&"],
		[
			"==",
			"===",
			"!=",
			"!=="
		],
		[
			"<",
			">",
			"<=",
			">=",
			"in",
			"instanceof"
		],
		[
			">>",
			"<<",
			">>>"
		],
		["+", "-"],
		[
			"*",
			"/",
			"%"
		],
		["**"]
	].forEach(function(tier, i$2) {
		tier.forEach(function(op) {
			PRECEDENCE[op] = i$2;
		});
	});
	var FastPath = function FastPath$1(value) {
		assert_1$2.default.ok(this instanceof FastPath$1);
		this.stack = [value];
	};
	var FPp = FastPath.prototype;
	FastPath.from = function(obj) {
		if (obj instanceof FastPath) return obj.copy();
		if (obj instanceof types$5.NodePath) {
			var copy = Object.create(FastPath.prototype);
			var stack = [obj.value];
			for (var pp = void 0; pp = obj.parentPath; obj = pp) stack.push(obj.name, pp.value);
			copy.stack = stack.reverse();
			return copy;
		}
		return new FastPath(obj);
	};
	FPp.copy = function copy() {
		var copy$1 = Object.create(FastPath.prototype);
		copy$1.stack = this.stack.slice(0);
		return copy$1;
	};
	FPp.getName = function getName() {
		var s$2 = this.stack;
		var len$1 = s$2.length;
		if (len$1 > 1) return s$2[len$1 - 2];
		return null;
	};
	FPp.getValue = function getValue() {
		var s$2 = this.stack;
		return s$2[s$2.length - 1];
	};
	FPp.valueIsDuplicate = function() {
		var s$2 = this.stack;
		var valueIndex = s$2.length - 1;
		return s$2.lastIndexOf(s$2[valueIndex], valueIndex - 1) >= 0;
	};
	function getNodeHelper(path, count) {
		var s$2 = path.stack;
		for (var i$2 = s$2.length - 1; i$2 >= 0; i$2 -= 2) {
			var value = s$2[i$2];
			if (n$1.Node.check(value) && --count < 0) return value;
		}
		return null;
	}
	FPp.getNode = function getNode(count) {
		if (count === void 0) count = 0;
		return getNodeHelper(this, ~~count);
	};
	FPp.getParentNode = function getParentNode(count) {
		if (count === void 0) count = 0;
		return getNodeHelper(this, ~~count + 1);
	};
	FPp.getRootValue = function getRootValue() {
		var s$2 = this.stack;
		if (s$2.length % 2 === 0) return s$2[1];
		return s$2[0];
	};
	FPp.call = function call$1(callback) {
		var s$2 = this.stack;
		var origLen = s$2.length;
		var value = s$2[origLen - 1];
		var argc = arguments.length;
		for (var i$2 = 1; i$2 < argc; ++i$2) {
			var name = arguments[i$2];
			value = value[name];
			s$2.push(name, value);
		}
		var result = callback(this);
		s$2.length = origLen;
		return result;
	};
	FPp.each = function each(callback) {
		var s$2 = this.stack;
		var origLen = s$2.length;
		var value = s$2[origLen - 1];
		var argc = arguments.length;
		for (var i$2 = 1; i$2 < argc; ++i$2) {
			var name = arguments[i$2];
			value = value[name];
			s$2.push(name, value);
		}
		for (var i$2 = 0; i$2 < value.length; ++i$2) if (i$2 in value) {
			s$2.push(i$2, value[i$2]);
			callback(this);
			s$2.length -= 2;
		}
		s$2.length = origLen;
	};
	FPp.map = function map(callback) {
		var s$2 = this.stack;
		var origLen = s$2.length;
		var value = s$2[origLen - 1];
		var argc = arguments.length;
		for (var i$2 = 1; i$2 < argc; ++i$2) {
			var name = arguments[i$2];
			value = value[name];
			s$2.push(name, value);
		}
		var result = new Array(value.length);
		for (var i$2 = 0; i$2 < value.length; ++i$2) if (i$2 in value) {
			s$2.push(i$2, value[i$2]);
			result[i$2] = callback(this, i$2);
			s$2.length -= 2;
		}
		s$2.length = origLen;
		return result;
	};
	FPp.hasParens = function() {
		var node = this.getNode();
		var prevToken = this.getPrevToken(node);
		if (!prevToken) return false;
		var nextToken = this.getNextToken(node);
		if (!nextToken) return false;
		if (prevToken.value === "(") {
			if (nextToken.value === ")") return true;
			if (!this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true)) return true;
		}
		return false;
	};
	FPp.getPrevToken = function(node) {
		node = node || this.getNode();
		var loc = node && node.loc;
		var tokens = loc && loc.tokens;
		if (tokens && loc.start.token > 0) {
			var token = tokens[loc.start.token - 1];
			if (token) {
				var rootLoc = this.getRootValue().loc;
				if (util$2.comparePos(rootLoc.start, token.loc.start) <= 0) return token;
			}
		}
		return null;
	};
	FPp.getNextToken = function(node) {
		node = node || this.getNode();
		var loc = node && node.loc;
		var tokens = loc && loc.tokens;
		if (tokens && loc.end.token < tokens.length) {
			var token = tokens[loc.end.token];
			if (token) {
				var rootLoc = this.getRootValue().loc;
				if (util$2.comparePos(token.loc.end, rootLoc.end) <= 0) return token;
			}
		}
		return null;
	};
	FPp.needsParens = function(assumeExpressionContext) {
		var node = this.getNode();
		if (node.type === "AssignmentExpression" && node.left.type === "ObjectPattern") return true;
		var parent = this.getParentNode();
		var name = this.getName();
		if (this.getValue() !== node) return false;
		if (n$1.Statement.check(node)) return false;
		if (node.type === "Identifier") return false;
		if (parent && parent.type === "ParenthesizedExpression") return false;
		if (node.extra && node.extra.parenthesized) return true;
		if (!parent) return false;
		switch (node.type) {
			case "UnaryExpression":
			case "SpreadElement":
			case "SpreadProperty": return parent.type === "MemberExpression" && name === "object" && parent.object === node;
			case "BinaryExpression":
			case "LogicalExpression":
				switch (parent.type) {
					case "CallExpression": return name === "callee" && parent.callee === node;
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty": return true;
					case "MemberExpression": return name === "object" && parent.object === node;
					case "BinaryExpression":
					case "LogicalExpression":
						var pp = PRECEDENCE[parent.operator];
						var np = PRECEDENCE[node.operator];
						if (pp > np) return true;
						if (pp === np && name === "right") {
							assert_1$2.default.strictEqual(parent.right, node);
							return true;
						}
						break;
					default: return false;
				}
				break;
			case "SequenceExpression": switch (parent.type) {
				case "ReturnStatement": return false;
				case "ForStatement": return false;
				case "ExpressionStatement": return name !== "expression";
				default: return true;
			}
			case "OptionalIndexedAccessType": return node.optional && parent.type === "IndexedAccessType";
			case "IntersectionTypeAnnotation":
			case "UnionTypeAnnotation": return parent.type === "NullableTypeAnnotation";
			case "Literal": return parent.type === "MemberExpression" && isNumber.check(node.value) && name === "object" && parent.object === node;
			case "NumericLiteral": return parent.type === "MemberExpression" && name === "object" && parent.object === node;
			case "YieldExpression":
			case "AwaitExpression":
			case "AssignmentExpression":
			case "ConditionalExpression": switch (parent.type) {
				case "UnaryExpression":
				case "SpreadElement":
				case "SpreadProperty":
				case "BinaryExpression":
				case "LogicalExpression": return true;
				case "CallExpression":
				case "NewExpression": return name === "callee" && parent.callee === node;
				case "ConditionalExpression": return name === "test" && parent.test === node;
				case "MemberExpression": return name === "object" && parent.object === node;
				default: return false;
			}
			case "ArrowFunctionExpression":
				if (n$1.CallExpression.check(parent) && name === "callee" && parent.callee === node) return true;
				if (n$1.MemberExpression.check(parent) && name === "object" && parent.object === node) return true;
				if (n$1.TSAsExpression && n$1.TSAsExpression.check(parent) && name === "expression" && parent.expression === node) return true;
				return isBinary(parent);
			case "ObjectExpression":
				if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node) return true;
				break;
			case "TSAsExpression":
				if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node && node.expression.type === "ObjectExpression") return true;
				break;
			case "CallExpression": if (name === "declaration" && n$1.ExportDefaultDeclaration.check(parent) && n$1.FunctionExpression.check(node.callee)) return true;
		}
		if (parent.type === "NewExpression" && name === "callee" && parent.callee === node) return containsCallExpression(node);
		if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
		return false;
	};
	function isBinary(node) {
		return n$1.BinaryExpression.check(node) || n$1.LogicalExpression.check(node);
	}
	function containsCallExpression(node) {
		if (n$1.CallExpression.check(node)) return true;
		if (isArray$4.check(node)) return node.some(containsCallExpression);
		if (n$1.Node.check(node)) return types$5.someField(node, function(_name, child) {
			return containsCallExpression(child);
		});
		return false;
	}
	FPp.canBeFirstInStatement = function() {
		var node = this.getNode();
		if (n$1.FunctionExpression.check(node)) return false;
		if (n$1.ObjectExpression.check(node)) return false;
		if (n$1.ClassExpression.check(node)) return false;
		return true;
	};
	FPp.firstInStatement = function() {
		var s$2 = this.stack;
		var parentName, parent;
		var childName, child;
		for (var i$2 = s$2.length - 1; i$2 >= 0; i$2 -= 2) {
			if (n$1.Node.check(s$2[i$2])) {
				childName = parentName;
				child = parent;
				parentName = s$2[i$2 - 1];
				parent = s$2[i$2];
			}
			if (!parent || !child) continue;
			if (n$1.BlockStatement.check(parent) && parentName === "body" && childName === 0) {
				assert_1$2.default.strictEqual(parent.body[0], child);
				return true;
			}
			if (n$1.ExpressionStatement.check(parent) && childName === "expression") {
				assert_1$2.default.strictEqual(parent.expression, child);
				return true;
			}
			if (n$1.AssignmentExpression.check(parent) && childName === "left") {
				assert_1$2.default.strictEqual(parent.left, child);
				return true;
			}
			if (n$1.ArrowFunctionExpression.check(parent) && childName === "body") {
				assert_1$2.default.strictEqual(parent.body, child);
				return true;
			}
			if (n$1.SequenceExpression.check(parent) && s$2[i$2 + 1] === "expressions" && childName === 0) {
				assert_1$2.default.strictEqual(parent.expressions[0], child);
				continue;
			}
			if (n$1.CallExpression.check(parent) && childName === "callee") {
				assert_1$2.default.strictEqual(parent.callee, child);
				continue;
			}
			if (n$1.MemberExpression.check(parent) && childName === "object") {
				assert_1$2.default.strictEqual(parent.object, child);
				continue;
			}
			if (n$1.ConditionalExpression.check(parent) && childName === "test") {
				assert_1$2.default.strictEqual(parent.test, child);
				continue;
			}
			if (isBinary(parent) && childName === "left") {
				assert_1$2.default.strictEqual(parent.left, child);
				continue;
			}
			if (n$1.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
				assert_1$2.default.strictEqual(parent.argument, child);
				continue;
			}
			return false;
		}
		return true;
	};
	exports.default = FastPath;
}));
var require_patcher = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$30 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1$1 = tslib_1$30.__importDefault(require_assert());
	var linesModule = tslib_1$30.__importStar(require_lines());
	var types$4 = tslib_1$30.__importStar(require_main$2());
	var Printable = types$4.namedTypes.Printable;
	var Expression$1 = types$4.namedTypes.Expression;
	var ReturnStatement = types$4.namedTypes.ReturnStatement;
	var SourceLocation = types$4.namedTypes.SourceLocation;
	var util_1 = require_util();
	var fast_path_1$1 = tslib_1$30.__importDefault(require_fast_path());
	var isObject$3 = types$4.builtInTypes.object;
	var isArray$3 = types$4.builtInTypes.array;
	var isString$1 = types$4.builtInTypes.string;
	var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
	var Patcher = function Patcher$1(lines) {
		assert_1$1.default.ok(this instanceof Patcher$1);
		assert_1$1.default.ok(lines instanceof linesModule.Lines);
		var self$1 = this, replacements = [];
		self$1.replace = function(loc, lines$1) {
			if (isString$1.check(lines$1)) lines$1 = linesModule.fromString(lines$1);
			replacements.push({
				lines: lines$1,
				start: loc.start,
				end: loc.end
			});
		};
		self$1.get = function(loc) {
			loc = loc || {
				start: {
					line: 1,
					column: 0
				},
				end: {
					line: lines.length,
					column: lines.getLineLength(lines.length)
				}
			};
			var sliceFrom = loc.start, toConcat = [];
			function pushSlice(from$2, to) {
				assert_1$1.default.ok(util_1.comparePos(from$2, to) <= 0);
				toConcat.push(lines.slice(from$2, to));
			}
			replacements.sort(function(a$1, b$5) {
				return util_1.comparePos(a$1.start, b$5.start);
			}).forEach(function(rep) {
				if (util_1.comparePos(sliceFrom, rep.start) > 0) {} else {
					pushSlice(sliceFrom, rep.start);
					toConcat.push(rep.lines);
					sliceFrom = rep.end;
				}
			});
			pushSlice(sliceFrom, loc.end);
			return linesModule.concat(toConcat);
		};
	};
	exports.Patcher = Patcher;
	var Pp = Patcher.prototype;
	Pp.tryToReprintComments = function(newNode, oldNode, print$4) {
		var patcher = this;
		if (!newNode.comments && !oldNode.comments) return true;
		var newPath = fast_path_1$1.default.from(newNode);
		var oldPath = fast_path_1$1.default.from(oldNode);
		newPath.stack.push("comments", getSurroundingComments(newNode));
		oldPath.stack.push("comments", getSurroundingComments(oldNode));
		var reprints = [];
		var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
		if (ableToReprintComments && reprints.length > 0) reprints.forEach(function(reprint) {
			var oldComment = reprint.oldPath.getValue();
			assert_1$1.default.ok(oldComment.leading || oldComment.trailing);
			patcher.replace(oldComment.loc, print$4(reprint.newPath).indentTail(oldComment.loc.indent));
		});
		return ableToReprintComments;
	};
	function getSurroundingComments(node) {
		var result = [];
		if (node.comments && node.comments.length > 0) node.comments.forEach(function(comment) {
			if (comment.leading || comment.trailing) result.push(comment);
		});
		return result;
	}
	Pp.deleteComments = function(node) {
		if (!node.comments) return;
		var patcher = this;
		node.comments.forEach(function(comment) {
			if (comment.leading) patcher.replace({
				start: comment.loc.start,
				end: node.loc.lines.skipSpaces(comment.loc.end, false, false)
			}, "");
			else if (comment.trailing) patcher.replace({
				start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
				end: comment.loc.end
			}, "");
		});
	};
	function getReprinter(path) {
		assert_1$1.default.ok(path instanceof fast_path_1$1.default);
		var node = path.getValue();
		if (!Printable.check(node)) return;
		var orig = node.original;
		var origLoc = orig && orig.loc;
		var lines = origLoc && origLoc.lines;
		var reprints = [];
		if (!lines || !findReprints(path, reprints)) return;
		return function(print$4) {
			var patcher = new Patcher(lines);
			reprints.forEach(function(reprint) {
				var newNode = reprint.newPath.getValue();
				var oldNode = reprint.oldPath.getValue();
				SourceLocation.assert(oldNode.loc, true);
				var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print$4);
				if (needToPrintNewPathWithComments) patcher.deleteComments(oldNode);
				var newLines = print$4(reprint.newPath, {
					includeComments: needToPrintNewPathWithComments,
					avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
				}).indentTail(oldNode.loc.indent);
				var nls = needsLeadingSpace(lines, oldNode.loc, newLines);
				var nts = needsTrailingSpace(lines, oldNode.loc, newLines);
				if (nls || nts) {
					var newParts = [];
					nls && newParts.push(" ");
					newParts.push(newLines);
					nts && newParts.push(" ");
					newLines = linesModule.concat(newParts);
				}
				patcher.replace(oldNode.loc, newLines);
			});
			var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);
			if (path.needsParens()) return linesModule.concat([
				"(",
				patchedLines,
				")"
			]);
			return patchedLines;
		};
	}
	exports.getReprinter = getReprinter;
	function needsLeadingSpace(oldLines, oldLoc, newLines) {
		var posBeforeOldLoc = util_1.copyPos(oldLoc.start);
		var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
		var newFirstChar = newLines.charAt(newLines.firstPos());
		return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
	}
	function needsTrailingSpace(oldLines, oldLoc, newLines) {
		var charAfterOldLoc = oldLines.charAt(oldLoc.end);
		var newLastPos = newLines.lastPos();
		var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
		return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
	}
	function findReprints(newPath, reprints) {
		var newNode = newPath.getValue();
		Printable.assert(newNode);
		var oldNode = newNode.original;
		Printable.assert(oldNode);
		assert_1$1.default.deepEqual(reprints, []);
		if (newNode.type !== oldNode.type) return false;
		var canReprint = findChildReprints(newPath, new fast_path_1$1.default(oldNode), reprints);
		if (!canReprint) reprints.length = 0;
		return canReprint;
	}
	function findAnyReprints(newPath, oldPath, reprints) {
		var newNode = newPath.getValue();
		if (newNode === oldPath.getValue()) return true;
		if (isArray$3.check(newNode)) return findArrayReprints(newPath, oldPath, reprints);
		if (isObject$3.check(newNode)) return findObjectReprints(newPath, oldPath, reprints);
		return false;
	}
	function findArrayReprints(newPath, oldPath, reprints) {
		var newNode = newPath.getValue();
		var oldNode = oldPath.getValue();
		if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) return true;
		isArray$3.assert(newNode);
		var len$1 = newNode.length;
		if (!(isArray$3.check(oldNode) && oldNode.length === len$1)) return false;
		for (var i$2 = 0; i$2 < len$1; ++i$2) {
			newPath.stack.push(i$2, newNode[i$2]);
			oldPath.stack.push(i$2, oldNode[i$2]);
			var canReprint = findAnyReprints(newPath, oldPath, reprints);
			newPath.stack.length -= 2;
			oldPath.stack.length -= 2;
			if (!canReprint) return false;
		}
		return true;
	}
	function findObjectReprints(newPath, oldPath, reprints) {
		var newNode = newPath.getValue();
		isObject$3.assert(newNode);
		if (newNode.original === null) return false;
		var oldNode = oldPath.getValue();
		if (!isObject$3.check(oldNode)) return false;
		if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) return true;
		if (Printable.check(newNode)) {
			if (!Printable.check(oldNode)) return false;
			var newParentNode = newPath.getParentNode();
			var oldParentNode = oldPath.getParentNode();
			if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
				var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
				var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
				if (!oldNeedsParens && newNeedParens) return false;
			}
			if (newNode.type === oldNode.type) {
				var childReprints = [];
				if (findChildReprints(newPath, oldPath, childReprints)) reprints.push.apply(reprints, childReprints);
				else if (oldNode.loc) reprints.push({
					oldPath: oldPath.copy(),
					newPath: newPath.copy()
				});
				else return false;
				return true;
			}
			if (Expression$1.check(newNode) && Expression$1.check(oldNode) && oldNode.loc) {
				reprints.push({
					oldPath: oldPath.copy(),
					newPath: newPath.copy()
				});
				return true;
			}
			return false;
		}
		return findChildReprints(newPath, oldPath, reprints);
	}
	function findChildReprints(newPath, oldPath, reprints) {
		var newNode = newPath.getValue();
		var oldNode = oldPath.getValue();
		isObject$3.assert(newNode);
		isObject$3.assert(oldNode);
		if (newNode.original === null) return false;
		if (newPath.needsParens() && !oldPath.hasParens()) return false;
		var keys$9 = util_1.getUnionOfKeys(oldNode, newNode);
		if (oldNode.type === "File" || newNode.type === "File") delete keys$9.tokens;
		delete keys$9.loc;
		var originalReprintCount = reprints.length;
		for (var k$1 in keys$9) {
			if (k$1.charAt(0) === "_") continue;
			newPath.stack.push(k$1, types$4.getFieldValue(newNode, k$1));
			oldPath.stack.push(k$1, types$4.getFieldValue(oldNode, k$1));
			var canReprint = findAnyReprints(newPath, oldPath, reprints);
			newPath.stack.length -= 2;
			oldPath.stack.length -= 2;
			if (!canReprint) return false;
		}
		if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) return false;
		return true;
	}
}));
var require_printer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$29 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var assert_1 = tslib_1$29.__importDefault(require_assert());
	var comments_1 = require_comments();
	var lines_1 = require_lines();
	var options_1 = require_options();
	var patcher_1 = require_patcher();
	var types$3 = tslib_1$29.__importStar(require_main$2());
	var namedTypes = types$3.namedTypes;
	var isString = types$3.builtInTypes.string;
	var isObject$2 = types$3.builtInTypes.object;
	var fast_path_1 = tslib_1$29.__importDefault(require_fast_path());
	var util$1 = tslib_1$29.__importStar(require_util());
	var PrintResult = function PrintResult$1(code$1, sourceMap) {
		assert_1.default.ok(this instanceof PrintResult$1);
		isString.assert(code$1);
		this.code = code$1;
		if (sourceMap) {
			isObject$2.assert(sourceMap);
			this.map = sourceMap;
		}
	};
	var PRp = PrintResult.prototype;
	var warnedAboutToString = false;
	PRp.toString = function() {
		if (!warnedAboutToString) {
			console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.");
			warnedAboutToString = true;
		}
		return this.code;
	};
	var emptyPrintResult = new PrintResult("");
	exports.Printer = function Printer$1(config$1) {
		assert_1.default.ok(this instanceof Printer$1);
		var explicitTabWidth = config$1 && config$1.tabWidth;
		config$1 = options_1.normalize(config$1);
		config$1.sourceFileName = null;
		function makePrintFunctionWith(options, overrides) {
			options = Object.assign({}, options, overrides);
			return function(path) {
				return print$4(path, options);
			};
		}
		function print$4(path, options) {
			assert_1.default.ok(path instanceof fast_path_1.default);
			options = options || {};
			if (options.includeComments) return comments_1.printComments(path, makePrintFunctionWith(options, { includeComments: false }));
			var oldTabWidth = config$1.tabWidth;
			if (!explicitTabWidth) {
				var loc = path.getNode().loc;
				if (loc && loc.lines && loc.lines.guessTabWidth) config$1.tabWidth = loc.lines.guessTabWidth();
			}
			var reprinter = patcher_1.getReprinter(path);
			var lines = reprinter ? reprinter(print$4) : genericPrint(path, config$1, options, makePrintFunctionWith(options, {
				includeComments: true,
				avoidRootParens: false
			}));
			config$1.tabWidth = oldTabWidth;
			return lines;
		}
		this.print = function(ast) {
			if (!ast) return emptyPrintResult;
			var lines = print$4(fast_path_1.default.from(ast), {
				includeComments: true,
				avoidRootParens: false
			});
			return new PrintResult(lines.toString(config$1), util$1.composeSourceMaps(config$1.inputSourceMap, lines.getSourceMap(config$1.sourceMapName, config$1.sourceRoot)));
		};
		this.printGenerically = function(ast) {
			if (!ast) return emptyPrintResult;
			function printGenerically(path$1) {
				return comments_1.printComments(path$1, function(path$2) {
					return genericPrint(path$2, config$1, {
						includeComments: true,
						avoidRootParens: false
					}, printGenerically);
				});
			}
			var path = fast_path_1.default.from(ast);
			var oldReuseWhitespace = config$1.reuseWhitespace;
			config$1.reuseWhitespace = false;
			var pr = new PrintResult(printGenerically(path).toString(config$1));
			config$1.reuseWhitespace = oldReuseWhitespace;
			return pr;
		};
	};
	function genericPrint(path, config$1, options, printPath) {
		assert_1.default.ok(path instanceof fast_path_1.default);
		var node = path.getValue();
		var parts = [];
		var linesWithoutParens = genericPrintNoParens(path, config$1, printPath);
		if (!node || linesWithoutParens.isEmpty()) return linesWithoutParens;
		var shouldAddParens = false;
		var decoratorsLines = printDecorators(path, printPath);
		if (decoratorsLines.isEmpty()) {
			if (!options.avoidRootParens) shouldAddParens = path.needsParens();
		} else parts.push(decoratorsLines);
		if (shouldAddParens) parts.unshift("(");
		parts.push(linesWithoutParens);
		if (shouldAddParens) parts.push(")");
		return lines_1.concat(parts);
	}
	function genericPrintNoParens(path, options, print$4) {
		var n$6 = path.getValue();
		if (!n$6) return lines_1.fromString("");
		if (typeof n$6 === "string") return lines_1.fromString(n$6, options);
		namedTypes.Printable.assert(n$6);
		var parts = [];
		switch (n$6.type) {
			case "File": return path.call(print$4, "program");
			case "Program":
				if (n$6.directives) path.each(function(childPath) {
					parts.push(print$4(childPath), ";\n");
				}, "directives");
				if (n$6.interpreter) parts.push(path.call(print$4, "interpreter"));
				parts.push(path.call(function(bodyPath) {
					return printStatementSequence(bodyPath, options, print$4);
				}, "body"));
				return lines_1.concat(parts);
			case "Noop":
			case "EmptyStatement": return lines_1.fromString("");
			case "ExpressionStatement": return lines_1.concat([path.call(print$4, "expression"), ";"]);
			case "ParenthesizedExpression": return lines_1.concat([
				"(",
				path.call(print$4, "expression"),
				")"
			]);
			case "BinaryExpression":
			case "LogicalExpression":
			case "AssignmentExpression": return lines_1.fromString(" ").join([
				path.call(print$4, "left"),
				n$6.operator,
				path.call(print$4, "right")
			]);
			case "AssignmentPattern": return lines_1.concat([
				path.call(print$4, "left"),
				" = ",
				path.call(print$4, "right")
			]);
			case "MemberExpression":
			case "OptionalMemberExpression":
				parts.push(path.call(print$4, "object"));
				var property$2 = path.call(print$4, "property");
				var optional = types$3.getFieldValue(n$6, "optional");
				if (n$6.computed) parts.push(optional ? "?.[" : "[", property$2, "]");
				else parts.push(optional ? "?." : ".", property$2);
				return lines_1.concat(parts);
			case "ChainExpression": return path.call(print$4, "expression");
			case "MetaProperty": return lines_1.concat([
				path.call(print$4, "meta"),
				".",
				path.call(print$4, "property")
			]);
			case "BindExpression":
				if (n$6.object) parts.push(path.call(print$4, "object"));
				parts.push("::", path.call(print$4, "callee"));
				return lines_1.concat(parts);
			case "Path": return lines_1.fromString(".").join(n$6.body);
			case "Identifier": return lines_1.concat([
				lines_1.fromString(n$6.name, options),
				n$6.optional ? "?" : "",
				path.call(print$4, "typeAnnotation")
			]);
			case "SpreadElement":
			case "SpreadElementPattern":
			case "RestProperty":
			case "SpreadProperty":
			case "SpreadPropertyPattern":
			case "ObjectTypeSpreadProperty":
			case "RestElement": return lines_1.concat([
				"...",
				path.call(print$4, "argument"),
				path.call(print$4, "typeAnnotation")
			]);
			case "FunctionDeclaration":
			case "FunctionExpression":
			case "TSDeclareFunction":
				if (n$6.declare) parts.push("declare ");
				if (n$6.async) parts.push("async ");
				parts.push("function");
				if (n$6.generator) parts.push("*");
				if (n$6.id) parts.push(" ", path.call(print$4, "id"), path.call(print$4, "typeParameters"));
				else if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				parts.push("(", printFunctionParams(path, options, print$4), ")", path.call(print$4, "returnType"));
				if (n$6.body) parts.push(" ", path.call(print$4, "body"));
				return lines_1.concat(parts);
			case "ArrowFunctionExpression":
				if (n$6.async) parts.push("async ");
				if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				if (!options.arrowParensAlways && n$6.params.length === 1 && !n$6.rest && n$6.params[0].type === "Identifier" && !n$6.params[0].typeAnnotation && !n$6.returnType) parts.push(path.call(print$4, "params", 0));
				else parts.push("(", printFunctionParams(path, options, print$4), ")", path.call(print$4, "returnType"));
				parts.push(" => ", path.call(print$4, "body"));
				return lines_1.concat(parts);
			case "MethodDefinition": return printMethod(path, options, print$4);
			case "YieldExpression":
				parts.push("yield");
				if (n$6.delegate) parts.push("*");
				if (n$6.argument) parts.push(" ", path.call(print$4, "argument"));
				return lines_1.concat(parts);
			case "AwaitExpression":
				parts.push("await");
				if (n$6.all) parts.push("*");
				if (n$6.argument) parts.push(" ", path.call(print$4, "argument"));
				return lines_1.concat(parts);
			case "ModuleExpression": return lines_1.concat([
				"module {\n",
				path.call(print$4, "body").indent(options.tabWidth),
				"\n}"
			]);
			case "ModuleDeclaration":
				parts.push("module", path.call(print$4, "id"));
				if (n$6.source) {
					assert_1.default.ok(!n$6.body);
					parts.push("from", path.call(print$4, "source"));
				} else parts.push(path.call(print$4, "body"));
				return lines_1.fromString(" ").join(parts);
			case "ImportSpecifier":
				if (n$6.importKind && n$6.importKind !== "value") parts.push(n$6.importKind + " ");
				if (n$6.imported) {
					parts.push(path.call(print$4, "imported"));
					if (n$6.local && n$6.local.name !== n$6.imported.name) parts.push(" as ", path.call(print$4, "local"));
				} else if (n$6.id) {
					parts.push(path.call(print$4, "id"));
					if (n$6.name) parts.push(" as ", path.call(print$4, "name"));
				}
				return lines_1.concat(parts);
			case "ExportSpecifier":
				if (n$6.local) {
					parts.push(path.call(print$4, "local"));
					if (n$6.exported && n$6.exported.name !== n$6.local.name) parts.push(" as ", path.call(print$4, "exported"));
				} else if (n$6.id) {
					parts.push(path.call(print$4, "id"));
					if (n$6.name) parts.push(" as ", path.call(print$4, "name"));
				}
				return lines_1.concat(parts);
			case "ExportBatchSpecifier": return lines_1.fromString("*");
			case "ImportNamespaceSpecifier":
				parts.push("* as ");
				if (n$6.local) parts.push(path.call(print$4, "local"));
				else if (n$6.id) parts.push(path.call(print$4, "id"));
				return lines_1.concat(parts);
			case "ImportDefaultSpecifier":
				if (n$6.local) return path.call(print$4, "local");
				return path.call(print$4, "id");
			case "TSExportAssignment": return lines_1.concat(["export = ", path.call(print$4, "expression")]);
			case "ExportDeclaration":
			case "ExportDefaultDeclaration":
			case "ExportNamedDeclaration": return printExportDeclaration(path, options, print$4);
			case "ExportAllDeclaration":
				parts.push("export *");
				if (n$6.exported) parts.push(" as ", path.call(print$4, "exported"));
				parts.push(" from ", path.call(print$4, "source"), ";");
				return lines_1.concat(parts);
			case "TSNamespaceExportDeclaration":
				parts.push("export as namespace ", path.call(print$4, "id"));
				return maybeAddSemicolon(lines_1.concat(parts));
			case "ExportNamespaceSpecifier": return lines_1.concat(["* as ", path.call(print$4, "exported")]);
			case "ExportDefaultSpecifier": return path.call(print$4, "exported");
			case "Import": return lines_1.fromString("import", options);
			case "ImportExpression": return lines_1.concat([
				"import(",
				path.call(print$4, "source"),
				")"
			]);
			case "ImportDeclaration":
				parts.push("import ");
				if (n$6.importKind && n$6.importKind !== "value") parts.push(n$6.importKind + " ");
				if (n$6.specifiers && n$6.specifiers.length > 0) {
					var unbracedSpecifiers_1 = [];
					var bracedSpecifiers_1 = [];
					path.each(function(specifierPath) {
						var spec = specifierPath.getValue();
						if (spec.type === "ImportSpecifier") bracedSpecifiers_1.push(print$4(specifierPath));
						else if (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") unbracedSpecifiers_1.push(print$4(specifierPath));
					}, "specifiers");
					unbracedSpecifiers_1.forEach(function(lines$1, i$2) {
						if (i$2 > 0) parts.push(", ");
						parts.push(lines$1);
					});
					if (bracedSpecifiers_1.length > 0) {
						var lines = lines_1.fromString(", ").join(bracedSpecifiers_1);
						if (lines.getLineLength(1) > options.wrapColumn) lines = lines_1.concat([lines_1.fromString(",\n").join(bracedSpecifiers_1).indent(options.tabWidth), ","]);
						if (unbracedSpecifiers_1.length > 0) parts.push(", ");
						if (lines.length > 1) parts.push("{\n", lines, "\n}");
						else if (options.objectCurlySpacing) parts.push("{ ", lines, " }");
						else parts.push("{", lines, "}");
					}
					parts.push(" from ");
				}
				parts.push(path.call(print$4, "source"), maybePrintImportAssertions(path, options, print$4), ";");
				return lines_1.concat(parts);
			case "ImportAttribute": return lines_1.concat([
				path.call(print$4, "key"),
				": ",
				path.call(print$4, "value")
			]);
			case "StaticBlock": parts.push("static ");
			case "BlockStatement":
				var naked_1 = path.call(function(bodyPath) {
					return printStatementSequence(bodyPath, options, print$4);
				}, "body");
				if (naked_1.isEmpty()) {
					if (!n$6.directives || n$6.directives.length === 0) {
						parts.push("{}");
						return lines_1.concat(parts);
					}
				}
				parts.push("{\n");
				if (n$6.directives) path.each(function(childPath) {
					parts.push(maybeAddSemicolon(print$4(childPath).indent(options.tabWidth)), n$6.directives.length > 1 || !naked_1.isEmpty() ? "\n" : "");
				}, "directives");
				parts.push(naked_1.indent(options.tabWidth));
				parts.push("\n}");
				return lines_1.concat(parts);
			case "ReturnStatement":
				parts.push("return");
				if (n$6.argument) {
					var argLines = path.call(print$4, "argument");
					if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n$6.argument)) parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
					else parts.push(" ", argLines);
				}
				parts.push(";");
				return lines_1.concat(parts);
			case "CallExpression":
			case "OptionalCallExpression":
				parts.push(path.call(print$4, "callee"));
				if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				if (n$6.typeArguments) parts.push(path.call(print$4, "typeArguments"));
				if (types$3.getFieldValue(n$6, "optional")) parts.push("?.");
				parts.push(printArgumentsList(path, options, print$4));
				return lines_1.concat(parts);
			case "RecordExpression": parts.push("#");
			case "ObjectExpression":
			case "ObjectPattern":
			case "ObjectTypeAnnotation":
				var isTypeAnnotation_1 = n$6.type === "ObjectTypeAnnotation";
				var separator_1 = options.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",";
				var fields = [];
				var allowBreak_1 = false;
				if (isTypeAnnotation_1) {
					fields.push("indexers", "callProperties");
					if (n$6.internalSlots != null) fields.push("internalSlots");
				}
				fields.push("properties");
				var len_1 = 0;
				fields.forEach(function(field) {
					len_1 += n$6[field].length;
				});
				var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;
				var leftBrace = n$6.exact ? "{|" : "{";
				var rightBrace = n$6.exact ? "|}" : "}";
				parts.push(oneLine_1 ? leftBrace : leftBrace + "\n");
				var leftBraceIndex = parts.length - 1;
				var i_1 = 0;
				fields.forEach(function(field) {
					path.each(function(childPath) {
						var lines$1 = print$4(childPath);
						if (!oneLine_1) lines$1 = lines$1.indent(options.tabWidth);
						var multiLine = !isTypeAnnotation_1 && lines$1.length > 1;
						if (multiLine && allowBreak_1) parts.push("\n");
						parts.push(lines$1);
						if (i_1 < len_1 - 1) {
							parts.push(separator_1 + (multiLine ? "\n\n" : "\n"));
							allowBreak_1 = !multiLine;
						} else if (len_1 !== 1 && isTypeAnnotation_1) parts.push(separator_1);
						else if (!oneLine_1 && util$1.isTrailingCommaEnabled(options, "objects") && childPath.getValue().type !== "RestElement") parts.push(separator_1);
						i_1++;
					}, field);
				});
				if (n$6.inexact) {
					var line = lines_1.fromString("...", options);
					if (oneLine_1) {
						if (len_1 > 0) parts.push(separator_1, " ");
						parts.push(line);
					} else parts.push("\n", line.indent(options.tabWidth));
				}
				parts.push(oneLine_1 ? rightBrace : "\n" + rightBrace);
				if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {
					parts[leftBraceIndex] = leftBrace + " ";
					parts[parts.length - 1] = " " + rightBrace;
				}
				if (n$6.typeAnnotation) parts.push(path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "PropertyPattern": return lines_1.concat([
				path.call(print$4, "key"),
				": ",
				path.call(print$4, "pattern")
			]);
			case "ObjectProperty":
			case "Property":
				if (n$6.method || n$6.kind === "get" || n$6.kind === "set") return printMethod(path, options, print$4);
				if (n$6.shorthand && n$6.value.type === "AssignmentPattern") return path.call(print$4, "value");
				var key = path.call(print$4, "key");
				if (n$6.computed) parts.push("[", key, "]");
				else parts.push(key);
				if (!n$6.shorthand || n$6.key.name !== n$6.value.name) parts.push(": ", path.call(print$4, "value"));
				return lines_1.concat(parts);
			case "ClassMethod":
			case "ObjectMethod":
			case "ClassPrivateMethod":
			case "TSDeclareMethod": return printMethod(path, options, print$4);
			case "PrivateName": return lines_1.concat(["#", path.call(print$4, "id")]);
			case "Decorator": return lines_1.concat(["@", path.call(print$4, "expression")]);
			case "TupleExpression": parts.push("#");
			case "ArrayExpression":
			case "ArrayPattern":
				var len_2 = n$6.elements.length;
				var printed_1 = path.map(print$4, "elements");
				var joined = lines_1.fromString(", ").join(printed_1);
				var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;
				if (oneLine_2) if (options.arrayBracketSpacing) parts.push("[ ");
				else parts.push("[");
				else parts.push("[\n");
				path.each(function(elemPath) {
					var i$2 = elemPath.getName();
					if (!elemPath.getValue()) parts.push(",");
					else {
						var lines$1 = printed_1[i$2];
						if (oneLine_2) {
							if (i$2 > 0) parts.push(" ");
						} else lines$1 = lines$1.indent(options.tabWidth);
						parts.push(lines$1);
						if (i$2 < len_2 - 1 || !oneLine_2 && util$1.isTrailingCommaEnabled(options, "arrays")) parts.push(",");
						if (!oneLine_2) parts.push("\n");
					}
				}, "elements");
				if (oneLine_2 && options.arrayBracketSpacing) parts.push(" ]");
				else parts.push("]");
				if (n$6.typeAnnotation) parts.push(path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "SequenceExpression": return lines_1.fromString(", ").join(path.map(print$4, "expressions"));
			case "ThisExpression": return lines_1.fromString("this");
			case "Super": return lines_1.fromString("super");
			case "NullLiteral": return lines_1.fromString("null");
			case "RegExpLiteral": return lines_1.fromString(getPossibleRaw(n$6) || "/" + n$6.pattern + "/" + (n$6.flags || ""), options);
			case "BigIntLiteral": return lines_1.fromString(getPossibleRaw(n$6) || n$6.value + "n", options);
			case "NumericLiteral": return lines_1.fromString(getPossibleRaw(n$6) || n$6.value, options);
			case "DecimalLiteral": return lines_1.fromString(getPossibleRaw(n$6) || n$6.value + "m", options);
			case "StringLiteral": return lines_1.fromString(nodeStr(n$6.value, options));
			case "BooleanLiteral":
			case "Literal": return lines_1.fromString(getPossibleRaw(n$6) || (typeof n$6.value === "string" ? nodeStr(n$6.value, options) : n$6.value), options);
			case "Directive": return path.call(print$4, "value");
			case "DirectiveLiteral": return lines_1.fromString(getPossibleRaw(n$6) || nodeStr(n$6.value, options), options);
			case "InterpreterDirective": return lines_1.fromString("#!" + n$6.value + "\n", options);
			case "ModuleSpecifier":
				if (n$6.local) throw new Error("The ESTree ModuleSpecifier type should be abstract");
				return lines_1.fromString(nodeStr(n$6.value, options), options);
			case "UnaryExpression":
				parts.push(n$6.operator);
				if (/[a-z]$/.test(n$6.operator)) parts.push(" ");
				parts.push(path.call(print$4, "argument"));
				return lines_1.concat(parts);
			case "UpdateExpression":
				parts.push(path.call(print$4, "argument"), n$6.operator);
				if (n$6.prefix) parts.reverse();
				return lines_1.concat(parts);
			case "ConditionalExpression": return lines_1.concat([
				path.call(print$4, "test"),
				" ? ",
				path.call(print$4, "consequent"),
				" : ",
				path.call(print$4, "alternate")
			]);
			case "NewExpression":
				parts.push("new ", path.call(print$4, "callee"));
				if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				if (n$6.typeArguments) parts.push(path.call(print$4, "typeArguments"));
				if (n$6.arguments) parts.push(printArgumentsList(path, options, print$4));
				return lines_1.concat(parts);
			case "VariableDeclaration":
				if (n$6.declare) parts.push("declare ");
				parts.push(n$6.kind, " ");
				var maxLen_1 = 0;
				var printed = path.map(function(childPath) {
					var lines$1 = print$4(childPath);
					maxLen_1 = Math.max(lines$1.length, maxLen_1);
					return lines$1;
				}, "declarations");
				if (maxLen_1 === 1) parts.push(lines_1.fromString(", ").join(printed));
				else if (printed.length > 1) parts.push(lines_1.fromString(",\n").join(printed).indentTail(n$6.kind.length + 1));
				else parts.push(printed[0]);
				var parentNode = path.getParentNode();
				if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) parts.push(";");
				return lines_1.concat(parts);
			case "VariableDeclarator": return n$6.init ? lines_1.fromString(" = ").join([path.call(print$4, "id"), path.call(print$4, "init")]) : path.call(print$4, "id");
			case "WithStatement": return lines_1.concat([
				"with (",
				path.call(print$4, "object"),
				") ",
				path.call(print$4, "body")
			]);
			case "IfStatement":
				var con = adjustClause(path.call(print$4, "consequent"), options);
				parts.push("if (", path.call(print$4, "test"), ")", con);
				if (n$6.alternate) parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path.call(print$4, "alternate"), options));
				return lines_1.concat(parts);
			case "ForStatement":
				var init = path.call(print$4, "init");
				var sep = init.length > 1 ? ";\n" : "; ";
				var forParen = "for (";
				var indented = lines_1.fromString(sep).join([
					init,
					path.call(print$4, "test"),
					path.call(print$4, "update")
				]).indentTail(forParen.length);
				var head = lines_1.concat([
					forParen,
					indented,
					")"
				]);
				var clause = adjustClause(path.call(print$4, "body"), options);
				parts.push(head);
				if (head.length > 1) {
					parts.push("\n");
					clause = clause.trimLeft();
				}
				parts.push(clause);
				return lines_1.concat(parts);
			case "WhileStatement": return lines_1.concat([
				"while (",
				path.call(print$4, "test"),
				")",
				adjustClause(path.call(print$4, "body"), options)
			]);
			case "ForInStatement": return lines_1.concat([
				n$6.each ? "for each (" : "for (",
				path.call(print$4, "left"),
				" in ",
				path.call(print$4, "right"),
				")",
				adjustClause(path.call(print$4, "body"), options)
			]);
			case "ForOfStatement":
			case "ForAwaitStatement":
				parts.push("for ");
				if (n$6.await || n$6.type === "ForAwaitStatement") parts.push("await ");
				parts.push("(", path.call(print$4, "left"), " of ", path.call(print$4, "right"), ")", adjustClause(path.call(print$4, "body"), options));
				return lines_1.concat(parts);
			case "DoWhileStatement":
				var doBody = lines_1.concat(["do", adjustClause(path.call(print$4, "body"), options)]);
				parts.push(doBody);
				if (endsWithBrace(doBody)) parts.push(" while");
				else parts.push("\nwhile");
				parts.push(" (", path.call(print$4, "test"), ");");
				return lines_1.concat(parts);
			case "DoExpression":
				var statements = path.call(function(bodyPath) {
					return printStatementSequence(bodyPath, options, print$4);
				}, "body");
				return lines_1.concat([
					"do {\n",
					statements.indent(options.tabWidth),
					"\n}"
				]);
			case "BreakStatement":
				parts.push("break");
				if (n$6.label) parts.push(" ", path.call(print$4, "label"));
				parts.push(";");
				return lines_1.concat(parts);
			case "ContinueStatement":
				parts.push("continue");
				if (n$6.label) parts.push(" ", path.call(print$4, "label"));
				parts.push(";");
				return lines_1.concat(parts);
			case "LabeledStatement": return lines_1.concat([
				path.call(print$4, "label"),
				":\n",
				path.call(print$4, "body")
			]);
			case "TryStatement":
				parts.push("try ", path.call(print$4, "block"));
				if (n$6.handler) parts.push(" ", path.call(print$4, "handler"));
				else if (n$6.handlers) path.each(function(handlerPath) {
					parts.push(" ", print$4(handlerPath));
				}, "handlers");
				if (n$6.finalizer) parts.push(" finally ", path.call(print$4, "finalizer"));
				return lines_1.concat(parts);
			case "CatchClause":
				parts.push("catch ");
				if (n$6.param) parts.push("(", path.call(print$4, "param"));
				if (n$6.guard) parts.push(" if ", path.call(print$4, "guard"));
				if (n$6.param) parts.push(") ");
				parts.push(path.call(print$4, "body"));
				return lines_1.concat(parts);
			case "ThrowStatement": return lines_1.concat([
				"throw ",
				path.call(print$4, "argument"),
				";"
			]);
			case "SwitchStatement": return lines_1.concat([
				"switch (",
				path.call(print$4, "discriminant"),
				") {\n",
				lines_1.fromString("\n").join(path.map(print$4, "cases")),
				"\n}"
			]);
			case "SwitchCase":
				if (n$6.test) parts.push("case ", path.call(print$4, "test"), ":");
				else parts.push("default:");
				if (n$6.consequent.length > 0) parts.push("\n", path.call(function(consequentPath) {
					return printStatementSequence(consequentPath, options, print$4);
				}, "consequent").indent(options.tabWidth));
				return lines_1.concat(parts);
			case "DebuggerStatement": return lines_1.fromString("debugger;");
			case "JSXAttribute":
				parts.push(path.call(print$4, "name"));
				if (n$6.value) parts.push("=", path.call(print$4, "value"));
				return lines_1.concat(parts);
			case "JSXIdentifier": return lines_1.fromString(n$6.name, options);
			case "JSXNamespacedName": return lines_1.fromString(":").join([path.call(print$4, "namespace"), path.call(print$4, "name")]);
			case "JSXMemberExpression": return lines_1.fromString(".").join([path.call(print$4, "object"), path.call(print$4, "property")]);
			case "JSXSpreadAttribute": return lines_1.concat([
				"{...",
				path.call(print$4, "argument"),
				"}"
			]);
			case "JSXSpreadChild": return lines_1.concat([
				"{...",
				path.call(print$4, "expression"),
				"}"
			]);
			case "JSXExpressionContainer": return lines_1.concat([
				"{",
				path.call(print$4, "expression"),
				"}"
			]);
			case "JSXElement":
			case "JSXFragment":
				var openingPropName = "opening" + (n$6.type === "JSXElement" ? "Element" : "Fragment");
				var closingPropName = "closing" + (n$6.type === "JSXElement" ? "Element" : "Fragment");
				var openingLines = path.call(print$4, openingPropName);
				if (n$6[openingPropName].selfClosing) {
					assert_1.default.ok(!n$6[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n$6.type);
					return openingLines;
				}
				var childLines = lines_1.concat(path.map(function(childPath) {
					var child = childPath.getValue();
					if (namedTypes.Literal.check(child) && typeof child.value === "string") {
						if (/\S/.test(child.value)) return child.value.replace(/^\s+|\s+$/g, "");
						else if (/\n/.test(child.value)) return "\n";
					}
					return print$4(childPath);
				}, "children")).indentTail(options.tabWidth);
				var closingLines = path.call(print$4, closingPropName);
				return lines_1.concat([
					openingLines,
					childLines,
					closingLines
				]);
			case "JSXOpeningElement":
				parts.push("<", path.call(print$4, "name"));
				var attrParts_1 = [];
				path.each(function(attrPath) {
					attrParts_1.push(" ", print$4(attrPath));
				}, "attributes");
				var attrLines = lines_1.concat(attrParts_1);
				if (attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn) {
					attrParts_1.forEach(function(part, i$2) {
						if (part === " ") {
							assert_1.default.strictEqual(i$2 % 2, 0);
							attrParts_1[i$2] = "\n";
						}
					});
					attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);
				}
				parts.push(attrLines, n$6.selfClosing ? " />" : ">");
				return lines_1.concat(parts);
			case "JSXClosingElement": return lines_1.concat([
				"</",
				path.call(print$4, "name"),
				">"
			]);
			case "JSXOpeningFragment": return lines_1.fromString("<>");
			case "JSXClosingFragment": return lines_1.fromString("</>");
			case "JSXText": return lines_1.fromString(n$6.value, options);
			case "JSXEmptyExpression": return lines_1.fromString("");
			case "TypeAnnotatedIdentifier": return lines_1.concat([
				path.call(print$4, "annotation"),
				" ",
				path.call(print$4, "identifier")
			]);
			case "ClassBody":
				if (n$6.body.length === 0) return lines_1.fromString("{}");
				return lines_1.concat([
					"{\n",
					path.call(function(bodyPath) {
						return printStatementSequence(bodyPath, options, print$4);
					}, "body").indent(options.tabWidth),
					"\n}"
				]);
			case "ClassPropertyDefinition":
				parts.push("static ", path.call(print$4, "definition"));
				if (!namedTypes.MethodDefinition.check(n$6.definition)) parts.push(";");
				return lines_1.concat(parts);
			case "ClassProperty":
				if (n$6.declare) parts.push("declare ");
				var access = n$6.accessibility || n$6.access;
				if (typeof access === "string") parts.push(access, " ");
				if (n$6.static) parts.push("static ");
				if (n$6.abstract) parts.push("abstract ");
				if (n$6.readonly) parts.push("readonly ");
				var key = path.call(print$4, "key");
				if (n$6.computed) key = lines_1.concat([
					"[",
					key,
					"]"
				]);
				if (n$6.variance) key = lines_1.concat([printVariance(path, print$4), key]);
				parts.push(key);
				if (n$6.optional) parts.push("?");
				if (n$6.definite) parts.push("!");
				if (n$6.typeAnnotation) parts.push(path.call(print$4, "typeAnnotation"));
				if (n$6.value) parts.push(" = ", path.call(print$4, "value"));
				parts.push(";");
				return lines_1.concat(parts);
			case "ClassPrivateProperty":
				if (n$6.static) parts.push("static ");
				parts.push(path.call(print$4, "key"));
				if (n$6.typeAnnotation) parts.push(path.call(print$4, "typeAnnotation"));
				if (n$6.value) parts.push(" = ", path.call(print$4, "value"));
				parts.push(";");
				return lines_1.concat(parts);
			case "ClassDeclaration":
			case "ClassExpression":
			case "DeclareClass":
				if (n$6.declare) parts.push("declare ");
				if (n$6.abstract) parts.push("abstract ");
				parts.push("class");
				if (n$6.id) parts.push(" ", path.call(print$4, "id"));
				if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				if (n$6.superClass) parts.push(" extends ", path.call(print$4, "superClass"), path.call(print$4, "superTypeParameters"));
				if (n$6.extends && n$6.extends.length > 0) parts.push(" extends ", lines_1.fromString(", ").join(path.map(print$4, "extends")));
				if (n$6["implements"] && n$6["implements"].length > 0) parts.push(" implements ", lines_1.fromString(", ").join(path.map(print$4, "implements")));
				parts.push(" ", path.call(print$4, "body"));
				if (n$6.type === "DeclareClass") return printFlowDeclaration(path, parts);
				else return lines_1.concat(parts);
			case "TemplateElement": return lines_1.fromString(n$6.value.raw, options).lockIndentTail();
			case "TemplateLiteral":
				var expressions_1 = path.map(print$4, "expressions");
				parts.push("`");
				path.each(function(childPath) {
					var i$2 = childPath.getName();
					parts.push(print$4(childPath));
					if (i$2 < expressions_1.length) parts.push("${", expressions_1[i$2], "}");
				}, "quasis");
				parts.push("`");
				return lines_1.concat(parts).lockIndentTail();
			case "TaggedTemplateExpression": return lines_1.concat([path.call(print$4, "tag"), path.call(print$4, "quasi")]);
			case "Node":
			case "Printable":
			case "SourceLocation":
			case "Position":
			case "Statement":
			case "Function":
			case "Pattern":
			case "Expression":
			case "Declaration":
			case "Specifier":
			case "NamedSpecifier":
			case "Comment":
			case "Flow":
			case "FlowType":
			case "FlowPredicate":
			case "MemberTypeAnnotation":
			case "Type":
			case "TSHasOptionalTypeParameterInstantiation":
			case "TSHasOptionalTypeParameters":
			case "TSHasOptionalTypeAnnotation":
			case "ChainElement": throw new Error("unprintable type: " + JSON.stringify(n$6.type));
			case "CommentBlock":
			case "Block": return lines_1.concat([
				"/*",
				lines_1.fromString(n$6.value, options),
				"*/"
			]);
			case "CommentLine":
			case "Line": return lines_1.concat(["//", lines_1.fromString(n$6.value, options)]);
			case "TypeAnnotation":
				if (n$6.typeAnnotation) {
					if (n$6.typeAnnotation.type !== "FunctionTypeAnnotation") parts.push(": ");
					parts.push(path.call(print$4, "typeAnnotation"));
					return lines_1.concat(parts);
				}
				return lines_1.fromString("");
			case "ExistentialTypeParam":
			case "ExistsTypeAnnotation": return lines_1.fromString("*", options);
			case "EmptyTypeAnnotation": return lines_1.fromString("empty", options);
			case "AnyTypeAnnotation": return lines_1.fromString("any", options);
			case "MixedTypeAnnotation": return lines_1.fromString("mixed", options);
			case "ArrayTypeAnnotation": return lines_1.concat([path.call(print$4, "elementType"), "[]"]);
			case "TupleTypeAnnotation":
				var printed_2 = path.map(print$4, "types");
				var joined = lines_1.fromString(", ").join(printed_2);
				var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;
				if (oneLine_3) if (options.arrayBracketSpacing) parts.push("[ ");
				else parts.push("[");
				else parts.push("[\n");
				path.each(function(elemPath) {
					var i$2 = elemPath.getName();
					if (!elemPath.getValue()) parts.push(",");
					else {
						var lines$1 = printed_2[i$2];
						if (oneLine_3) {
							if (i$2 > 0) parts.push(" ");
						} else lines$1 = lines$1.indent(options.tabWidth);
						parts.push(lines$1);
						if (i$2 < n$6.types.length - 1 || !oneLine_3 && util$1.isTrailingCommaEnabled(options, "arrays")) parts.push(",");
						if (!oneLine_3) parts.push("\n");
					}
				}, "types");
				if (oneLine_3 && options.arrayBracketSpacing) parts.push(" ]");
				else parts.push("]");
				return lines_1.concat(parts);
			case "BooleanTypeAnnotation": return lines_1.fromString("boolean", options);
			case "BooleanLiteralTypeAnnotation":
				assert_1.default.strictEqual(typeof n$6.value, "boolean");
				return lines_1.fromString("" + n$6.value, options);
			case "InterfaceTypeAnnotation":
				parts.push("interface");
				if (n$6.extends && n$6.extends.length > 0) parts.push(" extends ", lines_1.fromString(", ").join(path.map(print$4, "extends")));
				parts.push(" ", path.call(print$4, "body"));
				return lines_1.concat(parts);
			case "DeclareFunction": return printFlowDeclaration(path, [
				"function ",
				path.call(print$4, "id"),
				";"
			]);
			case "DeclareModule": return printFlowDeclaration(path, [
				"module ",
				path.call(print$4, "id"),
				" ",
				path.call(print$4, "body")
			]);
			case "DeclareModuleExports": return printFlowDeclaration(path, ["module.exports", path.call(print$4, "typeAnnotation")]);
			case "DeclareVariable": return printFlowDeclaration(path, [
				"var ",
				path.call(print$4, "id"),
				";"
			]);
			case "DeclareExportDeclaration":
			case "DeclareExportAllDeclaration": return lines_1.concat(["declare ", printExportDeclaration(path, options, print$4)]);
			case "EnumDeclaration": return lines_1.concat([
				"enum ",
				path.call(print$4, "id"),
				path.call(print$4, "body")
			]);
			case "EnumBooleanBody":
			case "EnumNumberBody":
			case "EnumStringBody":
			case "EnumSymbolBody":
				if (n$6.type === "EnumSymbolBody" || n$6.explicitType) parts.push(" of ", n$6.type.slice(4, -4).toLowerCase());
				parts.push(" {\n", lines_1.fromString("\n").join(path.map(print$4, "members")).indent(options.tabWidth), "\n}");
				return lines_1.concat(parts);
			case "EnumDefaultedMember": return lines_1.concat([path.call(print$4, "id"), ","]);
			case "EnumBooleanMember":
			case "EnumNumberMember":
			case "EnumStringMember": return lines_1.concat([
				path.call(print$4, "id"),
				" = ",
				path.call(print$4, "init"),
				","
			]);
			case "InferredPredicate": return lines_1.fromString("%checks", options);
			case "DeclaredPredicate": return lines_1.concat([
				"%checks(",
				path.call(print$4, "value"),
				")"
			]);
			case "FunctionTypeAnnotation":
				var parent = path.getParentNode(0);
				var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes.DeclareFunction.check(path.getParentNode(2)));
				if (isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent) && !namedTypes.TypeAlias.check(parent)) parts.push(": ");
				var hasTypeParameters = !!n$6.typeParameters;
				var needsParens = hasTypeParameters || n$6.params.length !== 1 || n$6.params[0].name;
				parts.push(hasTypeParameters ? path.call(print$4, "typeParameters") : "", needsParens ? "(" : "", printFunctionParams(path, options, print$4), needsParens ? ")" : "");
				if (n$6.returnType) parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print$4, "returnType"));
				return lines_1.concat(parts);
			case "FunctionTypeParam":
				var name = path.call(print$4, "name");
				parts.push(name);
				if (n$6.optional) parts.push("?");
				if (name.infos[0].line) parts.push(": ");
				parts.push(path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "GenericTypeAnnotation": return lines_1.concat([path.call(print$4, "id"), path.call(print$4, "typeParameters")]);
			case "DeclareInterface": parts.push("declare ");
			case "InterfaceDeclaration":
			case "TSInterfaceDeclaration":
				if (n$6.declare) parts.push("declare ");
				parts.push("interface ", path.call(print$4, "id"), path.call(print$4, "typeParameters"), " ");
				if (n$6["extends"] && n$6["extends"].length > 0) parts.push("extends ", lines_1.fromString(", ").join(path.map(print$4, "extends")), " ");
				if (n$6.body) parts.push(path.call(print$4, "body"));
				return lines_1.concat(parts);
			case "ClassImplements":
			case "InterfaceExtends": return lines_1.concat([path.call(print$4, "id"), path.call(print$4, "typeParameters")]);
			case "IntersectionTypeAnnotation": return lines_1.fromString(" & ").join(path.map(print$4, "types"));
			case "NullableTypeAnnotation": return lines_1.concat(["?", path.call(print$4, "typeAnnotation")]);
			case "NullLiteralTypeAnnotation": return lines_1.fromString("null", options);
			case "ThisTypeAnnotation": return lines_1.fromString("this", options);
			case "NumberTypeAnnotation": return lines_1.fromString("number", options);
			case "ObjectTypeCallProperty": return path.call(print$4, "value");
			case "ObjectTypeIndexer":
				if (n$6.static) parts.push("static ");
				parts.push(printVariance(path, print$4), "[");
				if (n$6.id) parts.push(path.call(print$4, "id"), ": ");
				parts.push(path.call(print$4, "key"), "]: ", path.call(print$4, "value"));
				return lines_1.concat(parts);
			case "ObjectTypeProperty": return lines_1.concat([
				printVariance(path, print$4),
				path.call(print$4, "key"),
				n$6.optional ? "?" : "",
				": ",
				path.call(print$4, "value")
			]);
			case "ObjectTypeInternalSlot": return lines_1.concat([
				n$6.static ? "static " : "",
				"[[",
				path.call(print$4, "id"),
				"]]",
				n$6.optional ? "?" : "",
				n$6.value.type !== "FunctionTypeAnnotation" ? ": " : "",
				path.call(print$4, "value")
			]);
			case "QualifiedTypeIdentifier": return lines_1.concat([
				path.call(print$4, "qualification"),
				".",
				path.call(print$4, "id")
			]);
			case "StringLiteralTypeAnnotation": return lines_1.fromString(nodeStr(n$6.value, options), options);
			case "NumberLiteralTypeAnnotation":
			case "NumericLiteralTypeAnnotation":
				assert_1.default.strictEqual(typeof n$6.value, "number");
				return lines_1.fromString(JSON.stringify(n$6.value), options);
			case "BigIntLiteralTypeAnnotation": return lines_1.fromString(n$6.raw, options);
			case "StringTypeAnnotation": return lines_1.fromString("string", options);
			case "DeclareTypeAlias": parts.push("declare ");
			case "TypeAlias": return lines_1.concat([
				"type ",
				path.call(print$4, "id"),
				path.call(print$4, "typeParameters"),
				" = ",
				path.call(print$4, "right"),
				";"
			]);
			case "DeclareOpaqueType": parts.push("declare ");
			case "OpaqueType":
				parts.push("opaque type ", path.call(print$4, "id"), path.call(print$4, "typeParameters"));
				if (n$6["supertype"]) parts.push(": ", path.call(print$4, "supertype"));
				if (n$6["impltype"]) parts.push(" = ", path.call(print$4, "impltype"));
				parts.push(";");
				return lines_1.concat(parts);
			case "TypeCastExpression": return lines_1.concat([
				"(",
				path.call(print$4, "expression"),
				path.call(print$4, "typeAnnotation"),
				")"
			]);
			case "TypeParameterDeclaration":
			case "TypeParameterInstantiation": return lines_1.concat([
				"<",
				lines_1.fromString(", ").join(path.map(print$4, "params")),
				">"
			]);
			case "Variance":
				if (n$6.kind === "plus") return lines_1.fromString("+");
				if (n$6.kind === "minus") return lines_1.fromString("-");
				return lines_1.fromString("");
			case "TypeParameter":
				if (n$6.variance) parts.push(printVariance(path, print$4));
				parts.push(path.call(print$4, "name"));
				if (n$6.bound) parts.push(path.call(print$4, "bound"));
				if (n$6["default"]) parts.push("=", path.call(print$4, "default"));
				return lines_1.concat(parts);
			case "TypeofTypeAnnotation": return lines_1.concat([lines_1.fromString("typeof ", options), path.call(print$4, "argument")]);
			case "IndexedAccessType":
			case "OptionalIndexedAccessType": return lines_1.concat([
				path.call(print$4, "objectType"),
				n$6.optional ? "?." : "",
				"[",
				path.call(print$4, "indexType"),
				"]"
			]);
			case "UnionTypeAnnotation": return lines_1.fromString(" | ").join(path.map(print$4, "types"));
			case "VoidTypeAnnotation": return lines_1.fromString("void", options);
			case "NullTypeAnnotation": return lines_1.fromString("null", options);
			case "SymbolTypeAnnotation": return lines_1.fromString("symbol", options);
			case "BigIntTypeAnnotation": return lines_1.fromString("bigint", options);
			case "TSType": throw new Error("unprintable type: " + JSON.stringify(n$6.type));
			case "TSNumberKeyword": return lines_1.fromString("number", options);
			case "TSBigIntKeyword": return lines_1.fromString("bigint", options);
			case "TSObjectKeyword": return lines_1.fromString("object", options);
			case "TSBooleanKeyword": return lines_1.fromString("boolean", options);
			case "TSStringKeyword": return lines_1.fromString("string", options);
			case "TSSymbolKeyword": return lines_1.fromString("symbol", options);
			case "TSAnyKeyword": return lines_1.fromString("any", options);
			case "TSVoidKeyword": return lines_1.fromString("void", options);
			case "TSIntrinsicKeyword": return lines_1.fromString("intrinsic", options);
			case "TSThisType": return lines_1.fromString("this", options);
			case "TSNullKeyword": return lines_1.fromString("null", options);
			case "TSUndefinedKeyword": return lines_1.fromString("undefined", options);
			case "TSUnknownKeyword": return lines_1.fromString("unknown", options);
			case "TSNeverKeyword": return lines_1.fromString("never", options);
			case "TSArrayType": return lines_1.concat([path.call(print$4, "elementType"), "[]"]);
			case "TSLiteralType": return path.call(print$4, "literal");
			case "TSUnionType": return lines_1.fromString(" | ").join(path.map(print$4, "types"));
			case "TSIntersectionType": return lines_1.fromString(" & ").join(path.map(print$4, "types"));
			case "TSConditionalType":
				parts.push(path.call(print$4, "checkType"), " extends ", path.call(print$4, "extendsType"), " ? ", path.call(print$4, "trueType"), " : ", path.call(print$4, "falseType"));
				return lines_1.concat(parts);
			case "TSInferType":
				parts.push("infer ", path.call(print$4, "typeParameter"));
				return lines_1.concat(parts);
			case "TSParenthesizedType": return lines_1.concat([
				"(",
				path.call(print$4, "typeAnnotation"),
				")"
			]);
			case "TSFunctionType": return lines_1.concat([
				path.call(print$4, "typeParameters"),
				"(",
				printFunctionParams(path, options, print$4),
				") => ",
				path.call(print$4, "typeAnnotation", "typeAnnotation")
			]);
			case "TSConstructorType": return lines_1.concat([
				"new ",
				path.call(print$4, "typeParameters"),
				"(",
				printFunctionParams(path, options, print$4),
				") => ",
				path.call(print$4, "typeAnnotation", "typeAnnotation")
			]);
			case "TSMappedType":
				parts.push(n$6.readonly ? "readonly " : "", "[", path.call(print$4, "typeParameter"), "]", n$6.optional ? "?" : "");
				if (n$6.typeAnnotation) parts.push(": ", path.call(print$4, "typeAnnotation"), ";");
				return lines_1.concat([
					"{\n",
					lines_1.concat(parts).indent(options.tabWidth),
					"\n}"
				]);
			case "TSTupleType": return lines_1.concat([
				"[",
				lines_1.fromString(", ").join(path.map(print$4, "elementTypes")),
				"]"
			]);
			case "TSNamedTupleMember":
				parts.push(path.call(print$4, "label"));
				if (n$6.optional) parts.push("?");
				parts.push(": ", path.call(print$4, "elementType"));
				return lines_1.concat(parts);
			case "TSRestType": return lines_1.concat(["...", path.call(print$4, "typeAnnotation")]);
			case "TSOptionalType": return lines_1.concat([path.call(print$4, "typeAnnotation"), "?"]);
			case "TSIndexedAccessType": return lines_1.concat([
				path.call(print$4, "objectType"),
				"[",
				path.call(print$4, "indexType"),
				"]"
			]);
			case "TSTypeOperator": return lines_1.concat([
				path.call(print$4, "operator"),
				" ",
				path.call(print$4, "typeAnnotation")
			]);
			case "TSTypeLiteral":
				var memberLines = lines_1.fromString("\n").join(path.map(print$4, "members"));
				if (memberLines.isEmpty()) return lines_1.fromString("{}", options);
				parts.push("{\n", memberLines.indent(options.tabWidth), "\n}");
				return lines_1.concat(parts);
			case "TSEnumMember":
				parts.push(path.call(print$4, "id"));
				if (n$6.initializer) parts.push(" = ", path.call(print$4, "initializer"));
				return lines_1.concat(parts);
			case "TSTypeQuery": return lines_1.concat(["typeof ", path.call(print$4, "exprName")]);
			case "TSParameterProperty":
				if (n$6.accessibility) parts.push(n$6.accessibility, " ");
				if (n$6.export) parts.push("export ");
				if (n$6.static) parts.push("static ");
				if (n$6.readonly) parts.push("readonly ");
				parts.push(path.call(print$4, "parameter"));
				return lines_1.concat(parts);
			case "TSTypeReference": return lines_1.concat([path.call(print$4, "typeName"), path.call(print$4, "typeParameters")]);
			case "TSQualifiedName": return lines_1.concat([
				path.call(print$4, "left"),
				".",
				path.call(print$4, "right")
			]);
			case "TSAsExpression":
				var expression = path.call(print$4, "expression");
				parts.push(expression, lines_1.fromString(" as "), path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "TSNonNullExpression": return lines_1.concat([path.call(print$4, "expression"), "!"]);
			case "TSTypeAnnotation": return lines_1.concat([": ", path.call(print$4, "typeAnnotation")]);
			case "TSIndexSignature": return lines_1.concat([
				n$6.readonly ? "readonly " : "",
				"[",
				path.map(print$4, "parameters"),
				"]",
				path.call(print$4, "typeAnnotation")
			]);
			case "TSPropertySignature":
				parts.push(printVariance(path, print$4), n$6.readonly ? "readonly " : "");
				if (n$6.computed) parts.push("[", path.call(print$4, "key"), "]");
				else parts.push(path.call(print$4, "key"));
				parts.push(n$6.optional ? "?" : "", path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "TSMethodSignature":
				if (n$6.computed) parts.push("[", path.call(print$4, "key"), "]");
				else parts.push(path.call(print$4, "key"));
				if (n$6.optional) parts.push("?");
				parts.push(path.call(print$4, "typeParameters"), "(", printFunctionParams(path, options, print$4), ")", path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "TSTypePredicate":
				if (n$6.asserts) parts.push("asserts ");
				parts.push(path.call(print$4, "parameterName"));
				if (n$6.typeAnnotation) parts.push(" is ", path.call(print$4, "typeAnnotation", "typeAnnotation"));
				return lines_1.concat(parts);
			case "TSCallSignatureDeclaration": return lines_1.concat([
				path.call(print$4, "typeParameters"),
				"(",
				printFunctionParams(path, options, print$4),
				")",
				path.call(print$4, "typeAnnotation")
			]);
			case "TSConstructSignatureDeclaration":
				if (n$6.typeParameters) parts.push("new", path.call(print$4, "typeParameters"));
				else parts.push("new ");
				parts.push("(", printFunctionParams(path, options, print$4), ")", path.call(print$4, "typeAnnotation"));
				return lines_1.concat(parts);
			case "TSTypeAliasDeclaration": return lines_1.concat([
				n$6.declare ? "declare " : "",
				"type ",
				path.call(print$4, "id"),
				path.call(print$4, "typeParameters"),
				" = ",
				path.call(print$4, "typeAnnotation"),
				";"
			]);
			case "TSTypeParameter":
				parts.push(path.call(print$4, "name"));
				var parent = path.getParentNode(0);
				var isInMappedType = namedTypes.TSMappedType.check(parent);
				if (n$6.constraint) parts.push(isInMappedType ? " in " : " extends ", path.call(print$4, "constraint"));
				if (n$6["default"]) parts.push(" = ", path.call(print$4, "default"));
				return lines_1.concat(parts);
			case "TSTypeAssertion":
				parts.push("<", path.call(print$4, "typeAnnotation"), "> ", path.call(print$4, "expression"));
				return lines_1.concat(parts);
			case "TSTypeParameterDeclaration":
			case "TSTypeParameterInstantiation": return lines_1.concat([
				"<",
				lines_1.fromString(", ").join(path.map(print$4, "params")),
				">"
			]);
			case "TSEnumDeclaration":
				parts.push(n$6.declare ? "declare " : "", n$6.const ? "const " : "", "enum ", path.call(print$4, "id"));
				var memberLines = lines_1.fromString(",\n").join(path.map(print$4, "members"));
				if (memberLines.isEmpty()) parts.push(" {}");
				else parts.push(" {\n", memberLines.indent(options.tabWidth), "\n}");
				return lines_1.concat(parts);
			case "TSExpressionWithTypeArguments": return lines_1.concat([path.call(print$4, "expression"), path.call(print$4, "typeParameters")]);
			case "TSInterfaceBody":
				var lines = lines_1.fromString("\n").join(path.map(print$4, "body"));
				if (lines.isEmpty()) return lines_1.fromString("{}", options);
				return lines_1.concat([
					"{\n",
					lines.indent(options.tabWidth),
					"\n}"
				]);
			case "TSImportType":
				parts.push("import(", path.call(print$4, "argument"), ")");
				if (n$6.qualifier) parts.push(".", path.call(print$4, "qualifier"));
				if (n$6.typeParameters) parts.push(path.call(print$4, "typeParameters"));
				return lines_1.concat(parts);
			case "TSImportEqualsDeclaration":
				if (n$6.isExport) parts.push("export ");
				parts.push("import ", path.call(print$4, "id"), " = ", path.call(print$4, "moduleReference"));
				return maybeAddSemicolon(lines_1.concat(parts));
			case "TSExternalModuleReference": return lines_1.concat([
				"require(",
				path.call(print$4, "expression"),
				")"
			]);
			case "TSModuleDeclaration":
				var parent = path.getParentNode();
				if (parent.type === "TSModuleDeclaration") parts.push(".");
				else {
					if (n$6.declare) parts.push("declare ");
					if (!n$6.global) if (n$6.id.type === "StringLiteral" || n$6.id.type === "Literal" && typeof n$6.id.value === "string") parts.push("module ");
					else if (n$6.loc && n$6.loc.lines && n$6.id.loc) if (n$6.loc.lines.sliceString(n$6.loc.start, n$6.id.loc.start).indexOf("module") >= 0) parts.push("module ");
					else parts.push("namespace ");
					else parts.push("namespace ");
				}
				parts.push(path.call(print$4, "id"));
				if (n$6.body) {
					parts.push(" ");
					parts.push(path.call(print$4, "body"));
				}
				return lines_1.concat(parts);
			case "TSModuleBlock":
				var naked = path.call(function(bodyPath) {
					return printStatementSequence(bodyPath, options, print$4);
				}, "body");
				if (naked.isEmpty()) parts.push("{}");
				else parts.push("{\n", naked.indent(options.tabWidth), "\n}");
				return lines_1.concat(parts);
			case "V8IntrinsicIdentifier": return lines_1.concat(["%", path.call(print$4, "name")]);
			case "TopicReference": return lines_1.fromString("#");
			case "ClassHeritage":
			case "ComprehensionBlock":
			case "ComprehensionExpression":
			case "Glob":
			case "GeneratorExpression":
			case "LetStatement":
			case "LetExpression":
			case "GraphExpression":
			case "GraphIndexExpression":
			case "XMLDefaultDeclaration":
			case "XMLAnyName":
			case "XMLQualifiedIdentifier":
			case "XMLFunctionQualifiedIdentifier":
			case "XMLAttributeSelector":
			case "XMLFilterExpression":
			case "XML":
			case "XMLElement":
			case "XMLList":
			case "XMLEscape":
			case "XMLText":
			case "XMLStartTag":
			case "XMLEndTag":
			case "XMLPointTag":
			case "XMLName":
			case "XMLAttribute":
			case "XMLCdata":
			case "XMLComment":
			case "XMLProcessingInstruction":
			default:
				debugger;
				throw new Error("unknown type: " + JSON.stringify(n$6.type));
		}
	}
	function printDecorators(path, printPath) {
		var parts = [];
		var node = path.getValue();
		if (node.decorators && node.decorators.length > 0 && !util$1.getParentExportDeclaration(path)) path.each(function(decoratorPath) {
			parts.push(printPath(decoratorPath), "\n");
		}, "decorators");
		else if (util$1.isExportDeclaration(node) && node.declaration && node.declaration.decorators) path.each(function(decoratorPath) {
			parts.push(printPath(decoratorPath), "\n");
		}, "declaration", "decorators");
		return lines_1.concat(parts);
	}
	function printStatementSequence(path, options, print$4) {
		var filtered = [];
		var sawComment = false;
		var sawStatement = false;
		path.each(function(stmtPath) {
			var stmt = stmtPath.getValue();
			if (!stmt) return;
			if (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0)) return;
			if (namedTypes.Comment.check(stmt)) sawComment = true;
			else if (namedTypes.Statement.check(stmt)) sawStatement = true;
			else isString.assert(stmt);
			filtered.push({
				node: stmt,
				printed: print$4(stmtPath)
			});
		});
		if (sawComment) assert_1.default.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
		var prevTrailingSpace = null;
		var len$1 = filtered.length;
		var parts = [];
		filtered.forEach(function(info, i$2) {
			var printed = info.printed;
			var stmt = info.node;
			var multiLine = printed.length > 1;
			var notFirst = i$2 > 0;
			var notLast = i$2 < len$1 - 1;
			var leadingSpace;
			var trailingSpace;
			var lines = stmt && stmt.loc && stmt.loc.lines;
			var trueLoc = lines && options.reuseWhitespace && util$1.getTrueLoc(stmt, lines);
			if (notFirst) if (trueLoc) {
				var beforeStart = lines.skipSpaces(trueLoc.start, true);
				var beforeStartLine = beforeStart ? beforeStart.line : 1;
				var leadingGap = trueLoc.start.line - beforeStartLine;
				leadingSpace = Array(leadingGap + 1).join("\n");
			} else leadingSpace = multiLine ? "\n\n" : "\n";
			else leadingSpace = "";
			if (notLast) if (trueLoc) {
				var afterEnd = lines.skipSpaces(trueLoc.end);
				var trailingGap = (afterEnd ? afterEnd.line : lines.length) - trueLoc.end.line;
				trailingSpace = Array(trailingGap + 1).join("\n");
			} else trailingSpace = multiLine ? "\n\n" : "\n";
			else trailingSpace = "";
			parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
			if (notLast) prevTrailingSpace = trailingSpace;
			else if (trailingSpace) parts.push(trailingSpace);
		});
		return lines_1.concat(parts);
	}
	function maxSpace(s1, s2) {
		if (!s1 && !s2) return lines_1.fromString("");
		if (!s1) return lines_1.fromString(s2);
		if (!s2) return lines_1.fromString(s1);
		var spaceLines1 = lines_1.fromString(s1);
		var spaceLines2 = lines_1.fromString(s2);
		if (spaceLines2.length > spaceLines1.length) return spaceLines2;
		return spaceLines1;
	}
	function printMethod(path, options, print$4) {
		var node = path.getNode();
		var kind = node.kind;
		var parts = [];
		var nodeValue = node.value;
		if (!namedTypes.FunctionExpression.check(nodeValue)) nodeValue = node;
		var access = node.accessibility || node.access;
		if (typeof access === "string") parts.push(access, " ");
		if (node.static) parts.push("static ");
		if (node.abstract) parts.push("abstract ");
		if (node.override) parts.push("override ");
		if (node.readonly) parts.push("readonly ");
		if (nodeValue.async) parts.push("async ");
		if (nodeValue.generator) parts.push("*");
		if (kind === "get" || kind === "set") parts.push(kind, " ");
		var key = path.call(print$4, "key");
		if (node.computed) key = lines_1.concat([
			"[",
			key,
			"]"
		]);
		parts.push(key);
		if (node.optional) parts.push("?");
		if (node === nodeValue) {
			parts.push(path.call(print$4, "typeParameters"), "(", printFunctionParams(path, options, print$4), ")", path.call(print$4, "returnType"));
			if (node.body) parts.push(" ", path.call(print$4, "body"));
			else parts.push(";");
		} else {
			parts.push(path.call(print$4, "value", "typeParameters"), "(", path.call(function(valuePath) {
				return printFunctionParams(valuePath, options, print$4);
			}, "value"), ")", path.call(print$4, "value", "returnType"));
			if (nodeValue.body) parts.push(" ", path.call(print$4, "value", "body"));
			else parts.push(";");
		}
		return lines_1.concat(parts);
	}
	function printArgumentsList(path, options, print$4) {
		var printed = path.map(print$4, "arguments");
		var trailingComma = util$1.isTrailingCommaEnabled(options, "parameters");
		var joined = lines_1.fromString(", ").join(printed);
		if (joined.getLineLength(1) > options.wrapColumn) {
			joined = lines_1.fromString(",\n").join(printed);
			return lines_1.concat([
				"(\n",
				joined.indent(options.tabWidth),
				trailingComma ? ",\n)" : "\n)"
			]);
		}
		return lines_1.concat([
			"(",
			joined,
			")"
		]);
	}
	function printFunctionParams(path, options, print$4) {
		var fun = path.getValue();
		var params;
		var printed = [];
		if (fun.params) {
			params = fun.params;
			printed = path.map(print$4, "params");
		} else if (fun.parameters) {
			params = fun.parameters;
			printed = path.map(print$4, "parameters");
		}
		if (fun.defaults) path.each(function(defExprPath) {
			var i$2 = defExprPath.getName();
			var p$1 = printed[i$2];
			if (p$1 && defExprPath.getValue()) printed[i$2] = lines_1.concat([
				p$1,
				" = ",
				print$4(defExprPath)
			]);
		}, "defaults");
		if (fun.rest) printed.push(lines_1.concat(["...", path.call(print$4, "rest")]));
		var joined = lines_1.fromString(", ").join(printed);
		if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
			joined = lines_1.fromString(",\n").join(printed);
			if (util$1.isTrailingCommaEnabled(options, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement") joined = lines_1.concat([joined, ",\n"]);
			else joined = lines_1.concat([joined, "\n"]);
			return lines_1.concat(["\n", joined.indent(options.tabWidth)]);
		}
		return joined;
	}
	function maybePrintImportAssertions(path, options, print$4) {
		var n$6 = path.getValue();
		if (n$6.assertions && n$6.assertions.length > 0) {
			var parts = [" assert {"];
			var printed = path.map(print$4, "assertions");
			var flat = lines_1.fromString(", ").join(printed);
			if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) parts.push("\n", lines_1.fromString(",\n").join(printed).indent(options.tabWidth), "\n}");
			else parts.push(" ", flat, " }");
			return lines_1.concat(parts);
		}
		return lines_1.fromString("");
	}
	function printExportDeclaration(path, options, print$4) {
		var decl = path.getValue();
		var parts = ["export "];
		if (decl.exportKind && decl.exportKind === "type") {
			if (!decl.declaration) parts.push("type ");
		}
		var shouldPrintSpaces = options.objectCurlySpacing;
		namedTypes.Declaration.assert(decl);
		if (decl["default"] || decl.type === "ExportDefaultDeclaration") parts.push("default ");
		if (decl.declaration) parts.push(path.call(print$4, "declaration"));
		else if (decl.specifiers) {
			if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") parts.push("*");
			else if (decl.specifiers.length === 0) parts.push("{}");
			else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
				var unbracedSpecifiers_2 = [];
				var bracedSpecifiers_2 = [];
				path.each(function(specifierPath) {
					if (specifierPath.getValue().type === "ExportDefaultSpecifier") unbracedSpecifiers_2.push(print$4(specifierPath));
					else bracedSpecifiers_2.push(print$4(specifierPath));
				}, "specifiers");
				unbracedSpecifiers_2.forEach(function(lines$1, i$2) {
					if (i$2 > 0) parts.push(", ");
					parts.push(lines$1);
				});
				if (bracedSpecifiers_2.length > 0) {
					var lines_2 = lines_1.fromString(", ").join(bracedSpecifiers_2);
					if (lines_2.getLineLength(1) > options.wrapColumn) lines_2 = lines_1.concat([lines_1.fromString(",\n").join(bracedSpecifiers_2).indent(options.tabWidth), ","]);
					if (unbracedSpecifiers_2.length > 0) parts.push(", ");
					if (lines_2.length > 1) parts.push("{\n", lines_2, "\n}");
					else if (options.objectCurlySpacing) parts.push("{ ", lines_2, " }");
					else parts.push("{", lines_2, "}");
				}
			} else parts.push(shouldPrintSpaces ? "{ " : "{", lines_1.fromString(", ").join(path.map(print$4, "specifiers")), shouldPrintSpaces ? " }" : "}");
			if (decl.source) parts.push(" from ", path.call(print$4, "source"), maybePrintImportAssertions(path, options, print$4));
		}
		var lines = lines_1.concat(parts);
		if (lastNonSpaceCharacter(lines) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration"))) lines = lines_1.concat([lines, ";"]);
		return lines;
	}
	function printFlowDeclaration(path, parts) {
		var parentExportDecl = util$1.getParentExportDeclaration(path);
		if (parentExportDecl) assert_1.default.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
		else parts.unshift("declare ");
		return lines_1.concat(parts);
	}
	function printVariance(path, print$4) {
		return path.call(function(variancePath) {
			var value = variancePath.getValue();
			if (value) {
				if (value === "plus") return lines_1.fromString("+");
				if (value === "minus") return lines_1.fromString("-");
				return print$4(variancePath);
			}
			return lines_1.fromString("");
		}, "variance");
	}
	function adjustClause(clause, options) {
		if (clause.length > 1) return lines_1.concat([" ", clause]);
		return lines_1.concat(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
	}
	function lastNonSpaceCharacter(lines) {
		var pos = lines.lastPos();
		do {
			var ch = lines.charAt(pos);
			if (/\S/.test(ch)) return ch;
		} while (lines.prevPos(pos));
	}
	function endsWithBrace(lines) {
		return lastNonSpaceCharacter(lines) === "}";
	}
	function swapQuotes(str) {
		return str.replace(/['"]/g, function(m$1) {
			return m$1 === "\"" ? "'" : "\"";
		});
	}
	function getPossibleRaw(node) {
		var value = types$3.getFieldValue(node, "value");
		var extra = types$3.getFieldValue(node, "extra");
		if (extra && typeof extra.raw === "string" && value == extra.rawValue) return extra.raw;
		if (node.type === "Literal") {
			var raw = node.raw;
			if (typeof raw === "string" && value == raw) return raw;
		}
	}
	function jsSafeStringify(str) {
		return JSON.stringify(str).replace(/[\u2028\u2029]/g, function(m$1) {
			return "\\u" + m$1.charCodeAt(0).toString(16);
		});
	}
	function nodeStr(str, options) {
		isString.assert(str);
		switch (options.quote) {
			case "auto":
				var double = jsSafeStringify(str);
				var single = swapQuotes(jsSafeStringify(swapQuotes(str)));
				return double.length > single.length ? single : double;
			case "single": return swapQuotes(jsSafeStringify(swapQuotes(str)));
			case "double":
			default: return jsSafeStringify(str);
		}
	}
	function maybeAddSemicolon(lines) {
		var eoc = lastNonSpaceCharacter(lines);
		if (!eoc || "\n};".indexOf(eoc) < 0) return lines_1.concat([lines, ";"]);
		return lines;
	}
}));
var require_main$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	init_dist$1();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.run = exports.prettyPrint = exports.print = exports.visit = exports.types = exports.parse = void 0;
	var tslib_1$28 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var fs_1 = tslib_1$28.__importDefault((init_empty(), __toCommonJS(empty_exports)));
	exports.types = tslib_1$28.__importStar(require_main$2());
	var parser_1 = require_parser();
	Object.defineProperty(exports, "parse", {
		enumerable: true,
		get: function() {
			return parser_1.parse;
		}
	});
	var printer_1 = require_printer();
	var ast_types_1 = require_main$2();
	Object.defineProperty(exports, "visit", {
		enumerable: true,
		get: function() {
			return ast_types_1.visit;
		}
	});
	function print$3(node, options) {
		return new printer_1.Printer(options).print(node);
	}
	exports.print = print$3;
	function prettyPrint(node, options) {
		return new printer_1.Printer(options).printGenerically(node);
	}
	exports.prettyPrint = prettyPrint;
	function run(transformer, options) {
		return runFile(process$1.argv[2], transformer, options);
	}
	exports.run = run;
	function runFile(path, transformer, options) {
		fs_1.default.readFile(path, "utf-8", function(err, code$1) {
			if (err) {
				console.error(err);
				return;
			}
			runString(code$1, transformer, options);
		});
	}
	function defaultWriteback(output) {
		process$1.stdout.write(output);
	}
	function runString(code$1, transformer, options) {
		var writeback = options && options.writeback || defaultWriteback;
		transformer(parser_1.parse(code$1, options), function(node) {
			writeback(print$3(node, options).code);
		});
	}
}));
var require_shared = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var types_1$21 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1)).__importDefault(require_types());
	function default_1$23(fork) {
		var types$8 = fork.use(types_1$21.default);
		var Type$2 = types$8.Type;
		var builtin = types$8.builtInTypes;
		var isNumber$3 = builtin.number;
		function geq(than) {
			return Type$2.from(function(value) {
				return isNumber$3.check(value) && value >= than;
			}, isNumber$3 + " >= " + than);
		}
		var defaults$1 = {
			"null": function() {
				return null;
			},
			"emptyArray": function() {
				return [];
			},
			"false": function() {
				return false;
			},
			"true": function() {
				return true;
			},
			"undefined": function() {},
			"use strict": function() {
				return "use strict";
			}
		};
		var naiveIsPrimitive = Type$2.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
		return {
			geq,
			defaults: defaults$1,
			isPrimitive: Type$2.from(function(value) {
				if (value === null) return true;
				var type = typeof value;
				if (type === "object" || type === "function") return false;
				return true;
			}, naiveIsPrimitive.toString())
		};
	}
	exports.default = default_1$23;
	function maybeSetModuleExports(moduleGetter) {
		try {
			var nodeModule = moduleGetter();
			var originalExports = nodeModule.exports;
			var defaultExport = originalExports["default"];
		} catch (_a$2) {
			return;
		}
		if (defaultExport && defaultExport !== originalExports && typeof originalExports === "object") {
			Object.assign(defaultExport, originalExports, { "default": defaultExport });
			if (originalExports.__esModule) Object.defineProperty(defaultExport, "__esModule", { value: true });
			nodeModule.exports = defaultExport;
		}
	}
	exports.maybeSetModuleExports = maybeSetModuleExports;
}));
var require_types = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Def = void 0;
	var tslib_1$27 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$27 = require_shared();
	var Op = Object.prototype;
	var objToStr = Op.toString;
	var hasOwn$3 = Op.hasOwnProperty;
	var BaseType = function() {
		function BaseType$2() {}
		BaseType$2.prototype.assert = function(value, deep) {
			if (!this.check(value, deep)) {
				var str = shallowStringify(value);
				throw new Error(str + " does not match type " + this);
			}
			return true;
		};
		BaseType$2.prototype.arrayOf = function() {
			return new ArrayType(this);
		};
		return BaseType$2;
	}();
	var ArrayType = function(_super) {
		tslib_1$27.__extends(ArrayType$2, _super);
		function ArrayType$2(elemType) {
			var _this = _super.call(this) || this;
			_this.elemType = elemType;
			_this.kind = "ArrayType";
			return _this;
		}
		ArrayType$2.prototype.toString = function() {
			return "[" + this.elemType + "]";
		};
		ArrayType$2.prototype.check = function(value, deep) {
			var _this = this;
			return Array.isArray(value) && value.every(function(elem) {
				return _this.elemType.check(elem, deep);
			});
		};
		return ArrayType$2;
	}(BaseType);
	var IdentityType = function(_super) {
		tslib_1$27.__extends(IdentityType$2, _super);
		function IdentityType$2(value) {
			var _this = _super.call(this) || this;
			_this.value = value;
			_this.kind = "IdentityType";
			return _this;
		}
		IdentityType$2.prototype.toString = function() {
			return String(this.value);
		};
		IdentityType$2.prototype.check = function(value, deep) {
			var result = value === this.value;
			if (!result && typeof deep === "function") deep(this, value);
			return result;
		};
		return IdentityType$2;
	}(BaseType);
	var ObjectType = function(_super) {
		tslib_1$27.__extends(ObjectType$2, _super);
		function ObjectType$2(fields) {
			var _this = _super.call(this) || this;
			_this.fields = fields;
			_this.kind = "ObjectType";
			return _this;
		}
		ObjectType$2.prototype.toString = function() {
			return "{ " + this.fields.join(", ") + " }";
		};
		ObjectType$2.prototype.check = function(value, deep) {
			return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
				return field.type.check(value[field.name], deep);
			});
		};
		return ObjectType$2;
	}(BaseType);
	var OrType = function(_super) {
		tslib_1$27.__extends(OrType$2, _super);
		function OrType$2(types$8) {
			var _this = _super.call(this) || this;
			_this.types = types$8;
			_this.kind = "OrType";
			return _this;
		}
		OrType$2.prototype.toString = function() {
			return this.types.join(" | ");
		};
		OrType$2.prototype.check = function(value, deep) {
			if (this.types.some(function(type) {
				return type.check(value, !!deep);
			})) return true;
			if (typeof deep === "function") deep(this, value);
			return false;
		};
		return OrType$2;
	}(BaseType);
	var PredicateType = function(_super) {
		tslib_1$27.__extends(PredicateType$2, _super);
		function PredicateType$2(name, predicate) {
			var _this = _super.call(this) || this;
			_this.name = name;
			_this.predicate = predicate;
			_this.kind = "PredicateType";
			return _this;
		}
		PredicateType$2.prototype.toString = function() {
			return this.name;
		};
		PredicateType$2.prototype.check = function(value, deep) {
			var result = this.predicate(value, deep);
			if (!result && typeof deep === "function") deep(this, value);
			return result;
		};
		return PredicateType$2;
	}(BaseType);
	var Def = function() {
		function Def$2(type, typeName) {
			this.type = type;
			this.typeName = typeName;
			this.baseNames = [];
			this.ownFields = Object.create(null);
			this.allSupertypes = Object.create(null);
			this.supertypeList = [];
			this.allFields = Object.create(null);
			this.fieldNames = [];
			this.finalized = false;
			this.buildable = false;
			this.buildParams = [];
		}
		Def$2.prototype.isSupertypeOf = function(that) {
			if (that instanceof Def$2) {
				if (this.finalized !== true || that.finalized !== true) throw new Error("");
				return hasOwn$3.call(that.allSupertypes, this.typeName);
			} else throw new Error(that + " is not a Def");
		};
		Def$2.prototype.checkAllFields = function(value, deep) {
			var allFields = this.allFields;
			if (this.finalized !== true) throw new Error("" + this.typeName);
			function checkFieldByName(name) {
				var field = allFields[name];
				var type = field.type;
				var child = field.getValue(value);
				return type.check(child, deep);
			}
			return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
		};
		Def$2.prototype.bases = function() {
			var supertypeNames = [];
			for (var _i = 0; _i < arguments.length; _i++) supertypeNames[_i] = arguments[_i];
			var bases = this.baseNames;
			if (this.finalized) {
				if (supertypeNames.length !== bases.length) throw new Error("");
				for (var i$2 = 0; i$2 < supertypeNames.length; i$2++) if (supertypeNames[i$2] !== bases[i$2]) throw new Error("");
				return this;
			}
			supertypeNames.forEach(function(baseName) {
				if (bases.indexOf(baseName) < 0) bases.push(baseName);
			});
			return this;
		};
		return Def$2;
	}();
	exports.Def = Def;
	var Field = function() {
		function Field$2(name, type, defaultFn, hidden) {
			this.name = name;
			this.type = type;
			this.defaultFn = defaultFn;
			this.hidden = !!hidden;
		}
		Field$2.prototype.toString = function() {
			return JSON.stringify(this.name) + ": " + this.type;
		};
		Field$2.prototype.getValue = function(obj) {
			var value = obj[this.name];
			if (typeof value !== "undefined") return value;
			if (typeof this.defaultFn === "function") value = this.defaultFn.call(obj);
			return value;
		};
		return Field$2;
	}();
	function shallowStringify(value) {
		if (Array.isArray(value)) return "[" + value.map(shallowStringify).join(", ") + "]";
		if (value && typeof value === "object") return "{ " + Object.keys(value).map(function(key) {
			return key + ": " + value[key];
		}).join(", ") + " }";
		return JSON.stringify(value);
	}
	function typesPlugin(_fork) {
		var Type$2 = {
			or: function() {
				var types$8 = [];
				for (var _i = 0; _i < arguments.length; _i++) types$8[_i] = arguments[_i];
				return new OrType(types$8.map(function(type) {
					return Type$2.from(type);
				}));
			},
			from: function(value, name) {
				if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) return value;
				if (value instanceof Def) return value.type;
				if (isArray$11.check(value)) {
					if (value.length !== 1) throw new Error("only one element type is permitted for typed arrays");
					return new ArrayType(Type$2.from(value[0]));
				}
				if (isObject$8.check(value)) return new ObjectType(Object.keys(value).map(function(name$1) {
					return new Field(name$1, Type$2.from(value[name$1], name$1));
				}));
				if (typeof value === "function") {
					var bicfIndex = builtInCtorFns.indexOf(value);
					if (bicfIndex >= 0) return builtInCtorTypes[bicfIndex];
					if (typeof name !== "string") throw new Error("missing name");
					return new PredicateType(name, value);
				}
				return new IdentityType(value);
			},
			def: function(typeName) {
				return hasOwn$3.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
			},
			hasDef: function(typeName) {
				return hasOwn$3.call(defCache, typeName);
			}
		};
		var builtInCtorFns = [];
		var builtInCtorTypes = [];
		function defBuiltInType(name, example) {
			var objStr = objToStr.call(example);
			var type = new PredicateType(name, function(value) {
				return objToStr.call(value) === objStr;
			});
			if (example && typeof example.constructor === "function") {
				builtInCtorFns.push(example.constructor);
				builtInCtorTypes.push(type);
			}
			return type;
		}
		var isString$4 = defBuiltInType("string", "truthy");
		var isFunction$2 = defBuiltInType("function", function() {});
		var isArray$11 = defBuiltInType("array", []);
		var isObject$8 = defBuiltInType("object", {});
		var isRegExp$3 = defBuiltInType("RegExp", /./);
		var isDate$4 = defBuiltInType("Date", /* @__PURE__ */ new Date());
		var isNumber$3 = defBuiltInType("number", 3);
		var isBoolean$1 = defBuiltInType("boolean", true);
		var isNull$1 = defBuiltInType("null", null);
		var isUndefined$2 = defBuiltInType("undefined", void 0);
		var builtInTypes$2 = {
			string: isString$4,
			function: isFunction$2,
			array: isArray$11,
			object: isObject$8,
			RegExp: isRegExp$3,
			Date: isDate$4,
			number: isNumber$3,
			boolean: isBoolean$1,
			null: isNull$1,
			undefined: isUndefined$2,
			BigInt: typeof BigInt === "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType("BigInt", function() {
				return false;
			})
		};
		var defCache = Object.create(null);
		function defFromValue(value) {
			if (value && typeof value === "object") {
				var type = value.type;
				if (typeof type === "string" && hasOwn$3.call(defCache, type)) {
					var d$1 = defCache[type];
					if (d$1.finalized) return d$1;
				}
			}
			return null;
		}
		var DefImpl = function(_super) {
			tslib_1$27.__extends(DefImpl$1, _super);
			function DefImpl$1(typeName) {
				var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
					return _this.check(value, deep);
				}), typeName) || this;
				return _this;
			}
			DefImpl$1.prototype.check = function(value, deep) {
				if (this.finalized !== true) throw new Error("prematurely checking unfinalized type " + this.typeName);
				if (value === null || typeof value !== "object") return false;
				var vDef = defFromValue(value);
				if (!vDef) {
					if (this.typeName === "SourceLocation" || this.typeName === "Position") return this.checkAllFields(value, deep);
					return false;
				}
				if (deep && vDef === this) return this.checkAllFields(value, deep);
				if (!this.isSupertypeOf(vDef)) return false;
				if (!deep) return true;
				return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
			};
			DefImpl$1.prototype.build = function() {
				var _this = this;
				var buildParams = [];
				for (var _i = 0; _i < arguments.length; _i++) buildParams[_i] = arguments[_i];
				this.buildParams = buildParams;
				if (this.buildable) return this;
				this.field("type", String, function() {
					return _this.typeName;
				});
				this.buildable = true;
				var addParam = function(built, param, arg, isArgAvailable) {
					if (hasOwn$3.call(built, param)) return;
					var all$1 = _this.allFields;
					if (!hasOwn$3.call(all$1, param)) throw new Error("" + param);
					var field = all$1[param];
					var type = field.type;
					var value;
					if (isArgAvailable) value = arg;
					else if (field.defaultFn) value = field.defaultFn.call(built);
					else {
						var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
							return all$1[name];
						}).join(", ") + ")";
						throw new Error(message);
					}
					if (!type.check(value)) throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
					built[param] = value;
				};
				var builder = function() {
					var args = [];
					for (var _i$1 = 0; _i$1 < arguments.length; _i$1++) args[_i$1] = arguments[_i$1];
					var argc = args.length;
					if (!_this.finalized) throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
					var built = Object.create(nodePrototype);
					_this.buildParams.forEach(function(param, i$2) {
						if (i$2 < argc) addParam(built, param, args[i$2], true);
						else addParam(built, param, null, false);
					});
					Object.keys(_this.allFields).forEach(function(param) {
						addParam(built, param, null, false);
					});
					if (built.type !== _this.typeName) throw new Error("");
					return built;
				};
				builder.from = function(obj) {
					if (!_this.finalized) throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
					var built = Object.create(nodePrototype);
					Object.keys(_this.allFields).forEach(function(param) {
						if (hasOwn$3.call(obj, param)) addParam(built, param, obj[param], true);
						else addParam(built, param, null, false);
					});
					if (built.type !== _this.typeName) throw new Error("");
					return built;
				};
				Object.defineProperty(builders$2, getBuilderName$2(this.typeName), {
					enumerable: true,
					value: builder
				});
				return this;
			};
			DefImpl$1.prototype.field = function(name, type, defaultFn, hidden) {
				if (this.finalized) {
					console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
					return this;
				}
				this.ownFields[name] = new Field(name, Type$2.from(type), defaultFn, hidden);
				return this;
			};
			DefImpl$1.prototype.finalize = function() {
				var _this = this;
				if (!this.finalized) {
					var allFields = this.allFields;
					var allSupertypes = this.allSupertypes;
					this.baseNames.forEach(function(name) {
						var def = defCache[name];
						if (def instanceof Def) {
							def.finalize();
							extend$1(allFields, def.allFields);
							extend$1(allSupertypes, def.allSupertypes);
						} else {
							var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
							throw new Error(message);
						}
					});
					extend$1(allFields, this.ownFields);
					allSupertypes[this.typeName] = this;
					this.fieldNames.length = 0;
					for (var fieldName in allFields) if (hasOwn$3.call(allFields, fieldName) && !allFields[fieldName].hidden) this.fieldNames.push(fieldName);
					Object.defineProperty(namedTypes$1, this.typeName, {
						enumerable: true,
						value: this.type
					});
					this.finalized = true;
					populateSupertypeList(this.typeName, this.supertypeList);
					if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) wrapExpressionBuilderWithStatement(this.typeName);
				}
			};
			return DefImpl$1;
		}(Def);
		function getSupertypeNames$2(typeName) {
			if (!hasOwn$3.call(defCache, typeName)) throw new Error("");
			var d$1 = defCache[typeName];
			if (d$1.finalized !== true) throw new Error("");
			return d$1.supertypeList.slice(1);
		}
		function computeSupertypeLookupTable(candidates) {
			var table = {};
			var typeNames = Object.keys(defCache);
			var typeNameCount = typeNames.length;
			for (var i$2 = 0; i$2 < typeNameCount; ++i$2) {
				var typeName = typeNames[i$2];
				var d$1 = defCache[typeName];
				if (d$1.finalized !== true) throw new Error("" + typeName);
				for (var j$1 = 0; j$1 < d$1.supertypeList.length; ++j$1) {
					var superTypeName = d$1.supertypeList[j$1];
					if (hasOwn$3.call(candidates, superTypeName)) {
						table[typeName] = superTypeName;
						break;
					}
				}
			}
			return table;
		}
		var builders$2 = Object.create(null);
		var nodePrototype = {};
		function defineMethod$2(name, func) {
			var old = nodePrototype[name];
			if (isUndefined$2.check(func)) delete nodePrototype[name];
			else {
				isFunction$2.assert(func);
				Object.defineProperty(nodePrototype, name, {
					enumerable: true,
					configurable: true,
					value: func
				});
			}
			return old;
		}
		function getBuilderName$2(typeName) {
			return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
				var len$1 = upperCasePrefix.length;
				switch (len$1) {
					case 0: return "";
					case 1: return upperCasePrefix.toLowerCase();
					default: return upperCasePrefix.slice(0, len$1 - 1).toLowerCase() + upperCasePrefix.charAt(len$1 - 1);
				}
			});
		}
		function getStatementBuilderName(typeName) {
			typeName = getBuilderName$2(typeName);
			return typeName.replace(/(Expression)?$/, "Statement");
		}
		var namedTypes$1 = {};
		function getFieldNames$2(object) {
			var d$1 = defFromValue(object);
			if (d$1) return d$1.fieldNames.slice(0);
			if ("type" in object) throw new Error("did not recognize object of type " + JSON.stringify(object.type));
			return Object.keys(object);
		}
		function getFieldValue$2(object, fieldName) {
			var d$1 = defFromValue(object);
			if (d$1) {
				var field = d$1.allFields[fieldName];
				if (field) return field.getValue(object);
			}
			return object && object[fieldName];
		}
		function eachField$2(object, callback, context) {
			getFieldNames$2(object).forEach(function(name) {
				callback.call(this, name, getFieldValue$2(object, name));
			}, context);
		}
		function someField$2(object, callback, context) {
			return getFieldNames$2(object).some(function(name) {
				return callback.call(this, name, getFieldValue$2(object, name));
			}, context);
		}
		function wrapExpressionBuilderWithStatement(typeName) {
			var wrapperName = getStatementBuilderName(typeName);
			if (builders$2[wrapperName]) return;
			var wrapped = builders$2[getBuilderName$2(typeName)];
			if (!wrapped) return;
			var builder = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return builders$2.expressionStatement(wrapped.apply(builders$2, args));
			};
			builder.from = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return builders$2.expressionStatement(wrapped.from.apply(builders$2, args));
			};
			builders$2[wrapperName] = builder;
		}
		function populateSupertypeList(typeName, list) {
			list.length = 0;
			list.push(typeName);
			var lastSeen = Object.create(null);
			for (var pos = 0; pos < list.length; ++pos) {
				typeName = list[pos];
				var d$1 = defCache[typeName];
				if (d$1.finalized !== true) throw new Error("");
				if (hasOwn$3.call(lastSeen, typeName)) delete list[lastSeen[typeName]];
				lastSeen[typeName] = pos;
				list.push.apply(list, d$1.baseNames);
			}
			for (var to = 0, from$2 = to, len$1 = list.length; from$2 < len$1; ++from$2) if (hasOwn$3.call(list, from$2)) list[to++] = list[from$2];
			list.length = to;
		}
		function extend$1(into, from$2) {
			Object.keys(from$2).forEach(function(name) {
				into[name] = from$2[name];
			});
			return into;
		}
		function finalize$2() {
			Object.keys(defCache).forEach(function(name) {
				defCache[name].finalize();
			});
		}
		return {
			Type: Type$2,
			builtInTypes: builtInTypes$2,
			getSupertypeNames: getSupertypeNames$2,
			computeSupertypeLookupTable,
			builders: builders$2,
			defineMethod: defineMethod$2,
			getBuilderName: getBuilderName$2,
			getStatementBuilderName,
			namedTypes: namedTypes$1,
			getFieldNames: getFieldNames$2,
			getFieldValue: getFieldValue$2,
			eachField: eachField$2,
			someField: someField$2,
			finalize: finalize$2
		};
	}
	exports.default = typesPlugin;
	(0, shared_1$27.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_path = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$26 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$26 = require_shared();
	var types_1$20 = tslib_1$26.__importDefault(require_types());
	var hasOwn$2 = Object.prototype.hasOwnProperty;
	function pathPlugin(fork) {
		var types$8 = fork.use(types_1$20.default);
		var isArray$11 = types$8.builtInTypes.array;
		var isNumber$3 = types$8.builtInTypes.number;
		var Path$2 = function Path$3(value, parentPath, name) {
			if (!(this instanceof Path$3)) throw new Error("Path constructor cannot be invoked without 'new'");
			if (parentPath) {
				if (!(parentPath instanceof Path$3)) throw new Error("");
			} else {
				parentPath = null;
				name = null;
			}
			this.value = value;
			this.parentPath = parentPath;
			this.name = name;
			this.__childCache = null;
		};
		var Pp$1 = Path$2.prototype;
		function getChildCache(path) {
			return path.__childCache || (path.__childCache = Object.create(null));
		}
		function getChildPath(path, name) {
			var cache$1 = getChildCache(path);
			var actualChildValue = path.getValueProperty(name);
			var childPath = cache$1[name];
			if (!hasOwn$2.call(cache$1, name) || childPath.value !== actualChildValue) childPath = cache$1[name] = new path.constructor(actualChildValue, path, name);
			return childPath;
		}
		Pp$1.getValueProperty = function getValueProperty(name) {
			return this.value[name];
		};
		Pp$1.get = function get$2() {
			var names = [];
			for (var _i = 0; _i < arguments.length; _i++) names[_i] = arguments[_i];
			var path = this;
			var count = names.length;
			for (var i$2 = 0; i$2 < count; ++i$2) path = getChildPath(path, names[i$2]);
			return path;
		};
		Pp$1.each = function each(callback, context) {
			var childPaths = [];
			var len$1 = this.value.length;
			var i$2 = 0;
			for (var i$2 = 0; i$2 < len$1; ++i$2) if (hasOwn$2.call(this.value, i$2)) childPaths[i$2] = this.get(i$2);
			context = context || this;
			for (i$2 = 0; i$2 < len$1; ++i$2) if (hasOwn$2.call(childPaths, i$2)) callback.call(context, childPaths[i$2]);
		};
		Pp$1.map = function map(callback, context) {
			var result = [];
			this.each(function(childPath) {
				result.push(callback.call(this, childPath));
			}, context);
			return result;
		};
		Pp$1.filter = function filter(callback, context) {
			var result = [];
			this.each(function(childPath) {
				if (callback.call(this, childPath)) result.push(childPath);
			}, context);
			return result;
		};
		function emptyMoves() {}
		function getMoves(path, offset$1, start, end) {
			isArray$11.assert(path.value);
			if (offset$1 === 0) return emptyMoves;
			var length$1 = path.value.length;
			if (length$1 < 1) return emptyMoves;
			var argc = arguments.length;
			if (argc === 2) {
				start = 0;
				end = length$1;
			} else if (argc === 3) {
				start = Math.max(start, 0);
				end = length$1;
			} else {
				start = Math.max(start, 0);
				end = Math.min(end, length$1);
			}
			isNumber$3.assert(start);
			isNumber$3.assert(end);
			var moves = Object.create(null);
			var cache$1 = getChildCache(path);
			for (var i$2 = start; i$2 < end; ++i$2) if (hasOwn$2.call(path.value, i$2)) {
				var childPath = path.get(i$2);
				if (childPath.name !== i$2) throw new Error("");
				var newIndex = i$2 + offset$1;
				childPath.name = newIndex;
				moves[newIndex] = childPath;
				delete cache$1[i$2];
			}
			delete cache$1.length;
			return function() {
				for (var newIndex$1 in moves) {
					var childPath$1 = moves[newIndex$1];
					if (childPath$1.name !== +newIndex$1) throw new Error("");
					cache$1[newIndex$1] = childPath$1;
					path.value[newIndex$1] = childPath$1.value;
				}
			};
		}
		Pp$1.shift = function shift() {
			var move = getMoves(this, -1);
			var result = this.value.shift();
			move();
			return result;
		};
		Pp$1.unshift = function unshift() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var move = getMoves(this, args.length);
			var result = this.value.unshift.apply(this.value, args);
			move();
			return result;
		};
		Pp$1.push = function push() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			isArray$11.assert(this.value);
			delete getChildCache(this).length;
			return this.value.push.apply(this.value, args);
		};
		Pp$1.pop = function pop() {
			isArray$11.assert(this.value);
			var cache$1 = getChildCache(this);
			delete cache$1[this.value.length - 1];
			delete cache$1.length;
			return this.value.pop();
		};
		Pp$1.insertAt = function insertAt(index) {
			var argc = arguments.length;
			var move = getMoves(this, argc - 1, index);
			if (move === emptyMoves && argc <= 1) return this;
			index = Math.max(index, 0);
			for (var i$2 = 1; i$2 < argc; ++i$2) this.value[index + i$2 - 1] = arguments[i$2];
			move();
			return this;
		};
		Pp$1.insertBefore = function insertBefore() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var pp = this.parentPath;
			var argc = args.length;
			var insertAtArgs = [this.name];
			for (var i$2 = 0; i$2 < argc; ++i$2) insertAtArgs.push(args[i$2]);
			return pp.insertAt.apply(pp, insertAtArgs);
		};
		Pp$1.insertAfter = function insertAfter() {
			var args = [];
			for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
			var pp = this.parentPath;
			var argc = args.length;
			var insertAtArgs = [this.name + 1];
			for (var i$2 = 0; i$2 < argc; ++i$2) insertAtArgs.push(args[i$2]);
			return pp.insertAt.apply(pp, insertAtArgs);
		};
		function repairRelationshipWithParent(path) {
			if (!(path instanceof Path$2)) throw new Error("");
			var pp = path.parentPath;
			if (!pp) return path;
			var parentValue = pp.value;
			var parentCache = getChildCache(pp);
			if (parentValue[path.name] === path.value) parentCache[path.name] = path;
			else if (isArray$11.check(parentValue)) {
				var i$2 = parentValue.indexOf(path.value);
				if (i$2 >= 0) parentCache[path.name = i$2] = path;
			} else {
				parentValue[path.name] = path.value;
				parentCache[path.name] = path;
			}
			if (parentValue[path.name] !== path.value) throw new Error("");
			if (path.parentPath.get(path.name) !== path) throw new Error("");
			return path;
		}
		Pp$1.replace = function replace(replacement) {
			var results = [];
			var parentValue = this.parentPath.value;
			var parentCache = getChildCache(this.parentPath);
			var count = arguments.length;
			repairRelationshipWithParent(this);
			if (isArray$11.check(parentValue)) {
				var originalLength = parentValue.length;
				var move = getMoves(this.parentPath, count - 1, this.name + 1);
				var spliceArgs = [this.name, 1];
				for (var i$2 = 0; i$2 < count; ++i$2) spliceArgs.push(arguments[i$2]);
				if (parentValue.splice.apply(parentValue, spliceArgs)[0] !== this.value) throw new Error("");
				if (parentValue.length !== originalLength - 1 + count) throw new Error("");
				move();
				if (count === 0) {
					delete this.value;
					delete parentCache[this.name];
					this.__childCache = null;
				} else {
					if (parentValue[this.name] !== replacement) throw new Error("");
					if (this.value !== replacement) {
						this.value = replacement;
						this.__childCache = null;
					}
					for (i$2 = 0; i$2 < count; ++i$2) results.push(this.parentPath.get(this.name + i$2));
					if (results[0] !== this) throw new Error("");
				}
			} else if (count === 1) {
				if (this.value !== replacement) this.__childCache = null;
				this.value = parentValue[this.name] = replacement;
				results.push(this);
			} else if (count === 0) {
				delete parentValue[this.name];
				delete this.value;
				this.__childCache = null;
			} else throw new Error("Could not replace path");
			return results;
		};
		return Path$2;
	}
	exports.default = pathPlugin;
	(0, shared_1$26.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_scope = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$25 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$25 = require_shared();
	var types_1$19 = tslib_1$25.__importDefault(require_types());
	var hasOwn$1 = Object.prototype.hasOwnProperty;
	function scopePlugin(fork) {
		var types$8 = fork.use(types_1$19.default);
		var Type$2 = types$8.Type;
		var namedTypes$1 = types$8.namedTypes;
		var Node = namedTypes$1.Node;
		var Expression$2 = namedTypes$1.Expression;
		var isArray$11 = types$8.builtInTypes.array;
		var b$5 = types$8.builders;
		var Scope = function Scope$1(path, parentScope) {
			if (!(this instanceof Scope$1)) throw new Error("Scope constructor cannot be invoked without 'new'");
			if (!TypeParameterScopeType.check(path.value)) ScopeType.assert(path.value);
			var depth;
			if (parentScope) {
				if (!(parentScope instanceof Scope$1)) throw new Error("");
				depth = parentScope.depth + 1;
			} else {
				parentScope = null;
				depth = 0;
			}
			Object.defineProperties(this, {
				path: { value: path },
				node: { value: path.value },
				isGlobal: {
					value: !parentScope,
					enumerable: true
				},
				depth: { value: depth },
				parent: { value: parentScope },
				bindings: { value: {} },
				types: { value: {} }
			});
		};
		var ScopeType = Type$2.or(namedTypes$1.Program, namedTypes$1.Function, namedTypes$1.CatchClause);
		var TypeParameterScopeType = Type$2.or(namedTypes$1.Function, namedTypes$1.ClassDeclaration, namedTypes$1.ClassExpression, namedTypes$1.InterfaceDeclaration, namedTypes$1.TSInterfaceDeclaration, namedTypes$1.TypeAlias, namedTypes$1.TSTypeAliasDeclaration);
		var FlowOrTSTypeParameterType = Type$2.or(namedTypes$1.TypeParameter, namedTypes$1.TSTypeParameter);
		Scope.isEstablishedBy = function(node) {
			return ScopeType.check(node) || TypeParameterScopeType.check(node);
		};
		var Sp = Scope.prototype;
		Sp.didScan = false;
		Sp.declares = function(name) {
			this.scan();
			return hasOwn$1.call(this.bindings, name);
		};
		Sp.declaresType = function(name) {
			this.scan();
			return hasOwn$1.call(this.types, name);
		};
		Sp.declareTemporary = function(prefix) {
			if (prefix) {
				if (!/^[a-z$_]/i.test(prefix)) throw new Error("");
			} else prefix = "t$";
			prefix += this.depth.toString(36) + "$";
			this.scan();
			var index = 0;
			while (this.declares(prefix + index)) ++index;
			var name = prefix + index;
			return this.bindings[name] = types$8.builders.identifier(name);
		};
		Sp.injectTemporary = function(identifier, init) {
			identifier || (identifier = this.declareTemporary());
			var bodyPath = this.path.get("body");
			if (namedTypes$1.BlockStatement.check(bodyPath.value)) bodyPath = bodyPath.get("body");
			bodyPath.unshift(b$5.variableDeclaration("var", [b$5.variableDeclarator(identifier, init || null)]));
			return identifier;
		};
		Sp.scan = function(force) {
			if (force || !this.didScan) {
				for (var name in this.bindings) delete this.bindings[name];
				for (var name in this.types) delete this.types[name];
				scanScope(this.path, this.bindings, this.types);
				this.didScan = true;
			}
		};
		Sp.getBindings = function() {
			this.scan();
			return this.bindings;
		};
		Sp.getTypes = function() {
			this.scan();
			return this.types;
		};
		function scanScope(path, bindings, scopeTypes) {
			var node = path.value;
			if (TypeParameterScopeType.check(node)) {
				var params = path.get("typeParameters", "params");
				if (isArray$11.check(params.value)) params.each(function(childPath) {
					addTypeParameter(childPath, scopeTypes);
				});
			}
			if (ScopeType.check(node)) if (namedTypes$1.CatchClause.check(node)) addPattern(path.get("param"), bindings);
			else recursiveScanScope(path, bindings, scopeTypes);
		}
		function recursiveScanScope(path, bindings, scopeTypes) {
			var node = path.value;
			if (path.parent && namedTypes$1.FunctionExpression.check(path.parent.node) && path.parent.node.id) addPattern(path.parent.get("id"), bindings);
			if (!node) {} else if (isArray$11.check(node)) path.each(function(childPath) {
				recursiveScanChild(childPath, bindings, scopeTypes);
			});
			else if (namedTypes$1.Function.check(node)) {
				path.get("params").each(function(paramPath) {
					addPattern(paramPath, bindings);
				});
				recursiveScanChild(path.get("body"), bindings, scopeTypes);
				recursiveScanScope(path.get("typeParameters"), bindings, scopeTypes);
			} else if (namedTypes$1.TypeAlias && namedTypes$1.TypeAlias.check(node) || namedTypes$1.InterfaceDeclaration && namedTypes$1.InterfaceDeclaration.check(node) || namedTypes$1.TSTypeAliasDeclaration && namedTypes$1.TSTypeAliasDeclaration.check(node) || namedTypes$1.TSInterfaceDeclaration && namedTypes$1.TSInterfaceDeclaration.check(node)) addTypePattern(path.get("id"), scopeTypes);
			else if (namedTypes$1.VariableDeclarator.check(node)) {
				addPattern(path.get("id"), bindings);
				recursiveScanChild(path.get("init"), bindings, scopeTypes);
			} else if (node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier") addPattern(path.get(node.local ? "local" : node.name ? "name" : "id"), bindings);
			else if (Node.check(node) && !Expression$2.check(node)) types$8.eachField(node, function(name, child) {
				var childPath = path.get(name);
				if (!pathHasValue(childPath, child)) throw new Error("");
				recursiveScanChild(childPath, bindings, scopeTypes);
			});
		}
		function pathHasValue(path, value) {
			if (path.value === value) return true;
			if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) return true;
			return false;
		}
		function recursiveScanChild(path, bindings, scopeTypes) {
			var node = path.value;
			if (!node || Expression$2.check(node)) {} else if (namedTypes$1.FunctionDeclaration.check(node) && node.id !== null) addPattern(path.get("id"), bindings);
			else if (namedTypes$1.ClassDeclaration && namedTypes$1.ClassDeclaration.check(node) && node.id !== null) {
				addPattern(path.get("id"), bindings);
				recursiveScanScope(path.get("typeParameters"), bindings, scopeTypes);
			} else if (namedTypes$1.InterfaceDeclaration && namedTypes$1.InterfaceDeclaration.check(node) || namedTypes$1.TSInterfaceDeclaration && namedTypes$1.TSInterfaceDeclaration.check(node)) addTypePattern(path.get("id"), scopeTypes);
			else if (ScopeType.check(node)) {
				if (namedTypes$1.CatchClause.check(node) && namedTypes$1.Identifier.check(node.param)) {
					var catchParamName = node.param.name;
					var hadBinding = hasOwn$1.call(bindings, catchParamName);
					recursiveScanScope(path.get("body"), bindings, scopeTypes);
					if (!hadBinding) delete bindings[catchParamName];
				}
			} else recursiveScanScope(path, bindings, scopeTypes);
		}
		function addPattern(patternPath, bindings) {
			var pattern = patternPath.value;
			namedTypes$1.Pattern.assert(pattern);
			if (namedTypes$1.Identifier.check(pattern)) if (hasOwn$1.call(bindings, pattern.name)) bindings[pattern.name].push(patternPath);
			else bindings[pattern.name] = [patternPath];
			else if (namedTypes$1.AssignmentPattern && namedTypes$1.AssignmentPattern.check(pattern)) addPattern(patternPath.get("left"), bindings);
			else if (namedTypes$1.ObjectPattern && namedTypes$1.ObjectPattern.check(pattern)) patternPath.get("properties").each(function(propertyPath) {
				var property$2 = propertyPath.value;
				if (namedTypes$1.Pattern.check(property$2)) addPattern(propertyPath, bindings);
				else if (namedTypes$1.Property.check(property$2) || namedTypes$1.ObjectProperty && namedTypes$1.ObjectProperty.check(property$2)) addPattern(propertyPath.get("value"), bindings);
				else if (namedTypes$1.SpreadProperty && namedTypes$1.SpreadProperty.check(property$2)) addPattern(propertyPath.get("argument"), bindings);
			});
			else if (namedTypes$1.ArrayPattern && namedTypes$1.ArrayPattern.check(pattern)) patternPath.get("elements").each(function(elementPath) {
				var element = elementPath.value;
				if (namedTypes$1.Pattern.check(element)) addPattern(elementPath, bindings);
				else if (namedTypes$1.SpreadElement && namedTypes$1.SpreadElement.check(element)) addPattern(elementPath.get("argument"), bindings);
			});
			else if (namedTypes$1.PropertyPattern && namedTypes$1.PropertyPattern.check(pattern)) addPattern(patternPath.get("pattern"), bindings);
			else if (namedTypes$1.SpreadElementPattern && namedTypes$1.SpreadElementPattern.check(pattern) || namedTypes$1.RestElement && namedTypes$1.RestElement.check(pattern) || namedTypes$1.SpreadPropertyPattern && namedTypes$1.SpreadPropertyPattern.check(pattern)) addPattern(patternPath.get("argument"), bindings);
		}
		function addTypePattern(patternPath, types$9) {
			var pattern = patternPath.value;
			namedTypes$1.Pattern.assert(pattern);
			if (namedTypes$1.Identifier.check(pattern)) if (hasOwn$1.call(types$9, pattern.name)) types$9[pattern.name].push(patternPath);
			else types$9[pattern.name] = [patternPath];
		}
		function addTypeParameter(parameterPath, types$9) {
			var parameter = parameterPath.value;
			FlowOrTSTypeParameterType.assert(parameter);
			if (hasOwn$1.call(types$9, parameter.name)) types$9[parameter.name].push(parameterPath);
			else types$9[parameter.name] = [parameterPath];
		}
		Sp.lookup = function(name) {
			for (var scope$1 = this; scope$1; scope$1 = scope$1.parent) if (scope$1.declares(name)) break;
			return scope$1;
		};
		Sp.lookupType = function(name) {
			for (var scope$1 = this; scope$1; scope$1 = scope$1.parent) if (scope$1.declaresType(name)) break;
			return scope$1;
		};
		Sp.getGlobalScope = function() {
			var scope$1 = this;
			while (!scope$1.isGlobal) scope$1 = scope$1.parent;
			return scope$1;
		};
		return Scope;
	}
	exports.default = scopePlugin;
	(0, shared_1$25.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_node_path = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$24 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$18 = tslib_1$24.__importDefault(require_types());
	var path_1$1 = tslib_1$24.__importDefault(require_path());
	var scope_1 = tslib_1$24.__importDefault(require_scope());
	var shared_1$24 = require_shared();
	function nodePathPlugin(fork) {
		var types$8 = fork.use(types_1$18.default);
		var n$6 = types$8.namedTypes;
		var b$5 = types$8.builders;
		var isNumber$3 = types$8.builtInTypes.number;
		var isArray$11 = types$8.builtInTypes.array;
		var Path$2 = fork.use(path_1$1.default);
		var Scope = fork.use(scope_1.default);
		var NodePath$2 = function NodePath$3(value, parentPath, name) {
			if (!(this instanceof NodePath$3)) throw new Error("NodePath constructor cannot be invoked without 'new'");
			Path$2.call(this, value, parentPath, name);
		};
		var NPp = NodePath$2.prototype = Object.create(Path$2.prototype, { constructor: {
			value: NodePath$2,
			enumerable: false,
			writable: true,
			configurable: true
		} });
		Object.defineProperties(NPp, {
			node: { get: function() {
				Object.defineProperty(this, "node", {
					configurable: true,
					value: this._computeNode()
				});
				return this.node;
			} },
			parent: { get: function() {
				Object.defineProperty(this, "parent", {
					configurable: true,
					value: this._computeParent()
				});
				return this.parent;
			} },
			scope: { get: function() {
				Object.defineProperty(this, "scope", {
					configurable: true,
					value: this._computeScope()
				});
				return this.scope;
			} }
		});
		NPp.replace = function() {
			delete this.node;
			delete this.parent;
			delete this.scope;
			return Path$2.prototype.replace.apply(this, arguments);
		};
		NPp.prune = function() {
			var remainingNodePath = this.parent;
			this.replace();
			return cleanUpNodesAfterPrune(remainingNodePath);
		};
		NPp._computeNode = function() {
			var value = this.value;
			if (n$6.Node.check(value)) return value;
			var pp = this.parentPath;
			return pp && pp.node || null;
		};
		NPp._computeParent = function() {
			var value = this.value;
			var pp = this.parentPath;
			if (!n$6.Node.check(value)) {
				while (pp && !n$6.Node.check(pp.value)) pp = pp.parentPath;
				if (pp) pp = pp.parentPath;
			}
			while (pp && !n$6.Node.check(pp.value)) pp = pp.parentPath;
			return pp || null;
		};
		NPp._computeScope = function() {
			var value = this.value;
			var pp = this.parentPath;
			var scope$1 = pp && pp.scope;
			if (n$6.Node.check(value) && Scope.isEstablishedBy(value)) scope$1 = new Scope(this, scope$1);
			return scope$1 || null;
		};
		NPp.getValueProperty = function(name) {
			return types$8.getFieldValue(this.value, name);
		};
		NPp.needsParens = function(assumeExpressionContext) {
			var pp = this.parentPath;
			if (!pp) return false;
			var node = this.value;
			if (!n$6.Expression.check(node)) return false;
			if (node.type === "Identifier") return false;
			while (!n$6.Node.check(pp.value)) {
				pp = pp.parentPath;
				if (!pp) return false;
			}
			var parent = pp.value;
			switch (node.type) {
				case "UnaryExpression":
				case "SpreadElement":
				case "SpreadProperty": return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
				case "BinaryExpression":
				case "LogicalExpression": switch (parent.type) {
					case "CallExpression": return this.name === "callee" && parent.callee === node;
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty": return true;
					case "MemberExpression": return this.name === "object" && parent.object === node;
					case "BinaryExpression":
					case "LogicalExpression":
						var n_1 = node;
						var pp_1 = PRECEDENCE$1[parent.operator];
						var np = PRECEDENCE$1[n_1.operator];
						if (pp_1 > np) return true;
						if (pp_1 === np && this.name === "right") {
							if (parent.right !== n_1) throw new Error("Nodes must be equal");
							return true;
						}
					default: return false;
				}
				case "SequenceExpression": switch (parent.type) {
					case "ForStatement": return false;
					case "ExpressionStatement": return this.name !== "expression";
					default: return true;
				}
				case "YieldExpression": switch (parent.type) {
					case "BinaryExpression":
					case "LogicalExpression":
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty":
					case "CallExpression":
					case "MemberExpression":
					case "NewExpression":
					case "ConditionalExpression":
					case "YieldExpression": return true;
					default: return false;
				}
				case "Literal": return parent.type === "MemberExpression" && isNumber$3.check(node.value) && this.name === "object" && parent.object === node;
				case "AssignmentExpression":
				case "ConditionalExpression": switch (parent.type) {
					case "UnaryExpression":
					case "SpreadElement":
					case "SpreadProperty":
					case "BinaryExpression":
					case "LogicalExpression": return true;
					case "CallExpression": return this.name === "callee" && parent.callee === node;
					case "ConditionalExpression": return this.name === "test" && parent.test === node;
					case "MemberExpression": return this.name === "object" && parent.object === node;
					default: return false;
				}
				default: if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node) return containsCallExpression$1(node);
			}
			if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
			return false;
		};
		function isBinary$1(node) {
			return n$6.BinaryExpression.check(node) || n$6.LogicalExpression.check(node);
		}
		var PRECEDENCE$1 = {};
		[
			["||"],
			["&&"],
			["|"],
			["^"],
			["&"],
			[
				"==",
				"===",
				"!=",
				"!=="
			],
			[
				"<",
				">",
				"<=",
				">=",
				"in",
				"instanceof"
			],
			[
				">>",
				"<<",
				">>>"
			],
			["+", "-"],
			[
				"*",
				"/",
				"%"
			]
		].forEach(function(tier, i$2) {
			tier.forEach(function(op) {
				PRECEDENCE$1[op] = i$2;
			});
		});
		function containsCallExpression$1(node) {
			if (n$6.CallExpression.check(node)) return true;
			if (isArray$11.check(node)) return node.some(containsCallExpression$1);
			if (n$6.Node.check(node)) return types$8.someField(node, function(_name, child) {
				return containsCallExpression$1(child);
			});
			return false;
		}
		NPp.canBeFirstInStatement = function() {
			var node = this.node;
			return !n$6.FunctionExpression.check(node) && !n$6.ObjectExpression.check(node);
		};
		NPp.firstInStatement = function() {
			return firstInStatement(this);
		};
		function firstInStatement(path) {
			for (var node, parent; path.parent; path = path.parent) {
				node = path.node;
				parent = path.parent.node;
				if (n$6.BlockStatement.check(parent) && path.parent.name === "body" && path.name === 0) {
					if (parent.body[0] !== node) throw new Error("Nodes must be equal");
					return true;
				}
				if (n$6.ExpressionStatement.check(parent) && path.name === "expression") {
					if (parent.expression !== node) throw new Error("Nodes must be equal");
					return true;
				}
				if (n$6.SequenceExpression.check(parent) && path.parent.name === "expressions" && path.name === 0) {
					if (parent.expressions[0] !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.CallExpression.check(parent) && path.name === "callee") {
					if (parent.callee !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.MemberExpression.check(parent) && path.name === "object") {
					if (parent.object !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.ConditionalExpression.check(parent) && path.name === "test") {
					if (parent.test !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (isBinary$1(parent) && path.name === "left") {
					if (parent.left !== node) throw new Error("Nodes must be equal");
					continue;
				}
				if (n$6.UnaryExpression.check(parent) && !parent.prefix && path.name === "argument") {
					if (parent.argument !== node) throw new Error("Nodes must be equal");
					continue;
				}
				return false;
			}
			return true;
		}
		function cleanUpNodesAfterPrune(remainingNodePath) {
			if (n$6.VariableDeclaration.check(remainingNodePath.node)) {
				var declarations = remainingNodePath.get("declarations").value;
				if (!declarations || declarations.length === 0) return remainingNodePath.prune();
			} else if (n$6.ExpressionStatement.check(remainingNodePath.node)) {
				if (!remainingNodePath.get("expression").value) return remainingNodePath.prune();
			} else if (n$6.IfStatement.check(remainingNodePath.node)) cleanUpIfStatementAfterPrune(remainingNodePath);
			return remainingNodePath;
		}
		function cleanUpIfStatementAfterPrune(ifStatement) {
			var testExpression = ifStatement.get("test").value;
			var alternate = ifStatement.get("alternate").value;
			var consequent = ifStatement.get("consequent").value;
			if (!consequent && !alternate) {
				var testExpressionStatement = b$5.expressionStatement(testExpression);
				ifStatement.replace(testExpressionStatement);
			} else if (!consequent && alternate) {
				var negatedTestExpression = b$5.unaryExpression("!", testExpression, true);
				if (n$6.UnaryExpression.check(testExpression) && testExpression.operator === "!") negatedTestExpression = testExpression.argument;
				ifStatement.get("test").replace(negatedTestExpression);
				ifStatement.get("consequent").replace(alternate);
				ifStatement.get("alternate").replace();
			}
		}
		return NodePath$2;
	}
	exports.default = nodePathPlugin;
	(0, shared_1$24.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_path_visitor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$23 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$17 = tslib_1$23.__importDefault(require_types());
	var node_path_1$1 = tslib_1$23.__importDefault(require_node_path());
	var shared_1$23 = require_shared();
	var hasOwn = Object.prototype.hasOwnProperty;
	function pathVisitorPlugin(fork) {
		var types$8 = fork.use(types_1$17.default);
		var NodePath$2 = fork.use(node_path_1$1.default);
		var isArray$11 = types$8.builtInTypes.array;
		var isObject$8 = types$8.builtInTypes.object;
		var isFunction$2 = types$8.builtInTypes.function;
		var undefined$1;
		var PathVisitor$2 = function PathVisitor$3() {
			if (!(this instanceof PathVisitor$3)) throw new Error("PathVisitor constructor cannot be invoked without 'new'");
			this._reusableContextStack = [];
			this._methodNameTable = computeMethodNameTable(this);
			this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
			this.Context = makeContextConstructor(this);
			this._visiting = false;
			this._changeReported = false;
		};
		function computeMethodNameTable(visitor) {
			var typeNames = Object.create(null);
			for (var methodName in visitor) if (/^visit[A-Z]/.test(methodName)) typeNames[methodName.slice(5)] = true;
			var supertypeTable = types$8.computeSupertypeLookupTable(typeNames);
			var methodNameTable = Object.create(null);
			var typeNameKeys = Object.keys(supertypeTable);
			var typeNameCount = typeNameKeys.length;
			for (var i$2 = 0; i$2 < typeNameCount; ++i$2) {
				var typeName = typeNameKeys[i$2];
				methodName = "visit" + supertypeTable[typeName];
				if (isFunction$2.check(visitor[methodName])) methodNameTable[typeName] = methodName;
			}
			return methodNameTable;
		}
		PathVisitor$2.fromMethodsObject = function fromMethodsObject(methods) {
			if (methods instanceof PathVisitor$2) return methods;
			if (!isObject$8.check(methods)) return new PathVisitor$2();
			var Visitor = function Visitor$1() {
				if (!(this instanceof Visitor$1)) throw new Error("Visitor constructor cannot be invoked without 'new'");
				PathVisitor$2.call(this);
			};
			var Vp = Visitor.prototype = Object.create(PVp);
			Vp.constructor = Visitor;
			extend$1(Vp, methods);
			extend$1(Visitor, PathVisitor$2);
			isFunction$2.assert(Visitor.fromMethodsObject);
			isFunction$2.assert(Visitor.visit);
			return new Visitor();
		};
		function extend$1(target, source) {
			for (var property$2 in source) if (hasOwn.call(source, property$2)) target[property$2] = source[property$2];
			return target;
		}
		PathVisitor$2.visit = function visit$6(node, methods) {
			return PathVisitor$2.fromMethodsObject(methods).visit(node);
		};
		var PVp = PathVisitor$2.prototype;
		PVp.visit = function() {
			if (this._visiting) throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
			this._visiting = true;
			this._changeReported = false;
			this._abortRequested = false;
			var argc = arguments.length;
			var args = new Array(argc);
			for (var i$2 = 0; i$2 < argc; ++i$2) args[i$2] = arguments[i$2];
			if (!(args[0] instanceof NodePath$2)) args[0] = new NodePath$2({ root: args[0] }).get("root");
			this.reset.apply(this, args);
			var didNotThrow;
			try {
				var root = this.visitWithoutReset(args[0]);
				didNotThrow = true;
			} finally {
				this._visiting = false;
				if (!didNotThrow && this._abortRequested) return args[0].value;
			}
			return root;
		};
		PVp.AbortRequest = function AbortRequest() {};
		PVp.abort = function() {
			var visitor = this;
			visitor._abortRequested = true;
			var request = new visitor.AbortRequest();
			request.cancel = function() {
				visitor._abortRequested = false;
			};
			throw request;
		};
		PVp.reset = function(_path) {};
		PVp.visitWithoutReset = function(path) {
			if (this instanceof this.Context) return this.visitor.visitWithoutReset(path);
			if (!(path instanceof NodePath$2)) throw new Error("");
			var value = path.value;
			var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
			if (methodName) {
				var context = this.acquireContext(path);
				try {
					return context.invokeVisitorMethod(methodName);
				} finally {
					this.releaseContext(context);
				}
			} else return visitChildren(path, this);
		};
		function visitChildren(path, visitor) {
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(visitor instanceof PathVisitor$2)) throw new Error("");
			var value = path.value;
			if (isArray$11.check(value)) path.each(visitor.visitWithoutReset, visitor);
			else if (!isObject$8.check(value)) {} else {
				var childNames = types$8.getFieldNames(value);
				if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) childNames.push("comments");
				var childCount = childNames.length;
				var childPaths = [];
				for (var i$2 = 0; i$2 < childCount; ++i$2) {
					var childName = childNames[i$2];
					if (!hasOwn.call(value, childName)) value[childName] = types$8.getFieldValue(value, childName);
					childPaths.push(path.get(childName));
				}
				for (var i$2 = 0; i$2 < childCount; ++i$2) visitor.visitWithoutReset(childPaths[i$2]);
			}
			return path.value;
		}
		PVp.acquireContext = function(path) {
			if (this._reusableContextStack.length === 0) return new this.Context(path);
			return this._reusableContextStack.pop().reset(path);
		};
		PVp.releaseContext = function(context) {
			if (!(context instanceof this.Context)) throw new Error("");
			this._reusableContextStack.push(context);
			context.currentPath = null;
		};
		PVp.reportChanged = function() {
			this._changeReported = true;
		};
		PVp.wasChangeReported = function() {
			return this._changeReported;
		};
		function makeContextConstructor(visitor) {
			function Context(path) {
				if (!(this instanceof Context)) throw new Error("");
				if (!(this instanceof PathVisitor$2)) throw new Error("");
				if (!(path instanceof NodePath$2)) throw new Error("");
				Object.defineProperty(this, "visitor", {
					value: visitor,
					writable: false,
					enumerable: true,
					configurable: false
				});
				this.currentPath = path;
				this.needToCallTraverse = true;
				Object.seal(this);
			}
			if (!(visitor instanceof PathVisitor$2)) throw new Error("");
			var Cp = Context.prototype = Object.create(visitor);
			Cp.constructor = Context;
			extend$1(Cp, sharedContextProtoMethods);
			return Context;
		}
		var sharedContextProtoMethods = Object.create(null);
		sharedContextProtoMethods.reset = function reset(path) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			this.currentPath = path;
			this.needToCallTraverse = true;
			return this;
		};
		sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			var result = this.visitor[methodName].call(this, this.currentPath);
			if (result === false) this.needToCallTraverse = false;
			else if (result !== undefined$1) {
				this.currentPath = this.currentPath.replace(result)[0];
				if (this.needToCallTraverse) this.traverse(this.currentPath);
			}
			if (this.needToCallTraverse !== false) throw new Error("Must either call this.traverse or return false in " + methodName);
			var path = this.currentPath;
			return path && path.value;
		};
		sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			this.needToCallTraverse = false;
			return visitChildren(path, PathVisitor$2.fromMethodsObject(newVisitor || this.visitor));
		};
		sharedContextProtoMethods.visit = function visit$6(path, newVisitor) {
			if (!(this instanceof this.Context)) throw new Error("");
			if (!(path instanceof NodePath$2)) throw new Error("");
			if (!(this.currentPath instanceof NodePath$2)) throw new Error("");
			this.needToCallTraverse = false;
			return PathVisitor$2.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);
		};
		sharedContextProtoMethods.reportChanged = function reportChanged() {
			this.visitor.reportChanged();
		};
		sharedContextProtoMethods.abort = function abort() {
			this.needToCallTraverse = false;
			this.visitor.abort();
		};
		return PathVisitor$2;
	}
	exports.default = pathVisitorPlugin;
	(0, shared_1$23.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_equiv = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$22 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$22 = require_shared();
	var types_1$16 = tslib_1$22.__importDefault(require_types());
	function default_1$22(fork) {
		var types$8 = fork.use(types_1$16.default);
		var getFieldNames$2 = types$8.getFieldNames;
		var getFieldValue$2 = types$8.getFieldValue;
		var isArray$11 = types$8.builtInTypes.array;
		var isObject$8 = types$8.builtInTypes.object;
		var isDate$4 = types$8.builtInTypes.Date;
		var isRegExp$3 = types$8.builtInTypes.RegExp;
		var hasOwn$12 = Object.prototype.hasOwnProperty;
		function astNodesAreEquivalent$2(a$1, b$5, problemPath) {
			if (isArray$11.check(problemPath)) problemPath.length = 0;
			else problemPath = null;
			return areEquivalent(a$1, b$5, problemPath);
		}
		astNodesAreEquivalent$2.assert = function(a$1, b$5) {
			var problemPath = [];
			if (!astNodesAreEquivalent$2(a$1, b$5, problemPath)) if (problemPath.length === 0) {
				if (a$1 !== b$5) throw new Error("Nodes must be equal");
			} else throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
		};
		function subscriptForProperty(property$2) {
			if (/[_$a-z][_$a-z0-9]*/i.test(property$2)) return "." + property$2;
			return "[" + JSON.stringify(property$2) + "]";
		}
		function areEquivalent(a$1, b$5, problemPath) {
			if (a$1 === b$5) return true;
			if (isArray$11.check(a$1)) return arraysAreEquivalent(a$1, b$5, problemPath);
			if (isObject$8.check(a$1)) return objectsAreEquivalent(a$1, b$5, problemPath);
			if (isDate$4.check(a$1)) return isDate$4.check(b$5) && +a$1 === +b$5;
			if (isRegExp$3.check(a$1)) return isRegExp$3.check(b$5) && a$1.source === b$5.source && a$1.global === b$5.global && a$1.multiline === b$5.multiline && a$1.ignoreCase === b$5.ignoreCase;
			return a$1 == b$5;
		}
		function arraysAreEquivalent(a$1, b$5, problemPath) {
			isArray$11.assert(a$1);
			var aLength = a$1.length;
			if (!isArray$11.check(b$5) || b$5.length !== aLength) {
				if (problemPath) problemPath.push("length");
				return false;
			}
			for (var i$2 = 0; i$2 < aLength; ++i$2) {
				if (problemPath) problemPath.push(i$2);
				if (i$2 in a$1 !== i$2 in b$5) return false;
				if (!areEquivalent(a$1[i$2], b$5[i$2], problemPath)) return false;
				if (problemPath) {
					var problemPathTail = problemPath.pop();
					if (problemPathTail !== i$2) throw new Error("" + problemPathTail);
				}
			}
			return true;
		}
		function objectsAreEquivalent(a$1, b$5, problemPath) {
			isObject$8.assert(a$1);
			if (!isObject$8.check(b$5)) return false;
			if (a$1.type !== b$5.type) {
				if (problemPath) problemPath.push("type");
				return false;
			}
			var aNames = getFieldNames$2(a$1);
			var aNameCount = aNames.length;
			var bNames = getFieldNames$2(b$5);
			var bNameCount = bNames.length;
			if (aNameCount === bNameCount) {
				for (var i$2 = 0; i$2 < aNameCount; ++i$2) {
					var name = aNames[i$2];
					var aChild = getFieldValue$2(a$1, name);
					var bChild = getFieldValue$2(b$5, name);
					if (problemPath) problemPath.push(name);
					if (!areEquivalent(aChild, bChild, problemPath)) return false;
					if (problemPath) {
						var problemPathTail = problemPath.pop();
						if (problemPathTail !== name) throw new Error("" + problemPathTail);
					}
				}
				return true;
			}
			if (!problemPath) return false;
			var seenNames = Object.create(null);
			for (i$2 = 0; i$2 < aNameCount; ++i$2) seenNames[aNames[i$2]] = true;
			for (i$2 = 0; i$2 < bNameCount; ++i$2) {
				name = bNames[i$2];
				if (!hasOwn$12.call(seenNames, name)) {
					problemPath.push(name);
					return false;
				}
				delete seenNames[name];
			}
			for (name in seenNames) {
				problemPath.push(name);
				break;
			}
			return false;
		}
		return astNodesAreEquivalent$2;
	}
	exports.default = default_1$22;
	(0, shared_1$22.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_fork = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$21 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$15 = tslib_1$21.__importDefault(require_types());
	var path_visitor_1 = tslib_1$21.__importDefault(require_path_visitor());
	var equiv_1 = tslib_1$21.__importDefault(require_equiv());
	var path_1 = tslib_1$21.__importDefault(require_path());
	var node_path_1 = tslib_1$21.__importDefault(require_node_path());
	var shared_1$21 = require_shared();
	function default_1$21(plugins) {
		var fork = createFork();
		var types$8 = fork.use(types_1$15.default);
		plugins.forEach(fork.use);
		types$8.finalize();
		var PathVisitor$2 = fork.use(path_visitor_1.default);
		return {
			Type: types$8.Type,
			builtInTypes: types$8.builtInTypes,
			namedTypes: types$8.namedTypes,
			builders: types$8.builders,
			defineMethod: types$8.defineMethod,
			getFieldNames: types$8.getFieldNames,
			getFieldValue: types$8.getFieldValue,
			eachField: types$8.eachField,
			someField: types$8.someField,
			getSupertypeNames: types$8.getSupertypeNames,
			getBuilderName: types$8.getBuilderName,
			astNodesAreEquivalent: fork.use(equiv_1.default),
			finalize: types$8.finalize,
			Path: fork.use(path_1.default),
			NodePath: fork.use(node_path_1.default),
			PathVisitor: PathVisitor$2,
			use: fork.use,
			visit: PathVisitor$2.visit
		};
	}
	exports.default = default_1$21;
	function createFork() {
		var used = [];
		var usedResult = [];
		function use$2(plugin) {
			var idx = used.indexOf(plugin);
			if (idx === -1) {
				idx = used.length;
				used.push(plugin);
				usedResult[idx] = plugin(fork);
			}
			return usedResult[idx];
		}
		var fork = { use: use$2 };
		return fork;
	}
	(0, shared_1$21.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_core$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var shared_1$20 = require_shared();
	function default_1$20() {
		return {
			BinaryOperators: [
				"==",
				"!=",
				"===",
				"!==",
				"<",
				"<=",
				">",
				">=",
				"<<",
				">>",
				">>>",
				"+",
				"-",
				"*",
				"/",
				"%",
				"&",
				"|",
				"^",
				"in",
				"instanceof"
			],
			AssignmentOperators: [
				"=",
				"+=",
				"-=",
				"*=",
				"/=",
				"%=",
				"<<=",
				">>=",
				">>>=",
				"|=",
				"^=",
				"&="
			],
			LogicalOperators: ["||", "&&"]
		};
	}
	exports.default = default_1$20;
	(0, shared_1$20.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2016$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$20 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$19 = require_shared();
	var core_1$2 = tslib_1$20.__importDefault(require_core$1());
	function default_1$19(fork) {
		var result = fork.use(core_1$2.default);
		if (result.BinaryOperators.indexOf("**") < 0) result.BinaryOperators.push("**");
		if (result.AssignmentOperators.indexOf("**=") < 0) result.AssignmentOperators.push("**=");
		return result;
	}
	exports.default = default_1$19;
	(0, shared_1$19.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2020$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$19 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$18 = require_shared();
	var es2016_1$2 = tslib_1$19.__importDefault(require_es2016$1());
	function default_1$18(fork) {
		var result = fork.use(es2016_1$2.default);
		if (result.LogicalOperators.indexOf("??") < 0) result.LogicalOperators.push("??");
		return result;
	}
	exports.default = default_1$18;
	(0, shared_1$18.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2021$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$18 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var shared_1$17 = require_shared();
	var es2020_1$2 = tslib_1$18.__importDefault(require_es2020$1());
	function default_1$17(fork) {
		var result = fork.use(es2020_1$2.default);
		result.LogicalOperators.forEach(function(op) {
			var assignOp = op + "=";
			if (result.AssignmentOperators.indexOf(assignOp) < 0) result.AssignmentOperators.push(assignOp);
		});
		return result;
	}
	exports.default = default_1$17;
	(0, shared_1$17.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$17 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var core_1$1 = tslib_1$17.__importDefault(require_core$1());
	var types_1$14 = tslib_1$17.__importDefault(require_types());
	var shared_1$16 = tslib_1$17.__importStar(require_shared());
	function default_1$16(fork) {
		var Type$2 = fork.use(types_1$14.default).Type;
		var def = Type$2.def;
		var or = Type$2.or;
		var shared = fork.use(shared_1$16.default);
		var defaults$1 = shared.defaults;
		var geq = shared.geq;
		var _a$2 = fork.use(core_1$1.default), BinaryOperators = _a$2.BinaryOperators, AssignmentOperators = _a$2.AssignmentOperators, LogicalOperators = _a$2.LogicalOperators;
		def("Printable").field("loc", or(def("SourceLocation"), null), defaults$1["null"], true);
		def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults$1["null"], true);
		def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults$1["null"]);
		def("Position").field("line", geq(1)).field("column", geq(0));
		def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults$1["null"]);
		def("Program").bases("Node").build("body").field("body", [def("Statement")]);
		def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults$1["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]);
		def("Statement").bases("Node");
		def("EmptyStatement").bases("Statement").build();
		def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
		def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
		def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults$1["null"]);
		def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
		def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults$1["null"]);
		def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults$1["null"]);
		def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
		def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults$1["false"]);
		def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
		def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
		def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
			return this.handlers && this.handlers[0] || null;
		}).field("handlers", [def("CatchClause")], function() {
			return this.handler ? [this.handler] : [];
		}, true).field("guardedHandlers", [def("CatchClause")], defaults$1.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults$1["null"]);
		def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults$1["null"]).field("body", def("BlockStatement"));
		def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
		def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
		def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
		def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
		def("DebuggerStatement").bases("Statement").build();
		def("Declaration").bases("Statement");
		def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
		def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
		def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
		def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults$1["null"]);
		def("Expression").bases("Node");
		def("ThisExpression").bases("Expression").build();
		def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
		def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
		def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
		def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
		var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
		def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults$1["true"]);
		var BinaryOperator = or.apply(void 0, BinaryOperators);
		def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
		var AssignmentOperator = or.apply(void 0, AssignmentOperators);
		def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
		var UpdateOperator = or("++", "--");
		def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
		var LogicalOperator = or.apply(void 0, LogicalOperators);
		def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
		def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
		def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
		def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
		def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
			var type = this.property.type;
			if (type === "Literal" || type === "MemberExpression" || type === "BinaryExpression") return true;
			return false;
		});
		def("Pattern").bases("Node");
		def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
		def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults$1["false"]);
		def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt));
		def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults$1["true"]).field("trailing", Boolean, defaults$1["false"]);
	}
	exports.default = default_1$16;
	(0, shared_1$16.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es6 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$16 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var core_1 = tslib_1$16.__importDefault(require_core());
	var types_1$13 = tslib_1$16.__importDefault(require_types());
	var shared_1$15 = tslib_1$16.__importStar(require_shared());
	function default_1$15(fork) {
		fork.use(core_1.default);
		var types$8 = fork.use(types_1$13.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$15.default).defaults;
		def("Function").field("generator", Boolean, defaults$1["false"]).field("expression", Boolean, defaults$1["false"]).field("defaults", [or(def("Expression"), null)], defaults$1.emptyArray).field("rest", or(def("Identifier"), null), defaults$1["null"]);
		def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field("typeAnnotation", or(def("TypeAnnotation"), def("TSTypeAnnotation"), null), defaults$1["null"]);
		def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
		def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null));
		def("FunctionExpression").build("id", "params", "body", "generator", "expression");
		def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults$1["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults$1["false"]);
		def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
		def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults$1["false"]);
		def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
		def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
		def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
		def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults$1["false"]).field("shorthand", Boolean, defaults$1["false"]).field("computed", Boolean, defaults$1["false"]);
		def("ObjectProperty").field("shorthand", Boolean, defaults$1["false"]);
		def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults$1["false"]);
		def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
		def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
		def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
		def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
		def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
		def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults$1["false"]).field("static", Boolean, defaults$1["false"]);
		var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("StaticBlock"));
		def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults$1["false"]);
		def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
		def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
		def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults$1["null"]);
		def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults$1["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults$1["null"]);
		def("Super").bases("Expression").build();
		def("Specifier").bases("Node");
		def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults$1["null"]).field("id", or(def("Identifier"), null), defaults$1["null"]).field("name", or(def("Identifier"), null), defaults$1["null"]);
		def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
		def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
		def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
		def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults$1.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
			return "value";
		});
		def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
		def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
		def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal"));
		def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
		def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
		def("TemplateElement").bases("Node").build("value", "tail").field("value", {
			"cooked": String,
			"raw": String
		}).field("tail", Boolean);
		def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
	}
	exports.default = default_1$15;
	(0, shared_1$15.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2016 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$15 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2016_1$1 = tslib_1$15.__importDefault(require_es2016$1());
	var es6_1 = tslib_1$15.__importDefault(require_es6());
	var shared_1$14 = require_shared();
	function default_1$14(fork) {
		fork.use(es2016_1$1.default);
		fork.use(es6_1.default);
	}
	exports.default = default_1$14;
	(0, shared_1$14.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2017 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$14 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2016_1 = tslib_1$14.__importDefault(require_es2016());
	var types_1$12 = tslib_1$14.__importDefault(require_types());
	var shared_1$13 = tslib_1$14.__importStar(require_shared());
	function default_1$13(fork) {
		fork.use(es2016_1.default);
		var def = fork.use(types_1$12.default).Type.def;
		var defaults$1 = fork.use(shared_1$13.default).defaults;
		def("Function").field("async", Boolean, defaults$1["false"]);
		def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
	}
	exports.default = default_1$13;
	(0, shared_1$13.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2018 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$13 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2017_1 = tslib_1$13.__importDefault(require_es2017());
	var types_1$11 = tslib_1$13.__importDefault(require_types());
	var shared_1$12 = tslib_1$13.__importStar(require_shared());
	function default_1$12(fork) {
		fork.use(es2017_1.default);
		var types$8 = fork.use(types_1$11.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$12.default).defaults;
		def("ForOfStatement").field("await", Boolean, defaults$1["false"]);
		def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
		def("TemplateElement").field("value", {
			"cooked": or(String, null),
			"raw": String
		});
		def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
		def("ObjectPattern").field("properties", [or(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
	}
	exports.default = default_1$12;
	(0, shared_1$12.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2019 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$12 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2018_1 = tslib_1$12.__importDefault(require_es2018());
	var types_1$10 = tslib_1$12.__importDefault(require_types());
	var shared_1$11 = tslib_1$12.__importStar(require_shared());
	function default_1$11(fork) {
		fork.use(es2018_1.default);
		var types$8 = fork.use(types_1$10.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$11.default).defaults;
		def("CatchClause").field("param", or(def("Pattern"), null), defaults$1["null"]);
	}
	exports.default = default_1$11;
	(0, shared_1$11.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2020 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$11 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2020_1$1 = tslib_1$11.__importDefault(require_es2020$1());
	var es2019_1 = tslib_1$11.__importDefault(require_es2019());
	var types_1$9 = tslib_1$11.__importDefault(require_types());
	var shared_1$10 = tslib_1$11.__importStar(require_shared());
	function default_1$10(fork) {
		fork.use(es2020_1$1.default);
		fork.use(es2019_1.default);
		var types$8 = fork.use(types_1$9.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$10.default).defaults;
		def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
		def("ExportAllDeclaration").bases("Declaration").build("source", "exported").field("source", def("Literal")).field("exported", or(def("Identifier"), null, void 0), defaults$1["null"]);
		def("ChainElement").bases("Node").field("optional", Boolean, defaults$1["false"]);
		def("CallExpression").bases("Expression", "ChainElement");
		def("MemberExpression").bases("Expression", "ChainElement");
		def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement"));
		def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults$1["true"]);
		def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults$1["true"]);
	}
	exports.default = default_1$10;
	(0, shared_1$10.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2021 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$10 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2021_1$1 = tslib_1$10.__importDefault(require_es2021$1());
	var es2020_1 = tslib_1$10.__importDefault(require_es2020());
	var shared_1$9 = require_shared();
	function default_1$9(fork) {
		fork.use(es2021_1$1.default);
		fork.use(es2020_1.default);
	}
	exports.default = default_1$9;
	(0, shared_1$9.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es2022 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$9 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es2021_1 = tslib_1$9.__importDefault(require_es2021());
	var types_1$8 = tslib_1$9.__importDefault(require_types());
	var shared_1$8 = require_shared();
	function default_1$8(fork) {
		fork.use(es2021_1.default);
		var def = fork.use(types_1$8.default).Type.def;
		def("StaticBlock").bases("Declaration").build("body").field("body", [def("Statement")]);
	}
	exports.default = default_1$8;
	(0, shared_1$8.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_es_proposals = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$8 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$7 = tslib_1$8.__importDefault(require_types());
	var shared_1$7 = tslib_1$8.__importStar(require_shared());
	var es2022_1 = tslib_1$8.__importDefault(require_es2022());
	function default_1$7(fork) {
		fork.use(es2022_1.default);
		var types$8 = fork.use(types_1$7.default);
		var Type$2 = types$8.Type;
		var def = types$8.Type.def;
		var or = Type$2.or;
		var defaults$1 = fork.use(shared_1$7.default).defaults;
		def("AwaitExpression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults$1["false"]);
		def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
		def("Property").field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
		def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults$1["null"]);
		def("ImportAttribute").bases("Node").build("key", "value").field("key", or(def("Identifier"), def("Literal"))).field("value", def("Expression"));
		[
			"ImportDeclaration",
			"ExportAllDeclaration",
			"ExportNamedDeclaration"
		].forEach(function(decl) {
			def(decl).field("assertions", [def("ImportAttribute")], defaults$1.emptyArray);
		});
		def("RecordExpression").bases("Expression").build("properties").field("properties", [or(def("ObjectProperty"), def("ObjectMethod"), def("SpreadElement"))]);
		def("TupleExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), def("SpreadElement"), null)]);
		def("ModuleExpression").bases("Node").build("body").field("body", def("Program"));
	}
	exports.default = default_1$7;
	(0, shared_1$7.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_jsx = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$7 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es_proposals_1$4 = tslib_1$7.__importDefault(require_es_proposals());
	var types_1$6 = tslib_1$7.__importDefault(require_types());
	var shared_1$6 = tslib_1$7.__importStar(require_shared());
	function default_1$6(fork) {
		fork.use(es_proposals_1$4.default);
		var types$8 = fork.use(types_1$6.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$6.default).defaults;
		def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(def("Literal"), def("JSXExpressionContainer"), def("JSXElement"), def("JSXFragment"), null), defaults$1["null"]);
		def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
		def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
		def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults$1.false);
		var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
		def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
		var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
		def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def("Expression"), def("JSXEmptyExpression")));
		var JSXChildren = [or(def("JSXText"), def("JSXExpressionContainer"), def("JSXSpreadChild"), def("JSXElement"), def("JSXFragment"), def("Literal"))];
		def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults$1["null"]).field("children", JSXChildren, defaults$1.emptyArray).field("name", JSXElementName, function() {
			return this.openingElement.name;
		}, true).field("selfClosing", Boolean, function() {
			return this.openingElement.selfClosing;
		}, true).field("attributes", JSXAttributes, function() {
			return this.openingElement.attributes;
		}, true);
		def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults$1.emptyArray).field("selfClosing", Boolean, defaults$1["false"]);
		def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
		def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults$1.emptyArray);
		def("JSXOpeningFragment").bases("Node").build();
		def("JSXClosingFragment").bases("Node").build();
		def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
			return this.value;
		});
		def("JSXEmptyExpression").bases("Node").build();
		def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
	}
	exports.default = default_1$6;
	(0, shared_1$6.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_type_annotations = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$6 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$5 = tslib_1$6.__importDefault(require_types());
	var shared_1$5 = tslib_1$6.__importStar(require_shared());
	function default_1$5(fork) {
		var types$8 = fork.use(types_1$5.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$5.default).defaults;
		var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
		var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
		def("Identifier").field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		def("Function").field("returnType", TypeAnnotation, defaults$1["null"]).field("typeParameters", TypeParamDecl, defaults$1["null"]);
		def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults$1["false"]).field("typeAnnotation", TypeAnnotation, defaults$1["null"]);
		["ClassDeclaration", "ClassExpression"].forEach(function(typeName) {
			def(typeName).field("typeParameters", TypeParamDecl, defaults$1["null"]).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults$1["null"]).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults$1.emptyArray);
		});
	}
	exports.default = default_1$5;
	(0, shared_1$5.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_flow = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$5 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es_proposals_1$3 = tslib_1$5.__importDefault(require_es_proposals());
	var type_annotations_1$1 = tslib_1$5.__importDefault(require_type_annotations());
	var types_1$4 = tslib_1$5.__importDefault(require_types());
	var shared_1$4 = tslib_1$5.__importStar(require_shared());
	function default_1$4(fork) {
		fork.use(es_proposals_1$3.default);
		fork.use(type_annotations_1$1.default);
		var types$8 = fork.use(types_1$4.default);
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1$4.default).defaults;
		def("Flow").bases("Node");
		def("FlowType").bases("Flow");
		def("AnyTypeAnnotation").bases("FlowType").build();
		def("EmptyTypeAnnotation").bases("FlowType").build();
		def("MixedTypeAnnotation").bases("FlowType").build();
		def("VoidTypeAnnotation").bases("FlowType").build();
		def("SymbolTypeAnnotation").bases("FlowType").build();
		def("NumberTypeAnnotation").bases("FlowType").build();
		def("BigIntTypeAnnotation").bases("FlowType").build();
		def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
		def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
		def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
		def("StringTypeAnnotation").bases("FlowType").build();
		def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
		def("BooleanTypeAnnotation").bases("FlowType").build();
		def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
		def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
		def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
		def("NullLiteralTypeAnnotation").bases("FlowType").build();
		def("NullTypeAnnotation").bases("FlowType").build();
		def("ThisTypeAnnotation").bases("FlowType").build();
		def("ExistsTypeAnnotation").bases("FlowType").build();
		def("ExistentialTypeParam").bases("FlowType").build();
		def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
		def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
		def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
		def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))]).field("indexers", [def("ObjectTypeIndexer")], defaults$1.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults$1.emptyArray).field("inexact", or(Boolean, void 0), defaults$1["undefined"]).field("exact", Boolean, defaults$1["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults$1.emptyArray);
		def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
		var LegacyVariance = or(def("Variance"), "plus", "minus", null);
		def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults$1["null"]);
		def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults$1["null"]).field("static", Boolean, defaults$1["false"]);
		def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults$1["false"]);
		def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
		def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
		def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
		def("IndexedAccessType").bases("FlowType").build("objectType", "indexType").field("objectType", def("FlowType")).field("indexType", def("FlowType"));
		def("OptionalIndexedAccessType").bases("FlowType").build("objectType", "indexType", "optional").field("objectType", def("FlowType")).field("indexType", def("FlowType")).field("optional", Boolean);
		def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
		def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
		def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
		def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
		def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
		def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults$1["null"]).field("bound", or(def("TypeAnnotation"), null), defaults$1["null"]).field("default", or(def("FlowType"), null), defaults$1["null"]);
		def("ClassProperty").field("variance", LegacyVariance, defaults$1["null"]);
		def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults$1["null"]).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults$1["null"]);
		def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults$1["null"]);
		def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults$1["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
		def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
		def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults$1["null"]);
		def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
		def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
		def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or(def("FlowType"), null));
		def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def("FlowType"), null));
		def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
		def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
		def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
		def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or(def("FlowPredicate"), null), defaults$1["null"]);
		def("DeclareClass").bases("InterfaceDeclaration").build("id");
		def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
		def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
		def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("FlowType"), def("TypeAlias"), def("DeclareOpaqueType"), def("InterfaceDeclaration"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults$1["null"]);
		def("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
			return "value";
		});
		def("FlowPredicate").bases("Flow");
		def("InferredPredicate").bases("FlowPredicate").build();
		def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
		def("Function").field("predicate", or(def("FlowPredicate"), null), defaults$1["null"]);
		def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults$1["null"]);
		def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults$1["null"]);
		def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody")));
		def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean);
		def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean);
		def("EnumStringBody").build("members", "explicitType").field("members", or([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean);
		def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]);
		def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or(def("Literal"), Boolean));
		def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
		def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
		def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
	}
	exports.default = default_1$4;
	(0, shared_1$4.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_esprima = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$4 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es_proposals_1$2 = tslib_1$4.__importDefault(require_es_proposals());
	var types_1$3 = tslib_1$4.__importDefault(require_types());
	var shared_1$3 = tslib_1$4.__importStar(require_shared());
	function default_1$3(fork) {
		fork.use(es_proposals_1$2.default);
		var types$8 = fork.use(types_1$3.default);
		var defaults$1 = fork.use(shared_1$3.default).defaults;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		def("VariableDeclaration").field("declarations", [or(def("VariableDeclarator"), def("Identifier"))]);
		def("Property").field("value", or(def("Expression"), def("Pattern")));
		def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
		def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"))]);
		def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
		def("ExportBatchSpecifier").bases("Specifier").build();
		def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(def("Declaration"), def("Expression"), null)).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults$1.emptyArray).field("source", or(def("Literal"), null), defaults$1["null"]);
		def("Block").bases("Comment").build("value", "leading", "trailing");
		def("Line").bases("Comment").build("value", "leading", "trailing");
	}
	exports.default = default_1$3;
	(0, shared_1$3.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_babel_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$3 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var es_proposals_1$1 = tslib_1$3.__importDefault(require_es_proposals());
	var types_1$2 = tslib_1$3.__importDefault(require_types());
	var shared_1$2 = tslib_1$3.__importStar(require_shared());
	function default_1$2(fork) {
		var _a$2, _b, _c, _d, _e;
		fork.use(es_proposals_1$1.default);
		var types$8 = fork.use(types_1$2.default);
		var defaults$1 = fork.use(shared_1$2.default).defaults;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var isUndefined$2 = types$8.builtInTypes.undefined;
		def("Noop").bases("Statement").build();
		def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
		def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
		def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
		def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
		def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
		def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
		def("CommentLine").bases("Comment").build("value", "leading", "trailing");
		def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
		def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults$1["use strict"]);
		def("InterpreterDirective").bases("Node").build("value").field("value", String);
		def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults$1.emptyArray);
		def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults$1.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults$1["null"]);
		function makeLiteralExtra(rawValueType, toRaw) {
			if (rawValueType === void 0) rawValueType = String;
			return [
				"extra",
				{
					rawValue: rawValueType,
					raw: String
				},
				function getDefault() {
					var value = types$8.getFieldValue(this, "value");
					return {
						rawValue: value,
						raw: toRaw ? toRaw(value) : String(value)
					};
				}
			];
		}
		(_a$2 = def("StringLiteral").bases("Literal").build("value").field("value", String)).field.apply(_a$2, makeLiteralExtra(String, function(val) {
			return JSON.stringify(val);
		}));
		(_b = def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults$1["null"])).field.apply(_b, makeLiteralExtra(Number));
		(_c = def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number))).field.apply(_c, makeLiteralExtra(String, function(val) {
			return val + "n";
		}));
		(_d = def("DecimalLiteral").bases("Literal").build("value").field("value", String)).field.apply(_d, makeLiteralExtra(String, function(val) {
			return val + "m";
		}));
		def("NullLiteral").bases("Literal").build().field("value", null, defaults$1["null"]);
		def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
		(_e = def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
			return new RegExp(this.pattern, this.flags);
		})).field.apply(_e, makeLiteralExtra(or(RegExp, isUndefined$2), function(exp) {
			return "/".concat(exp.pattern, "/").concat(exp.flags || "");
		})).field("regex", {
			pattern: String,
			flags: String
		}, function() {
			return {
				pattern: this.pattern,
				flags: this.flags
			};
		});
		var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
		def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
		def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]).field("accessibility", or(def("Literal"), null), defaults$1["null"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("accessibility", or(def("Literal"), null), defaults$1["null"]).field("computed", Boolean, defaults$1["false"]);
		var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("ClassAccessorProperty"), def("StaticBlock"));
		def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
		def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression")));
		def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
		def("ClassAccessorProperty").bases("Declaration").build("key", "value", "decorators", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("PrivateName"), def("Expression"))).field("value", or(def("Expression"), null), defaults$1["null"]);
		["ClassMethod", "ClassPrivateMethod"].forEach(function(typeName) {
			def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
				return "method";
			}).field("body", def("BlockStatement")).field("access", or("public", "private", "protected", null), defaults$1["null"]);
		});
		[
			"ClassMethod",
			"ClassPrivateMethod",
			"ClassAccessorProperty"
		].forEach(function(typeName) {
			def(typeName).field("computed", Boolean, defaults$1["false"]).field("static", Boolean, defaults$1["false"]).field("abstract", Boolean, defaults$1["false"]).field("accessibility", or("public", "private", "protected", null), defaults$1["null"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]).field("definite", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("override", Boolean, defaults$1["false"]).field("readonly", Boolean, defaults$1["false"]);
		});
		var ObjectPatternProperty = or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"), def("ObjectProperty"), def("RestProperty"), def("RestElement"));
		def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults$1["null"]);
		def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
		def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
		def("Import").bases("Expression").build();
	}
	exports.default = default_1$2;
	(0, shared_1$2.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_babel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$2 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var types_1$1 = tslib_1$2.__importDefault(require_types());
	var babel_core_1$1 = tslib_1$2.__importDefault(require_babel_core());
	var flow_1$1 = tslib_1$2.__importDefault(require_flow());
	var shared_1$1 = require_shared();
	function default_1$1(fork) {
		var def = fork.use(types_1$1.default).Type.def;
		fork.use(babel_core_1$1.default);
		fork.use(flow_1$1.default);
		def("V8IntrinsicIdentifier").bases("Expression").build("name").field("name", String);
		def("TopicReference").bases("Expression").build();
	}
	exports.default = default_1$1;
	(0, shared_1$1.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_typescript = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1$1 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var babel_core_1 = tslib_1$1.__importDefault(require_babel_core());
	var type_annotations_1 = tslib_1$1.__importDefault(require_type_annotations());
	var types_1 = tslib_1$1.__importDefault(require_types());
	var shared_1 = tslib_1$1.__importStar(require_shared());
	function default_1(fork) {
		fork.use(babel_core_1.default);
		fork.use(type_annotations_1.default);
		var types$8 = fork.use(types_1.default);
		var n$6 = types$8.namedTypes;
		var def = types$8.Type.def;
		var or = types$8.Type.or;
		var defaults$1 = fork.use(shared_1.default).defaults;
		var StringLiteral = types$8.Type.from(function(value, deep) {
			if (n$6.StringLiteral && n$6.StringLiteral.check(value, deep)) return true;
			if (n$6.Literal && n$6.Literal.check(value, deep) && typeof value.value === "string") return true;
			return false;
		}, "StringLiteral");
		def("TSType").bases("Node");
		var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
		def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
		def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults$1["null"]);
		def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults$1["null"]);
		def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults$1["null"]);
		def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
		def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults$1["null"]);
		def("TSTypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType"));
		def("TSSatisfiesExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType"));
		def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
		[
			"TSAnyKeyword",
			"TSBigIntKeyword",
			"TSBooleanKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSIntrinsicKeyword",
			"TSThisType"
		].forEach(function(keywordType) {
			def(keywordType).bases("TSType").build();
		});
		def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
		def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression"), def("BigIntLiteral")));
		def("TemplateLiteral").field("expressions", or([def("Expression")], [def("TSType")]));
		["TSUnionType", "TSIntersectionType"].forEach(function(typeName) {
			def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
		});
		def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
		def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
		def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
		["TSFunctionType", "TSConstructorType"].forEach(function(typeName) {
			def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
		});
		def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults$1["false"]).field("async", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("id", or(def("Identifier"), null), defaults$1["null"]).field("params", [def("Pattern")]).field("returnType", or(def("TSTypeAnnotation"), def("Noop"), null), defaults$1["null"]);
		def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults$1["false"]).field("generator", Boolean, defaults$1["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults$1["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("static", Boolean, defaults$1["false"]).field("computed", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("key", or(def("Identifier"), def("StringLiteral"), def("NumericLiteral"), def("Expression"))).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
			return "method";
		}).field("access", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("decorators", or([def("Decorator")], null), defaults$1["null"]).field("returnType", or(def("TSTypeAnnotation"), def("Noop"), null), defaults$1["null"]);
		def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults$1["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults$1["false"]).field("typeAnnotation", or(def("TSType"), null), defaults$1["null"]);
		def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
		def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults$1["false"]).field("elementType", def("TSType"));
		def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
		def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
		def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
		def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
		def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults$1["false"]);
		def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults$1["false"]).field("readonly", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults$1["false"]).field("optional", Boolean, defaults$1["false"]).field("parameters", ParametersType);
		def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults$1["null"]).field("asserts", Boolean, defaults$1["false"]);
		["TSCallSignatureDeclaration", "TSConstructSignatureDeclaration"].forEach(function(typeName) {
			def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
		});
		def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
		var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
		def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
		def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", or(def("Identifier"), String)).field("constraint", or(def("TSType"), void 0), defaults$1["undefined"]).field("default", or(def("TSType"), void 0), defaults$1["undefined"]);
		def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults$1["null"]);
		def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
		def("TSInstantiationExpression").bases("Expression", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", def("Expression"));
		def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
		def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults$1["false"]).field("declare", Boolean, defaults$1["false"]).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults$1["null"]);
		def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults$1["false"]).field("typeAnnotation", def("TSType"));
		def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
		def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults$1["false"]).field("global", Boolean, defaults$1["false"]).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults$1["null"]);
		def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults$1["undefined"]);
		def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults$1["false"]).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
		def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
		def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
		def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
		def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
		def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
		def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults$1["false"]).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults$1["null"]).field("body", def("TSInterfaceBody"));
		def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults$1["undefined"]).field("readonly", Boolean, defaults$1["false"]).field("parameter", or(def("Identifier"), def("AssignmentPattern")));
		def("ClassProperty").field("access", or("public", "private", "protected", void 0), defaults$1["undefined"]);
		def("ClassAccessorProperty").bases("Declaration", "TSHasOptionalTypeAnnotation");
		def("ClassBody").field("body", [or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassAccessorProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("StaticBlock"), def("TSDeclareMethod"), TSTypeMember)]);
	}
	exports.default = default_1;
	(0, shared_1.maybeSetModuleExports)(function() {
		return module;
	});
}));
var require_namedTypes = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.namedTypes = void 0;
	(function(namedTypes$1) {})(exports.namedTypes || (exports.namedTypes = {}));
}));
var require_main = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.visit = exports.use = exports.Type = exports.someField = exports.PathVisitor = exports.Path = exports.NodePath = exports.namedTypes = exports.getSupertypeNames = exports.getFieldValue = exports.getFieldNames = exports.getBuilderName = exports.finalize = exports.eachField = exports.defineMethod = exports.builtInTypes = exports.builders = exports.astNodesAreEquivalent = void 0;
	var tslib_1 = (init_tslib_es6$1(), __toCommonJS(tslib_es6_exports$1));
	var fork_1 = tslib_1.__importDefault(require_fork());
	var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
	var jsx_1 = tslib_1.__importDefault(require_jsx());
	var flow_1 = tslib_1.__importDefault(require_flow());
	var esprima_1 = tslib_1.__importDefault(require_esprima());
	var babel_1 = tslib_1.__importDefault(require_babel());
	var typescript_1 = tslib_1.__importDefault(require_typescript());
	var namedTypes_1 = require_namedTypes();
	Object.defineProperty(exports, "namedTypes", {
		enumerable: true,
		get: function() {
			return namedTypes_1.namedTypes;
		}
	});
	var _a = (0, fork_1.default)([
		es_proposals_1.default,
		jsx_1.default,
		flow_1.default,
		esprima_1.default,
		babel_1.default,
		typescript_1.default
	]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit$4 = _a.visit;
	exports.astNodesAreEquivalent = astNodesAreEquivalent;
	exports.builders = builders;
	exports.builtInTypes = builtInTypes;
	exports.defineMethod = defineMethod;
	exports.eachField = eachField;
	exports.finalize = finalize;
	exports.getBuilderName = getBuilderName;
	exports.getFieldNames = getFieldNames;
	exports.getFieldValue = getFieldValue;
	exports.getSupertypeNames = getSupertypeNames;
	exports.NodePath = NodePath;
	exports.Path = Path;
	exports.PathVisitor = PathVisitor;
	exports.someField = someField;
	exports.Type = Type;
	exports.use = use;
	exports.visit = visit$4;
	Object.assign(namedTypes_1.namedTypes, n);
}));
const EXEMPT_IDENTIFIER_LIST = [
	"isFinite",
	"isNaN",
	"NaN",
	"Date",
	"RegExp",
	"Math",
	"undefined"
];
var import_main$7 = /* @__PURE__ */ __toESM(require_main$1());
var import_main$8 = /* @__PURE__ */ __toESM(require_main());
function assertNever(value) {
	return true;
}
const globalIdentifier = import_main$8.builders.identifier(typeof window !== "object" ? "global" : "window");
var buildGlobalSwitch = (node, dataNode) => {
	return import_main$8.builders.memberExpression(import_main$8.builders.conditionalExpression(import_main$8.builders.binaryExpression("in", import_main$8.builders.literal(node.name), dataNode), dataNode, globalIdentifier), import_main$8.builders.identifier(node.name));
};
var isInScope = (path) => {
	let scope$1 = path.scope;
	while (scope$1 !== null) {
		if (scope$1.declares(path.node.name)) return true;
		scope$1 = scope$1.parent;
	}
	return false;
};
var polyfillExceptions = [
	"this",
	"window",
	"global"
];
var polyfillVar = (path, dataNode, force = false) => {
	if (!force) {
		if (isInScope(path)) return;
	}
	if (polyfillExceptions.includes(path.node.name)) return;
	path.replace(buildGlobalSwitch(path.node, dataNode));
};
var customPatches = {
	MemberExpression(path, parent, dataNode) {
		if (parent.object === path.node || parent.computed) polyfillVar(path, dataNode);
	},
	OptionalMemberExpression(path, parent, dataNode) {
		if (parent.object === path.node) polyfillVar(path, dataNode);
	},
	Property(path, parent, dataNode) {
		if (path.node !== parent.value) return;
		const objPattern = path.parent?.parent?.node;
		if (!objPattern) return;
		const objParent = path.parent.parent.parent?.node;
		if (!objParent) return;
		if (objParent.type === "VariableDeclarator" && objParent.id === objPattern) return;
		parent.shorthand = false;
		polyfillVar(path, dataNode);
	},
	AssignmentPattern(path, parent, dataNode) {
		if (parent.right === path.node) polyfillVar(path, dataNode);
	},
	VariableDeclarator(path, parent, dataNode) {
		if (parent.init === path.node) polyfillVar(path, dataNode);
	}
};
const jsVariablePolyfill = (ast, dataNode) => {
	(0, import_main$7.visit)(ast, {
		visitImportExpression(_path) {
			throw new Error("Imports are not supported");
		},
		visitIdentifier(path) {
			this.traverse(path);
			const parent = path.parent.node;
			if (EXEMPT_IDENTIFIER_LIST.includes(path.node.name)) return;
			switch (parent.type) {
				case "AssignmentPattern":
				case "Property":
				case "MemberExpression":
				case "OptionalMemberExpression":
				case "VariableDeclarator":
					if (!customPatches[parent.type]) throw new Error(`Couldn\'t find custom patcher for parent type: ${parent.type}`);
					customPatches[parent.type](path, parent, dataNode);
					break;
				case "BinaryExpression":
				case "UnaryExpression":
				case "ArrayExpression":
				case "AssignmentExpression":
				case "SequenceExpression":
				case "YieldExpression":
				case "UpdateExpression":
				case "LogicalExpression":
				case "ConditionalExpression":
				case "NewExpression":
				case "CallExpression":
				case "OptionalCallExpression":
				case "TaggedTemplateExpression":
				case "TemplateLiteral":
				case "AwaitExpression":
				case "ImportExpression":
				case "ForStatement":
				case "IfStatement":
				case "WhileStatement":
				case "ForInStatement":
				case "ForOfStatement":
				case "SwitchStatement":
				case "ReturnStatement":
				case "DoWhileStatement":
				case "ExpressionStatement":
				case "ForAwaitStatement":
				case "ThrowStatement":
				case "WithStatement":
				case "TupleExpression":
					polyfillVar(path, dataNode);
					break;
				case "Super":
				case "Identifier":
				case "ArrowFunctionExpression":
				case "FunctionDeclaration":
				case "FunctionExpression":
				case "ThisExpression":
				case "ObjectExpression":
				case "MetaProperty":
				case "ChainExpression":
				case "PrivateName":
				case "ParenthesizedExpression":
				case "Import":
				case "VariableDeclaration":
				case "CatchClause":
				case "BlockStatement":
				case "TryStatement":
				case "EmptyStatement":
				case "LabeledStatement":
				case "BreakStatement":
				case "ContinueStatement":
				case "DebuggerStatement":
				case "ImportDeclaration":
				case "ExportDeclaration":
				case "ExportAllDeclaration":
				case "ExportDefaultDeclaration":
				case "Noop":
				case "ClassMethod":
				case "ClassPrivateMethod":
				case "RestElement":
				case "ArrayPattern":
				case "ObjectPattern":
				case "ClassExpression":
				case "RecordExpression":
				case "V8IntrinsicIdentifier":
				case "TopicReference":
				case "MethodDefinition":
				case "ClassDeclaration":
				case "ClassProperty":
				case "StaticBlock":
				case "ClassBody":
				case "ExportNamedDeclaration":
				case "ClassPrivateProperty":
				case "ClassAccessorProperty":
				case "PropertyPattern": break;
				case "SpreadElementPattern":
				case "SpreadPropertyPattern":
				case "ClassPropertyDefinition": break;
				case "DeclareClass":
				case "DeclareModule":
				case "DeclareVariable":
				case "DeclareFunction":
				case "DeclareInterface":
				case "DeclareTypeAlias":
				case "DeclareOpaqueType":
				case "DeclareModuleExports":
				case "DeclareExportDeclaration":
				case "DeclareExportAllDeclaration":
				case "InterfaceDeclaration":
				case "TypeAlias":
				case "OpaqueType":
				case "EnumDeclaration":
				case "TypeCastExpression": break;
				case "TSAsExpression":
				case "TSTypeParameter":
				case "TSTypeAssertion":
				case "TSDeclareMethod":
				case "TSIndexSignature":
				case "TSDeclareFunction":
				case "TSMethodSignature":
				case "TSEnumDeclaration":
				case "TSExportAssignment":
				case "TSNonNullExpression":
				case "TSPropertySignature":
				case "TSModuleDeclaration":
				case "TSParameterProperty":
				case "TSTypeCastExpression":
				case "TSSatisfiesExpression":
				case "TSTypeAliasDeclaration":
				case "TSInterfaceDeclaration":
				case "TSImportEqualsDeclaration":
				case "TSExternalModuleReference":
				case "TSInstantiationExpression":
				case "TSTypeParameterDeclaration":
				case "TSCallSignatureDeclaration":
				case "TSNamespaceExportDeclaration":
				case "TSConstructSignatureDeclaration": break;
				case "DirectiveLiteral":
				case "StringLiteral":
				case "NumericLiteral":
				case "BigIntLiteral":
				case "NullLiteral":
				case "Literal":
				case "RegExpLiteral":
				case "BooleanLiteral":
				case "DecimalLiteral": break;
				case "DoExpression":
				case "BindExpression": break;
				case "JSXIdentifier":
				case "JSXText":
				case "JSXElement":
				case "JSXFragment":
				case "JSXMemberExpression":
				case "JSXExpressionContainer": break;
				case "ComprehensionExpression":
				case "GeneratorExpression":
					polyfillVar(path, dataNode);
					break;
				default:
					assertNever(parent);
					break;
			}
		}
	});
	return ast.program.body;
};
var OPEN_BRACKET$1 = /(?<brackets>\{\{)/;
var CLOSE_BRACKET$1 = /(?<brackets>\}\})/;
const escapeCode$1 = (text) => {
	return text.replace("\\}}", "}}");
};
var normalizeBackslashes = (text) => {
	return text.replace(/\\\\/g, "\\");
};
const splitExpression$1 = (expression) => {
	const chunks = [];
	let searchingFor = "open";
	let activeRegex = OPEN_BRACKET$1;
	let buffer$1 = "";
	let index = 0;
	while (index < expression.length) {
		const expr = expression.slice(index);
		const res = activeRegex.exec(expr);
		if (!res?.groups) {
			buffer$1 += expr;
			if (searchingFor === "open") chunks.push({
				type: "text",
				text: buffer$1
			});
			else chunks.push({
				type: "code",
				text: escapeCode$1(buffer$1),
				hasClosingBrackets: false
			});
			break;
		}
		if ((expr.slice(0, res.index).match(/\\*$/)?.[0]?.length ?? 0) % 2 === 1) {
			buffer$1 += expr.slice(0, res.index + 2);
			index += res.index + 2;
		} else {
			buffer$1 += expr.slice(0, res.index);
			if (searchingFor === "open") {
				chunks.push({
					type: "text",
					text: normalizeBackslashes(buffer$1)
				});
				searchingFor = "close";
				activeRegex = CLOSE_BRACKET$1;
			} else {
				chunks.push({
					type: "code",
					text: escapeCode$1(buffer$1),
					hasClosingBrackets: true
				});
				searchingFor = "open";
				activeRegex = OPEN_BRACKET$1;
			}
			index += res.index + 2;
			buffer$1 = "";
		}
	}
	return chunks;
};
var escapeTmplExpression$1 = (part) => {
	return part.replace("}}", "\\}}");
};
const joinExpression$1 = (parts) => {
	return parts.map((chunk$1) => {
		if (chunk$1.type === "code") return `{{${escapeTmplExpression$1(chunk$1.text)}${chunk$1.hasClosingBrackets ? "}}" : ""}`;
		return chunk$1.text;
	}).join("");
};
var import_util$1 = /* @__PURE__ */ __toESM(require_util());
function parseWithEsprimaNext$1(source, options) {
	try {
		return parse(source, {
			loc: true,
			locations: true,
			comment: true,
			range: (0, import_util$1.getOption)(options, "range", false),
			tolerant: (0, import_util$1.getOption)(options, "tolerant", true),
			tokens: true,
			jsx: (0, import_util$1.getOption)(options, "jsx", false),
			sourceType: (0, import_util$1.getOption)(options, "sourceType", "module")
		});
	} catch (error$1) {
		if (error$1 instanceof Error) throw new SyntaxError(error$1.message);
		throw error$1;
	}
}
var import_main$5 = /* @__PURE__ */ __toESM(require_main$1());
var import_main$6 = /* @__PURE__ */ __toESM(require_main());
var v$1 = import_main$6.builders.identifier("v");
var shouldAlwaysWrapList = [
	"window",
	"global",
	"this"
];
var shouldWrapInTry = (node) => {
	let shouldWrap = false;
	(0, import_main$5.visit)(node, {
		visitMemberExpression() {
			shouldWrap = true;
			return false;
		},
		visitCallExpression() {
			shouldWrap = true;
			return false;
		},
		visitIdentifier(path) {
			if (shouldAlwaysWrapList.includes(path.node.name)) {
				shouldWrap = true;
				return false;
			}
			this.traverse(path);
		}
	});
	return shouldWrap;
};
var hasFunction = (node) => {
	let hasFn = false;
	(0, import_main$5.visit)(node, {
		visitFunctionExpression() {
			hasFn = true;
			return false;
		},
		visitFunctionDeclaration() {
			hasFn = true;
			return false;
		},
		visitArrowFunctionExpression() {
			hasFn = true;
			return false;
		}
	});
	return hasFn;
};
var hasTemplateString = (node) => {
	let hasTemp = false;
	(0, import_main$5.visit)(node, { visitTemplateLiteral(path) {
		if (path.node.expressions.length) {
			hasTemp = true;
			return false;
		}
		this.traverse(path);
	} });
	return hasTemp;
};
var wrapInErrorHandler = (node) => {
	return import_main$6.builders.tryStatement(import_main$6.builders.blockStatement([node]), import_main$6.builders.catchClause(import_main$6.builders.identifier("e"), null, import_main$6.builders.blockStatement([import_main$6.builders.expressionStatement(import_main$6.builders.callExpression(import_main$6.builders.identifier("E"), [import_main$6.builders.identifier("e"), import_main$6.builders.thisExpression()]))])));
};
var maybeWrapExpr = (expr) => {
	if (expr.trimStart()[0] === "{") return "(" + expr + ")";
	return expr;
};
var buildFunctionBody = (expr) => {
	return import_main$6.builders.blockStatement([import_main$6.builders.expressionStatement(import_main$6.builders.assignmentExpression("=", v$1, expr)), import_main$6.builders.returnStatement(import_main$6.builders.conditionalExpression(import_main$6.builders.logicalExpression("||", import_main$6.builders.logicalExpression("||", v$1, import_main$6.builders.binaryExpression("===", v$1, import_main$6.builders.literal(0))), import_main$6.builders.binaryExpression("===", v$1, import_main$6.builders.literal(false))), v$1, import_main$6.builders.literal("")))]);
};
var fixStringNewLines = (node) => {
	const replace = (str) => {
		return str.replace(/\n/g, "\\n");
	};
	(0, import_main$5.visit)(node, { visitTemplateElement(path) {
		this.traverse(path);
		const el = import_main$6.builders.templateElement({
			cooked: path.node.value.cooked === null ? null : replace(path.node.value.cooked),
			raw: replace(path.node.value.raw)
		}, path.node.tail);
		path.replace(el);
	} });
	return node;
};
const getParsedExpression = (expr) => {
	return splitExpression$1(expr).map((chunk$1) => {
		if (chunk$1.type === "code") {
			const node = (0, import_main$5.parse)(maybeWrapExpr(chunk$1.text), { parser: { parse: parseWithEsprimaNext$1 } });
			return {
				...chunk$1,
				parsed: node
			};
		}
		return chunk$1;
	});
};
const getExpressionCode = (expr, dataNodeName, hooks) => {
	const chunks = getParsedExpression(expr);
	const newProg = import_main$6.builders.program([import_main$6.builders.variableDeclaration("var", [import_main$6.builders.variableDeclarator(globalIdentifier, import_main$6.builders.objectExpression([]))])]);
	let dataNode = import_main$6.builders.thisExpression();
	const hasFn = chunks.filter((c$1) => c$1.type === "code").some((c$1) => hasFunction(c$1.parsed));
	if (hasFn) {
		dataNode = import_main$6.builders.identifier(dataNodeName);
		newProg.body.push(import_main$6.builders.variableDeclaration("var", [import_main$6.builders.variableDeclarator(dataNode, import_main$6.builders.thisExpression())]));
	}
	const hasTempString = chunks.filter((c$1) => c$1.type === "code").some((c$1) => hasTemplateString(c$1.parsed));
	if (chunks.length > 2 || chunks[0].text !== "" || chunks[0].text === "" && chunks.length === 1) {
		let parts = [];
		for (const chunk$1 of chunks) if (chunk$1.type === "text") parts.push(import_main$6.builders.literal(chunk$1.text));
		else {
			const fixed = fixStringNewLines(chunk$1.parsed);
			for (const hook of hooks.before) hook(fixed, dataNode);
			const parsed = jsVariablePolyfill(fixed, dataNode)?.[0];
			if (!parsed || parsed.type !== "ExpressionStatement") throw new SyntaxError("Not a expression statement");
			for (const hook of hooks.after) hook(parsed, dataNode);
			const functionBody = buildFunctionBody(parsed.expression);
			if (shouldWrapInTry(parsed)) functionBody.body = [
				wrapInErrorHandler(functionBody.body[0]),
				import_main$6.builders.expressionStatement(import_main$6.builders.identifier("")),
				functionBody.body[1]
			];
			parts.push(import_main$6.builders.callExpression(import_main$6.builders.memberExpression(import_main$6.builders.functionExpression(null, [v$1], functionBody), import_main$6.builders.identifier("call")), [import_main$6.builders.thisExpression()]));
		}
		if (chunks.length < 2) newProg.body.push(import_main$6.builders.returnStatement(parts[0]));
		else {
			parts = parts.filter((i$2) => !(i$2.type === "Literal" && i$2.value === ""));
			newProg.body.push(import_main$6.builders.returnStatement(import_main$6.builders.callExpression(import_main$6.builders.memberExpression(import_main$6.builders.arrayExpression(parts), import_main$6.builders.identifier("join")), [import_main$6.builders.literal("")])));
		}
	} else {
		const fixed = fixStringNewLines(chunks[1].parsed);
		for (const hook of hooks.before) hook(fixed, dataNode);
		const parsed = jsVariablePolyfill(fixed, dataNode)?.[0];
		if (!parsed || parsed.type !== "ExpressionStatement") throw new SyntaxError("Not a expression statement");
		for (const hook of hooks.after) hook(parsed, dataNode);
		let retData = import_main$6.builders.returnStatement(parsed.expression);
		if (shouldWrapInTry(parsed)) retData = wrapInErrorHandler(retData);
		newProg.body.push(retData);
	}
	return [(0, import_main$5.print)(newProg).code, { has: {
		function: hasFn,
		templateString: hasTempString
	} }];
};
var skipRegex = (function() {
	var beforeReChars = "[{(,;:?=|&!^~>%*/";
	var beforeReWords = [
		"case",
		"default",
		"do",
		"else",
		"in",
		"instanceof",
		"prefix",
		"return",
		"typeof",
		"void",
		"yield"
	];
	var wordsLastChar = beforeReWords.reduce(function(s$2, w$1) {
		return s$2 + w$1.slice(-1);
	}, "");
	var RE_REGEX = /^\/(?=[^*>/])[^[/\\]*(?:(?:\\.|\[(?:\\.|[^\]\\]*)*\])[^[\\/]*)*?\/[gimuy]*/;
	var RE_VN_CHAR = /[$\w]/;
	function prev(code$1, pos) {
		while (--pos >= 0 && /\s/.test(code$1[pos]));
		return pos;
	}
	function _skipRegex(code$1, start) {
		var re = /.*/g;
		var pos = re.lastIndex = start++;
		var match$1 = re.exec(code$1)[0].match(RE_REGEX);
		if (match$1) {
			var next = pos + match$1[0].length;
			pos = prev(code$1, pos);
			var c$1 = code$1[pos];
			if (pos < 0 || ~beforeReChars.indexOf(c$1)) return next;
			if (c$1 === ".") {
				if (code$1[pos - 1] === ".") start = next;
			} else if (c$1 === "+" || c$1 === "-") {
				if (code$1[--pos] !== c$1 || (pos = prev(code$1, pos)) < 0 || !RE_VN_CHAR.test(code$1[pos])) start = next;
			} else if (~wordsLastChar.indexOf(c$1)) {
				var end = pos + 1;
				while (--pos >= 0 && RE_VN_CHAR.test(code$1[pos]));
				if (~beforeReWords.indexOf(code$1.slice(pos + 1, end))) start = next;
			}
		}
		return start;
	}
	return _skipRegex;
})();
var brackets = (function(UNDEF) {
	var REGLOB = "g", R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g, R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|`[^`\\]*(?:\\[\S\s][^`\\]*)*`/g, S_QBLOCKS = R_STRINGS.source + "|" + /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + "|" + /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?([^<]\/)[gim]*/.source, UNSUPPORTED = RegExp("[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]"), NEED_ESCAPE = /(?=[[\]()*+?.^$|])/g, S_QBLOCK2 = R_STRINGS.source + "|" + /(\/)(?![*\/])/.source, FINDBRACES = {
		"(": RegExp("([()])|" + S_QBLOCK2, REGLOB),
		"[": RegExp("([[\\]])|" + S_QBLOCK2, REGLOB),
		"{": RegExp("([{}])|" + S_QBLOCK2, REGLOB)
	}, DEFAULT = "{ }";
	var _pairs = [
		"{",
		"}",
		"{",
		"}",
		/{[^}]*}/,
		/\\([{}])/g,
		/\\({)|{/g,
		RegExp("\\\\(})|([[({])|(})|" + S_QBLOCK2, REGLOB),
		DEFAULT,
		/^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/,
		/(^|[^\\]){=[\S\s]*?}/
	];
	var cachedBrackets = UNDEF, _regex, _cache = [], _settings;
	function _loopback(re) {
		return re;
	}
	function _rewrite(re, bp) {
		if (!bp) bp = _cache;
		return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : "");
	}
	function _create(pair) {
		if (pair === DEFAULT) return _pairs;
		var arr = pair.split(" ");
		if (arr.length !== 2 || UNSUPPORTED.test(pair)) throw new Error("Unsupported brackets \"" + pair + "\"");
		arr = arr.concat(pair.replace(NEED_ESCAPE, "\\").split(" "));
		arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr);
		arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr);
		arr[6] = _rewrite(_pairs[6], arr);
		arr[7] = RegExp("\\\\(" + arr[3] + ")|([[({])|(" + arr[3] + ")|" + S_QBLOCK2, REGLOB);
		arr[8] = pair;
		return arr;
	}
	function _brackets(reOrIdx) {
		return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];
	}
	_brackets.split = function split(str, tmpl$1, _bp) {
		// istanbul ignore next: _bp is for the compiler
		if (!_bp) _bp = _cache;
		var parts = [], match$1, isexpr, start, pos, re = _bp[6];
		var qblocks = [];
		var prevStr = "";
		var mark, lastIndex;
		isexpr = start = re.lastIndex = 0;
		while (match$1 = re.exec(str)) {
			lastIndex = re.lastIndex;
			pos = match$1.index;
			if (isexpr) {
				if (match$1[2]) {
					var ch = match$1[2];
					var rech = FINDBRACES[ch];
					var ix = 1;
					rech.lastIndex = lastIndex;
					while (match$1 = rech.exec(str)) if (match$1[1]) {
						if (match$1[1] === ch) ++ix;
						else if (!--ix) break;
					} else rech.lastIndex = pushQBlock(match$1.index, rech.lastIndex, match$1[2]);
					re.lastIndex = ix ? str.length : rech.lastIndex;
					continue;
				}
				if (!match$1[3]) {
					re.lastIndex = pushQBlock(pos, lastIndex, match$1[4]);
					continue;
				}
			}
			if (!match$1[1]) {
				unescapeStr(str.slice(start, pos));
				start = re.lastIndex;
				re = _bp[6 + (isexpr ^= 1)];
				re.lastIndex = start;
			}
		}
		if (str && start < str.length) unescapeStr(str.slice(start));
		parts.qblocks = qblocks;
		return parts;
		function unescapeStr(s$2) {
			if (prevStr) {
				s$2 = prevStr + s$2;
				prevStr = "";
			}
			if (tmpl$1 || isexpr) parts.push(s$2 && s$2.replace(_bp[5], "$1"));
			else parts.push(s$2);
		}
		function pushQBlock(_pos, _lastIndex, slash) {
			if (slash) _lastIndex = skipRegex(str, _pos);
			if (tmpl$1 && _lastIndex > _pos + 2) {
				mark = "⁗" + qblocks.length + "~";
				qblocks.push(str.slice(_pos, _lastIndex));
				prevStr += str.slice(start, _pos) + mark;
				start = _lastIndex;
			}
			return _lastIndex;
		}
	};
	_brackets.hasExpr = function hasExpr(str) {
		return _cache[4].test(str);
	};
	_brackets.loopKeys = function loopKeys(expr) {
		var m$1 = expr.match(_cache[9]);
		return m$1 ? {
			key: m$1[1],
			pos: m$1[2],
			val: _cache[0] + m$1[3].trim() + _cache[1]
		} : { val: expr.trim() };
	};
	_brackets.array = function array(pair) {
		return pair ? _create(pair) : _cache;
	};
	function _reset(pair) {
		if ((pair || (pair = DEFAULT)) !== _cache[8]) {
			_cache = _create(pair);
			_regex = pair === DEFAULT ? _loopback : _rewrite;
			_cache[9] = _regex(_pairs[9]);
		}
		cachedBrackets = pair;
	}
	function _setSettings(o$1) {
		var b$5;
		o$1 = o$1 || {};
		b$5 = o$1.brackets;
		Object.defineProperty(o$1, "brackets", {
			set: _reset,
			get: function() {
				return cachedBrackets;
			},
			enumerable: true
		});
		_settings = o$1;
		_reset(b$5);
	}
	Object.defineProperty(_brackets, "settings", {
		set: _setSettings,
		get: function() {
			return _settings;
		}
	});
	/* istanbul ignore next: in the browser riot is always in the scope */
	_brackets.settings = typeof riot !== "undefined" && riot.settings || {};
	_brackets.set = _reset;
	_brackets.skipRegex = skipRegex;
	_brackets.R_STRINGS = R_STRINGS;
	_brackets.R_MLCOMMS = R_MLCOMMS;
	_brackets.S_QBLOCKS = S_QBLOCKS;
	_brackets.S_QBLOCK2 = S_QBLOCK2;
	return _brackets;
})();
var tmpl = (function() {
	var _cache = {};
	function _tmpl(str, data) {
		if (!str) return str;
		return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr.bind({
			data,
			tmpl: str
		}));
	}
	_tmpl.hasExpr = brackets.hasExpr;
	_tmpl.loopKeys = brackets.loopKeys;
	// istanbul ignore next
	_tmpl.clearCache = function() {
		_cache = {};
	};
	_tmpl.errorHandler = null;
	_tmpl.getStr = _getStr;
	function _logErr(err, ctx) {
		err.riotData = {
			tagName: ctx && ctx.__ && ctx.__.tagName,
			_riot_id: ctx && ctx._riot_id
		};
		if (_tmpl.errorHandler) _tmpl.errorHandler(err);
		else if (typeof console !== "undefined" && typeof console.error === "function") {
			console.error(err.message);
			console.log("<%s> %s", err.riotData.tagName || "Unknown tag", this.tmpl);
			console.log(this.data);
		}
	}
	function _getStr(str) {
		var expr = _getTmpl(str);
		if (expr.slice(0, 11) !== "try{return ") expr = "return " + expr;
		expr = "var " + (typeof window !== "object" ? "global" : "window") + " = {}; " + expr;
		return expr;
	}
	function _create(str) {
		var expr = _getTmpl(str);
		if (expr.slice(0, 11) !== "try{return ") expr = "return " + expr;
		expr = "var " + (typeof window !== "object" ? "global" : "window") + " = {}; " + expr;
		return new Function("E", expr + ";");
	}
	var RE_DQUOTE = /\u2057/g;
	var RE_QBMARK = /\u2057(\d+)~/g;
	function _getTmpl(str) {
		var parts = brackets.split(str.replace(RE_DQUOTE, "\""), 1);
		var qstr = parts.qblocks;
		var expr;
		if (parts.length > 2 || parts[0]) {
			var i$2, j$1, list = [];
			for (i$2 = j$1 = 0; i$2 < parts.length; ++i$2) {
				expr = parts[i$2];
				if (expr && (expr = i$2 & 1 ? _parseExpr(expr, 1, qstr) : "\"" + expr.replace(/\\/g, "\\\\").replace(/\r\n?|\n/g, "\\n").replace(/"/g, "\\\"") + "\"")) list[j$1++] = expr;
			}
			expr = j$1 < 2 ? list[0] : "[" + list.join(",") + "].join(\"\")";
		} else expr = _parseExpr(parts[1], 0, qstr);
		if (qstr.length) expr = expr.replace(RE_QBMARK, function(_$1, pos) {
			return qstr[pos].replace(/\r/g, "\\r").replace(/\n/g, "\\n");
		});
		return expr;
	}
	var RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/;
	var RE_BREND = {
		"(": /[()]/g,
		"[": /[[\]]/g,
		"{": /[{}]/g
	};
	function _parseExpr(expr, asText, qstr) {
		expr = expr.replace(/\s+/g, " ").trim().replace(/\ ?([[\({},?\.:])\ ?/g, "$1");
		if (expr) {
			var list = [], cnt = 0, match$1;
			while (expr && (match$1 = expr.match(RE_CSNAME)) && !match$1.index) {
				var key, jsb, re = /,|([[{(])|$/g;
				expr = RegExp.rightContext;
				key = match$1[2] ? qstr[match$1[2]].slice(1, -1).trim().replace(/\s+/g, " ") : match$1[1];
				while (jsb = (match$1 = re.exec(expr))[1]) skipBraces(jsb, re);
				jsb = expr.slice(0, match$1.index);
				expr = RegExp.rightContext;
				list[cnt++] = _wrapExpr(jsb, 1, key);
			}
			expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? "[" + list.join(",") + "].join(\" \").trim()" : list[0];
		}
		return expr;
		function skipBraces(ch, re$1) {
			var mm, lv = 1, ir = RE_BREND[ch];
			ir.lastIndex = re$1.lastIndex;
			while (mm = ir.exec(expr)) if (mm[0] === ch) ++lv;
			else if (!--lv) break;
			re$1.lastIndex = lv ? expr.length : ir.lastIndex;
		}
	}
	// istanbul ignore next: not both
	var JS_CONTEXT = "\"in this?this:" + (typeof window !== "object" ? "global" : "window") + ").", JS_VARNAME = /[,{][\$\w]+(?=:)|(^ *|[^$\w\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g, JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;
	function _wrapExpr(expr, asText, key) {
		var tb;
		expr = expr.replace(JS_VARNAME, function(match$1, p$1, mvar, pos, s$2) {
			if (mvar) {
				pos = tb ? 0 : pos + match$1.length;
				if (mvar !== "this" && mvar !== "global" && mvar !== "window") {
					match$1 = p$1 + "(\"" + mvar + JS_CONTEXT + mvar;
					if (pos) tb = (s$2 = s$2[pos]) === "." || s$2 === "(" || s$2 === "[";
				} else if (pos) tb = !JS_NOPROPS.test(s$2.slice(pos));
			}
			return match$1;
		});
		if (tb) expr = "try{return " + expr + "}catch(e){E(e,this)}";
		if (key) expr = (tb ? "function(){" + expr + "}.call(this)" : "(" + expr + ")") + "?\"" + key + "\":\"\"";
		else if (asText) if (expr === "false") expr = "function(v){" + (tb ? expr.replace("return ", "v=") : "v=(" + expr + ")") + ";return false}.call(this)";
		else expr = "function(v){" + (tb ? expr.replace("return ", "v=") : "v=(" + expr + ")") + ";return v||v===0||v===false?v:\"\"}.call(this)";
		return expr;
	}
	_tmpl.version = brackets.version = "v1.0.0";
	return _tmpl;
})();
var import_main$4 = /* @__PURE__ */ __toESM(require_main$1());
var isWrapped = (node) => {
	return node.program.body[1]?.type === "TryStatement";
};
var getWrapped = (node) => {
	return node.program.body[1]?.block.body[0];
};
var isMultiPartExpression = (node) => {
	return node.program.body[1]?.type === "ReturnStatement" && node.program.body[1].argument?.type === "CallExpression" && node.program.body[1].argument?.arguments[0]?.type === "Literal" && node.program.body[1].argument?.arguments[0]?.value === "" && node.program.body[1].argument?.callee.type === "MemberExpression" && node.program.body[1].argument?.callee.object.type === "ArrayExpression" && node.program.body[1].argument?.callee.property.type === "Identifier" && node.program.body[1].argument?.callee.property.name === "join";
};
var getMultiPartExpression = (node) => {
	if (!(node.program.body[1]?.type === "ReturnStatement" && node.program.body[1].argument?.type === "CallExpression" && node.program.body[1].argument?.arguments[0]?.type === "Literal" && node.program.body[1].argument?.arguments[0]?.value === "" && node.program.body[1].argument?.callee.type === "MemberExpression" && node.program.body[1].argument?.callee.object.type === "ArrayExpression")) return [];
	return node.program.body[1].argument.callee.object.elements.map((e$1) => {
		if (e$1?.type !== "CallExpression" || e$1.callee.type !== "MemberExpression" || e$1.callee.object.type !== "FunctionExpression") return null;
		const maybeExpr = e$1.callee.object.body.body[0];
		if (maybeExpr.type !== "TryStatement") return maybeExpr;
		return maybeExpr.block.body[0];
	}).filter((e$1) => e$1 !== null);
};
const isDifferent = (tmpl$1, tourn) => {
	const tmplParsed = (0, import_main$4.parse)(tmpl$1, { parser: { parse: parseWithEsprimaNext$1 } });
	const tournParsed = (0, import_main$4.parse)(tourn, { parser: { parse: parseWithEsprimaNext$1 } });
	const problemPaths = [];
	let same = import_main$4.types.astNodesAreEquivalent(tmplParsed, tournParsed, problemPaths);
	if (!same) {
		if (isWrapped(tournParsed) && !isWrapped(tmplParsed)) {
			const tournWrapped = getWrapped(tournParsed);
			same = import_main$4.types.astNodesAreEquivalent(tmplParsed.program.body[1], tournWrapped);
		} else if (isMultiPartExpression(tournParsed) && isMultiPartExpression(tmplParsed)) {
			const tournExprs = getMultiPartExpression(tournParsed);
			const tmplExprs = getMultiPartExpression(tmplParsed);
			if (tournExprs.length === tmplExprs.length) for (let i$2 = 0; i$2 < tournExprs.length; i$2++) {
				same = import_main$4.types.astNodesAreEquivalent(tmplExprs[i$2], tournExprs[i$2], problemPaths);
				if (!same) break;
			}
		}
	}
	return !same;
};
var import_main$3 = /* @__PURE__ */ __toESM(require_main$1());
const getTmplDifference = (expr, dataNodeName) => {
	if (!expr) return { same: true };
	if (brackets.settings.brackets !== "{{ }}") brackets.set("{{ }}");
	let tournParsed;
	let tmplParsed;
	let analysis;
	try {
		[tournParsed, analysis] = getExpressionCode(expr, dataNodeName, {
			before: [],
			after: []
		});
	} catch (e$1) {
		tournParsed = null;
		analysis = null;
	}
	try {
		tmplParsed = tmpl.getStr(expr);
	} catch (e$1) {
		tmplParsed = null;
	}
	if (analysis?.has.function || analysis?.has.templateString) return {
		same: false,
		expression: stripIdentifyingInformation(expr),
		has: analysis.has
	};
	if (tournParsed === null && tmplParsed === null) return { same: true };
	else if (tournParsed === null) return {
		same: false,
		expression: "UNPARSEABLE",
		parserError: {
			tmpl: false,
			tournament: true
		}
	};
	else if (tmplParsed === null) return {
		same: false,
		expression: stripIdentifyingInformation(expr),
		parserError: {
			tmpl: true,
			tournament: false
		}
	};
	if (isDifferent(tmplParsed, tournParsed)) return {
		same: false,
		expression: stripIdentifyingInformation(expr)
	};
	return {
		same: true,
		expression: stripIdentifyingInformation(expr)
	};
};
var CHAR_REPLACE = /\S/gu;
var replaceValue = (value) => {
	return value.replace(CHAR_REPLACE, "v");
};
const stripIdentifyingInformation = (expr) => {
	const chunks = getParsedExpression(expr);
	for (const chunk$1 of chunks) if (chunk$1.type === "text") chunk$1.text = replaceValue(chunk$1.text);
	else {
		(0, import_main$3.visit)(chunk$1.parsed, {
			visitLiteral(path) {
				this.traverse(path);
				if (typeof path.node.value === "string") path.node.value = replaceValue(path.node.value);
			},
			visitStringLiteral(path) {
				this.traverse(path);
				path.node.value = replaceValue(path.node.value);
			},
			visitTemplateElement(path) {
				this.traverse(path);
				if (path.node.value.cooked !== null) path.node.value.cooked = replaceValue(path.node.value.cooked);
				path.node.value.raw = replaceValue(path.node.value.raw);
			}
		});
		chunk$1.text = (0, import_main$3.print)(chunk$1.parsed).code;
	}
	return {
		value: joinExpression$1(chunks),
		sanitized: "ACTUALLY_SANITIZED_DO_NOT_MANUALLY_MAKE_THIS_OBJECT"
	};
};
var FunctionEvaluator = class {
	_codeCache = {};
	constructor(instance) {
		this.instance = instance;
	}
	getFunction(expr) {
		if (expr in this._codeCache) return this._codeCache[expr];
		const [code$1] = this.instance.getExpressionCode(expr);
		const func = new Function("E", code$1 + ";");
		this._codeCache[expr] = func;
		return func;
	}
	evaluate(expr, data) {
		return this.getFunction(expr).call(data, this.instance.errorHandler);
	}
};
var import_main$1 = /* @__PURE__ */ __toESM(require_main$1());
var import_main$2 = /* @__PURE__ */ __toESM(require_main());
var DATA_NODE_NAME = "___n8n_data";
var Tournament = class {
	evaluator;
	constructor(errorHandler$1 = () => {}, _dataNodeName = DATA_NODE_NAME, Evaluator = FunctionEvaluator, astHooks = {
		before: [],
		after: []
	}) {
		this.errorHandler = errorHandler$1;
		this._dataNodeName = _dataNodeName;
		this.astHooks = astHooks;
		this.setEvaluator(Evaluator);
	}
	setEvaluator(Evaluator) {
		this.evaluator = new Evaluator(this);
	}
	getExpressionCode(expr) {
		return getExpressionCode(expr, this._dataNodeName, this.astHooks);
	}
	tmplDiff(expr) {
		return getTmplDifference(expr, this._dataNodeName);
	}
	execute(expr, data) {
		if (!expr) return expr;
		return this.evaluator.evaluate(expr, data);
	}
};
const sanitizerName = "__sanitize";
var sanitizerIdentifier = import_main$2.builders.identifier(sanitizerName);
const DOLLAR_SIGN_ERROR = "Cannot access \"$\" without calling it as a function";
var isValidDollarPropertyAccess = (expr) => {
	if (typeof expr !== "object" || expr === null || !("type" in expr) || expr.type !== "MemberExpression" || !("property" in expr) || !("object" in expr)) return false;
	const property$2 = expr.property;
	const object = expr.object;
	const isPropertyDollar = typeof property$2 === "object" && property$2 !== null && "name" in property$2 && property$2.name === "$";
	const isObjectDollar = typeof object === "object" && object !== null && "name" in object && object.name === "$";
	const isObjectValid = typeof object === "object" && object !== null && "type" in object && (object.type === "Identifier" || object.type === "MemberExpression");
	return isPropertyDollar && !isObjectDollar && isObjectValid;
};
const DollarSignValidator = (ast, _dataNode) => {
	(0, import_main$1.visit)(ast, { visitIdentifier(path) {
		this.traverse(path);
		if (path.node.name !== "$") return;
		const parent = path.parent;
		if (typeof parent !== "object" || parent === null || !("name" in parent)) throw new ExpressionError(DOLLAR_SIGN_ERROR);
		if (parent.name === "callee") return;
		if (parent.name === "object") throw new ExpressionError(DOLLAR_SIGN_ERROR);
		if ("parent" in parent && typeof parent.parent === "object" && parent.parent !== null) {
			const grandparent = parent.parent;
			if ("value" in grandparent && typeof grandparent.value === "object" && grandparent.value !== null) {
				const gpNode = grandparent.value;
				if ("type" in gpNode && gpNode.type === "ExpressionStatement" && "expression" in gpNode) {
					if (isValidDollarPropertyAccess(gpNode.expression)) return;
				}
			}
		}
		throw new ExpressionError(DOLLAR_SIGN_ERROR);
	} });
};
const PrototypeSanitizer = (ast, dataNode) => {
	(0, import_main$1.visit)(ast, { visitMemberExpression(path) {
		this.traverse(path);
		const node = path.node;
		if (!node.computed) {
			if (node.property.type !== "Identifier") throw new ExpressionError(`Unknown property type ${node.property.type} while sanitising expression`);
			if (!isSafeObjectProperty(node.property.name)) throw new ExpressionError(`Cannot access "${node.property.name}" due to security concerns`);
		} else if (node.property.type === "StringLiteral" || node.property.type === "Literal") {
			if (!isSafeObjectProperty(node.property.value)) throw new ExpressionError(`Cannot access "${node.property.value}" due to security concerns`);
		} else if (!node.property.type.endsWith("Literal")) path.replace(import_main$2.builders.memberExpression(node.object, import_main$2.builders.callExpression(import_main$2.builders.memberExpression(dataNode, sanitizerIdentifier), [node.property]), true));
	} });
};
const sanitizer = (value) => {
	if (!isSafeObjectProperty(value)) throw new ExpressionError(`Cannot access "${value}" due to security concerns`);
	return value;
};
var errorHandler = () => {};
var tournamentEvaluator = new Tournament(errorHandler, void 0, void 0, {
	before: [],
	after: [PrototypeSanitizer, DollarSignValidator]
});
var evaluator = tournamentEvaluator.execute.bind(tournamentEvaluator);
const setErrorHandler = (handler) => {
	tournamentEvaluator.errorHandler = handler;
};
const evaluateExpression = (expr, data) => {
	return evaluator(expr, data);
};
const isExpression = (expr) => {
	if (typeof expr !== "string") return false;
	return expr.charAt(0) === "=";
};
var require__baseFindIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
		var length$1 = array.length, index = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index-- : ++index < length$1) if (predicate(array[index], index, array)) return index;
		return -1;
	}
	module.exports = baseFindIndex$1;
}));
var require__baseIsNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseIsNaN$1(value) {
		return value !== value;
	}
	module.exports = baseIsNaN$1;
}));
var require__strictIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function strictIndexOf$1(array, value, fromIndex) {
		var index = fromIndex - 1, length$1 = array.length;
		while (++index < length$1) if (array[index] === value) return index;
		return -1;
	}
	module.exports = strictIndexOf$1;
}));
var require__baseIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex = require__baseFindIndex(), baseIsNaN = require__baseIsNaN(), strictIndexOf = require__strictIndexOf();
	function baseIndexOf$1(array, value, fromIndex) {
		return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	module.exports = baseIndexOf$1;
}));
var require__arrayIncludes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIndexOf = require__baseIndexOf();
	function arrayIncludes$1(array, value) {
		return !!(array == null ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
	}
	module.exports = arrayIncludes$1;
}));
var require__arrayIncludesWith = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayIncludesWith$1(array, value, comparator) {
		var index = -1, length$1 = array == null ? 0 : array.length;
		while (++index < length$1) if (comparator(value, array[index])) return true;
		return false;
	}
	module.exports = arrayIncludesWith$1;
}));
var require_noop = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function noop$1() {}
	module.exports = noop$1;
}));
var require__createSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Set$1 = require__Set(), noop = require_noop(), setToArray$1 = require__setToArray();
	module.exports = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == Infinity) ? noop : function(values$1) {
		return new Set$1(values$1);
	};
}));
var require__baseUniq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), cacheHas = require__cacheHas(), createSet = require__createSet(), setToArray = require__setToArray();
	var LARGE_ARRAY_SIZE = 200;
	function baseUniq$1(array, iteratee, comparator) {
		var index = -1, includes$2 = arrayIncludes, length$1 = array.length, isCommon = true, result = [], seen = result;
		if (comparator) {
			isCommon = false;
			includes$2 = arrayIncludesWith;
		} else if (length$1 >= LARGE_ARRAY_SIZE) {
			var set = iteratee ? null : createSet(array);
			if (set) return setToArray(set);
			isCommon = false;
			includes$2 = cacheHas;
			seen = new SetCache();
		} else seen = iteratee ? [] : result;
		outer: while (++index < length$1) {
			var value = array[index], computed = iteratee ? iteratee(value) : value;
			value = comparator || value !== 0 ? value : 0;
			if (isCommon && computed === computed) {
				var seenIndex = seen.length;
				while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
				if (iteratee) seen.push(computed);
				result.push(value);
			} else if (!includes$2(seen, computed, comparator)) {
				if (seen !== result) seen.push(computed);
				result.push(value);
			}
		}
		return result;
	}
	module.exports = baseUniq$1;
}));
var require_uniqWith = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseUniq = require__baseUniq();
	function uniqWith$1(array, comparator) {
		comparator = typeof comparator == "function" ? comparator : void 0;
		return array && array.length ? baseUniq(array, void 0, comparator) : [];
	}
	module.exports = uniqWith$1;
}));
function isEmpty$4(value) {
	return Object.keys(value).length === 0;
}
function isNotEmpty$4(value) {
	return !isEmpty$4(value);
}
function keys$4(value) {
	return Object.keys(value);
}
function values(value) {
	return Object.values(value);
}
function hasField(value, extraArgs) {
	const [name] = extraArgs;
	return name in value;
}
function removeField(value, extraArgs) {
	const [name] = extraArgs;
	if (name in value) {
		const newObject = { ...value };
		delete newObject[name];
		return newObject;
	}
	return value;
}
function removeFieldsContaining(value, extraArgs) {
	const [match$1] = extraArgs;
	if (typeof match$1 !== "string" || match$1 === "") throw new ExpressionExtensionError("removeFieldsContaining(): expected non-empty string arg");
	const newObject = { ...value };
	for (const [key, val] of Object.entries(value)) if (typeof val === "string" && val.includes(match$1)) delete newObject[key];
	return newObject;
}
function keepFieldsContaining(value, extraArgs) {
	const [match$1] = extraArgs;
	if (typeof match$1 !== "string" || match$1 === "") throw new ExpressionExtensionError("argument of keepFieldsContaining must be a non-empty string");
	const newObject = { ...value };
	for (const [key, val] of Object.entries(value)) if (typeof val !== "string" || typeof val === "string" && !val.includes(match$1)) delete newObject[key];
	return newObject;
}
function compact(value) {
	const newObj = {};
	for (const [key, val] of Object.entries(value)) if (val !== null && val !== void 0 && val !== "nil" && val !== "") if (typeof val === "object") {
		if (Object.keys(val).length === 0) continue;
		newObj[key] = compact(val);
	} else newObj[key] = val;
	return newObj;
}
function urlEncode$1(value) {
	return new URLSearchParams(value).toString();
}
function toJsonString$2(value) {
	return JSON.stringify(value);
}
function toInt$5() {}
function toFloat$5() {}
function toBoolean$5() {}
function toDateTime$5() {}
isEmpty$4.doc = {
	name: "isEmpty",
	description: "Returns <code>true</code> if the Object has no keys (fields) set or is <code>null</code>",
	examples: [{
		example: "({'name': 'Nathan'}).isEmpty()",
		evaluated: "false"
	}, {
		example: "({}).isEmpty()",
		evaluated: "true"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-isEmpty"
};
isNotEmpty$4.doc = {
	name: "isNotEmpty",
	description: "Returns <code>true</code> if the Object has at least one key (field) set",
	examples: [{
		example: "({'name': 'Nathan'}).isNotEmpty()",
		evaluated: "true"
	}, {
		example: "({}).isNotEmpty()",
		evaluated: "false"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-isNotEmpty"
};
compact.doc = {
	name: "compact",
	description: "Removes all fields that have empty values, i.e. are <code>null</code>, <code>undefined</code>, <code>\"nil\"</code> or <code>\"\"</code>",
	examples: [{
		example: "({ x: null, y: 2, z: '' }).compact()",
		evaluated: "{ y: 2 }"
	}],
	returnType: "Object",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-compact"
};
urlEncode$1.doc = {
	name: "urlEncode",
	description: "Generates a URL parameter string from the Object's keys and values. Only top-level keys are supported.",
	examples: [{
		example: "({ name: 'Mr Nathan', city: 'hanoi' }).urlEncode()",
		evaluated: "'name=Mr+Nathan&city=hanoi'"
	}],
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-urlEncode"
};
hasField.doc = {
	name: "hasField",
	description: "Returns <code>true</code> if there is a field called <code>name</code>. Only checks top-level keys. Comparison is case-sensitive.",
	examples: [
		{
			example: "({ name: 'Nathan', age: 42 }).hasField('name')",
			evaluated: "true"
		},
		{
			example: "({ name: 'Nathan', age: 42 }).hasField('Name')",
			evaluated: "false"
		},
		{
			example: "({ name: 'Nathan', age: 42 }).hasField('inventedField')",
			evaluated: "false"
		}
	],
	returnType: "boolean",
	args: [{
		name: "name",
		optional: false,
		description: "The name of the key to search for",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-hasField"
};
removeField.doc = {
	name: "removeField",
	description: "Removes a field from the Object. The same as JavaScript's <code>delete</code>.",
	examples: [{
		example: "({ name: 'Nathan', city: 'hanoi' }).removeField('name')",
		evaluated: "{ city: 'hanoi' }"
	}],
	returnType: "Object",
	args: [{
		name: "key",
		optional: false,
		description: "The name of the field to remove",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-removeField"
};
removeFieldsContaining.doc = {
	name: "removeFieldsContaining",
	description: "Removes keys (fields) whose values at least partly match the given <code>value</code>. Comparison is case-sensitive. Fields that aren't strings are always kept.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('Nathan')",
			evaluated: "{ city: 'hanoi', age: 42 }"
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('Han')",
			evaluated: "{ age: 42 }"
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('nathan')",
			evaluated: "{ name: 'Mr Nathan', city: 'hanoi', age: 42 }"
		}
	],
	returnType: "Object",
	args: [{
		name: "value",
		optional: false,
		description: "The text that a value must contain in order to be removed",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-removeFieldsContaining"
};
keepFieldsContaining.doc = {
	name: "keepFieldsContaining",
	description: "Removes any fields whose values don't at least partly match the given <code>value</code>. Comparison is case-sensitive. Fields that aren't strings will always be removed.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('Nathan')",
			evaluated: "{ name: 'Mr Nathan' }"
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('nathan')",
			evaluated: "{}"
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('han')",
			evaluated: "{ name: 'Mr Nathan', city: 'hanoi' }"
		}
	],
	returnType: "Object",
	args: [{
		name: "value",
		optional: false,
		description: "The text that a value must contain in order to be kept",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-keepFieldsContaining"
};
keys$4.doc = {
	name: "keys",
	description: "Returns an array with all the field names (keys) the Object contains. The same as JavaScript's <code>Object.keys(obj)</code>.",
	examples: [{
		example: "({ name: 'Mr Nathan', age: 42 }).keys()",
		evaluated: "['name', 'age']"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-keys",
	returnType: "Array"
};
values.doc = {
	name: "values",
	description: "Returns an array with all the values of the fields the Object contains. The same as JavaScript's <code>Object.values(obj)</code>.",
	examples: [{
		example: "({ name: 'Mr Nathan', age: 42 }).values()",
		evaluated: "['Mr Nathan', 42]"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-values",
	returnType: "Array"
};
toJsonString$2.doc = {
	name: "toJsonString",
	description: "Converts the Object to a JSON string. Similar to JavaScript's <code>JSON.stringify()</code>.",
	examples: [{
		example: "({ name: 'Mr Nathan', age: 42 }).toJsonString()",
		evaluated: "'{\"name\":\"Nathan\",\"age\":42}'"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-toJsonString",
	returnType: "string"
};
const objectExtensions = {
	typeName: "Object",
	functions: {
		isEmpty: isEmpty$4,
		isNotEmpty: isNotEmpty$4,
		hasField,
		removeField,
		removeFieldsContaining,
		keepFieldsContaining,
		compact,
		urlEncode: urlEncode$1,
		keys: keys$4,
		values,
		toJsonString: toJsonString$2,
		toInt: toInt$5,
		toFloat: toFloat$5,
		toBoolean: toBoolean$5,
		toDateTime: toDateTime$5
	}
};
var import_isEqual$1 = /* @__PURE__ */ __toESM(require_isEqual());
var import_uniqWith = /* @__PURE__ */ __toESM(require_uniqWith());
function first(value) {
	return value[0];
}
function isEmpty$3(value) {
	return value.length === 0;
}
function isNotEmpty$3(value) {
	return value.length > 0;
}
function last(value) {
	return value[value.length - 1];
}
function pluck(value, extraArgs) {
	if (!Array.isArray(extraArgs)) throw new ExpressionError("arguments must be passed to pluck");
	if (!extraArgs || extraArgs.length === 0) return value;
	return value.reduce((pluckedFromObject, current) => {
		if (current && typeof current === "object") {
			const p$1 = [];
			Object.keys(current).forEach((k$1) => {
				extraArgs.forEach((field) => {
					if (current && field === k$1) p$1.push(current[k$1]);
				});
			});
			if (p$1.length > 0) pluckedFromObject.push(p$1.length === 1 ? p$1[0] : p$1);
		}
		return pluckedFromObject;
	}, new Array());
}
function randomItem(value) {
	const len$1 = value === void 0 ? 0 : value.length;
	return len$1 ? value[randomInt(len$1)] : void 0;
}
function unique(value, extraArgs) {
	const mapForEqualityCheck = (item) => {
		if (extraArgs.length > 0 && item && typeof item === "object") return extraArgs.reduce((acc, key) => {
			acc[key] = item[key];
			return acc;
		}, {});
		return item;
	};
	return (0, import_uniqWith.default)(value, (a$1, b$5) => (0, import_isEqual$1.default)(mapForEqualityCheck(a$1), mapForEqualityCheck(b$5)));
}
var ensureNumberArray = (arr, { fnName }) => {
	if (arr.some((i$2) => typeof i$2 !== "number")) throw new ExpressionExtensionError(`${fnName}(): all array elements must be numbers`);
};
function sum(value) {
	ensureNumberArray(value, { fnName: "sum" });
	return value.reduce((p$1, c$1) => {
		if (typeof c$1 === "string") return p$1 + parseFloat(c$1);
		if (typeof c$1 !== "number") return NaN;
		return p$1 + c$1;
	}, 0);
}
function min$1(value) {
	ensureNumberArray(value, { fnName: "min" });
	return Math.min(...value.map((v$3) => {
		if (typeof v$3 === "string") return parseFloat(v$3);
		if (typeof v$3 !== "number") return NaN;
		return v$3;
	}));
}
function max$1(value) {
	ensureNumberArray(value, { fnName: "max" });
	return Math.max(...value.map((v$3) => {
		if (typeof v$3 === "string") return parseFloat(v$3);
		if (typeof v$3 !== "number") return NaN;
		return v$3;
	}));
}
function average(value) {
	ensureNumberArray(value, { fnName: "average" });
	if (value.length === 0) return 0;
	return sum(value) / value.length;
}
function compact$1(value) {
	return value.filter((v$3) => {
		if (v$3 && typeof v$3 === "object" && Object.keys(v$3).length === 0) return false;
		return v$3 !== null && v$3 !== void 0 && v$3 !== "nil" && v$3 !== "";
	}).map((v$3) => {
		if (typeof v$3 === "object" && v$3 !== null) return compact(v$3);
		return v$3;
	});
}
function smartJoin(value, extraArgs) {
	const [keyField, valueField] = extraArgs;
	if (!keyField || !valueField || typeof keyField !== "string" || typeof valueField !== "string") throw new ExpressionExtensionError("smartJoin(): expected two string args, e.g. .smartJoin(\"name\", \"value\")");
	return value.reduce((o$1, v$3) => {
		if (typeof v$3 === "object" && v$3 !== null && keyField in v$3 && valueField in v$3) o$1[v$3[keyField]] = v$3[valueField];
		return o$1;
	}, {});
}
function chunk(value, extraArgs) {
	const [chunkSize] = extraArgs;
	if (typeof chunkSize !== "number" || chunkSize === 0) throw new ExpressionExtensionError("chunk(): expected non-zero numeric arg, e.g. .chunk(5)");
	const chunks = [];
	for (let i$2 = 0; i$2 < value.length; i$2 += chunkSize) chunks.push(value.slice(i$2, i$2 + chunkSize));
	return chunks;
}
function renameKeys(value, extraArgs) {
	if (extraArgs.length === 0 || extraArgs.length % 2 !== 0) throw new ExpressionExtensionError("renameKeys(): expected an even amount of args: from1, to1 [, from2, to2, ...]. e.g. .renameKeys(\"name\", \"title\")");
	return value.map((v$3) => {
		if (typeof v$3 !== "object" || v$3 === null) return v$3;
		const newObj = { ...v$3 };
		chunk(extraArgs, [2]).forEach(([from$2, to]) => {
			if (from$2 in newObj) {
				newObj[to] = newObj[from$2];
				delete newObj[from$2];
			}
		});
		return newObj;
	});
}
function mergeObjects(value, extraArgs) {
	const [other] = extraArgs;
	if (!other) return value;
	if (typeof other !== "object") throw new ExpressionExtensionError("merge(): expected object arg");
	const newObject = { ...value };
	for (const [key, val] of Object.entries(other)) if (!(key in newObject)) newObject[key] = val;
	return newObject;
}
function merge(value, extraArgs) {
	const [others] = extraArgs;
	if (others === void 0) return value.reduce((combined, current) => {
		if (current !== null && typeof current === "object" && !Array.isArray(current)) combined = mergeObjects(combined, [current]);
		return combined;
	}, {});
	if (!Array.isArray(others)) throw new ExpressionExtensionError("merge(): expected array arg, e.g. .merge([{ id: 1, otherValue: 3 }])");
	const listLength = value.length > others.length ? value.length : others.length;
	let merged = {};
	for (let i$2 = 0; i$2 < listLength; i$2++) if (value[i$2] !== void 0) {
		if (typeof value[i$2] === "object" && typeof others[i$2] === "object") merged = Object.assign(merged, mergeObjects(value[i$2], [others[i$2]]));
	}
	return merged;
}
function union$1(value, extraArgs) {
	const [others] = extraArgs;
	if (!Array.isArray(others)) throw new ExpressionExtensionError("union(): expected array arg, e.g. .union([1, 2, 3, 4])");
	const newArr = Array.from(value);
	for (const v$3 of others) if (newArr.findIndex((w$1) => (0, import_isEqual$1.default)(w$1, v$3)) === -1) newArr.push(v$3);
	return unique(newArr, []);
}
function difference$1(value, extraArgs) {
	const [others] = extraArgs;
	if (!Array.isArray(others)) throw new ExpressionExtensionError("difference(): expected array arg, e.g. .difference([1, 2, 3, 4])");
	const newArr = [];
	for (const v$3 of value) if (others.findIndex((w$1) => (0, import_isEqual$1.default)(w$1, v$3)) === -1) newArr.push(v$3);
	return unique(newArr, []);
}
function intersection$1(value, extraArgs) {
	const [others] = extraArgs;
	if (!Array.isArray(others)) throw new ExpressionExtensionError("intersection(): expected array arg, e.g. .intersection([1, 2, 3, 4])");
	const newArr = [];
	for (const v$3 of value) if (others.findIndex((w$1) => (0, import_isEqual$1.default)(w$1, v$3)) !== -1) newArr.push(v$3);
	for (const v$3 of others) if (value.findIndex((w$1) => (0, import_isEqual$1.default)(w$1, v$3)) !== -1) newArr.push(v$3);
	return unique(newArr, []);
}
function append(value, extraArgs) {
	return value.concat(extraArgs);
}
function toJsonString$1(value) {
	return JSON.stringify(value);
}
function toInt$4() {}
function toFloat$4() {}
function toBoolean$4() {}
function toDateTime$4() {}
average.doc = {
	name: "average",
	description: "Returns the average of the numbers in the array. Throws an error if there are any non-numbers.",
	examples: [{
		example: "[12, 1, 5].average()",
		evaluated: "6"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-average"
};
compact$1.doc = {
	name: "compact",
	description: "Removes any empty values from the array. <code>null</code>, <code>\"\"</code> and <code>undefined</code> count as empty.",
	examples: [{
		example: "[2, null, 1, \"\"].compact()",
		evaluated: "[2, 1]"
	}],
	returnType: "Array",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-compact"
};
isEmpty$3.doc = {
	name: "isEmpty",
	description: "Returns <code>true</code> if the array has no elements or is <code>null</code>",
	examples: [{
		example: "[].isEmpty()",
		evaluated: "true"
	}, {
		example: "['quick', 'brown', 'fox'].isEmpty()",
		evaluated: "false"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isEmpty"
};
isNotEmpty$3.doc = {
	name: "isNotEmpty",
	description: "Returns <code>true</code> if the array has at least one element",
	examples: [{
		example: "['quick', 'brown', 'fox'].isNotEmpty()",
		evaluated: "true"
	}, {
		example: "[].isNotEmpty()",
		evaluated: "false"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isNotEmpty"
};
first.doc = {
	name: "first",
	description: "Returns the first element of the array",
	examples: [{
		example: "['quick', 'brown', 'fox'].first()",
		evaluated: "'quick'"
	}],
	returnType: "any",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-first"
};
last.doc = {
	name: "last",
	description: "Returns the last element of the array",
	examples: [{
		example: "['quick', 'brown', 'fox'].last()",
		evaluated: "'fox'"
	}],
	returnType: "any",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-last"
};
max$1.doc = {
	name: "max",
	description: "Returns the largest number in the array. Throws an error if there are any non-numbers.",
	examples: [{
		example: "[1, 12, 5].max()",
		evaluated: "12"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-max"
};
min$1.doc = {
	name: "min",
	description: "Returns the smallest number in the array. Throws an error if there are any non-numbers.",
	examples: [{
		example: "[12, 1, 5].min()",
		evaluated: "1"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-min"
};
randomItem.doc = {
	name: "randomItem",
	description: "Returns a randomly-chosen element from the array",
	examples: [{
		example: "['quick', 'brown', 'fox'].randomItem()",
		evaluated: "'brown'"
	}, {
		example: "['quick', 'brown', 'fox'].randomItem()",
		evaluated: "'quick'"
	}],
	returnType: "any",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-randomItem"
};
sum.doc = {
	name: "sum",
	description: "Returns the total of all the numbers in the array. Throws an error if there are any non-numbers.",
	examples: [{
		example: "[12, 1, 5].sum()",
		evaluated: "18"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-sum"
};
chunk.doc = {
	name: "chunk",
	description: "Splits the array into an array of sub-arrays, each with the given length",
	examples: [{
		example: "[1, 2, 3, 4, 5, 6].chunk(2)",
		evaluated: "[[1,2],[3,4],[5,6]]"
	}],
	returnType: "Array",
	args: [{
		name: "length",
		optional: false,
		description: "The number of elements in each chunk",
		type: "number"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-chunk"
};
difference$1.doc = {
	name: "difference",
	description: "Compares two arrays. Returns all elements in the base array that aren't present\nin <code>otherArray</code>.",
	examples: [{
		example: "[1, 2, 3].difference([2, 3])",
		evaluated: "[1]"
	}],
	returnType: "Array",
	args: [{
		name: "otherArray",
		optional: false,
		description: "The array to compare to the base array",
		type: "Array"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-difference"
};
intersection$1.doc = {
	name: "intersection",
	description: "Compares two arrays. Returns all elements in the base array that are also present in the other array.",
	examples: [{
		example: "[1, 2].intersection([2, 3])",
		evaluated: "[2]"
	}],
	returnType: "Array",
	args: [{
		name: "otherArray",
		optional: false,
		description: "The array to compare to the base array",
		type: "Array"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-intersection"
};
merge.doc = {
	name: "merge",
	description: "Merges two Object-arrays into one object by merging the key-value pairs of each element.",
	examples: [{
		example: "[{ name: 'Nathan' }, { age: 42 }].merge([{ city: 'Berlin' }, { country: 'Germany' }])",
		evaluated: "{ name: 'Nathan', age: 42, city: 'Berlin', country: 'Germany' }"
	}],
	returnType: "Object",
	args: [{
		name: "otherArray",
		optional: false,
		description: "The array to merge into the base array",
		type: "Array"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-merge"
};
pluck.doc = {
	name: "pluck",
	description: "Returns an array containing the values of the given field(s) in each Object of the array. Ignores any array elements that aren’t Objects or don’t have a key matching the field name(s) provided.",
	examples: [{
		example: "[{ name: 'Nathan', age: 42 },{ name: 'Jan', city: 'Berlin' }].pluck('name')",
		evaluated: "[\"Nathan\", \"Jan\"]"
	}, {
		example: "[{ name: 'Nathan', age: 42 },{ name: 'Jan', city: 'Berlin' }].pluck('age')",
		evaluated: "[42]"
	}],
	returnType: "Array",
	args: [{
		name: "fieldNames",
		optional: false,
		variadic: true,
		description: "The keys to retrieve the value of",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-pluck"
};
renameKeys.doc = {
	name: "renameKeys",
	description: "Changes all matching keys (field names) of any Objects in the array. Rename more than one key by\nadding extra arguments, i.e. <code>from1, to1, from2, to2, ...</code>.",
	examples: [{
		example: "[{ name: 'bob' }, { name: 'meg' }].renameKeys('name', 'x')",
		evaluated: "[{ x: 'bob' }, { x: 'meg' }]"
	}],
	returnType: "Array",
	args: [{
		name: "from",
		optional: false,
		description: "The key to rename",
		type: "string"
	}, {
		name: "to",
		optional: false,
		description: "The new key name",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-renameKeys"
};
smartJoin.doc = {
	name: "smartJoin",
	description: "Creates a single Object from an array of Objects. Each Object in the array provides one field for the returned Object. Each Object in the array must contain a field with the key name and a field with the value.",
	examples: [{
		example: "[{ field: 'age', value: 2 }, { field: 'city', value: 'Berlin' }].smartJoin('field', 'value')",
		evaluated: "{ age: 2, city: 'Berlin' }"
	}],
	returnType: "Object",
	args: [{
		name: "keyField",
		optional: false,
		description: "The field in each Object containing the key name",
		type: "string"
	}, {
		name: "nameField",
		optional: false,
		description: "The field in each Object containing the value",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-smartJoin"
};
union$1.doc = {
	name: "union",
	description: "Concatenates two arrays and then removes any duplicates",
	examples: [{
		example: "[1, 2].union([2, 3])",
		evaluated: "[1, 2, 3]"
	}],
	returnType: "Array",
	args: [{
		name: "otherArray",
		optional: false,
		description: "The array to union with the base array",
		type: "Array"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-union"
};
unique.doc = {
	name: "unique",
	description: "Removes any duplicate elements from the array",
	examples: [
		{
			example: "['quick', 'brown', 'quick'].unique()",
			evaluated: "['quick', 'brown']"
		},
		{
			example: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }].unique()",
			evaluated: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }]"
		},
		{
			example: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }].unique('name')",
			evaluated: "[{ name: 'Nathan', age: 42 }]"
		}
	],
	returnType: "any",
	aliases: ["removeDuplicates"],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-unique",
	args: [{
		name: "fieldNames",
		optional: false,
		variadic: true,
		description: "The object keys to check for equality",
		type: "any"
	}]
};
toJsonString$1.doc = {
	name: "toJsonString",
	description: "Converts the array to a JSON string. The same as JavaScript's <code>JSON.stringify()</code>.",
	examples: [{
		example: "['quick', 'brown', 'fox'].toJsonString()",
		evaluated: "'[\"quick\",\"brown\",\"fox\"]'"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-toJsonString",
	returnType: "string"
};
append.doc = {
	name: "append",
	description: "Adds new elements to the end of the array. Similar to <code>push()</code>, but returns the modified array. Consider using spread syntax instead (see examples).",
	examples: [
		{
			example: "['forget', 'me'].append('not')",
			evaluated: "['forget', 'me', 'not']"
		},
		{
			example: "[9, 0, 2].append(1, 0)",
			evaluated: "[9, 0, 2, 1, 0]"
		},
		{
			example: "[...[9, 0, 2], 1, 0]",
			evaluated: "[9, 0, 2, 1, 0]",
			description: "Consider using spread syntax instead"
		}
	],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-append",
	returnType: "Array",
	args: [{
		name: "elements",
		optional: false,
		variadic: true,
		description: "The elements to append, in order",
		type: "any"
	}]
};
var removeDuplicates = unique.bind({});
removeDuplicates.doc = {
	...unique.doc,
	hidden: true
};
const arrayExtensions = {
	typeName: "Array",
	functions: {
		removeDuplicates,
		unique,
		first,
		last,
		pluck,
		randomItem,
		sum,
		min: min$1,
		max: max$1,
		average,
		isNotEmpty: isNotEmpty$3,
		isEmpty: isEmpty$3,
		compact: compact$1,
		smartJoin,
		chunk,
		renameKeys,
		merge,
		union: union$1,
		difference: difference$1,
		intersection: intersection$1,
		append,
		toJsonString: toJsonString$1,
		toInt: toInt$4,
		toFloat: toFloat$4,
		toBoolean: toBoolean$4,
		toDateTime: toDateTime$4
	}
};
function toBoolean$3(value) {
	return value;
}
function toInt$3(value) {
	return value ? 1 : 0;
}
function toDateTime$3() {}
var toFloat$3 = toInt$3;
var toNumber$1 = toInt$3.bind({});
toNumber$1.doc = {
	name: "toNumber",
	description: "Converts <code>true</code> to <code>1</code> and <code>false</code> to <code>0</code>.",
	examples: [{
		example: "true.toNumber()",
		evaluated: "1"
	}, {
		example: "false.toNumber()",
		evaluated: "0"
	}],
	section: "cast",
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/booleans/#boolean-toNumber"
};
const booleanExtensions = {
	typeName: "Boolean",
	functions: {
		toBoolean: toBoolean$3,
		toInt: toInt$3,
		toFloat: toFloat$3,
		toNumber: toNumber$1,
		toDateTime: toDateTime$3
	}
};
init_dist$2();
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64chs = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
var b64tab = ((a$1) => {
	let tab = {};
	a$1.forEach((c$1, i$2) => tab[c$1] = i$2);
	return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it$1, fn$1 = (x$1) => x$1) => new Uint8Array(Array.prototype.slice.call(it$1, 0).map(fn$1));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s$2) => s$2.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
	let u32, c0, c1, c2, asc = "";
	const pad$1 = bin.length % 3;
	for (let i$2 = 0; i$2 < bin.length;) {
		if ((c0 = bin.charCodeAt(i$2++)) > 255 || (c1 = bin.charCodeAt(i$2++)) > 255 || (c2 = bin.charCodeAt(i$2++)) > 255) throw new TypeError("invalid character found");
		u32 = c0 << 16 | c1 << 8 | c2;
		asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
	}
	return pad$1 ? asc.slice(0, pad$1 - 3) + "===".substring(pad$1) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
	const maxargs = 4096;
	let strs = [];
	for (let i$2 = 0, l$2 = u8a.length; i$2 < l$2; i$2 += maxargs) strs.push(_fromCC.apply(null, u8a.subarray(i$2, i$2 + maxargs)));
	return _btoa(strs.join(""));
};
var cb_utob = (c$1) => {
	if (c$1.length < 2) {
		var cc = c$1.charCodeAt(0);
		return cc < 128 ? c$1 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
	} else {
		var cc = 65536 + (c$1.charCodeAt(0) - 55296) * 1024 + (c$1.charCodeAt(1) - 56320);
		return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
	}
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u$1) => u$1.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s$2) => Buffer.from(s$2, "utf8").toString("base64") : _TE ? (s$2) => _fromUint8Array(_TE.encode(s$2)) : (s$2) => _btoa(utob(s$2));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
	switch (cccc.length) {
		case 4:
			var offset$1 = ((7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3)) - 65536;
			return _fromCC((offset$1 >>> 10) + 55296) + _fromCC((offset$1 & 1023) + 56320);
		case 3: return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
		default: return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
	}
};
var btou = (b$5) => b$5.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
	asc = asc.replace(/\s+/g, "");
	if (!b64re.test(asc)) throw new TypeError("malformed base64.");
	asc += "==".slice(2 - (asc.length & 3));
	let u24, bin = "", r1, r2;
	for (let i$2 = 0; i$2 < asc.length;) {
		u24 = b64tab[asc.charAt(i$2++)] << 18 | b64tab[asc.charAt(i$2++)] << 12 | (r1 = b64tab[asc.charAt(i$2++)]) << 6 | (r2 = b64tab[asc.charAt(i$2++)]);
		bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
	}
	return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a$1) => _U8Afrom(Buffer.from(a$1, "base64")) : (a$1) => _U8Afrom(_atob(a$1), (c$1) => c$1.charCodeAt(0));
var _decode = _hasBuffer ? (a$1) => Buffer.from(a$1, "base64").toString("utf8") : _TD ? (a$1) => _TD.decode(_toUint8Array(a$1)) : (a$1) => btou(_atob(a$1));
var _unURI = (a$1) => _tidyB64(a$1.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = "UINT8ARRAY not supported by this environment";
function r(t$1, n$6, e$1, r$1) {
	let i$2, s$2, o$1;
	const h$1 = n$6 || [0], u$1 = (e$1 = e$1 || 0) >>> 3, w$1 = -1 === r$1 ? 3 : 0;
	for (i$2 = 0; i$2 < t$1.length; i$2 += 1) o$1 = i$2 + u$1, s$2 = o$1 >>> 2, h$1.length <= s$2 && h$1.push(0), h$1[s$2] |= t$1[i$2] << 8 * (w$1 + r$1 * (o$1 % 4));
	return {
		value: h$1,
		binLen: 8 * t$1.length + e$1
	};
}
function i(i$2, s$2, o$1) {
	switch (s$2) {
		case "UTF8":
		case "UTF16BE":
		case "UTF16LE": break;
		default: throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
	}
	switch (i$2) {
		case "HEX": return function(t$1, n$6, e$1) {
			return function(t$2, n$7, e$2, r$1) {
				let i$3, s$3, o$2, h$1;
				if (0 != t$2.length % 2) throw new Error("String of HEX type must be in byte increments");
				const u$1 = n$7 || [0], w$1 = (e$2 = e$2 || 0) >>> 3, c$1 = -1 === r$1 ? 3 : 0;
				for (i$3 = 0; i$3 < t$2.length; i$3 += 2) {
					if (s$3 = parseInt(t$2.substr(i$3, 2), 16), isNaN(s$3)) throw new Error("String of HEX type contains invalid characters");
					for (h$1 = (i$3 >>> 1) + w$1, o$2 = h$1 >>> 2; u$1.length <= o$2;) u$1.push(0);
					u$1[o$2] |= s$3 << 8 * (c$1 + r$1 * (h$1 % 4));
				}
				return {
					value: u$1,
					binLen: 4 * t$2.length + e$2
				};
			}(t$1, n$6, e$1, o$1);
		};
		case "TEXT": return function(t$1, n$6, e$1) {
			return function(t$2, n$7, e$2, r$1, i$3) {
				let s$3, o$2, h$1, u$1, w$1, c$1, f$1, a$1, l$2 = 0;
				const A$1 = e$2 || [0], E$1 = (r$1 = r$1 || 0) >>> 3;
				if ("UTF8" === n$7) for (f$1 = -1 === i$3 ? 3 : 0, h$1 = 0; h$1 < t$2.length; h$1 += 1) for (s$3 = t$2.charCodeAt(h$1), o$2 = [], 128 > s$3 ? o$2.push(s$3) : 2048 > s$3 ? (o$2.push(192 | s$3 >>> 6), o$2.push(128 | 63 & s$3)) : 55296 > s$3 || 57344 <= s$3 ? o$2.push(224 | s$3 >>> 12, 128 | s$3 >>> 6 & 63, 128 | 63 & s$3) : (h$1 += 1, s$3 = 65536 + ((1023 & s$3) << 10 | 1023 & t$2.charCodeAt(h$1)), o$2.push(240 | s$3 >>> 18, 128 | s$3 >>> 12 & 63, 128 | s$3 >>> 6 & 63, 128 | 63 & s$3)), u$1 = 0; u$1 < o$2.length; u$1 += 1) {
					for (c$1 = l$2 + E$1, w$1 = c$1 >>> 2; A$1.length <= w$1;) A$1.push(0);
					A$1[w$1] |= o$2[u$1] << 8 * (f$1 + i$3 * (c$1 % 4)), l$2 += 1;
				}
				else for (f$1 = -1 === i$3 ? 2 : 0, a$1 = "UTF16LE" === n$7 && 1 !== i$3 || "UTF16LE" !== n$7 && 1 === i$3, h$1 = 0; h$1 < t$2.length; h$1 += 1) {
					for (s$3 = t$2.charCodeAt(h$1), !0 === a$1 && (u$1 = 255 & s$3, s$3 = u$1 << 8 | s$3 >>> 8), c$1 = l$2 + E$1, w$1 = c$1 >>> 2; A$1.length <= w$1;) A$1.push(0);
					A$1[w$1] |= s$3 << 8 * (f$1 + i$3 * (c$1 % 4)), l$2 += 2;
				}
				return {
					value: A$1,
					binLen: 8 * l$2 + r$1
				};
			}(t$1, s$2, n$6, e$1, o$1);
		};
		case "B64": return function(n$6, e$1, r$1) {
			return function(n$7, e$2, r$2, i$3) {
				let s$3, o$2, h$1, u$1, w$1, c$1, f$1, a$1 = 0;
				const l$2 = e$2 || [0], A$1 = (r$2 = r$2 || 0) >>> 3, E$1 = -1 === i$3 ? 3 : 0, H$1 = n$7.indexOf("=");
				if (-1 === n$7.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
				if (n$7 = n$7.replace(/=/g, ""), -1 !== H$1 && H$1 < n$7.length) throw new Error("Invalid '=' found in base-64 string");
				for (o$2 = 0; o$2 < n$7.length; o$2 += 4) {
					for (w$1 = n$7.substr(o$2, 4), u$1 = 0, h$1 = 0; h$1 < w$1.length; h$1 += 1) s$3 = t.indexOf(w$1.charAt(h$1)), u$1 |= s$3 << 18 - 6 * h$1;
					for (h$1 = 0; h$1 < w$1.length - 1; h$1 += 1) {
						for (f$1 = a$1 + A$1, c$1 = f$1 >>> 2; l$2.length <= c$1;) l$2.push(0);
						l$2[c$1] |= (u$1 >>> 16 - 8 * h$1 & 255) << 8 * (E$1 + i$3 * (f$1 % 4)), a$1 += 1;
					}
				}
				return {
					value: l$2,
					binLen: 8 * a$1 + r$2
				};
			}(n$6, e$1, r$1, o$1);
		};
		case "BYTES": return function(t$1, n$6, e$1) {
			return function(t$2, n$7, e$2, r$1) {
				let i$3, s$3, o$2, h$1;
				const u$1 = n$7 || [0], w$1 = (e$2 = e$2 || 0) >>> 3, c$1 = -1 === r$1 ? 3 : 0;
				for (s$3 = 0; s$3 < t$2.length; s$3 += 1) i$3 = t$2.charCodeAt(s$3), h$1 = s$3 + w$1, o$2 = h$1 >>> 2, u$1.length <= o$2 && u$1.push(0), u$1[o$2] |= i$3 << 8 * (c$1 + r$1 * (h$1 % 4));
				return {
					value: u$1,
					binLen: 8 * t$2.length + e$2
				};
			}(t$1, n$6, e$1, o$1);
		};
		case "ARRAYBUFFER": return function(t$1, n$6, e$1) {
			return function(t$2, n$7, e$2, i$3) {
				return r(new Uint8Array(t$2), n$7, e$2, i$3);
			}(t$1, n$6, e$1, o$1);
		};
		case "UINT8ARRAY":
			try {
				new Uint8Array(0);
			} catch (t$1) {
				throw new Error(e);
			}
			return function(t$1, n$6, e$1) {
				return r(t$1, n$6, e$1, o$1);
			};
		default: throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
	}
}
function s(r$1, i$2, s$2, o$1) {
	switch (r$1) {
		case "HEX": return function(t$1) {
			return function(t$2, n$6, e$1, r$2) {
				const i$3 = "0123456789abcdef";
				let s$3, o$2, h$1 = "";
				const u$1 = n$6 / 8, w$1 = -1 === e$1 ? 3 : 0;
				for (s$3 = 0; s$3 < u$1; s$3 += 1) o$2 = t$2[s$3 >>> 2] >>> 8 * (w$1 + e$1 * (s$3 % 4)), h$1 += i$3.charAt(o$2 >>> 4 & 15) + i$3.charAt(15 & o$2);
				return r$2.outputUpper ? h$1.toUpperCase() : h$1;
			}(t$1, i$2, s$2, o$1);
		};
		case "B64": return function(n$6) {
			return function(n$7, e$1, r$2, i$3) {
				let s$3, o$2, h$1, u$1, w$1, c$1 = "";
				const f$1 = e$1 / 8, a$1 = -1 === r$2 ? 3 : 0;
				for (s$3 = 0; s$3 < f$1; s$3 += 3) for (u$1 = s$3 + 1 < f$1 ? n$7[s$3 + 1 >>> 2] : 0, w$1 = s$3 + 2 < f$1 ? n$7[s$3 + 2 >>> 2] : 0, h$1 = (n$7[s$3 >>> 2] >>> 8 * (a$1 + r$2 * (s$3 % 4)) & 255) << 16 | (u$1 >>> 8 * (a$1 + r$2 * ((s$3 + 1) % 4)) & 255) << 8 | w$1 >>> 8 * (a$1 + r$2 * ((s$3 + 2) % 4)) & 255, o$2 = 0; o$2 < 4; o$2 += 1) c$1 += 8 * s$3 + 6 * o$2 <= e$1 ? t.charAt(h$1 >>> 6 * (3 - o$2) & 63) : i$3.b64Pad;
				return c$1;
			}(n$6, i$2, s$2, o$1);
		};
		case "BYTES": return function(t$1) {
			return function(t$2, n$6, e$1) {
				let r$2, i$3, s$3 = "";
				const o$2 = n$6 / 8, h$1 = -1 === e$1 ? 3 : 0;
				for (r$2 = 0; r$2 < o$2; r$2 += 1) i$3 = t$2[r$2 >>> 2] >>> 8 * (h$1 + e$1 * (r$2 % 4)) & 255, s$3 += String.fromCharCode(i$3);
				return s$3;
			}(t$1, i$2, s$2);
		};
		case "ARRAYBUFFER": return function(t$1) {
			return function(t$2, n$6, e$1) {
				let r$2;
				const i$3 = n$6 / 8, s$3 = new ArrayBuffer(i$3), o$2 = new Uint8Array(s$3), h$1 = -1 === e$1 ? 3 : 0;
				for (r$2 = 0; r$2 < i$3; r$2 += 1) o$2[r$2] = t$2[r$2 >>> 2] >>> 8 * (h$1 + e$1 * (r$2 % 4)) & 255;
				return s$3;
			}(t$1, i$2, s$2);
		};
		case "UINT8ARRAY":
			try {
				new Uint8Array(0);
			} catch (t$1) {
				throw new Error(e);
			}
			return function(t$1) {
				return function(t$2, n$6, e$1) {
					let r$2;
					const i$3 = n$6 / 8, s$3 = -1 === e$1 ? 3 : 0, o$2 = new Uint8Array(i$3);
					for (r$2 = 0; r$2 < i$3; r$2 += 1) o$2[r$2] = t$2[r$2 >>> 2] >>> 8 * (s$3 + e$1 * (r$2 % 4)) & 255;
					return o$2;
				}(t$1, i$2, s$2);
			};
		default: throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
	}
}
var o = 4294967296, h = [
	1116352408,
	1899447441,
	3049323471,
	3921009573,
	961987163,
	1508970993,
	2453635748,
	2870763221,
	3624381080,
	310598401,
	607225278,
	1426881987,
	1925078388,
	2162078206,
	2614888103,
	3248222580,
	3835390401,
	4022224774,
	264347078,
	604807628,
	770255983,
	1249150122,
	1555081692,
	1996064986,
	2554220882,
	2821834349,
	2952996808,
	3210313671,
	3336571891,
	3584528711,
	113926993,
	338241895,
	666307205,
	773529912,
	1294757372,
	1396182291,
	1695183700,
	1986661051,
	2177026350,
	2456956037,
	2730485921,
	2820302411,
	3259730800,
	3345764771,
	3516065817,
	3600352804,
	4094571909,
	275423344,
	430227734,
	506948616,
	659060556,
	883997877,
	958139571,
	1322822218,
	1537002063,
	1747873779,
	1955562222,
	2024104815,
	2227730452,
	2361852424,
	2428436474,
	2756734187,
	3204031479,
	3329325298
], u = [
	3238371032,
	914150663,
	812702999,
	4144912697,
	4290775857,
	1750603025,
	1694076839,
	3204075428
], w = [
	1779033703,
	3144134277,
	1013904242,
	2773480762,
	1359893119,
	2600822924,
	528734635,
	1541459225
], c = "Chosen SHA variant is not supported", f = "Cannot set numRounds with MAC";
function a(t$1, n$6) {
	let e$1, r$1;
	const i$2 = t$1.binLen >>> 3, s$2 = n$6.binLen >>> 3, o$1 = i$2 << 3, h$1 = 4 - i$2 << 3;
	if (i$2 % 4 != 0) {
		for (e$1 = 0; e$1 < s$2; e$1 += 4) r$1 = i$2 + e$1 >>> 2, t$1.value[r$1] |= n$6.value[e$1 >>> 2] << o$1, t$1.value.push(0), t$1.value[r$1 + 1] |= n$6.value[e$1 >>> 2] >>> h$1;
		return (t$1.value.length << 2) - 4 >= s$2 + i$2 && t$1.value.pop(), {
			value: t$1.value,
			binLen: t$1.binLen + n$6.binLen
		};
	}
	return {
		value: t$1.value.concat(n$6.value),
		binLen: t$1.binLen + n$6.binLen
	};
}
function l(t$1) {
	const n$6 = {
		outputUpper: !1,
		b64Pad: "=",
		outputLen: -1
	}, e$1 = t$1 || {}, r$1 = "Output length must be a multiple of 8";
	if (n$6.outputUpper = e$1.outputUpper || !1, e$1.b64Pad && (n$6.b64Pad = e$1.b64Pad), e$1.outputLen) {
		if (e$1.outputLen % 8 != 0) throw new Error(r$1);
		n$6.outputLen = e$1.outputLen;
	} else if (e$1.shakeLen) {
		if (e$1.shakeLen % 8 != 0) throw new Error(r$1);
		n$6.outputLen = e$1.shakeLen;
	}
	if ("boolean" != typeof n$6.outputUpper) throw new Error("Invalid outputUpper formatting option");
	if ("string" != typeof n$6.b64Pad) throw new Error("Invalid b64Pad formatting option");
	return n$6;
}
function A(t$1, n$6, e$1, r$1) {
	const s$2 = t$1 + " must include a value and format";
	if (!n$6) {
		if (!r$1) throw new Error(s$2);
		return r$1;
	}
	if (void 0 === n$6.value || !n$6.format) throw new Error(s$2);
	return i(n$6.format, n$6.encoding || "UTF8", e$1)(n$6.value);
}
var E = class {
	constructor(t$1, n$6, e$1) {
		const r$1 = e$1 || {};
		if (this.t = n$6, this.i = r$1.encoding || "UTF8", this.numRounds = r$1.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
		this.o = t$1, this.h = [], this.u = 0, this.l = !1, this.A = 0, this.H = !1, this.S = [], this.p = [];
	}
	update(t$1) {
		let n$6, e$1 = 0;
		const r$1 = this.m >>> 5, i$2 = this.C(t$1, this.h, this.u), s$2 = i$2.binLen, o$1 = i$2.value, h$1 = s$2 >>> 5;
		for (n$6 = 0; n$6 < h$1; n$6 += r$1) e$1 + this.m <= s$2 && (this.U = this.v(o$1.slice(n$6, n$6 + r$1), this.U), e$1 += this.m);
		return this.A += e$1, this.h = o$1.slice(e$1 >>> 5), this.u = s$2 % this.m, this.l = !0, this;
	}
	getHash(t$1, n$6) {
		let e$1, r$1, i$2 = this.R;
		const o$1 = l(n$6);
		if (this.K) {
			if (-1 === o$1.outputLen) throw new Error("Output length must be specified in options");
			i$2 = o$1.outputLen;
		}
		const h$1 = s(t$1, i$2, this.T, o$1);
		if (this.H && this.g) return h$1(this.g(o$1));
		for (r$1 = this.F(this.h.slice(), this.u, this.A, this.L(this.U), i$2), e$1 = 1; e$1 < this.numRounds; e$1 += 1) this.K && i$2 % 32 != 0 && (r$1[r$1.length - 1] &= 16777215 >>> 24 - i$2 % 32), r$1 = this.F(r$1, i$2, 0, this.B(this.o), i$2);
		return h$1(r$1);
	}
	setHMACKey(t$1, n$6, e$1) {
		if (!this.M) throw new Error("Variant does not support HMAC");
		if (this.l) throw new Error("Cannot set MAC key after calling update");
		const r$1 = i(n$6, (e$1 || {}).encoding || "UTF8", this.T);
		this.k(r$1(t$1));
	}
	k(t$1) {
		const n$6 = this.m >>> 3, e$1 = n$6 / 4 - 1;
		let r$1;
		if (1 !== this.numRounds) throw new Error(f);
		if (this.H) throw new Error("MAC key already set");
		for (n$6 < t$1.binLen / 8 && (t$1.value = this.F(t$1.value, t$1.binLen, 0, this.B(this.o), this.R)); t$1.value.length <= e$1;) t$1.value.push(0);
		for (r$1 = 0; r$1 <= e$1; r$1 += 1) this.S[r$1] = 909522486 ^ t$1.value[r$1], this.p[r$1] = 1549556828 ^ t$1.value[r$1];
		this.U = this.v(this.S, this.U), this.A = this.m, this.H = !0;
	}
	getHMAC(t$1, n$6) {
		const e$1 = l(n$6);
		return s(t$1, this.R, this.T, e$1)(this.Y());
	}
	Y() {
		let t$1;
		if (!this.H) throw new Error("Cannot call getHMAC without first setting MAC key");
		const n$6 = this.F(this.h.slice(), this.u, this.A, this.L(this.U), this.R);
		return t$1 = this.v(this.p, this.B(this.o)), t$1 = this.F(n$6, this.R, this.m, t$1, this.R), t$1;
	}
};
function H(t$1, n$6) {
	return t$1 << n$6 | t$1 >>> 32 - n$6;
}
function S(t$1, n$6) {
	return t$1 >>> n$6 | t$1 << 32 - n$6;
}
function b(t$1, n$6) {
	return t$1 >>> n$6;
}
function p(t$1, n$6, e$1) {
	return t$1 ^ n$6 ^ e$1;
}
function d(t$1, n$6, e$1) {
	return t$1 & n$6 ^ ~t$1 & e$1;
}
function m(t$1, n$6, e$1) {
	return t$1 & n$6 ^ t$1 & e$1 ^ n$6 & e$1;
}
function C(t$1) {
	return S(t$1, 2) ^ S(t$1, 13) ^ S(t$1, 22);
}
function y(t$1, n$6) {
	const e$1 = (65535 & t$1) + (65535 & n$6);
	return (65535 & (t$1 >>> 16) + (n$6 >>> 16) + (e$1 >>> 16)) << 16 | 65535 & e$1;
}
function U(t$1, n$6, e$1, r$1) {
	const i$2 = (65535 & t$1) + (65535 & n$6) + (65535 & e$1) + (65535 & r$1);
	return (65535 & (t$1 >>> 16) + (n$6 >>> 16) + (e$1 >>> 16) + (r$1 >>> 16) + (i$2 >>> 16)) << 16 | 65535 & i$2;
}
function v(t$1, n$6, e$1, r$1, i$2) {
	const s$2 = (65535 & t$1) + (65535 & n$6) + (65535 & e$1) + (65535 & r$1) + (65535 & i$2);
	return (65535 & (t$1 >>> 16) + (n$6 >>> 16) + (e$1 >>> 16) + (r$1 >>> 16) + (i$2 >>> 16) + (s$2 >>> 16)) << 16 | 65535 & s$2;
}
function R(t$1) {
	return S(t$1, 7) ^ S(t$1, 18) ^ b(t$1, 3);
}
function K(t$1) {
	return S(t$1, 6) ^ S(t$1, 11) ^ S(t$1, 25);
}
function T(t$1) {
	return [
		1732584193,
		4023233417,
		2562383102,
		271733878,
		3285377520
	];
}
function g(t$1, n$6) {
	let e$1, r$1, i$2, s$2, o$1, h$1, u$1;
	const w$1 = [];
	for (e$1 = n$6[0], r$1 = n$6[1], i$2 = n$6[2], s$2 = n$6[3], o$1 = n$6[4], u$1 = 0; u$1 < 80; u$1 += 1) w$1[u$1] = u$1 < 16 ? t$1[u$1] : H(w$1[u$1 - 3] ^ w$1[u$1 - 8] ^ w$1[u$1 - 14] ^ w$1[u$1 - 16], 1), h$1 = u$1 < 20 ? v(H(e$1, 5), d(r$1, i$2, s$2), o$1, 1518500249, w$1[u$1]) : u$1 < 40 ? v(H(e$1, 5), p(r$1, i$2, s$2), o$1, 1859775393, w$1[u$1]) : u$1 < 60 ? v(H(e$1, 5), m(r$1, i$2, s$2), o$1, 2400959708, w$1[u$1]) : v(H(e$1, 5), p(r$1, i$2, s$2), o$1, 3395469782, w$1[u$1]), o$1 = s$2, s$2 = i$2, i$2 = H(r$1, 30), r$1 = e$1, e$1 = h$1;
	return n$6[0] = y(e$1, n$6[0]), n$6[1] = y(r$1, n$6[1]), n$6[2] = y(i$2, n$6[2]), n$6[3] = y(s$2, n$6[3]), n$6[4] = y(o$1, n$6[4]), n$6;
}
function F(t$1, n$6, e$1, r$1) {
	let i$2;
	const s$2 = 15 + (n$6 + 65 >>> 9 << 4), h$1 = n$6 + e$1;
	for (; t$1.length <= s$2;) t$1.push(0);
	for (t$1[n$6 >>> 5] |= 128 << 24 - n$6 % 32, t$1[s$2] = 4294967295 & h$1, t$1[s$2 - 1] = h$1 / o | 0, i$2 = 0; i$2 < t$1.length; i$2 += 16) r$1 = g(t$1.slice(i$2, i$2 + 16), r$1);
	return r$1;
}
var L = class extends E {
	constructor(t$1, n$6, e$1) {
		if ("SHA-1" !== t$1) throw new Error(c);
		super(t$1, n$6, e$1);
		const r$1 = e$1 || {};
		this.M = !0, this.g = this.Y, this.T = -1, this.C = i(this.t, this.i, this.T), this.v = g, this.L = function(t$2) {
			return t$2.slice();
		}, this.B = T, this.F = F, this.U = [
			1732584193,
			4023233417,
			2562383102,
			271733878,
			3285377520
		], this.m = 512, this.R = 160, this.K = !1, r$1.hmacKey && this.k(A("hmacKey", r$1.hmacKey, this.T));
	}
};
function B(t$1) {
	let n$6;
	return n$6 = "SHA-224" == t$1 ? u.slice() : w.slice(), n$6;
}
function M(t$1, n$6) {
	let e$1, r$1, i$2, s$2, o$1, u$1, w$1, c$1, f$1, a$1, l$2;
	const A$1 = [];
	for (e$1 = n$6[0], r$1 = n$6[1], i$2 = n$6[2], s$2 = n$6[3], o$1 = n$6[4], u$1 = n$6[5], w$1 = n$6[6], c$1 = n$6[7], l$2 = 0; l$2 < 64; l$2 += 1) A$1[l$2] = l$2 < 16 ? t$1[l$2] : U(S(E$1 = A$1[l$2 - 2], 17) ^ S(E$1, 19) ^ b(E$1, 10), A$1[l$2 - 7], R(A$1[l$2 - 15]), A$1[l$2 - 16]), f$1 = v(c$1, K(o$1), d(o$1, u$1, w$1), h[l$2], A$1[l$2]), a$1 = y(C(e$1), m(e$1, r$1, i$2)), c$1 = w$1, w$1 = u$1, u$1 = o$1, o$1 = y(s$2, f$1), s$2 = i$2, i$2 = r$1, r$1 = e$1, e$1 = y(f$1, a$1);
	var E$1;
	return n$6[0] = y(e$1, n$6[0]), n$6[1] = y(r$1, n$6[1]), n$6[2] = y(i$2, n$6[2]), n$6[3] = y(s$2, n$6[3]), n$6[4] = y(o$1, n$6[4]), n$6[5] = y(u$1, n$6[5]), n$6[6] = y(w$1, n$6[6]), n$6[7] = y(c$1, n$6[7]), n$6;
}
var k = class extends E {
	constructor(t$1, n$6, e$1) {
		if ("SHA-224" !== t$1 && "SHA-256" !== t$1) throw new Error(c);
		super(t$1, n$6, e$1);
		const r$1 = e$1 || {};
		this.g = this.Y, this.M = !0, this.T = -1, this.C = i(this.t, this.i, this.T), this.v = M, this.L = function(t$2) {
			return t$2.slice();
		}, this.B = B, this.F = function(n$7, e$2, r$2, i$2) {
			return function(t$2, n$8, e$3, r$3, i$3) {
				let s$2, h$1;
				const u$1 = 15 + (n$8 + 65 >>> 9 << 4), w$1 = n$8 + e$3;
				for (; t$2.length <= u$1;) t$2.push(0);
				for (t$2[n$8 >>> 5] |= 128 << 24 - n$8 % 32, t$2[u$1] = 4294967295 & w$1, t$2[u$1 - 1] = w$1 / o | 0, s$2 = 0; s$2 < t$2.length; s$2 += 16) r$3 = M(t$2.slice(s$2, s$2 + 16), r$3);
				return h$1 = "SHA-224" === i$3 ? [
					r$3[0],
					r$3[1],
					r$3[2],
					r$3[3],
					r$3[4],
					r$3[5],
					r$3[6]
				] : r$3, h$1;
			}(n$7, e$2, r$2, i$2, t$1);
		}, this.U = B(t$1), this.m = 512, this.R = "SHA-224" === t$1 ? 224 : 256, this.K = !1, r$1.hmacKey && this.k(A("hmacKey", r$1.hmacKey, this.T));
	}
};
var Y = class {
	constructor(t$1, n$6) {
		this.N = t$1, this.I = n$6;
	}
};
function N(t$1, n$6) {
	let e$1;
	return n$6 > 32 ? (e$1 = 64 - n$6, new Y(t$1.I << n$6 | t$1.N >>> e$1, t$1.N << n$6 | t$1.I >>> e$1)) : 0 !== n$6 ? (e$1 = 32 - n$6, new Y(t$1.N << n$6 | t$1.I >>> e$1, t$1.I << n$6 | t$1.N >>> e$1)) : t$1;
}
function I(t$1, n$6) {
	let e$1;
	return n$6 < 32 ? (e$1 = 32 - n$6, new Y(t$1.N >>> n$6 | t$1.I << e$1, t$1.I >>> n$6 | t$1.N << e$1)) : (e$1 = 64 - n$6, new Y(t$1.I >>> n$6 | t$1.N << e$1, t$1.N >>> n$6 | t$1.I << e$1));
}
function X(t$1, n$6) {
	return new Y(t$1.N >>> n$6, t$1.I >>> n$6 | t$1.N << 32 - n$6);
}
function z(t$1, n$6, e$1) {
	return new Y(t$1.N & n$6.N ^ t$1.N & e$1.N ^ n$6.N & e$1.N, t$1.I & n$6.I ^ t$1.I & e$1.I ^ n$6.I & e$1.I);
}
function x(t$1) {
	const n$6 = I(t$1, 28), e$1 = I(t$1, 34), r$1 = I(t$1, 39);
	return new Y(n$6.N ^ e$1.N ^ r$1.N, n$6.I ^ e$1.I ^ r$1.I);
}
function _(t$1, n$6) {
	let e$1, r$1;
	e$1 = (65535 & t$1.I) + (65535 & n$6.I), r$1 = (t$1.I >>> 16) + (n$6.I >>> 16) + (e$1 >>> 16);
	const i$2 = (65535 & r$1) << 16 | 65535 & e$1;
	e$1 = (65535 & t$1.N) + (65535 & n$6.N) + (r$1 >>> 16), r$1 = (t$1.N >>> 16) + (n$6.N >>> 16) + (e$1 >>> 16);
	return new Y((65535 & r$1) << 16 | 65535 & e$1, i$2);
}
function O(t$1, n$6, e$1, r$1) {
	let i$2, s$2;
	i$2 = (65535 & t$1.I) + (65535 & n$6.I) + (65535 & e$1.I) + (65535 & r$1.I), s$2 = (t$1.I >>> 16) + (n$6.I >>> 16) + (e$1.I >>> 16) + (r$1.I >>> 16) + (i$2 >>> 16);
	const o$1 = (65535 & s$2) << 16 | 65535 & i$2;
	i$2 = (65535 & t$1.N) + (65535 & n$6.N) + (65535 & e$1.N) + (65535 & r$1.N) + (s$2 >>> 16), s$2 = (t$1.N >>> 16) + (n$6.N >>> 16) + (e$1.N >>> 16) + (r$1.N >>> 16) + (i$2 >>> 16);
	return new Y((65535 & s$2) << 16 | 65535 & i$2, o$1);
}
function P(t$1, n$6, e$1, r$1, i$2) {
	let s$2, o$1;
	s$2 = (65535 & t$1.I) + (65535 & n$6.I) + (65535 & e$1.I) + (65535 & r$1.I) + (65535 & i$2.I), o$1 = (t$1.I >>> 16) + (n$6.I >>> 16) + (e$1.I >>> 16) + (r$1.I >>> 16) + (i$2.I >>> 16) + (s$2 >>> 16);
	const h$1 = (65535 & o$1) << 16 | 65535 & s$2;
	s$2 = (65535 & t$1.N) + (65535 & n$6.N) + (65535 & e$1.N) + (65535 & r$1.N) + (65535 & i$2.N) + (o$1 >>> 16), o$1 = (t$1.N >>> 16) + (n$6.N >>> 16) + (e$1.N >>> 16) + (r$1.N >>> 16) + (i$2.N >>> 16) + (s$2 >>> 16);
	return new Y((65535 & o$1) << 16 | 65535 & s$2, h$1);
}
function V(t$1, n$6) {
	return new Y(t$1.N ^ n$6.N, t$1.I ^ n$6.I);
}
function Z(t$1) {
	const n$6 = I(t$1, 19), e$1 = I(t$1, 61), r$1 = X(t$1, 6);
	return new Y(n$6.N ^ e$1.N ^ r$1.N, n$6.I ^ e$1.I ^ r$1.I);
}
function j(t$1) {
	const n$6 = I(t$1, 1), e$1 = I(t$1, 8), r$1 = X(t$1, 7);
	return new Y(n$6.N ^ e$1.N ^ r$1.N, n$6.I ^ e$1.I ^ r$1.I);
}
function q(t$1) {
	const n$6 = I(t$1, 14), e$1 = I(t$1, 18), r$1 = I(t$1, 41);
	return new Y(n$6.N ^ e$1.N ^ r$1.N, n$6.I ^ e$1.I ^ r$1.I);
}
var D = [
	new Y(h[0], 3609767458),
	new Y(h[1], 602891725),
	new Y(h[2], 3964484399),
	new Y(h[3], 2173295548),
	new Y(h[4], 4081628472),
	new Y(h[5], 3053834265),
	new Y(h[6], 2937671579),
	new Y(h[7], 3664609560),
	new Y(h[8], 2734883394),
	new Y(h[9], 1164996542),
	new Y(h[10], 1323610764),
	new Y(h[11], 3590304994),
	new Y(h[12], 4068182383),
	new Y(h[13], 991336113),
	new Y(h[14], 633803317),
	new Y(h[15], 3479774868),
	new Y(h[16], 2666613458),
	new Y(h[17], 944711139),
	new Y(h[18], 2341262773),
	new Y(h[19], 2007800933),
	new Y(h[20], 1495990901),
	new Y(h[21], 1856431235),
	new Y(h[22], 3175218132),
	new Y(h[23], 2198950837),
	new Y(h[24], 3999719339),
	new Y(h[25], 766784016),
	new Y(h[26], 2566594879),
	new Y(h[27], 3203337956),
	new Y(h[28], 1034457026),
	new Y(h[29], 2466948901),
	new Y(h[30], 3758326383),
	new Y(h[31], 168717936),
	new Y(h[32], 1188179964),
	new Y(h[33], 1546045734),
	new Y(h[34], 1522805485),
	new Y(h[35], 2643833823),
	new Y(h[36], 2343527390),
	new Y(h[37], 1014477480),
	new Y(h[38], 1206759142),
	new Y(h[39], 344077627),
	new Y(h[40], 1290863460),
	new Y(h[41], 3158454273),
	new Y(h[42], 3505952657),
	new Y(h[43], 106217008),
	new Y(h[44], 3606008344),
	new Y(h[45], 1432725776),
	new Y(h[46], 1467031594),
	new Y(h[47], 851169720),
	new Y(h[48], 3100823752),
	new Y(h[49], 1363258195),
	new Y(h[50], 3750685593),
	new Y(h[51], 3785050280),
	new Y(h[52], 3318307427),
	new Y(h[53], 3812723403),
	new Y(h[54], 2003034995),
	new Y(h[55], 3602036899),
	new Y(h[56], 1575990012),
	new Y(h[57], 1125592928),
	new Y(h[58], 2716904306),
	new Y(h[59], 442776044),
	new Y(h[60], 593698344),
	new Y(h[61], 3733110249),
	new Y(h[62], 2999351573),
	new Y(h[63], 3815920427),
	new Y(3391569614, 3928383900),
	new Y(3515267271, 566280711),
	new Y(3940187606, 3454069534),
	new Y(4118630271, 4000239992),
	new Y(116418474, 1914138554),
	new Y(174292421, 2731055270),
	new Y(289380356, 3203993006),
	new Y(460393269, 320620315),
	new Y(685471733, 587496836),
	new Y(852142971, 1086792851),
	new Y(1017036298, 365543100),
	new Y(1126000580, 2618297676),
	new Y(1288033470, 3409855158),
	new Y(1501505948, 4234509866),
	new Y(1607167915, 987167468),
	new Y(1816402316, 1246189591)
];
function G(t$1) {
	return "SHA-384" === t$1 ? [
		new Y(3418070365, u[0]),
		new Y(1654270250, u[1]),
		new Y(2438529370, u[2]),
		new Y(355462360, u[3]),
		new Y(1731405415, u[4]),
		new Y(41048885895, u[5]),
		new Y(3675008525, u[6]),
		new Y(1203062813, u[7])
	] : [
		new Y(w[0], 4089235720),
		new Y(w[1], 2227873595),
		new Y(w[2], 4271175723),
		new Y(w[3], 1595750129),
		new Y(w[4], 2917565137),
		new Y(w[5], 725511199),
		new Y(w[6], 4215389547),
		new Y(w[7], 327033209)
	];
}
function J(t$1, n$6) {
	let e$1, r$1, i$2, s$2, o$1, h$1, u$1, w$1, c$1, f$1, a$1, l$2;
	const A$1 = [];
	for (e$1 = n$6[0], r$1 = n$6[1], i$2 = n$6[2], s$2 = n$6[3], o$1 = n$6[4], h$1 = n$6[5], u$1 = n$6[6], w$1 = n$6[7], a$1 = 0; a$1 < 80; a$1 += 1) a$1 < 16 ? (l$2 = 2 * a$1, A$1[a$1] = new Y(t$1[l$2], t$1[l$2 + 1])) : A$1[a$1] = O(Z(A$1[a$1 - 2]), A$1[a$1 - 7], j(A$1[a$1 - 15]), A$1[a$1 - 16]), c$1 = P(w$1, q(o$1), (H$1 = h$1, S$1 = u$1, new Y((E$1 = o$1).N & H$1.N ^ ~E$1.N & S$1.N, E$1.I & H$1.I ^ ~E$1.I & S$1.I)), D[a$1], A$1[a$1]), f$1 = _(x(e$1), z(e$1, r$1, i$2)), w$1 = u$1, u$1 = h$1, h$1 = o$1, o$1 = _(s$2, c$1), s$2 = i$2, i$2 = r$1, r$1 = e$1, e$1 = _(c$1, f$1);
	var E$1, H$1, S$1;
	return n$6[0] = _(e$1, n$6[0]), n$6[1] = _(r$1, n$6[1]), n$6[2] = _(i$2, n$6[2]), n$6[3] = _(s$2, n$6[3]), n$6[4] = _(o$1, n$6[4]), n$6[5] = _(h$1, n$6[5]), n$6[6] = _(u$1, n$6[6]), n$6[7] = _(w$1, n$6[7]), n$6;
}
var Q = class extends E {
	constructor(t$1, n$6, e$1) {
		if ("SHA-384" !== t$1 && "SHA-512" !== t$1) throw new Error(c);
		super(t$1, n$6, e$1);
		const r$1 = e$1 || {};
		this.g = this.Y, this.M = !0, this.T = -1, this.C = i(this.t, this.i, this.T), this.v = J, this.L = function(t$2) {
			return t$2.slice();
		}, this.B = G, this.F = function(n$7, e$2, r$2, i$2) {
			return function(t$2, n$8, e$3, r$3, i$3) {
				let s$2, h$1;
				const u$1 = 31 + (n$8 + 129 >>> 10 << 5), w$1 = n$8 + e$3;
				for (; t$2.length <= u$1;) t$2.push(0);
				for (t$2[n$8 >>> 5] |= 128 << 24 - n$8 % 32, t$2[u$1] = 4294967295 & w$1, t$2[u$1 - 1] = w$1 / o | 0, s$2 = 0; s$2 < t$2.length; s$2 += 32) r$3 = J(t$2.slice(s$2, s$2 + 32), r$3);
				return h$1 = "SHA-384" === i$3 ? [
					r$3[0].N,
					r$3[0].I,
					r$3[1].N,
					r$3[1].I,
					r$3[2].N,
					r$3[2].I,
					r$3[3].N,
					r$3[3].I,
					r$3[4].N,
					r$3[4].I,
					r$3[5].N,
					r$3[5].I
				] : [
					r$3[0].N,
					r$3[0].I,
					r$3[1].N,
					r$3[1].I,
					r$3[2].N,
					r$3[2].I,
					r$3[3].N,
					r$3[3].I,
					r$3[4].N,
					r$3[4].I,
					r$3[5].N,
					r$3[5].I,
					r$3[6].N,
					r$3[6].I,
					r$3[7].N,
					r$3[7].I
				], h$1;
			}(n$7, e$2, r$2, i$2, t$1);
		}, this.U = G(t$1), this.m = 1024, this.R = "SHA-384" === t$1 ? 384 : 512, this.K = !1, r$1.hmacKey && this.k(A("hmacKey", r$1.hmacKey, this.T));
	}
};
var W = [
	new Y(0, 1),
	new Y(0, 32898),
	new Y(2147483648, 32906),
	new Y(2147483648, 2147516416),
	new Y(0, 32907),
	new Y(0, 2147483649),
	new Y(2147483648, 2147516545),
	new Y(2147483648, 32777),
	new Y(0, 138),
	new Y(0, 136),
	new Y(0, 2147516425),
	new Y(0, 2147483658),
	new Y(0, 2147516555),
	new Y(2147483648, 139),
	new Y(2147483648, 32905),
	new Y(2147483648, 32771),
	new Y(2147483648, 32770),
	new Y(2147483648, 128),
	new Y(0, 32778),
	new Y(2147483648, 2147483658),
	new Y(2147483648, 2147516545),
	new Y(2147483648, 32896),
	new Y(0, 2147483649),
	new Y(2147483648, 2147516424)
], $ = [
	[
		0,
		36,
		3,
		41,
		18
	],
	[
		1,
		44,
		10,
		45,
		2
	],
	[
		62,
		6,
		43,
		15,
		61
	],
	[
		28,
		55,
		25,
		21,
		56
	],
	[
		27,
		20,
		39,
		8,
		14
	]
];
function tt(t$1) {
	let n$6;
	const e$1 = [];
	for (n$6 = 0; n$6 < 5; n$6 += 1) e$1[n$6] = [
		new Y(0, 0),
		new Y(0, 0),
		new Y(0, 0),
		new Y(0, 0),
		new Y(0, 0)
	];
	return e$1;
}
function nt(t$1) {
	let n$6;
	const e$1 = [];
	for (n$6 = 0; n$6 < 5; n$6 += 1) e$1[n$6] = t$1[n$6].slice();
	return e$1;
}
function et(t$1, n$6) {
	let e$1, r$1, i$2, s$2;
	const o$1 = [], h$1 = [];
	if (null !== t$1) for (r$1 = 0; r$1 < t$1.length; r$1 += 2) n$6[(r$1 >>> 1) % 5][(r$1 >>> 1) / 5 | 0] = V(n$6[(r$1 >>> 1) % 5][(r$1 >>> 1) / 5 | 0], new Y(t$1[r$1 + 1], t$1[r$1]));
	for (e$1 = 0; e$1 < 24; e$1 += 1) {
		for (s$2 = tt(), r$1 = 0; r$1 < 5; r$1 += 1) o$1[r$1] = (u$1 = n$6[r$1][0], w$1 = n$6[r$1][1], c$1 = n$6[r$1][2], f$1 = n$6[r$1][3], a$1 = n$6[r$1][4], new Y(u$1.N ^ w$1.N ^ c$1.N ^ f$1.N ^ a$1.N, u$1.I ^ w$1.I ^ c$1.I ^ f$1.I ^ a$1.I));
		for (r$1 = 0; r$1 < 5; r$1 += 1) h$1[r$1] = V(o$1[(r$1 + 4) % 5], N(o$1[(r$1 + 1) % 5], 1));
		for (r$1 = 0; r$1 < 5; r$1 += 1) for (i$2 = 0; i$2 < 5; i$2 += 1) n$6[r$1][i$2] = V(n$6[r$1][i$2], h$1[r$1]);
		for (r$1 = 0; r$1 < 5; r$1 += 1) for (i$2 = 0; i$2 < 5; i$2 += 1) s$2[i$2][(2 * r$1 + 3 * i$2) % 5] = N(n$6[r$1][i$2], $[r$1][i$2]);
		for (r$1 = 0; r$1 < 5; r$1 += 1) for (i$2 = 0; i$2 < 5; i$2 += 1) n$6[r$1][i$2] = V(s$2[r$1][i$2], new Y(~s$2[(r$1 + 1) % 5][i$2].N & s$2[(r$1 + 2) % 5][i$2].N, ~s$2[(r$1 + 1) % 5][i$2].I & s$2[(r$1 + 2) % 5][i$2].I));
		n$6[0][0] = V(n$6[0][0], W[e$1]);
	}
	var u$1, w$1, c$1, f$1, a$1;
	return n$6;
}
function rt(t$1) {
	let n$6, e$1, r$1 = 0;
	const i$2 = [0, 0], s$2 = [4294967295 & t$1, t$1 / o & 2097151];
	for (n$6 = 6; n$6 >= 0; n$6--) e$1 = s$2[n$6 >> 2] >>> 8 * n$6 & 255, 0 === e$1 && 0 === r$1 || (i$2[r$1 + 1 >> 2] |= e$1 << 8 * (r$1 + 1), r$1 += 1);
	return r$1 = 0 !== r$1 ? r$1 : 1, i$2[0] |= r$1, {
		value: r$1 + 1 > 4 ? i$2 : [i$2[0]],
		binLen: 8 + 8 * r$1
	};
}
function it(t$1) {
	return a(rt(t$1.binLen), t$1);
}
function st(t$1, n$6) {
	let e$1, r$1 = rt(n$6);
	r$1 = a(r$1, t$1);
	const i$2 = n$6 >>> 2, s$2 = (i$2 - r$1.value.length % i$2) % i$2;
	for (e$1 = 0; e$1 < s$2; e$1++) r$1.value.push(0);
	return r$1.value;
}
var ot = class extends E {
	constructor(t$1, n$6, e$1) {
		let r$1 = 6, s$2 = 0;
		super(t$1, n$6, e$1);
		const o$1 = e$1 || {};
		if (1 !== this.numRounds) {
			if (o$1.kmacKey || o$1.hmacKey) throw new Error(f);
			if ("CSHAKE128" === this.o || "CSHAKE256" === this.o) throw new Error("Cannot set numRounds for CSHAKE variants");
		}
		switch (this.T = 1, this.C = i(this.t, this.i, this.T), this.v = et, this.L = nt, this.B = tt, this.U = tt(), this.K = !1, t$1) {
			case "SHA3-224":
				this.m = s$2 = 1152, this.R = 224, this.M = !0, this.g = this.Y;
				break;
			case "SHA3-256":
				this.m = s$2 = 1088, this.R = 256, this.M = !0, this.g = this.Y;
				break;
			case "SHA3-384":
				this.m = s$2 = 832, this.R = 384, this.M = !0, this.g = this.Y;
				break;
			case "SHA3-512":
				this.m = s$2 = 576, this.R = 512, this.M = !0, this.g = this.Y;
				break;
			case "SHAKE128":
				r$1 = 31, this.m = s$2 = 1344, this.R = -1, this.K = !0, this.M = !1, this.g = null;
				break;
			case "SHAKE256":
				r$1 = 31, this.m = s$2 = 1088, this.R = -1, this.K = !0, this.M = !1, this.g = null;
				break;
			case "KMAC128":
				r$1 = 4, this.m = s$2 = 1344, this.X(e$1), this.R = -1, this.K = !0, this.M = !1, this.g = this._;
				break;
			case "KMAC256":
				r$1 = 4, this.m = s$2 = 1088, this.X(e$1), this.R = -1, this.K = !0, this.M = !1, this.g = this._;
				break;
			case "CSHAKE128":
				this.m = s$2 = 1344, r$1 = this.O(e$1), this.R = -1, this.K = !0, this.M = !1, this.g = null;
				break;
			case "CSHAKE256":
				this.m = s$2 = 1088, r$1 = this.O(e$1), this.R = -1, this.K = !0, this.M = !1, this.g = null;
				break;
			default: throw new Error(c);
		}
		this.F = function(t$2, n$7, e$2, i$2, o$2) {
			return function(t$3, n$8, e$3, r$2, i$3, s$3, o$3) {
				let h$1, u$1, w$1 = 0;
				const c$1 = [], f$1 = i$3 >>> 5, a$1 = n$8 >>> 5;
				for (h$1 = 0; h$1 < a$1 && n$8 >= i$3; h$1 += f$1) r$2 = et(t$3.slice(h$1, h$1 + f$1), r$2), n$8 -= i$3;
				for (t$3 = t$3.slice(h$1), n$8 %= i$3; t$3.length < f$1;) t$3.push(0);
				for (h$1 = n$8 >>> 3, t$3[h$1 >> 2] ^= s$3 << h$1 % 4 * 8, t$3[f$1 - 1] ^= 2147483648, r$2 = et(t$3, r$2); 32 * c$1.length < o$3 && (u$1 = r$2[w$1 % 5][w$1 / 5 | 0], c$1.push(u$1.I), !(32 * c$1.length >= o$3));) c$1.push(u$1.N), w$1 += 1, 0 == 64 * w$1 % i$3 && (et(null, r$2), w$1 = 0);
				return c$1;
			}(t$2, n$7, 0, i$2, s$2, r$1, o$2);
		}, o$1.hmacKey && this.k(A("hmacKey", o$1.hmacKey, this.T));
	}
	O(t$1, n$6) {
		const e$1 = function(t$2) {
			const n$7 = t$2 || {};
			return {
				funcName: A("funcName", n$7.funcName, 1, {
					value: [],
					binLen: 0
				}),
				customization: A("Customization", n$7.customization, 1, {
					value: [],
					binLen: 0
				})
			};
		}(t$1 || {});
		n$6 && (e$1.funcName = n$6);
		const r$1 = a(it(e$1.funcName), it(e$1.customization));
		if (0 !== e$1.customization.binLen || 0 !== e$1.funcName.binLen) {
			const t$2 = st(r$1, this.m >>> 3);
			for (let n$7 = 0; n$7 < t$2.length; n$7 += this.m >>> 5) this.U = this.v(t$2.slice(n$7, n$7 + (this.m >>> 5)), this.U), this.A += this.m;
			return 4;
		}
		return 31;
	}
	X(t$1) {
		const n$6 = function(t$2) {
			const n$7 = t$2 || {};
			return {
				kmacKey: A("kmacKey", n$7.kmacKey, 1),
				funcName: {
					value: [1128353099],
					binLen: 32
				},
				customization: A("Customization", n$7.customization, 1, {
					value: [],
					binLen: 0
				})
			};
		}(t$1 || {});
		this.O(t$1, n$6.funcName);
		const e$1 = st(it(n$6.kmacKey), this.m >>> 3);
		for (let t$2 = 0; t$2 < e$1.length; t$2 += this.m >>> 5) this.U = this.v(e$1.slice(t$2, t$2 + (this.m >>> 5)), this.U), this.A += this.m;
		this.H = !0;
	}
	_(t$1) {
		const n$6 = a({
			value: this.h.slice(),
			binLen: this.u
		}, function(t$2) {
			let n$7, e$1, r$1 = 0;
			const i$2 = [0, 0], s$2 = [4294967295 & t$2, t$2 / o & 2097151];
			for (n$7 = 6; n$7 >= 0; n$7--) e$1 = s$2[n$7 >> 2] >>> 8 * n$7 & 255, 0 === e$1 && 0 === r$1 || (i$2[r$1 >> 2] |= e$1 << 8 * r$1, r$1 += 1);
			return r$1 = 0 !== r$1 ? r$1 : 1, i$2[r$1 >> 2] |= r$1 << 8 * r$1, {
				value: r$1 + 1 > 4 ? i$2 : [i$2[0]],
				binLen: 8 + 8 * r$1
			};
		}(t$1.outputLen));
		return this.F(n$6.value, n$6.binLen, this.A, this.L(this.U), t$1.outputLen);
	}
};
var ht = class {
	constructor(t$1, n$6, e$1) {
		if ("SHA-1" == t$1) this.P = new L(t$1, n$6, e$1);
		else if ("SHA-224" == t$1 || "SHA-256" == t$1) this.P = new k(t$1, n$6, e$1);
		else if ("SHA-384" == t$1 || "SHA-512" == t$1) this.P = new Q(t$1, n$6, e$1);
		else {
			if ("SHA3-224" != t$1 && "SHA3-256" != t$1 && "SHA3-384" != t$1 && "SHA3-512" != t$1 && "SHAKE128" != t$1 && "SHAKE256" != t$1 && "CSHAKE128" != t$1 && "CSHAKE256" != t$1 && "KMAC128" != t$1 && "KMAC256" != t$1) throw new Error(c);
			this.P = new ot(t$1, n$6, e$1);
		}
	}
	update(t$1) {
		return this.P.update(t$1), this;
	}
	getHash(t$1, n$6) {
		return this.P.getHash(t$1, n$6);
	}
	setHMACKey(t$1, n$6, e$1) {
		this.P.setHMACKey(t$1, n$6, e$1);
	}
	getHMAC(t$1, n$6) {
		return this.P.getHMAC(t$1, n$6);
	}
};
var require_crypt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
			rotl: function(n$6, b$5) {
				return n$6 << b$5 | n$6 >>> 32 - b$5;
			},
			rotr: function(n$6, b$5) {
				return n$6 << 32 - b$5 | n$6 >>> b$5;
			},
			endian: function(n$6) {
				if (n$6.constructor == Number) return crypt.rotl(n$6, 8) & 16711935 | crypt.rotl(n$6, 24) & 4278255360;
				for (var i$2 = 0; i$2 < n$6.length; i$2++) n$6[i$2] = crypt.endian(n$6[i$2]);
				return n$6;
			},
			randomBytes: function(n$6) {
				for (var bytes = []; n$6 > 0; n$6--) bytes.push(Math.floor(Math.random() * 256));
				return bytes;
			},
			bytesToWords: function(bytes) {
				for (var words = [], i$2 = 0, b$5 = 0; i$2 < bytes.length; i$2++, b$5 += 8) words[b$5 >>> 5] |= bytes[i$2] << 24 - b$5 % 32;
				return words;
			},
			wordsToBytes: function(words) {
				for (var bytes = [], b$5 = 0; b$5 < words.length * 32; b$5 += 8) bytes.push(words[b$5 >>> 5] >>> 24 - b$5 % 32 & 255);
				return bytes;
			},
			bytesToHex: function(bytes) {
				for (var hex = [], i$2 = 0; i$2 < bytes.length; i$2++) {
					hex.push((bytes[i$2] >>> 4).toString(16));
					hex.push((bytes[i$2] & 15).toString(16));
				}
				return hex.join("");
			},
			hexToBytes: function(hex) {
				for (var bytes = [], c$1 = 0; c$1 < hex.length; c$1 += 2) bytes.push(parseInt(hex.substr(c$1, 2), 16));
				return bytes;
			},
			bytesToBase64: function(bytes) {
				for (var base64$2 = [], i$2 = 0; i$2 < bytes.length; i$2 += 3) {
					var triplet = bytes[i$2] << 16 | bytes[i$2 + 1] << 8 | bytes[i$2 + 2];
					for (var j$1 = 0; j$1 < 4; j$1++) if (i$2 * 8 + j$1 * 6 <= bytes.length * 8) base64$2.push(base64map.charAt(triplet >>> 6 * (3 - j$1) & 63));
					else base64$2.push("=");
				}
				return base64$2.join("");
			},
			base64ToBytes: function(base64$2) {
				base64$2 = base64$2.replace(/[^A-Z0-9+\/]/gi, "");
				for (var bytes = [], i$2 = 0, imod4 = 0; i$2 < base64$2.length; imod4 = ++i$2 % 4) {
					if (imod4 == 0) continue;
					bytes.push((base64map.indexOf(base64$2.charAt(i$2 - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64$2.charAt(i$2)) >>> 6 - imod4 * 2);
				}
				return bytes;
			}
		};
		module.exports = crypt;
	})();
}));
var require_charenc = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var charenc = {
		utf8: {
			stringToBytes: function(str) {
				return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
			},
			bytesToString: function(bytes) {
				return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
			}
		},
		bin: {
			stringToBytes: function(str) {
				for (var bytes = [], i$2 = 0; i$2 < str.length; i$2++) bytes.push(str.charCodeAt(i$2) & 255);
				return bytes;
			},
			bytesToString: function(bytes) {
				for (var str = [], i$2 = 0; i$2 < bytes.length; i$2++) str.push(String.fromCharCode(bytes[i$2]));
				return str.join("");
			}
		}
	};
	module.exports = charenc;
}));
var require_is_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* Determine if an object is a Buffer
	*
	* @author   Feross Aboukhadijeh <https://feross.org>
	* @license  MIT
	*/
	module.exports = function(obj) {
		return obj != null && (isBuffer$1(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
	};
	function isBuffer$1(obj) {
		return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
	}
	function isSlowBuffer(obj) {
		return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer$1(obj.slice(0, 0));
	}
}));
var require_md5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer$3 = require_is_buffer(), bin = require_charenc().bin, md5 = function(message, options) {
			if (message.constructor == String) if (options && options.encoding === "binary") message = bin.stringToBytes(message);
			else message = utf8.stringToBytes(message);
			else if (isBuffer$3(message)) message = Array.prototype.slice.call(message, 0);
			else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
			var m$1 = crypt.bytesToWords(message), l$2 = message.length * 8, a$1 = 1732584193, b$5 = -271733879, c$1 = -1732584194, d$1 = 271733878;
			for (var i$2 = 0; i$2 < m$1.length; i$2++) m$1[i$2] = (m$1[i$2] << 8 | m$1[i$2] >>> 24) & 16711935 | (m$1[i$2] << 24 | m$1[i$2] >>> 8) & 4278255360;
			m$1[l$2 >>> 5] |= 128 << l$2 % 32;
			m$1[(l$2 + 64 >>> 9 << 4) + 14] = l$2;
			var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
			for (var i$2 = 0; i$2 < m$1.length; i$2 += 16) {
				var aa = a$1, bb = b$5, cc = c$1, dd = d$1;
				a$1 = FF(a$1, b$5, c$1, d$1, m$1[i$2 + 0], 7, -680876936);
				d$1 = FF(d$1, a$1, b$5, c$1, m$1[i$2 + 1], 12, -389564586);
				c$1 = FF(c$1, d$1, a$1, b$5, m$1[i$2 + 2], 17, 606105819);
				b$5 = FF(b$5, c$1, d$1, a$1, m$1[i$2 + 3], 22, -1044525330);
				a$1 = FF(a$1, b$5, c$1, d$1, m$1[i$2 + 4], 7, -176418897);
				d$1 = FF(d$1, a$1, b$5, c$1, m$1[i$2 + 5], 12, 1200080426);
				c$1 = FF(c$1, d$1, a$1, b$5, m$1[i$2 + 6], 17, -1473231341);
				b$5 = FF(b$5, c$1, d$1, a$1, m$1[i$2 + 7], 22, -45705983);
				a$1 = FF(a$1, b$5, c$1, d$1, m$1[i$2 + 8], 7, 1770035416);
				d$1 = FF(d$1, a$1, b$5, c$1, m$1[i$2 + 9], 12, -1958414417);
				c$1 = FF(c$1, d$1, a$1, b$5, m$1[i$2 + 10], 17, -42063);
				b$5 = FF(b$5, c$1, d$1, a$1, m$1[i$2 + 11], 22, -1990404162);
				a$1 = FF(a$1, b$5, c$1, d$1, m$1[i$2 + 12], 7, 1804603682);
				d$1 = FF(d$1, a$1, b$5, c$1, m$1[i$2 + 13], 12, -40341101);
				c$1 = FF(c$1, d$1, a$1, b$5, m$1[i$2 + 14], 17, -1502002290);
				b$5 = FF(b$5, c$1, d$1, a$1, m$1[i$2 + 15], 22, 1236535329);
				a$1 = GG(a$1, b$5, c$1, d$1, m$1[i$2 + 1], 5, -165796510);
				d$1 = GG(d$1, a$1, b$5, c$1, m$1[i$2 + 6], 9, -1069501632);
				c$1 = GG(c$1, d$1, a$1, b$5, m$1[i$2 + 11], 14, 643717713);
				b$5 = GG(b$5, c$1, d$1, a$1, m$1[i$2 + 0], 20, -373897302);
				a$1 = GG(a$1, b$5, c$1, d$1, m$1[i$2 + 5], 5, -701558691);
				d$1 = GG(d$1, a$1, b$5, c$1, m$1[i$2 + 10], 9, 38016083);
				c$1 = GG(c$1, d$1, a$1, b$5, m$1[i$2 + 15], 14, -660478335);
				b$5 = GG(b$5, c$1, d$1, a$1, m$1[i$2 + 4], 20, -405537848);
				a$1 = GG(a$1, b$5, c$1, d$1, m$1[i$2 + 9], 5, 568446438);
				d$1 = GG(d$1, a$1, b$5, c$1, m$1[i$2 + 14], 9, -1019803690);
				c$1 = GG(c$1, d$1, a$1, b$5, m$1[i$2 + 3], 14, -187363961);
				b$5 = GG(b$5, c$1, d$1, a$1, m$1[i$2 + 8], 20, 1163531501);
				a$1 = GG(a$1, b$5, c$1, d$1, m$1[i$2 + 13], 5, -1444681467);
				d$1 = GG(d$1, a$1, b$5, c$1, m$1[i$2 + 2], 9, -51403784);
				c$1 = GG(c$1, d$1, a$1, b$5, m$1[i$2 + 7], 14, 1735328473);
				b$5 = GG(b$5, c$1, d$1, a$1, m$1[i$2 + 12], 20, -1926607734);
				a$1 = HH(a$1, b$5, c$1, d$1, m$1[i$2 + 5], 4, -378558);
				d$1 = HH(d$1, a$1, b$5, c$1, m$1[i$2 + 8], 11, -2022574463);
				c$1 = HH(c$1, d$1, a$1, b$5, m$1[i$2 + 11], 16, 1839030562);
				b$5 = HH(b$5, c$1, d$1, a$1, m$1[i$2 + 14], 23, -35309556);
				a$1 = HH(a$1, b$5, c$1, d$1, m$1[i$2 + 1], 4, -1530992060);
				d$1 = HH(d$1, a$1, b$5, c$1, m$1[i$2 + 4], 11, 1272893353);
				c$1 = HH(c$1, d$1, a$1, b$5, m$1[i$2 + 7], 16, -155497632);
				b$5 = HH(b$5, c$1, d$1, a$1, m$1[i$2 + 10], 23, -1094730640);
				a$1 = HH(a$1, b$5, c$1, d$1, m$1[i$2 + 13], 4, 681279174);
				d$1 = HH(d$1, a$1, b$5, c$1, m$1[i$2 + 0], 11, -358537222);
				c$1 = HH(c$1, d$1, a$1, b$5, m$1[i$2 + 3], 16, -722521979);
				b$5 = HH(b$5, c$1, d$1, a$1, m$1[i$2 + 6], 23, 76029189);
				a$1 = HH(a$1, b$5, c$1, d$1, m$1[i$2 + 9], 4, -640364487);
				d$1 = HH(d$1, a$1, b$5, c$1, m$1[i$2 + 12], 11, -421815835);
				c$1 = HH(c$1, d$1, a$1, b$5, m$1[i$2 + 15], 16, 530742520);
				b$5 = HH(b$5, c$1, d$1, a$1, m$1[i$2 + 2], 23, -995338651);
				a$1 = II(a$1, b$5, c$1, d$1, m$1[i$2 + 0], 6, -198630844);
				d$1 = II(d$1, a$1, b$5, c$1, m$1[i$2 + 7], 10, 1126891415);
				c$1 = II(c$1, d$1, a$1, b$5, m$1[i$2 + 14], 15, -1416354905);
				b$5 = II(b$5, c$1, d$1, a$1, m$1[i$2 + 5], 21, -57434055);
				a$1 = II(a$1, b$5, c$1, d$1, m$1[i$2 + 12], 6, 1700485571);
				d$1 = II(d$1, a$1, b$5, c$1, m$1[i$2 + 3], 10, -1894986606);
				c$1 = II(c$1, d$1, a$1, b$5, m$1[i$2 + 10], 15, -1051523);
				b$5 = II(b$5, c$1, d$1, a$1, m$1[i$2 + 1], 21, -2054922799);
				a$1 = II(a$1, b$5, c$1, d$1, m$1[i$2 + 8], 6, 1873313359);
				d$1 = II(d$1, a$1, b$5, c$1, m$1[i$2 + 15], 10, -30611744);
				c$1 = II(c$1, d$1, a$1, b$5, m$1[i$2 + 6], 15, -1560198380);
				b$5 = II(b$5, c$1, d$1, a$1, m$1[i$2 + 13], 21, 1309151649);
				a$1 = II(a$1, b$5, c$1, d$1, m$1[i$2 + 4], 6, -145523070);
				d$1 = II(d$1, a$1, b$5, c$1, m$1[i$2 + 11], 10, -1120210379);
				c$1 = II(c$1, d$1, a$1, b$5, m$1[i$2 + 2], 15, 718787259);
				b$5 = II(b$5, c$1, d$1, a$1, m$1[i$2 + 9], 21, -343485551);
				a$1 = a$1 + aa >>> 0;
				b$5 = b$5 + bb >>> 0;
				c$1 = c$1 + cc >>> 0;
				d$1 = d$1 + dd >>> 0;
			}
			return crypt.endian([
				a$1,
				b$5,
				c$1,
				d$1
			]);
		};
		md5._ff = function(a$1, b$5, c$1, d$1, x$1, s$2, t$1) {
			var n$6 = a$1 + (b$5 & c$1 | ~b$5 & d$1) + (x$1 >>> 0) + t$1;
			return (n$6 << s$2 | n$6 >>> 32 - s$2) + b$5;
		};
		md5._gg = function(a$1, b$5, c$1, d$1, x$1, s$2, t$1) {
			var n$6 = a$1 + (b$5 & d$1 | c$1 & ~d$1) + (x$1 >>> 0) + t$1;
			return (n$6 << s$2 | n$6 >>> 32 - s$2) + b$5;
		};
		md5._hh = function(a$1, b$5, c$1, d$1, x$1, s$2, t$1) {
			var n$6 = a$1 + (b$5 ^ c$1 ^ d$1) + (x$1 >>> 0) + t$1;
			return (n$6 << s$2 | n$6 >>> 32 - s$2) + b$5;
		};
		md5._ii = function(a$1, b$5, c$1, d$1, x$1, s$2, t$1) {
			var n$6 = a$1 + (c$1 ^ (b$5 | ~d$1)) + (x$1 >>> 0) + t$1;
			return (n$6 << s$2 | n$6 >>> 32 - s$2) + b$5;
		};
		md5._blocksize = 16;
		md5._digestsize = 16;
		module.exports = function(message, options) {
			if (message === void 0 || message === null) throw new Error("Illegal argument " + message);
			var digestbytes = crypt.wordsToBytes(md5(message, options));
			return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
		};
	})();
}));
var SMALL_WORDS = /\b(?:an?d?|a[st]|because|but|by|en|for|i[fn]|neither|nor|o[fnr]|only|over|per|so|some|tha[tn]|the|to|up|upon|vs?\.?|versus|via|when|with|without|yet)\b/i;
var TOKENS = /[^\s:–—-]+|./g;
var WHITESPACE = /\s/;
var IS_MANUAL_CASE = /.(?=[A-Z]|\..)/;
var ALPHANUMERIC_PATTERN = /[A-Za-z0-9\u00C0-\u00FF]/;
function titleCase(input) {
	var result = "";
	var m$1;
	while ((m$1 = TOKENS.exec(input)) !== null) {
		var token = m$1[0], index = m$1.index;
		if (!IS_MANUAL_CASE.test(token) && (!SMALL_WORDS.test(token) || index === 0 || index + token.length === input.length) && (input.charAt(index + token.length) !== ":" || WHITESPACE.test(input.charAt(index + token.length + 1)))) {
			result += token.replace(ALPHANUMERIC_PATTERN, function(m$2) {
				return m$2.toUpperCase();
			});
			continue;
		}
		result += token;
	}
	return result;
}
var require_bundle_umd_min = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	init_dist();
	(function(n$6, a$1) {
		"object" == typeof exports && "undefined" != typeof module ? a$1(exports) : "function" == typeof define && define.amd ? define(["exports"], a$1) : a$1((n$6 = "undefined" != typeof globalThis ? globalThis : n$6 || self).window = n$6.window || {});
	})(exports, (function(n$6) {
		function a$1(n$7, a$2) {
			for (var i$3 = 0; i$3 < a$2.length; i$3++) {
				var e$2 = a$2[i$3];
				e$2.enumerable = e$2.enumerable || !1, e$2.configurable = !0, "value" in e$2 && (e$2.writable = !0), Object.defineProperty(n$7, e$2.key, e$2);
			}
		}
		function i$2(n$7, i$3, e$2) {
			return i$3 && a$1(n$7.prototype, i$3), e$2 && a$1(n$7, e$2), Object.defineProperty(n$7, "prototype", { writable: !1 }), n$7;
		}
		function e$1(n$7, a$2) {
			return (e$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n$8, a$3) {
				return n$8.__proto__ = a$3, n$8;
			})(n$7, a$2);
		}
		function u$1(n$7, a$2) {
			if (n$7 !== a$2) throw new TypeError("Cannot instantiate an arrow function");
		}
		var o$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
		function g$3(n$7, a$2) {
			return n$7(a$2 = { exports: {} }, a$2.exports), a$2.exports;
		}
		var h$1, s$2, y$1 = function(n$7) {
			return n$7 && n$7.Math == Math && n$7;
		}, l$2 = y$1("object" == typeof globalThis && globalThis) || y$1("object" == typeof window && window) || y$1("object" == typeof self && self) || y$1("object" == typeof o$1 && o$1) || function() {
			return this;
		}() || Function("return this")(), t$1 = function(n$7) {
			try {
				return !!n$7();
			} catch (n$8) {
				return !0;
			}
		}, b$5 = !t$1((function() {
			return 7 != Object.defineProperty({}, 1, { get: function() {
				return 7;
			} })[1];
		})), w$1 = !t$1((function() {
			var n$7 = function() {}.bind();
			return "function" != typeof n$7 || n$7.hasOwnProperty("prototype");
		})), d$1 = Function.prototype.call, j$1 = w$1 ? d$1.bind(d$1) : function() {
			return d$1.apply(d$1, arguments);
		}, r$1 = {}.propertyIsEnumerable, p$1 = Object.getOwnPropertyDescriptor, Y$1 = { f: p$1 && !r$1.call({ 1: 2 }, 1) ? function(n$7) {
			var a$2 = p$1(this, n$7);
			return !!a$2 && a$2.enumerable;
		} : r$1 }, c$1 = function(n$7, a$2) {
			return {
				enumerable: !(1 & n$7),
				configurable: !(2 & n$7),
				writable: !(4 & n$7),
				value: a$2
			};
		}, m$1 = Function.prototype, Z$1 = m$1.bind, L$1 = m$1.call, J$1 = w$1 && Z$1.bind(L$1, L$1), S$1 = w$1 ? function(n$7) {
			return n$7 && J$1(n$7);
		} : function(n$7) {
			return n$7 && function() {
				return L$1.apply(n$7, arguments);
			};
		}, C$1 = S$1({}.toString), k$1 = S$1("".slice), X$1 = function(n$7) {
			return k$1(C$1(n$7), 8, -1);
		}, D$1 = Object, H$1 = S$1("".split), T$1 = t$1((function() {
			return !D$1("z").propertyIsEnumerable(0);
		})) ? function(n$7) {
			return "String" == X$1(n$7) ? H$1(n$7, "") : D$1(n$7);
		} : D$1, Q$1 = TypeError, B$1 = function(n$7) {
			if (null == n$7) throw Q$1("Can't call method on " + n$7);
			return n$7;
		}, M$1 = function(n$7) {
			return T$1(B$1(n$7));
		}, G$1 = function(n$7) {
			return "function" == typeof n$7;
		}, F$1 = function(n$7) {
			return "object" == typeof n$7 ? null !== n$7 : G$1(n$7);
		}, P$1 = function(n$7) {
			return G$1(n$7) ? n$7 : void 0;
		}, N$1 = function(n$7, a$2) {
			return arguments.length < 2 ? P$1(l$2[n$7]) : l$2[n$7] && l$2[n$7][a$2];
		}, f$1 = S$1({}.isPrototypeOf), W$1 = N$1("navigator", "userAgent") || "", K$1 = l$2.process, x$1 = l$2.Deno, R$2 = K$1 && K$1.versions || x$1 && x$1.version, E$1 = R$2 && R$2.v8;
		E$1 && (s$2 = (h$1 = E$1.split("."))[0] > 0 && h$1[0] < 4 ? 1 : +(h$1[0] + h$1[1])), !s$2 && W$1 && (!(h$1 = W$1.match(/Edge\/(\d+)/)) || h$1[1] >= 74) && (h$1 = W$1.match(/Chrome\/(\d+)/)) && (s$2 = +h$1[1]);
		var A$1 = s$2, v$3 = !!Object.getOwnPropertySymbols && !t$1((function() {
			var n$7 = Symbol();
			return !String(n$7) || !(Object(n$7) instanceof Symbol) || !Symbol.sham && A$1 && A$1 < 41;
		})), z$1 = v$3 && !Symbol.sham && "symbol" == typeof Symbol.iterator, O$1 = Object, I$1 = z$1 ? function(n$7) {
			return "symbol" == typeof n$7;
		} : function(n$7) {
			var a$2 = N$1("Symbol");
			return G$1(a$2) && f$1(a$2.prototype, O$1(n$7));
		}, U$1 = String, q$1 = function(n$7) {
			try {
				return U$1(n$7);
			} catch (n$8) {
				return "Object";
			}
		}, V$1 = TypeError, _$1 = function(n$7) {
			if (G$1(n$7)) return n$7;
			throw V$1(q$1(n$7) + " is not a function");
		}, $$1 = function(n$7, a$2) {
			var i$3 = n$7[a$2];
			return null == i$3 ? void 0 : _$1(i$3);
		}, nn = TypeError, an = Object.defineProperty, en = function(n$7, a$2) {
			try {
				an(l$2, n$7, {
					value: a$2,
					configurable: !0,
					writable: !0
				});
			} catch (i$3) {
				l$2[n$7] = a$2;
			}
			return a$2;
		}, un = l$2["__core-js_shared__"] || en("__core-js_shared__", {}), on = g$3((function(n$7) {
			(n$7.exports = function(n$8, a$2) {
				return un[n$8] || (un[n$8] = void 0 !== a$2 ? a$2 : {});
			})("versions", []).push({
				version: "3.23.3",
				mode: "global",
				copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)",
				license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
				source: "https://github.com/zloirock/core-js"
			});
		})), gn = Object, hn = function(n$7) {
			return gn(B$1(n$7));
		}, sn = S$1({}.hasOwnProperty), yn = Object.hasOwn || function(n$7, a$2) {
			return sn(hn(n$7), a$2);
		}, ln = 0, tn = Math.random(), bn = S$1(1 .toString), wn = function(n$7) {
			return "Symbol(" + (void 0 === n$7 ? "" : n$7) + ")_" + bn(++ln + tn, 36);
		}, dn = on("wks"), jn = l$2.Symbol, rn = jn && jn.for, pn = z$1 ? jn : jn && jn.withoutSetter || wn, Yn = function(n$7) {
			if (!yn(dn, n$7) || !v$3 && "string" != typeof dn[n$7]) {
				var a$2 = "Symbol." + n$7;
				v$3 && yn(jn, n$7) ? dn[n$7] = jn[n$7] : dn[n$7] = z$1 && rn ? rn(a$2) : pn(a$2);
			}
			return dn[n$7];
		}, cn = TypeError, mn = Yn("toPrimitive"), Zn = function(n$7, a$2) {
			if (!F$1(n$7) || I$1(n$7)) return n$7;
			var i$3, e$2 = $$1(n$7, mn);
			if (e$2) {
				if (void 0 === a$2 && (a$2 = "default"), i$3 = j$1(e$2, n$7, a$2), !F$1(i$3) || I$1(i$3)) return i$3;
				throw cn("Can't convert object to primitive value");
			}
			return void 0 === a$2 && (a$2 = "number"), function(n$8, a$3) {
				var i$4, e$3;
				if ("string" === a$3 && G$1(i$4 = n$8.toString) && !F$1(e$3 = j$1(i$4, n$8))) return e$3;
				if (G$1(i$4 = n$8.valueOf) && !F$1(e$3 = j$1(i$4, n$8))) return e$3;
				if ("string" !== a$3 && G$1(i$4 = n$8.toString) && !F$1(e$3 = j$1(i$4, n$8))) return e$3;
				throw nn("Can't convert object to primitive value");
			}(n$7, a$2);
		}, Ln = function(n$7) {
			var a$2 = Zn(n$7, "string");
			return I$1(a$2) ? a$2 : a$2 + "";
		}, Jn = l$2.document, Sn = F$1(Jn) && F$1(Jn.createElement), Cn = function(n$7) {
			return Sn ? Jn.createElement(n$7) : {};
		}, kn = !b$5 && !t$1((function() {
			return 7 != Object.defineProperty(Cn("div"), "a", { get: function() {
				return 7;
			} }).a;
		})), Xn = Object.getOwnPropertyDescriptor, Dn = { f: b$5 ? Xn : function(n$7, a$2) {
			if (n$7 = M$1(n$7), a$2 = Ln(a$2), kn) try {
				return Xn(n$7, a$2);
			} catch (n$8) {}
			if (yn(n$7, a$2)) return c$1(!j$1(Y$1.f, n$7, a$2), n$7[a$2]);
		} }, Hn = b$5 && t$1((function() {
			return 42 != Object.defineProperty((function() {}), "prototype", {
				value: 42,
				writable: !1
			}).prototype;
		})), Tn = String, Qn = TypeError, Bn = function(n$7) {
			if (F$1(n$7)) return n$7;
			throw Qn(Tn(n$7) + " is not an object");
		}, Mn = TypeError, Gn = Object.defineProperty, Fn = Object.getOwnPropertyDescriptor, Pn = { f: b$5 ? Hn ? function(n$7, a$2, i$3) {
			if (Bn(n$7), a$2 = Ln(a$2), Bn(i$3), "function" == typeof n$7 && "prototype" === a$2 && "value" in i$3 && "writable" in i$3 && !i$3.writable) {
				var e$2 = Fn(n$7, a$2);
				e$2 && e$2.writable && (n$7[a$2] = i$3.value, i$3 = {
					configurable: "configurable" in i$3 ? i$3.configurable : e$2.configurable,
					enumerable: "enumerable" in i$3 ? i$3.enumerable : e$2.enumerable,
					writable: !1
				});
			}
			return Gn(n$7, a$2, i$3);
		} : Gn : function(n$7, a$2, i$3) {
			if (Bn(n$7), a$2 = Ln(a$2), Bn(i$3), kn) try {
				return Gn(n$7, a$2, i$3);
			} catch (n$8) {}
			if ("get" in i$3 || "set" in i$3) throw Mn("Accessors not supported");
			return "value" in i$3 && (n$7[a$2] = i$3.value), n$7;
		} }, Nn = b$5 ? function(n$7, a$2, i$3) {
			return Pn.f(n$7, a$2, c$1(1, i$3));
		} : function(n$7, a$2, i$3) {
			return n$7[a$2] = i$3, n$7;
		}, fn$1 = Function.prototype, Wn = b$5 && Object.getOwnPropertyDescriptor, Kn = yn(fn$1, "name"), xn = {
			EXISTS: Kn,
			PROPER: Kn && "something" === function() {}.name,
			CONFIGURABLE: Kn && (!b$5 || b$5 && Wn(fn$1, "name").configurable)
		}, Rn = S$1(Function.toString);
		G$1(un.inspectSource) || (un.inspectSource = function(n$7) {
			return Rn(n$7);
		});
		var En, An, vn, zn = un.inspectSource, On = l$2.WeakMap, In = G$1(On) && /native code/.test(zn(On)), Un = on("keys"), qn = function(n$7) {
			return Un[n$7] || (Un[n$7] = wn(n$7));
		}, Vn = {}, _n = l$2.TypeError, $n = l$2.WeakMap;
		if (In || un.state) {
			var na = un.state || (un.state = new $n()), aa = S$1(na.get), ia = S$1(na.has), ea = S$1(na.set);
			En = function(n$7, a$2) {
				if (ia(na, n$7)) throw new _n("Object already initialized");
				return a$2.facade = n$7, ea(na, n$7, a$2), a$2;
			}, An = function(n$7) {
				return aa(na, n$7) || {};
			}, vn = function(n$7) {
				return ia(na, n$7);
			};
		} else {
			var ua = qn("state");
			Vn[ua] = !0, En = function(n$7, a$2) {
				if (yn(n$7, ua)) throw new _n("Object already initialized");
				return a$2.facade = n$7, Nn(n$7, ua, a$2), a$2;
			}, An = function(n$7) {
				return yn(n$7, ua) ? n$7[ua] : {};
			}, vn = function(n$7) {
				return yn(n$7, ua);
			};
		}
		var oa = {
			set: En,
			get: An,
			has: vn,
			enforce: function(n$7) {
				return vn(n$7) ? An(n$7) : En(n$7, {});
			},
			getterFor: function(n$7) {
				return function(a$2) {
					var i$3;
					if (!F$1(a$2) || (i$3 = An(a$2)).type !== n$7) throw _n("Incompatible receiver, " + n$7 + " required");
					return i$3;
				};
			}
		}, ga = g$3((function(n$7) {
			var a$2 = xn.CONFIGURABLE, i$3 = oa.enforce, e$2 = oa.get, u$2 = Object.defineProperty, o$2 = b$5 && !t$1((function() {
				return 8 !== u$2((function() {}), "length", { value: 8 }).length;
			})), g$4 = String(String).split("String"), h$2 = n$7.exports = function(n$8, e$3, h$3) {
				"Symbol(" === String(e$3).slice(0, 7) && (e$3 = "[" + String(e$3).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), h$3 && h$3.getter && (e$3 = "get " + e$3), h$3 && h$3.setter && (e$3 = "set " + e$3), (!yn(n$8, "name") || a$2 && n$8.name !== e$3) && (b$5 ? u$2(n$8, "name", {
					value: e$3,
					configurable: !0
				}) : n$8.name = e$3), o$2 && h$3 && yn(h$3, "arity") && n$8.length !== h$3.arity && u$2(n$8, "length", { value: h$3.arity });
				try {
					h$3 && yn(h$3, "constructor") && h$3.constructor ? b$5 && u$2(n$8, "prototype", { writable: !1 }) : n$8.prototype && (n$8.prototype = void 0);
				} catch (n$9) {}
				var s$3 = i$3(n$8);
				return yn(s$3, "source") || (s$3.source = g$4.join("string" == typeof e$3 ? e$3 : "")), n$8;
			};
			Function.prototype.toString = h$2((function() {
				return G$1(this) && e$2(this).source || zn(this);
			}), "toString");
		})), ha = function(n$7, a$2, i$3, e$2) {
			e$2 || (e$2 = {});
			var u$2 = e$2.enumerable, o$2 = void 0 !== e$2.name ? e$2.name : a$2;
			if (G$1(i$3) && ga(i$3, o$2, e$2), e$2.global) u$2 ? n$7[a$2] = i$3 : en(a$2, i$3);
			else {
				try {
					e$2.unsafe ? n$7[a$2] && (u$2 = !0) : delete n$7[a$2];
				} catch (n$8) {}
				u$2 ? n$7[a$2] = i$3 : Pn.f(n$7, a$2, {
					value: i$3,
					enumerable: !1,
					configurable: !e$2.nonConfigurable,
					writable: !e$2.nonWritable
				});
			}
			return n$7;
		}, sa = Math.ceil, ya = Math.floor, la = Math.trunc || function(n$7) {
			var a$2 = +n$7;
			return (a$2 > 0 ? ya : sa)(a$2);
		}, ta = function(n$7) {
			var a$2 = +n$7;
			return a$2 != a$2 || 0 === a$2 ? 0 : la(a$2);
		}, ba = Math.max, wa = Math.min, da = function(n$7, a$2) {
			var i$3 = ta(n$7);
			return i$3 < 0 ? ba(i$3 + a$2, 0) : wa(i$3, a$2);
		}, ja = Math.min, ra = function(n$7) {
			return n$7 > 0 ? ja(ta(n$7), 9007199254740991) : 0;
		}, pa = function(n$7) {
			return ra(n$7.length);
		}, Ya = function(n$7) {
			return function(a$2, i$3, e$2) {
				var u$2, o$2 = M$1(a$2), g$4 = pa(o$2), h$2 = da(e$2, g$4);
				if (n$7 && i$3 != i$3) {
					for (; g$4 > h$2;) if ((u$2 = o$2[h$2++]) != u$2) return !0;
				} else for (; g$4 > h$2; h$2++) if ((n$7 || h$2 in o$2) && o$2[h$2] === i$3) return n$7 || h$2 || 0;
				return !n$7 && -1;
			};
		}, ca = {
			includes: Ya(!0),
			indexOf: Ya(!1)
		}, ma = ca.indexOf, Za = S$1([].push), La = function(n$7, a$2) {
			var i$3, e$2 = M$1(n$7), u$2 = 0, o$2 = [];
			for (i$3 in e$2) !yn(Vn, i$3) && yn(e$2, i$3) && Za(o$2, i$3);
			for (; a$2.length > u$2;) yn(e$2, i$3 = a$2[u$2++]) && (~ma(o$2, i$3) || Za(o$2, i$3));
			return o$2;
		}, Ja = [
			"constructor",
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"toLocaleString",
			"toString",
			"valueOf"
		], Sa = Ja.concat("length", "prototype"), Ca = { f: Object.getOwnPropertyNames || function(n$7) {
			return La(n$7, Sa);
		} }, ka = { f: Object.getOwnPropertySymbols }, Xa = S$1([].concat), Da = N$1("Reflect", "ownKeys") || function(n$7) {
			var a$2 = Ca.f(Bn(n$7)), i$3 = ka.f;
			return i$3 ? Xa(a$2, i$3(n$7)) : a$2;
		}, Ha = function(n$7, a$2, i$3) {
			for (var e$2 = Da(a$2), u$2 = Pn.f, o$2 = Dn.f, g$4 = 0; g$4 < e$2.length; g$4++) {
				var h$2 = e$2[g$4];
				yn(n$7, h$2) || i$3 && yn(i$3, h$2) || u$2(n$7, h$2, o$2(a$2, h$2));
			}
		}, Ta = /#|\.prototype\./, Qa = function(n$7, a$2) {
			var i$3 = Ma[Ba(n$7)];
			return i$3 == Fa || i$3 != Ga && (G$1(a$2) ? t$1(a$2) : !!a$2);
		}, Ba = Qa.normalize = function(n$7) {
			return String(n$7).replace(Ta, ".").toLowerCase();
		}, Ma = Qa.data = {}, Ga = Qa.NATIVE = "N", Fa = Qa.POLYFILL = "P", Pa = Qa, Na = Dn.f, fa = function(n$7, a$2) {
			var i$3, e$2, u$2, o$2, g$4, h$2 = n$7.target, s$3 = n$7.global, y$2 = n$7.stat;
			if (i$3 = s$3 ? l$2 : y$2 ? l$2[h$2] || en(h$2, {}) : (l$2[h$2] || {}).prototype) for (e$2 in a$2) {
				if (o$2 = a$2[e$2], u$2 = n$7.dontCallGetSet ? (g$4 = Na(i$3, e$2)) && g$4.value : i$3[e$2], !Pa(s$3 ? e$2 : h$2 + (y$2 ? "." : "#") + e$2, n$7.forced) && void 0 !== u$2) {
					if (typeof o$2 == typeof u$2) continue;
					Ha(o$2, u$2);
				}
				(n$7.sham || u$2 && u$2.sham) && Nn(o$2, "sham", !0), ha(i$3, e$2, o$2, n$7);
			}
		}, Wa = Object.keys || function(n$7) {
			return La(n$7, Ja);
		}, Ka = Object.assign, xa = Object.defineProperty, Ra = S$1([].concat), Ea = !Ka || t$1((function() {
			if (b$5 && 1 !== Ka({ b: 1 }, Ka(xa({}, "a", {
				enumerable: !0,
				get: function() {
					xa(this, "b", {
						value: 3,
						enumerable: !1
					});
				}
			}), { b: 2 })).b) return !0;
			var n$7 = {}, a$2 = {}, i$3 = Symbol();
			return n$7[i$3] = 7, "abcdefghijklmnopqrst".split("").forEach((function(n$8) {
				a$2[n$8] = n$8;
			})), 7 != Ka({}, n$7)[i$3] || "abcdefghijklmnopqrst" != Wa(Ka({}, a$2)).join("");
		})) ? function(n$7, a$2) {
			for (var i$3 = hn(n$7), e$2 = arguments.length, u$2 = 1, o$2 = ka.f, g$4 = Y$1.f; e$2 > u$2;) for (var h$2, s$3 = T$1(arguments[u$2++]), y$2 = o$2 ? Ra(Wa(s$3), o$2(s$3)) : Wa(s$3), l$3 = y$2.length, t$2 = 0; l$3 > t$2;) h$2 = y$2[t$2++], b$5 && !j$1(g$4, s$3, h$2) || (i$3[h$2] = s$3[h$2]);
			return i$3;
		} : Ka;
		fa({
			target: "Object",
			stat: !0,
			arity: 2,
			forced: Object.assign !== Ea
		}, { assign: Ea });
		var Aa = String, va = TypeError, za = Object.setPrototypeOf || ("__proto__" in {} ? function() {
			var n$7, a$2 = !1, i$3 = {};
			try {
				(n$7 = S$1(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i$3, []), a$2 = i$3 instanceof Array;
			} catch (n$8) {}
			return function(i$4, e$2) {
				return Bn(i$4), function(n$8) {
					if ("object" == typeof n$8 || G$1(n$8)) return n$8;
					throw va("Can't set " + Aa(n$8) + " as a prototype");
				}(e$2), a$2 ? n$7(i$4, e$2) : i$4.__proto__ = e$2, i$4;
			};
		}() : void 0), Oa = Yn("match"), Ia = {};
		Ia[Yn("toStringTag")] = "z";
		var Ua = "[object z]" === String(Ia), qa = Yn("toStringTag"), Va = Object, _a$2 = "Arguments" == X$1(function() {
			return arguments;
		}()), $a = Ua ? X$1 : function(n$7) {
			var a$2, i$3, e$2;
			return void 0 === n$7 ? "Undefined" : null === n$7 ? "Null" : "string" == typeof (i$3 = function(n$8, a$3) {
				try {
					return n$8[a$3];
				} catch (n$9) {}
			}(a$2 = Va(n$7), qa)) ? i$3 : _a$2 ? X$1(a$2) : "Object" == (e$2 = X$1(a$2)) && G$1(a$2.callee) ? "Arguments" : e$2;
		}, ni = String, ai = function(n$7) {
			if ("Symbol" === $a(n$7)) throw TypeError("Cannot convert a Symbol value to a string");
			return ni(n$7);
		}, ii = function() {
			var n$7 = Bn(this), a$2 = "";
			return n$7.hasIndices && (a$2 += "d"), n$7.global && (a$2 += "g"), n$7.ignoreCase && (a$2 += "i"), n$7.multiline && (a$2 += "m"), n$7.dotAll && (a$2 += "s"), n$7.unicode && (a$2 += "u"), n$7.unicodeSets && (a$2 += "v"), n$7.sticky && (a$2 += "y"), a$2;
		}, ei = RegExp.prototype, ui = function(n$7) {
			var a$2 = n$7.flags;
			return void 0 !== a$2 || "flags" in ei || yn(n$7, "flags") || !f$1(ei, n$7) ? a$2 : j$1(ii, n$7);
		}, oi = l$2.RegExp, gi = t$1((function() {
			var n$7 = oi("a", "y");
			return n$7.lastIndex = 2, null != n$7.exec("abcd");
		})), hi = gi || t$1((function() {
			return !oi("a", "y").sticky;
		})), si = {
			BROKEN_CARET: gi || t$1((function() {
				var n$7 = oi("^r", "gy");
				return n$7.lastIndex = 2, null != n$7.exec("str");
			})),
			MISSED_STICKY: hi,
			UNSUPPORTED_Y: gi
		}, yi = Pn.f, li = function(n$7, a$2, i$3) {
			i$3 in n$7 || yi(n$7, i$3, {
				configurable: !0,
				get: function() {
					return a$2[i$3];
				},
				set: function(n$8) {
					a$2[i$3] = n$8;
				}
			});
		}, ti = Yn("species"), bi = l$2.RegExp, wi = t$1((function() {
			var n$7 = bi(".", "s");
			return !(n$7.dotAll && n$7.exec("\n") && "s" === n$7.flags);
		})), di = l$2.RegExp, ji = t$1((function() {
			var n$7 = di("(?<a>b)", "g");
			return "b" !== n$7.exec("b").groups.a || "bc" !== "b".replace(n$7, "$<a>c");
		})), ri = Ca.f, pi = oa.enforce, Yi = Yn("match"), ci = l$2.RegExp, mi = ci.prototype, Zi = l$2.SyntaxError, Li = S$1(mi.exec), Ji = S$1("".charAt), Si = S$1("".replace), Ci = S$1("".indexOf), ki = S$1("".slice), Xi = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, Di = /a/g, Hi = /a/g, Ti = new ci(Di) !== Di, Qi = si.MISSED_STICKY, Bi = si.UNSUPPORTED_Y;
		if (Pa("RegExp", b$5 && (!Ti || Qi || wi || ji || t$1((function() {
			return Hi[Yi] = !1, ci(Di) != Di || ci(Hi) == Hi || "/a/i" != ci(Di, "i");
		}))))) {
			for (var Gi = function(n$7, a$2) {
				var i$3, e$2, u$2, o$2, g$4, h$2, s$3, y$2, l$3, t$2, b$6, w$2, d$2, j$2 = f$1(mi, this), r$2 = F$1(i$3 = n$7) && (void 0 !== (e$2 = i$3[Oa]) ? !!e$2 : "RegExp" == X$1(i$3)), p$2 = void 0 === a$2, Y$2 = [], c$2 = n$7;
				if (!j$2 && r$2 && p$2 && n$7.constructor === Gi) return n$7;
				if ((r$2 || f$1(mi, n$7)) && (n$7 = n$7.source, p$2 && (a$2 = ui(c$2))), n$7 = void 0 === n$7 ? "" : ai(n$7), a$2 = void 0 === a$2 ? "" : ai(a$2), c$2 = n$7, wi && "dotAll" in Di && (o$2 = !!a$2 && Ci(a$2, "s") > -1) && (a$2 = Si(a$2, /s/g, "")), u$2 = a$2, Qi && "sticky" in Di && (g$4 = !!a$2 && Ci(a$2, "y") > -1) && Bi && (a$2 = Si(a$2, /y/g, "")), ji && (n$7 = (h$2 = function(n$8) {
					for (var a$3, i$4 = n$8.length, e$3 = 0, u$3 = "", o$3 = [], g$5 = {}, h$3 = !1, s$4 = !1, y$3 = 0, l$4 = ""; e$3 <= i$4; e$3++) {
						if ("\\" === (a$3 = Ji(n$8, e$3))) a$3 += Ji(n$8, ++e$3);
						else if ("]" === a$3) h$3 = !1;
						else if (!h$3) switch (!0) {
							case "[" === a$3:
								h$3 = !0;
								break;
							case "(" === a$3:
								Li(Xi, ki(n$8, e$3 + 1)) && (e$3 += 2, s$4 = !0), u$3 += a$3, y$3++;
								continue;
							case ">" === a$3 && s$4:
								if ("" === l$4 || yn(g$5, l$4)) throw new Zi("Invalid capture group name");
								g$5[l$4] = !0, o$3[o$3.length] = [l$4, y$3], s$4 = !1, l$4 = "";
								continue;
						}
						s$4 ? l$4 += a$3 : u$3 += a$3;
					}
					return [u$3, o$3];
				}(n$7))[0], Y$2 = h$2[1]), l$3 = ci(n$7, a$2), t$2 = j$2 ? this : mi, b$6 = Gi, za && G$1(w$2 = t$2.constructor) && w$2 !== b$6 && F$1(d$2 = w$2.prototype) && d$2 !== b$6.prototype && za(l$3, d$2), s$3 = l$3, (o$2 || g$4 || Y$2.length) && (y$2 = pi(s$3), o$2 && (y$2.dotAll = !0, y$2.raw = Gi(function(n$8) {
					for (var a$3, i$4 = n$8.length, e$3 = 0, u$3 = "", o$3 = !1; e$3 <= i$4; e$3++) "\\" !== (a$3 = Ji(n$8, e$3)) ? o$3 || "." !== a$3 ? ("[" === a$3 ? o$3 = !0 : "]" === a$3 && (o$3 = !1), u$3 += a$3) : u$3 += "[\\s\\S]" : u$3 += a$3 + Ji(n$8, ++e$3);
					return u$3;
				}(n$7), u$2)), g$4 && (y$2.sticky = !0), Y$2.length && (y$2.groups = Y$2)), n$7 !== c$2) try {
					Nn(s$3, "source", "" === c$2 ? "(?:)" : c$2);
				} catch (n$8) {}
				return s$3;
			}, Fi = ri(ci), Pi = 0; Fi.length > Pi;) li(Gi, ci, Fi[Pi++]);
			mi.constructor = Gi, Gi.prototype = mi, ha(l$2, "RegExp", Gi, { constructor: !0 });
		}
		(function(n$7) {
			var a$2 = N$1(n$7), i$3 = Pn.f;
			b$5 && a$2 && !a$2[ti] && i$3(a$2, ti, {
				configurable: !0,
				get: function() {
					return this;
				}
			});
		})("RegExp");
		var Ni, fi = { f: b$5 && !Hn ? Object.defineProperties : function(n$7, a$2) {
			Bn(n$7);
			for (var i$3, e$2 = M$1(a$2), u$2 = Wa(a$2), o$2 = u$2.length, g$4 = 0; o$2 > g$4;) Pn.f(n$7, i$3 = u$2[g$4++], e$2[i$3]);
			return n$7;
		} }, Wi = N$1("document", "documentElement"), Ki = qn("IE_PROTO"), xi = function() {}, Ri = function(n$7) {
			return "<script>" + n$7 + "<\/script>";
		}, Ei = function(n$7) {
			n$7.write(Ri("")), n$7.close();
			var a$2 = n$7.parentWindow.Object;
			return n$7 = null, a$2;
		}, Ai = function() {
			try {
				Ni = new ActiveXObject("htmlfile");
			} catch (n$8) {}
			var n$7, a$2;
			Ai = "undefined" != typeof document ? document.domain && Ni ? Ei(Ni) : ((a$2 = Cn("iframe")).style.display = "none", Wi.appendChild(a$2), a$2.src = String("javascript:"), (n$7 = a$2.contentWindow.document).open(), n$7.write(Ri("document.F=Object")), n$7.close(), n$7.F) : Ei(Ni);
			for (var i$3 = Ja.length; i$3--;) delete Ai.prototype[Ja[i$3]];
			return Ai();
		};
		Vn[Ki] = !0;
		var vi = Object.create || function(n$7, a$2) {
			var i$3;
			return null !== n$7 ? (xi.prototype = Bn(n$7), i$3 = new xi(), xi.prototype = null, i$3[Ki] = n$7) : i$3 = Ai(), void 0 === a$2 ? i$3 : fi.f(i$3, a$2);
		}, zi = oa.get, Oi = on("native-string-replace", String.prototype.replace), Ii = RegExp.prototype.exec, Ui = Ii, qi = S$1("".charAt), Vi = S$1("".indexOf), _i = S$1("".replace), $i = S$1("".slice), ne = function() {
			var n$7 = /a/, a$2 = /b*/g;
			return j$1(Ii, n$7, "a"), j$1(Ii, a$2, "a"), 0 !== n$7.lastIndex || 0 !== a$2.lastIndex;
		}(), ae = si.BROKEN_CARET, ie = void 0 !== /()??/.exec("")[1];
		(ne || ie || ae || wi || ji) && (Ui = function(n$7) {
			var a$2, i$3, e$2, u$2, o$2, g$4, h$2, s$3 = this, y$2 = zi(s$3), l$3 = ai(n$7), t$2 = y$2.raw;
			if (t$2) return t$2.lastIndex = s$3.lastIndex, a$2 = j$1(Ui, t$2, l$3), s$3.lastIndex = t$2.lastIndex, a$2;
			var b$6 = y$2.groups, w$2 = ae && s$3.sticky, d$2 = j$1(ii, s$3), r$2 = s$3.source, p$2 = 0, Y$2 = l$3;
			if (w$2 && (d$2 = _i(d$2, "y", ""), -1 === Vi(d$2, "g") && (d$2 += "g"), Y$2 = $i(l$3, s$3.lastIndex), s$3.lastIndex > 0 && (!s$3.multiline || s$3.multiline && "\n" !== qi(l$3, s$3.lastIndex - 1)) && (r$2 = "(?: " + r$2 + ")", Y$2 = " " + Y$2, p$2++), i$3 = new RegExp("^(?:" + r$2 + ")", d$2)), ie && (i$3 = new RegExp("^" + r$2 + "$(?!\\s)", d$2)), ne && (e$2 = s$3.lastIndex), u$2 = j$1(Ii, w$2 ? i$3 : s$3, Y$2), w$2 ? u$2 ? (u$2.input = $i(u$2.input, p$2), u$2[0] = $i(u$2[0], p$2), u$2.index = s$3.lastIndex, s$3.lastIndex += u$2[0].length) : s$3.lastIndex = 0 : ne && u$2 && (s$3.lastIndex = s$3.global ? u$2.index + u$2[0].length : e$2), ie && u$2 && u$2.length > 1 && j$1(Oi, u$2[0], i$3, (function() {
				for (o$2 = 1; o$2 < arguments.length - 2; o$2++) void 0 === arguments[o$2] && (u$2[o$2] = void 0);
			})), u$2 && b$6) for (u$2.groups = g$4 = vi(null), o$2 = 0; o$2 < b$6.length; o$2++) g$4[(h$2 = b$6[o$2])[0]] = u$2[h$2[1]];
			return u$2;
		});
		var ee = Ui;
		fa({
			target: "RegExp",
			proto: !0,
			forced: /./.exec !== ee
		}, { exec: ee });
		var ue = xn.PROPER, oe = RegExp.prototype.toString, ge = t$1((function() {
			return "/a/b" != oe.call({
				source: "a",
				flags: "b"
			});
		})), he = ue && "toString" != oe.name;
		(ge || he) && ha(RegExp.prototype, "toString", (function() {
			var n$7 = Bn(this);
			return "/" + ai(n$7.source) + "/" + ai(ui(n$7));
		}), { unsafe: !0 });
		var se = Function.prototype, ye = se.apply, le = se.call, te = "object" == typeof Reflect && Reflect.apply || (w$1 ? le.bind(ye) : function() {
			return le.apply(ye, arguments);
		}), be = Yn("species"), we = RegExp.prototype, de = S$1("".charAt), je = S$1("".charCodeAt), re = S$1("".slice), pe = function(n$7) {
			return function(a$2, i$3) {
				var e$2, u$2, o$2 = ai(B$1(a$2)), g$4 = ta(i$3), h$2 = o$2.length;
				return g$4 < 0 || g$4 >= h$2 ? n$7 ? "" : void 0 : (e$2 = je(o$2, g$4)) < 55296 || e$2 > 56319 || g$4 + 1 === h$2 || (u$2 = je(o$2, g$4 + 1)) < 56320 || u$2 > 57343 ? n$7 ? de(o$2, g$4) : e$2 : n$7 ? re(o$2, g$4, g$4 + 2) : u$2 - 56320 + (e$2 - 55296 << 10) + 65536;
			};
		}, Ye = {
			codeAt: pe(!1),
			charAt: pe(!0)
		}.charAt, ce = function(n$7, a$2, i$3) {
			return a$2 + (i$3 ? Ye(n$7, a$2).length : 1);
		}, me = Math.floor, Ze = S$1("".charAt), Le = S$1("".replace), Je = S$1("".slice), Se = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Ce = /\$([$&'`]|\d{1,2})/g, ke = function(n$7, a$2, i$3, e$2, u$2, o$2) {
			var g$4 = i$3 + n$7.length, h$2 = e$2.length, s$3 = Ce;
			return void 0 !== u$2 && (u$2 = hn(u$2), s$3 = Se), Le(o$2, s$3, (function(o$3, s$4) {
				var y$2;
				switch (Ze(s$4, 0)) {
					case "$": return "$";
					case "&": return n$7;
					case "`": return Je(a$2, 0, i$3);
					case "'": return Je(a$2, g$4);
					case "<":
						y$2 = u$2[Je(s$4, 1, -1)];
						break;
					default:
						var l$3 = +s$4;
						if (0 === l$3) return o$3;
						if (l$3 > h$2) {
							var t$2 = me(l$3 / 10);
							return 0 === t$2 ? o$3 : t$2 <= h$2 ? void 0 === e$2[t$2 - 1] ? Ze(s$4, 1) : e$2[t$2 - 1] + Ze(s$4, 1) : o$3;
						}
						y$2 = e$2[l$3 - 1];
				}
				return void 0 === y$2 ? "" : y$2;
			}));
		}, Xe = TypeError, De = function(n$7, a$2) {
			var i$3 = n$7.exec;
			if (G$1(i$3)) {
				var e$2 = j$1(i$3, n$7, a$2);
				return null !== e$2 && Bn(e$2), e$2;
			}
			if ("RegExp" === X$1(n$7)) return j$1(ee, n$7, a$2);
			throw Xe("RegExp#exec called on incompatible receiver");
		}, He = Yn("replace"), Te = Math.max, Qe = Math.min, Be = S$1([].concat), Me = S$1([].push), Ge = S$1("".indexOf), Fe = S$1("".slice), Pe = "$0" === "a".replace(/./, "$0"), Ne = !!/./[He] && "" === /./[He]("a", "$0");
		(function(n$7, a$2, i$3, e$2) {
			var u$2 = Yn(n$7), o$2 = !t$1((function() {
				var a$3 = {};
				return a$3[u$2] = function() {
					return 7;
				}, 7 != ""[n$7](a$3);
			})), g$4 = o$2 && !t$1((function() {
				var a$3 = !1, i$4 = /a/;
				return "split" === n$7 && ((i$4 = {}).constructor = {}, i$4.constructor[be] = function() {
					return i$4;
				}, i$4.flags = "", i$4[u$2] = /./[u$2]), i$4.exec = function() {
					return a$3 = !0, null;
				}, i$4[u$2](""), !a$3;
			}));
			if (!o$2 || !g$4 || i$3) {
				var h$2 = S$1(/./[u$2]), s$3 = a$2(u$2, ""[n$7], (function(n$8, a$3, i$4, e$3, u$3) {
					var g$5 = S$1(n$8), s$4 = a$3.exec;
					return s$4 === ee || s$4 === we.exec ? o$2 && !u$3 ? {
						done: !0,
						value: h$2(a$3, i$4, e$3)
					} : {
						done: !0,
						value: g$5(i$4, a$3, e$3)
					} : { done: !1 };
				}));
				ha(String.prototype, n$7, s$3[0]), ha(we, u$2, s$3[1]);
			}
			e$2 && Nn(we[u$2], "sham", !0);
		})("replace", (function(n$7, a$2, i$3) {
			var e$2 = Ne ? "$" : "$0";
			return [function(n$8, i$4) {
				var e$3 = B$1(this), u$2 = null == n$8 ? void 0 : $$1(n$8, He);
				return u$2 ? j$1(u$2, n$8, e$3, i$4) : j$1(a$2, ai(e$3), n$8, i$4);
			}, function(n$8, u$2) {
				var o$2 = Bn(this), g$4 = ai(n$8);
				if ("string" == typeof u$2 && -1 === Ge(u$2, e$2) && -1 === Ge(u$2, "$<")) {
					var h$2 = i$3(a$2, o$2, g$4, u$2);
					if (h$2.done) return h$2.value;
				}
				var s$3 = G$1(u$2);
				s$3 || (u$2 = ai(u$2));
				var y$2 = o$2.global;
				if (y$2) {
					var l$3 = o$2.unicode;
					o$2.lastIndex = 0;
				}
				for (var t$2 = [];;) {
					var b$6 = De(o$2, g$4);
					if (null === b$6) break;
					if (Me(t$2, b$6), !y$2) break;
					"" === ai(b$6[0]) && (o$2.lastIndex = ce(g$4, ra(o$2.lastIndex), l$3));
				}
				for (var w$2, d$2 = "", j$2 = 0, r$2 = 0; r$2 < t$2.length; r$2++) {
					for (var p$2 = ai((b$6 = t$2[r$2])[0]), Y$2 = Te(Qe(ta(b$6.index), g$4.length), 0), c$2 = [], m$2 = 1; m$2 < b$6.length; m$2++) Me(c$2, void 0 === (w$2 = b$6[m$2]) ? w$2 : String(w$2));
					var Z$2 = b$6.groups;
					if (s$3) {
						var L$2 = Be([p$2], c$2, Y$2, g$4);
						void 0 !== Z$2 && Me(L$2, Z$2);
						var J$2 = ai(te(u$2, void 0, L$2));
					} else J$2 = ke(p$2, g$4, Y$2, c$2, Z$2, u$2);
					Y$2 >= j$2 && (d$2 += Fe(g$4, j$2, Y$2) + J$2, j$2 = Y$2 + p$2.length);
				}
				return d$2 + Fe(g$4, j$2);
			}];
		}), !!t$1((function() {
			var n$7 = /./;
			return n$7.exec = function() {
				var n$8 = [];
				return n$8.groups = { a: "7" }, n$8;
			}, "7" !== "".replace(n$7, "$<a>");
		})) || !Pe || Ne);
		var fe = S$1(S$1.bind), We = Array.isArray || function(n$7) {
			return "Array" == X$1(n$7);
		}, Ke = function() {}, xe = [], Re = N$1("Reflect", "construct"), Ee = /^\s*(?:class|function)\b/, Ae = S$1(Ee.exec), ve = !Ee.exec(Ke), ze = function(n$7) {
			if (!G$1(n$7)) return !1;
			try {
				return Re(Ke, xe, n$7), !0;
			} catch (n$8) {
				return !1;
			}
		}, Oe = function(n$7) {
			if (!G$1(n$7)) return !1;
			switch ($a(n$7)) {
				case "AsyncFunction":
				case "GeneratorFunction":
				case "AsyncGeneratorFunction": return !1;
			}
			try {
				return ve || !!Ae(Ee, zn(n$7));
			} catch (n$8) {
				return !0;
			}
		};
		Oe.sham = !0;
		var Ie = !Re || t$1((function() {
			var n$7;
			return ze(ze.call) || !ze(Object) || !ze((function() {
				n$7 = !0;
			})) || n$7;
		})) ? Oe : ze, Ue = Yn("species"), qe = Array, Ve = function(n$7, a$2) {
			return new (function(n$8) {
				var a$3;
				return We(n$8) && (a$3 = n$8.constructor, (Ie(a$3) && (a$3 === qe || We(a$3.prototype)) || F$1(a$3) && null === (a$3 = a$3[Ue])) && (a$3 = void 0)), void 0 === a$3 ? qe : a$3;
			}(n$7))(0 === a$2 ? 0 : a$2);
		}, _e = S$1([].push), $e = function(n$7) {
			var a$2 = 1 == n$7, i$3 = 2 == n$7, e$2 = 3 == n$7, u$2 = 4 == n$7, o$2 = 6 == n$7, g$4 = 7 == n$7, h$2 = 5 == n$7 || o$2;
			return function(s$3, y$2, l$3, t$2) {
				for (var b$6, d$2, j$2 = hn(s$3), r$2 = T$1(j$2), p$2 = function(n$8, a$3) {
					return _$1(n$8), void 0 === a$3 ? n$8 : w$1 ? fe(n$8, a$3) : function() {
						return n$8.apply(a$3, arguments);
					};
				}(y$2, l$3), Y$2 = pa(r$2), c$2 = 0, m$2 = t$2 || Ve, Z$2 = a$2 ? m$2(s$3, Y$2) : i$3 || g$4 ? m$2(s$3, 0) : void 0; Y$2 > c$2; c$2++) if ((h$2 || c$2 in r$2) && (d$2 = p$2(b$6 = r$2[c$2], c$2, j$2), n$7)) if (a$2) Z$2[c$2] = d$2;
				else if (d$2) switch (n$7) {
					case 3: return !0;
					case 5: return b$6;
					case 6: return c$2;
					case 2: _e(Z$2, b$6);
				}
				else switch (n$7) {
					case 4: return !1;
					case 7: _e(Z$2, b$6);
				}
				return o$2 ? -1 : e$2 || u$2 ? u$2 : Z$2;
			};
		}, nu = {
			forEach: $e(0),
			map: $e(1),
			filter: $e(2),
			some: $e(3),
			every: $e(4),
			find: $e(5),
			findIndex: $e(6),
			filterReject: $e(7)
		}, au = Yn("species"), iu = function(n$7) {
			return A$1 >= 51 || !t$1((function() {
				var a$2 = [];
				return (a$2.constructor = {})[au] = function() {
					return { foo: 1 };
				}, 1 !== a$2[n$7](Boolean).foo;
			}));
		}, eu = nu.map;
		fa({
			target: "Array",
			proto: !0,
			forced: !iu("map")
		}, { map: function(n$7) {
			return eu(this, n$7, arguments.length > 1 ? arguments[1] : void 0);
		} });
		var uu = Pn.f, ou = Yn("unscopables"), gu = Array.prototype;
		gu[ou] ?? uu(gu, ou, {
			configurable: !0,
			value: vi(null)
		});
		var hu, su = nu.find, yu = !0;
		"find" in [] && Array(1).find((function() {
			yu = !1;
		})), fa({
			target: "Array",
			proto: !0,
			forced: yu
		}, { find: function(n$7) {
			return su(this, n$7, arguments.length > 1 ? arguments[1] : void 0);
		} }), hu = "find", gu[ou][hu] = !0;
		var lu = Ua ? {}.toString : function() {
			return "[object " + $a(this) + "]";
		};
		Ua || ha(Object.prototype, "toString", lu, { unsafe: !0 });
		var tu, bu, wu, du = l$2.RegExp, ju = du.prototype;
		b$5 && t$1((function() {
			var n$7 = !0;
			try {
				du(".", "d");
			} catch (a$3) {
				n$7 = !1;
			}
			var a$2 = {}, i$3 = "", e$2 = n$7 ? "dgimsy" : "gimsy", u$2 = function(n$8, e$3) {
				Object.defineProperty(a$2, n$8, { get: function() {
					return i$3 += e$3, !0;
				} });
			}, o$2 = {
				dotAll: "s",
				global: "g",
				ignoreCase: "i",
				multiline: "m",
				sticky: "y"
			};
			for (var g$4 in n$7 && (o$2.hasIndices = "d"), o$2) u$2(g$4, o$2[g$4]);
			return Object.getOwnPropertyDescriptor(ju, "flags").get.call(a$2) !== e$2 || i$3 !== e$2;
		})) && (tu = ju, bu = "flags", (wu = {
			configurable: !0,
			get: ii
		}).get && ga(wu.get, bu, { getter: !0 }), wu.set && ga(wu.set, bu, { setter: !0 }), Pn.f(tu, bu, wu)), fa({
			target: "Object",
			stat: !0,
			forced: t$1((function() {
				Wa(1);
			}))
		}, { keys: function(n$7) {
			return Wa(hn(n$7));
		} });
		var ru, pu = "	\n\v\f\r \xA0              　\u2028\u2029﻿", Yu = S$1("".replace), cu = "[" + pu + "]", mu = RegExp("^" + cu + cu + "*"), Zu = RegExp(cu + cu + "*$"), Lu = function(n$7) {
			return function(a$2) {
				var i$3 = ai(B$1(a$2));
				return 1 & n$7 && (i$3 = Yu(i$3, mu, "")), 2 & n$7 && (i$3 = Yu(i$3, Zu, "")), i$3;
			};
		}, Ju = {
			start: Lu(1),
			end: Lu(2),
			trim: Lu(3)
		}, Su = xn.PROPER, Cu = Ju.trim;
		fa({
			target: "String",
			proto: !0,
			forced: (ru = "trim", t$1((function() {
				return !!pu[ru]() || "​᠎" !== "​᠎"[ru]() || Su && pu[ru].name !== ru;
			})))
		}, { trim: function() {
			return Cu(this);
		} });
		for (var ku = [
			[
				"\0",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x07",
				"\b",
				"	",
				"\n",
				"\v",
				"\f",
				"\r",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1B",
				"",
				"",
				"",
				"",
				" ",
				"!",
				"\"",
				"#",
				"$",
				"%",
				"&",
				"'",
				"(",
				")",
				"*",
				"+",
				",",
				"-",
				".",
				"/",
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				":",
				";",
				"<",
				"=",
				">",
				"?",
				"@",
				"A",
				"B",
				"C",
				"D",
				"E",
				"F",
				"G",
				"H",
				"I",
				"J",
				"K",
				"L",
				"M",
				"N",
				"O",
				"P",
				"Q",
				"R",
				"S",
				"T",
				"U",
				"V",
				"W",
				"X",
				"Y",
				"Z",
				"[",
				"\\",
				"]",
				"^",
				"_",
				"`",
				"a",
				"b",
				"c",
				"d",
				"e",
				"f",
				"g",
				"h",
				"i",
				"j",
				"k",
				"l",
				"m",
				"n",
				"o",
				"p",
				"q",
				"r",
				"s",
				"t",
				"u",
				"v",
				"w",
				"x",
				"y",
				"z",
				"{",
				"|",
				"}",
				"~",
				"",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				" ",
				"!",
				"C/",
				"PS",
				"$?",
				"Y=",
				"|",
				"SS",
				"\"",
				"(c)",
				"a",
				"<<",
				"!",
				,
				"(r)",
				"-",
				"deg",
				"+-",
				"2",
				"3",
				"'",
				"u",
				"P",
				"*",
				",",
				"1",
				"o",
				">>",
				"1/4",
				"1/2",
				"3/4",
				"?",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"AE",
				"C",
				"E",
				"E",
				"E",
				"E",
				"I",
				"I",
				"I",
				"I",
				"D",
				"N",
				"O",
				"O",
				"O",
				"O",
				"O",
				"x",
				"O",
				"U",
				"U",
				"U",
				"U",
				"U",
				"Th",
				"ss",
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"ae",
				"c",
				"e",
				"e",
				"e",
				"e",
				"i",
				"i",
				"i",
				"i",
				"d",
				"n",
				"o",
				"o",
				"o",
				"o",
				"o",
				"/",
				"o",
				"u",
				"u",
				"u",
				"u",
				"y",
				"th",
				"y"
			],
			[
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"C",
				"c",
				"C",
				"c",
				"C",
				"c",
				"C",
				"c",
				"D",
				"d",
				"D",
				"d",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"G",
				"g",
				"G",
				"g",
				"G",
				"g",
				"G",
				"g",
				"H",
				"h",
				"H",
				"h",
				"I",
				"i",
				"I",
				"i",
				"I",
				"i",
				"I",
				"i",
				"I",
				"i",
				"IJ",
				"ij",
				"J",
				"j",
				"K",
				"k",
				"k",
				"L",
				"l",
				"L",
				"l",
				"L",
				"l",
				"L",
				"l",
				"L",
				"l",
				"N",
				"n",
				"N",
				"n",
				"N",
				"n",
				"'n",
				"NG",
				"ng",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"OE",
				"oe",
				"R",
				"r",
				"R",
				"r",
				"R",
				"r",
				"S",
				"s",
				"S",
				"s",
				"S",
				"s",
				"S",
				"s",
				"T",
				"t",
				"T",
				"t",
				"T",
				"t",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"W",
				"w",
				"Y",
				"y",
				"Y",
				"Z",
				"z",
				"Z",
				"z",
				"Z",
				"z",
				"s",
				"b",
				"B",
				"B",
				"b",
				"6",
				"6",
				"O",
				"C",
				"c",
				"D",
				"D",
				"D",
				"d",
				"d",
				"3",
				"@",
				"E",
				"F",
				"f",
				"G",
				"G",
				"hv",
				"I",
				"I",
				"K",
				"k",
				"l",
				"l",
				"W",
				"N",
				"n",
				"O",
				"O",
				"o",
				"OI",
				"oi",
				"P",
				"p",
				"YR",
				"2",
				"2",
				"SH",
				"sh",
				"t",
				"T",
				"t",
				"T",
				"U",
				"u",
				"Y",
				"V",
				"Y",
				"y",
				"Z",
				"z",
				"ZH",
				"ZH",
				"zh",
				"zh",
				"2",
				"5",
				"5",
				"ts",
				"w",
				"|",
				"||",
				"|=",
				"!",
				"DZ",
				"Dz",
				"dz",
				"LJ",
				"Lj",
				"lj",
				"NJ",
				"Nj",
				"nj",
				"A",
				"a",
				"I",
				"i",
				"O",
				"o",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"@",
				"A",
				"a",
				"A",
				"a",
				"AE",
				"ae",
				"G",
				"g",
				"G",
				"g",
				"K",
				"k",
				"O",
				"o",
				"O",
				"o",
				"ZH",
				"zh",
				"j",
				"DZ",
				"D",
				"dz",
				"G",
				"g",
				"HV",
				"W",
				"N",
				"n",
				"A",
				"a",
				"AE",
				"ae",
				"O",
				"o"
			],
			[
				"A",
				"a",
				"A",
				"a",
				"E",
				"e",
				"E",
				"e",
				"I",
				"i",
				"I",
				"i",
				"O",
				"o",
				"O",
				"o",
				"R",
				"r",
				"R",
				"r",
				"U",
				"u",
				"U",
				"u",
				"S",
				"s",
				"T",
				"t",
				"Y",
				"y",
				"H",
				"h",
				"N",
				"d",
				"OU",
				"ou",
				"Z",
				"z",
				"A",
				"a",
				"E",
				"e",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"Y",
				"y",
				"l",
				"n",
				"t",
				"j",
				"db",
				"qp",
				"A",
				"C",
				"c",
				"L",
				"T",
				"s",
				"z",
				"?",
				"?",
				"B",
				"U",
				"V",
				"E",
				"e",
				"J",
				"j",
				"Q",
				"q",
				"R",
				"r",
				"Y",
				"y",
				"a",
				"a",
				"a",
				"b",
				"o",
				"c",
				"d",
				"d",
				"e",
				"@",
				"@",
				"e",
				"e",
				"e",
				"e",
				"j",
				"g",
				"g",
				"g",
				"g",
				"u",
				"Y",
				"h",
				"h",
				"i",
				"i",
				"I",
				"l",
				"l",
				"l",
				"lZ",
				"W",
				"W",
				"m",
				"n",
				"n",
				"n",
				"o",
				"OE",
				"O",
				"F",
				"R",
				"R",
				"R",
				"R",
				"r",
				"r",
				"R",
				"R",
				"R",
				"s",
				"S",
				"j",
				"S",
				"S",
				"t",
				"t",
				"U",
				"U",
				"v",
				"^",
				"W",
				"Y",
				"Y",
				"z",
				"z",
				"Z",
				"Z",
				"?",
				"?",
				"?",
				"C",
				"@",
				"B",
				"E",
				"G",
				"H",
				"j",
				"k",
				"L",
				"q",
				"?",
				"?",
				"dz",
				"dZ",
				"dz",
				"ts",
				"tS",
				"tC",
				"fN",
				"ls",
				"lz",
				"WW",
				"]]",
				"h",
				"h",
				"k",
				"h",
				"j",
				"r",
				"r",
				"r",
				"r",
				"w",
				"y",
				"'",
				"\"",
				"`",
				"'",
				"`",
				"`",
				"'",
				"?",
				"?",
				"<",
				">",
				"^",
				"V",
				"^",
				"V",
				"'",
				"-",
				"/",
				"\\",
				",",
				"_",
				"\\",
				"/",
				":",
				".",
				"`",
				"'",
				"^",
				"V",
				"+",
				"-",
				"V",
				".",
				"@",
				",",
				"~",
				"\"",
				"R",
				"X",
				"G",
				"l",
				"s",
				"x",
				"?",
				,
				,
				,
				,
				,
				,
				,
				"V",
				"=",
				"\""
			],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"'",
				",",
				,
				,
				,
				,
				,
				,
				,
				,
				"?",
				,
				,
				,
				,
				,
				,
				,
				"A",
				";",
				"E",
				"I",
				"I",
				,
				"O",
				,
				"U",
				"O",
				"I",
				"A",
				"V",
				"G",
				"D",
				"E",
				"Z",
				"I",
				"Th",
				"I",
				"K",
				"L",
				"M",
				"N",
				"X",
				"O",
				"P",
				"R",
				,
				"S",
				"T",
				"Y",
				"F",
				"H",
				"Ps",
				"O",
				"I",
				"Y",
				"a",
				"e",
				"i",
				"i",
				"y",
				"a",
				"v",
				"g",
				"d",
				"e",
				"z",
				"i",
				"th",
				"i",
				"k",
				"l",
				"m",
				"n",
				"x",
				"o",
				"p",
				"r",
				"s",
				"s",
				"t",
				"y",
				"f",
				"h",
				"ps",
				"o",
				"i",
				"y",
				"o",
				"y",
				"o",
				,
				"b",
				"th",
				"U",
				"U",
				"U",
				"ph",
				"p",
				"&",
				,
				,
				"St",
				"st",
				"W",
				"w",
				"Q",
				"q",
				"Sp",
				"sp",
				"Sh",
				"sh",
				"F",
				"f",
				"Kh",
				"kh",
				"H",
				"h",
				"G",
				"g",
				"CH",
				"ch",
				"Ti",
				"ti",
				"k",
				"r",
				"c",
				"j"
			],
			[
				"Jo",
				"Yo",
				"Dj",
				"Gj",
				"Ie",
				"Dz",
				"I",
				"Yi",
				"J",
				"Lj",
				"Nj",
				"Tsh",
				"Kj",
				"I",
				"U",
				"Dzh",
				"A",
				"B",
				"V",
				"G",
				"D",
				"E",
				"Zh",
				"Z",
				"I",
				"Y",
				"K",
				"L",
				"M",
				"N",
				"O",
				"P",
				"R",
				"S",
				"T",
				"U",
				"F",
				"H",
				"C",
				"Ch",
				"Sh",
				"Shch",
				,
				"Y",
				,
				"E",
				"Yu",
				"Ya",
				"a",
				"b",
				"v",
				"g",
				"d",
				"e",
				"zh",
				"z",
				"i",
				"y",
				"k",
				"l",
				"m",
				"n",
				"o",
				"p",
				"r",
				"s",
				"t",
				"u",
				"f",
				"h",
				"c",
				"ch",
				"sh",
				"shch",
				,
				"y",
				,
				"e",
				"yu",
				"ya",
				"je",
				"yo",
				"dj",
				"gj",
				"ie",
				"dz",
				"i",
				"yi",
				"j",
				"lj",
				"nj",
				"tsh",
				"kj",
				"i",
				"u",
				"dzh",
				"O",
				"o",
				"E",
				"e",
				"Ie",
				"ie",
				"E",
				"e",
				"Ie",
				"ie",
				"O",
				"o",
				"Io",
				"io",
				"Ks",
				"ks",
				"Ps",
				"ps",
				"F",
				"f",
				"Y",
				"y",
				"Y",
				"y",
				"u",
				"u",
				"O",
				"o",
				"O",
				"o",
				"Ot",
				"ot",
				"Q",
				"q",
				"*1000*",
				,
				,
				,
				,
				,
				"*100.000*",
				"*1.000.000*",
				,
				,
				"\"",
				"\"",
				"R'",
				"r'",
				"G'",
				"g'",
				"G'",
				"g'",
				"G'",
				"g'",
				"Zh'",
				"zh'",
				"Z'",
				"z'",
				"K'",
				"k'",
				"K'",
				"k'",
				"K'",
				"k'",
				"K'",
				"k'",
				"N'",
				"n'",
				"Ng",
				"ng",
				"P'",
				"p'",
				"Kh",
				"kh",
				"S'",
				"s'",
				"T'",
				"t'",
				"U",
				"u",
				"U'",
				"u'",
				"Kh'",
				"kh'",
				"Tts",
				"tts",
				"Ch'",
				"ch'",
				"Ch'",
				"ch'",
				"H",
				"h",
				"Ch",
				"ch",
				"Ch'",
				"ch'",
				"`",
				"Zh",
				"zh",
				"K'",
				"k'",
				,
				,
				"N'",
				"n'",
				,
				,
				"Ch",
				"ch",
				,
				,
				,
				"a",
				"a",
				"A",
				"a",
				"Ae",
				"ae",
				"Ie",
				"ie",
				"@",
				"@",
				"@",
				"@",
				"Zh",
				"zh",
				"Z",
				"z",
				"Dz",
				"dz",
				"I",
				"i",
				"I",
				"i",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"E",
				"e",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"Ch",
				"ch",
				,
				,
				"Y",
				"y"
			],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"A",
				"B",
				"G",
				"D",
				"E",
				"Z",
				"E",
				"E",
				"T`",
				"Zh",
				"I",
				"L",
				"Kh",
				"Ts",
				"K",
				"H",
				"Dz",
				"Gh",
				"Ch",
				"M",
				"Y",
				"N",
				"Sh",
				"O",
				"Ch`",
				"P",
				"J",
				"Rh",
				"S",
				"V",
				"T",
				"R",
				"Ts`",
				"W",
				"P`",
				"K`",
				"O",
				"F",
				,
				,
				"<",
				"'",
				"/",
				"!",
				",",
				"?",
				".",
				,
				"a",
				"b",
				"g",
				"d",
				"e",
				"z",
				"e",
				"e",
				"t`",
				"zh",
				"i",
				"l",
				"kh",
				"ts",
				"k",
				"h",
				"dz",
				"gh",
				"ch",
				"m",
				"y",
				"n",
				"sh",
				"o",
				"ch`",
				"p",
				"j",
				"rh",
				"s",
				"v",
				"t",
				"r",
				"ts`",
				"w",
				"p`",
				"k`",
				"o",
				"f",
				"ew",
				,
				".",
				"-",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"@",
				"e",
				"a",
				"o",
				"i",
				"e",
				"e",
				"a",
				"a",
				"o",
				,
				"u",
				"'",
				,
				,
				,
				,
				,
				,
				":",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"b",
				"g",
				"d",
				"h",
				"v",
				"z",
				"kh",
				"t",
				"y",
				"k",
				"k",
				"l",
				"m",
				"m",
				"n",
				"n",
				"s",
				"`",
				"p",
				"p",
				"ts",
				"ts",
				"q",
				"r",
				"sh",
				"t",
				,
				,
				,
				,
				,
				"V",
				"oy",
				"i",
				"'",
				"\""
			],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				",",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				";",
				,
				,
				,
				"?",
				,
				,
				"a",
				"'",
				"w'",
				,
				"y'",
				,
				"b",
				"@",
				"t",
				"th",
				"j",
				"H",
				"kh",
				"d",
				"dh",
				"r",
				"z",
				"s",
				"sh",
				"S",
				"D",
				"T",
				"Z",
				"aa",
				"G",
				,
				,
				,
				,
				,
				,
				"f",
				"q",
				"k",
				"l",
				"m",
				"n",
				"h",
				"w",
				"~",
				"y",
				"an",
				"un",
				"in",
				"a",
				"u",
				"i",
				"W",
				,
				,
				"'",
				"'",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"%",
				".",
				",",
				"*",
				,
				,
				,
				"'",
				"'",
				"'",
				,
				"'",
				"'w",
				"'u",
				"'y",
				"tt",
				"tth",
				"b",
				"t",
				"T",
				"p",
				"th",
				"bh",
				"'h",
				"H",
				"ny",
				"dy",
				"H",
				"ch",
				"cch",
				"dd",
				"D",
				"D",
				"Dt",
				"dh",
				"ddh",
				"d",
				"D",
				"D",
				"rr",
				"R",
				"R",
				"R",
				"R",
				"R",
				"R",
				"j",
				"R",
				"S",
				"S",
				"S",
				"S",
				"S",
				"T",
				"GH",
				"F",
				"F",
				"F",
				"v",
				"f",
				"ph",
				"Q",
				"Q",
				"kh",
				"k",
				"K",
				"K",
				"ng",
				"K",
				"g",
				"G",
				"N",
				"G",
				"G",
				"G",
				"L",
				"L",
				"L",
				"L",
				"N",
				"N",
				"N",
				"N",
				"N",
				"h",
				"Ch",
				"hy",
				"h",
				"H",
				"@",
				"W",
				"oe",
				"oe",
				"u",
				"yu",
				"yu",
				"W",
				"v",
				"y",
				"Y",
				"Y",
				"W",
				,
				,
				"y",
				"y'",
				".",
				"ae",
				,
				,
				,
				,
				,
				,
				,
				"@",
				"#",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"^",
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"Sh",
				"D",
				"Gh",
				"&",
				"+m"
			],
			[
				"//",
				"/",
				",",
				"!",
				"!",
				"-",
				",",
				",",
				";",
				"?",
				"~",
				"{",
				"}",
				"*",
				,
				,
				"'",
				,
				"b",
				"g",
				"g",
				"d",
				"d",
				"h",
				"w",
				"z",
				"H",
				"t",
				"t",
				"y",
				"yh",
				"k",
				"l",
				"m",
				"n",
				"s",
				"s",
				"`",
				"p",
				"p",
				"S",
				"q",
				"r",
				"sh",
				"t",
				,
				,
				,
				"a",
				"a",
				"a",
				"A",
				"A",
				"A",
				"e",
				"e",
				"e",
				"E",
				"i",
				"i",
				"u",
				"u",
				"u",
				"o",
				,
				"`",
				"'",
				,
				,
				"X",
				"Q",
				"@",
				"@",
				"|",
				"+",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"h",
				"sh",
				"n",
				"r",
				"b",
				"L",
				"k",
				"'",
				"v",
				"m",
				"f",
				"dh",
				"th",
				"l",
				"g",
				"ny",
				"s",
				"d",
				"z",
				"t",
				"y",
				"p",
				"j",
				"ch",
				"tt",
				"hh",
				"kh",
				"th",
				"z",
				"sh",
				"s",
				"d",
				"t",
				"z",
				"`",
				"gh",
				"q",
				"w",
				"a",
				"aa",
				"i",
				"ee",
				"u",
				"oo",
				"e",
				"ey",
				"o",
				"oa"
			],
			[],
			[
				,
				"N",
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"L",
				"eN",
				"e",
				"e",
				"ai",
				"oN",
				"o",
				"o",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				"nnn",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"rr",
				"l",
				"l",
				"lll",
				"v",
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				"'",
				"'",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				"eN",
				"e",
				"e",
				"ai",
				"oN",
				"o",
				"o",
				"au",
				,
				,
				,
				"AUM",
				"'",
				"'",
				"`",
				"'",
				,
				,
				,
				"q",
				"khh",
				"ghh",
				"z",
				"dddh",
				"rh",
				"f",
				"yy",
				"RR",
				"LL",
				"L",
				"LL",
				" / ",
				" // ",
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				".",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"N",
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				,
				,
				"e",
				"ai",
				,
				,
				"o",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				,
				"l",
				,
				,
				,
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				"'",
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				,
				,
				"e",
				"ai",
				,
				,
				"o",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				,
				,
				,
				,
				"rr",
				"rh",
				,
				"yy",
				"RR",
				"LL",
				"L",
				"LL",
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"r'",
				"r`",
				"Rs",
				"Rs",
				"1/",
				"2/",
				"3/",
				"4/",
				" 1 - 1/",
				"/16"
			],
			[
				,
				,
				"N",
				,
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				,
				,
				,
				,
				"ee",
				"ai",
				,
				,
				"oo",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bb",
				"m",
				"y",
				"r",
				,
				"l",
				"ll",
				,
				"v",
				"sh",
				,
				"s",
				"h",
				,
				,
				"'",
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				,
				,
				,
				,
				"ee",
				"ai",
				,
				,
				"oo",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"khh",
				"ghh",
				"z",
				"rr",
				,
				"f",
				,
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"N",
				"H",
				,
				,
				"G.E.O.",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"N",
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				,
				"eN",
				,
				"e",
				"ai",
				"oN",
				,
				"o",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"ya",
				"r",
				,
				"l",
				"ll",
				,
				"v",
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				"'",
				"'",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				"eN",
				,
				"e",
				"ai",
				"oN",
				,
				"o",
				"au",
				,
				,
				,
				"AUM",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"RR",
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9"
			],
			[
				,
				"N",
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"L",
				,
				,
				"e",
				"ai",
				,
				,
				"o",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				,
				"l",
				"ll",
				,
				,
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				"'",
				"'",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				,
				,
				,
				"e",
				"ai",
				,
				,
				"o",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				"+",
				,
				,
				,
				,
				"rr",
				"rh",
				,
				"yy",
				"RR",
				"LL",
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				,
				,
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				"k",
				,
				,
				,
				"ng",
				"c",
				,
				"j",
				,
				"ny",
				"tt",
				,
				,
				,
				"nn",
				"t",
				,
				,
				,
				"n",
				"nnn",
				"p",
				,
				,
				,
				"m",
				"y",
				"r",
				"rr",
				"l",
				"ll",
				"lll",
				"v",
				,
				"ss",
				"s",
				"h",
				,
				,
				,
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				,
				,
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"+10+",
				"+100+",
				"+1000+"
			],
			[
				,
				"N",
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"L",
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"rr",
				"l",
				"ll",
				,
				"v",
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				,
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				"+",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"RR",
				"LL",
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"L",
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"rr",
				"l",
				"ll",
				,
				"v",
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				,
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				"+",
				,
				,
				,
				,
				,
				,
				,
				"lll",
				,
				"RR",
				"LL",
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9"
			],
			[
				,
				,
				"N",
				"H",
				,
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"L",
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"rr",
				"l",
				"ll",
				"lll",
				"v",
				"sh",
				"ss",
				"s",
				"h",
				,
				,
				,
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				,
				,
				"e",
				"ee",
				"ai",
				,
				"o",
				"oo",
				"au",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"+",
				,
				,
				,
				,
				,
				,
				,
				,
				"RR",
				"LL",
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"N",
				"H",
				,
				"a",
				"aa",
				"ae",
				"aae",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				"L",
				"LL",
				"e",
				"ee",
				"ai",
				"o",
				"oo",
				"au",
				,
				,
				,
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"nng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"jny",
				"nyj",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"nndd",
				"t",
				"th",
				"d",
				"dh",
				"n",
				,
				"nd",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"mb",
				"y",
				"r",
				,
				"l",
				,
				,
				"v",
				"sh",
				"ss",
				"s",
				"h",
				"ll",
				"f",
				,
				,
				,
				,
				,
				,
				,
				,
				"aa",
				"ae",
				"aae",
				"i",
				"ii",
				"u",
				,
				"uu",
				,
				"R",
				"e",
				"ee",
				"ai",
				"o",
				"oo",
				"au",
				"L",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"RR",
				"LL",
				" . "
			],
			[
				,
				"k",
				"kh",
				"kh",
				"kh",
				"kh",
				"kh",
				"ng",
				"cch",
				"ch",
				"ch",
				"ch",
				"ch",
				"y",
				"d",
				"t",
				"th",
				"th",
				"th",
				"n",
				"d",
				"t",
				"th",
				"th",
				"th",
				"n",
				"b",
				"p",
				"ph",
				"f",
				"ph",
				"f",
				"ph",
				"m",
				"y",
				"r",
				"R",
				"l",
				"L",
				"w",
				"s",
				"s",
				"s",
				"h",
				"l",
				"`",
				"h",
				"~",
				"a",
				"a",
				"aa",
				"am",
				"i",
				"ii",
				"ue",
				"uue",
				"u",
				"uu",
				"'",
				,
				,
				,
				,
				"Bh.",
				"e",
				"ae",
				"o",
				"ai",
				"ai",
				"ao",
				"+",
				,
				,
				,
				,
				,
				,
				"M",
				,
				" * ",
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				" // ",
				" /// ",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"k",
				"kh",
				,
				"kh",
				,
				,
				"ng",
				"ch",
				,
				"s",
				,
				,
				"ny",
				,
				,
				,
				,
				,
				,
				"d",
				"h",
				"th",
				"th",
				,
				"n",
				"b",
				"p",
				"ph",
				"f",
				"ph",
				"f",
				,
				"m",
				"y",
				"r",
				,
				"l",
				,
				"w",
				,
				,
				"s",
				"h",
				,
				"`",
				,
				"~",
				"a",
				,
				"aa",
				"am",
				"i",
				"ii",
				"y",
				"yy",
				"u",
				"uu",
				,
				"o",
				"l",
				"ny",
				,
				,
				"e",
				"ei",
				"o",
				"ay",
				"ai",
				,
				"+",
				,
				,
				,
				,
				,
				,
				"M",
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				"hn",
				"hm"
			],
			[
				"AUM",
				,
				,
				,
				,
				,
				,
				,
				" // ",
				" * ",
				,
				"-",
				" / ",
				" / ",
				" // ",
				" -/ ",
				" +/ ",
				" X/ ",
				" /XX/ ",
				" /X/ ",
				",",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				".5",
				"1.5",
				"2.5",
				"3.5",
				"4.5",
				"5.5",
				"6.5",
				"7.5",
				"8.5",
				"-.5",
				"+",
				"*",
				"^",
				"_",
				,
				"~",
				,
				"]",
				"[[",
				"]]",
				,
				,
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				,
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"ts",
				"tsh",
				"dz",
				"dzh",
				"w",
				"zh",
				"z",
				"'",
				"y",
				"r",
				"l",
				"sh",
				"ssh",
				"s",
				"h",
				"a",
				"kss",
				"r",
				,
				,
				,
				,
				,
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"R",
				"RR",
				"L",
				"LL",
				"e",
				"ee",
				"o",
				"oo",
				"M",
				"H",
				"i",
				"ii",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				,
				"ny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"ts",
				"tsh",
				"dz",
				"dzh",
				"w",
				"zh",
				"z",
				"'",
				"y",
				"r",
				"l",
				"sh",
				"ss",
				"s",
				"h",
				"a",
				"kss",
				"w",
				"y",
				"r",
				,
				"X",
				" :X: ",
				" /O/ ",
				" /o/ ",
				" \\o\\ ",
				" (O) "
			],
			[
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"nny",
				"tt",
				"tth",
				"dd",
				"ddh",
				"nn",
				"tt",
				"th",
				"d",
				"dh",
				"n",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"l",
				"w",
				"s",
				"h",
				"ll",
				"a",
				,
				"i",
				"ii",
				"u",
				"uu",
				"e",
				,
				"o",
				"au",
				,
				"aa",
				"i",
				"ii",
				"u",
				"uu",
				"e",
				"ai",
				,
				,
				,
				"N",
				"'",
				":",
				,
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				" / ",
				" // ",
				"n*",
				"r*",
				"l*",
				"e*",
				"sh",
				"ss",
				"R",
				"RR",
				"L",
				"LL",
				"R",
				"RR",
				"L",
				"LL",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"A",
				"B",
				"G",
				"D",
				"E",
				"V",
				"Z",
				"T`",
				"I",
				"K",
				"L",
				"M",
				"N",
				"O",
				"P",
				"Zh",
				"R",
				"S",
				"T",
				"U",
				"P`",
				"K`",
				"G'",
				"Q",
				"Sh",
				"Ch`",
				"C`",
				"Z'",
				"C",
				"Ch",
				"X",
				"J",
				"H",
				"E",
				"Y",
				"W",
				"Xh",
				"OE",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"a",
				"b",
				"g",
				"d",
				"e",
				"v",
				"z",
				"t`",
				"i",
				"k",
				"l",
				"m",
				"n",
				"o",
				"p",
				"zh",
				"r",
				"s",
				"t",
				"u",
				"p`",
				"k`",
				"g'",
				"q",
				"sh",
				"ch`",
				"c`",
				"z'",
				"c",
				"ch",
				"x",
				"j",
				"h",
				"e",
				"y",
				"w",
				"xh",
				"oe",
				"f",
				,
				,
				,
				,
				" // "
			],
			[
				"g",
				"gg",
				"n",
				"d",
				"dd",
				"r",
				"m",
				"b",
				"bb",
				"s",
				"ss",
				,
				"j",
				"jj",
				"c",
				"k",
				"t",
				"p",
				"h",
				"ng",
				"nn",
				"nd",
				"nb",
				"dg",
				"rn",
				"rr",
				"rh",
				"rN",
				"mb",
				"mN",
				"bg",
				"bn",
				,
				"bs",
				"bsg",
				"bst",
				"bsb",
				"bss",
				"bsj",
				"bj",
				"bc",
				"bt",
				"bp",
				"bN",
				"bbN",
				"sg",
				"sn",
				"sd",
				"sr",
				"sm",
				"sb",
				"sbg",
				"sss",
				"s",
				"sj",
				"sc",
				"sk",
				"st",
				"sp",
				"sh",
				,
				,
				,
				,
				"Z",
				"g",
				"d",
				"m",
				"b",
				"s",
				"Z",
				,
				"j",
				"c",
				"t",
				"p",
				"N",
				"j",
				,
				,
				,
				,
				"ck",
				"ch",
				,
				,
				"pb",
				"pN",
				"hh",
				"Q",
				,
				,
				,
				,
				,
				,
				,
				"a",
				"ae",
				"ya",
				"yae",
				"eo",
				"e",
				"yeo",
				"ye",
				"o",
				"wa",
				"wae",
				"oe",
				"yo",
				"u",
				"weo",
				"we",
				"wi",
				"yu",
				"eu",
				"yi",
				"i",
				"a-o",
				"a-u",
				"ya-o",
				"ya-yo",
				"eo-o",
				"eo-u",
				"eo-eu",
				"yeo-o",
				"yeo-u",
				"o-eo",
				"o-e",
				"o-ye",
				"o-o",
				"o-u",
				"yo-ya",
				"yo-yae",
				"yo-yeo",
				"yo-o",
				"yo-i",
				"u-a",
				"u-ae",
				"u-eo-eu",
				"u-ye",
				"u-u",
				"yu-a",
				"yu-eo",
				"yu-e",
				"yu-yeo",
				"yu-ye",
				"yu-u",
				"yu-i",
				"eu-u",
				"eu-eu",
				"yi-u",
				"i-a",
				"i-ya",
				"i-o",
				"i-u",
				"i-eu",
				"i-U",
				"U",
				"U-eo",
				"U-u",
				"U-i",
				"UU",
				,
				,
				,
				,
				,
				"g",
				"gg",
				"gs",
				"n",
				"nj",
				"nh",
				"d",
				"l",
				"lg",
				"lm",
				"lb",
				"ls",
				"lt",
				"lp",
				"lh",
				"m",
				"b",
				"bs",
				"s",
				"ss",
				"ng",
				"j",
				"c",
				"k",
				"t",
				"p",
				"h",
				"gl",
				"gsg",
				"ng",
				"nd",
				"ns",
				"nZ",
				"nt",
				"dg",
				"tl",
				"lgs",
				"ln",
				"ld",
				"lth",
				"ll",
				"lmg",
				"lms",
				"lbs",
				"lbh",
				"rNp",
				"lss",
				"lZ",
				"lk",
				"lQ",
				"mg",
				"ml",
				"mb",
				"ms",
				"mss",
				"mZ",
				"mc",
				"mh",
				"mN",
				"bl",
				"bp",
				"ph",
				"pN",
				"sg",
				"sd",
				"sl",
				"sb",
				"Z",
				"g",
				"ss",
				,
				"kh",
				"N",
				"Ns",
				"NZ",
				"pb",
				"pN",
				"hn",
				"hl",
				"hm",
				"hb",
				"Q"
			],
			[
				"ha",
				"hu",
				"hi",
				"haa",
				"hee",
				"he",
				"ho",
				,
				"la",
				"lu",
				"li",
				"laa",
				"lee",
				"le",
				"lo",
				"lwa",
				"hha",
				"hhu",
				"hhi",
				"hhaa",
				"hhee",
				"hhe",
				"hho",
				"hhwa",
				"ma",
				"mu",
				"mi",
				"maa",
				"mee",
				"me",
				"mo",
				"mwa",
				"sza",
				"szu",
				"szi",
				"szaa",
				"szee",
				"sze",
				"szo",
				"szwa",
				"ra",
				"ru",
				"ri",
				"raa",
				"ree",
				"re",
				"ro",
				"rwa",
				"sa",
				"su",
				"si",
				"saa",
				"see",
				"se",
				"so",
				"swa",
				"sha",
				"shu",
				"shi",
				"shaa",
				"shee",
				"she",
				"sho",
				"shwa",
				"qa",
				"qu",
				"qi",
				"qaa",
				"qee",
				"qe",
				"qo",
				,
				"qwa",
				,
				"qwi",
				"qwaa",
				"qwee",
				"qwe",
				,
				,
				"qha",
				"qhu",
				"qhi",
				"qhaa",
				"qhee",
				"qhe",
				"qho",
				,
				"qhwa",
				,
				"qhwi",
				"qhwaa",
				"qhwee",
				"qhwe",
				,
				,
				"ba",
				"bu",
				"bi",
				"baa",
				"bee",
				"be",
				"bo",
				"bwa",
				"va",
				"vu",
				"vi",
				"vaa",
				"vee",
				"ve",
				"vo",
				"vwa",
				"ta",
				"tu",
				"ti",
				"taa",
				"tee",
				"te",
				"to",
				"twa",
				"ca",
				"cu",
				"ci",
				"caa",
				"cee",
				"ce",
				"co",
				"cwa",
				"xa",
				"xu",
				"xi",
				"xaa",
				"xee",
				"xe",
				"xo",
				,
				"xwa",
				,
				"xwi",
				"xwaa",
				"xwee",
				"xwe",
				,
				,
				"na",
				"nu",
				"ni",
				"naa",
				"nee",
				"ne",
				"no",
				"nwa",
				"nya",
				"nyu",
				"nyi",
				"nyaa",
				"nyee",
				"nye",
				"nyo",
				"nywa",
				"'a",
				"'u",
				,
				"'aa",
				"'ee",
				"'e",
				"'o",
				"'wa",
				"ka",
				"ku",
				"ki",
				"kaa",
				"kee",
				"ke",
				"ko",
				,
				"kwa",
				,
				"kwi",
				"kwaa",
				"kwee",
				"kwe",
				,
				,
				"kxa",
				"kxu",
				"kxi",
				"kxaa",
				"kxee",
				"kxe",
				"kxo",
				,
				"kxwa",
				,
				"kxwi",
				"kxwaa",
				"kxwee",
				"kxwe",
				,
				,
				"wa",
				"wu",
				"wi",
				"waa",
				"wee",
				"we",
				"wo",
				,
				"`a",
				"`u",
				"`i",
				"`aa",
				"`ee",
				"`e",
				"`o",
				,
				"za",
				"zu",
				"zi",
				"zaa",
				"zee",
				"ze",
				"zo",
				"zwa",
				"zha",
				"zhu",
				"zhi",
				"zhaa",
				"zhee",
				"zhe",
				"zho",
				"zhwa",
				"ya",
				"yu",
				"yi",
				"yaa",
				"yee",
				"ye",
				"yo",
				,
				"da",
				"du",
				"di",
				"daa",
				"dee",
				"de",
				"do",
				"dwa",
				"dda",
				"ddu",
				"ddi",
				"ddaa",
				"ddee",
				"dde",
				"ddo",
				"ddwa"
			],
			[
				"ja",
				"ju",
				"ji",
				"jaa",
				"jee",
				"je",
				"jo",
				"jwa",
				"ga",
				"gu",
				"gi",
				"gaa",
				"gee",
				"ge",
				"go",
				,
				"gwa",
				,
				"gwi",
				"gwaa",
				"gwee",
				"gwe",
				,
				,
				"gga",
				"ggu",
				"ggi",
				"ggaa",
				"ggee",
				"gge",
				"ggo",
				,
				"tha",
				"thu",
				"thi",
				"thaa",
				"thee",
				"the",
				"tho",
				"thwa",
				"cha",
				"chu",
				"chi",
				"chaa",
				"chee",
				"che",
				"cho",
				"chwa",
				"pha",
				"phu",
				"phi",
				"phaa",
				"phee",
				"phe",
				"pho",
				"phwa",
				"tsa",
				"tsu",
				"tsi",
				"tsaa",
				"tsee",
				"tse",
				"tso",
				"tswa",
				"tza",
				"tzu",
				"tzi",
				"tzaa",
				"tzee",
				"tze",
				"tzo",
				,
				"fa",
				"fu",
				"fi",
				"faa",
				"fee",
				"fe",
				"fo",
				"fwa",
				"pa",
				"pu",
				"pi",
				"paa",
				"pee",
				"pe",
				"po",
				"pwa",
				"rya",
				"mya",
				"fya",
				,
				,
				,
				,
				,
				,
				" ",
				".",
				",",
				";",
				":",
				":: ",
				"?",
				"//",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"10+",
				"20+",
				"30+",
				"40+",
				"50+",
				"60+",
				"70+",
				"80+",
				"90+",
				"100+",
				"10,000+",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"a",
				"e",
				"i",
				"o",
				"u",
				"v",
				"ga",
				"ka",
				"ge",
				"gi",
				"go",
				"gu",
				"gv",
				"ha",
				"he",
				"hi",
				"ho",
				"hu",
				"hv",
				"la",
				"le",
				"li",
				"lo",
				"lu",
				"lv",
				"ma",
				"me",
				"mi",
				"mo",
				"mu",
				"na",
				"hna",
				"nah",
				"ne",
				"ni",
				"no",
				"nu",
				"nv",
				"qua",
				"que",
				"qui",
				"quo",
				"quu",
				"quv",
				"sa",
				"s",
				"se",
				"si",
				"so",
				"su",
				"sv",
				"da",
				"ta",
				"de",
				"te",
				"di",
				"ti",
				"do",
				"du",
				"dv",
				"dla",
				"tla",
				"tle",
				"tli",
				"tlo",
				"tlu",
				"tlv",
				"tsa",
				"tse",
				"tsi",
				"tso",
				"tsu",
				"tsv",
				"wa",
				"we",
				"wi",
				"wo",
				"wu",
				"wv",
				"ya",
				"ye",
				"yi",
				"yo",
				"yu",
				"yv"
			],
			[
				,
				"ai",
				"aai",
				"i",
				"ii",
				"u",
				"uu",
				"oo",
				"ee",
				"i",
				"a",
				"aa",
				"we",
				"we",
				"wi",
				"wi",
				"wii",
				"wii",
				"wo",
				"wo",
				"woo",
				"woo",
				"woo",
				"wa",
				"wa",
				"waa",
				"waa",
				"waa",
				"ai",
				"w",
				"'",
				"t",
				"k",
				"sh",
				"s",
				"n",
				"w",
				"n",
				,
				"w",
				"c",
				"?",
				"l",
				"en",
				"in",
				"on",
				"an",
				"pai",
				"paai",
				"pi",
				"pii",
				"pu",
				"puu",
				"poo",
				"hee",
				"hi",
				"pa",
				"paa",
				"pwe",
				"pwe",
				"pwi",
				"pwi",
				"pwii",
				"pwii",
				"pwo",
				"pwo",
				"pwoo",
				"pwoo",
				"pwa",
				"pwa",
				"pwaa",
				"pwaa",
				"pwaa",
				"p",
				"p",
				"h",
				"tai",
				"taai",
				"ti",
				"tii",
				"tu",
				"tuu",
				"too",
				"dee",
				"di",
				"ta",
				"taa",
				"twe",
				"twe",
				"twi",
				"twi",
				"twii",
				"twii",
				"two",
				"two",
				"twoo",
				"twoo",
				"twa",
				"twa",
				"twaa",
				"twaa",
				"twaa",
				"t",
				"tte",
				"tti",
				"tto",
				"tta",
				"kai",
				"kaai",
				"ki",
				"kii",
				"ku",
				"kuu",
				"koo",
				"ka",
				"kaa",
				"kwe",
				"kwe",
				"kwi",
				"kwi",
				"kwii",
				"kwii",
				"kwo",
				"kwo",
				"kwoo",
				"kwoo",
				"kwa",
				"kwa",
				"kwaa",
				"kwaa",
				"kwaa",
				"k",
				"kw",
				"keh",
				"kih",
				"koh",
				"kah",
				"gai",
				"caai",
				"gi",
				"gii",
				"gu",
				"guu",
				"coo",
				"ga",
				"gaa",
				"cwe",
				"cwe",
				"cwi",
				"cwi",
				"cwii",
				"cwii",
				"cwo",
				"cwo",
				"cwoo",
				"cwoo",
				"cwa",
				"cwa",
				"cwaa",
				"cwaa",
				"cwaa",
				"g",
				"th",
				"mai",
				"maai",
				"mi",
				"mii",
				"mu",
				"muu",
				"moo",
				"ma",
				"maa",
				"mwe",
				"mwe",
				"mwi",
				"mwi",
				"mwii",
				"mwii",
				"mwo",
				"mwo",
				"mwoo",
				"mwoo",
				"mwa",
				"mwa",
				"mwaa",
				"mwaa",
				"mwaa",
				"m",
				"m",
				"mh",
				"m",
				"m",
				"nai",
				"naai",
				"ni",
				"nii",
				"nu",
				"nuu",
				"noo",
				"na",
				"naa",
				"nwe",
				"nwe",
				"nwa",
				"nwa",
				"nwaa",
				"nwaa",
				"nwaa",
				"n",
				"ng",
				"nh",
				"lai",
				"laai",
				"li",
				"lii",
				"lu",
				"luu",
				"loo",
				"la",
				"laa",
				"lwe",
				"lwe",
				"lwi",
				"lwi",
				"lwii",
				"lwii",
				"lwo",
				"lwo",
				"lwoo",
				"lwoo",
				"lwa",
				"lwa",
				"lwaa",
				"lwaa",
				"l",
				"l",
				"l",
				"sai",
				"saai",
				"si",
				"sii",
				"su",
				"suu",
				"soo",
				"sa",
				"saa",
				"swe",
				"swe",
				"swi",
				"swi",
				"swii",
				"swii",
				"swo",
				"swo",
				"swoo",
				"swoo"
			],
			[
				"swa",
				"swa",
				"swaa",
				"swaa",
				"swaa",
				"s",
				"s",
				"sw",
				"s",
				"sk",
				"skw",
				"sW",
				"spwa",
				"stwa",
				"skwa",
				"scwa",
				"she",
				"shi",
				"shii",
				"sho",
				"shoo",
				"sha",
				"shaa",
				"shwe",
				"shwe",
				"shwi",
				"shwi",
				"shwii",
				"shwii",
				"shwo",
				"shwo",
				"shwoo",
				"shwoo",
				"shwa",
				"shwa",
				"shwaa",
				"shwaa",
				"sh",
				"jai",
				"yaai",
				"ji",
				"jii",
				"ju",
				"juu",
				"yoo",
				"ja",
				"jaa",
				"ywe",
				"ywe",
				"ywi",
				"ywi",
				"ywii",
				"ywii",
				"ywo",
				"ywo",
				"ywoo",
				"ywoo",
				"ywa",
				"ywa",
				"ywaa",
				"ywaa",
				"ywaa",
				"j",
				"y",
				"y",
				"yi",
				"re",
				"rai",
				"le",
				"raai",
				"ri",
				"rii",
				"ru",
				"ruu",
				"lo",
				"ra",
				"raa",
				"la",
				"rwaa",
				"rwaa",
				"r",
				"r",
				"r",
				"vai",
				"faai",
				"vi",
				"vii",
				"vu",
				"vuu",
				"va",
				"vaa",
				"fwaa",
				"fwaa",
				"v",
				"the",
				"the",
				"thi",
				"thi",
				"thii",
				"thii",
				"tho",
				"thoo",
				"tha",
				"thaa",
				"thwaa",
				"thwaa",
				"th",
				"tthe",
				"tthi",
				"ttho",
				"ttha",
				"tth",
				"tye",
				"tyi",
				"tyo",
				"tya",
				"he",
				"hi",
				"hii",
				"ho",
				"hoo",
				"ha",
				"haa",
				"h",
				"h",
				"hk",
				"qaai",
				"qi",
				"qii",
				"qu",
				"quu",
				"qa",
				"qaa",
				"q",
				"tlhe",
				"tlhi",
				"tlho",
				"tlha",
				"re",
				"ri",
				"ro",
				"ra",
				"ngaai",
				"ngi",
				"ngii",
				"ngu",
				"nguu",
				"nga",
				"ngaa",
				"ng",
				"nng",
				"she",
				"shi",
				"sho",
				"sha",
				"the",
				"thi",
				"tho",
				"tha",
				"th",
				"lhi",
				"lhii",
				"lho",
				"lhoo",
				"lha",
				"lhaa",
				"lh",
				"the",
				"thi",
				"thii",
				"tho",
				"thoo",
				"tha",
				"thaa",
				"th",
				"b",
				"e",
				"i",
				"o",
				"a",
				"we",
				"wi",
				"wo",
				"wa",
				"ne",
				"ni",
				"no",
				"na",
				"ke",
				"ki",
				"ko",
				"ka",
				"he",
				"hi",
				"ho",
				"ha",
				"ghu",
				"gho",
				"ghe",
				"ghee",
				"ghi",
				"gha",
				"ru",
				"ro",
				"re",
				"ree",
				"ri",
				"ra",
				"wu",
				"wo",
				"we",
				"wee",
				"wi",
				"wa",
				"hwu",
				"hwo",
				"hwe",
				"hwee",
				"hwi",
				"hwa",
				"thu",
				"tho",
				"the",
				"thee",
				"thi",
				"tha",
				"ttu",
				"tto",
				"tte",
				"ttee",
				"tti",
				"tta",
				"pu",
				"po",
				"pe",
				"pee",
				"pi",
				"pa",
				"p",
				"gu",
				"go",
				"ge",
				"gee",
				"gi",
				"ga",
				"khu",
				"kho",
				"khe",
				"khee",
				"khi",
				"kha",
				"kku",
				"kko",
				"kke",
				"kkee",
				"kki"
			],
			[
				"kka",
				"kk",
				"nu",
				"no",
				"ne",
				"nee",
				"ni",
				"na",
				"mu",
				"mo",
				"me",
				"mee",
				"mi",
				"ma",
				"yu",
				"yo",
				"ye",
				"yee",
				"yi",
				"ya",
				"ju",
				"ju",
				"jo",
				"je",
				"jee",
				"ji",
				"ji",
				"ja",
				"jju",
				"jjo",
				"jje",
				"jjee",
				"jji",
				"jja",
				"lu",
				"lo",
				"le",
				"lee",
				"li",
				"la",
				"dlu",
				"dlo",
				"dle",
				"dlee",
				"dli",
				"dla",
				"lhu",
				"lho",
				"lhe",
				"lhee",
				"lhi",
				"lha",
				"tlhu",
				"tlho",
				"tlhe",
				"tlhee",
				"tlhi",
				"tlha",
				"tlu",
				"tlo",
				"tle",
				"tlee",
				"tli",
				"tla",
				"zu",
				"zo",
				"ze",
				"zee",
				"zi",
				"za",
				"z",
				"z",
				"dzu",
				"dzo",
				"dze",
				"dzee",
				"dzi",
				"dza",
				"su",
				"so",
				"se",
				"see",
				"si",
				"sa",
				"shu",
				"sho",
				"she",
				"shee",
				"shi",
				"sha",
				"sh",
				"tsu",
				"tso",
				"tse",
				"tsee",
				"tsi",
				"tsa",
				"chu",
				"cho",
				"che",
				"chee",
				"chi",
				"cha",
				"ttsu",
				"ttso",
				"ttse",
				"ttsee",
				"ttsi",
				"ttsa",
				"X",
				".",
				"qai",
				"ngai",
				"nngi",
				"nngii",
				"nngo",
				"nngoo",
				"nnga",
				"nngaa",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				" ",
				"b",
				"l",
				"f",
				"s",
				"n",
				"h",
				"d",
				"t",
				"c",
				"q",
				"m",
				"g",
				"ng",
				"z",
				"r",
				"a",
				"o",
				"u",
				"e",
				"i",
				"ch",
				"th",
				"ph",
				"p",
				"x",
				"p",
				"<",
				">",
				,
				,
				,
				"f",
				"v",
				"u",
				"yr",
				"y",
				"w",
				"th",
				"th",
				"a",
				"o",
				"ac",
				"ae",
				"o",
				"o",
				"o",
				"oe",
				"on",
				"r",
				"k",
				"c",
				"k",
				"g",
				"ng",
				"g",
				"g",
				"w",
				"h",
				"h",
				"h",
				"h",
				"n",
				"n",
				"n",
				"i",
				"e",
				"j",
				"g",
				"ae",
				"a",
				"eo",
				"p",
				"z",
				"s",
				"s",
				"s",
				"c",
				"z",
				"t",
				"t",
				"d",
				"b",
				"b",
				"p",
				"p",
				"e",
				"m",
				"m",
				"m",
				"l",
				"l",
				"ng",
				"ng",
				"d",
				"o",
				"ear",
				"ior",
				"qu",
				"qu",
				"qu",
				"s",
				"yr",
				"yr",
				"yr",
				"q",
				"x",
				".",
				":",
				"+",
				"17",
				"18",
				"19"
			],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"k",
				"kh",
				"g",
				"gh",
				"ng",
				"c",
				"ch",
				"j",
				"jh",
				"ny",
				"t",
				"tth",
				"d",
				"ddh",
				"nn",
				"t",
				"th",
				"d",
				"dh",
				"n",
				"p",
				"ph",
				"b",
				"bh",
				"m",
				"y",
				"r",
				"l",
				"v",
				"sh",
				"ss",
				"s",
				"h",
				"l",
				"q",
				"a",
				"aa",
				"i",
				"ii",
				"u",
				"uk",
				"uu",
				"uuv",
				"ry",
				"ryy",
				"ly",
				"lyy",
				"e",
				"ai",
				"oo",
				"oo",
				"au",
				"a",
				"aa",
				"aa",
				"i",
				"ii",
				"y",
				"yy",
				"u",
				"uu",
				"ua",
				"oe",
				"ya",
				"ie",
				"e",
				"ae",
				"ai",
				"oo",
				"au",
				"M",
				"H",
				"a`",
				,
				,
				,
				"r",
				,
				"!",
				,
				,
				,
				,
				,
				".",
				" // ",
				":",
				"+",
				"++",
				" * ",
				" /// ",
				"KR",
				"'",
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9"
			],
			[
				" @ ",
				" ... ",
				",",
				". ",
				": ",
				" // ",
				,
				"-",
				",",
				". ",
				,
				,
				,
				,
				,
				,
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				,
				,
				,
				,
				"a",
				"e",
				"i",
				"o",
				"u",
				"O",
				"U",
				"ee",
				"n",
				"ng",
				"b",
				"p",
				"q",
				"g",
				"m",
				"l",
				"s",
				"sh",
				"t",
				"d",
				"ch",
				"j",
				"y",
				"r",
				"w",
				"f",
				"k",
				"kha",
				"ts",
				"z",
				"h",
				"zr",
				"lh",
				"zh",
				"ch",
				"-",
				"e",
				"i",
				"o",
				"u",
				"O",
				"U",
				"ng",
				"b",
				"p",
				"q",
				"g",
				"m",
				"t",
				"d",
				"ch",
				"j",
				"ts",
				"y",
				"w",
				"k",
				"g",
				"h",
				"jy",
				"ny",
				"dz",
				"e",
				"i",
				"iy",
				"U",
				"u",
				"ng",
				"k",
				"g",
				"h",
				"p",
				"sh",
				"t",
				"d",
				"j",
				"f",
				"g",
				"h",
				"ts",
				"z",
				"r",
				"ch",
				"zh",
				"i",
				"k",
				"r",
				"f",
				"zh",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"H",
				"X",
				"W",
				"M",
				" 3 ",
				" 333 ",
				"a",
				"i",
				"k",
				"ng",
				"c",
				"tt",
				"tth",
				"dd",
				"nn",
				"t",
				"d",
				"p",
				"ph",
				"ss",
				"zh",
				"z",
				"a",
				"t",
				"zh",
				"gh",
				"ng",
				"c",
				"jh",
				"tta",
				"ddh",
				"t",
				"dh",
				"ss",
				"cy",
				"zh",
				"z",
				"u",
				"y",
				"bh",
				"'"
			],
			[],
			[],
			[],
			[],
			[],
			[
				"A",
				"a",
				"B",
				"b",
				"B",
				"b",
				"B",
				"b",
				"C",
				"c",
				"D",
				"d",
				"D",
				"d",
				"D",
				"d",
				"D",
				"d",
				"D",
				"d",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"F",
				"f",
				"G",
				"g",
				"H",
				"h",
				"H",
				"h",
				"H",
				"h",
				"H",
				"h",
				"H",
				"h",
				"I",
				"i",
				"I",
				"i",
				"K",
				"k",
				"K",
				"k",
				"K",
				"k",
				"L",
				"l",
				"L",
				"l",
				"L",
				"l",
				"L",
				"l",
				"M",
				"m",
				"M",
				"m",
				"M",
				"m",
				"N",
				"n",
				"N",
				"n",
				"N",
				"n",
				"N",
				"n",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"P",
				"p",
				"P",
				"p",
				"R",
				"r",
				"R",
				"r",
				"R",
				"r",
				"R",
				"r",
				"S",
				"s",
				"S",
				"s",
				"S",
				"s",
				"S",
				"s",
				"S",
				"s",
				"T",
				"t",
				"T",
				"t",
				"T",
				"t",
				"T",
				"t",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"V",
				"v",
				"V",
				"v",
				"W",
				"w",
				"W",
				"w",
				"W",
				"w",
				"W",
				"w",
				"W",
				"w",
				"X",
				"x",
				"X",
				"x",
				"Y",
				"y",
				"Z",
				"z",
				"Z",
				"z",
				"Z",
				"z",
				"h",
				"t",
				"w",
				"y",
				"a",
				"S",
				,
				,
				,
				,
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"A",
				"a",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"E",
				"e",
				"I",
				"i",
				"I",
				"i",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"O",
				"o",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"U",
				"u",
				"Y",
				"y",
				"Y",
				"y",
				"Y",
				"y",
				"Y",
				"y"
			],
			[
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				,
				,
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				,
				,
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"i",
				"i",
				"i",
				"i",
				"i",
				"i",
				"i",
				"i",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				,
				,
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				,
				,
				"u",
				"u",
				"u",
				"u",
				"u",
				"u",
				"u",
				"u",
				,
				"U",
				,
				"U",
				,
				"U",
				,
				"U",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"a",
				"a",
				"e",
				"e",
				"e",
				"e",
				"i",
				"i",
				"o",
				"o",
				"u",
				"u",
				"o",
				"o",
				,
				,
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"a",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"A",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"e",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"E",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"o",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"O",
				"a",
				"a",
				"a",
				"a",
				"a",
				,
				"a",
				"a",
				"A",
				"A",
				"A",
				"A",
				"A",
				"'",
				"i",
				"'",
				"~",
				"\"~",
				"e",
				"e",
				"e",
				,
				"e",
				"e",
				"E",
				"E",
				"E",
				"E",
				"E",
				"'`",
				"''",
				"'~",
				"i",
				"i",
				"i",
				"i",
				,
				,
				"i",
				"i",
				"I",
				"I",
				"I",
				"I",
				,
				"`'",
				"`'",
				"`~",
				"u",
				"u",
				"u",
				"u",
				"R",
				"R",
				"u",
				"u",
				"U",
				"U",
				"U",
				"U",
				"R",
				"\"`",
				"\"'",
				"`",
				,
				,
				"o",
				"o",
				"o",
				,
				"o",
				"o",
				"O",
				"O",
				"O",
				"O",
				"O",
				"'",
				"`"
			],
			[
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				" ",
				,
				,
				,
				,
				"-",
				"-",
				"-",
				"-",
				"--",
				"--",
				"||",
				"_",
				"'",
				"'",
				",",
				"'",
				"\"",
				"\"",
				",,",
				"\"",
				"+",
				"++",
				"*",
				"*>",
				".",
				"..",
				"...",
				".",
				"\n",
				"\n\n",
				,
				,
				,
				,
				,
				" ",
				"%0",
				"%00",
				"'",
				"''",
				"'''",
				"`",
				"``",
				"```",
				"^",
				"<",
				">",
				"*",
				"!!",
				"!?",
				"-",
				"_",
				"-",
				"^",
				"***",
				"--",
				"/",
				"-[",
				"]-",
				,
				"?!",
				"!?",
				"7",
				"PP",
				"(]",
				"[)",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"0",
				,
				,
				,
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"+",
				"-",
				"=",
				"(",
				")",
				"n",
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"+",
				"-",
				"=",
				"(",
				")",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"ECU",
				"CL",
				"Cr",
				"FF",
				"L",
				"mil",
				"N",
				"Pts",
				"Rs",
				"W",
				"NS",
				"D",
				"EU",
				"K",
				"T",
				"Dr"
			],
			[
				,
				,
				"C",
				,
				,
				,
				,
				,
				,
				,
				"g",
				"H",
				"H",
				"H",
				"h",
				,
				"I",
				"I",
				"L",
				"l",
				"lb",
				"N",
				"no",
				"(p)",
				"P",
				"P",
				"Q",
				"R",
				"R",
				"R",
				,
				,
				"(sm)",
				"(tel)",
				"(tm)",
				,
				"Z",
				,
				,
				"mho",
				"Z",
				,
				,
				,
				"B",
				"C",
				"e",
				"e",
				,
				"F",
				,
				"M",
				"o",
				,
				,
				,
				,
				"i",
				"Q",
				"(fax)",
				"pi",
				,
				,
				"Pi",
				,
				"G",
				"L",
				"L",
				"Y",
				"D",
				"d",
				"e",
				"i",
				"j",
				,
				,
				"per",
				,
				,
				,
				,
				,
				,
				" 1/3 ",
				" 2/3 ",
				" 1/5 ",
				" 2/5 ",
				" 3/5 ",
				" 4/5 ",
				" 1/6 ",
				" 5/6 ",
				" 1/8 ",
				" 3/8 ",
				" 5/8 ",
				" 7/8 ",
				" 1/",
				"I",
				"II",
				"III",
				"IV",
				"V",
				"VI",
				"VII",
				"VIII",
				"IX",
				"X",
				"XI",
				"XII",
				"L",
				"C",
				"D",
				"M",
				"i",
				"ii",
				"iii",
				"iv",
				"v",
				"vi",
				"vii",
				"viii",
				"ix",
				"x",
				"xi",
				"xii",
				"l",
				"c",
				"d",
				"m",
				"(D",
				"D)",
				"((|))",
				")",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"-",
				"|",
				"-",
				"|",
				"-",
				"|",
				"\\",
				"/",
				"\\",
				"/",
				"-",
				"-",
				"~",
				"~",
				"-",
				"|",
				"-",
				"|",
				"-",
				"-",
				"-",
				"|",
				"-",
				"|",
				"|",
				"-",
				"-",
				"-",
				"-",
				"-",
				"-",
				"|",
				"|",
				"|",
				"|",
				"|",
				"|",
				"|",
				"^",
				"V",
				"\\",
				"=",
				"V",
				"^",
				"-",
				"-",
				"|",
				"|",
				"-",
				"-",
				"|",
				"|",
				"=",
				"|",
				"=",
				"=",
				"|",
				"=",
				"|",
				"=",
				"=",
				"=",
				"=",
				"=",
				"=",
				"|",
				"=",
				"|",
				"=",
				"|",
				"\\",
				"/",
				"\\",
				"/",
				"=",
				"=",
				"~",
				"~",
				"|",
				"|",
				"-",
				"|",
				"-",
				"|",
				"-",
				"-",
				"-",
				"|",
				"-",
				"|",
				"|",
				"|",
				"|",
				"|",
				"|",
				"|",
				"-",
				"\\",
				"\\",
				"|"
			],
			[],
			[],
			[],
			[
				"-",
				"-",
				"|",
				"|",
				"-",
				"-",
				"|",
				"|",
				"-",
				"-",
				"|",
				"|",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"-",
				"-",
				"|",
				"|",
				"-",
				"|",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"+",
				"/",
				"\\",
				"X",
				"-",
				"|",
				"-",
				"|",
				"-",
				"|",
				"-",
				"|",
				"-",
				"|",
				"-",
				"|",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"-",
				"|",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"^",
				"^",
				"^",
				"^",
				">",
				">",
				">",
				">",
				">",
				">",
				"V",
				"V",
				"V",
				"V",
				"<",
				"<",
				"<",
				"<",
				"<",
				"<",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"*",
				"#",
				"#",
				"#",
				"#",
				"#",
				"^",
				"^",
				"^",
				"O",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#",
				"#"
			],
			[],
			[],
			[
				" ",
				"a",
				"1",
				"b",
				"'",
				"k",
				"2",
				"l",
				"@",
				"c",
				"i",
				"f",
				"/",
				"m",
				"s",
				"p",
				"\"",
				"e",
				"3",
				"h",
				"9",
				"o",
				"6",
				"r",
				"^",
				"d",
				"j",
				"g",
				">",
				"n",
				"t",
				"q",
				",",
				"*",
				"5",
				"<",
				"-",
				"u",
				"8",
				"v",
				".",
				"%",
				"[",
				"$",
				"+",
				"x",
				"!",
				"&",
				";",
				":",
				"4",
				"\\",
				"0",
				"z",
				"7",
				"(",
				"_",
				"?",
				"w",
				"]",
				"#",
				"y",
				")",
				"=",
				"[d7]",
				"[d17]",
				"[d27]",
				"[d127]",
				"[d37]",
				"[d137]",
				"[d237]",
				"[d1237]",
				"[d47]",
				"[d147]",
				"[d247]",
				"[d1247]",
				"[d347]",
				"[d1347]",
				"[d2347]",
				"[d12347]",
				"[d57]",
				"[d157]",
				"[d257]",
				"[d1257]",
				"[d357]",
				"[d1357]",
				"[d2357]",
				"[d12357]",
				"[d457]",
				"[d1457]",
				"[d2457]",
				"[d12457]",
				"[d3457]",
				"[d13457]",
				"[d23457]",
				"[d123457]",
				"[d67]",
				"[d167]",
				"[d267]",
				"[d1267]",
				"[d367]",
				"[d1367]",
				"[d2367]",
				"[d12367]",
				"[d467]",
				"[d1467]",
				"[d2467]",
				"[d12467]",
				"[d3467]",
				"[d13467]",
				"[d23467]",
				"[d123467]",
				"[d567]",
				"[d1567]",
				"[d2567]",
				"[d12567]",
				"[d3567]",
				"[d13567]",
				"[d23567]",
				"[d123567]",
				"[d4567]",
				"[d14567]",
				"[d24567]",
				"[d124567]",
				"[d34567]",
				"[d134567]",
				"[d234567]",
				"[d1234567]",
				"[d8]",
				"[d18]",
				"[d28]",
				"[d128]",
				"[d38]",
				"[d138]",
				"[d238]",
				"[d1238]",
				"[d48]",
				"[d148]",
				"[d248]",
				"[d1248]",
				"[d348]",
				"[d1348]",
				"[d2348]",
				"[d12348]",
				"[d58]",
				"[d158]",
				"[d258]",
				"[d1258]",
				"[d358]",
				"[d1358]",
				"[d2358]",
				"[d12358]",
				"[d458]",
				"[d1458]",
				"[d2458]",
				"[d12458]",
				"[d3458]",
				"[d13458]",
				"[d23458]",
				"[d123458]",
				"[d68]",
				"[d168]",
				"[d268]",
				"[d1268]",
				"[d368]",
				"[d1368]",
				"[d2368]",
				"[d12368]",
				"[d468]",
				"[d1468]",
				"[d2468]",
				"[d12468]",
				"[d3468]",
				"[d13468]",
				"[d23468]",
				"[d123468]",
				"[d568]",
				"[d1568]",
				"[d2568]",
				"[d12568]",
				"[d3568]",
				"[d13568]",
				"[d23568]",
				"[d123568]",
				"[d4568]",
				"[d14568]",
				"[d24568]",
				"[d124568]",
				"[d34568]",
				"[d134568]",
				"[d234568]",
				"[d1234568]",
				"[d78]",
				"[d178]",
				"[d278]",
				"[d1278]",
				"[d378]",
				"[d1378]",
				"[d2378]",
				"[d12378]",
				"[d478]",
				"[d1478]",
				"[d2478]",
				"[d12478]",
				"[d3478]",
				"[d13478]",
				"[d23478]",
				"[d123478]",
				"[d578]",
				"[d1578]",
				"[d2578]",
				"[d12578]",
				"[d3578]",
				"[d13578]",
				"[d23578]",
				"[d123578]",
				"[d4578]",
				"[d14578]",
				"[d24578]",
				"[d124578]",
				"[d34578]",
				"[d134578]",
				"[d234578]",
				"[d1234578]",
				"[d678]",
				"[d1678]",
				"[d2678]",
				"[d12678]",
				"[d3678]",
				"[d13678]",
				"[d23678]",
				"[d123678]",
				"[d4678]",
				"[d14678]",
				"[d24678]",
				"[d124678]",
				"[d34678]",
				"[d134678]",
				"[d234678]",
				"[d1234678]",
				"[d5678]",
				"[d15678]",
				"[d25678]",
				"[d125678]",
				"[d35678]",
				"[d135678]",
				"[d235678]",
				"[d1235678]",
				"[d45678]",
				"[d145678]",
				"[d245678]",
				"[d1245678]",
				"[d345678]",
				"[d1345678]",
				"[d2345678]",
				"[d12345678]"
			],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[
				" ",
				",",
				". ",
				"\"",
				"[JIS]",
				"\"",
				"/",
				"0",
				"<",
				"> ",
				"<<",
				">> ",
				"[",
				"] ",
				"{",
				"} ",
				"[(",
				")] ",
				"@",
				"X ",
				"[",
				"] ",
				"[[",
				"]] ",
				"((",
				")) ",
				"[[",
				"]] ",
				"~ ",
				"``",
				"''",
				",,",
				"@",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				,
				,
				,
				,
				,
				,
				"~",
				"+",
				"+",
				"+",
				"+",
				,
				"@",
				" // ",
				"+10+",
				"+20+",
				"+30+",
				,
				,
				,
				,
				,
				,
				"a",
				"a",
				"i",
				"i",
				"u",
				"u",
				"e",
				"e",
				"o",
				"o",
				"ka",
				"ga",
				"ki",
				"gi",
				"ku",
				"gu",
				"ke",
				"ge",
				"ko",
				"go",
				"sa",
				"za",
				"si",
				"zi",
				"su",
				"zu",
				"se",
				"ze",
				"so",
				"zo",
				"ta",
				"da",
				"ti",
				"di",
				"tu",
				"tu",
				"du",
				"te",
				"de",
				"to",
				"do",
				"na",
				"ni",
				"nu",
				"ne",
				"no",
				"ha",
				"ba",
				"pa",
				"hi",
				"bi",
				"pi",
				"hu",
				"bu",
				"pu",
				"he",
				"be",
				"pe",
				"ho",
				"bo",
				"po",
				"ma",
				"mi",
				"mu",
				"me",
				"mo",
				"ya",
				"ya",
				"yu",
				"yu",
				"yo",
				"yo",
				"ra",
				"ri",
				"ru",
				"re",
				"ro",
				"wa",
				"wa",
				"wi",
				"we",
				"wo",
				"n",
				"vu",
				,
				,
				,
				,
				,
				,
				,
				,
				"\"",
				"\"",
				,
				,
				"a",
				"a",
				"i",
				"i",
				"u",
				"u",
				"e",
				"e",
				"o",
				"o",
				"ka",
				"ga",
				"ki",
				"gi",
				"ku",
				"gu",
				"ke",
				"ge",
				"ko",
				"go",
				"sa",
				"za",
				"si",
				"zi",
				"su",
				"zu",
				"se",
				"ze",
				"so",
				"zo",
				"ta",
				"da",
				"ti",
				"di",
				"tu",
				"tu",
				"du",
				"te",
				"de",
				"to",
				"do",
				"na",
				"ni",
				"nu",
				"ne",
				"no",
				"ha",
				"ba",
				"pa",
				"hi",
				"bi",
				"pi",
				"hu",
				"bu",
				"pu",
				"he",
				"be",
				"pe",
				"ho",
				"bo",
				"po",
				"ma",
				"mi",
				"mu",
				"me",
				"mo",
				"ya",
				"ya",
				"yu",
				"yu",
				"yo",
				"yo",
				"ra",
				"ri",
				"ru",
				"re",
				"ro",
				"wa",
				"wa",
				"wi",
				"we",
				"wo",
				"n",
				"vu",
				"ka",
				"ke",
				"va",
				"vi",
				"ve",
				"vo",
				,
				,
				"\"",
				"\""
			],
			[
				,
				,
				,
				,
				,
				"B",
				"P",
				"M",
				"F",
				"D",
				"T",
				"N",
				"L",
				"G",
				"K",
				"H",
				"J",
				"Q",
				"X",
				"ZH",
				"CH",
				"SH",
				"R",
				"Z",
				"C",
				"S",
				"A",
				"O",
				"E",
				"EH",
				"AI",
				"EI",
				"AU",
				"OU",
				"AN",
				"EN",
				"ANG",
				"ENG",
				"ER",
				"I",
				"U",
				"IU",
				"V",
				"NG",
				"GN",
				,
				,
				,
				,
				"g",
				"gg",
				"gs",
				"n",
				"nj",
				"nh",
				"d",
				"dd",
				"r",
				"lg",
				"lm",
				"lb",
				"ls",
				"lt",
				"lp",
				"rh",
				"m",
				"b",
				"bb",
				"bs",
				"s",
				"ss",
				,
				"j",
				"jj",
				"c",
				"k",
				"t",
				"p",
				"h",
				"a",
				"ae",
				"ya",
				"yae",
				"eo",
				"e",
				"yeo",
				"ye",
				"o",
				"wa",
				"wae",
				"oe",
				"yo",
				"u",
				"weo",
				"we",
				"wi",
				"yu",
				"eu",
				"yi",
				"i",
				,
				"nn",
				"nd",
				"ns",
				"nZ",
				"lgs",
				"ld",
				"lbs",
				"lZ",
				"lQ",
				"mb",
				"ms",
				"mZ",
				"mN",
				"bg",
				,
				"bsg",
				"bst",
				"bj",
				"bt",
				"bN",
				"bbN",
				"sg",
				"sn",
				"sd",
				"sb",
				"sj",
				"Z",
				,
				"N",
				"Ns",
				"NZ",
				"pN",
				"hh",
				"Q",
				"yo-ya",
				"yo-yae",
				"yo-i",
				"yu-yeo",
				"yu-ye",
				"yu-i",
				"U",
				"U-i",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"BU",
				"ZI",
				"JI",
				"GU",
				"EE",
				"ENN",
				"OO",
				"ONN",
				"IR",
				"ANN",
				"INN",
				"UNN",
				"IM",
				"NGG",
				"AINN",
				"AUNN",
				"AM",
				"OM",
				"ONG",
				"INNN",
				"P",
				"T",
				"K",
				"H"
			],
			[
				"(g)",
				"(n)",
				"(d)",
				"(r)",
				"(m)",
				"(b)",
				"(s)",
				"()",
				"(j)",
				"(c)",
				"(k)",
				"(t)",
				"(p)",
				"(h)",
				"(ga)",
				"(na)",
				"(da)",
				"(ra)",
				"(ma)",
				"(ba)",
				"(sa)",
				"(a)",
				"(ja)",
				"(ca)",
				"(ka)",
				"(ta)",
				"(pa)",
				"(ha)",
				"(ju)",
				,
				,
				,
				"(1) ",
				"(2) ",
				"(3) ",
				"(4) ",
				"(5) ",
				"(6) ",
				"(7) ",
				"(8) ",
				"(9) ",
				"(10) ",
				"(Yue) ",
				"(Huo) ",
				"(Shui) ",
				"(Mu) ",
				"(Jin) ",
				"(Tu) ",
				"(Ri) ",
				"(Zhu) ",
				"(You) ",
				"(She) ",
				"(Ming) ",
				"(Te) ",
				"(Cai) ",
				"(Zhu) ",
				"(Lao) ",
				"(Dai) ",
				"(Hu) ",
				"(Xue) ",
				"(Jian) ",
				"(Qi) ",
				"(Zi) ",
				"(Xie) ",
				"(Ji) ",
				"(Xiu) ",
				"<<",
				">>",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"(g)",
				"(n)",
				"(d)",
				"(r)",
				"(m)",
				"(b)",
				"(s)",
				"()",
				"(j)",
				"(c)",
				"(k)",
				"(t)",
				"(p)",
				"(h)",
				"(ga)",
				"(na)",
				"(da)",
				"(ra)",
				"(ma)",
				"(ba)",
				"(sa)",
				"(a)",
				"(ja)",
				"(ca)",
				"(ka)",
				"(ta)",
				"(pa)",
				"(ha)",
				,
				,
				,
				"KIS ",
				"(1) ",
				"(2) ",
				"(3) ",
				"(4) ",
				"(5) ",
				"(6) ",
				"(7) ",
				"(8) ",
				"(9) ",
				"(10) ",
				"(Yue) ",
				"(Huo) ",
				"(Shui) ",
				"(Mu) ",
				"(Jin) ",
				"(Tu) ",
				"(Ri) ",
				"(Zhu) ",
				"(You) ",
				"(She) ",
				"(Ming) ",
				"(Te) ",
				"(Cai) ",
				"(Zhu) ",
				"(Lao) ",
				"(Mi) ",
				"(Nan) ",
				"(Nu) ",
				"(Shi) ",
				"(You) ",
				"(Yin) ",
				"(Zhu) ",
				"(Xiang) ",
				"(Xiu) ",
				"(Xie) ",
				"(Zheng) ",
				"(Shang) ",
				"(Zhong) ",
				"(Xia) ",
				"(Zuo) ",
				"(You) ",
				"(Yi) ",
				"(Zong) ",
				"(Xue) ",
				"(Jian) ",
				"(Qi) ",
				"(Zi) ",
				"(Xie) ",
				"(Ye) ",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"1M",
				"2M",
				"3M",
				"4M",
				"5M",
				"6M",
				"7M",
				"8M",
				"9M",
				"10M",
				"11M",
				"12M",
				,
				,
				,
				,
				"a",
				"i",
				"u",
				"u",
				"o",
				"ka",
				"ki",
				"ku",
				"ke",
				"ko",
				"sa",
				"si",
				"su",
				"se",
				"so",
				"ta",
				"ti",
				"tu",
				"te",
				"to",
				"na",
				"ni",
				"nu",
				"ne",
				"no",
				"ha",
				"hi",
				"hu",
				"he",
				"ho",
				"ma",
				"mi",
				"mu",
				"me",
				"mo",
				"ya",
				"yu",
				"yo",
				"ra",
				"ri",
				"ru",
				"re",
				"ro",
				"wa",
				"wi",
				"we",
				"wo"
			],
			[
				"apartment",
				"alpha",
				"ampere",
				"are",
				"inning",
				"inch",
				"won",
				"escudo",
				"acre",
				"ounce",
				"ohm",
				"kai-ri",
				"carat",
				"calorie",
				"gallon",
				"gamma",
				"giga",
				"guinea",
				"curie",
				"guilder",
				"kilo",
				"kilogram",
				"kilometer",
				"kilowatt",
				"gram",
				"gram ton",
				"cruzeiro",
				"krone",
				"case",
				"koruna",
				"co-op",
				"cycle",
				"centime",
				"shilling",
				"centi",
				"cent",
				"dozen",
				"desi",
				"dollar",
				"ton",
				"nano",
				"knot",
				"heights",
				"percent",
				"parts",
				"barrel",
				"piaster",
				"picul",
				"pico",
				"building",
				"farad",
				"feet",
				"bushel",
				"franc",
				"hectare",
				"peso",
				"pfennig",
				"hertz",
				"pence",
				"page",
				"beta",
				"point",
				"volt",
				"hon",
				"pound",
				"hall",
				"horn",
				"micro",
				"mile",
				"mach",
				"mark",
				"mansion",
				"micron",
				"milli",
				"millibar",
				"mega",
				"megaton",
				"meter",
				"yard",
				"yard",
				"yuan",
				"liter",
				"lira",
				"rupee",
				"ruble",
				"rem",
				"roentgen",
				"watt",
				"0h",
				"1h",
				"2h",
				"3h",
				"4h",
				"5h",
				"6h",
				"7h",
				"8h",
				"9h",
				"10h",
				"11h",
				"12h",
				"13h",
				"14h",
				"15h",
				"16h",
				"17h",
				"18h",
				"19h",
				"20h",
				"21h",
				"22h",
				"23h",
				"24h",
				"HPA",
				"da",
				"AU",
				"bar",
				"oV",
				"pc",
				,
				,
				,
				,
				"Heisei",
				"Syouwa",
				"Taisyou",
				"Meiji",
				"Inc.",
				"pA",
				"nA",
				"microamp",
				"mA",
				"kA",
				"kB",
				"MB",
				"GB",
				"cal",
				"kcal",
				"pF",
				"nF",
				"microFarad",
				"microgram",
				"mg",
				"kg",
				"Hz",
				"kHz",
				"MHz",
				"GHz",
				"THz",
				"microliter",
				"ml",
				"dl",
				"kl",
				"fm",
				"nm",
				"micrometer",
				"mm",
				"cm",
				"km",
				"mm^2",
				"cm^2",
				"m^2",
				"km^2",
				"mm^4",
				"cm^3",
				"m^3",
				"km^3",
				"m/s",
				"m/s^2",
				"Pa",
				"kPa",
				"MPa",
				"GPa",
				"rad",
				"rad/s",
				"rad/s^2",
				"ps",
				"ns",
				"microsecond",
				"ms",
				"pV",
				"nV",
				"microvolt",
				"mV",
				"kV",
				"MV",
				"pW",
				"nW",
				"microwatt",
				"mW",
				"kW",
				"MW",
				"kOhm",
				"MOhm",
				"a.m.",
				"Bq",
				"cc",
				"cd",
				"C/kg",
				"Co.",
				"dB",
				"Gy",
				"ha",
				"HP",
				"in",
				"K.K.",
				"KM",
				"kt",
				"lm",
				"ln",
				"log",
				"lx",
				"mb",
				"mil",
				"mol",
				"pH",
				"p.m.",
				"PPM",
				"PR",
				"sr",
				"Sv",
				"Wb",
				,
				,
				"1d",
				"2d",
				"3d",
				"4d",
				"5d",
				"6d",
				"7d",
				"8d",
				"9d",
				"10d",
				"11d",
				"12d",
				"13d",
				"14d",
				"15d",
				"16d",
				"17d",
				"18d",
				"19d",
				"20d",
				"21d",
				"22d",
				"23d",
				"24d",
				"25d",
				"26d",
				"27d",
				"28d",
				"29d",
				"30d",
				"31d"
			],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[
				"Yi",
				"Ding",
				"Kao",
				"Qi",
				"Shang",
				"Xia",
				,
				"Wan",
				"Zhang",
				"San",
				"Shang",
				"Xia",
				"Ji",
				"Bu",
				"Yu",
				"Mian",
				"Gai",
				"Chou",
				"Chou",
				"Zhuan",
				"Qie",
				"Pi",
				"Shi",
				"Shi",
				"Qiu",
				"Bing",
				"Ye",
				"Cong",
				"Dong",
				"Si",
				"Cheng",
				"Diu",
				"Qiu",
				"Liang",
				"Diu",
				"You",
				"Liang",
				"Yan",
				"Bing",
				"Sang",
				"Gun",
				"Jiu",
				"Ge",
				"Ya",
				"Qiang",
				"Zhong",
				"Ji",
				"Jie",
				"Feng",
				"Guan",
				"Chuan",
				"Chan",
				"Lin",
				"Zhuo",
				"Zhu",
				"Ha",
				"Wan",
				"Dan",
				"Wei",
				"Zhu",
				"Jing",
				"Li",
				"Ju",
				"Pie",
				"Fu",
				"Yi",
				"Yi",
				"Nai",
				"Shime",
				"Jiu",
				"Jiu",
				"Zhe",
				"Me",
				"Yi",
				,
				"Zhi",
				"Wu",
				"Zha",
				"Hu",
				"Fa",
				"Le",
				"Zhong",
				"Ping",
				"Pang",
				"Qiao",
				"Hu",
				"Guai",
				"Cheng",
				"Cheng",
				"Yi",
				"Yin",
				,
				"Mie",
				"Jiu",
				"Qi",
				"Ye",
				"Xi",
				"Xiang",
				"Gai",
				"Diu",
				"Hal",
				,
				"Shu",
				"Twul",
				"Shi",
				"Ji",
				"Nang",
				"Jia",
				"Kel",
				"Shi",
				,
				"Ol",
				"Mai",
				"Luan",
				"Cal",
				"Ru",
				"Xue",
				"Yan",
				"Fu",
				"Sha",
				"Na",
				"Gan",
				"Sol",
				"El",
				"Cwul",
				,
				"Gan",
				"Chi",
				"Gui",
				"Gan",
				"Luan",
				"Lin",
				"Yi",
				"Jue",
				"Liao",
				"Ma",
				"Yu",
				"Zheng",
				"Shi",
				"Shi",
				"Er",
				"Chu",
				"Yu",
				"Yu",
				"Yu",
				"Yun",
				"Hu",
				"Qi",
				"Wu",
				"Jing",
				"Si",
				"Sui",
				"Gen",
				"Gen",
				"Ya",
				"Xie",
				"Ya",
				"Qi",
				"Ya",
				"Ji",
				"Tou",
				"Wang",
				"Kang",
				"Ta",
				"Jiao",
				"Hai",
				"Yi",
				"Chan",
				"Heng",
				"Mu",
				,
				"Xiang",
				"Jing",
				"Ting",
				"Liang",
				"Xiang",
				"Jing",
				"Ye",
				"Qin",
				"Bo",
				"You",
				"Xie",
				"Dan",
				"Lian",
				"Duo",
				"Wei",
				"Ren",
				"Ren",
				"Ji",
				"La",
				"Wang",
				"Yi",
				"Shi",
				"Ren",
				"Le",
				"Ding",
				"Ze",
				"Jin",
				"Pu",
				"Chou",
				"Ba",
				"Zhang",
				"Jin",
				"Jie",
				"Bing",
				"Reng",
				"Cong",
				"Fo",
				"San",
				"Lun",
				"Sya",
				"Cang",
				"Zi",
				"Shi",
				"Ta",
				"Zhang",
				"Fu",
				"Xian",
				"Xian",
				"Tuo",
				"Hong",
				"Tong",
				"Ren",
				"Qian",
				"Gan",
				"Yi",
				"Di",
				"Dai",
				"Ling",
				"Yi",
				"Chao",
				"Chang",
				"Sa",
				,
				"Yi",
				"Mu",
				"Men",
				"Ren",
				"Jia",
				"Chao",
				"Yang",
				"Qian",
				"Zhong",
				"Pi",
				"Wan",
				"Wu",
				"Jian",
				"Jie",
				"Yao",
				"Feng",
				"Cang",
				"Ren",
				"Wang",
				"Fen",
				"Di",
				"Fang"
			],
			[
				"Zhong",
				"Qi",
				"Pei",
				"Yu",
				"Diao",
				"Dun",
				"Wen",
				"Yi",
				"Xin",
				"Kang",
				"Yi",
				"Ji",
				"Ai",
				"Wu",
				"Ji",
				"Fu",
				"Fa",
				"Xiu",
				"Jin",
				"Bei",
				"Dan",
				"Fu",
				"Tang",
				"Zhong",
				"You",
				"Huo",
				"Hui",
				"Yu",
				"Cui",
				"Chuan",
				"San",
				"Wei",
				"Chuan",
				"Che",
				"Ya",
				"Xian",
				"Shang",
				"Chang",
				"Lun",
				"Cang",
				"Xun",
				"Xin",
				"Wei",
				"Zhu",
				,
				"Xuan",
				"Nu",
				"Bo",
				"Gu",
				"Ni",
				"Ni",
				"Xie",
				"Ban",
				"Xu",
				"Ling",
				"Zhou",
				"Shen",
				"Qu",
				"Si",
				"Beng",
				"Si",
				"Jia",
				"Pi",
				"Yi",
				"Si",
				"Ai",
				"Zheng",
				"Dian",
				"Han",
				"Mai",
				"Dan",
				"Zhu",
				"Bu",
				"Qu",
				"Bi",
				"Shao",
				"Ci",
				"Wei",
				"Di",
				"Zhu",
				"Zuo",
				"You",
				"Yang",
				"Ti",
				"Zhan",
				"He",
				"Bi",
				"Tuo",
				"She",
				"Yu",
				"Yi",
				"Fo",
				"Zuo",
				"Kou",
				"Ning",
				"Tong",
				"Ni",
				"Xuan",
				"Qu",
				"Yong",
				"Wa",
				"Qian",
				,
				"Ka",
				,
				"Pei",
				"Huai",
				"He",
				"Lao",
				"Xiang",
				"Ge",
				"Yang",
				"Bai",
				"Fa",
				"Ming",
				"Jia",
				"Er",
				"Bing",
				"Ji",
				"Hen",
				"Huo",
				"Gui",
				"Quan",
				"Tiao",
				"Jiao",
				"Ci",
				"Yi",
				"Shi",
				"Xing",
				"Shen",
				"Tuo",
				"Kan",
				"Zhi",
				"Gai",
				"Lai",
				"Yi",
				"Chi",
				"Kua",
				"Guang",
				"Li",
				"Yin",
				"Shi",
				"Mi",
				"Zhu",
				"Xu",
				"You",
				"An",
				"Lu",
				"Mou",
				"Er",
				"Lun",
				"Tong",
				"Cha",
				"Chi",
				"Xun",
				"Gong",
				"Zhou",
				"Yi",
				"Ru",
				"Jian",
				"Xia",
				"Jia",
				"Zai",
				"Lu",
				"Ko",
				"Jiao",
				"Zhen",
				"Ce",
				"Qiao",
				"Kuai",
				"Chai",
				"Ning",
				"Nong",
				"Jin",
				"Wu",
				"Hou",
				"Jiong",
				"Cheng",
				"Zhen",
				"Zuo",
				"Chou",
				"Qin",
				"Lu",
				"Ju",
				"Shu",
				"Ting",
				"Shen",
				"Tuo",
				"Bo",
				"Nan",
				"Hao",
				"Bian",
				"Tui",
				"Yu",
				"Xi",
				"Cu",
				"E",
				"Qiu",
				"Xu",
				"Kuang",
				"Ku",
				"Wu",
				"Jun",
				"Yi",
				"Fu",
				"Lang",
				"Zu",
				"Qiao",
				"Li",
				"Yong",
				"Hun",
				"Jing",
				"Xian",
				"San",
				"Pai",
				"Su",
				"Fu",
				"Xi",
				"Li",
				"Fu",
				"Ping",
				"Bao",
				"Yu",
				"Si",
				"Xia",
				"Xin",
				"Xiu",
				"Yu",
				"Ti",
				"Che",
				"Chou",
				,
				"Yan",
				"Lia",
				"Li",
				"Lai",
				,
				"Jian",
				"Xiu",
				"Fu",
				"He",
				"Ju",
				"Xiao",
				"Pai",
				"Jian",
				"Biao",
				"Chu",
				"Fei",
				"Feng",
				"Ya",
				"An",
				"Bei",
				"Yu",
				"Xin",
				"Bi",
				"Jian"
			],
			[
				"Chang",
				"Chi",
				"Bing",
				"Zan",
				"Yao",
				"Cui",
				"Lia",
				"Wan",
				"Lai",
				"Cang",
				"Zong",
				"Ge",
				"Guan",
				"Bei",
				"Tian",
				"Shu",
				"Shu",
				"Men",
				"Dao",
				"Tan",
				"Jue",
				"Chui",
				"Xing",
				"Peng",
				"Tang",
				"Hou",
				"Yi",
				"Qi",
				"Ti",
				"Gan",
				"Jing",
				"Jie",
				"Sui",
				"Chang",
				"Jie",
				"Fang",
				"Zhi",
				"Kong",
				"Juan",
				"Zong",
				"Ju",
				"Qian",
				"Ni",
				"Lun",
				"Zhuo",
				"Wei",
				"Luo",
				"Song",
				"Leng",
				"Hun",
				"Dong",
				"Zi",
				"Ben",
				"Wu",
				"Ju",
				"Nai",
				"Cai",
				"Jian",
				"Zhai",
				"Ye",
				"Zhi",
				"Sha",
				"Qing",
				,
				"Ying",
				"Cheng",
				"Jian",
				"Yan",
				"Nuan",
				"Zhong",
				"Chun",
				"Jia",
				"Jie",
				"Wei",
				"Yu",
				"Bing",
				"Ruo",
				"Ti",
				"Wei",
				"Pian",
				"Yan",
				"Feng",
				"Tang",
				"Wo",
				"E",
				"Xie",
				"Che",
				"Sheng",
				"Kan",
				"Di",
				"Zuo",
				"Cha",
				"Ting",
				"Bei",
				"Ye",
				"Huang",
				"Yao",
				"Zhan",
				"Chou",
				"Yan",
				"You",
				"Jian",
				"Xu",
				"Zha",
				"Ci",
				"Fu",
				"Bi",
				"Zhi",
				"Zong",
				"Mian",
				"Ji",
				"Yi",
				"Xie",
				"Xun",
				"Si",
				"Duan",
				"Ce",
				"Zhen",
				"Ou",
				"Tou",
				"Tou",
				"Bei",
				"Za",
				"Lu",
				"Jie",
				"Wei",
				"Fen",
				"Chang",
				"Gui",
				"Sou",
				"Zhi",
				"Su",
				"Xia",
				"Fu",
				"Yuan",
				"Rong",
				"Li",
				"Ru",
				"Yun",
				"Gou",
				"Ma",
				"Bang",
				"Dian",
				"Tang",
				"Hao",
				"Jie",
				"Xi",
				"Shan",
				"Qian",
				"Jue",
				"Cang",
				"Chu",
				"San",
				"Bei",
				"Xiao",
				"Yong",
				"Yao",
				"Tan",
				"Suo",
				"Yang",
				"Fa",
				"Bing",
				"Jia",
				"Dai",
				"Zai",
				"Tang",
				,
				"Bin",
				"Chu",
				"Nuo",
				"Can",
				"Lei",
				"Cui",
				"Yong",
				"Zao",
				"Zong",
				"Peng",
				"Song",
				"Ao",
				"Chuan",
				"Yu",
				"Zhai",
				"Cou",
				"Shang",
				"Qiang",
				"Jing",
				"Chi",
				"Sha",
				"Han",
				"Zhang",
				"Qing",
				"Yan",
				"Di",
				"Xi",
				"Lu",
				"Bei",
				"Piao",
				"Jin",
				"Lian",
				"Lu",
				"Man",
				"Qian",
				"Xian",
				"Tan",
				"Ying",
				"Dong",
				"Zhuan",
				"Xiang",
				"Shan",
				"Qiao",
				"Jiong",
				"Tui",
				"Zun",
				"Pu",
				"Xi",
				"Lao",
				"Chang",
				"Guang",
				"Liao",
				"Qi",
				"Deng",
				"Chan",
				"Wei",
				"Ji",
				"Fan",
				"Hui",
				"Chuan",
				"Jian",
				"Dan",
				"Jiao",
				"Jiu",
				"Seng",
				"Fen",
				"Xian",
				"Jue",
				"E",
				"Jiao",
				"Jian",
				"Tong",
				"Lin",
				"Bo",
				"Gu",
				,
				"Su",
				"Xian",
				"Jiang",
				"Min",
				"Ye",
				"Jin",
				"Jia",
				"Qiao",
				"Pi",
				"Feng",
				"Zhou",
				"Ai",
				"Sai"
			],
			[
				"Yi",
				"Jun",
				"Nong",
				"Chan",
				"Yi",
				"Dang",
				"Jing",
				"Xuan",
				"Kuai",
				"Jian",
				"Chu",
				"Dan",
				"Jiao",
				"Sha",
				"Zai",
				,
				"Bin",
				"An",
				"Ru",
				"Tai",
				"Chou",
				"Chai",
				"Lan",
				"Ni",
				"Jin",
				"Qian",
				"Meng",
				"Wu",
				"Ning",
				"Qiong",
				"Ni",
				"Chang",
				"Lie",
				"Lei",
				"Lu",
				"Kuang",
				"Bao",
				"Du",
				"Biao",
				"Zan",
				"Zhi",
				"Si",
				"You",
				"Hao",
				"Chen",
				"Chen",
				"Li",
				"Teng",
				"Wei",
				"Long",
				"Chu",
				"Chan",
				"Rang",
				"Shu",
				"Hui",
				"Li",
				"Luo",
				"Zan",
				"Nuo",
				"Tang",
				"Yan",
				"Lei",
				"Nang",
				"Er",
				"Wu",
				"Yun",
				"Zan",
				"Yuan",
				"Xiong",
				"Chong",
				"Zhao",
				"Xiong",
				"Xian",
				"Guang",
				"Dui",
				"Ke",
				"Dui",
				"Mian",
				"Tu",
				"Chang",
				"Er",
				"Dui",
				"Er",
				"Xin",
				"Tu",
				"Si",
				"Yan",
				"Yan",
				"Shi",
				"Shi",
				"Dang",
				"Qian",
				"Dou",
				"Fen",
				"Mao",
				"Shen",
				"Dou",
				"Bai",
				"Jing",
				"Li",
				"Huang",
				"Ru",
				"Wang",
				"Nei",
				"Quan",
				"Liang",
				"Yu",
				"Ba",
				"Gong",
				"Liu",
				"Xi",
				,
				"Lan",
				"Gong",
				"Tian",
				"Guan",
				"Xing",
				"Bing",
				"Qi",
				"Ju",
				"Dian",
				"Zi",
				"Ppwun",
				"Yang",
				"Jian",
				"Shou",
				"Ji",
				"Yi",
				"Ji",
				"Chan",
				"Jiong",
				"Mao",
				"Ran",
				"Nei",
				"Yuan",
				"Mao",
				"Gang",
				"Ran",
				"Ce",
				"Jiong",
				"Ce",
				"Zai",
				"Gua",
				"Jiong",
				"Mao",
				"Zhou",
				"Mou",
				"Gou",
				"Xu",
				"Mian",
				"Mi",
				"Rong",
				"Yin",
				"Xie",
				"Kan",
				"Jun",
				"Nong",
				"Yi",
				"Mi",
				"Shi",
				"Guan",
				"Meng",
				"Zhong",
				"Ju",
				"Yuan",
				"Ming",
				"Kou",
				"Lam",
				"Fu",
				"Xie",
				"Mi",
				"Bing",
				"Dong",
				"Tai",
				"Gang",
				"Feng",
				"Bing",
				"Hu",
				"Chong",
				"Jue",
				"Hu",
				"Kuang",
				"Ye",
				"Leng",
				"Pan",
				"Fu",
				"Min",
				"Dong",
				"Xian",
				"Lie",
				"Xia",
				"Jian",
				"Jing",
				"Shu",
				"Mei",
				"Tu",
				"Qi",
				"Gu",
				"Zhun",
				"Song",
				"Jing",
				"Liang",
				"Qing",
				"Diao",
				"Ling",
				"Dong",
				"Gan",
				"Jian",
				"Yin",
				"Cou",
				"Yi",
				"Li",
				"Cang",
				"Ming",
				"Zhuen",
				"Cui",
				"Si",
				"Duo",
				"Jin",
				"Lin",
				"Lin",
				"Ning",
				"Xi",
				"Du",
				"Ji",
				"Fan",
				"Fan",
				"Fan",
				"Feng",
				"Ju",
				"Chu",
				"Tako",
				"Feng",
				"Mok",
				"Ci",
				"Fu",
				"Feng",
				"Ping",
				"Feng",
				"Kai",
				"Huang",
				"Kai",
				"Gan",
				"Deng",
				"Ping",
				"Qu",
				"Xiong",
				"Kuai",
				"Tu",
				"Ao",
				"Chu",
				"Ji",
				"Dang",
				"Han",
				"Han",
				"Zao"
			],
			[
				"Dao",
				"Diao",
				"Dao",
				"Ren",
				"Ren",
				"Chuang",
				"Fen",
				"Qie",
				"Yi",
				"Ji",
				"Kan",
				"Qian",
				"Cun",
				"Chu",
				"Wen",
				"Ji",
				"Dan",
				"Xing",
				"Hua",
				"Wan",
				"Jue",
				"Li",
				"Yue",
				"Lie",
				"Liu",
				"Ze",
				"Gang",
				"Chuang",
				"Fu",
				"Chu",
				"Qu",
				"Ju",
				"Shan",
				"Min",
				"Ling",
				"Zhong",
				"Pan",
				"Bie",
				"Jie",
				"Jie",
				"Bao",
				"Li",
				"Shan",
				"Bie",
				"Chan",
				"Jing",
				"Gua",
				"Gen",
				"Dao",
				"Chuang",
				"Kui",
				"Ku",
				"Duo",
				"Er",
				"Zhi",
				"Shua",
				"Quan",
				"Cha",
				"Ci",
				"Ke",
				"Jie",
				"Gui",
				"Ci",
				"Gui",
				"Kai",
				"Duo",
				"Ji",
				"Ti",
				"Jing",
				"Lou",
				"Gen",
				"Ze",
				"Yuan",
				"Cuo",
				"Xue",
				"Ke",
				"La",
				"Qian",
				"Cha",
				"Chuang",
				"Gua",
				"Jian",
				"Cuo",
				"Li",
				"Ti",
				"Fei",
				"Pou",
				"Chan",
				"Qi",
				"Chuang",
				"Zi",
				"Gang",
				"Wan",
				"Bo",
				"Ji",
				"Duo",
				"Qing",
				"Yan",
				"Zhuo",
				"Jian",
				"Ji",
				"Bo",
				"Yan",
				"Ju",
				"Huo",
				"Sheng",
				"Jian",
				"Duo",
				"Duan",
				"Wu",
				"Gua",
				"Fu",
				"Sheng",
				"Jian",
				"Ge",
				"Zha",
				"Kai",
				"Chuang",
				"Juan",
				"Chan",
				"Tuan",
				"Lu",
				"Li",
				"Fou",
				"Shan",
				"Piao",
				"Kou",
				"Jiao",
				"Gua",
				"Qiao",
				"Jue",
				"Hua",
				"Zha",
				"Zhuo",
				"Lian",
				"Ju",
				"Pi",
				"Liu",
				"Gui",
				"Jiao",
				"Gui",
				"Jian",
				"Jian",
				"Tang",
				"Huo",
				"Ji",
				"Jian",
				"Yi",
				"Jian",
				"Zhi",
				"Chan",
				"Cuan",
				"Mo",
				"Li",
				"Zhu",
				"Li",
				"Ya",
				"Quan",
				"Ban",
				"Gong",
				"Jia",
				"Wu",
				"Mai",
				"Lie",
				"Jin",
				"Keng",
				"Xie",
				"Zhi",
				"Dong",
				"Zhu",
				"Nu",
				"Jie",
				"Qu",
				"Shao",
				"Yi",
				"Zhu",
				"Miao",
				"Li",
				"Jing",
				"Lao",
				"Lao",
				"Juan",
				"Kou",
				"Yang",
				"Wa",
				"Xiao",
				"Mou",
				"Kuang",
				"Jie",
				"Lie",
				"He",
				"Shi",
				"Ke",
				"Jing",
				"Hao",
				"Bo",
				"Min",
				"Chi",
				"Lang",
				"Yong",
				"Yong",
				"Mian",
				"Ke",
				"Xun",
				"Juan",
				"Qing",
				"Lu",
				"Pou",
				"Meng",
				"Lai",
				"Le",
				"Kai",
				"Mian",
				"Dong",
				"Xu",
				"Xu",
				"Kan",
				"Wu",
				"Yi",
				"Xun",
				"Weng",
				"Sheng",
				"Lao",
				"Mu",
				"Lu",
				"Piao",
				"Shi",
				"Ji",
				"Qin",
				"Qiang",
				"Jiao",
				"Quan",
				"Yang",
				"Yi",
				"Jue",
				"Fan",
				"Juan",
				"Tong",
				"Ju",
				"Dan",
				"Xie",
				"Mai",
				"Xun",
				"Xun",
				"Lu",
				"Li",
				"Che",
				"Rang",
				"Quan",
				"Bao",
				"Shao",
				"Yun",
				"Jiu",
				"Bao",
				"Gou",
				"Wu"
			],
			[
				"Yun",
				"Mwun",
				"Nay",
				"Gai",
				"Gai",
				"Bao",
				"Cong",
				,
				"Xiong",
				"Peng",
				"Ju",
				"Tao",
				"Ge",
				"Pu",
				"An",
				"Pao",
				"Fu",
				"Gong",
				"Da",
				"Jiu",
				"Qiong",
				"Bi",
				"Hua",
				"Bei",
				"Nao",
				"Chi",
				"Fang",
				"Jiu",
				"Yi",
				"Za",
				"Jiang",
				"Kang",
				"Jiang",
				"Kuang",
				"Hu",
				"Xia",
				"Qu",
				"Bian",
				"Gui",
				"Qie",
				"Zang",
				"Kuang",
				"Fei",
				"Hu",
				"Tou",
				"Gui",
				"Gui",
				"Hui",
				"Dan",
				"Gui",
				"Lian",
				"Lian",
				"Suan",
				"Du",
				"Jiu",
				"Qu",
				"Xi",
				"Pi",
				"Qu",
				"Yi",
				"Qia",
				"Yan",
				"Bian",
				"Ni",
				"Qu",
				"Shi",
				"Xin",
				"Qian",
				"Nian",
				"Sa",
				"Zu",
				"Sheng",
				"Wu",
				"Hui",
				"Ban",
				"Shi",
				"Xi",
				"Wan",
				"Hua",
				"Xie",
				"Wan",
				"Bei",
				"Zu",
				"Zhuo",
				"Xie",
				"Dan",
				"Mai",
				"Nan",
				"Dan",
				"Ji",
				"Bo",
				"Shuai",
				"Bu",
				"Kuang",
				"Bian",
				"Bu",
				"Zhan",
				"Qia",
				"Lu",
				"You",
				"Lu",
				"Xi",
				"Gua",
				"Wo",
				"Xie",
				"Jie",
				"Jie",
				"Wei",
				"Ang",
				"Qiong",
				"Zhi",
				"Mao",
				"Yin",
				"Wei",
				"Shao",
				"Ji",
				"Que",
				"Luan",
				"Shi",
				"Juan",
				"Xie",
				"Xu",
				"Jin",
				"Que",
				"Wu",
				"Ji",
				"E",
				"Qing",
				"Xi",
				,
				"Han",
				"Zhan",
				"E",
				"Ting",
				"Li",
				"Zhe",
				"Han",
				"Li",
				"Ya",
				"Ya",
				"Yan",
				"She",
				"Zhi",
				"Zha",
				"Pang",
				,
				"He",
				"Ya",
				"Zhi",
				"Ce",
				"Pang",
				"Ti",
				"Li",
				"She",
				"Hou",
				"Ting",
				"Zui",
				"Cuo",
				"Fei",
				"Yuan",
				"Ce",
				"Yuan",
				"Xiang",
				"Yan",
				"Li",
				"Jue",
				"Sha",
				"Dian",
				"Chu",
				"Jiu",
				"Qin",
				"Ao",
				"Gui",
				"Yan",
				"Si",
				"Li",
				"Chang",
				"Lan",
				"Li",
				"Yan",
				"Yan",
				"Yuan",
				"Si",
				"Gong",
				"Lin",
				"Qiu",
				"Qu",
				"Qu",
				"Uk",
				"Lei",
				"Du",
				"Xian",
				"Zhuan",
				"San",
				"Can",
				"Can",
				"Can",
				"Can",
				"Ai",
				"Dai",
				"You",
				"Cha",
				"Ji",
				"You",
				"Shuang",
				"Fan",
				"Shou",
				"Guai",
				"Ba",
				"Fa",
				"Ruo",
				"Shi",
				"Shu",
				"Zhuo",
				"Qu",
				"Shou",
				"Bian",
				"Xu",
				"Jia",
				"Pan",
				"Sou",
				"Gao",
				"Wei",
				"Sou",
				"Die",
				"Rui",
				"Cong",
				"Kou",
				"Gu",
				"Ju",
				"Ling",
				"Gua",
				"Tao",
				"Kou",
				"Zhi",
				"Jiao",
				"Zhao",
				"Ba",
				"Ding",
				"Ke",
				"Tai",
				"Chi",
				"Shi",
				"You",
				"Qiu",
				"Po",
				"Ye",
				"Hao",
				"Si",
				"Tan",
				"Chi",
				"Le",
				"Diao",
				"Ji",
				,
				"Hong"
			],
			[
				"Mie",
				"Xu",
				"Mang",
				"Chi",
				"Ge",
				"Xuan",
				"Yao",
				"Zi",
				"He",
				"Ji",
				"Diao",
				"Cun",
				"Tong",
				"Ming",
				"Hou",
				"Li",
				"Tu",
				"Xiang",
				"Zha",
				"Xia",
				"Ye",
				"Lu",
				"A",
				"Ma",
				"Ou",
				"Xue",
				"Yi",
				"Jun",
				"Chou",
				"Lin",
				"Tun",
				"Yin",
				"Fei",
				"Bi",
				"Qin",
				"Qin",
				"Jie",
				"Bu",
				"Fou",
				"Ba",
				"Dun",
				"Fen",
				"E",
				"Han",
				"Ting",
				"Hang",
				"Shun",
				"Qi",
				"Hong",
				"Zhi",
				"Shen",
				"Wu",
				"Wu",
				"Chao",
				"Ne",
				"Xue",
				"Xi",
				"Chui",
				"Dou",
				"Wen",
				"Hou",
				"Ou",
				"Wu",
				"Gao",
				"Ya",
				"Jun",
				"Lu",
				"E",
				"Ge",
				"Mei",
				"Ai",
				"Qi",
				"Cheng",
				"Wu",
				"Gao",
				"Fu",
				"Jiao",
				"Hong",
				"Chi",
				"Sheng",
				"Ne",
				"Tun",
				"Fu",
				"Yi",
				"Dai",
				"Ou",
				"Li",
				"Bai",
				"Yuan",
				"Kuai",
				,
				"Qiang",
				"Wu",
				"E",
				"Shi",
				"Quan",
				"Pen",
				"Wen",
				"Ni",
				"M",
				"Ling",
				"Ran",
				"You",
				"Di",
				"Zhou",
				"Shi",
				"Zhou",
				"Tie",
				"Xi",
				"Yi",
				"Qi",
				"Ping",
				"Zi",
				"Gu",
				"Zi",
				"Wei",
				"Xu",
				"He",
				"Nao",
				"Xia",
				"Pei",
				"Yi",
				"Xiao",
				"Shen",
				"Hu",
				"Ming",
				"Da",
				"Qu",
				"Ju",
				"Gem",
				"Za",
				"Tuo",
				"Duo",
				"Pou",
				"Pao",
				"Bi",
				"Fu",
				"Yang",
				"He",
				"Zha",
				"He",
				"Hai",
				"Jiu",
				"Yong",
				"Fu",
				"Que",
				"Zhou",
				"Wa",
				"Ka",
				"Gu",
				"Ka",
				"Zuo",
				"Bu",
				"Long",
				"Dong",
				"Ning",
				"Tha",
				"Si",
				"Xian",
				"Huo",
				"Qi",
				"Er",
				"E",
				"Guang",
				"Zha",
				"Xi",
				"Yi",
				"Lie",
				"Zi",
				"Mie",
				"Mi",
				"Zhi",
				"Yao",
				"Ji",
				"Zhou",
				"Ge",
				"Shuai",
				"Zan",
				"Xiao",
				"Ke",
				"Hui",
				"Kua",
				"Huai",
				"Tao",
				"Xian",
				"E",
				"Xuan",
				"Xiu",
				"Wai",
				"Yan",
				"Lao",
				"Yi",
				"Ai",
				"Pin",
				"Shen",
				"Tong",
				"Hong",
				"Xiong",
				"Chi",
				"Wa",
				"Ha",
				"Zai",
				"Yu",
				"Di",
				"Pai",
				"Xiang",
				"Ai",
				"Hen",
				"Kuang",
				"Ya",
				"Da",
				"Xiao",
				"Bi",
				"Yue",
				,
				"Hua",
				"Sasou",
				"Kuai",
				"Duo",
				,
				"Ji",
				"Nong",
				"Mou",
				"Yo",
				"Hao",
				"Yuan",
				"Long",
				"Pou",
				"Mang",
				"Ge",
				"E",
				"Chi",
				"Shao",
				"Li",
				"Na",
				"Zu",
				"He",
				"Ku",
				"Xiao",
				"Xian",
				"Lao",
				"Bo",
				"Zhe",
				"Zha",
				"Liang",
				"Ba",
				"Mie",
				"Le",
				"Sui",
				"Fou",
				"Bu",
				"Han",
				"Heng",
				"Geng",
				"Shuo",
				"Ge"
			],
			[
				"You",
				"Yan",
				"Gu",
				"Gu",
				"Bai",
				"Han",
				"Suo",
				"Chun",
				"Yi",
				"Ai",
				"Jia",
				"Tu",
				"Xian",
				"Huan",
				"Li",
				"Xi",
				"Tang",
				"Zuo",
				"Qiu",
				"Che",
				"Wu",
				"Zao",
				"Ya",
				"Dou",
				"Qi",
				"Di",
				"Qin",
				"Ma",
				"Mal",
				"Hong",
				"Dou",
				"Kes",
				"Lao",
				"Liang",
				"Suo",
				"Zao",
				"Huan",
				"Lang",
				"Sha",
				"Ji",
				"Zuo",
				"Wo",
				"Feng",
				"Yin",
				"Hu",
				"Qi",
				"Shou",
				"Wei",
				"Shua",
				"Chang",
				"Er",
				"Li",
				"Qiang",
				"An",
				"Jie",
				"Yo",
				"Nian",
				"Yu",
				"Tian",
				"Lai",
				"Sha",
				"Xi",
				"Tuo",
				"Hu",
				"Ai",
				"Zhou",
				"Nou",
				"Ken",
				"Zhuo",
				"Zhuo",
				"Shang",
				"Di",
				"Heng",
				"Lan",
				"A",
				"Xiao",
				"Xiang",
				"Tun",
				"Wu",
				"Wen",
				"Cui",
				"Sha",
				"Hu",
				"Qi",
				"Qi",
				"Tao",
				"Dan",
				"Dan",
				"Ye",
				"Zi",
				"Bi",
				"Cui",
				"Chuo",
				"He",
				"Ya",
				"Qi",
				"Zhe",
				"Pei",
				"Liang",
				"Xian",
				"Pi",
				"Sha",
				"La",
				"Ze",
				"Qing",
				"Gua",
				"Pa",
				"Zhe",
				"Se",
				"Zhuan",
				"Nie",
				"Guo",
				"Luo",
				"Yan",
				"Di",
				"Quan",
				"Tan",
				"Bo",
				"Ding",
				"Lang",
				"Xiao",
				,
				"Tang",
				"Chi",
				"Ti",
				"An",
				"Jiu",
				"Dan",
				"Ke",
				"Yong",
				"Wei",
				"Nan",
				"Shan",
				"Yu",
				"Zhe",
				"La",
				"Jie",
				"Hou",
				"Han",
				"Die",
				"Zhou",
				"Chai",
				"Wai",
				"Re",
				"Yu",
				"Yin",
				"Zan",
				"Yao",
				"Wo",
				"Mian",
				"Hu",
				"Yun",
				"Chuan",
				"Hui",
				"Huan",
				"Huan",
				"Xi",
				"He",
				"Ji",
				"Kui",
				"Zhong",
				"Wei",
				"Sha",
				"Xu",
				"Huang",
				"Du",
				"Nie",
				"Xuan",
				"Liang",
				"Yu",
				"Sang",
				"Chi",
				"Qiao",
				"Yan",
				"Dan",
				"Pen",
				"Can",
				"Li",
				"Yo",
				"Zha",
				"Wei",
				"Miao",
				"Ying",
				"Pen",
				"Phos",
				"Kui",
				"Xi",
				"Yu",
				"Jie",
				"Lou",
				"Ku",
				"Sao",
				"Huo",
				"Ti",
				"Yao",
				"He",
				"A",
				"Xiu",
				"Qiang",
				"Se",
				"Yong",
				"Su",
				"Hong",
				"Xie",
				"Yi",
				"Suo",
				"Ma",
				"Cha",
				"Hai",
				"Ke",
				"Ta",
				"Sang",
				"Tian",
				"Ru",
				"Sou",
				"Wa",
				"Ji",
				"Pang",
				"Wu",
				"Xian",
				"Shi",
				"Ge",
				"Zi",
				"Jie",
				"Luo",
				"Weng",
				"Wa",
				"Si",
				"Chi",
				"Hao",
				"Suo",
				"Jia",
				"Hai",
				"Suo",
				"Qin",
				"Nie",
				"He",
				"Cis",
				"Sai",
				"Ng",
				"Ge",
				"Na",
				"Dia",
				"Ai",
				,
				"Tong",
				"Bi",
				"Ao",
				"Ao",
				"Lian",
				"Cui",
				"Zhe",
				"Mo",
				"Sou",
				"Sou",
				"Tan"
			],
			[
				"Di",
				"Qi",
				"Jiao",
				"Chong",
				"Jiao",
				"Kai",
				"Tan",
				"San",
				"Cao",
				"Jia",
				"Ai",
				"Xiao",
				"Piao",
				"Lou",
				"Ga",
				"Gu",
				"Xiao",
				"Hu",
				"Hui",
				"Guo",
				"Ou",
				"Xian",
				"Ze",
				"Chang",
				"Xu",
				"Po",
				"De",
				"Ma",
				"Ma",
				"Hu",
				"Lei",
				"Du",
				"Ga",
				"Tang",
				"Ye",
				"Beng",
				"Ying",
				"Saai",
				"Jiao",
				"Mi",
				"Xiao",
				"Hua",
				"Mai",
				"Ran",
				"Zuo",
				"Peng",
				"Lao",
				"Xiao",
				"Ji",
				"Zhu",
				"Chao",
				"Kui",
				"Zui",
				"Xiao",
				"Si",
				"Hao",
				"Fu",
				"Liao",
				"Qiao",
				"Xi",
				"Xiu",
				"Tan",
				"Tan",
				"Mo",
				"Xun",
				"E",
				"Zun",
				"Fan",
				"Chi",
				"Hui",
				"Zan",
				"Chuang",
				"Cu",
				"Dan",
				"Yu",
				"Tun",
				"Cheng",
				"Jiao",
				"Ye",
				"Xi",
				"Qi",
				"Hao",
				"Lian",
				"Xu",
				"Deng",
				"Hui",
				"Yin",
				"Pu",
				"Jue",
				"Qin",
				"Xun",
				"Nie",
				"Lu",
				"Si",
				"Yan",
				"Ying",
				"Da",
				"Dan",
				"Yu",
				"Zhou",
				"Jin",
				"Nong",
				"Yue",
				"Hui",
				"Qi",
				"E",
				"Zao",
				"Yi",
				"Shi",
				"Jiao",
				"Yuan",
				"Ai",
				"Yong",
				"Jue",
				"Kuai",
				"Yu",
				"Pen",
				"Dao",
				"Ge",
				"Xin",
				"Dun",
				"Dang",
				"Sin",
				"Sai",
				"Pi",
				"Pi",
				"Yin",
				"Zui",
				"Ning",
				"Di",
				"Lan",
				"Ta",
				"Huo",
				"Ru",
				"Hao",
				"Xia",
				"Ya",
				"Duo",
				"Xi",
				"Chou",
				"Ji",
				"Jin",
				"Hao",
				"Ti",
				"Chang",
				,
				,
				"Ca",
				"Ti",
				"Lu",
				"Hui",
				"Bo",
				"You",
				"Nie",
				"Yin",
				"Hu",
				"Mo",
				"Huang",
				"Zhe",
				"Li",
				"Liu",
				"Haai",
				"Nang",
				"Xiao",
				"Mo",
				"Yan",
				"Li",
				"Lu",
				"Long",
				"Fu",
				"Dan",
				"Chen",
				"Pin",
				"Pi",
				"Xiang",
				"Huo",
				"Mo",
				"Xi",
				"Duo",
				"Ku",
				"Yan",
				"Chan",
				"Ying",
				"Rang",
				"Dian",
				"La",
				"Ta",
				"Xiao",
				"Jiao",
				"Chuo",
				"Huan",
				"Huo",
				"Zhuan",
				"Nie",
				"Xiao",
				"Ca",
				"Li",
				"Chan",
				"Chai",
				"Li",
				"Yi",
				"Luo",
				"Nang",
				"Zan",
				"Su",
				"Xi",
				"So",
				"Jian",
				"Za",
				"Zhu",
				"Lan",
				"Nie",
				"Nang",
				,
				,
				"Wei",
				"Hui",
				"Yin",
				"Qiu",
				"Si",
				"Nin",
				"Jian",
				"Hui",
				"Xin",
				"Yin",
				"Nan",
				"Tuan",
				"Tuan",
				"Dun",
				"Kang",
				"Yuan",
				"Jiong",
				"Pian",
				"Yun",
				"Cong",
				"Hu",
				"Hui",
				"Yuan",
				"You",
				"Guo",
				"Kun",
				"Cong",
				"Wei",
				"Tu",
				"Wei",
				"Lun",
				"Guo",
				"Qun",
				"Ri",
				"Ling",
				"Gu",
				"Guo",
				"Tai",
				"Guo",
				"Tu",
				"You"
			],
			[
				"Guo",
				"Yin",
				"Hun",
				"Pu",
				"Yu",
				"Han",
				"Yuan",
				"Lun",
				"Quan",
				"Yu",
				"Qing",
				"Guo",
				"Chuan",
				"Wei",
				"Yuan",
				"Quan",
				"Ku",
				"Fu",
				"Yuan",
				"Yuan",
				"E",
				"Tu",
				"Tu",
				"Tu",
				"Tuan",
				"Lue",
				"Hui",
				"Yi",
				"Yuan",
				"Luan",
				"Luan",
				"Tu",
				"Ya",
				"Tu",
				"Ting",
				"Sheng",
				"Pu",
				"Lu",
				"Iri",
				"Ya",
				"Zai",
				"Wei",
				"Ge",
				"Yu",
				"Wu",
				"Gui",
				"Pi",
				"Yi",
				"Di",
				"Qian",
				"Qian",
				"Zhen",
				"Zhuo",
				"Dang",
				"Qia",
				"Akutsu",
				"Yama",
				"Kuang",
				"Chang",
				"Qi",
				"Nie",
				"Mo",
				"Ji",
				"Jia",
				"Zhi",
				"Zhi",
				"Ban",
				"Xun",
				"Tou",
				"Qin",
				"Fen",
				"Jun",
				"Keng",
				"Tun",
				"Fang",
				"Fen",
				"Ben",
				"Tan",
				"Kan",
				"Pi",
				"Zuo",
				"Keng",
				"Bi",
				"Xing",
				"Di",
				"Jing",
				"Ji",
				"Kuai",
				"Di",
				"Jing",
				"Jian",
				"Tan",
				"Li",
				"Ba",
				"Wu",
				"Fen",
				"Zhui",
				"Po",
				"Pan",
				"Tang",
				"Kun",
				"Qu",
				"Tan",
				"Zhi",
				"Tuo",
				"Gan",
				"Ping",
				"Dian",
				"Gua",
				"Ni",
				"Tai",
				"Pi",
				"Jiong",
				"Yang",
				"Fo",
				"Ao",
				"Liu",
				"Qiu",
				"Mu",
				"Ke",
				"Gou",
				"Xue",
				"Ba",
				"Chi",
				"Che",
				"Ling",
				"Zhu",
				"Fu",
				"Hu",
				"Zhi",
				"Chui",
				"La",
				"Long",
				"Long",
				"Lu",
				"Ao",
				"Tay",
				"Pao",
				,
				"Xing",
				"Dong",
				"Ji",
				"Ke",
				"Lu",
				"Ci",
				"Chi",
				"Lei",
				"Gai",
				"Yin",
				"Hou",
				"Dui",
				"Zhao",
				"Fu",
				"Guang",
				"Yao",
				"Duo",
				"Duo",
				"Gui",
				"Cha",
				"Yang",
				"Yin",
				"Fa",
				"Gou",
				"Yuan",
				"Die",
				"Xie",
				"Ken",
				"Jiong",
				"Shou",
				"E",
				"Ha",
				"Dian",
				"Hong",
				"Wu",
				"Kua",
				,
				"Tao",
				"Dang",
				"Kai",
				"Gake",
				"Nao",
				"An",
				"Xing",
				"Xian",
				"Huan",
				"Bang",
				"Pei",
				"Ba",
				"Yi",
				"Yin",
				"Han",
				"Xu",
				"Chui",
				"Cen",
				"Geng",
				"Ai",
				"Peng",
				"Fang",
				"Que",
				"Yong",
				"Xun",
				"Jia",
				"Di",
				"Mai",
				"Lang",
				"Xuan",
				"Cheng",
				"Yan",
				"Jin",
				"Zhe",
				"Lei",
				"Lie",
				"Bu",
				"Cheng",
				"Gomi",
				"Bu",
				"Shi",
				"Xun",
				"Guo",
				"Jiong",
				"Ye",
				"Nian",
				"Di",
				"Yu",
				"Bu",
				"Ya",
				"Juan",
				"Sui",
				"Pi",
				"Cheng",
				"Wan",
				"Ju",
				"Lun",
				"Zheng",
				"Kong",
				"Chong",
				"Dong",
				"Dai",
				"Tan",
				"An",
				"Cai",
				"Shu",
				"Beng",
				"Kan",
				"Zhi",
				"Duo",
				"Yi",
				"Zhi",
				"Yi",
				"Pei",
				"Ji",
				"Zhun",
				"Qi",
				"Sao",
				"Ju",
				"Ni"
			],
			[
				"Ku",
				"Ke",
				"Tang",
				"Kun",
				"Ni",
				"Jian",
				"Dui",
				"Jin",
				"Gang",
				"Yu",
				"E",
				"Peng",
				"Gu",
				"Tu",
				"Leng",
				,
				"Ya",
				"Qian",
				,
				"An",
				,
				"Duo",
				"Nao",
				"Tu",
				"Cheng",
				"Yin",
				"Hun",
				"Bi",
				"Lian",
				"Guo",
				"Die",
				"Zhuan",
				"Hou",
				"Bao",
				"Bao",
				"Yu",
				"Di",
				"Mao",
				"Jie",
				"Ruan",
				"E",
				"Geng",
				"Kan",
				"Zong",
				"Yu",
				"Huang",
				"E",
				"Yao",
				"Yan",
				"Bao",
				"Ji",
				"Mei",
				"Chang",
				"Du",
				"Tuo",
				"Yin",
				"Feng",
				"Zhong",
				"Jie",
				"Zhen",
				"Feng",
				"Gang",
				"Chuan",
				"Jian",
				"Pyeng",
				"Toride",
				"Xiang",
				"Huang",
				"Leng",
				"Duan",
				,
				"Xuan",
				"Ji",
				"Ji",
				"Kuai",
				"Ying",
				"Ta",
				"Cheng",
				"Yong",
				"Kai",
				"Su",
				"Su",
				"Shi",
				"Mi",
				"Ta",
				"Weng",
				"Cheng",
				"Tu",
				"Tang",
				"Que",
				"Zhong",
				"Li",
				"Peng",
				"Bang",
				"Sai",
				"Zang",
				"Dui",
				"Tian",
				"Wu",
				"Cheng",
				"Xun",
				"Ge",
				"Zhen",
				"Ai",
				"Gong",
				"Yan",
				"Kan",
				"Tian",
				"Yuan",
				"Wen",
				"Xie",
				"Liu",
				"Ama",
				"Lang",
				"Chang",
				"Peng",
				"Beng",
				"Chen",
				"Cu",
				"Lu",
				"Ou",
				"Qian",
				"Mei",
				"Mo",
				"Zhuan",
				"Shuang",
				"Shu",
				"Lou",
				"Chi",
				"Man",
				"Biao",
				"Jing",
				"Qi",
				"Shu",
				"Di",
				"Zhang",
				"Kan",
				"Yong",
				"Dian",
				"Chen",
				"Zhi",
				"Xi",
				"Guo",
				"Qiang",
				"Jin",
				"Di",
				"Shang",
				"Mu",
				"Cui",
				"Yan",
				"Ta",
				"Zeng",
				"Qi",
				"Qiang",
				"Liang",
				,
				"Zhui",
				"Qiao",
				"Zeng",
				"Xu",
				"Shan",
				"Shan",
				"Ba",
				"Pu",
				"Kuai",
				"Dong",
				"Fan",
				"Que",
				"Mo",
				"Dun",
				"Dun",
				"Dun",
				"Di",
				"Sheng",
				"Duo",
				"Duo",
				"Tan",
				"Deng",
				"Wu",
				"Fen",
				"Huang",
				"Tan",
				"Da",
				"Ye",
				"Sho",
				"Mama",
				"Yu",
				"Qiang",
				"Ji",
				"Qiao",
				"Ken",
				"Yi",
				"Pi",
				"Bi",
				"Dian",
				"Jiang",
				"Ye",
				"Yong",
				"Bo",
				"Tan",
				"Lan",
				"Ju",
				"Huai",
				"Dang",
				"Rang",
				"Qian",
				"Xun",
				"Lan",
				"Xi",
				"He",
				"Ai",
				"Ya",
				"Dao",
				"Hao",
				"Ruan",
				"Mama",
				"Lei",
				"Kuang",
				"Lu",
				"Yan",
				"Tan",
				"Wei",
				"Huai",
				"Long",
				"Long",
				"Rui",
				"Li",
				"Lin",
				"Rang",
				"Ten",
				"Xun",
				"Yan",
				"Lei",
				"Ba",
				,
				"Shi",
				"Ren",
				,
				"Zhuang",
				"Zhuang",
				"Sheng",
				"Yi",
				"Mai",
				"Ke",
				"Zhu",
				"Zhuang",
				"Hu",
				"Hu",
				"Kun",
				"Yi",
				"Hu",
				"Xu",
				"Kun",
				"Shou",
				"Mang",
				"Zun"
			],
			[
				"Shou",
				"Yi",
				"Zhi",
				"Gu",
				"Chu",
				"Jiang",
				"Feng",
				"Bei",
				"Cay",
				"Bian",
				"Sui",
				"Qun",
				"Ling",
				"Fu",
				"Zuo",
				"Xia",
				"Xiong",
				,
				"Nao",
				"Xia",
				"Kui",
				"Xi",
				"Wai",
				"Yuan",
				"Mao",
				"Su",
				"Duo",
				"Duo",
				"Ye",
				"Qing",
				"Uys",
				"Gou",
				"Gou",
				"Qi",
				"Meng",
				"Meng",
				"Yin",
				"Huo",
				"Chen",
				"Da",
				"Ze",
				"Tian",
				"Tai",
				"Fu",
				"Guai",
				"Yao",
				"Yang",
				"Hang",
				"Gao",
				"Shi",
				"Ben",
				"Tai",
				"Tou",
				"Yan",
				"Bi",
				"Yi",
				"Kua",
				"Jia",
				"Duo",
				"Kwu",
				"Kuang",
				"Yun",
				"Jia",
				"Pa",
				"En",
				"Lian",
				"Huan",
				"Di",
				"Yan",
				"Pao",
				"Quan",
				"Qi",
				"Nai",
				"Feng",
				"Xie",
				"Fen",
				"Dian",
				,
				"Kui",
				"Zou",
				"Huan",
				"Qi",
				"Kai",
				"Zha",
				"Ben",
				"Yi",
				"Jiang",
				"Tao",
				"Zang",
				"Ben",
				"Xi",
				"Xiang",
				"Fei",
				"Diao",
				"Xun",
				"Keng",
				"Dian",
				"Ao",
				"She",
				"Weng",
				"Pan",
				"Ao",
				"Wu",
				"Ao",
				"Jiang",
				"Lian",
				"Duo",
				"Yun",
				"Jiang",
				"Shi",
				"Fen",
				"Huo",
				"Bi",
				"Lian",
				"Duo",
				"Nu",
				"Nu",
				"Ding",
				"Nai",
				"Qian",
				"Jian",
				"Ta",
				"Jiu",
				"Nan",
				"Cha",
				"Hao",
				"Xian",
				"Fan",
				"Ji",
				"Shuo",
				"Ru",
				"Fei",
				"Wang",
				"Hong",
				"Zhuang",
				"Fu",
				"Ma",
				"Dan",
				"Ren",
				"Fu",
				"Jing",
				"Yan",
				"Xie",
				"Wen",
				"Zhong",
				"Pa",
				"Du",
				"Ji",
				"Keng",
				"Zhong",
				"Yao",
				"Jin",
				"Yun",
				"Miao",
				"Pei",
				"Shi",
				"Yue",
				"Zhuang",
				"Niu",
				"Yan",
				"Na",
				"Xin",
				"Fen",
				"Bi",
				"Yu",
				"Tuo",
				"Feng",
				"Yuan",
				"Fang",
				"Wu",
				"Yu",
				"Gui",
				"Du",
				"Ba",
				"Ni",
				"Zhou",
				"Zhuo",
				"Zhao",
				"Da",
				"Nai",
				"Yuan",
				"Tou",
				"Xuan",
				"Zhi",
				"E",
				"Mei",
				"Mo",
				"Qi",
				"Bi",
				"Shen",
				"Qie",
				"E",
				"He",
				"Xu",
				"Fa",
				"Zheng",
				"Min",
				"Ban",
				"Mu",
				"Fu",
				"Ling",
				"Zi",
				"Zi",
				"Shi",
				"Ran",
				"Shan",
				"Yang",
				"Man",
				"Jie",
				"Gu",
				"Si",
				"Xing",
				"Wei",
				"Zi",
				"Ju",
				"Shan",
				"Pin",
				"Ren",
				"Yao",
				"Tong",
				"Jiang",
				"Shu",
				"Ji",
				"Gai",
				"Shang",
				"Kuo",
				"Juan",
				"Jiao",
				"Gou",
				"Mu",
				"Jian",
				"Jian",
				"Yi",
				"Nian",
				"Zhi",
				"Ji",
				"Ji",
				"Xian",
				"Heng",
				"Guang",
				"Jun",
				"Kua",
				"Yan",
				"Ming",
				"Lie",
				"Pei",
				"Yan",
				"You",
				"Yan",
				"Cha",
				"Shen",
				"Yin",
				"Chi",
				"Gui",
				"Quan",
				"Zi"
			],
			[
				"Song",
				"Wei",
				"Hong",
				"Wa",
				"Lou",
				"Ya",
				"Rao",
				"Jiao",
				"Luan",
				"Ping",
				"Xian",
				"Shao",
				"Li",
				"Cheng",
				"Xiao",
				"Mang",
				"Fu",
				"Suo",
				"Wu",
				"Wei",
				"Ke",
				"Lai",
				"Chuo",
				"Ding",
				"Niang",
				"Xing",
				"Nan",
				"Yu",
				"Nuo",
				"Pei",
				"Nei",
				"Juan",
				"Shen",
				"Zhi",
				"Han",
				"Di",
				"Zhuang",
				"E",
				"Pin",
				"Tui",
				"Han",
				"Mian",
				"Wu",
				"Yan",
				"Wu",
				"Xi",
				"Yan",
				"Yu",
				"Si",
				"Yu",
				"Wa",
				,
				"Xian",
				"Ju",
				"Qu",
				"Shui",
				"Qi",
				"Xian",
				"Zhui",
				"Dong",
				"Chang",
				"Lu",
				"Ai",
				"E",
				"E",
				"Lou",
				"Mian",
				"Cong",
				"Pou",
				"Ju",
				"Po",
				"Cai",
				"Ding",
				"Wan",
				"Biao",
				"Xiao",
				"Shu",
				"Qi",
				"Hui",
				"Fu",
				"E",
				"Wo",
				"Tan",
				"Fei",
				"Wei",
				"Jie",
				"Tian",
				"Ni",
				"Quan",
				"Jing",
				"Hun",
				"Jing",
				"Qian",
				"Dian",
				"Xing",
				"Hu",
				"Wa",
				"Lai",
				"Bi",
				"Yin",
				"Chou",
				"Chuo",
				"Fu",
				"Jing",
				"Lun",
				"Yan",
				"Lan",
				"Kun",
				"Yin",
				"Ya",
				"Ju",
				"Li",
				"Dian",
				"Xian",
				"Hwa",
				"Hua",
				"Ying",
				"Chan",
				"Shen",
				"Ting",
				"Dang",
				"Yao",
				"Wu",
				"Nan",
				"Ruo",
				"Jia",
				"Tou",
				"Xu",
				"Yu",
				"Wei",
				"Ti",
				"Rou",
				"Mei",
				"Dan",
				"Ruan",
				"Qin",
				"Hui",
				"Wu",
				"Qian",
				"Chun",
				"Mao",
				"Fu",
				"Jie",
				"Duan",
				"Xi",
				"Zhong",
				"Mei",
				"Huang",
				"Mian",
				"An",
				"Ying",
				"Xuan",
				"Jie",
				"Wei",
				"Mei",
				"Yuan",
				"Zhen",
				"Qiu",
				"Ti",
				"Xie",
				"Tuo",
				"Lian",
				"Mao",
				"Ran",
				"Si",
				"Pian",
				"Wei",
				"Wa",
				"Jiu",
				"Hu",
				"Ao",
				,
				"Bou",
				"Xu",
				"Tou",
				"Gui",
				"Zou",
				"Yao",
				"Pi",
				"Xi",
				"Yuan",
				"Ying",
				"Rong",
				"Ru",
				"Chi",
				"Liu",
				"Mei",
				"Pan",
				"Ao",
				"Ma",
				"Gou",
				"Kui",
				"Qin",
				"Jia",
				"Sao",
				"Zhen",
				"Yuan",
				"Cha",
				"Yong",
				"Ming",
				"Ying",
				"Ji",
				"Su",
				"Niao",
				"Xian",
				"Tao",
				"Pang",
				"Lang",
				"Nao",
				"Bao",
				"Ai",
				"Pi",
				"Pin",
				"Yi",
				"Piao",
				"Yu",
				"Lei",
				"Xuan",
				"Man",
				"Yi",
				"Zhang",
				"Kang",
				"Yong",
				"Ni",
				"Li",
				"Di",
				"Gui",
				"Yan",
				"Jin",
				"Zhuan",
				"Chang",
				"Ce",
				"Han",
				"Nen",
				"Lao",
				"Mo",
				"Zhe",
				"Hu",
				"Hu",
				"Ao",
				"Nen",
				"Qiang",
				"Ma",
				"Pie",
				"Gu",
				"Wu",
				"Jiao",
				"Tuo",
				"Zhan",
				"Mao",
				"Xian",
				"Xian",
				"Mo",
				"Liao",
				"Lian",
				"Hua"
			],
			[
				"Gui",
				"Deng",
				"Zhi",
				"Xu",
				"Yi",
				"Hua",
				"Xi",
				"Hui",
				"Rao",
				"Xi",
				"Yan",
				"Chan",
				"Jiao",
				"Mei",
				"Fan",
				"Fan",
				"Xian",
				"Yi",
				"Wei",
				"Jiao",
				"Fu",
				"Shi",
				"Bi",
				"Shan",
				"Sui",
				"Qiang",
				"Lian",
				"Huan",
				"Xin",
				"Niao",
				"Dong",
				"Yi",
				"Can",
				"Ai",
				"Niang",
				"Neng",
				"Ma",
				"Tiao",
				"Chou",
				"Jin",
				"Ci",
				"Yu",
				"Pin",
				"Yong",
				"Xu",
				"Nai",
				"Yan",
				"Tai",
				"Ying",
				"Can",
				"Niao",
				"Wo",
				"Ying",
				"Mian",
				"Kaka",
				"Ma",
				"Shen",
				"Xing",
				"Ni",
				"Du",
				"Liu",
				"Yuan",
				"Lan",
				"Yan",
				"Shuang",
				"Ling",
				"Jiao",
				"Niang",
				"Lan",
				"Xian",
				"Ying",
				"Shuang",
				"Shuai",
				"Quan",
				"Mi",
				"Li",
				"Luan",
				"Yan",
				"Zhu",
				"Lan",
				"Zi",
				"Jie",
				"Jue",
				"Jue",
				"Kong",
				"Yun",
				"Zi",
				"Zi",
				"Cun",
				"Sun",
				"Fu",
				"Bei",
				"Zi",
				"Xiao",
				"Xin",
				"Meng",
				"Si",
				"Tai",
				"Bao",
				"Ji",
				"Gu",
				"Nu",
				"Xue",
				,
				"Zhuan",
				"Hai",
				"Luan",
				"Sun",
				"Huai",
				"Mie",
				"Cong",
				"Qian",
				"Shu",
				"Chan",
				"Ya",
				"Zi",
				"Ni",
				"Fu",
				"Zi",
				"Li",
				"Xue",
				"Bo",
				"Ru",
				"Lai",
				"Nie",
				"Nie",
				"Ying",
				"Luan",
				"Mian",
				"Ning",
				"Rong",
				"Ta",
				"Gui",
				"Zhai",
				"Qiong",
				"Yu",
				"Shou",
				"An",
				"Tu",
				"Song",
				"Wan",
				"Rou",
				"Yao",
				"Hong",
				"Yi",
				"Jing",
				"Zhun",
				"Mi",
				"Zhu",
				"Dang",
				"Hong",
				"Zong",
				"Guan",
				"Zhou",
				"Ding",
				"Wan",
				"Yi",
				"Bao",
				"Shi",
				"Shi",
				"Chong",
				"Shen",
				"Ke",
				"Xuan",
				"Shi",
				"You",
				"Huan",
				"Yi",
				"Tiao",
				"Shi",
				"Xian",
				"Gong",
				"Cheng",
				"Qun",
				"Gong",
				"Xiao",
				"Zai",
				"Zha",
				"Bao",
				"Hai",
				"Yan",
				"Xiao",
				"Jia",
				"Shen",
				"Chen",
				"Rong",
				"Huang",
				"Mi",
				"Kou",
				"Kuan",
				"Bin",
				"Su",
				"Cai",
				"Zan",
				"Ji",
				"Yuan",
				"Ji",
				"Yin",
				"Mi",
				"Kou",
				"Qing",
				"Que",
				"Zhen",
				"Jian",
				"Fu",
				"Ning",
				"Bing",
				"Huan",
				"Mei",
				"Qin",
				"Han",
				"Yu",
				"Shi",
				"Ning",
				"Qin",
				"Ning",
				"Zhi",
				"Yu",
				"Bao",
				"Kuan",
				"Ning",
				"Qin",
				"Mo",
				"Cha",
				"Ju",
				"Gua",
				"Qin",
				"Hu",
				"Wu",
				"Liao",
				"Shi",
				"Zhu",
				"Zhai",
				"Shen",
				"Wei",
				"Xie",
				"Kuan",
				"Hui",
				"Liao",
				"Jun",
				"Huan",
				"Yi",
				"Yi",
				"Bao",
				"Qin",
				"Chong",
				"Bao",
				"Feng",
				"Cun",
				"Dui",
				"Si",
				"Xun",
				"Dao",
				"Lu",
				"Dui",
				"Shou"
			],
			[
				"Po",
				"Feng",
				"Zhuan",
				"Fu",
				"She",
				"Ke",
				"Jiang",
				"Jiang",
				"Zhuan",
				"Wei",
				"Zun",
				"Xun",
				"Shu",
				"Dui",
				"Dao",
				"Xiao",
				"Ji",
				"Shao",
				"Er",
				"Er",
				"Er",
				"Ga",
				"Jian",
				"Shu",
				"Chen",
				"Shang",
				"Shang",
				"Mo",
				"Ga",
				"Chang",
				"Liao",
				"Xian",
				"Xian",
				,
				"Wang",
				"Wang",
				"You",
				"Liao",
				"Liao",
				"Yao",
				"Mang",
				"Wang",
				"Wang",
				"Wang",
				"Ga",
				"Yao",
				"Duo",
				"Kui",
				"Zhong",
				"Jiu",
				"Gan",
				"Gu",
				"Gan",
				"Tui",
				"Gan",
				"Gan",
				"Shi",
				"Yin",
				"Chi",
				"Kao",
				"Ni",
				"Jin",
				"Wei",
				"Niao",
				"Ju",
				"Pi",
				"Ceng",
				"Xi",
				"Bi",
				"Ju",
				"Jie",
				"Tian",
				"Qu",
				"Ti",
				"Jie",
				"Wu",
				"Diao",
				"Shi",
				"Shi",
				"Ping",
				"Ji",
				"Xie",
				"Chen",
				"Xi",
				"Ni",
				"Zhan",
				"Xi",
				,
				"Man",
				"E",
				"Lou",
				"Ping",
				"Ti",
				"Fei",
				"Shu",
				"Xie",
				"Tu",
				"Lu",
				"Lu",
				"Xi",
				"Ceng",
				"Lu",
				"Ju",
				"Xie",
				"Ju",
				"Jue",
				"Liao",
				"Jue",
				"Shu",
				"Xi",
				"Che",
				"Tun",
				"Ni",
				"Shan",
				,
				"Xian",
				"Li",
				"Xue",
				"Nata",
				,
				"Long",
				"Yi",
				"Qi",
				"Ren",
				"Wu",
				"Han",
				"Shen",
				"Yu",
				"Chu",
				"Sui",
				"Qi",
				,
				"Yue",
				"Ban",
				"Yao",
				"Ang",
				"Ya",
				"Wu",
				"Jie",
				"E",
				"Ji",
				"Qian",
				"Fen",
				"Yuan",
				"Qi",
				"Cen",
				"Qian",
				"Qi",
				"Cha",
				"Jie",
				"Qu",
				"Gang",
				"Xian",
				"Ao",
				"Lan",
				"Dao",
				"Ba",
				"Zuo",
				"Zuo",
				"Yang",
				"Ju",
				"Gang",
				"Ke",
				"Gou",
				"Xue",
				"Bei",
				"Li",
				"Tiao",
				"Ju",
				"Yan",
				"Fu",
				"Xiu",
				"Jia",
				"Ling",
				"Tuo",
				"Pei",
				"You",
				"Dai",
				"Kuang",
				"Yue",
				"Qu",
				"Hu",
				"Po",
				"Min",
				"An",
				"Tiao",
				"Ling",
				"Chi",
				"Yuri",
				"Dong",
				"Cem",
				"Kui",
				"Xiu",
				"Mao",
				"Tong",
				"Xue",
				"Yi",
				"Kura",
				"He",
				"Ke",
				"Luo",
				"E",
				"Fu",
				"Xun",
				"Die",
				"Lu",
				"An",
				"Er",
				"Gai",
				"Quan",
				"Tong",
				"Yi",
				"Mu",
				"Shi",
				"An",
				"Wei",
				"Hu",
				"Zhi",
				"Mi",
				"Li",
				"Ji",
				"Tong",
				"Wei",
				"You",
				"Sang",
				"Xia",
				"Li",
				"Yao",
				"Jiao",
				"Zheng",
				"Luan",
				"Jiao",
				"E",
				"E",
				"Yu",
				"Ye",
				"Bu",
				"Qiao",
				"Qun",
				"Feng",
				"Feng",
				"Nao",
				"Li",
				"You",
				"Xian",
				"Hong",
				"Dao",
				"Shen",
				"Cheng",
				"Tu",
				"Geng",
				"Jun",
				"Hao",
				"Xia",
				"Yin",
				"Yu"
			],
			[
				"Lang",
				"Kan",
				"Lao",
				"Lai",
				"Xian",
				"Que",
				"Kong",
				"Chong",
				"Chong",
				"Ta",
				"Lin",
				"Hua",
				"Ju",
				"Lai",
				"Qi",
				"Min",
				"Kun",
				"Kun",
				"Zu",
				"Gu",
				"Cui",
				"Ya",
				"Ya",
				"Gang",
				"Lun",
				"Lun",
				"Leng",
				"Jue",
				"Duo",
				"Zheng",
				"Guo",
				"Yin",
				"Dong",
				"Han",
				"Zheng",
				"Wei",
				"Yao",
				"Pi",
				"Yan",
				"Song",
				"Jie",
				"Beng",
				"Zu",
				"Jue",
				"Dong",
				"Zhan",
				"Gu",
				"Yin",
				,
				"Ze",
				"Huang",
				"Yu",
				"Wei",
				"Yang",
				"Feng",
				"Qiu",
				"Dun",
				"Ti",
				"Yi",
				"Zhi",
				"Shi",
				"Zai",
				"Yao",
				"E",
				"Zhu",
				"Kan",
				"Lu",
				"Yan",
				"Mei",
				"Gan",
				"Ji",
				"Ji",
				"Huan",
				"Ting",
				"Sheng",
				"Mei",
				"Qian",
				"Wu",
				"Yu",
				"Zong",
				"Lan",
				"Jue",
				"Yan",
				"Yan",
				"Wei",
				"Zong",
				"Cha",
				"Sui",
				"Rong",
				"Yamashina",
				"Qin",
				"Yu",
				"Kewashii",
				"Lou",
				"Tu",
				"Dui",
				"Xi",
				"Weng",
				"Cang",
				"Dang",
				"Hong",
				"Jie",
				"Ai",
				"Liu",
				"Wu",
				"Song",
				"Qiao",
				"Zi",
				"Wei",
				"Beng",
				"Dian",
				"Cuo",
				"Qian",
				"Yong",
				"Nie",
				"Cuo",
				"Ji",
				,
				"Tao",
				"Song",
				"Zong",
				"Jiang",
				"Liao",
				"Kang",
				"Chan",
				"Die",
				"Cen",
				"Ding",
				"Tu",
				"Lou",
				"Zhang",
				"Zhan",
				"Zhan",
				"Ao",
				"Cao",
				"Qu",
				"Qiang",
				"Zui",
				"Zui",
				"Dao",
				"Dao",
				"Xi",
				"Yu",
				"Bo",
				"Long",
				"Xiang",
				"Ceng",
				"Bo",
				"Qin",
				"Jiao",
				"Yan",
				"Lao",
				"Zhan",
				"Lin",
				"Liao",
				"Liao",
				"Jin",
				"Deng",
				"Duo",
				"Zun",
				"Jiao",
				"Gui",
				"Yao",
				"Qiao",
				"Yao",
				"Jue",
				"Zhan",
				"Yi",
				"Xue",
				"Nao",
				"Ye",
				"Ye",
				"Yi",
				"E",
				"Xian",
				"Ji",
				"Xie",
				"Ke",
				"Xi",
				"Di",
				"Ao",
				"Zui",
				,
				"Ni",
				"Rong",
				"Dao",
				"Ling",
				"Za",
				"Yu",
				"Yue",
				"Yin",
				,
				"Jie",
				"Li",
				"Sui",
				"Long",
				"Long",
				"Dian",
				"Ying",
				"Xi",
				"Ju",
				"Chan",
				"Ying",
				"Kui",
				"Yan",
				"Wei",
				"Nao",
				"Quan",
				"Chao",
				"Cuan",
				"Luan",
				"Dian",
				"Dian",
				,
				"Yan",
				"Yan",
				"Yan",
				"Nao",
				"Yan",
				"Chuan",
				"Gui",
				"Chuan",
				"Zhou",
				"Huang",
				"Jing",
				"Xun",
				"Chao",
				"Chao",
				"Lie",
				"Gong",
				"Zuo",
				"Qiao",
				"Ju",
				"Gong",
				"Kek",
				"Wu",
				"Pwu",
				"Pwu",
				"Chai",
				"Qiu",
				"Qiu",
				"Ji",
				"Yi",
				"Si",
				"Ba",
				"Zhi",
				"Zhao",
				"Xiang",
				"Yi",
				"Jin",
				"Xun",
				"Juan",
				"Phas",
				"Xun",
				"Jin",
				"Fu"
			],
			[
				"Za",
				"Bi",
				"Shi",
				"Bu",
				"Ding",
				"Shuai",
				"Fan",
				"Nie",
				"Shi",
				"Fen",
				"Pa",
				"Zhi",
				"Xi",
				"Hu",
				"Dan",
				"Wei",
				"Zhang",
				"Tang",
				"Dai",
				"Ma",
				"Pei",
				"Pa",
				"Tie",
				"Fu",
				"Lian",
				"Zhi",
				"Zhou",
				"Bo",
				"Zhi",
				"Di",
				"Mo",
				"Yi",
				"Yi",
				"Ping",
				"Qia",
				"Juan",
				"Ru",
				"Shuai",
				"Dai",
				"Zheng",
				"Shui",
				"Qiao",
				"Zhen",
				"Shi",
				"Qun",
				"Xi",
				"Bang",
				"Dai",
				"Gui",
				"Chou",
				"Ping",
				"Zhang",
				"Sha",
				"Wan",
				"Dai",
				"Wei",
				"Chang",
				"Sha",
				"Qi",
				"Ze",
				"Guo",
				"Mao",
				"Du",
				"Hou",
				"Zheng",
				"Xu",
				"Mi",
				"Wei",
				"Wo",
				"Fu",
				"Yi",
				"Bang",
				"Ping",
				"Tazuna",
				"Gong",
				"Pan",
				"Huang",
				"Dao",
				"Mi",
				"Jia",
				"Teng",
				"Hui",
				"Zhong",
				"Shan",
				"Man",
				"Mu",
				"Biao",
				"Guo",
				"Ze",
				"Mu",
				"Bang",
				"Zhang",
				"Jiong",
				"Chan",
				"Fu",
				"Zhi",
				"Hu",
				"Fan",
				"Chuang",
				"Bi",
				"Hei",
				,
				"Mi",
				"Qiao",
				"Chan",
				"Fen",
				"Meng",
				"Bang",
				"Chou",
				"Mie",
				"Chu",
				"Jie",
				"Xian",
				"Lan",
				"Gan",
				"Ping",
				"Nian",
				"Qian",
				"Bing",
				"Bing",
				"Xing",
				"Gan",
				"Yao",
				"Huan",
				"You",
				"You",
				"Ji",
				"Guang",
				"Pi",
				"Ting",
				"Ze",
				"Guang",
				"Zhuang",
				"Mo",
				"Qing",
				"Bi",
				"Qin",
				"Dun",
				"Chuang",
				"Gui",
				"Ya",
				"Bai",
				"Jie",
				"Xu",
				"Lu",
				"Wu",
				,
				"Ku",
				"Ying",
				"Di",
				"Pao",
				"Dian",
				"Ya",
				"Miao",
				"Geng",
				"Ci",
				"Fu",
				"Tong",
				"Pang",
				"Fei",
				"Xiang",
				"Yi",
				"Zhi",
				"Tiao",
				"Zhi",
				"Xiu",
				"Du",
				"Zuo",
				"Xiao",
				"Tu",
				"Gui",
				"Ku",
				"Pang",
				"Ting",
				"You",
				"Bu",
				"Ding",
				"Cheng",
				"Lai",
				"Bei",
				"Ji",
				"An",
				"Shu",
				"Kang",
				"Yong",
				"Tuo",
				"Song",
				"Shu",
				"Qing",
				"Yu",
				"Yu",
				"Miao",
				"Sou",
				"Ce",
				"Xiang",
				"Fei",
				"Jiu",
				"He",
				"Hui",
				"Liu",
				"Sha",
				"Lian",
				"Lang",
				"Sou",
				"Jian",
				"Pou",
				"Qing",
				"Jiu",
				"Jiu",
				"Qin",
				"Ao",
				"Kuo",
				"Lou",
				"Yin",
				"Liao",
				"Dai",
				"Lu",
				"Yi",
				"Chu",
				"Chan",
				"Tu",
				"Si",
				"Xin",
				"Miao",
				"Chang",
				"Wu",
				"Fei",
				"Guang",
				"Koc",
				"Kuai",
				"Bi",
				"Qiang",
				"Xie",
				"Lin",
				"Lin",
				"Liao",
				"Lu",
				,
				"Ying",
				"Xian",
				"Ting",
				"Yong",
				"Li",
				"Ting",
				"Yin",
				"Xun",
				"Yan",
				"Ting",
				"Di",
				"Po",
				"Jian",
				"Hui",
				"Nai",
				"Hui",
				"Gong",
				"Nian"
			],
			[
				"Kai",
				"Bian",
				"Yi",
				"Qi",
				"Nong",
				"Fen",
				"Ju",
				"Yan",
				"Yi",
				"Zang",
				"Bi",
				"Yi",
				"Yi",
				"Er",
				"San",
				"Shi",
				"Er",
				"Shi",
				"Shi",
				"Gong",
				"Diao",
				"Yin",
				"Hu",
				"Fu",
				"Hong",
				"Wu",
				"Tui",
				"Chi",
				"Jiang",
				"Ba",
				"Shen",
				"Di",
				"Zhang",
				"Jue",
				"Tao",
				"Fu",
				"Di",
				"Mi",
				"Xian",
				"Hu",
				"Chao",
				"Nu",
				"Jing",
				"Zhen",
				"Yi",
				"Mi",
				"Quan",
				"Wan",
				"Shao",
				"Ruo",
				"Xuan",
				"Jing",
				"Dun",
				"Zhang",
				"Jiang",
				"Qiang",
				"Peng",
				"Dan",
				"Qiang",
				"Bi",
				"Bi",
				"She",
				"Dan",
				"Jian",
				"Gou",
				"Sei",
				"Fa",
				"Bi",
				"Kou",
				"Nagi",
				"Bie",
				"Xiao",
				"Dan",
				"Kuo",
				"Qiang",
				"Hong",
				"Mi",
				"Kuo",
				"Wan",
				"Jue",
				"Ji",
				"Ji",
				"Gui",
				"Dang",
				"Lu",
				"Lu",
				"Tuan",
				"Hui",
				"Zhi",
				"Hui",
				"Hui",
				"Yi",
				"Yi",
				"Yi",
				"Yi",
				"Huo",
				"Huo",
				"Shan",
				"Xing",
				"Wen",
				"Tong",
				"Yan",
				"Yan",
				"Yu",
				"Chi",
				"Cai",
				"Biao",
				"Diao",
				"Bin",
				"Peng",
				"Yong",
				"Piao",
				"Zhang",
				"Ying",
				"Chi",
				"Chi",
				"Zhuo",
				"Tuo",
				"Ji",
				"Pang",
				"Zhong",
				"Yi",
				"Wang",
				"Che",
				"Bi",
				"Chi",
				"Ling",
				"Fu",
				"Wang",
				"Zheng",
				"Cu",
				"Wang",
				"Jing",
				"Dai",
				"Xi",
				"Xun",
				"Hen",
				"Yang",
				"Huai",
				"Lu",
				"Hou",
				"Wa",
				"Cheng",
				"Zhi",
				"Xu",
				"Jing",
				"Tu",
				"Cong",
				,
				"Lai",
				"Cong",
				"De",
				"Pai",
				"Xi",
				,
				"Qi",
				"Chang",
				"Zhi",
				"Cong",
				"Zhou",
				"Lai",
				"Yu",
				"Xie",
				"Jie",
				"Jian",
				"Chi",
				"Jia",
				"Bian",
				"Huang",
				"Fu",
				"Xun",
				"Wei",
				"Pang",
				"Yao",
				"Wei",
				"Xi",
				"Zheng",
				"Piao",
				"Chi",
				"De",
				"Zheng",
				"Zheng",
				"Bie",
				"De",
				"Chong",
				"Che",
				"Jiao",
				"Wei",
				"Jiao",
				"Hui",
				"Mei",
				"Long",
				"Xiang",
				"Bao",
				"Qu",
				"Xin",
				"Shu",
				"Bi",
				"Yi",
				"Le",
				"Ren",
				"Dao",
				"Ding",
				"Gai",
				"Ji",
				"Ren",
				"Ren",
				"Chan",
				"Tan",
				"Te",
				"Te",
				"Gan",
				"Qi",
				"Shi",
				"Cun",
				"Zhi",
				"Wang",
				"Mang",
				"Xi",
				"Fan",
				"Ying",
				"Tian",
				"Min",
				"Min",
				"Zhong",
				"Chong",
				"Wu",
				"Ji",
				"Wu",
				"Xi",
				"Ye",
				"You",
				"Wan",
				"Cong",
				"Zhong",
				"Kuai",
				"Yu",
				"Bian",
				"Zhi",
				"Qi",
				"Cui",
				"Chen",
				"Tai",
				"Tun",
				"Qian",
				"Nian",
				"Hun",
				"Xiong",
				"Niu",
				"Wang",
				"Xian",
				"Xin",
				"Kang",
				"Hu",
				"Kai",
				"Fen"
			],
			[
				"Huai",
				"Tai",
				"Song",
				"Wu",
				"Ou",
				"Chang",
				"Chuang",
				"Ju",
				"Yi",
				"Bao",
				"Chao",
				"Min",
				"Pei",
				"Zuo",
				"Zen",
				"Yang",
				"Kou",
				"Ban",
				"Nu",
				"Nao",
				"Zheng",
				"Pa",
				"Bu",
				"Tie",
				"Gu",
				"Hu",
				"Ju",
				"Da",
				"Lian",
				"Si",
				"Chou",
				"Di",
				"Dai",
				"Yi",
				"Tu",
				"You",
				"Fu",
				"Ji",
				"Peng",
				"Xing",
				"Yuan",
				"Ni",
				"Guai",
				"Fu",
				"Xi",
				"Bi",
				"You",
				"Qie",
				"Xuan",
				"Cong",
				"Bing",
				"Huang",
				"Xu",
				"Chu",
				"Pi",
				"Xi",
				"Xi",
				"Tan",
				"Koraeru",
				"Zong",
				"Dui",
				,
				"Ki",
				"Yi",
				"Chi",
				"Ren",
				"Xun",
				"Shi",
				"Xi",
				"Lao",
				"Heng",
				"Kuang",
				"Mu",
				"Zhi",
				"Xie",
				"Lian",
				"Tiao",
				"Huang",
				"Die",
				"Hao",
				"Kong",
				"Gui",
				"Heng",
				"Xi",
				"Xiao",
				"Shu",
				"S",
				"Kua",
				"Qiu",
				"Yang",
				"Hui",
				"Hui",
				"Chi",
				"Jia",
				"Yi",
				"Xiong",
				"Guai",
				"Lin",
				"Hui",
				"Zi",
				"Xu",
				"Chi",
				"Xiang",
				"Nu",
				"Hen",
				"En",
				"Ke",
				"Tong",
				"Tian",
				"Gong",
				"Quan",
				"Xi",
				"Qia",
				"Yue",
				"Peng",
				"Ken",
				"De",
				"Hui",
				"E",
				"Kyuu",
				"Tong",
				"Yan",
				"Kai",
				"Ce",
				"Nao",
				"Yun",
				"Mang",
				"Yong",
				"Yong",
				"Yuan",
				"Pi",
				"Kun",
				"Qiao",
				"Yue",
				"Yu",
				"Yu",
				"Jie",
				"Xi",
				"Zhe",
				"Lin",
				"Ti",
				"Han",
				"Hao",
				"Qie",
				"Ti",
				"Bu",
				"Yi",
				"Qian",
				"Hui",
				"Xi",
				"Bei",
				"Man",
				"Yi",
				"Heng",
				"Song",
				"Quan",
				"Cheng",
				"Hui",
				"Wu",
				"Wu",
				"You",
				"Li",
				"Liang",
				"Huan",
				"Cong",
				"Yi",
				"Yue",
				"Li",
				"Nin",
				"Nao",
				"E",
				"Que",
				"Xuan",
				"Qian",
				"Wu",
				"Min",
				"Cong",
				"Fei",
				"Bei",
				"Duo",
				"Cui",
				"Chang",
				"Men",
				"Li",
				"Ji",
				"Guan",
				"Guan",
				"Xing",
				"Dao",
				"Qi",
				"Kong",
				"Tian",
				"Lun",
				"Xi",
				"Kan",
				"Kun",
				"Ni",
				"Qing",
				"Chou",
				"Dun",
				"Guo",
				"Chan",
				"Liang",
				"Wan",
				"Yuan",
				"Jin",
				"Ji",
				"Lin",
				"Yu",
				"Huo",
				"He",
				"Quan",
				"Tan",
				"Ti",
				"Ti",
				"Nie",
				"Wang",
				"Chuo",
				"Bu",
				"Hun",
				"Xi",
				"Tang",
				"Xin",
				"Wei",
				"Hui",
				"E",
				"Rui",
				"Zong",
				"Jian",
				"Yong",
				"Dian",
				"Ju",
				"Can",
				"Cheng",
				"De",
				"Bei",
				"Qie",
				"Can",
				"Dan",
				"Guan",
				"Duo",
				"Nao",
				"Yun",
				"Xiang",
				"Zhui",
				"Die",
				"Huang",
				"Chun",
				"Qiong",
				"Re",
				"Xing",
				"Ce",
				"Bian",
				"Hun",
				"Zong",
				"Ti"
			],
			[
				"Qiao",
				"Chou",
				"Bei",
				"Xuan",
				"Wei",
				"Ge",
				"Qian",
				"Wei",
				"Yu",
				"Yu",
				"Bi",
				"Xuan",
				"Huan",
				"Min",
				"Bi",
				"Yi",
				"Mian",
				"Yong",
				"Kai",
				"Dang",
				"Yin",
				"E",
				"Chen",
				"Mou",
				"Ke",
				"Ke",
				"Yu",
				"Ai",
				"Qie",
				"Yan",
				"Nuo",
				"Gan",
				"Yun",
				"Zong",
				"Sai",
				"Leng",
				"Fen",
				,
				"Kui",
				"Kui",
				"Que",
				"Gong",
				"Yun",
				"Su",
				"Su",
				"Qi",
				"Yao",
				"Song",
				"Huang",
				"Ji",
				"Gu",
				"Ju",
				"Chuang",
				"Ni",
				"Xie",
				"Kai",
				"Zheng",
				"Yong",
				"Cao",
				"Sun",
				"Shen",
				"Bo",
				"Kai",
				"Yuan",
				"Xie",
				"Hun",
				"Yong",
				"Yang",
				"Li",
				"Sao",
				"Tao",
				"Yin",
				"Ci",
				"Xu",
				"Qian",
				"Tai",
				"Huang",
				"Yun",
				"Shen",
				"Ming",
				,
				"She",
				"Cong",
				"Piao",
				"Mo",
				"Mu",
				"Guo",
				"Chi",
				"Can",
				"Can",
				"Can",
				"Cui",
				"Min",
				"Te",
				"Zhang",
				"Tong",
				"Ao",
				"Shuang",
				"Man",
				"Guan",
				"Que",
				"Zao",
				"Jiu",
				"Hui",
				"Kai",
				"Lian",
				"Ou",
				"Song",
				"Jin",
				"Yin",
				"Lu",
				"Shang",
				"Wei",
				"Tuan",
				"Man",
				"Qian",
				"She",
				"Yong",
				"Qing",
				"Kang",
				"Di",
				"Zhi",
				"Lou",
				"Juan",
				"Qi",
				"Qi",
				"Yu",
				"Ping",
				"Liao",
				"Cong",
				"You",
				"Chong",
				"Zhi",
				"Tong",
				"Cheng",
				"Qi",
				"Qu",
				"Peng",
				"Bei",
				"Bie",
				"Chun",
				"Jiao",
				"Zeng",
				"Chi",
				"Lian",
				"Ping",
				"Kui",
				"Hui",
				"Qiao",
				"Cheng",
				"Yin",
				"Yin",
				"Xi",
				"Xi",
				"Dan",
				"Tan",
				"Duo",
				"Dui",
				"Dui",
				"Su",
				"Jue",
				"Ce",
				"Xiao",
				"Fan",
				"Fen",
				"Lao",
				"Lao",
				"Chong",
				"Han",
				"Qi",
				"Xian",
				"Min",
				"Jing",
				"Liao",
				"Wu",
				"Can",
				"Jue",
				"Cu",
				"Xian",
				"Tan",
				"Sheng",
				"Pi",
				"Yi",
				"Chu",
				"Xian",
				"Nao",
				"Dan",
				"Tan",
				"Jing",
				"Song",
				"Han",
				"Jiao",
				"Wai",
				"Huan",
				"Dong",
				"Qin",
				"Qin",
				"Qu",
				"Cao",
				"Ken",
				"Xie",
				"Ying",
				"Ao",
				"Mao",
				"Yi",
				"Lin",
				"Se",
				"Jun",
				"Huai",
				"Men",
				"Lan",
				"Ai",
				"Lin",
				"Yan",
				"Gua",
				"Xia",
				"Chi",
				"Yu",
				"Yin",
				"Dai",
				"Meng",
				"Ai",
				"Meng",
				"Dui",
				"Qi",
				"Mo",
				"Lan",
				"Men",
				"Chou",
				"Zhi",
				"Nuo",
				"Nuo",
				"Yan",
				"Yang",
				"Bo",
				"Zhi",
				"Kuang",
				"Kuang",
				"You",
				"Fu",
				"Liu",
				"Mie",
				"Cheng",
				,
				"Chan",
				"Meng",
				"Lan",
				"Huai",
				"Xuan",
				"Rang",
				"Chan",
				"Ji",
				"Ju",
				"Huan",
				"She",
				"Yi"
			],
			[
				"Lian",
				"Nan",
				"Mi",
				"Tang",
				"Jue",
				"Gang",
				"Gang",
				"Gang",
				"Ge",
				"Yue",
				"Wu",
				"Jian",
				"Xu",
				"Shu",
				"Rong",
				"Xi",
				"Cheng",
				"Wo",
				"Jie",
				"Ge",
				"Jian",
				"Qiang",
				"Huo",
				"Qiang",
				"Zhan",
				"Dong",
				"Qi",
				"Jia",
				"Die",
				"Zei",
				"Jia",
				"Ji",
				"Shi",
				"Kan",
				"Ji",
				"Kui",
				"Gai",
				"Deng",
				"Zhan",
				"Chuang",
				"Ge",
				"Jian",
				"Jie",
				"Yu",
				"Jian",
				"Yan",
				"Lu",
				"Xi",
				"Zhan",
				"Xi",
				"Xi",
				"Chuo",
				"Dai",
				"Qu",
				"Hu",
				"Hu",
				"Hu",
				"E",
				"Shi",
				"Li",
				"Mao",
				"Hu",
				"Li",
				"Fang",
				"Suo",
				"Bian",
				"Dian",
				"Jiong",
				"Shang",
				"Yi",
				"Yi",
				"Shan",
				"Hu",
				"Fei",
				"Yan",
				"Shou",
				"T",
				"Cai",
				"Zha",
				"Qiu",
				"Le",
				"Bu",
				"Ba",
				"Da",
				"Reng",
				"Fu",
				"Hameru",
				"Zai",
				"Tuo",
				"Zhang",
				"Diao",
				"Kang",
				"Yu",
				"Ku",
				"Han",
				"Shen",
				"Cha",
				"Yi",
				"Gu",
				"Kou",
				"Wu",
				"Tuo",
				"Qian",
				"Zhi",
				"Ren",
				"Kuo",
				"Men",
				"Sao",
				"Yang",
				"Niu",
				"Ban",
				"Che",
				"Rao",
				"Xi",
				"Qian",
				"Ban",
				"Jia",
				"Yu",
				"Fu",
				"Ao",
				"Xi",
				"Pi",
				"Zhi",
				"Zi",
				"E",
				"Dun",
				"Zhao",
				"Cheng",
				"Ji",
				"Yan",
				"Kuang",
				"Bian",
				"Chao",
				"Ju",
				"Wen",
				"Hu",
				"Yue",
				"Jue",
				"Ba",
				"Qin",
				"Zhen",
				"Zheng",
				"Yun",
				"Wan",
				"Nu",
				"Yi",
				"Shu",
				"Zhua",
				"Pou",
				"Tou",
				"Dou",
				"Kang",
				"Zhe",
				"Pou",
				"Fu",
				"Pao",
				"Ba",
				"Ao",
				"Ze",
				"Tuan",
				"Kou",
				"Lun",
				"Qiang",
				,
				"Hu",
				"Bao",
				"Bing",
				"Zhi",
				"Peng",
				"Tan",
				"Pu",
				"Pi",
				"Tai",
				"Yao",
				"Zhen",
				"Zha",
				"Yang",
				"Bao",
				"He",
				"Ni",
				"Yi",
				"Di",
				"Chi",
				"Pi",
				"Za",
				"Mo",
				"Mo",
				"Shen",
				"Ya",
				"Chou",
				"Qu",
				"Min",
				"Chu",
				"Jia",
				"Fu",
				"Zhan",
				"Zhu",
				"Dan",
				"Chai",
				"Mu",
				"Nian",
				"La",
				"Fu",
				"Pao",
				"Ban",
				"Pai",
				"Ling",
				"Na",
				"Guai",
				"Qian",
				"Ju",
				"Tuo",
				"Ba",
				"Tuo",
				"Tuo",
				"Ao",
				"Ju",
				"Zhuo",
				"Pan",
				"Zhao",
				"Bai",
				"Bai",
				"Di",
				"Ni",
				"Ju",
				"Kuo",
				"Long",
				"Jian",
				,
				"Yong",
				"Lan",
				"Ning",
				"Bo",
				"Ze",
				"Qian",
				"Hen",
				"Gua",
				"Shi",
				"Jie",
				"Zheng",
				"Nin",
				"Gong",
				"Gong",
				"Quan",
				"Shuan",
				"Cun",
				"Zan",
				"Kao",
				"Chi",
				"Xie",
				"Ce",
				"Hui",
				"Pin",
				"Zhuai",
				"Shi",
				"Na"
			],
			[
				"Bo",
				"Chi",
				"Gua",
				"Zhi",
				"Kuo",
				"Duo",
				"Duo",
				"Zhi",
				"Qie",
				"An",
				"Nong",
				"Zhen",
				"Ge",
				"Jiao",
				"Ku",
				"Dong",
				"Ru",
				"Tiao",
				"Lie",
				"Zha",
				"Lu",
				"Die",
				"Wa",
				"Jue",
				"Mushiru",
				"Ju",
				"Zhi",
				"Luan",
				"Ya",
				"Zhua",
				"Ta",
				"Xie",
				"Nao",
				"Dang",
				"Jiao",
				"Zheng",
				"Ji",
				"Hui",
				"Xun",
				"Ku",
				"Ai",
				"Tuo",
				"Nuo",
				"Cuo",
				"Bo",
				"Geng",
				"Ti",
				"Zhen",
				"Cheng",
				"Suo",
				"Suo",
				"Keng",
				"Mei",
				"Long",
				"Ju",
				"Peng",
				"Jian",
				"Yi",
				"Ting",
				"Shan",
				"Nuo",
				"Wan",
				"Xie",
				"Cha",
				"Feng",
				"Jiao",
				"Wu",
				"Jun",
				"Jiu",
				"Tong",
				"Kun",
				"Huo",
				"Tu",
				"Zhuo",
				"Pou",
				"Le",
				"Ba",
				"Han",
				"Shao",
				"Nie",
				"Juan",
				"Ze",
				"Song",
				"Ye",
				"Jue",
				"Bu",
				"Huan",
				"Bu",
				"Zun",
				"Yi",
				"Zhai",
				"Lu",
				"Sou",
				"Tuo",
				"Lao",
				"Sun",
				"Bang",
				"Jian",
				"Huan",
				"Dao",
				,
				"Wan",
				"Qin",
				"Peng",
				"She",
				"Lie",
				"Min",
				"Men",
				"Fu",
				"Bai",
				"Ju",
				"Dao",
				"Wo",
				"Ai",
				"Juan",
				"Yue",
				"Zong",
				"Chen",
				"Chui",
				"Jie",
				"Tu",
				"Ben",
				"Na",
				"Nian",
				"Nuo",
				"Zu",
				"Wo",
				"Xi",
				"Xian",
				"Cheng",
				"Dian",
				"Sao",
				"Lun",
				"Qing",
				"Gang",
				"Duo",
				"Shou",
				"Diao",
				"Pou",
				"Di",
				"Zhang",
				"Gun",
				"Ji",
				"Tao",
				"Qia",
				"Qi",
				"Pai",
				"Shu",
				"Qian",
				"Ling",
				"Yi",
				"Ya",
				"Jue",
				"Zheng",
				"Liang",
				"Gua",
				"Yi",
				"Huo",
				"Shan",
				"Zheng",
				"Lue",
				"Cai",
				"Tan",
				"Che",
				"Bing",
				"Jie",
				"Ti",
				"Kong",
				"Tui",
				"Yan",
				"Cuo",
				"Zou",
				"Ju",
				"Tian",
				"Qian",
				"Ken",
				"Bai",
				"Shou",
				"Jie",
				"Lu",
				"Guo",
				"Haba",
				,
				"Zhi",
				"Dan",
				"Mang",
				"Xian",
				"Sao",
				"Guan",
				"Peng",
				"Yuan",
				"Nuo",
				"Jian",
				"Zhen",
				"Jiu",
				"Jian",
				"Yu",
				"Yan",
				"Kui",
				"Nan",
				"Hong",
				"Rou",
				"Pi",
				"Wei",
				"Sai",
				"Zou",
				"Xuan",
				"Miao",
				"Ti",
				"Nie",
				"Cha",
				"Shi",
				"Zong",
				"Zhen",
				"Yi",
				"Shun",
				"Heng",
				"Bian",
				"Yang",
				"Huan",
				"Yan",
				"Zuan",
				"An",
				"Xu",
				"Ya",
				"Wo",
				"Ke",
				"Chuai",
				"Ji",
				"Ti",
				"La",
				"La",
				"Cheng",
				"Kai",
				"Jiu",
				"Jiu",
				"Tu",
				"Jie",
				"Hui",
				"Geng",
				"Chong",
				"Shuo",
				"She",
				"Xie",
				"Yuan",
				"Qian",
				"Ye",
				"Cha",
				"Zha",
				"Bei",
				"Yao",
				,
				,
				"Lan",
				"Wen",
				"Qin"
			],
			[
				"Chan",
				"Ge",
				"Lou",
				"Zong",
				"Geng",
				"Jiao",
				"Gou",
				"Qin",
				"Yong",
				"Que",
				"Chou",
				"Chi",
				"Zhan",
				"Sun",
				"Sun",
				"Bo",
				"Chu",
				"Rong",
				"Beng",
				"Cuo",
				"Sao",
				"Ke",
				"Yao",
				"Dao",
				"Zhi",
				"Nu",
				"Xie",
				"Jian",
				"Sou",
				"Qiu",
				"Gao",
				"Xian",
				"Shuo",
				"Sang",
				"Jin",
				"Mie",
				"E",
				"Chui",
				"Nuo",
				"Shan",
				"Ta",
				"Jie",
				"Tang",
				"Pan",
				"Ban",
				"Da",
				"Li",
				"Tao",
				"Hu",
				"Zhi",
				"Wa",
				"Xia",
				"Qian",
				"Wen",
				"Qiang",
				"Tian",
				"Zhen",
				"E",
				"Xi",
				"Nuo",
				"Quan",
				"Cha",
				"Zha",
				"Ge",
				"Wu",
				"En",
				"She",
				"Kang",
				"She",
				"Shu",
				"Bai",
				"Yao",
				"Bin",
				"Sou",
				"Tan",
				"Sa",
				"Chan",
				"Suo",
				"Liao",
				"Chong",
				"Chuang",
				"Guo",
				"Bing",
				"Feng",
				"Shuai",
				"Di",
				"Qi",
				"Sou",
				"Zhai",
				"Lian",
				"Tang",
				"Chi",
				"Guan",
				"Lu",
				"Luo",
				"Lou",
				"Zong",
				"Gai",
				"Hu",
				"Zha",
				"Chuang",
				"Tang",
				"Hua",
				"Cui",
				"Nai",
				"Mo",
				"Jiang",
				"Gui",
				"Ying",
				"Zhi",
				"Ao",
				"Zhi",
				"Nie",
				"Man",
				"Shan",
				"Kou",
				"Shu",
				"Suo",
				"Tuan",
				"Jiao",
				"Mo",
				"Mo",
				"Zhe",
				"Xian",
				"Keng",
				"Piao",
				"Jiang",
				"Yin",
				"Gou",
				"Qian",
				"Lue",
				"Ji",
				"Ying",
				"Jue",
				"Pie",
				"Pie",
				"Lao",
				"Dun",
				"Xian",
				"Ruan",
				"Kui",
				"Zan",
				"Yi",
				"Xun",
				"Cheng",
				"Cheng",
				"Sa",
				"Nao",
				"Heng",
				"Si",
				"Qian",
				"Huang",
				"Da",
				"Zun",
				"Nian",
				"Lin",
				"Zheng",
				"Hui",
				"Zhuang",
				"Jiao",
				"Ji",
				"Cao",
				"Dan",
				"Dan",
				"Che",
				"Bo",
				"Che",
				"Jue",
				"Xiao",
				"Liao",
				"Ben",
				"Fu",
				"Qiao",
				"Bo",
				"Cuo",
				"Zhuo",
				"Zhuan",
				"Tuo",
				"Pu",
				"Qin",
				"Dun",
				"Nian",
				,
				"Xie",
				"Lu",
				"Jiao",
				"Cuan",
				"Ta",
				"Han",
				"Qiao",
				"Zhua",
				"Jian",
				"Gan",
				"Yong",
				"Lei",
				"Kuo",
				"Lu",
				"Shan",
				"Zhuo",
				"Ze",
				"Pu",
				"Chuo",
				"Ji",
				"Dang",
				"Suo",
				"Cao",
				"Qing",
				"Jing",
				"Huan",
				"Jie",
				"Qin",
				"Kuai",
				"Dan",
				"Xi",
				"Ge",
				"Pi",
				"Bo",
				"Ao",
				"Ju",
				"Ye",
				,
				"Mang",
				"Sou",
				"Mi",
				"Ji",
				"Tai",
				"Zhuo",
				"Dao",
				"Xing",
				"Lan",
				"Ca",
				"Ju",
				"Ye",
				"Ru",
				"Ye",
				"Ye",
				"Ni",
				"Hu",
				"Ji",
				"Bin",
				"Ning",
				"Ge",
				"Zhi",
				"Jie",
				"Kuo",
				"Mo",
				"Jian",
				"Xie",
				"Lie",
				"Tan",
				"Bai",
				"Sou",
				"Lu",
				"Lue",
				"Rao",
				"Zhi"
			],
			[
				"Pan",
				"Yang",
				"Lei",
				"Sa",
				"Shu",
				"Zan",
				"Nian",
				"Xian",
				"Jun",
				"Huo",
				"Li",
				"La",
				"Han",
				"Ying",
				"Lu",
				"Long",
				"Qian",
				"Qian",
				"Zan",
				"Qian",
				"Lan",
				"San",
				"Ying",
				"Mei",
				"Rang",
				"Chan",
				,
				"Cuan",
				"Xi",
				"She",
				"Luo",
				"Jun",
				"Mi",
				"Li",
				"Zan",
				"Luan",
				"Tan",
				"Zuan",
				"Li",
				"Dian",
				"Wa",
				"Dang",
				"Jiao",
				"Jue",
				"Lan",
				"Li",
				"Nang",
				"Zhi",
				"Gui",
				"Gui",
				"Qi",
				"Xin",
				"Pu",
				"Sui",
				"Shou",
				"Kao",
				"You",
				"Gai",
				"Yi",
				"Gong",
				"Gan",
				"Ban",
				"Fang",
				"Zheng",
				"Bo",
				"Dian",
				"Kou",
				"Min",
				"Wu",
				"Gu",
				"He",
				"Ce",
				"Xiao",
				"Mi",
				"Chu",
				"Ge",
				"Di",
				"Xu",
				"Jiao",
				"Min",
				"Chen",
				"Jiu",
				"Zhen",
				"Duo",
				"Yu",
				"Chi",
				"Ao",
				"Bai",
				"Xu",
				"Jiao",
				"Duo",
				"Lian",
				"Nie",
				"Bi",
				"Chang",
				"Dian",
				"Duo",
				"Yi",
				"Gan",
				"San",
				"Ke",
				"Yan",
				"Dun",
				"Qi",
				"Dou",
				"Xiao",
				"Duo",
				"Jiao",
				"Jing",
				"Yang",
				"Xia",
				"Min",
				"Shu",
				"Ai",
				"Qiao",
				"Ai",
				"Zheng",
				"Di",
				"Zhen",
				"Fu",
				"Shu",
				"Liao",
				"Qu",
				"Xiong",
				"Xi",
				"Jiao",
				"Sen",
				"Jiao",
				"Zhuo",
				"Yi",
				"Lian",
				"Bi",
				"Li",
				"Xiao",
				"Xiao",
				"Wen",
				"Xue",
				"Qi",
				"Qi",
				"Zhai",
				"Bin",
				"Jue",
				"Zhai",
				,
				"Fei",
				"Ban",
				"Ban",
				"Lan",
				"Yu",
				"Lan",
				"Wei",
				"Dou",
				"Sheng",
				"Liao",
				"Jia",
				"Hu",
				"Xie",
				"Jia",
				"Yu",
				"Zhen",
				"Jiao",
				"Wo",
				"Tou",
				"Chu",
				"Jin",
				"Chi",
				"Yin",
				"Fu",
				"Qiang",
				"Zhan",
				"Qu",
				"Zhuo",
				"Zhan",
				"Duan",
				"Zhuo",
				"Si",
				"Xin",
				"Zhuo",
				"Zhuo",
				"Qin",
				"Lin",
				"Zhuo",
				"Chu",
				"Duan",
				"Zhu",
				"Fang",
				"Xie",
				"Hang",
				"Yu",
				"Shi",
				"Pei",
				"You",
				"Mye",
				"Pang",
				"Qi",
				"Zhan",
				"Mao",
				"Lu",
				"Pei",
				"Pi",
				"Liu",
				"Fu",
				"Fang",
				"Xuan",
				"Jing",
				"Jing",
				"Ni",
				"Zu",
				"Zhao",
				"Yi",
				"Liu",
				"Shao",
				"Jian",
				"Es",
				"Yi",
				"Qi",
				"Zhi",
				"Fan",
				"Piao",
				"Fan",
				"Zhan",
				"Guai",
				"Sui",
				"Yu",
				"Wu",
				"Ji",
				"Ji",
				"Ji",
				"Huo",
				"Ri",
				"Dan",
				"Jiu",
				"Zhi",
				"Zao",
				"Xie",
				"Tiao",
				"Xun",
				"Xu",
				"Xu",
				"Xu",
				"Gan",
				"Han",
				"Tai",
				"Di",
				"Xu",
				"Chan",
				"Shi",
				"Kuang",
				"Yang",
				"Shi",
				"Wang",
				"Min",
				"Min",
				"Tun",
				"Chun",
				"Wu"
			],
			[
				"Yun",
				"Bei",
				"Ang",
				"Ze",
				"Ban",
				"Jie",
				"Kun",
				"Sheng",
				"Hu",
				"Fang",
				"Hao",
				"Gui",
				"Chang",
				"Xuan",
				"Ming",
				"Hun",
				"Fen",
				"Qin",
				"Hu",
				"Yi",
				"Xi",
				"Xin",
				"Yan",
				"Ze",
				"Fang",
				"Tan",
				"Shen",
				"Ju",
				"Yang",
				"Zan",
				"Bing",
				"Xing",
				"Ying",
				"Xuan",
				"Pei",
				"Zhen",
				"Ling",
				"Chun",
				"Hao",
				"Mei",
				"Zuo",
				"Mo",
				"Bian",
				"Xu",
				"Hun",
				"Zhao",
				"Zong",
				"Shi",
				"Shi",
				"Yu",
				"Fei",
				"Die",
				"Mao",
				"Ni",
				"Chang",
				"Wen",
				"Dong",
				"Ai",
				"Bing",
				"Ang",
				"Zhou",
				"Long",
				"Xian",
				"Kuang",
				"Tiao",
				"Chao",
				"Shi",
				"Huang",
				"Huang",
				"Xuan",
				"Kui",
				"Xu",
				"Jiao",
				"Jin",
				"Zhi",
				"Jin",
				"Shang",
				"Tong",
				"Hong",
				"Yan",
				"Gai",
				"Xiang",
				"Shai",
				"Xiao",
				"Ye",
				"Yun",
				"Hui",
				"Han",
				"Han",
				"Jun",
				"Wan",
				"Xian",
				"Kun",
				"Zhou",
				"Xi",
				"Cheng",
				"Sheng",
				"Bu",
				"Zhe",
				"Zhe",
				"Wu",
				"Han",
				"Hui",
				"Hao",
				"Chen",
				"Wan",
				"Tian",
				"Zhuo",
				"Zui",
				"Zhou",
				"Pu",
				"Jing",
				"Xi",
				"Shan",
				"Yi",
				"Xi",
				"Qing",
				"Qi",
				"Jing",
				"Gui",
				"Zhen",
				"Yi",
				"Zhi",
				"An",
				"Wan",
				"Lin",
				"Liang",
				"Chang",
				"Wang",
				"Xiao",
				"Zan",
				"Hi",
				"Xuan",
				"Xuan",
				"Yi",
				"Xia",
				"Yun",
				"Hui",
				"Fu",
				"Min",
				"Kui",
				"He",
				"Ying",
				"Du",
				"Wei",
				"Shu",
				"Qing",
				"Mao",
				"Nan",
				"Jian",
				"Nuan",
				"An",
				"Yang",
				"Chun",
				"Yao",
				"Suo",
				"Jin",
				"Ming",
				"Jiao",
				"Kai",
				"Gao",
				"Weng",
				"Chang",
				"Qi",
				"Hao",
				"Yan",
				"Li",
				"Ai",
				"Ji",
				"Gui",
				"Men",
				"Zan",
				"Xie",
				"Hao",
				"Mu",
				"Mo",
				"Cong",
				"Ni",
				"Zhang",
				"Hui",
				"Bao",
				"Han",
				"Xuan",
				"Chuan",
				"Liao",
				"Xian",
				"Dan",
				"Jing",
				"Pie",
				"Lin",
				"Tun",
				"Xi",
				"Yi",
				"Ji",
				"Huang",
				"Tai",
				"Ye",
				"Ye",
				"Li",
				"Tan",
				"Tong",
				"Xiao",
				"Fei",
				"Qin",
				"Zhao",
				"Hao",
				"Yi",
				"Xiang",
				"Xing",
				"Sen",
				"Jiao",
				"Bao",
				"Jing",
				"Yian",
				"Ai",
				"Ye",
				"Ru",
				"Shu",
				"Meng",
				"Xun",
				"Yao",
				"Pu",
				"Li",
				"Chen",
				"Kuang",
				"Die",
				,
				"Yan",
				"Huo",
				"Lu",
				"Xi",
				"Rong",
				"Long",
				"Nang",
				"Luo",
				"Luan",
				"Shai",
				"Tang",
				"Yan",
				"Chu",
				"Yue",
				"Yue",
				"Qu",
				"Yi",
				"Geng",
				"Ye",
				"Hu",
				"He",
				"Shu",
				"Cao",
				"Cao",
				"Noboru",
				"Man",
				"Ceng",
				"Ceng",
				"Ti"
			],
			[
				"Zui",
				"Can",
				"Xu",
				"Hui",
				"Yin",
				"Qie",
				"Fen",
				"Pi",
				"Yue",
				"You",
				"Ruan",
				"Peng",
				"Ban",
				"Fu",
				"Ling",
				"Fei",
				"Qu",
				,
				"Nu",
				"Tiao",
				"Shuo",
				"Zhen",
				"Lang",
				"Lang",
				"Juan",
				"Ming",
				"Huang",
				"Wang",
				"Tun",
				"Zhao",
				"Ji",
				"Qi",
				"Ying",
				"Zong",
				"Wang",
				"Tong",
				"Lang",
				,
				"Meng",
				"Long",
				"Mu",
				"Deng",
				"Wei",
				"Mo",
				"Ben",
				"Zha",
				"Zhu",
				"Shu",
				,
				"Zhu",
				"Ren",
				"Ba",
				"Po",
				"Duo",
				"Duo",
				"Dao",
				"Li",
				"Qiu",
				"Ji",
				"Jiu",
				"Bi",
				"Xiu",
				"Ting",
				"Ci",
				"Sha",
				"Eburi",
				"Za",
				"Quan",
				"Qian",
				"Yu",
				"Gan",
				"Wu",
				"Cha",
				"Shan",
				"Xun",
				"Fan",
				"Wu",
				"Zi",
				"Li",
				"Xing",
				"Cai",
				"Cun",
				"Ren",
				"Shao",
				"Tuo",
				"Di",
				"Zhang",
				"Mang",
				"Chi",
				"Yi",
				"Gu",
				"Gong",
				"Du",
				"Yi",
				"Qi",
				"Shu",
				"Gang",
				"Tiao",
				"Moku",
				"Soma",
				"Tochi",
				"Lai",
				"Sugi",
				"Mang",
				"Yang",
				"Ma",
				"Miao",
				"Si",
				"Yuan",
				"Hang",
				"Fei",
				"Bei",
				"Jie",
				"Dong",
				"Gao",
				"Yao",
				"Xian",
				"Chu",
				"Qun",
				"Pa",
				"Shu",
				"Hua",
				"Xin",
				"Chou",
				"Zhu",
				"Chou",
				"Song",
				"Ban",
				"Song",
				"Ji",
				"Yue",
				"Jin",
				"Gou",
				"Ji",
				"Mao",
				"Pi",
				"Bi",
				"Wang",
				"Ang",
				"Fang",
				"Fen",
				"Yi",
				"Fu",
				"Nan",
				"Xi",
				"Hu",
				"Ya",
				"Dou",
				"Xun",
				"Zhen",
				"Yao",
				"Lin",
				"Rui",
				"E",
				"Mei",
				"Zhao",
				"Guo",
				"Zhi",
				"Cong",
				"Yun",
				"Waku",
				"Dou",
				"Shu",
				"Zao",
				,
				"Li",
				"Haze",
				"Jian",
				"Cheng",
				"Matsu",
				"Qiang",
				"Feng",
				"Nan",
				"Xiao",
				"Xian",
				"Ku",
				"Ping",
				"Yi",
				"Xi",
				"Zhi",
				"Guai",
				"Xiao",
				"Jia",
				"Jia",
				"Gou",
				"Fu",
				"Mo",
				"Yi",
				"Ye",
				"Ye",
				"Shi",
				"Nie",
				"Bi",
				"Duo",
				"Yi",
				"Ling",
				"Bing",
				"Ni",
				"La",
				"He",
				"Pan",
				"Fan",
				"Zhong",
				"Dai",
				"Ci",
				"Yang",
				"Fu",
				"Bo",
				"Mou",
				"Gan",
				"Qi",
				"Ran",
				"Rou",
				"Mao",
				"Zhao",
				"Song",
				"Zhe",
				"Xia",
				"You",
				"Shen",
				"Ju",
				"Tuo",
				"Zuo",
				"Nan",
				"Ning",
				"Yong",
				"Di",
				"Zhi",
				"Zha",
				"Cha",
				"Dan",
				"Gu",
				"Pu",
				"Jiu",
				"Ao",
				"Fu",
				"Jian",
				"Bo",
				"Duo",
				"Ke",
				"Nai",
				"Zhu",
				"Bi",
				"Liu",
				"Chai",
				"Zha",
				"Si",
				"Zhu",
				"Pei",
				"Shi",
				"Guai",
				"Cha",
				"Yao",
				"Jue",
				"Jiu",
				"Shi"
			],
			[
				"Zhi",
				"Liu",
				"Mei",
				"Hoy",
				"Rong",
				"Zha",
				,
				"Biao",
				"Zhan",
				"Jie",
				"Long",
				"Dong",
				"Lu",
				"Sayng",
				"Li",
				"Lan",
				"Yong",
				"Shu",
				"Xun",
				"Shuan",
				"Qi",
				"Zhen",
				"Qi",
				"Li",
				"Yi",
				"Xiang",
				"Zhen",
				"Li",
				"Su",
				"Gua",
				"Kan",
				"Bing",
				"Ren",
				"Xiao",
				"Bo",
				"Ren",
				"Bing",
				"Zi",
				"Chou",
				"Yi",
				"Jie",
				"Xu",
				"Zhu",
				"Jian",
				"Zui",
				"Er",
				"Er",
				"You",
				"Fa",
				"Gong",
				"Kao",
				"Lao",
				"Zhan",
				"Li",
				"Yin",
				"Yang",
				"He",
				"Gen",
				"Zhi",
				"Chi",
				"Ge",
				"Zai",
				"Luan",
				"Fu",
				"Jie",
				"Hang",
				"Gui",
				"Tao",
				"Guang",
				"Wei",
				"Kuang",
				"Ru",
				"An",
				"An",
				"Juan",
				"Yi",
				"Zhuo",
				"Ku",
				"Zhi",
				"Qiong",
				"Tong",
				"Sang",
				"Sang",
				"Huan",
				"Jie",
				"Jiu",
				"Xue",
				"Duo",
				"Zhui",
				"Yu",
				"Zan",
				"Kasei",
				"Ying",
				"Masu",
				,
				"Zhan",
				"Ya",
				"Nao",
				"Zhen",
				"Dang",
				"Qi",
				"Qiao",
				"Hua",
				"Kuai",
				"Jiang",
				"Zhuang",
				"Xun",
				"Suo",
				"Sha",
				"Zhen",
				"Bei",
				"Ting",
				"Gua",
				"Jing",
				"Bo",
				"Ben",
				"Fu",
				"Rui",
				"Tong",
				"Jue",
				"Xi",
				"Lang",
				"Liu",
				"Feng",
				"Qi",
				"Wen",
				"Jun",
				"Gan",
				"Cu",
				"Liang",
				"Qiu",
				"Ting",
				"You",
				"Mei",
				"Bang",
				"Long",
				"Peng",
				"Zhuang",
				"Di",
				"Xuan",
				"Tu",
				"Zao",
				"Ao",
				"Gu",
				"Bi",
				"Di",
				"Han",
				"Zi",
				"Zhi",
				"Ren",
				"Bei",
				"Geng",
				"Jian",
				"Huan",
				"Wan",
				"Nuo",
				"Jia",
				"Tiao",
				"Ji",
				"Xiao",
				"Lu",
				"Huan",
				"Shao",
				"Cen",
				"Fen",
				"Song",
				"Meng",
				"Wu",
				"Li",
				"Li",
				"Dou",
				"Cen",
				"Ying",
				"Suo",
				"Ju",
				"Ti",
				"Jie",
				"Kun",
				"Zhuo",
				"Shu",
				"Chan",
				"Fan",
				"Wei",
				"Jing",
				"Li",
				"Bing",
				"Fumoto",
				"Shikimi",
				"Tao",
				"Zhi",
				"Lai",
				"Lian",
				"Jian",
				"Zhuo",
				"Ling",
				"Li",
				"Qi",
				"Bing",
				"Zhun",
				"Cong",
				"Qian",
				"Mian",
				"Qi",
				"Qi",
				"Cai",
				"Gun",
				"Chan",
				"Te",
				"Fei",
				"Pai",
				"Bang",
				"Pou",
				"Hun",
				"Zong",
				"Cheng",
				"Zao",
				"Ji",
				"Li",
				"Peng",
				"Yu",
				"Yu",
				"Gu",
				"Hun",
				"Dong",
				"Tang",
				"Gang",
				"Wang",
				"Di",
				"Xi",
				"Fan",
				"Cheng",
				"Zhan",
				"Qi",
				"Yuan",
				"Yan",
				"Yu",
				"Quan",
				"Yi",
				"Sen",
				"Ren",
				"Chui",
				"Leng",
				"Qi",
				"Zhuo",
				"Fu",
				"Ke",
				"Lai",
				"Zou",
				"Zou",
				"Zhuo",
				"Guan",
				"Fen",
				"Fen",
				"Chen",
				"Qiong",
				"Nie"
			],
			[
				"Wan",
				"Guo",
				"Lu",
				"Hao",
				"Jie",
				"Yi",
				"Chou",
				"Ju",
				"Ju",
				"Cheng",
				"Zuo",
				"Liang",
				"Qiang",
				"Zhi",
				"Zhui",
				"Ya",
				"Ju",
				"Bei",
				"Jiao",
				"Zhuo",
				"Zi",
				"Bin",
				"Peng",
				"Ding",
				"Chu",
				"Chang",
				"Kunugi",
				"Momiji",
				"Jian",
				"Gui",
				"Xi",
				"Du",
				"Qian",
				"Kunugi",
				"Soko",
				"Shide",
				"Luo",
				"Zhi",
				"Ken",
				"Myeng",
				"Tafu",
				,
				"Peng",
				"Zhan",
				,
				"Tuo",
				"Sen",
				"Duo",
				"Ye",
				"Fou",
				"Wei",
				"Wei",
				"Duan",
				"Jia",
				"Zong",
				"Jian",
				"Yi",
				"Shen",
				"Xi",
				"Yan",
				"Yan",
				"Chuan",
				"Zhan",
				"Chun",
				"Yu",
				"He",
				"Zha",
				"Wo",
				"Pian",
				"Bi",
				"Yao",
				"Huo",
				"Xu",
				"Ruo",
				"Yang",
				"La",
				"Yan",
				"Ben",
				"Hun",
				"Kui",
				"Jie",
				"Kui",
				"Si",
				"Feng",
				"Xie",
				"Tuo",
				"Zhi",
				"Jian",
				"Mu",
				"Mao",
				"Chu",
				"Hu",
				"Hu",
				"Lian",
				"Leng",
				"Ting",
				"Nan",
				"Yu",
				"You",
				"Mei",
				"Song",
				"Xuan",
				"Xuan",
				"Ying",
				"Zhen",
				"Pian",
				"Ye",
				"Ji",
				"Jie",
				"Ye",
				"Chu",
				"Shun",
				"Yu",
				"Cou",
				"Wei",
				"Mei",
				"Di",
				"Ji",
				"Jie",
				"Kai",
				"Qiu",
				"Ying",
				"Rou",
				"Heng",
				"Lou",
				"Le",
				"Hazou",
				"Katsura",
				"Pin",
				"Muro",
				"Gai",
				"Tan",
				"Lan",
				"Yun",
				"Yu",
				"Chen",
				"Lu",
				"Ju",
				"Sakaki",
				,
				"Pi",
				"Xie",
				"Jia",
				"Yi",
				"Zhan",
				"Fu",
				"Nai",
				"Mi",
				"Lang",
				"Rong",
				"Gu",
				"Jian",
				"Ju",
				"Ta",
				"Yao",
				"Zhen",
				"Bang",
				"Sha",
				"Yuan",
				"Zi",
				"Ming",
				"Su",
				"Jia",
				"Yao",
				"Jie",
				"Huang",
				"Gan",
				"Fei",
				"Zha",
				"Qian",
				"Ma",
				"Sun",
				"Yuan",
				"Xie",
				"Rong",
				"Shi",
				"Zhi",
				"Cui",
				"Yun",
				"Ting",
				"Liu",
				"Rong",
				"Tang",
				"Que",
				"Zhai",
				"Si",
				"Sheng",
				"Ta",
				"Ke",
				"Xi",
				"Gu",
				"Qi",
				"Kao",
				"Gao",
				"Sun",
				"Pan",
				"Tao",
				"Ge",
				"Xun",
				"Dian",
				"Nou",
				"Ji",
				"Shuo",
				"Gou",
				"Chui",
				"Qiang",
				"Cha",
				"Qian",
				"Huai",
				"Mei",
				"Xu",
				"Gang",
				"Gao",
				"Zhuo",
				"Tuo",
				"Hashi",
				"Yang",
				"Dian",
				"Jia",
				"Jian",
				"Zui",
				"Kashi",
				"Ori",
				"Bin",
				"Zhu",
				,
				"Xi",
				"Qi",
				"Lian",
				"Hui",
				"Yong",
				"Qian",
				"Guo",
				"Gai",
				"Gai",
				"Tuan",
				"Hua",
				"Cu",
				"Sen",
				"Cui",
				"Beng",
				"You",
				"Hu",
				"Jiang",
				"Hu",
				"Huan",
				"Kui",
				"Yi",
				"Nie",
				"Gao",
				"Kang",
				"Gui",
				"Gui",
				"Cao",
				"Man",
				"Jin"
			],
			[
				"Di",
				"Zhuang",
				"Le",
				"Lang",
				"Chen",
				"Cong",
				"Li",
				"Xiu",
				"Qing",
				"Shuang",
				"Fan",
				"Tong",
				"Guan",
				"Ji",
				"Suo",
				"Lei",
				"Lu",
				"Liang",
				"Mi",
				"Lou",
				"Chao",
				"Su",
				"Ke",
				"Shu",
				"Tang",
				"Biao",
				"Lu",
				"Jiu",
				"Shu",
				"Zha",
				"Shu",
				"Zhang",
				"Men",
				"Mo",
				"Niao",
				"Yang",
				"Tiao",
				"Peng",
				"Zhu",
				"Sha",
				"Xi",
				"Quan",
				"Heng",
				"Jian",
				"Cong",
				,
				"Hokuso",
				"Qiang",
				"Tara",
				"Ying",
				"Er",
				"Xin",
				"Zhi",
				"Qiao",
				"Zui",
				"Cong",
				"Pu",
				"Shu",
				"Hua",
				"Kui",
				"Zhen",
				"Zun",
				"Yue",
				"Zhan",
				"Xi",
				"Xun",
				"Dian",
				"Fa",
				"Gan",
				"Mo",
				"Wu",
				"Qiao",
				"Nao",
				"Lin",
				"Liu",
				"Qiao",
				"Xian",
				"Run",
				"Fan",
				"Zhan",
				"Tuo",
				"Lao",
				"Yun",
				"Shun",
				"Tui",
				"Cheng",
				"Tang",
				"Meng",
				"Ju",
				"Cheng",
				"Su",
				"Jue",
				"Jue",
				"Tan",
				"Hui",
				"Ji",
				"Nuo",
				"Xiang",
				"Tuo",
				"Ning",
				"Rui",
				"Zhu",
				"Chuang",
				"Zeng",
				"Fen",
				"Qiong",
				"Ran",
				"Heng",
				"Cen",
				"Gu",
				"Liu",
				"Lao",
				"Gao",
				"Chu",
				"Zusa",
				"Nude",
				"Ca",
				"San",
				"Ji",
				"Dou",
				"Shou",
				"Lu",
				,
				,
				"Yuan",
				"Ta",
				"Shu",
				"Jiang",
				"Tan",
				"Lin",
				"Nong",
				"Yin",
				"Xi",
				"Sui",
				"Shan",
				"Zui",
				"Xuan",
				"Cheng",
				"Gan",
				"Ju",
				"Zui",
				"Yi",
				"Qin",
				"Pu",
				"Yan",
				"Lei",
				"Feng",
				"Hui",
				"Dang",
				"Ji",
				"Sui",
				"Bo",
				"Bi",
				"Ding",
				"Chu",
				"Zhua",
				"Kuai",
				"Ji",
				"Jie",
				"Jia",
				"Qing",
				"Zhe",
				"Jian",
				"Qiang",
				"Dao",
				"Yi",
				"Biao",
				"Song",
				"She",
				"Lin",
				"Kunugi",
				"Cha",
				"Meng",
				"Yin",
				"Tao",
				"Tai",
				"Mian",
				"Qi",
				"Toan",
				"Bin",
				"Huo",
				"Ji",
				"Qian",
				"Mi",
				"Ning",
				"Yi",
				"Gao",
				"Jian",
				"Yin",
				"Er",
				"Qing",
				"Yan",
				"Qi",
				"Mi",
				"Zhao",
				"Gui",
				"Chun",
				"Ji",
				"Kui",
				"Po",
				"Deng",
				"Chu",
				,
				"Mian",
				"You",
				"Zhi",
				"Guang",
				"Qian",
				"Lei",
				"Lei",
				"Sa",
				"Lu",
				"Li",
				"Cuan",
				"Lu",
				"Mie",
				"Hui",
				"Ou",
				"Lu",
				"Jie",
				"Gao",
				"Du",
				"Yuan",
				"Li",
				"Fei",
				"Zhuo",
				"Sou",
				"Lian",
				"Tamo",
				"Chu",
				,
				"Zhu",
				"Lu",
				"Yan",
				"Li",
				"Zhu",
				"Chen",
				"Jie",
				"E",
				"Su",
				"Huai",
				"Nie",
				"Yu",
				"Long",
				"Lai",
				,
				"Xian",
				"Kwi",
				"Ju",
				"Xiao",
				"Ling",
				"Ying",
				"Jian",
				"Yin",
				"You",
				"Ying"
			],
			[
				"Xiang",
				"Nong",
				"Bo",
				"Chan",
				"Lan",
				"Ju",
				"Shuang",
				"She",
				"Wei",
				"Cong",
				"Quan",
				"Qu",
				"Cang",
				,
				"Yu",
				"Luo",
				"Li",
				"Zan",
				"Luan",
				"Dang",
				"Jue",
				"Em",
				"Lan",
				"Lan",
				"Zhu",
				"Lei",
				"Li",
				"Ba",
				"Nang",
				"Yu",
				"Ling",
				"Tsuki",
				"Qian",
				"Ci",
				"Huan",
				"Xin",
				"Yu",
				"Yu",
				"Qian",
				"Ou",
				"Xu",
				"Chao",
				"Chu",
				"Chi",
				"Kai",
				"Yi",
				"Jue",
				"Xi",
				"Xu",
				"Xia",
				"Yu",
				"Kuai",
				"Lang",
				"Kuan",
				"Shuo",
				"Xi",
				"Ai",
				"Yi",
				"Qi",
				"Hu",
				"Chi",
				"Qin",
				"Kuan",
				"Kan",
				"Kuan",
				"Kan",
				"Chuan",
				"Sha",
				"Gua",
				"Yin",
				"Xin",
				"Xie",
				"Yu",
				"Qian",
				"Xiao",
				"Yi",
				"Ge",
				"Wu",
				"Tan",
				"Jin",
				"Ou",
				"Hu",
				"Ti",
				"Huan",
				"Xu",
				"Pen",
				"Xi",
				"Xiao",
				"Xu",
				"Xi",
				"Sen",
				"Lian",
				"Chu",
				"Yi",
				"Kan",
				"Yu",
				"Chuo",
				"Huan",
				"Zhi",
				"Zheng",
				"Ci",
				"Bu",
				"Wu",
				"Qi",
				"Bu",
				"Bu",
				"Wai",
				"Ju",
				"Qian",
				"Chi",
				"Se",
				"Chi",
				"Se",
				"Zhong",
				"Sui",
				"Sui",
				"Li",
				"Cuo",
				"Yu",
				"Li",
				"Gui",
				"Dai",
				"Dai",
				"Si",
				"Jian",
				"Zhe",
				"Mo",
				"Mo",
				"Yao",
				"Mo",
				"Cu",
				"Yang",
				"Tian",
				"Sheng",
				"Dai",
				"Shang",
				"Xu",
				"Xun",
				"Shu",
				"Can",
				"Jue",
				"Piao",
				"Qia",
				"Qiu",
				"Su",
				"Qing",
				"Yun",
				"Lian",
				"Yi",
				"Fou",
				"Zhi",
				"Ye",
				"Can",
				"Hun",
				"Dan",
				"Ji",
				"Ye",
				"Zhen",
				"Yun",
				"Wen",
				"Chou",
				"Bin",
				"Ti",
				"Jin",
				"Shang",
				"Yin",
				"Diao",
				"Cu",
				"Hui",
				"Cuan",
				"Yi",
				"Dan",
				"Du",
				"Jiang",
				"Lian",
				"Bin",
				"Du",
				"Tsukusu",
				"Jian",
				"Shu",
				"Ou",
				"Duan",
				"Zhu",
				"Yin",
				"Qing",
				"Yi",
				"Sha",
				"Que",
				"Ke",
				"Yao",
				"Jun",
				"Dian",
				"Hui",
				"Hui",
				"Gu",
				"Que",
				"Ji",
				"Yi",
				"Ou",
				"Hui",
				"Duan",
				"Yi",
				"Xiao",
				"Wu",
				"Guan",
				"Mu",
				"Mei",
				"Mei",
				"Ai",
				"Zuo",
				"Du",
				"Yu",
				"Bi",
				"Bi",
				"Bi",
				"Pi",
				"Pi",
				"Bi",
				"Chan",
				"Mao",
				,
				,
				"Pu",
				"Mushiru",
				"Jia",
				"Zhan",
				"Sai",
				"Mu",
				"Tuo",
				"Xun",
				"Er",
				"Rong",
				"Xian",
				"Ju",
				"Mu",
				"Hao",
				"Qiu",
				"Dou",
				"Mushiru",
				"Tan",
				"Pei",
				"Ju",
				"Duo",
				"Cui",
				"Bi",
				"San",
				,
				"Mao",
				"Sui",
				"Yu",
				"Yu",
				"Tuo",
				"He",
				"Jian",
				"Ta",
				"San"
			],
			[
				"Lu",
				"Mu",
				"Li",
				"Tong",
				"Rong",
				"Chang",
				"Pu",
				"Luo",
				"Zhan",
				"Sao",
				"Zhan",
				"Meng",
				"Luo",
				"Qu",
				"Die",
				"Shi",
				"Di",
				"Min",
				"Jue",
				"Mang",
				"Qi",
				"Pie",
				"Nai",
				"Qi",
				"Dao",
				"Xian",
				"Chuan",
				"Fen",
				"Ri",
				"Nei",
				,
				"Fu",
				"Shen",
				"Dong",
				"Qing",
				"Qi",
				"Yin",
				"Xi",
				"Hai",
				"Yang",
				"An",
				"Ya",
				"Ke",
				"Qing",
				"Ya",
				"Dong",
				"Dan",
				"Lu",
				"Qing",
				"Yang",
				"Yun",
				"Yun",
				"Shui",
				"San",
				"Zheng",
				"Bing",
				"Yong",
				"Dang",
				"Shitamizu",
				"Le",
				"Ni",
				"Tun",
				"Fan",
				"Gui",
				"Ting",
				"Zhi",
				"Qiu",
				"Bin",
				"Ze",
				"Mian",
				"Cuan",
				"Hui",
				"Diao",
				"Han",
				"Cha",
				"Zhuo",
				"Chuan",
				"Wan",
				"Fan",
				"Dai",
				"Xi",
				"Tuo",
				"Mang",
				"Qiu",
				"Qi",
				"Shan",
				"Pai",
				"Han",
				"Qian",
				"Wu",
				"Wu",
				"Xun",
				"Si",
				"Ru",
				"Gong",
				"Jiang",
				"Chi",
				"Wu",
				"Tsuchi",
				,
				"Tang",
				"Zhi",
				"Chi",
				"Qian",
				"Mi",
				"Yu",
				"Wang",
				"Qing",
				"Jing",
				"Rui",
				"Jun",
				"Hong",
				"Tai",
				"Quan",
				"Ji",
				"Bian",
				"Bian",
				"Gan",
				"Wen",
				"Zhong",
				"Fang",
				"Xiong",
				"Jue",
				"Hang",
				"Niou",
				"Qi",
				"Fen",
				"Xu",
				"Xu",
				"Qin",
				"Yi",
				"Wo",
				"Yun",
				"Yuan",
				"Hang",
				"Yan",
				"Shen",
				"Chen",
				"Dan",
				"You",
				"Dun",
				"Hu",
				"Huo",
				"Qie",
				"Mu",
				"Rou",
				"Mei",
				"Ta",
				"Mian",
				"Wu",
				"Chong",
				"Tian",
				"Bi",
				"Sha",
				"Zhi",
				"Pei",
				"Pan",
				"Zhui",
				"Za",
				"Gou",
				"Liu",
				"Mei",
				"Ze",
				"Feng",
				"Ou",
				"Li",
				"Lun",
				"Cang",
				"Feng",
				"Wei",
				"Hu",
				"Mo",
				"Mei",
				"Shu",
				"Ju",
				"Zan",
				"Tuo",
				"Tuo",
				"Tuo",
				"He",
				"Li",
				"Mi",
				"Yi",
				"Fa",
				"Fei",
				"You",
				"Tian",
				"Zhi",
				"Zhao",
				"Gu",
				"Zhan",
				"Yan",
				"Si",
				"Kuang",
				"Jiong",
				"Ju",
				"Xie",
				"Qiu",
				"Yi",
				"Jia",
				"Zhong",
				"Quan",
				"Bo",
				"Hui",
				"Mi",
				"Ben",
				"Zhuo",
				"Chu",
				"Le",
				"You",
				"Gu",
				"Hong",
				"Gan",
				"Fa",
				"Mao",
				"Si",
				"Hu",
				"Ping",
				"Ci",
				"Fan",
				"Chi",
				"Su",
				"Ning",
				"Cheng",
				"Ling",
				"Pao",
				"Bo",
				"Qi",
				"Si",
				"Ni",
				"Ju",
				"Yue",
				"Zhu",
				"Sheng",
				"Lei",
				"Xuan",
				"Xue",
				"Fu",
				"Pan",
				"Min",
				"Tai",
				"Yang",
				"Ji",
				"Yong",
				"Guan",
				"Beng",
				"Xue",
				"Long",
				"Lu",
				,
				"Bo",
				"Xie",
				"Po",
				"Ze",
				"Jing",
				"Yin"
			],
			[
				"Zhou",
				"Ji",
				"Yi",
				"Hui",
				"Hui",
				"Zui",
				"Cheng",
				"Yin",
				"Wei",
				"Hou",
				"Jian",
				"Yang",
				"Lie",
				"Si",
				"Ji",
				"Er",
				"Xing",
				"Fu",
				"Sa",
				"Suo",
				"Zhi",
				"Yin",
				"Wu",
				"Xi",
				"Kao",
				"Zhu",
				"Jiang",
				"Luo",
				,
				"An",
				"Dong",
				"Yi",
				"Mou",
				"Lei",
				"Yi",
				"Mi",
				"Quan",
				"Jin",
				"Mo",
				"Wei",
				"Xiao",
				"Xie",
				"Hong",
				"Xu",
				"Shuo",
				"Kuang",
				"Tao",
				"Qie",
				"Ju",
				"Er",
				"Zhou",
				"Ru",
				"Ping",
				"Xun",
				"Xiong",
				"Zhi",
				"Guang",
				"Huan",
				"Ming",
				"Huo",
				"Wa",
				"Qia",
				"Pai",
				"Wu",
				"Qu",
				"Liu",
				"Yi",
				"Jia",
				"Jing",
				"Qian",
				"Jiang",
				"Jiao",
				"Cheng",
				"Shi",
				"Zhuo",
				"Ce",
				"Pal",
				"Kuai",
				"Ji",
				"Liu",
				"Chan",
				"Hun",
				"Hu",
				"Nong",
				"Xun",
				"Jin",
				"Lie",
				"Qiu",
				"Wei",
				"Zhe",
				"Jun",
				"Han",
				"Bang",
				"Mang",
				"Zhuo",
				"You",
				"Xi",
				"Bo",
				"Dou",
				"Wan",
				"Hong",
				"Yi",
				"Pu",
				"Ying",
				"Lan",
				"Hao",
				"Lang",
				"Han",
				"Li",
				"Geng",
				"Fu",
				"Wu",
				"Lian",
				"Chun",
				"Feng",
				"Yi",
				"Yu",
				"Tong",
				"Lao",
				"Hai",
				"Jin",
				"Jia",
				"Chong",
				"Weng",
				"Mei",
				"Sui",
				"Cheng",
				"Pei",
				"Xian",
				"Shen",
				"Tu",
				"Kun",
				"Pin",
				"Nie",
				"Han",
				"Jing",
				"Xiao",
				"She",
				"Nian",
				"Tu",
				"Yong",
				"Xiao",
				"Xian",
				"Ting",
				"E",
				"Su",
				"Tun",
				"Juan",
				"Cen",
				"Ti",
				"Li",
				"Shui",
				"Si",
				"Lei",
				"Shui",
				"Tao",
				"Du",
				"Lao",
				"Lai",
				"Lian",
				"Wei",
				"Wo",
				"Yun",
				"Huan",
				"Di",
				,
				"Run",
				"Jian",
				"Zhang",
				"Se",
				"Fu",
				"Guan",
				"Xing",
				"Shou",
				"Shuan",
				"Ya",
				"Chuo",
				"Zhang",
				"Ye",
				"Kong",
				"Wo",
				"Han",
				"Tuo",
				"Dong",
				"He",
				"Wo",
				"Ju",
				"Gan",
				"Liang",
				"Hun",
				"Ta",
				"Zhuo",
				"Dian",
				"Qie",
				"De",
				"Juan",
				"Zi",
				"Xi",
				"Yao",
				"Qi",
				"Gu",
				"Guo",
				"Han",
				"Lin",
				"Tang",
				"Zhou",
				"Peng",
				"Hao",
				"Chang",
				"Shu",
				"Qi",
				"Fang",
				"Chi",
				"Lu",
				"Nao",
				"Ju",
				"Tao",
				"Cong",
				"Lei",
				"Zhi",
				"Peng",
				"Fei",
				"Song",
				"Tian",
				"Pi",
				"Dan",
				"Yu",
				"Ni",
				"Yu",
				"Lu",
				"Gan",
				"Mi",
				"Jing",
				"Ling",
				"Lun",
				"Yin",
				"Cui",
				"Qu",
				"Huai",
				"Yu",
				"Nian",
				"Shen",
				"Piao",
				"Chun",
				"Wa",
				"Yuan",
				"Lai",
				"Hun",
				"Qing",
				"Yan",
				"Qian",
				"Tian",
				"Miao",
				"Zhi",
				"Yin",
				"Mi"
			],
			[
				"Ben",
				"Yuan",
				"Wen",
				"Re",
				"Fei",
				"Qing",
				"Yuan",
				"Ke",
				"Ji",
				"She",
				"Yuan",
				"Shibui",
				"Lu",
				"Zi",
				"Du",
				,
				"Jian",
				"Min",
				"Pi",
				"Tani",
				"Yu",
				"Yuan",
				"Shen",
				"Shen",
				"Rou",
				"Huan",
				"Zhu",
				"Jian",
				"Nuan",
				"Yu",
				"Qiu",
				"Ting",
				"Qu",
				"Du",
				"Feng",
				"Zha",
				"Bo",
				"Wo",
				"Wo",
				"Di",
				"Wei",
				"Wen",
				"Ru",
				"Xie",
				"Ce",
				"Wei",
				"Ge",
				"Gang",
				"Yan",
				"Hong",
				"Xuan",
				"Mi",
				"Ke",
				"Mao",
				"Ying",
				"Yan",
				"You",
				"Hong",
				"Miao",
				"Xing",
				"Mei",
				"Zai",
				"Hun",
				"Nai",
				"Kui",
				"Shi",
				"E",
				"Pai",
				"Mei",
				"Lian",
				"Qi",
				"Qi",
				"Mei",
				"Tian",
				"Cou",
				"Wei",
				"Can",
				"Tuan",
				"Mian",
				"Hui",
				"Mo",
				"Xu",
				"Ji",
				"Pen",
				"Jian",
				"Jian",
				"Hu",
				"Feng",
				"Xiang",
				"Yi",
				"Yin",
				"Zhan",
				"Shi",
				"Jie",
				"Cheng",
				"Huang",
				"Tan",
				"Yu",
				"Bi",
				"Min",
				"Shi",
				"Tu",
				"Sheng",
				"Yong",
				"Qu",
				"Zhong",
				"Suei",
				"Jiu",
				"Jiao",
				"Qiou",
				"Yin",
				"Tang",
				"Long",
				"Huo",
				"Yuan",
				"Nan",
				"Ban",
				"You",
				"Quan",
				"Chui",
				"Liang",
				"Chan",
				"Yan",
				"Chun",
				"Nie",
				"Zi",
				"Wan",
				"Shi",
				"Man",
				"Ying",
				"Ratsu",
				"Kui",
				,
				"Jian",
				"Xu",
				"Lu",
				"Gui",
				"Gai",
				,
				,
				"Po",
				"Jin",
				"Gui",
				"Tang",
				"Yuan",
				"Suo",
				"Yuan",
				"Lian",
				"Yao",
				"Meng",
				"Zhun",
				"Sheng",
				"Ke",
				"Tai",
				"Da",
				"Wa",
				"Liu",
				"Gou",
				"Sao",
				"Ming",
				"Zha",
				"Shi",
				"Yi",
				"Lun",
				"Ma",
				"Pu",
				"Wei",
				"Li",
				"Cai",
				"Wu",
				"Xi",
				"Wen",
				"Qiang",
				"Ze",
				"Shi",
				"Su",
				"Yi",
				"Zhen",
				"Sou",
				"Yun",
				"Xiu",
				"Yin",
				"Rong",
				"Hun",
				"Su",
				"Su",
				"Ni",
				"Ta",
				"Shi",
				"Ru",
				"Wei",
				"Pan",
				"Chu",
				"Chu",
				"Pang",
				"Weng",
				"Cang",
				"Mie",
				"He",
				"Dian",
				"Hao",
				"Huang",
				"Xi",
				"Zi",
				"Di",
				"Zhi",
				"Ying",
				"Fu",
				"Jie",
				"Hua",
				"Ge",
				"Zi",
				"Tao",
				"Teng",
				"Sui",
				"Bi",
				"Jiao",
				"Hui",
				"Gun",
				"Yin",
				"Gao",
				"Long",
				"Zhi",
				"Yan",
				"She",
				"Man",
				"Ying",
				"Chun",
				"Lu",
				"Lan",
				"Luan",
				,
				"Bin",
				"Tan",
				"Yu",
				"Sou",
				"Hu",
				"Bi",
				"Biao",
				"Zhi",
				"Jiang",
				"Kou",
				"Shen",
				"Shang",
				"Di",
				"Mi",
				"Ao",
				"Lu",
				"Hu",
				"Hu",
				"You",
				"Chan",
				"Fan",
				"Yong",
				"Gun",
				"Man"
			],
			[
				"Qing",
				"Yu",
				"Piao",
				"Ji",
				"Ya",
				"Jiao",
				"Qi",
				"Xi",
				"Ji",
				"Lu",
				"Lu",
				"Long",
				"Jin",
				"Guo",
				"Cong",
				"Lou",
				"Zhi",
				"Gai",
				"Qiang",
				"Li",
				"Yan",
				"Cao",
				"Jiao",
				"Cong",
				"Qun",
				"Tuan",
				"Ou",
				"Teng",
				"Ye",
				"Xi",
				"Mi",
				"Tang",
				"Mo",
				"Shang",
				"Han",
				"Lian",
				"Lan",
				"Wa",
				"Li",
				"Qian",
				"Feng",
				"Xuan",
				"Yi",
				"Man",
				"Zi",
				"Mang",
				"Kang",
				"Lei",
				"Peng",
				"Shu",
				"Zhang",
				"Zhang",
				"Chong",
				"Xu",
				"Huan",
				"Kuo",
				"Jian",
				"Yan",
				"Chuang",
				"Liao",
				"Cui",
				"Ti",
				"Yang",
				"Jiang",
				"Cong",
				"Ying",
				"Hong",
				"Xun",
				"Shu",
				"Guan",
				"Ying",
				"Xiao",
				,
				,
				"Xu",
				"Lian",
				"Zhi",
				"Wei",
				"Pi",
				"Jue",
				"Jiao",
				"Po",
				"Dang",
				"Hui",
				"Jie",
				"Wu",
				"Pa",
				"Ji",
				"Pan",
				"Gui",
				"Xiao",
				"Qian",
				"Qian",
				"Xi",
				"Lu",
				"Xi",
				"Xuan",
				"Dun",
				"Huang",
				"Min",
				"Run",
				"Su",
				"Liao",
				"Zhen",
				"Zhong",
				"Yi",
				"Di",
				"Wan",
				"Dan",
				"Tan",
				"Chao",
				"Xun",
				"Kui",
				"Yie",
				"Shao",
				"Tu",
				"Zhu",
				"San",
				"Hei",
				"Bi",
				"Shan",
				"Chan",
				"Chan",
				"Shu",
				"Tong",
				"Pu",
				"Lin",
				"Wei",
				"Se",
				"Se",
				"Cheng",
				"Jiong",
				"Cheng",
				"Hua",
				"Jiao",
				"Lao",
				"Che",
				"Gan",
				"Cun",
				"Heng",
				"Si",
				"Shu",
				"Peng",
				"Han",
				"Yun",
				"Liu",
				"Hong",
				"Fu",
				"Hao",
				"He",
				"Xian",
				"Jian",
				"Shan",
				"Xi",
				"Oki",
				,
				"Lan",
				,
				"Yu",
				"Lin",
				"Min",
				"Zao",
				"Dang",
				"Wan",
				"Ze",
				"Xie",
				"Yu",
				"Li",
				"Shi",
				"Xue",
				"Ling",
				"Man",
				"Zi",
				"Yong",
				"Kuai",
				"Can",
				"Lian",
				"Dian",
				"Ye",
				"Ao",
				"Huan",
				"Zhen",
				"Chan",
				"Man",
				"Dan",
				"Dan",
				"Yi",
				"Sui",
				"Pi",
				"Ju",
				"Ta",
				"Qin",
				"Ji",
				"Zhuo",
				"Lian",
				"Nong",
				"Guo",
				"Jin",
				"Fen",
				"Se",
				"Ji",
				"Sui",
				"Hui",
				"Chu",
				"Ta",
				"Song",
				"Ding",
				,
				"Zhu",
				"Lai",
				"Bin",
				"Lian",
				"Mi",
				"Shi",
				"Shu",
				"Mi",
				"Ning",
				"Ying",
				"Ying",
				"Meng",
				"Jin",
				"Qi",
				"Pi",
				"Ji",
				"Hao",
				"Ru",
				"Zui",
				"Wo",
				"Tao",
				"Yin",
				"Yin",
				"Dui",
				"Ci",
				"Huo",
				"Jing",
				"Lan",
				"Jun",
				"Ai",
				"Pu",
				"Zhuo",
				"Wei",
				"Bin",
				"Gu",
				"Qian",
				"Xing",
				"Hama",
				"Kuo",
				"Fei",
				,
				"Boku",
				"Jian",
				"Wei",
				"Luo",
				"Zan",
				"Lu",
				"Li"
			],
			[
				"You",
				"Yang",
				"Lu",
				"Si",
				"Jie",
				"Ying",
				"Du",
				"Wang",
				"Hui",
				"Xie",
				"Pan",
				"Shen",
				"Biao",
				"Chan",
				"Mo",
				"Liu",
				"Jian",
				"Pu",
				"Se",
				"Cheng",
				"Gu",
				"Bin",
				"Huo",
				"Xian",
				"Lu",
				"Qin",
				"Han",
				"Ying",
				"Yong",
				"Li",
				"Jing",
				"Xiao",
				"Ying",
				"Sui",
				"Wei",
				"Xie",
				"Huai",
				"Hao",
				"Zhu",
				"Long",
				"Lai",
				"Dui",
				"Fan",
				"Hu",
				"Lai",
				,
				,
				"Ying",
				"Mi",
				"Ji",
				"Lian",
				"Jian",
				"Ying",
				"Fen",
				"Lin",
				"Yi",
				"Jian",
				"Yue",
				"Chan",
				"Dai",
				"Rang",
				"Jian",
				"Lan",
				"Fan",
				"Shuang",
				"Yuan",
				"Zhuo",
				"Feng",
				"She",
				"Lei",
				"Lan",
				"Cong",
				"Qu",
				"Yong",
				"Qian",
				"Fa",
				"Guan",
				"Que",
				"Yan",
				"Hao",
				"Hyeng",
				"Sa",
				"Zan",
				"Luan",
				"Yan",
				"Li",
				"Mi",
				"Shan",
				"Tan",
				"Dang",
				"Jiao",
				"Chan",
				,
				"Hao",
				"Ba",
				"Zhu",
				"Lan",
				"Lan",
				"Nang",
				"Wan",
				"Luan",
				"Xun",
				"Xian",
				"Yan",
				"Gan",
				"Yan",
				"Yu",
				"Huo",
				"Si",
				"Mie",
				"Guang",
				"Deng",
				"Hui",
				"Xiao",
				"Xiao",
				"Hu",
				"Hong",
				"Ling",
				"Zao",
				"Zhuan",
				"Jiu",
				"Zha",
				"Xie",
				"Chi",
				"Zhuo",
				"Zai",
				"Zai",
				"Can",
				"Yang",
				"Qi",
				"Zhong",
				"Fen",
				"Niu",
				"Jiong",
				"Wen",
				"Po",
				"Yi",
				"Lu",
				"Chui",
				"Pi",
				"Kai",
				"Pan",
				"Yan",
				"Kai",
				"Pang",
				"Mu",
				"Chao",
				"Liao",
				"Gui",
				"Kang",
				"Tun",
				"Guang",
				"Xin",
				"Zhi",
				"Guang",
				"Guang",
				"Wei",
				"Qiang",
				,
				"Da",
				"Xia",
				"Zheng",
				"Zhu",
				"Ke",
				"Zhao",
				"Fu",
				"Ba",
				"Duo",
				"Duo",
				"Ling",
				"Zhuo",
				"Xuan",
				"Ju",
				"Tan",
				"Pao",
				"Jiong",
				"Pao",
				"Tai",
				"Tai",
				"Bing",
				"Yang",
				"Tong",
				"Han",
				"Zhu",
				"Zha",
				"Dian",
				"Wei",
				"Shi",
				"Lian",
				"Chi",
				"Huang",
				,
				"Hu",
				"Shuo",
				"Lan",
				"Jing",
				"Jiao",
				"Xu",
				"Xing",
				"Quan",
				"Lie",
				"Huan",
				"Yang",
				"Xiao",
				"Xiu",
				"Xian",
				"Yin",
				"Wu",
				"Zhou",
				"Yao",
				"Shi",
				"Wei",
				"Tong",
				"Xue",
				"Zai",
				"Kai",
				"Hong",
				"Luo",
				"Xia",
				"Zhu",
				"Xuan",
				"Zheng",
				"Po",
				"Yan",
				"Hui",
				"Guang",
				"Zhe",
				"Hui",
				"Kao",
				,
				"Fan",
				"Shao",
				"Ye",
				"Hui",
				,
				"Tang",
				"Jin",
				"Re",
				,
				"Xi",
				"Fu",
				"Jiong",
				"Che",
				"Pu",
				"Jing",
				"Zhuo",
				"Ting",
				"Wan",
				"Hai",
				"Peng",
				"Lang",
				"Shan",
				"Hu",
				"Feng",
				"Chi",
				"Rong"
			],
			[
				"Hu",
				"Xi",
				"Shu",
				"He",
				"Xun",
				"Ku",
				"Jue",
				"Xiao",
				"Xi",
				"Yan",
				"Han",
				"Zhuang",
				"Jun",
				"Di",
				"Xie",
				"Ji",
				"Wu",
				,
				,
				"Han",
				"Yan",
				"Huan",
				"Men",
				"Ju",
				"Chou",
				"Bei",
				"Fen",
				"Lin",
				"Kun",
				"Hun",
				"Tun",
				"Xi",
				"Cui",
				"Wu",
				"Hong",
				"Ju",
				"Fu",
				"Wo",
				"Jiao",
				"Cong",
				"Feng",
				"Ping",
				"Qiong",
				"Ruo",
				"Xi",
				"Qiong",
				"Xin",
				"Zhuo",
				"Yan",
				"Yan",
				"Yi",
				"Jue",
				"Yu",
				"Gang",
				"Ran",
				"Pi",
				"Gu",
				,
				"Sheng",
				"Chang",
				"Shao",
				,
				,
				,
				,
				"Chen",
				"He",
				"Kui",
				"Zhong",
				"Duan",
				"Xia",
				"Hui",
				"Feng",
				"Lian",
				"Xuan",
				"Xing",
				"Huang",
				"Jiao",
				"Jian",
				"Bi",
				"Ying",
				"Zhu",
				"Wei",
				"Tuan",
				"Tian",
				"Xi",
				"Nuan",
				"Nuan",
				"Chan",
				"Yan",
				"Jiong",
				"Jiong",
				"Yu",
				"Mei",
				"Sha",
				"Wei",
				"Ye",
				"Xin",
				"Qiong",
				"Rou",
				"Mei",
				"Huan",
				"Xu",
				"Zhao",
				"Wei",
				"Fan",
				"Qiu",
				"Sui",
				"Yang",
				"Lie",
				"Zhu",
				"Jie",
				"Gao",
				"Gua",
				"Bao",
				"Hu",
				"Yun",
				"Xia",
				,
				,
				"Bian",
				"Gou",
				"Tui",
				"Tang",
				"Chao",
				"Shan",
				"N",
				"Bo",
				"Huang",
				"Xie",
				"Xi",
				"Wu",
				"Xi",
				"Yun",
				"He",
				"He",
				"Xi",
				"Yun",
				"Xiong",
				"Nai",
				"Shan",
				"Qiong",
				"Yao",
				"Xun",
				"Mi",
				"Lian",
				"Ying",
				"Wen",
				"Rong",
				"Oozutsu",
				,
				"Qiang",
				"Liu",
				"Xi",
				"Bi",
				"Biao",
				"Zong",
				"Lu",
				"Jian",
				"Shou",
				"Yi",
				"Lou",
				"Feng",
				"Sui",
				"Yi",
				"Tong",
				"Jue",
				"Zong",
				"Yun",
				"Hu",
				"Yi",
				"Zhi",
				"Ao",
				"Wei",
				"Liao",
				"Han",
				"Ou",
				"Re",
				"Jiong",
				"Man",
				,
				"Shang",
				"Cuan",
				"Zeng",
				"Jian",
				"Xi",
				"Xi",
				"Xi",
				"Yi",
				"Xiao",
				"Chi",
				"Huang",
				"Chan",
				"Ye",
				"Qian",
				"Ran",
				"Yan",
				"Xian",
				"Qiao",
				"Zun",
				"Deng",
				"Dun",
				"Shen",
				"Jiao",
				"Fen",
				"Si",
				"Liao",
				"Yu",
				"Lin",
				"Tong",
				"Shao",
				"Fen",
				"Fan",
				"Yan",
				"Xun",
				"Lan",
				"Mei",
				"Tang",
				"Yi",
				"Jing",
				"Men",
				,
				,
				"Ying",
				"Yu",
				"Yi",
				"Xue",
				"Lan",
				"Tai",
				"Zao",
				"Can",
				"Sui",
				"Xi",
				"Que",
				"Cong",
				"Lian",
				"Hui",
				"Zhu",
				"Xie",
				"Ling",
				"Wei",
				"Yi",
				"Xie",
				"Zhao",
				"Hui",
				"Tatsu",
				"Nung",
				"Lan",
				"Ru",
				"Xian",
				"Kao",
				"Xun",
				"Jin",
				"Chou",
				"Chou",
				"Yao"
			],
			[
				"He",
				"Lan",
				"Biao",
				"Rong",
				"Li",
				"Mo",
				"Bao",
				"Ruo",
				"Lu",
				"La",
				"Ao",
				"Xun",
				"Kuang",
				"Shuo",
				,
				"Li",
				"Lu",
				"Jue",
				"Liao",
				"Yan",
				"Xi",
				"Xie",
				"Long",
				"Ye",
				,
				"Rang",
				"Yue",
				"Lan",
				"Cong",
				"Jue",
				"Tong",
				"Guan",
				,
				"Che",
				"Mi",
				"Tang",
				"Lan",
				"Zhu",
				,
				"Ling",
				"Cuan",
				"Yu",
				"Zhua",
				"Tsumekanmuri",
				"Pa",
				"Zheng",
				"Pao",
				"Cheng",
				"Yuan",
				"Ai",
				"Wei",
				,
				"Jue",
				"Jue",
				"Fu",
				"Ye",
				"Ba",
				"Die",
				"Ye",
				"Yao",
				"Zu",
				"Shuang",
				"Er",
				"Qiang",
				"Chuang",
				"Ge",
				"Zang",
				"Die",
				"Qiang",
				"Yong",
				"Qiang",
				"Pian",
				"Ban",
				"Pan",
				"Shao",
				"Jian",
				"Pai",
				"Du",
				"Chuang",
				"Tou",
				"Zha",
				"Bian",
				"Die",
				"Bang",
				"Bo",
				"Chuang",
				"You",
				,
				"Du",
				"Ya",
				"Cheng",
				"Niu",
				"Ushihen",
				"Pin",
				"Jiu",
				"Mou",
				"Tuo",
				"Mu",
				"Lao",
				"Ren",
				"Mang",
				"Fang",
				"Mao",
				"Mu",
				"Gang",
				"Wu",
				"Yan",
				"Ge",
				"Bei",
				"Si",
				"Jian",
				"Gu",
				"You",
				"Ge",
				"Sheng",
				"Mu",
				"Di",
				"Qian",
				"Quan",
				"Quan",
				"Zi",
				"Te",
				"Xi",
				"Mang",
				"Keng",
				"Qian",
				"Wu",
				"Gu",
				"Xi",
				"Li",
				"Li",
				"Pou",
				"Ji",
				"Gang",
				"Zhi",
				"Ben",
				"Quan",
				"Run",
				"Du",
				"Ju",
				"Jia",
				"Jian",
				"Feng",
				"Pian",
				"Ke",
				"Ju",
				"Kao",
				"Chu",
				"Xi",
				"Bei",
				"Luo",
				"Jie",
				"Ma",
				"San",
				"Wei",
				"Li",
				"Dun",
				"Tong",
				,
				"Jiang",
				"Ikenie",
				"Li",
				"Du",
				"Lie",
				"Pi",
				"Piao",
				"Bao",
				"Xi",
				"Chou",
				"Wei",
				"Kui",
				"Chou",
				"Quan",
				"Fan",
				"Ba",
				"Fan",
				"Qiu",
				"Ji",
				"Cai",
				"Chuo",
				"An",
				"Jie",
				"Zhuang",
				"Guang",
				"Ma",
				"You",
				"Kang",
				"Bo",
				"Hou",
				"Ya",
				"Yin",
				"Huan",
				"Zhuang",
				"Yun",
				"Kuang",
				"Niu",
				"Di",
				"Qing",
				"Zhong",
				"Mu",
				"Bei",
				"Pi",
				"Ju",
				"Ni",
				"Sheng",
				"Pao",
				"Xia",
				"Tuo",
				"Hu",
				"Ling",
				"Fei",
				"Pi",
				"Ni",
				"Ao",
				"You",
				"Gou",
				"Yue",
				"Ju",
				"Dan",
				"Po",
				"Gu",
				"Xian",
				"Ning",
				"Huan",
				"Hen",
				"Jiao",
				"He",
				"Zhao",
				"Ji",
				"Xun",
				"Shan",
				"Ta",
				"Rong",
				"Shou",
				"Tong",
				"Lao",
				"Du",
				"Xia",
				"Shi",
				"Hua",
				"Zheng",
				"Yu",
				"Sun",
				"Yu",
				"Bi",
				"Mang",
				"Xi",
				"Juan",
				"Li",
				"Xia",
				"Yin",
				"Suan",
				"Lang",
				"Bei",
				"Zhi",
				"Yan"
			],
			[
				"Sha",
				"Li",
				"Han",
				"Xian",
				"Jing",
				"Pai",
				"Fei",
				"Yao",
				"Ba",
				"Qi",
				"Ni",
				"Biao",
				"Yin",
				"Lai",
				"Xi",
				"Jian",
				"Qiang",
				"Kun",
				"Yan",
				"Guo",
				"Zong",
				"Mi",
				"Chang",
				"Yi",
				"Zhi",
				"Zheng",
				"Ya",
				"Meng",
				"Cai",
				"Cu",
				"She",
				"Kari",
				"Cen",
				"Luo",
				"Hu",
				"Zong",
				"Ji",
				"Wei",
				"Feng",
				"Wo",
				"Yuan",
				"Xing",
				"Zhu",
				"Mao",
				"Wei",
				"Yuan",
				"Xian",
				"Tuan",
				"Ya",
				"Nao",
				"Xie",
				"Jia",
				"Hou",
				"Bian",
				"You",
				"You",
				"Mei",
				"Zha",
				"Yao",
				"Sun",
				"Bo",
				"Ming",
				"Hua",
				"Yuan",
				"Sou",
				"Ma",
				"Yuan",
				"Dai",
				"Yu",
				"Shi",
				"Hao",
				,
				"Yi",
				"Zhen",
				"Chuang",
				"Hao",
				"Man",
				"Jing",
				"Jiang",
				"Mu",
				"Zhang",
				"Chan",
				"Ao",
				"Ao",
				"Hao",
				"Cui",
				"Fen",
				"Jue",
				"Bi",
				"Bi",
				"Huang",
				"Pu",
				"Lin",
				"Yu",
				"Tong",
				"Yao",
				"Liao",
				"Shuo",
				"Xiao",
				"Swu",
				"Ton",
				"Xi",
				"Ge",
				"Juan",
				"Du",
				"Hui",
				"Kuai",
				"Xian",
				"Xie",
				"Ta",
				"Xian",
				"Xun",
				"Ning",
				"Pin",
				"Huo",
				"Nou",
				"Meng",
				"Lie",
				"Nao",
				"Guang",
				"Shou",
				"Lu",
				"Ta",
				"Xian",
				"Mi",
				"Rang",
				"Huan",
				"Nao",
				"Luo",
				"Xian",
				"Qi",
				"Jue",
				"Xuan",
				"Miao",
				"Zi",
				"Lu",
				"Lu",
				"Yu",
				"Su",
				"Wang",
				"Qiu",
				"Ga",
				"Ding",
				"Le",
				"Ba",
				"Ji",
				"Hong",
				"Di",
				"Quan",
				"Gan",
				"Jiu",
				"Yu",
				"Ji",
				"Yu",
				"Yang",
				"Ma",
				"Gong",
				"Wu",
				"Fu",
				"Wen",
				"Jie",
				"Ya",
				"Fen",
				"Bian",
				"Beng",
				"Yue",
				"Jue",
				"Yun",
				"Jue",
				"Wan",
				"Jian",
				"Mei",
				"Dan",
				"Pi",
				"Wei",
				"Huan",
				"Xian",
				"Qiang",
				"Ling",
				"Dai",
				"Yi",
				"An",
				"Ping",
				"Dian",
				"Fu",
				"Xuan",
				"Xi",
				"Bo",
				"Ci",
				"Gou",
				"Jia",
				"Shao",
				"Po",
				"Ci",
				"Ke",
				"Ran",
				"Sheng",
				"Shen",
				"Yi",
				"Zu",
				"Jia",
				"Min",
				"Shan",
				"Liu",
				"Bi",
				"Zhen",
				"Zhen",
				"Jue",
				"Fa",
				"Long",
				"Jin",
				"Jiao",
				"Jian",
				"Li",
				"Guang",
				"Xian",
				"Zhou",
				"Gong",
				"Yan",
				"Xiu",
				"Yang",
				"Xu",
				"Luo",
				"Su",
				"Zhu",
				"Qin",
				"Ken",
				"Xun",
				"Bao",
				"Er",
				"Xiang",
				"Yao",
				"Xia",
				"Heng",
				"Gui",
				"Chong",
				"Xu",
				"Ban",
				"Pei",
				,
				"Dang",
				"Ei",
				"Hun",
				"Wen",
				"E",
				"Cheng",
				"Ti",
				"Wu",
				"Wu",
				"Cheng",
				"Jun",
				"Mei",
				"Bei",
				"Ting",
				"Xian",
				"Chuo"
			],
			[
				"Han",
				"Xuan",
				"Yan",
				"Qiu",
				"Quan",
				"Lang",
				"Li",
				"Xiu",
				"Fu",
				"Liu",
				"Ye",
				"Xi",
				"Ling",
				"Li",
				"Jin",
				"Lian",
				"Suo",
				"Chiisai",
				,
				"Wan",
				"Dian",
				"Pin",
				"Zhan",
				"Cui",
				"Min",
				"Yu",
				"Ju",
				"Chen",
				"Lai",
				"Wen",
				"Sheng",
				"Wei",
				"Dian",
				"Chu",
				"Zhuo",
				"Pei",
				"Cheng",
				"Hu",
				"Qi",
				"E",
				"Kun",
				"Chang",
				"Qi",
				"Beng",
				"Wan",
				"Lu",
				"Cong",
				"Guan",
				"Yan",
				"Diao",
				"Bei",
				"Lin",
				"Qin",
				"Pi",
				"Pa",
				"Que",
				"Zhuo",
				"Qin",
				"Fa",
				,
				"Qiong",
				"Du",
				"Jie",
				"Hun",
				"Yu",
				"Mao",
				"Mei",
				"Chun",
				"Xuan",
				"Ti",
				"Xing",
				"Dai",
				"Rou",
				"Min",
				"Zhen",
				"Wei",
				"Ruan",
				"Huan",
				"Jie",
				"Chuan",
				"Jian",
				"Zhuan",
				"Yang",
				"Lian",
				"Quan",
				"Xia",
				"Duan",
				"Yuan",
				"Ye",
				"Nao",
				"Hu",
				"Ying",
				"Yu",
				"Huang",
				"Rui",
				"Se",
				"Liu",
				"Shi",
				"Rong",
				"Suo",
				"Yao",
				"Wen",
				"Wu",
				"Jin",
				"Jin",
				"Ying",
				"Ma",
				"Tao",
				"Liu",
				"Tang",
				"Li",
				"Lang",
				"Gui",
				"Zhen",
				"Qiang",
				"Cuo",
				"Jue",
				"Zhao",
				"Yao",
				"Ai",
				"Bin",
				"Tu",
				"Chang",
				"Kun",
				"Zhuan",
				"Cong",
				"Jin",
				"Yi",
				"Cui",
				"Cong",
				"Qi",
				"Li",
				"Ying",
				"Suo",
				"Qiu",
				"Xuan",
				"Ao",
				"Lian",
				"Man",
				"Zhang",
				"Yin",
				,
				"Ying",
				"Zhi",
				"Lu",
				"Wu",
				"Deng",
				"Xiou",
				"Zeng",
				"Xun",
				"Qu",
				"Dang",
				"Lin",
				"Liao",
				"Qiong",
				"Su",
				"Huang",
				"Gui",
				"Pu",
				"Jing",
				"Fan",
				"Jin",
				"Liu",
				"Ji",
				,
				"Jing",
				"Ai",
				"Bi",
				"Can",
				"Qu",
				"Zao",
				"Dang",
				"Jiao",
				"Gun",
				"Tan",
				"Hui",
				"Huan",
				"Se",
				"Sui",
				"Tian",
				,
				"Yu",
				"Jin",
				"Lu",
				"Bin",
				"Shou",
				"Wen",
				"Zui",
				"Lan",
				"Xi",
				"Ji",
				"Xuan",
				"Ruan",
				"Huo",
				"Gai",
				"Lei",
				"Du",
				"Li",
				"Zhi",
				"Rou",
				"Li",
				"Zan",
				"Qiong",
				"Zhe",
				"Gui",
				"Sui",
				"La",
				"Long",
				"Lu",
				"Li",
				"Zan",
				"Lan",
				"Ying",
				"Mi",
				"Xiang",
				"Xi",
				"Guan",
				"Dao",
				"Zan",
				"Huan",
				"Gua",
				"Bo",
				"Die",
				"Bao",
				"Hu",
				"Zhi",
				"Piao",
				"Ban",
				"Rang",
				"Li",
				"Wa",
				"Dekaguramu",
				"Jiang",
				"Qian",
				"Fan",
				"Pen",
				"Fang",
				"Dan",
				"Weng",
				"Ou",
				"Deshiguramu",
				"Miriguramu",
				"Thon",
				"Hu",
				"Ling",
				"Yi",
				"Ping",
				"Ci",
				"Hekutogura",
				"Juan",
				"Chang",
				"Chi",
				"Sarake",
				"Dang",
				"Meng",
				"Pou"
			],
			[
				"Zhui",
				"Ping",
				"Bian",
				"Zhou",
				"Zhen",
				"Senchigura",
				"Ci",
				"Ying",
				"Qi",
				"Xian",
				"Lou",
				"Di",
				"Ou",
				"Meng",
				"Zhuan",
				"Peng",
				"Lin",
				"Zeng",
				"Wu",
				"Pi",
				"Dan",
				"Weng",
				"Ying",
				"Yan",
				"Gan",
				"Dai",
				"Shen",
				"Tian",
				"Tian",
				"Han",
				"Chang",
				"Sheng",
				"Qing",
				"Sheng",
				"Chan",
				"Chan",
				"Rui",
				"Sheng",
				"Su",
				"Sen",
				"Yong",
				"Shuai",
				"Lu",
				"Fu",
				"Yong",
				"Beng",
				"Feng",
				"Ning",
				"Tian",
				"You",
				"Jia",
				"Shen",
				"Zha",
				"Dian",
				"Fu",
				"Nan",
				"Dian",
				"Ping",
				"Ting",
				"Hua",
				"Ting",
				"Quan",
				"Zi",
				"Meng",
				"Bi",
				"Qi",
				"Liu",
				"Xun",
				"Liu",
				"Chang",
				"Mu",
				"Yun",
				"Fan",
				"Fu",
				"Geng",
				"Tian",
				"Jie",
				"Jie",
				"Quan",
				"Wei",
				"Fu",
				"Tian",
				"Mu",
				"Tap",
				"Pan",
				"Jiang",
				"Wa",
				"Da",
				"Nan",
				"Liu",
				"Ben",
				"Zhen",
				"Chu",
				"Mu",
				"Mu",
				"Ce",
				"Cen",
				"Gai",
				"Bi",
				"Da",
				"Zhi",
				"Lue",
				"Qi",
				"Lue",
				"Pan",
				"Kesa",
				"Fan",
				"Hua",
				"Yu",
				"Yu",
				"Mu",
				"Jun",
				"Yi",
				"Liu",
				"Yu",
				"Die",
				"Chou",
				"Hua",
				"Dang",
				"Chuo",
				"Ji",
				"Wan",
				"Jiang",
				"Sheng",
				"Chang",
				"Tuan",
				"Lei",
				"Ji",
				"Cha",
				"Liu",
				"Tatamu",
				"Tuan",
				"Lin",
				"Jiang",
				"Jiang",
				"Chou",
				"Bo",
				"Die",
				"Die",
				"Pi",
				"Nie",
				"Dan",
				"Shu",
				"Shu",
				"Zhi",
				"Yi",
				"Chuang",
				"Nai",
				"Ding",
				"Bi",
				"Jie",
				"Liao",
				"Gong",
				"Ge",
				"Jiu",
				"Zhou",
				"Xia",
				"Shan",
				"Xu",
				"Nue",
				"Li",
				"Yang",
				"Chen",
				"You",
				"Ba",
				"Jie",
				"Jue",
				"Zhi",
				"Xia",
				"Cui",
				"Bi",
				"Yi",
				"Li",
				"Zong",
				"Chuang",
				"Feng",
				"Zhu",
				"Pao",
				"Pi",
				"Gan",
				"Ke",
				"Ci",
				"Xie",
				"Qi",
				"Dan",
				"Zhen",
				"Fa",
				"Zhi",
				"Teng",
				"Ju",
				"Ji",
				"Fei",
				"Qu",
				"Dian",
				"Jia",
				"Xian",
				"Cha",
				"Bing",
				"Ni",
				"Zheng",
				"Yong",
				"Jing",
				"Quan",
				"Chong",
				"Tong",
				"Yi",
				"Kai",
				"Wei",
				"Hui",
				"Duo",
				"Yang",
				"Chi",
				"Zhi",
				"Hen",
				"Ya",
				"Mei",
				"Dou",
				"Jing",
				"Xiao",
				"Tong",
				"Tu",
				"Mang",
				"Pi",
				"Xiao",
				"Suan",
				"Pu",
				"Li",
				"Zhi",
				"Cuo",
				"Duo",
				"Wu",
				"Sha",
				"Lao",
				"Shou",
				"Huan",
				"Xian",
				"Yi",
				"Peng",
				"Zhang",
				"Guan",
				"Tan",
				"Fei",
				"Ma",
				"Lin",
				"Chi",
				"Ji",
				"Dian",
				"An",
				"Chi",
				"Bi",
				"Bei",
				"Min",
				"Gu",
				"Dui",
				"E",
				"Wei"
			],
			[
				"Yu",
				"Cui",
				"Ya",
				"Zhu",
				"Cu",
				"Dan",
				"Shen",
				"Zhung",
				"Ji",
				"Yu",
				"Hou",
				"Feng",
				"La",
				"Yang",
				"Shen",
				"Tu",
				"Yu",
				"Gua",
				"Wen",
				"Huan",
				"Ku",
				"Jia",
				"Yin",
				"Yi",
				"Lu",
				"Sao",
				"Jue",
				"Chi",
				"Xi",
				"Guan",
				"Yi",
				"Wen",
				"Ji",
				"Chuang",
				"Ban",
				"Lei",
				"Liu",
				"Chai",
				"Shou",
				"Nue",
				"Dian",
				"Da",
				"Pie",
				"Tan",
				"Zhang",
				"Biao",
				"Shen",
				"Cu",
				"Luo",
				"Yi",
				"Zong",
				"Chou",
				"Zhang",
				"Zhai",
				"Sou",
				"Suo",
				"Que",
				"Diao",
				"Lou",
				"Lu",
				"Mo",
				"Jin",
				"Yin",
				"Ying",
				"Huang",
				"Fu",
				"Liao",
				"Long",
				"Qiao",
				"Liu",
				"Lao",
				"Xian",
				"Fei",
				"Dan",
				"Yin",
				"He",
				"Ai",
				"Ban",
				"Xian",
				"Guan",
				"Guai",
				"Nong",
				"Yu",
				"Wei",
				"Yi",
				"Yong",
				"Pi",
				"Lei",
				"Li",
				"Shu",
				"Dan",
				"Lin",
				"Dian",
				"Lin",
				"Lai",
				"Pie",
				"Ji",
				"Chi",
				"Yang",
				"Xian",
				"Jie",
				"Zheng",
				,
				"Li",
				"Huo",
				"Lai",
				"Shaku",
				"Dian",
				"Xian",
				"Ying",
				"Yin",
				"Qu",
				"Yong",
				"Tan",
				"Dian",
				"Luo",
				"Luan",
				"Luan",
				"Bo",
				,
				"Gui",
				"Po",
				"Fa",
				"Deng",
				"Fa",
				"Bai",
				"Bai",
				"Qie",
				"Bi",
				"Zao",
				"Zao",
				"Mao",
				"De",
				"Pa",
				"Jie",
				"Huang",
				"Gui",
				"Ci",
				"Ling",
				"Gao",
				"Mo",
				"Ji",
				"Jiao",
				"Peng",
				"Gao",
				"Ai",
				"E",
				"Hao",
				"Han",
				"Bi",
				"Wan",
				"Chou",
				"Qian",
				"Xi",
				"Ai",
				"Jiong",
				"Hao",
				"Huang",
				"Hao",
				"Ze",
				"Cui",
				"Hao",
				"Xiao",
				"Ye",
				"Po",
				"Hao",
				"Jiao",
				"Ai",
				"Xing",
				"Huang",
				"Li",
				"Piao",
				"He",
				"Jiao",
				"Pi",
				"Gan",
				"Pao",
				"Zhou",
				"Jun",
				"Qiu",
				"Cun",
				"Que",
				"Zha",
				"Gu",
				"Jun",
				"Jun",
				"Zhou",
				"Zha",
				"Gu",
				"Zhan",
				"Du",
				"Min",
				"Qi",
				"Ying",
				"Yu",
				"Bei",
				"Zhao",
				"Zhong",
				"Pen",
				"He",
				"Ying",
				"He",
				"Yi",
				"Bo",
				"Wan",
				"He",
				"Ang",
				"Zhan",
				"Yan",
				"Jian",
				"He",
				"Yu",
				"Kui",
				"Fan",
				"Gai",
				"Dao",
				"Pan",
				"Fu",
				"Qiu",
				"Sheng",
				"Dao",
				"Lu",
				"Zhan",
				"Meng",
				"Li",
				"Jin",
				"Xu",
				"Jian",
				"Pan",
				"Guan",
				"An",
				"Lu",
				"Shu",
				"Zhou",
				"Dang",
				"An",
				"Gu",
				"Li",
				"Mu",
				"Cheng",
				"Gan",
				"Xu",
				"Mang",
				"Mang",
				"Zhi",
				"Qi",
				"Ruan",
				"Tian",
				"Xiang",
				"Dun",
				"Xin",
				"Xi",
				"Pan",
				"Feng",
				"Dun",
				"Min"
			],
			[
				"Ming",
				"Sheng",
				"Shi",
				"Yun",
				"Mian",
				"Pan",
				"Fang",
				"Miao",
				"Dan",
				"Mei",
				"Mao",
				"Kan",
				"Xian",
				"Ou",
				"Shi",
				"Yang",
				"Zheng",
				"Yao",
				"Shen",
				"Huo",
				"Da",
				"Zhen",
				"Kuang",
				"Ju",
				"Shen",
				"Chi",
				"Sheng",
				"Mei",
				"Mo",
				"Zhu",
				"Zhen",
				"Zhen",
				"Mian",
				"Di",
				"Yuan",
				"Die",
				"Yi",
				"Zi",
				"Zi",
				"Chao",
				"Zha",
				"Xuan",
				"Bing",
				"Mi",
				"Long",
				"Sui",
				"Dong",
				"Mi",
				"Die",
				"Yi",
				"Er",
				"Ming",
				"Xuan",
				"Chi",
				"Kuang",
				"Juan",
				"Mou",
				"Zhen",
				"Tiao",
				"Yang",
				"Yan",
				"Mo",
				"Zhong",
				"Mai",
				"Zhao",
				"Zheng",
				"Mei",
				"Jun",
				"Shao",
				"Han",
				"Huan",
				"Di",
				"Cheng",
				"Cuo",
				"Juan",
				"E",
				"Wan",
				"Xian",
				"Xi",
				"Kun",
				"Lai",
				"Jian",
				"Shan",
				"Tian",
				"Hun",
				"Wan",
				"Ling",
				"Shi",
				"Qiong",
				"Lie",
				"Yai",
				"Jing",
				"Zheng",
				"Li",
				"Lai",
				"Sui",
				"Juan",
				"Shui",
				"Sui",
				"Du",
				"Bi",
				"Bi",
				"Mu",
				"Hun",
				"Ni",
				"Lu",
				"Yi",
				"Jie",
				"Cai",
				"Zhou",
				"Yu",
				"Hun",
				"Ma",
				"Xia",
				"Xing",
				"Xi",
				"Gun",
				"Cai",
				"Chun",
				"Jian",
				"Mei",
				"Du",
				"Hou",
				"Xuan",
				"Ti",
				"Kui",
				"Gao",
				"Rui",
				"Mou",
				"Xu",
				"Fa",
				"Wen",
				"Miao",
				"Chou",
				"Kui",
				"Mi",
				"Weng",
				"Kou",
				"Dang",
				"Chen",
				"Ke",
				"Sou",
				"Xia",
				"Qiong",
				"Mao",
				"Ming",
				"Man",
				"Shui",
				"Ze",
				"Zhang",
				"Yi",
				"Diao",
				"Ou",
				"Mo",
				"Shun",
				"Cong",
				"Lou",
				"Chi",
				"Man",
				"Piao",
				"Cheng",
				"Ji",
				"Meng",
				,
				"Run",
				"Pie",
				"Xi",
				"Qiao",
				"Pu",
				"Zhu",
				"Deng",
				"Shen",
				"Shun",
				"Liao",
				"Che",
				"Xian",
				"Kan",
				"Ye",
				"Xu",
				"Tong",
				"Mou",
				"Lin",
				"Kui",
				"Xian",
				"Ye",
				"Ai",
				"Hui",
				"Zhan",
				"Jian",
				"Gu",
				"Zhao",
				"Qu",
				"Wei",
				"Chou",
				"Sao",
				"Ning",
				"Xun",
				"Yao",
				"Huo",
				"Meng",
				"Mian",
				"Bin",
				"Mian",
				"Li",
				"Kuang",
				"Jue",
				"Xuan",
				"Mian",
				"Huo",
				"Lu",
				"Meng",
				"Long",
				"Guan",
				"Man",
				"Xi",
				"Chu",
				"Tang",
				"Kan",
				"Zhu",
				"Mao",
				"Jin",
				"Lin",
				"Yu",
				"Shuo",
				"Ce",
				"Jue",
				"Shi",
				"Yi",
				"Shen",
				"Zhi",
				"Hou",
				"Shen",
				"Ying",
				"Ju",
				"Zhou",
				"Jiao",
				"Cuo",
				"Duan",
				"Ai",
				"Jiao",
				"Zeng",
				"Huo",
				"Bai",
				"Shi",
				"Ding",
				"Qi",
				"Ji",
				"Zi",
				"Gan",
				"Wu",
				"Tuo",
				"Ku",
				"Qiang",
				"Xi",
				"Fan",
				"Kuang"
			],
			[
				"Dang",
				"Ma",
				"Sha",
				"Dan",
				"Jue",
				"Li",
				"Fu",
				"Min",
				"Nuo",
				"Huo",
				"Kang",
				"Zhi",
				"Qi",
				"Kan",
				"Jie",
				"Fen",
				"E",
				"Ya",
				"Pi",
				"Zhe",
				"Yan",
				"Sui",
				"Zhuan",
				"Che",
				"Dun",
				"Pan",
				"Yan",
				,
				"Feng",
				"Fa",
				"Mo",
				"Zha",
				"Qu",
				"Yu",
				"Luo",
				"Tuo",
				"Tuo",
				"Di",
				"Zhai",
				"Zhen",
				"Ai",
				"Fei",
				"Mu",
				"Zhu",
				"Li",
				"Bian",
				"Nu",
				"Ping",
				"Peng",
				"Ling",
				"Pao",
				"Le",
				"Po",
				"Bo",
				"Po",
				"Shen",
				"Za",
				"Nuo",
				"Li",
				"Long",
				"Tong",
				,
				"Li",
				"Aragane",
				"Chu",
				"Keng",
				"Quan",
				"Zhu",
				"Kuang",
				"Huo",
				"E",
				"Nao",
				"Jia",
				"Lu",
				"Wei",
				"Ai",
				"Luo",
				"Ken",
				"Xing",
				"Yan",
				"Tong",
				"Peng",
				"Xi",
				,
				"Hong",
				"Shuo",
				"Xia",
				"Qiao",
				,
				"Wei",
				"Qiao",
				,
				"Keng",
				"Xiao",
				"Que",
				"Chan",
				"Lang",
				"Hong",
				"Yu",
				"Xiao",
				"Xia",
				"Mang",
				"Long",
				"Iong",
				"Che",
				"Che",
				"E",
				"Liu",
				"Ying",
				"Mang",
				"Que",
				"Yan",
				"Sha",
				"Kun",
				"Yu",
				,
				"Kaki",
				"Lu",
				"Chen",
				"Jian",
				"Nue",
				"Song",
				"Zhuo",
				"Keng",
				"Peng",
				"Yan",
				"Zhui",
				"Kong",
				"Ceng",
				"Qi",
				"Zong",
				"Qing",
				"Lin",
				"Jun",
				"Bo",
				"Ding",
				"Min",
				"Diao",
				"Jian",
				"He",
				"Lu",
				"Ai",
				"Sui",
				"Que",
				"Ling",
				"Bei",
				"Yin",
				"Dui",
				"Wu",
				"Qi",
				"Lun",
				"Wan",
				"Dian",
				"Gang",
				"Pei",
				"Qi",
				"Chen",
				"Ruan",
				"Yan",
				"Die",
				"Ding",
				"Du",
				"Tuo",
				"Jie",
				"Ying",
				"Bian",
				"Ke",
				"Bi",
				"Wei",
				"Shuo",
				"Zhen",
				"Duan",
				"Xia",
				"Dang",
				"Ti",
				"Nao",
				"Peng",
				"Jian",
				"Di",
				"Tan",
				"Cha",
				"Seki",
				"Qi",
				,
				"Feng",
				"Xuan",
				"Que",
				"Que",
				"Ma",
				"Gong",
				"Nian",
				"Su",
				"E",
				"Ci",
				"Liu",
				"Si",
				"Tang",
				"Bang",
				"Hua",
				"Pi",
				"Wei",
				"Sang",
				"Lei",
				"Cuo",
				"Zhen",
				"Xia",
				"Qi",
				"Lian",
				"Pan",
				"Wei",
				"Yun",
				"Dui",
				"Zhe",
				"Ke",
				"La",
				,
				"Qing",
				"Gun",
				"Zhuan",
				"Chan",
				"Qi",
				"Ao",
				"Peng",
				"Lu",
				"Lu",
				"Kan",
				"Qiang",
				"Chen",
				"Yin",
				"Lei",
				"Biao",
				"Qi",
				"Mo",
				"Qi",
				"Cui",
				"Zong",
				"Qing",
				"Chuo",
				,
				"Ji",
				"Shan",
				"Lao",
				"Qu",
				"Zeng",
				"Deng",
				"Jian",
				"Xi",
				"Lin",
				"Ding",
				"Dian",
				"Huang",
				"Pan",
				"Za",
				"Qiao",
				"Di",
				"Li"
			],
			[
				"Tani",
				"Jiao",
				,
				"Zhang",
				"Qiao",
				"Dun",
				"Xian",
				"Yu",
				"Zhui",
				"He",
				"Huo",
				"Zhai",
				"Lei",
				"Ke",
				"Chu",
				"Ji",
				"Que",
				"Dang",
				"Yi",
				"Jiang",
				"Pi",
				"Pi",
				"Yu",
				"Pin",
				"Qi",
				"Ai",
				"Kai",
				"Jian",
				"Yu",
				"Ruan",
				"Meng",
				"Pao",
				"Ci",
				,
				,
				"Mie",
				"Ca",
				"Xian",
				"Kuang",
				"Lei",
				"Lei",
				"Zhi",
				"Li",
				"Li",
				"Fan",
				"Que",
				"Pao",
				"Ying",
				"Li",
				"Long",
				"Long",
				"Mo",
				"Bo",
				"Shuang",
				"Guan",
				"Lan",
				"Zan",
				"Yan",
				"Shi",
				"Shi",
				"Li",
				"Reng",
				"She",
				"Yue",
				"Si",
				"Qi",
				"Ta",
				"Ma",
				"Xie",
				"Xian",
				"Xian",
				"Zhi",
				"Qi",
				"Zhi",
				"Beng",
				"Dui",
				"Zhong",
				,
				"Yi",
				"Shi",
				"You",
				"Zhi",
				"Tiao",
				"Fu",
				"Fu",
				"Mi",
				"Zu",
				"Zhi",
				"Suan",
				"Mei",
				"Zuo",
				"Qu",
				"Hu",
				"Zhu",
				"Shen",
				"Sui",
				"Ci",
				"Chai",
				"Mi",
				"Lu",
				"Yu",
				"Xiang",
				"Wu",
				"Tiao",
				"Piao",
				"Zhu",
				"Gui",
				"Xia",
				"Zhi",
				"Ji",
				"Gao",
				"Zhen",
				"Gao",
				"Shui",
				"Jin",
				"Chen",
				"Gai",
				"Kun",
				"Di",
				"Dao",
				"Huo",
				"Tao",
				"Qi",
				"Gu",
				"Guan",
				"Zui",
				"Ling",
				"Lu",
				"Bing",
				"Jin",
				"Dao",
				"Zhi",
				"Lu",
				"Shan",
				"Bei",
				"Zhe",
				"Hui",
				"You",
				"Xi",
				"Yin",
				"Zi",
				"Huo",
				"Zhen",
				"Fu",
				"Yuan",
				"Wu",
				"Xian",
				"Yang",
				"Ti",
				"Yi",
				"Mei",
				"Si",
				"Di",
				,
				"Zhuo",
				"Zhen",
				"Yong",
				"Ji",
				"Gao",
				"Tang",
				"Si",
				"Ma",
				"Ta",
				,
				"Xuan",
				"Qi",
				"Yu",
				"Xi",
				"Ji",
				"Si",
				"Chan",
				"Tan",
				"Kuai",
				"Sui",
				"Li",
				"Nong",
				"Ni",
				"Dao",
				"Li",
				"Rang",
				"Yue",
				"Ti",
				"Zan",
				"Lei",
				"Rou",
				"Yu",
				"Yu",
				"Chi",
				"Xie",
				"Qin",
				"He",
				"Tu",
				"Xiu",
				"Si",
				"Ren",
				"Tu",
				"Zi",
				"Cha",
				"Gan",
				"Yi",
				"Xian",
				"Bing",
				"Nian",
				"Qiu",
				"Qiu",
				"Zhong",
				"Fen",
				"Hao",
				"Yun",
				"Ke",
				"Miao",
				"Zhi",
				"Geng",
				"Bi",
				"Zhi",
				"Yu",
				"Mi",
				"Ku",
				"Ban",
				"Pi",
				"Ni",
				"Li",
				"You",
				"Zu",
				"Pi",
				"Ba",
				"Ling",
				"Mo",
				"Cheng",
				"Nian",
				"Qin",
				"Yang",
				"Zuo",
				"Zhi",
				"Zhi",
				"Shu",
				"Ju",
				"Zi",
				"Huo",
				"Ji",
				"Cheng",
				"Tong",
				"Zhi",
				"Huo",
				"He",
				"Yin",
				"Zi",
				"Zhi",
				"Jie",
				"Ren",
				"Du",
				"Yi",
				"Zhu",
				"Hui",
				"Nong",
				"Fu"
			],
			[
				"Xi",
				"Kao",
				"Lang",
				"Fu",
				"Ze",
				"Shui",
				"Lu",
				"Kun",
				"Gan",
				"Geng",
				"Ti",
				"Cheng",
				"Tu",
				"Shao",
				"Shui",
				"Ya",
				"Lun",
				"Lu",
				"Gu",
				"Zuo",
				"Ren",
				"Zhun",
				"Bang",
				"Bai",
				"Ji",
				"Zhi",
				"Zhi",
				"Kun",
				"Leng",
				"Peng",
				"Ke",
				"Bing",
				"Chou",
				"Zu",
				"Yu",
				"Su",
				"Lue",
				,
				"Yi",
				"Xi",
				"Bian",
				"Ji",
				"Fu",
				"Bi",
				"Nuo",
				"Jie",
				"Zhong",
				"Zong",
				"Xu",
				"Cheng",
				"Dao",
				"Wen",
				"Lian",
				"Zi",
				"Yu",
				"Ji",
				"Xu",
				"Zhen",
				"Zhi",
				"Dao",
				"Jia",
				"Ji",
				"Gao",
				"Gao",
				"Gu",
				"Rong",
				"Sui",
				"You",
				"Ji",
				"Kang",
				"Mu",
				"Shan",
				"Men",
				"Zhi",
				"Ji",
				"Lu",
				"Su",
				"Ji",
				"Ying",
				"Wen",
				"Qiu",
				"Se",
				,
				"Yi",
				"Huang",
				"Qie",
				"Ji",
				"Sui",
				"Xiao",
				"Pu",
				"Jiao",
				"Zhuo",
				"Tong",
				"Sai",
				"Lu",
				"Sui",
				"Nong",
				"Se",
				"Hui",
				"Rang",
				"Nuo",
				"Yu",
				"Bin",
				"Ji",
				"Tui",
				"Wen",
				"Cheng",
				"Huo",
				"Gong",
				"Lu",
				"Biao",
				,
				"Rang",
				"Zhuo",
				"Li",
				"Zan",
				"Xue",
				"Wa",
				"Jiu",
				"Qiong",
				"Xi",
				"Qiong",
				"Kong",
				"Yu",
				"Sen",
				"Jing",
				"Yao",
				"Chuan",
				"Zhun",
				"Tu",
				"Lao",
				"Qie",
				"Zhai",
				"Yao",
				"Bian",
				"Bao",
				"Yao",
				"Bing",
				"Wa",
				"Zhu",
				"Jiao",
				"Qiao",
				"Diao",
				"Wu",
				"Gui",
				"Yao",
				"Zhi",
				"Chuang",
				"Yao",
				"Tiao",
				"Jiao",
				"Chuang",
				"Jiong",
				"Xiao",
				"Cheng",
				"Kou",
				"Cuan",
				"Wo",
				"Dan",
				"Ku",
				"Ke",
				"Zhui",
				"Xu",
				"Su",
				"Guan",
				"Kui",
				"Dou",
				,
				"Yin",
				"Wo",
				"Wa",
				"Ya",
				"Yu",
				"Ju",
				"Qiong",
				"Yao",
				"Yao",
				"Tiao",
				"Chao",
				"Yu",
				"Tian",
				"Diao",
				"Ju",
				"Liao",
				"Xi",
				"Wu",
				"Kui",
				"Chuang",
				"Zhao",
				,
				"Kuan",
				"Long",
				"Cheng",
				"Cui",
				"Piao",
				"Zao",
				"Cuan",
				"Qiao",
				"Qiong",
				"Dou",
				"Zao",
				"Long",
				"Qie",
				"Li",
				"Chu",
				"Shi",
				"Fou",
				"Qian",
				"Chu",
				"Hong",
				"Qi",
				"Qian",
				"Gong",
				"Shi",
				"Shu",
				"Miao",
				"Ju",
				"Zhan",
				"Zhu",
				"Ling",
				"Long",
				"Bing",
				"Jing",
				"Jing",
				"Zhang",
				"Yi",
				"Si",
				"Jun",
				"Hong",
				"Tong",
				"Song",
				"Jing",
				"Diao",
				"Yi",
				"Shu",
				"Jing",
				"Qu",
				"Jie",
				"Ping",
				"Duan",
				"Shao",
				"Zhuan",
				"Ceng",
				"Deng",
				"Cui",
				"Huai",
				"Jing",
				"Kan",
				"Jing",
				"Zhu",
				"Zhu",
				"Le",
				"Peng",
				"Yu",
				"Chi",
				"Gan"
			],
			[
				"Mang",
				"Zhu",
				"Utsubo",
				"Du",
				"Ji",
				"Xiao",
				"Ba",
				"Suan",
				"Ji",
				"Zhen",
				"Zhao",
				"Sun",
				"Ya",
				"Zhui",
				"Yuan",
				"Hu",
				"Gang",
				"Xiao",
				"Cen",
				"Pi",
				"Bi",
				"Jian",
				"Yi",
				"Dong",
				"Shan",
				"Sheng",
				"Xia",
				"Di",
				"Zhu",
				"Na",
				"Chi",
				"Gu",
				"Li",
				"Qie",
				"Min",
				"Bao",
				"Tiao",
				"Si",
				"Fu",
				"Ce",
				"Ben",
				"Pei",
				"Da",
				"Zi",
				"Di",
				"Ling",
				"Ze",
				"Nu",
				"Fu",
				"Gou",
				"Fan",
				"Jia",
				"Ge",
				"Fan",
				"Shi",
				"Mao",
				"Po",
				"Sey",
				"Jian",
				"Qiong",
				"Long",
				"Souke",
				"Bian",
				"Luo",
				"Gui",
				"Qu",
				"Chi",
				"Yin",
				"Yao",
				"Xian",
				"Bi",
				"Qiong",
				"Gua",
				"Deng",
				"Jiao",
				"Jin",
				"Quan",
				"Sun",
				"Ru",
				"Fa",
				"Kuang",
				"Zhu",
				"Tong",
				"Ji",
				"Da",
				"Xing",
				"Ce",
				"Zhong",
				"Kou",
				"Lai",
				"Bi",
				"Shai",
				"Dang",
				"Zheng",
				"Ce",
				"Fu",
				"Yun",
				"Tu",
				"Pa",
				"Li",
				"Lang",
				"Ju",
				"Guan",
				"Jian",
				"Han",
				"Tong",
				"Xia",
				"Zhi",
				"Cheng",
				"Suan",
				"Shi",
				"Zhu",
				"Zuo",
				"Xiao",
				"Shao",
				"Ting",
				"Ce",
				"Yan",
				"Gao",
				"Kuai",
				"Gan",
				"Chou",
				"Kago",
				"Gang",
				"Yun",
				"O",
				"Qian",
				"Xiao",
				"Jian",
				"Pu",
				"Lai",
				"Zou",
				"Bi",
				"Bi",
				"Bi",
				"Ge",
				"Chi",
				"Guai",
				"Yu",
				"Jian",
				"Zhao",
				"Gu",
				"Chi",
				"Zheng",
				"Jing",
				"Sha",
				"Zhou",
				"Lu",
				"Bo",
				"Ji",
				"Lin",
				"Suan",
				"Jun",
				"Fu",
				"Zha",
				"Gu",
				"Kong",
				"Qian",
				"Quan",
				"Jun",
				"Chui",
				"Guan",
				"Yuan",
				"Ce",
				"Ju",
				"Bo",
				"Ze",
				"Qie",
				"Tuo",
				"Luo",
				"Dan",
				"Xiao",
				"Ruo",
				"Jian",
				"Xuan",
				"Bian",
				"Sun",
				"Xiang",
				"Xian",
				"Ping",
				"Zhen",
				"Sheng",
				"Hu",
				"Shi",
				"Zhu",
				"Yue",
				"Chun",
				"Lu",
				"Wu",
				"Dong",
				"Xiao",
				"Ji",
				"Jie",
				"Huang",
				"Xing",
				"Mei",
				"Fan",
				"Chui",
				"Zhuan",
				"Pian",
				"Feng",
				"Zhu",
				"Hong",
				"Qie",
				"Hou",
				"Qiu",
				"Miao",
				"Qian",
				,
				"Kui",
				"Sik",
				"Lou",
				"Yun",
				"He",
				"Tang",
				"Yue",
				"Chou",
				"Gao",
				"Fei",
				"Ruo",
				"Zheng",
				"Gou",
				"Nie",
				"Qian",
				"Xiao",
				"Cuan",
				"Gong",
				"Pang",
				"Du",
				"Li",
				"Bi",
				"Zhuo",
				"Chu",
				"Shai",
				"Chi",
				"Zhu",
				"Qiang",
				"Long",
				"Lan",
				"Jian",
				"Bu",
				"Li",
				"Hui",
				"Bi",
				"Di",
				"Cong",
				"Yan",
				"Peng",
				"Sen",
				"Zhuan",
				"Pai",
				"Piao",
				"Dou",
				"Yu",
				"Mie",
				"Zhuan"
			],
			[
				"Ze",
				"Xi",
				"Guo",
				"Yi",
				"Hu",
				"Chan",
				"Kou",
				"Cu",
				"Ping",
				"Chou",
				"Ji",
				"Gui",
				"Su",
				"Lou",
				"Zha",
				"Lu",
				"Nian",
				"Suo",
				"Cuan",
				"Sasara",
				"Suo",
				"Le",
				"Duan",
				"Yana",
				"Xiao",
				"Bo",
				"Mi",
				"Si",
				"Dang",
				"Liao",
				"Dan",
				"Dian",
				"Fu",
				"Jian",
				"Min",
				"Kui",
				"Dai",
				"Qiao",
				"Deng",
				"Huang",
				"Sun",
				"Lao",
				"Zan",
				"Xiao",
				"Du",
				"Shi",
				"Zan",
				,
				"Pai",
				"Hata",
				"Pai",
				"Gan",
				"Ju",
				"Du",
				"Lu",
				"Yan",
				"Bo",
				"Dang",
				"Sai",
				"Ke",
				"Long",
				"Qian",
				"Lian",
				"Bo",
				"Zhou",
				"Lai",
				,
				"Lan",
				"Kui",
				"Yu",
				"Yue",
				"Hao",
				"Zhen",
				"Tai",
				"Ti",
				"Mi",
				"Chou",
				"Ji",
				,
				"Hata",
				"Teng",
				"Zhuan",
				"Zhou",
				"Fan",
				"Sou",
				"Zhou",
				"Kuji",
				"Zhuo",
				"Teng",
				"Lu",
				"Lu",
				"Jian",
				"Tuo",
				"Ying",
				"Yu",
				"Lai",
				"Long",
				"Shinshi",
				"Lian",
				"Lan",
				"Qian",
				"Yue",
				"Zhong",
				"Qu",
				"Lian",
				"Bian",
				"Duan",
				"Zuan",
				"Li",
				"Si",
				"Luo",
				"Ying",
				"Yue",
				"Zhuo",
				"Xu",
				"Mi",
				"Di",
				"Fan",
				"Shen",
				"Zhe",
				"Shen",
				"Nu",
				"Xie",
				"Lei",
				"Xian",
				"Zi",
				"Ni",
				"Cun",
				,
				"Qian",
				"Kume",
				"Bi",
				"Ban",
				"Wu",
				"Sha",
				"Kang",
				"Rou",
				"Fen",
				"Bi",
				"Cui",
				,
				"Li",
				"Chi",
				"Nukamiso",
				"Ro",
				"Ba",
				"Li",
				"Gan",
				"Ju",
				"Po",
				"Mo",
				"Cu",
				"Nian",
				"Zhou",
				"Li",
				"Su",
				"Tiao",
				"Li",
				"Qi",
				"Su",
				"Hong",
				"Tong",
				"Zi",
				"Ce",
				"Yue",
				"Zhou",
				"Lin",
				"Zhuang",
				"Bai",
				,
				"Fen",
				"Ji",
				,
				"Sukumo",
				"Liang",
				"Xian",
				"Fu",
				"Liang",
				"Can",
				"Geng",
				"Li",
				"Yue",
				"Lu",
				"Ju",
				"Qi",
				"Cui",
				"Bai",
				"Zhang",
				"Lin",
				"Zong",
				"Jing",
				"Guo",
				"Kouji",
				"San",
				"San",
				"Tang",
				"Bian",
				"Rou",
				"Mian",
				"Hou",
				"Xu",
				"Zong",
				"Hu",
				"Jian",
				"Zan",
				"Ci",
				"Li",
				"Xie",
				"Fu",
				"Ni",
				"Bei",
				"Gu",
				"Xiu",
				"Gao",
				"Tang",
				"Qiu",
				"Sukumo",
				"Cao",
				"Zhuang",
				"Tang",
				"Mi",
				"San",
				"Fen",
				"Zao",
				"Kang",
				"Jiang",
				"Mo",
				"San",
				"San",
				"Nuo",
				"Xi",
				"Liang",
				"Jiang",
				"Kuai",
				"Bo",
				"Huan",
				,
				"Zong",
				"Xian",
				"Nuo",
				"Tuan",
				"Nie",
				"Li",
				"Zuo",
				"Di",
				"Nie",
				"Tiao",
				"Lan",
				"Mi",
				"Jiao",
				"Jiu",
				"Xi",
				"Gong",
				"Zheng",
				"Jiu",
				"You"
			],
			[
				"Ji",
				"Cha",
				"Zhou",
				"Xun",
				"Yue",
				"Hong",
				"Yu",
				"He",
				"Wan",
				"Ren",
				"Wen",
				"Wen",
				"Qiu",
				"Na",
				"Zi",
				"Tou",
				"Niu",
				"Fou",
				"Jie",
				"Shu",
				"Chun",
				"Pi",
				"Yin",
				"Sha",
				"Hong",
				"Zhi",
				"Ji",
				"Fen",
				"Yun",
				"Ren",
				"Dan",
				"Jin",
				"Su",
				"Fang",
				"Suo",
				"Cui",
				"Jiu",
				"Zha",
				"Kinu",
				"Jin",
				"Fu",
				"Zhi",
				"Ci",
				"Zi",
				"Chou",
				"Hong",
				"Zha",
				"Lei",
				"Xi",
				"Fu",
				"Xie",
				"Shen",
				"Bei",
				"Zhu",
				"Qu",
				"Ling",
				"Zhu",
				"Shao",
				"Gan",
				"Yang",
				"Fu",
				"Tuo",
				"Zhen",
				"Dai",
				"Zhuo",
				"Shi",
				"Zhong",
				"Xian",
				"Zu",
				"Jiong",
				"Ban",
				"Ju",
				"Mo",
				"Shu",
				"Zui",
				"Wata",
				"Jing",
				"Ren",
				"Heng",
				"Xie",
				"Jie",
				"Zhu",
				"Chou",
				"Gua",
				"Bai",
				"Jue",
				"Kuang",
				"Hu",
				"Ci",
				"Geng",
				"Geng",
				"Tao",
				"Xie",
				"Ku",
				"Jiao",
				"Quan",
				"Gai",
				"Luo",
				"Xuan",
				"Bing",
				"Xian",
				"Fu",
				"Gei",
				"Tong",
				"Rong",
				"Tiao",
				"Yin",
				"Lei",
				"Xie",
				"Quan",
				"Xu",
				"Lun",
				"Die",
				"Tong",
				"Si",
				"Jiang",
				"Xiang",
				"Hui",
				"Jue",
				"Zhi",
				"Jian",
				"Juan",
				"Chi",
				"Mian",
				"Zhen",
				"Lu",
				"Cheng",
				"Qiu",
				"Shu",
				"Bang",
				"Tong",
				"Xiao",
				"Wan",
				"Qin",
				"Geng",
				"Xiu",
				"Ti",
				"Xiu",
				"Xie",
				"Hong",
				"Xi",
				"Fu",
				"Ting",
				"Sui",
				"Dui",
				"Kun",
				"Fu",
				"Jing",
				"Hu",
				"Zhi",
				"Yan",
				"Jiong",
				"Feng",
				"Ji",
				"Sok",
				"Kase",
				"Zong",
				"Lin",
				"Duo",
				"Li",
				"Lu",
				"Liang",
				"Chou",
				"Quan",
				"Shao",
				"Qi",
				"Qi",
				"Zhun",
				"Qi",
				"Wan",
				"Qian",
				"Xian",
				"Shou",
				"Wei",
				"Qi",
				"Tao",
				"Wan",
				"Gang",
				"Wang",
				"Beng",
				"Zhui",
				"Cai",
				"Guo",
				"Cui",
				"Lun",
				"Liu",
				"Qi",
				"Zhan",
				"Bei",
				"Chuo",
				"Ling",
				"Mian",
				"Qi",
				"Qie",
				"Tan",
				"Zong",
				"Gun",
				"Zou",
				"Yi",
				"Zi",
				"Xing",
				"Liang",
				"Jin",
				"Fei",
				"Rui",
				"Min",
				"Yu",
				"Zong",
				"Fan",
				"Lu",
				"Xu",
				"Yingl",
				"Zhang",
				"Kasuri",
				"Xu",
				"Xiang",
				"Jian",
				"Ke",
				"Xian",
				"Ruan",
				"Mian",
				"Qi",
				"Duan",
				"Zhong",
				"Di",
				"Min",
				"Miao",
				"Yuan",
				"Xie",
				"Bao",
				"Si",
				"Qiu",
				"Bian",
				"Huan",
				"Geng",
				"Cong",
				"Mian",
				"Wei",
				"Fu",
				"Wei",
				"Yu",
				"Gou",
				"Miao",
				"Xie",
				"Lian",
				"Zong",
				"Bian",
				"Yun",
				"Yin",
				"Ti",
				"Gua",
				"Zhi",
				"Yun",
				"Cheng",
				"Chan",
				"Dai"
			],
			[
				"Xia",
				"Yuan",
				"Zong",
				"Xu",
				"Nawa",
				"Odoshi",
				"Geng",
				"Sen",
				"Ying",
				"Jin",
				"Yi",
				"Zhui",
				"Ni",
				"Bang",
				"Gu",
				"Pan",
				"Zhou",
				"Jian",
				"Cuo",
				"Quan",
				"Shuang",
				"Yun",
				"Xia",
				"Shuai",
				"Xi",
				"Rong",
				"Tao",
				"Fu",
				"Yun",
				"Zhen",
				"Gao",
				"Ru",
				"Hu",
				"Zai",
				"Teng",
				"Xian",
				"Su",
				"Zhen",
				"Zong",
				"Tao",
				"Horo",
				"Cai",
				"Bi",
				"Feng",
				"Cu",
				"Li",
				"Suo",
				"Yin",
				"Xi",
				"Zong",
				"Lei",
				"Zhuan",
				"Qian",
				"Man",
				"Zhi",
				"Lu",
				"Mo",
				"Piao",
				"Lian",
				"Mi",
				"Xuan",
				"Zong",
				"Ji",
				"Shan",
				"Sui",
				"Fan",
				"Shuai",
				"Beng",
				"Yi",
				"Sao",
				"Mou",
				"Zhou",
				"Qiang",
				"Hun",
				"Sem",
				"Xi",
				"Jung",
				"Xiu",
				"Ran",
				"Xuan",
				"Hui",
				"Qiao",
				"Zeng",
				"Zuo",
				"Zhi",
				"Shan",
				"San",
				"Lin",
				"Yu",
				"Fan",
				"Liao",
				"Chuo",
				"Zun",
				"Jian",
				"Rao",
				"Chan",
				"Rui",
				"Xiu",
				"Hui",
				"Hua",
				"Zuan",
				"Xi",
				"Qiang",
				"Un",
				"Da",
				"Sheng",
				"Hui",
				"Xi",
				"Se",
				"Jian",
				"Jiang",
				"Huan",
				"Zao",
				"Cong",
				"Jie",
				"Jiao",
				"Bo",
				"Chan",
				"Yi",
				"Nao",
				"Sui",
				"Yi",
				"Shai",
				"Xu",
				"Ji",
				"Bin",
				"Qian",
				"Lan",
				"Pu",
				"Xun",
				"Zuan",
				"Qi",
				"Peng",
				"Li",
				"Mo",
				"Lei",
				"Xie",
				"Zuan",
				"Kuang",
				"You",
				"Xu",
				"Lei",
				"Xian",
				"Chan",
				"Kou",
				"Lu",
				"Chan",
				"Ying",
				"Cai",
				"Xiang",
				"Xian",
				"Zui",
				"Zuan",
				"Luo",
				"Xi",
				"Dao",
				"Lan",
				"Lei",
				"Lian",
				"Si",
				"Jiu",
				"Yu",
				"Hong",
				"Zhou",
				"Xian",
				"He",
				"Yue",
				"Ji",
				"Wan",
				"Kuang",
				"Ji",
				"Ren",
				"Wei",
				"Yun",
				"Hong",
				"Chun",
				"Pi",
				"Sha",
				"Gang",
				"Na",
				"Ren",
				"Zong",
				"Lun",
				"Fen",
				"Zhi",
				"Wen",
				"Fang",
				"Zhu",
				"Yin",
				"Niu",
				"Shu",
				"Xian",
				"Gan",
				"Xie",
				"Fu",
				"Lian",
				"Zu",
				"Shen",
				"Xi",
				"Zhi",
				"Zhong",
				"Zhou",
				"Ban",
				"Fu",
				"Zhuo",
				"Shao",
				"Yi",
				"Jing",
				"Dai",
				"Bang",
				"Rong",
				"Jie",
				"Ku",
				"Rao",
				"Die",
				"Heng",
				"Hui",
				"Gei",
				"Xuan",
				"Jiang",
				"Luo",
				"Jue",
				"Jiao",
				"Tong",
				"Geng",
				"Xiao",
				"Juan",
				"Xiu",
				"Xi",
				"Sui",
				"Tao",
				"Ji",
				"Ti",
				"Ji",
				"Xu",
				"Ling",
				,
				"Xu",
				"Qi",
				"Fei",
				"Chuo",
				"Zhang",
				"Gun",
				"Sheng",
				"Wei",
				"Mian",
				"Shou",
				"Beng",
				"Chou",
				"Tao",
				"Liu",
				"Quan",
				"Zong",
				"Zhan",
				"Wan",
				"Lu"
			],
			[
				"Zhui",
				"Zi",
				"Ke",
				"Xiang",
				"Jian",
				"Mian",
				"Lan",
				"Ti",
				"Miao",
				"Qi",
				"Yun",
				"Hui",
				"Si",
				"Duo",
				"Duan",
				"Bian",
				"Xian",
				"Gou",
				"Zhui",
				"Huan",
				"Di",
				"Lu",
				"Bian",
				"Min",
				"Yuan",
				"Jin",
				"Fu",
				"Ru",
				"Zhen",
				"Feng",
				"Shuai",
				"Gao",
				"Chan",
				"Li",
				"Yi",
				"Jian",
				"Bin",
				"Piao",
				"Man",
				"Lei",
				"Ying",
				"Suo",
				"Mou",
				"Sao",
				"Xie",
				"Liao",
				"Shan",
				"Zeng",
				"Jiang",
				"Qian",
				"Zao",
				"Huan",
				"Jiao",
				"Zuan",
				"Fou",
				"Xie",
				"Gang",
				"Fou",
				"Que",
				"Fou",
				"Kaakeru",
				"Bo",
				"Ping",
				"Hou",
				,
				"Gang",
				"Ying",
				"Ying",
				"Qing",
				"Xia",
				"Guan",
				"Zun",
				"Tan",
				"Chang",
				"Qi",
				"Weng",
				"Ying",
				"Lei",
				"Tan",
				"Lu",
				"Guan",
				"Wang",
				"Wang",
				"Gang",
				"Wang",
				"Han",
				,
				"Luo",
				"Fu",
				"Mi",
				"Fa",
				"Gu",
				"Zhu",
				"Ju",
				"Mao",
				"Gu",
				"Min",
				"Gang",
				"Ba",
				"Gua",
				"Ti",
				"Juan",
				"Fu",
				"Lin",
				"Yan",
				"Zhao",
				"Zui",
				"Gua",
				"Zhuo",
				"Yu",
				"Zhi",
				"An",
				"Fa",
				"Nan",
				"Shu",
				"Si",
				"Pi",
				"Ma",
				"Liu",
				"Ba",
				"Fa",
				"Li",
				"Chao",
				"Wei",
				"Bi",
				"Ji",
				"Zeng",
				"Tong",
				"Liu",
				"Ji",
				"Juan",
				"Mi",
				"Zhao",
				"Luo",
				"Pi",
				"Ji",
				"Ji",
				"Luan",
				"Yang",
				"Mie",
				"Qiang",
				"Ta",
				"Mei",
				"Yang",
				"You",
				"You",
				"Fen",
				"Ba",
				"Gao",
				"Yang",
				"Gu",
				"Qiang",
				"Zang",
				"Gao",
				"Ling",
				"Yi",
				"Zhu",
				"Di",
				"Xiu",
				"Qian",
				"Yi",
				"Xian",
				"Rong",
				"Qun",
				"Qun",
				"Qian",
				"Huan",
				"Zui",
				"Xian",
				"Yi",
				"Yashinau",
				"Qiang",
				"Xian",
				"Yu",
				"Geng",
				"Jie",
				"Tang",
				"Yuan",
				"Xi",
				"Fan",
				"Shan",
				"Fen",
				"Shan",
				"Lian",
				"Lei",
				"Geng",
				"Nou",
				"Qiang",
				"Chan",
				"Yu",
				"Gong",
				"Yi",
				"Chong",
				"Weng",
				"Fen",
				"Hong",
				"Chi",
				"Chi",
				"Cui",
				"Fu",
				"Xia",
				"Pen",
				"Yi",
				"La",
				"Yi",
				"Pi",
				"Ling",
				"Liu",
				"Zhi",
				"Qu",
				"Xi",
				"Xie",
				"Xiang",
				"Xi",
				"Xi",
				"Qi",
				"Qiao",
				"Hui",
				"Hui",
				"Xiao",
				"Se",
				"Hong",
				"Jiang",
				"Di",
				"Cui",
				"Fei",
				"Tao",
				"Sha",
				"Chi",
				"Zhu",
				"Jian",
				"Xuan",
				"Shi",
				"Pian",
				"Zong",
				"Wan",
				"Hui",
				"Hou",
				"He",
				"He",
				"Han",
				"Ao",
				"Piao",
				"Yi",
				"Lian",
				"Qu",
				,
				"Lin",
				"Pen",
				"Qiao",
				"Ao",
				"Fan",
				"Yi",
				"Hui",
				"Xuan",
				"Dao"
			],
			[
				"Yao",
				"Lao",
				,
				"Kao",
				"Mao",
				"Zhe",
				"Qi",
				"Gou",
				"Gou",
				"Gou",
				"Die",
				"Die",
				"Er",
				"Shua",
				"Ruan",
				"Er",
				"Nai",
				"Zhuan",
				"Lei",
				"Ting",
				"Zi",
				"Geng",
				"Chao",
				"Hao",
				"Yun",
				"Pa",
				"Pi",
				"Chi",
				"Si",
				"Chu",
				"Jia",
				"Ju",
				"He",
				"Chu",
				"Lao",
				"Lun",
				"Ji",
				"Tang",
				"Ou",
				"Lou",
				"Nou",
				"Gou",
				"Pang",
				"Ze",
				"Lou",
				"Ji",
				"Lao",
				"Huo",
				"You",
				"Mo",
				"Huai",
				"Er",
				"Zhe",
				"Ting",
				"Ye",
				"Da",
				"Song",
				"Qin",
				"Yun",
				"Chi",
				"Dan",
				"Dan",
				"Hong",
				"Geng",
				"Zhi",
				,
				"Nie",
				"Dan",
				"Zhen",
				"Che",
				"Ling",
				"Zheng",
				"You",
				"Wa",
				"Liao",
				"Long",
				"Zhi",
				"Ning",
				"Tiao",
				"Er",
				"Ya",
				"Die",
				"Gua",
				,
				"Lian",
				"Hao",
				"Sheng",
				"Lie",
				"Pin",
				"Jing",
				"Ju",
				"Bi",
				"Di",
				"Guo",
				"Wen",
				"Xu",
				"Ping",
				"Cong",
				"Shikato",
				,
				"Ting",
				"Yu",
				"Cong",
				"Kui",
				"Tsuraneru",
				"Kui",
				"Cong",
				"Lian",
				"Weng",
				"Kui",
				"Lian",
				"Lian",
				"Cong",
				"Ao",
				"Sheng",
				"Song",
				"Ting",
				"Kui",
				"Nie",
				"Zhi",
				"Dan",
				"Ning",
				"Qie",
				"Ji",
				"Ting",
				"Ting",
				"Long",
				"Yu",
				"Yu",
				"Zhao",
				"Si",
				"Su",
				"Yi",
				"Su",
				"Si",
				"Zhao",
				"Zhao",
				"Rou",
				"Yi",
				"Le",
				"Ji",
				"Qiu",
				"Ken",
				"Cao",
				"Ge",
				"Di",
				"Huan",
				"Huang",
				"Yi",
				"Ren",
				"Xiao",
				"Ru",
				"Zhou",
				"Yuan",
				"Du",
				"Gang",
				"Rong",
				"Gan",
				"Cha",
				"Wo",
				"Chang",
				"Gu",
				"Zhi",
				"Han",
				"Fu",
				"Fei",
				"Fen",
				"Pei",
				"Pang",
				"Jian",
				"Fang",
				"Zhun",
				"You",
				"Na",
				"Hang",
				"Ken",
				"Ran",
				"Gong",
				"Yu",
				"Wen",
				"Yao",
				"Jin",
				"Pi",
				"Qian",
				"Xi",
				"Xi",
				"Fei",
				"Ken",
				"Jing",
				"Tai",
				"Shen",
				"Zhong",
				"Zhang",
				"Xie",
				"Shen",
				"Wei",
				"Zhou",
				"Die",
				"Dan",
				"Fei",
				"Ba",
				"Bo",
				"Qu",
				"Tian",
				"Bei",
				"Gua",
				"Tai",
				"Zi",
				"Ku",
				"Zhi",
				"Ni",
				"Ping",
				"Zi",
				"Fu",
				"Pang",
				"Zhen",
				"Xian",
				"Zuo",
				"Pei",
				"Jia",
				"Sheng",
				"Zhi",
				"Bao",
				"Mu",
				"Qu",
				"Hu",
				"Ke",
				"Yi",
				"Yin",
				"Xu",
				"Yang",
				"Long",
				"Dong",
				"Ka",
				"Lu",
				"Jing",
				"Nu",
				"Yan",
				"Pang",
				"Kua",
				"Yi",
				"Guang",
				"Gai",
				"Ge",
				"Dong",
				"Zhi",
				"Xiao",
				"Xiong",
				"Xiong",
				"Er",
				"E",
				"Xing",
				"Pian",
				"Neng",
				"Zi",
				"Gui"
			],
			[
				"Cheng",
				"Tiao",
				"Zhi",
				"Cui",
				"Mei",
				"Xie",
				"Cui",
				"Xie",
				"Mo",
				"Mai",
				"Ji",
				"Obiyaakasu",
				,
				"Kuai",
				"Sa",
				"Zang",
				"Qi",
				"Nao",
				"Mi",
				"Nong",
				"Luan",
				"Wan",
				"Bo",
				"Wen",
				"Guan",
				"Qiu",
				"Jiao",
				"Jing",
				"Rou",
				"Heng",
				"Cuo",
				"Lie",
				"Shan",
				"Ting",
				"Mei",
				"Chun",
				"Shen",
				"Xie",
				"De",
				"Zui",
				"Cu",
				"Xiu",
				"Xin",
				"Tuo",
				"Pao",
				"Cheng",
				"Nei",
				"Fu",
				"Dou",
				"Tuo",
				"Niao",
				"Noy",
				"Pi",
				"Gu",
				"Gua",
				"Li",
				"Lian",
				"Zhang",
				"Cui",
				"Jie",
				"Liang",
				"Zhou",
				"Pi",
				"Biao",
				"Lun",
				"Pian",
				"Guo",
				"Kui",
				"Chui",
				"Dan",
				"Tian",
				"Nei",
				"Jing",
				"Jie",
				"La",
				"Yi",
				"An",
				"Ren",
				"Shen",
				"Chuo",
				"Fu",
				"Fu",
				"Ju",
				"Fei",
				"Qiang",
				"Wan",
				"Dong",
				"Pi",
				"Guo",
				"Zong",
				"Ding",
				"Wu",
				"Mei",
				"Ruan",
				"Zhuan",
				"Zhi",
				"Cou",
				"Gua",
				"Ou",
				"Di",
				"An",
				"Xing",
				"Nao",
				"Yu",
				"Chuan",
				"Nan",
				"Yun",
				"Zhong",
				"Rou",
				"E",
				"Sai",
				"Tu",
				"Yao",
				"Jian",
				"Wei",
				"Jiao",
				"Yu",
				"Jia",
				"Duan",
				"Bi",
				"Chang",
				"Fu",
				"Xian",
				"Ni",
				"Mian",
				"Wa",
				"Teng",
				"Tui",
				"Bang",
				"Qian",
				"Lu",
				"Wa",
				"Sou",
				"Tang",
				"Su",
				"Zhui",
				"Ge",
				"Yi",
				"Bo",
				"Liao",
				"Ji",
				"Pi",
				"Xie",
				"Gao",
				"Lu",
				"Bin",
				"Ou",
				"Chang",
				"Lu",
				"Guo",
				"Pang",
				"Chuai",
				"Piao",
				"Jiang",
				"Fu",
				"Tang",
				"Mo",
				"Xi",
				"Zhuan",
				"Lu",
				"Jiao",
				"Ying",
				"Lu",
				"Zhi",
				"Tara",
				"Chun",
				"Lian",
				"Tong",
				"Peng",
				"Ni",
				"Zha",
				"Liao",
				"Cui",
				"Gui",
				"Xiao",
				"Teng",
				"Fan",
				"Zhi",
				"Jiao",
				"Shan",
				"Wu",
				"Cui",
				"Run",
				"Xiang",
				"Sui",
				"Fen",
				"Ying",
				"Tan",
				"Zhua",
				"Dan",
				"Kuai",
				"Nong",
				"Tun",
				"Lian",
				"Bi",
				"Yong",
				"Jue",
				"Chu",
				"Yi",
				"Juan",
				"La",
				"Lian",
				"Sao",
				"Tun",
				"Gu",
				"Qi",
				"Cui",
				"Bin",
				"Xun",
				"Ru",
				"Huo",
				"Zang",
				"Xian",
				"Biao",
				"Xing",
				"Kuan",
				"La",
				"Yan",
				"Lu",
				"Huo",
				"Zang",
				"Luo",
				"Qu",
				"Zang",
				"Luan",
				"Ni",
				"Zang",
				"Chen",
				"Qian",
				"Wo",
				"Guang",
				"Zang",
				"Lin",
				"Guang",
				"Zi",
				"Jiao",
				"Nie",
				"Chou",
				"Ji",
				"Gao",
				"Chou",
				"Mian",
				"Nie",
				"Zhi",
				"Zhi",
				"Ge",
				"Jian",
				"Die",
				"Zhi",
				"Xiu",
				"Tai",
				"Zhen",
				"Jiu",
				"Xian",
				"Yu",
				"Cha"
			],
			[
				"Yao",
				"Yu",
				"Chong",
				"Xi",
				"Xi",
				"Jiu",
				"Yu",
				"Yu",
				"Xing",
				"Ju",
				"Jiu",
				"Xin",
				"She",
				"She",
				"Yadoru",
				"Jiu",
				"Shi",
				"Tan",
				"Shu",
				"Shi",
				"Tian",
				"Dan",
				"Pu",
				"Pu",
				"Guan",
				"Hua",
				"Tan",
				"Chuan",
				"Shun",
				"Xia",
				"Wu",
				"Zhou",
				"Dao",
				"Gang",
				"Shan",
				"Yi",
				,
				"Pa",
				"Tai",
				"Fan",
				"Ban",
				"Chuan",
				"Hang",
				"Fang",
				"Ban",
				"Que",
				"Hesaki",
				"Zhong",
				"Jian",
				"Cang",
				"Ling",
				"Zhu",
				"Ze",
				"Duo",
				"Bo",
				"Xian",
				"Ge",
				"Chuan",
				"Jia",
				"Lu",
				"Hong",
				"Pang",
				"Xi",
				,
				"Fu",
				"Zao",
				"Feng",
				"Li",
				"Shao",
				"Yu",
				"Lang",
				"Ting",
				,
				"Wei",
				"Bo",
				"Meng",
				"Nian",
				"Ju",
				"Huang",
				"Shou",
				"Zong",
				"Bian",
				"Mao",
				"Die",
				,
				"Bang",
				"Cha",
				"Yi",
				"Sao",
				"Cang",
				"Cao",
				"Lou",
				"Dai",
				"Sori",
				"Yao",
				"Tong",
				"Yofune",
				"Dang",
				"Tan",
				"Lu",
				"Yi",
				"Jie",
				"Jian",
				"Huo",
				"Meng",
				"Qi",
				"Lu",
				"Lu",
				"Chan",
				"Shuang",
				"Gen",
				"Liang",
				"Jian",
				"Jian",
				"Se",
				"Yan",
				"Fu",
				"Ping",
				"Yan",
				"Yan",
				"Cao",
				"Cao",
				"Yi",
				"Le",
				"Ting",
				"Qiu",
				"Ai",
				"Nai",
				"Tiao",
				"Jiao",
				"Jie",
				"Peng",
				"Wan",
				"Yi",
				"Chai",
				"Mian",
				"Mie",
				"Gan",
				"Qian",
				"Yu",
				"Yu",
				"Shuo",
				"Qiong",
				"Tu",
				"Xia",
				"Qi",
				"Mang",
				"Zi",
				"Hui",
				"Sui",
				"Zhi",
				"Xiang",
				"Bi",
				"Fu",
				"Tun",
				"Wei",
				"Wu",
				"Zhi",
				"Qi",
				"Shan",
				"Wen",
				"Qian",
				"Ren",
				"Fou",
				"Kou",
				"Jie",
				"Lu",
				"Xu",
				"Ji",
				"Qin",
				"Qi",
				"Yuan",
				"Fen",
				"Ba",
				"Rui",
				"Xin",
				"Ji",
				"Hua",
				"Hua",
				"Fang",
				"Wu",
				"Jue",
				"Gou",
				"Zhi",
				"Yun",
				"Qin",
				"Ao",
				"Chu",
				"Mao",
				"Ya",
				"Fei",
				"Reng",
				"Hang",
				"Cong",
				"Yin",
				"You",
				"Bian",
				"Yi",
				"Susa",
				"Wei",
				"Li",
				"Pi",
				"E",
				"Xian",
				"Chang",
				"Cang",
				"Meng",
				"Su",
				"Yi",
				"Yuan",
				"Ran",
				"Ling",
				"Tai",
				"Tiao",
				"Di",
				"Miao",
				"Qiong",
				"Li",
				"Yong",
				"Ke",
				"Mu",
				"Pei",
				"Bao",
				"Gou",
				"Min",
				"Yi",
				"Yi",
				"Ju",
				"Pi",
				"Ruo",
				"Ku",
				"Zhu",
				"Ni",
				"Bo",
				"Bing",
				"Shan",
				"Qiu",
				"Yao",
				"Xian",
				"Ben",
				"Hong",
				"Ying",
				"Zha",
				"Dong",
				"Ju",
				"Die",
				"Nie",
				"Gan",
				"Hu",
				"Ping",
				"Mei",
				"Fu",
				"Sheng",
				"Gu",
				"Bi",
				"Wei"
			],
			[
				"Fu",
				"Zhuo",
				"Mao",
				"Fan",
				"Qie",
				"Mao",
				"Mao",
				"Ba",
				"Zi",
				"Mo",
				"Zi",
				"Di",
				"Chi",
				"Ji",
				"Jing",
				"Long",
				,
				"Niao",
				,
				"Xue",
				"Ying",
				"Qiong",
				"Ge",
				"Ming",
				"Li",
				"Rong",
				"Yin",
				"Gen",
				"Qian",
				"Chai",
				"Chen",
				"Yu",
				"Xiu",
				"Zi",
				"Lie",
				"Wu",
				"Ji",
				"Kui",
				"Ce",
				"Chong",
				"Ci",
				"Gou",
				"Guang",
				"Mang",
				"Chi",
				"Jiao",
				"Jiao",
				"Fu",
				"Yu",
				"Zhu",
				"Zi",
				"Jiang",
				"Hui",
				"Yin",
				"Cha",
				"Fa",
				"Rong",
				"Ru",
				"Chong",
				"Mang",
				"Tong",
				"Zhong",
				,
				"Zhu",
				"Xun",
				"Huan",
				"Kua",
				"Quan",
				"Gai",
				"Da",
				"Jing",
				"Xing",
				"Quan",
				"Cao",
				"Jing",
				"Er",
				"An",
				"Shou",
				"Chi",
				"Ren",
				"Jian",
				"Ti",
				"Huang",
				"Ping",
				"Li",
				"Jin",
				"Lao",
				"Shu",
				"Zhuang",
				"Da",
				"Jia",
				"Rao",
				"Bi",
				"Ze",
				"Qiao",
				"Hui",
				"Qi",
				"Dang",
				,
				"Rong",
				"Hun",
				"Ying",
				"Luo",
				"Ying",
				"Xun",
				"Jin",
				"Sun",
				"Yin",
				"Mai",
				"Hong",
				"Zhou",
				"Yao",
				"Du",
				"Wei",
				"Chu",
				"Dou",
				"Fu",
				"Ren",
				"Yin",
				"He",
				"Bi",
				"Bu",
				"Yun",
				"Di",
				"Tu",
				"Sui",
				"Sui",
				"Cheng",
				"Chen",
				"Wu",
				"Bie",
				"Xi",
				"Geng",
				"Li",
				"Fu",
				"Zhu",
				"Mo",
				"Li",
				"Zhuang",
				"Ji",
				"Duo",
				"Qiu",
				"Sha",
				"Suo",
				"Chen",
				"Feng",
				"Ju",
				"Mei",
				"Meng",
				"Xing",
				"Jing",
				"Che",
				"Xin",
				"Jun",
				"Yan",
				"Ting",
				"Diao",
				"Cuo",
				"Wan",
				"Han",
				"You",
				"Cuo",
				"Jia",
				"Wang",
				"You",
				"Niu",
				"Shao",
				"Xian",
				"Lang",
				"Fu",
				"E",
				"Mo",
				"Wen",
				"Jie",
				"Nan",
				"Mu",
				"Kan",
				"Lai",
				"Lian",
				"Shi",
				"Wo",
				"Usagi",
				"Lian",
				"Huo",
				"You",
				"Ying",
				"Ying",
				"Nuc",
				"Chun",
				"Mang",
				"Mang",
				"Ci",
				"Wan",
				"Jing",
				"Di",
				"Qu",
				"Dong",
				"Jian",
				"Zou",
				"Gu",
				"La",
				"Lu",
				"Ju",
				"Wei",
				"Jun",
				"Nie",
				"Kun",
				"He",
				"Pu",
				"Zi",
				"Gao",
				"Guo",
				"Fu",
				"Lun",
				"Chang",
				"Chou",
				"Song",
				"Chui",
				"Zhan",
				"Men",
				"Cai",
				"Ba",
				"Li",
				"Tu",
				"Bo",
				"Han",
				"Bao",
				"Qin",
				"Juan",
				"Xi",
				"Qin",
				"Di",
				"Jie",
				"Pu",
				"Dang",
				"Jin",
				"Zhao",
				"Tai",
				"Geng",
				"Hua",
				"Gu",
				"Ling",
				"Fei",
				"Jin",
				"An",
				"Wang",
				"Beng",
				"Zhou",
				"Yan",
				"Ju",
				"Jian",
				"Lin",
				"Tan",
				"Shu",
				"Tian",
				"Dao"
			],
			[
				"Hu",
				"Qi",
				"He",
				"Cui",
				"Tao",
				"Chun",
				"Bei",
				"Chang",
				"Huan",
				"Fei",
				"Lai",
				"Qi",
				"Meng",
				"Ping",
				"Wei",
				"Dan",
				"Sha",
				"Huan",
				"Yan",
				"Yi",
				"Tiao",
				"Qi",
				"Wan",
				"Ce",
				"Nai",
				"Kutabireru",
				"Tuo",
				"Jiu",
				"Tie",
				"Luo",
				,
				,
				"Meng",
				,
				"Yaji",
				,
				"Ying",
				"Ying",
				"Ying",
				"Xiao",
				"Sa",
				"Qiu",
				"Ke",
				"Xiang",
				"Wan",
				"Yu",
				"Yu",
				"Fu",
				"Lian",
				"Xuan",
				"Yuan",
				"Nan",
				"Ze",
				"Wo",
				"Chun",
				"Xiao",
				"Yu",
				"Pian",
				"Mao",
				"An",
				"E",
				"Luo",
				"Ying",
				"Huo",
				"Gua",
				"Jiang",
				"Mian",
				"Zuo",
				"Zuo",
				"Ju",
				"Bao",
				"Rou",
				"Xi",
				"Xie",
				"An",
				"Qu",
				"Jian",
				"Fu",
				"Lu",
				"Jing",
				"Pen",
				"Feng",
				"Hong",
				"Hong",
				"Hou",
				"Yan",
				"Tu",
				"Zhu",
				"Zi",
				"Xiang",
				"Shen",
				"Ge",
				"Jie",
				"Jing",
				"Mi",
				"Huang",
				"Shen",
				"Pu",
				"Gai",
				"Dong",
				"Zhou",
				"Qian",
				"Wei",
				"Bo",
				"Wei",
				"Pa",
				"Ji",
				"Hu",
				"Zang",
				"Jia",
				"Duan",
				"Yao",
				"Jun",
				"Cong",
				"Quan",
				"Wei",
				"Xian",
				"Kui",
				"Ting",
				"Hun",
				"Xi",
				"Shi",
				"Qi",
				"Lan",
				"Zong",
				"Yao",
				"Yuan",
				"Mei",
				"Yun",
				"Shu",
				"Di",
				"Zhuan",
				"Guan",
				"Sukumo",
				"Xue",
				"Chan",
				"Kai",
				"Kui",
				,
				"Jiang",
				"Lou",
				"Wei",
				"Pai",
				,
				"Sou",
				"Yin",
				"Shi",
				"Chun",
				"Shi",
				"Yun",
				"Zhen",
				"Lang",
				"Nu",
				"Meng",
				"He",
				"Que",
				"Suan",
				"Yuan",
				"Li",
				"Ju",
				"Xi",
				"Pang",
				"Chu",
				"Xu",
				"Tu",
				"Liu",
				"Wo",
				"Zhen",
				"Qian",
				"Zu",
				"Po",
				"Cuo",
				"Yuan",
				"Chu",
				"Yu",
				"Kuai",
				"Pan",
				"Pu",
				"Pu",
				"Na",
				"Shuo",
				"Xi",
				"Fen",
				"Yun",
				"Zheng",
				"Jian",
				"Ji",
				"Ruo",
				"Cang",
				"En",
				"Mi",
				"Hao",
				"Sun",
				"Zhen",
				"Ming",
				"Sou",
				"Xu",
				"Liu",
				"Xi",
				"Gu",
				"Lang",
				"Rong",
				"Weng",
				"Gai",
				"Cuo",
				"Shi",
				"Tang",
				"Luo",
				"Ru",
				"Suo",
				"Xian",
				"Bei",
				"Yao",
				"Gui",
				"Bi",
				"Zong",
				"Gun",
				"Za",
				"Xiu",
				"Ce",
				"Hai",
				"Lan",
				,
				"Ji",
				"Li",
				"Can",
				"Lang",
				"Yu",
				,
				"Ying",
				"Mo",
				"Diao",
				"Tiao",
				"Mao",
				"Tong",
				"Zhu",
				"Peng",
				"An",
				"Lian",
				"Cong",
				"Xi",
				"Ping",
				"Qiu",
				"Jin",
				"Chun",
				"Jie",
				"Wei",
				"Tui",
				"Cao",
				"Yu",
				"Yi",
				"Ji",
				"Liao",
				"Bi",
				"Lu",
				"Su"
			],
			[
				"Bu",
				"Zhang",
				"Luo",
				"Jiang",
				"Man",
				"Yan",
				"Ling",
				"Ji",
				"Piao",
				"Gun",
				"Han",
				"Di",
				"Su",
				"Lu",
				"She",
				"Shang",
				"Di",
				"Mie",
				"Xun",
				"Man",
				"Bo",
				"Di",
				"Cuo",
				"Zhe",
				"Sen",
				"Xuan",
				"Wei",
				"Hu",
				"Ao",
				"Mi",
				"Lou",
				"Cu",
				"Zhong",
				"Cai",
				"Po",
				"Jiang",
				"Mi",
				"Cong",
				"Niao",
				"Hui",
				"Jun",
				"Yin",
				"Jian",
				"Yan",
				"Shu",
				"Yin",
				"Kui",
				"Chen",
				"Hu",
				"Sha",
				"Kou",
				"Qian",
				"Ma",
				"Zang",
				"Sonoko",
				"Qiang",
				"Dou",
				"Lian",
				"Lin",
				"Kou",
				"Ai",
				"Bi",
				"Li",
				"Wei",
				"Ji",
				"Xun",
				"Sheng",
				"Fan",
				"Meng",
				"Ou",
				"Chan",
				"Dian",
				"Xun",
				"Jiao",
				"Rui",
				"Rui",
				"Lei",
				"Yu",
				"Qiao",
				"Chu",
				"Hua",
				"Jian",
				"Mai",
				"Yun",
				"Bao",
				"You",
				"Qu",
				"Lu",
				"Rao",
				"Hui",
				"E",
				"Teng",
				"Fei",
				"Jue",
				"Zui",
				"Fa",
				"Ru",
				"Fen",
				"Kui",
				"Shun",
				"Rui",
				"Ya",
				"Xu",
				"Fu",
				"Jue",
				"Dang",
				"Wu",
				"Tong",
				"Si",
				"Xiao",
				"Xi",
				"Long",
				"Yun",
				,
				"Qi",
				"Jian",
				"Yun",
				"Sun",
				"Ling",
				"Yu",
				"Xia",
				"Yong",
				"Ji",
				"Hong",
				"Si",
				"Nong",
				"Lei",
				"Xuan",
				"Yun",
				"Yu",
				"Xi",
				"Hao",
				"Bo",
				"Hao",
				"Ai",
				"Wei",
				"Hui",
				"Wei",
				"Ji",
				"Ci",
				"Xiang",
				"Luan",
				"Mie",
				"Yi",
				"Leng",
				"Jiang",
				"Can",
				"Shen",
				"Qiang",
				"Lian",
				"Ke",
				"Yuan",
				"Da",
				"Ti",
				"Tang",
				"Xie",
				"Bi",
				"Zhan",
				"Sun",
				"Lian",
				"Fan",
				"Ding",
				"Jie",
				"Gu",
				"Xie",
				"Shu",
				"Jian",
				"Kao",
				"Hong",
				"Sa",
				"Xin",
				"Xun",
				"Yao",
				"Hie",
				"Sou",
				"Shu",
				"Xun",
				"Dui",
				"Pin",
				"Wei",
				"Neng",
				"Chou",
				"Mai",
				"Ru",
				"Piao",
				"Tai",
				"Qi",
				"Zao",
				"Chen",
				"Zhen",
				"Er",
				"Ni",
				"Ying",
				"Gao",
				"Cong",
				"Xiao",
				"Qi",
				"Fa",
				"Jian",
				"Xu",
				"Kui",
				"Jie",
				"Bian",
				"Diao",
				"Mi",
				"Lan",
				"Jin",
				"Cang",
				"Miao",
				"Qiong",
				"Qie",
				"Xian",
				,
				"Ou",
				"Xian",
				"Su",
				"Lu",
				"Yi",
				"Xu",
				"Xie",
				"Li",
				"Yi",
				"La",
				"Lei",
				"Xiao",
				"Di",
				"Zhi",
				"Bei",
				"Teng",
				"Yao",
				"Mo",
				"Huan",
				"Piao",
				"Fan",
				"Sou",
				"Tan",
				"Tui",
				"Qiong",
				"Qiao",
				"Wei",
				"Liu",
				"Hui",
				,
				"Gao",
				"Yun",
				,
				"Li",
				"Shu",
				"Chu",
				"Ai",
				"Lin",
				"Zao",
				"Xuan",
				"Chen",
				"Lai",
				"Huo"
			],
			[
				"Tuo",
				"Wu",
				"Rui",
				"Rui",
				"Qi",
				"Heng",
				"Lu",
				"Su",
				"Tui",
				"Mang",
				"Yun",
				"Pin",
				"Yu",
				"Xun",
				"Ji",
				"Jiong",
				"Xian",
				"Mo",
				"Hagi",
				"Su",
				"Jiong",
				,
				"Nie",
				"Bo",
				"Rang",
				"Yi",
				"Xian",
				"Yu",
				"Ju",
				"Lian",
				"Lian",
				"Yin",
				"Qiang",
				"Ying",
				"Long",
				"Tong",
				"Wei",
				"Yue",
				"Ling",
				"Qu",
				"Yao",
				"Fan",
				"Mi",
				"Lan",
				"Kui",
				"Lan",
				"Ji",
				"Dang",
				"Katsura",
				"Lei",
				"Lei",
				"Hua",
				"Feng",
				"Zhi",
				"Wei",
				"Kui",
				"Zhan",
				"Huai",
				"Li",
				"Ji",
				"Mi",
				"Lei",
				"Huai",
				"Luo",
				"Ji",
				"Kui",
				"Lu",
				"Jian",
				"San",
				,
				"Lei",
				"Quan",
				"Xiao",
				"Yi",
				"Luan",
				"Men",
				"Bie",
				"Hu",
				"Hu",
				"Lu",
				"Nue",
				"Lu",
				"Si",
				"Xiao",
				"Qian",
				"Chu",
				"Hu",
				"Xu",
				"Cuo",
				"Fu",
				"Xu",
				"Xu",
				"Lu",
				"Hu",
				"Yu",
				"Hao",
				"Jiao",
				"Ju",
				"Guo",
				"Bao",
				"Yan",
				"Zhan",
				"Zhan",
				"Kui",
				"Ban",
				"Xi",
				"Shu",
				"Chong",
				"Qiu",
				"Diao",
				"Ji",
				"Qiu",
				"Cheng",
				"Shi",
				,
				"Di",
				"Zhe",
				"She",
				"Yu",
				"Gan",
				"Zi",
				"Hong",
				"Hui",
				"Meng",
				"Ge",
				"Sui",
				"Xia",
				"Chai",
				"Shi",
				"Yi",
				"Ma",
				"Xiang",
				"Fang",
				"E",
				"Pa",
				"Chi",
				"Qian",
				"Wen",
				"Wen",
				"Rui",
				"Bang",
				"Bi",
				"Yue",
				"Yue",
				"Jun",
				"Qi",
				"Ran",
				"Yin",
				"Qi",
				"Tian",
				"Yuan",
				"Jue",
				"Hui",
				"Qin",
				"Qi",
				"Zhong",
				"Ya",
				"Ci",
				"Mu",
				"Wang",
				"Fen",
				"Fen",
				"Hang",
				"Gong",
				"Zao",
				"Fu",
				"Ran",
				"Jie",
				"Fu",
				"Chi",
				"Dou",
				"Piao",
				"Xian",
				"Ni",
				"Te",
				"Qiu",
				"You",
				"Zha",
				"Ping",
				"Chi",
				"You",
				"He",
				"Han",
				"Ju",
				"Li",
				"Fu",
				"Ran",
				"Zha",
				"Gou",
				"Pi",
				"Bo",
				"Xian",
				"Zhu",
				"Diao",
				"Bie",
				"Bing",
				"Gu",
				"Ran",
				"Qu",
				"She",
				"Tie",
				"Ling",
				"Gu",
				"Dan",
				"Gu",
				"Ying",
				"Li",
				"Cheng",
				"Qu",
				"Mou",
				"Ge",
				"Ci",
				"Hui",
				"Hui",
				"Mang",
				"Fu",
				"Yang",
				"Wa",
				"Lie",
				"Zhu",
				"Yi",
				"Xian",
				"Kuo",
				"Jiao",
				"Li",
				"Yi",
				"Ping",
				"Ji",
				"Ha",
				"She",
				"Yi",
				"Wang",
				"Mo",
				"Qiong",
				"Qie",
				"Gui",
				"Gong",
				"Zhi",
				"Man",
				"Ebi",
				"Zhi",
				"Jia",
				"Rao",
				"Si",
				"Qi",
				"Xing",
				"Lie",
				"Qiu",
				"Shao",
				"Yong",
				"Jia",
				"Shui",
				"Che",
				"Bai",
				"E",
				"Han"
			],
			[
				"Shu",
				"Xuan",
				"Feng",
				"Shen",
				"Zhen",
				"Fu",
				"Xian",
				"Zhe",
				"Wu",
				"Fu",
				"Li",
				"Lang",
				"Bi",
				"Chu",
				"Yuan",
				"You",
				"Jie",
				"Dan",
				"Yan",
				"Ting",
				"Dian",
				"Shui",
				"Hui",
				"Gua",
				"Zhi",
				"Song",
				"Fei",
				"Ju",
				"Mi",
				"Qi",
				"Qi",
				"Yu",
				"Jun",
				"Zha",
				"Meng",
				"Qiang",
				"Si",
				"Xi",
				"Lun",
				"Li",
				"Die",
				"Tiao",
				"Tao",
				"Kun",
				"Gan",
				"Han",
				"Yu",
				"Bang",
				"Fei",
				"Pi",
				"Wei",
				"Dun",
				"Yi",
				"Yuan",
				"Su",
				"Quan",
				"Qian",
				"Rui",
				"Ni",
				"Qing",
				"Wei",
				"Liang",
				"Guo",
				"Wan",
				"Dong",
				"E",
				"Ban",
				"Di",
				"Wang",
				"Can",
				"Yang",
				"Ying",
				"Guo",
				"Chan",
				,
				"La",
				"Ke",
				"Ji",
				"He",
				"Ting",
				"Mai",
				"Xu",
				"Mian",
				"Yu",
				"Jie",
				"Shi",
				"Xuan",
				"Huang",
				"Yan",
				"Bian",
				"Rou",
				"Wei",
				"Fu",
				"Yuan",
				"Mei",
				"Wei",
				"Fu",
				"Ruan",
				"Xie",
				"You",
				"Qiu",
				"Mao",
				"Xia",
				"Ying",
				"Shi",
				"Chong",
				"Tang",
				"Zhu",
				"Zong",
				"Ti",
				"Fu",
				"Yuan",
				"Hui",
				"Meng",
				"La",
				"Du",
				"Hu",
				"Qiu",
				"Die",
				"Li",
				"Gua",
				"Yun",
				"Ju",
				"Nan",
				"Lou",
				"Qun",
				"Rong",
				"Ying",
				"Jiang",
				,
				"Lang",
				"Pang",
				"Si",
				"Xi",
				"Ci",
				"Xi",
				"Yuan",
				"Weng",
				"Lian",
				"Sou",
				"Ban",
				"Rong",
				"Rong",
				"Ji",
				"Wu",
				"Qiu",
				"Han",
				"Qin",
				"Yi",
				"Bi",
				"Hua",
				"Tang",
				"Yi",
				"Du",
				"Nai",
				"He",
				"Hu",
				"Hui",
				"Ma",
				"Ming",
				"Yi",
				"Wen",
				"Ying",
				"Teng",
				"Yu",
				"Cang",
				"So",
				"Ebi",
				"Man",
				,
				"Shang",
				"Zhe",
				"Cao",
				"Chi",
				"Di",
				"Ao",
				"Lu",
				"Wei",
				"Zhi",
				"Tang",
				"Chen",
				"Piao",
				"Qu",
				"Pi",
				"Yu",
				"Jian",
				"Luo",
				"Lou",
				"Qin",
				"Zhong",
				"Yin",
				"Jiang",
				"Shuai",
				"Wen",
				"Jiao",
				"Wan",
				"Zhi",
				"Zhe",
				"Ma",
				"Ma",
				"Guo",
				"Liu",
				"Mao",
				"Xi",
				"Cong",
				"Li",
				"Man",
				"Xiao",
				"Kamakiri",
				"Zhang",
				"Mang",
				"Xiang",
				"Mo",
				"Zui",
				"Si",
				"Qiu",
				"Te",
				"Zhi",
				"Peng",
				"Peng",
				"Jiao",
				"Qu",
				"Bie",
				"Liao",
				"Pan",
				"Gui",
				"Xi",
				"Ji",
				"Zhuan",
				"Huang",
				"Fei",
				"Lao",
				"Jue",
				"Jue",
				"Hui",
				"Yin",
				"Chan",
				"Jiao",
				"Shan",
				"Rao",
				"Xiao",
				"Mou",
				"Chong",
				"Xun",
				"Si",
				,
				"Cheng",
				"Dang",
				"Li",
				"Xie",
				"Shan",
				"Yi",
				"Jing",
				"Da",
				"Chan",
				"Qi"
			],
			[
				"Ci",
				"Xiang",
				"She",
				"Luo",
				"Qin",
				"Ying",
				"Chai",
				"Li",
				"Ze",
				"Xuan",
				"Lian",
				"Zhu",
				"Ze",
				"Xie",
				"Mang",
				"Xie",
				"Qi",
				"Rong",
				"Jian",
				"Meng",
				"Hao",
				"Ruan",
				"Huo",
				"Zhuo",
				"Jie",
				"Bin",
				"He",
				"Mie",
				"Fan",
				"Lei",
				"Jie",
				"La",
				"Mi",
				"Li",
				"Chun",
				"Li",
				"Qiu",
				"Nie",
				"Lu",
				"Du",
				"Xiao",
				"Zhu",
				"Long",
				"Li",
				"Long",
				"Feng",
				"Ye",
				"Beng",
				"Shang",
				"Gu",
				"Juan",
				"Ying",
				,
				"Xi",
				"Can",
				"Qu",
				"Quan",
				"Du",
				"Can",
				"Man",
				"Jue",
				"Jie",
				"Zhu",
				"Zha",
				"Xie",
				"Huang",
				"Niu",
				"Pei",
				"Nu",
				"Xin",
				"Zhong",
				"Mo",
				"Er",
				"Ke",
				"Mie",
				"Xi",
				"Xing",
				"Yan",
				"Kan",
				"Yuan",
				,
				"Ling",
				"Xuan",
				"Shu",
				"Xian",
				"Tong",
				"Long",
				"Jie",
				"Xian",
				"Ya",
				"Hu",
				"Wei",
				"Dao",
				"Chong",
				"Wei",
				"Dao",
				"Zhun",
				"Heng",
				"Qu",
				"Yi",
				"Yi",
				"Bu",
				"Gan",
				"Yu",
				"Biao",
				"Cha",
				"Yi",
				"Shan",
				"Chen",
				"Fu",
				"Gun",
				"Fen",
				"Shuai",
				"Jie",
				"Na",
				"Zhong",
				"Dan",
				"Ri",
				"Zhong",
				"Zhong",
				"Xie",
				"Qi",
				"Xie",
				"Ran",
				"Zhi",
				"Ren",
				"Qin",
				"Jin",
				"Jun",
				"Yuan",
				"Mei",
				"Chai",
				"Ao",
				"Niao",
				"Hui",
				"Ran",
				"Jia",
				"Tuo",
				"Ling",
				"Dai",
				"Bao",
				"Pao",
				"Yao",
				"Zuo",
				"Bi",
				"Shao",
				"Tan",
				"Ju",
				"He",
				"Shu",
				"Xiu",
				"Zhen",
				"Yi",
				"Pa",
				"Bo",
				"Di",
				"Wa",
				"Fu",
				"Gun",
				"Zhi",
				"Zhi",
				"Ran",
				"Pan",
				"Yi",
				"Mao",
				"Tuo",
				"Na",
				"Kou",
				"Xian",
				"Chan",
				"Qu",
				"Bei",
				"Gun",
				"Xi",
				"Ne",
				"Bo",
				"Horo",
				"Fu",
				"Yi",
				"Chi",
				"Ku",
				"Ren",
				"Jiang",
				"Jia",
				"Cun",
				"Mo",
				"Jie",
				"Er",
				"Luo",
				"Ru",
				"Zhu",
				"Gui",
				"Yin",
				"Cai",
				"Lie",
				"Kamishimo",
				"Yuki",
				"Zhuang",
				"Dang",
				,
				"Kun",
				"Ken",
				"Niao",
				"Shu",
				"Jia",
				"Kun",
				"Cheng",
				"Li",
				"Juan",
				"Shen",
				"Pou",
				"Ge",
				"Yi",
				"Yu",
				"Zhen",
				"Liu",
				"Qiu",
				"Qun",
				"Ji",
				"Yi",
				"Bu",
				"Zhuang",
				"Shui",
				"Sha",
				"Qun",
				"Li",
				"Lian",
				"Lian",
				"Ku",
				"Jian",
				"Fou",
				"Chan",
				"Bi",
				"Gun",
				"Tao",
				"Yuan",
				"Ling",
				"Chi",
				"Chang",
				"Chou",
				"Duo",
				"Biao",
				"Liang",
				"Chang",
				"Pei",
				"Pei",
				"Fei",
				"Yuan",
				"Luo",
				"Guo",
				"Yan",
				"Du",
				"Xi",
				"Zhi",
				"Ju",
				"Qi"
			],
			[
				"Ji",
				"Zhi",
				"Gua",
				"Ken",
				"Che",
				"Ti",
				"Ti",
				"Fu",
				"Chong",
				"Xie",
				"Bian",
				"Die",
				"Kun",
				"Duan",
				"Xiu",
				"Xiu",
				"He",
				"Yuan",
				"Bao",
				"Bao",
				"Fu",
				"Yu",
				"Tuan",
				"Yan",
				"Hui",
				"Bei",
				"Chu",
				"Lu",
				"Ena",
				"Hitoe",
				"Yun",
				"Da",
				"Gou",
				"Da",
				"Huai",
				"Rong",
				"Yuan",
				"Ru",
				"Nai",
				"Jiong",
				"Suo",
				"Ban",
				"Tun",
				"Chi",
				"Sang",
				"Niao",
				"Ying",
				"Jie",
				"Qian",
				"Huai",
				"Ku",
				"Lian",
				"Bao",
				"Li",
				"Zhe",
				"Shi",
				"Lu",
				"Yi",
				"Die",
				"Xie",
				"Xian",
				"Wei",
				"Biao",
				"Cao",
				"Ji",
				"Jiang",
				"Sen",
				"Bao",
				"Xiang",
				"Chihaya",
				"Pu",
				"Jian",
				"Zhuan",
				"Jian",
				"Zui",
				"Ji",
				"Dan",
				"Za",
				"Fan",
				"Bo",
				"Xiang",
				"Xin",
				"Bie",
				"Rao",
				"Man",
				"Lan",
				"Ao",
				"Duo",
				"Gui",
				"Cao",
				"Sui",
				"Nong",
				"Chan",
				"Lian",
				"Bi",
				"Jin",
				"Dang",
				"Shu",
				"Tan",
				"Bi",
				"Lan",
				"Pu",
				"Ru",
				"Zhi",
				,
				"Shu",
				"Wa",
				"Shi",
				"Bai",
				"Xie",
				"Bo",
				"Chen",
				"Lai",
				"Long",
				"Xi",
				"Xian",
				"Lan",
				"Zhe",
				"Dai",
				"Tasuki",
				"Zan",
				"Shi",
				"Jian",
				"Pan",
				"Yi",
				"Ran",
				"Ya",
				"Xi",
				"Xi",
				"Yao",
				"Feng",
				"Tan",
				,
				"Biao",
				"Fu",
				"Ba",
				"He",
				"Ji",
				"Ji",
				"Jian",
				"Guan",
				"Bian",
				"Yan",
				"Gui",
				"Jue",
				"Pian",
				"Mao",
				"Mi",
				"Mi",
				"Mie",
				"Shi",
				"Si",
				"Zhan",
				"Luo",
				"Jue",
				"Mi",
				"Tiao",
				"Lian",
				"Yao",
				"Zhi",
				"Jun",
				"Xi",
				"Shan",
				"Wei",
				"Xi",
				"Tian",
				"Yu",
				"Lan",
				"E",
				"Du",
				"Qin",
				"Pang",
				"Ji",
				"Ming",
				"Ying",
				"Gou",
				"Qu",
				"Zhan",
				"Jin",
				"Guan",
				"Deng",
				"Jian",
				"Luo",
				"Qu",
				"Jian",
				"Wei",
				"Jue",
				"Qu",
				"Luo",
				"Lan",
				"Shen",
				"Di",
				"Guan",
				"Jian",
				"Guan",
				"Yan",
				"Gui",
				"Mi",
				"Shi",
				"Zhan",
				"Lan",
				"Jue",
				"Ji",
				"Xi",
				"Di",
				"Tian",
				"Yu",
				"Gou",
				"Jin",
				"Qu",
				"Jiao",
				"Jiu",
				"Jin",
				"Cu",
				"Jue",
				"Zhi",
				"Chao",
				"Ji",
				"Gu",
				"Dan",
				"Zui",
				"Di",
				"Shang",
				"Hua",
				"Quan",
				"Ge",
				"Chi",
				"Jie",
				"Gui",
				"Gong",
				"Chu",
				"Jie",
				"Hun",
				"Qiu",
				"Xing",
				"Su",
				"Ni",
				"Ji",
				"Lu",
				"Zhi",
				"Zha",
				"Bi",
				"Xing",
				"Hu",
				"Shang",
				"Gong",
				"Zhi",
				"Xue",
				"Chu",
				"Xi",
				"Yi",
				"Lu",
				"Jue",
				"Xi",
				"Yan",
				"Xi"
			],
			[
				"Yan",
				"Yan",
				"Ding",
				"Fu",
				"Qiu",
				"Qiu",
				"Jiao",
				"Hong",
				"Ji",
				"Fan",
				"Xun",
				"Diao",
				"Hong",
				"Cha",
				"Tao",
				"Xu",
				"Jie",
				"Yi",
				"Ren",
				"Xun",
				"Yin",
				"Shan",
				"Qi",
				"Tuo",
				"Ji",
				"Xun",
				"Yin",
				"E",
				"Fen",
				"Ya",
				"Yao",
				"Song",
				"Shen",
				"Yin",
				"Xin",
				"Jue",
				"Xiao",
				"Ne",
				"Chen",
				"You",
				"Zhi",
				"Xiong",
				"Fang",
				"Xin",
				"Chao",
				"She",
				"Xian",
				"Sha",
				"Tun",
				"Xu",
				"Yi",
				"Yi",
				"Su",
				"Chi",
				"He",
				"Shen",
				"He",
				"Xu",
				"Zhen",
				"Zhu",
				"Zheng",
				"Gou",
				"Zi",
				"Zi",
				"Zhan",
				"Gu",
				"Fu",
				"Quan",
				"Die",
				"Ling",
				"Di",
				"Yang",
				"Li",
				"Nao",
				"Pan",
				"Zhou",
				"Gan",
				"Yi",
				"Ju",
				"Ao",
				"Zha",
				"Tuo",
				"Yi",
				"Qu",
				"Zhao",
				"Ping",
				"Bi",
				"Xiong",
				"Qu",
				"Ba",
				"Da",
				"Zu",
				"Tao",
				"Zhu",
				"Ci",
				"Zhe",
				"Yong",
				"Xu",
				"Xun",
				"Yi",
				"Huang",
				"He",
				"Shi",
				"Cha",
				"Jiao",
				"Shi",
				"Hen",
				"Cha",
				"Gou",
				"Gui",
				"Quan",
				"Hui",
				"Jie",
				"Hua",
				"Gai",
				"Xiang",
				"Wei",
				"Shen",
				"Chou",
				"Tong",
				"Mi",
				"Zhan",
				"Ming",
				"E",
				"Hui",
				"Yan",
				"Xiong",
				"Gua",
				"Er",
				"Beng",
				"Tiao",
				"Chi",
				"Lei",
				"Zhu",
				"Kuang",
				"Kua",
				"Wu",
				"Yu",
				"Teng",
				"Ji",
				"Zhi",
				"Ren",
				"Su",
				"Lang",
				"E",
				"Kuang",
				"E",
				"Shi",
				"Ting",
				"Dan",
				"Bo",
				"Chan",
				"You",
				"Heng",
				"Qiao",
				"Qin",
				"Shua",
				"An",
				"Yu",
				"Xiao",
				"Cheng",
				"Jie",
				"Xian",
				"Wu",
				"Wu",
				"Gao",
				"Song",
				"Pu",
				"Hui",
				"Jing",
				"Shuo",
				"Zhen",
				"Shuo",
				"Du",
				"Yasashi",
				"Chang",
				"Shui",
				"Jie",
				"Ke",
				"Qu",
				"Cong",
				"Xiao",
				"Sui",
				"Wang",
				"Xuan",
				"Fei",
				"Chi",
				"Ta",
				"Yi",
				"Na",
				"Yin",
				"Diao",
				"Pi",
				"Chuo",
				"Chan",
				"Chen",
				"Zhun",
				"Ji",
				"Qi",
				"Tan",
				"Zhui",
				"Wei",
				"Ju",
				"Qing",
				"Jian",
				"Zheng",
				"Ze",
				"Zou",
				"Qian",
				"Zhuo",
				"Liang",
				"Jian",
				"Zhu",
				"Hao",
				"Lun",
				"Shen",
				"Biao",
				"Huai",
				"Pian",
				"Yu",
				"Die",
				"Xu",
				"Pian",
				"Shi",
				"Xuan",
				"Shi",
				"Hun",
				"Hua",
				"E",
				"Zhong",
				"Di",
				"Xie",
				"Fu",
				"Pu",
				"Ting",
				"Jian",
				"Qi",
				"Yu",
				"Zi",
				"Chuan",
				"Xi",
				"Hui",
				"Yin",
				"An",
				"Xian",
				"Nan",
				"Chen",
				"Feng",
				"Zhu",
				"Yang",
				"Yan",
				"Heng",
				"Xuan",
				"Ge",
				"Nuo",
				"Qi"
			],
			[
				"Mou",
				"Ye",
				"Wei",
				,
				"Teng",
				"Zou",
				"Shan",
				"Jian",
				"Bo",
				"Ku",
				"Huang",
				"Huo",
				"Ge",
				"Ying",
				"Mi",
				"Xiao",
				"Mi",
				"Xi",
				"Qiang",
				"Chen",
				"Nue",
				"Ti",
				"Su",
				"Bang",
				"Chi",
				"Qian",
				"Shi",
				"Jiang",
				"Yuan",
				"Xie",
				"Xue",
				"Tao",
				"Yao",
				"Yao",
				,
				"Yu",
				"Biao",
				"Cong",
				"Qing",
				"Li",
				"Mo",
				"Mo",
				"Shang",
				"Zhe",
				"Miu",
				"Jian",
				"Ze",
				"Jie",
				"Lian",
				"Lou",
				"Can",
				"Ou",
				"Guan",
				"Xi",
				"Zhuo",
				"Ao",
				"Ao",
				"Jin",
				"Zhe",
				"Yi",
				"Hu",
				"Jiang",
				"Man",
				"Chao",
				"Han",
				"Hua",
				"Chan",
				"Xu",
				"Zeng",
				"Se",
				"Xi",
				"She",
				"Dui",
				"Zheng",
				"Nao",
				"Lan",
				"E",
				"Ying",
				"Jue",
				"Ji",
				"Zun",
				"Jiao",
				"Bo",
				"Hui",
				"Zhuan",
				"Mu",
				"Zen",
				"Zha",
				"Shi",
				"Qiao",
				"Tan",
				"Zen",
				"Pu",
				"Sheng",
				"Xuan",
				"Zao",
				"Tan",
				"Dang",
				"Sui",
				"Qian",
				"Ji",
				"Jiao",
				"Jing",
				"Lian",
				"Nou",
				"Yi",
				"Ai",
				"Zhan",
				"Pi",
				"Hui",
				"Hua",
				"Yi",
				"Yi",
				"Shan",
				"Rang",
				"Nou",
				"Qian",
				"Zhui",
				"Ta",
				"Hu",
				"Zhou",
				"Hao",
				"Ye",
				"Ying",
				"Jian",
				"Yu",
				"Jian",
				"Hui",
				"Du",
				"Zhe",
				"Xuan",
				"Zan",
				"Lei",
				"Shen",
				"Wei",
				"Chan",
				"Li",
				"Yi",
				"Bian",
				"Zhe",
				"Yan",
				"E",
				"Chou",
				"Wei",
				"Chou",
				"Yao",
				"Chan",
				"Rang",
				"Yin",
				"Lan",
				"Chen",
				"Huo",
				"Zhe",
				"Huan",
				"Zan",
				"Yi",
				"Dang",
				"Zhan",
				"Yan",
				"Du",
				"Yan",
				"Ji",
				"Ding",
				"Fu",
				"Ren",
				"Ji",
				"Jie",
				"Hong",
				"Tao",
				"Rang",
				"Shan",
				"Qi",
				"Tuo",
				"Xun",
				"Yi",
				"Xun",
				"Ji",
				"Ren",
				"Jiang",
				"Hui",
				"Ou",
				"Ju",
				"Ya",
				"Ne",
				"Xu",
				"E",
				"Lun",
				"Xiong",
				"Song",
				"Feng",
				"She",
				"Fang",
				"Jue",
				"Zheng",
				"Gu",
				"He",
				"Ping",
				"Zu",
				"Shi",
				"Xiong",
				"Zha",
				"Su",
				"Zhen",
				"Di",
				"Zou",
				"Ci",
				"Qu",
				"Zhao",
				"Bi",
				"Yi",
				"Yi",
				"Kuang",
				"Lei",
				"Shi",
				"Gua",
				"Shi",
				"Jie",
				"Hui",
				"Cheng",
				"Zhu",
				"Shen",
				"Hua",
				"Dan",
				"Gou",
				"Quan",
				"Gui",
				"Xun",
				"Yi",
				"Zheng",
				"Gai",
				"Xiang",
				"Cha",
				"Hun",
				"Xu",
				"Zhou",
				"Jie",
				"Wu",
				"Yu",
				"Qiao",
				"Wu",
				"Gao",
				"You",
				"Hui",
				"Kuang",
				"Shuo",
				"Song",
				"Ai",
				"Qing",
				"Zhu",
				"Zou",
				"Nuo",
				"Du",
				"Zhuo",
				"Fei",
				"Ke",
				"Wei"
			],
			[
				"Yu",
				"Shui",
				"Shen",
				"Diao",
				"Chan",
				"Liang",
				"Zhun",
				"Sui",
				"Tan",
				"Shen",
				"Yi",
				"Mou",
				"Chen",
				"Die",
				"Huang",
				"Jian",
				"Xie",
				"Nue",
				"Ye",
				"Wei",
				"E",
				"Yu",
				"Xuan",
				"Chan",
				"Zi",
				"An",
				"Yan",
				"Di",
				"Mi",
				"Pian",
				"Xu",
				"Mo",
				"Dang",
				"Su",
				"Xie",
				"Yao",
				"Bang",
				"Shi",
				"Qian",
				"Mi",
				"Jin",
				"Man",
				"Zhe",
				"Jian",
				"Miu",
				"Tan",
				"Zen",
				"Qiao",
				"Lan",
				"Pu",
				"Jue",
				"Yan",
				"Qian",
				"Zhan",
				"Chen",
				"Gu",
				"Qian",
				"Hong",
				"Xia",
				"Jue",
				"Hong",
				"Han",
				"Hong",
				"Xi",
				"Xi",
				"Huo",
				"Liao",
				"Han",
				"Du",
				"Long",
				"Dou",
				"Jiang",
				"Qi",
				"Shi",
				"Li",
				"Deng",
				"Wan",
				"Bi",
				"Shu",
				"Xian",
				"Feng",
				"Zhi",
				"Zhi",
				"Yan",
				"Yan",
				"Shi",
				"Chu",
				"Hui",
				"Tun",
				"Yi",
				"Tun",
				"Yi",
				"Jian",
				"Ba",
				"Hou",
				"E",
				"Cu",
				"Xiang",
				"Huan",
				"Jian",
				"Ken",
				"Gai",
				"Qu",
				"Fu",
				"Xi",
				"Bin",
				"Hao",
				"Yu",
				"Zhu",
				"Jia",
				,
				"Xi",
				"Bo",
				"Wen",
				"Huan",
				"Bin",
				"Di",
				"Zong",
				"Fen",
				"Yi",
				"Zhi",
				"Bao",
				"Chai",
				"Han",
				"Pi",
				"Na",
				"Pi",
				"Gou",
				"Na",
				"You",
				"Diao",
				"Mo",
				"Si",
				"Xiu",
				"Huan",
				"Kun",
				"He",
				"He",
				"Mo",
				"Han",
				"Mao",
				"Li",
				"Ni",
				"Bi",
				"Yu",
				"Jia",
				"Tuan",
				"Mao",
				"Pi",
				"Xi",
				"E",
				"Ju",
				"Mo",
				"Chu",
				"Tan",
				"Huan",
				"Jue",
				"Bei",
				"Zhen",
				"Yuan",
				"Fu",
				"Cai",
				"Gong",
				"Te",
				"Yi",
				"Hang",
				"Wan",
				"Pin",
				"Huo",
				"Fan",
				"Tan",
				"Guan",
				"Ze",
				"Zhi",
				"Er",
				"Zhu",
				"Shi",
				"Bi",
				"Zi",
				"Er",
				"Gui",
				"Pian",
				"Bian",
				"Mai",
				"Dai",
				"Sheng",
				"Kuang",
				"Fei",
				"Tie",
				"Yi",
				"Chi",
				"Mao",
				"He",
				"Bi",
				"Lu",
				"Ren",
				"Hui",
				"Gai",
				"Pian",
				"Zi",
				"Jia",
				"Xu",
				"Zei",
				"Jiao",
				"Gai",
				"Zang",
				"Jian",
				"Ying",
				"Xun",
				"Zhen",
				"She",
				"Bin",
				"Bin",
				"Qiu",
				"She",
				"Chuan",
				"Zang",
				"Zhou",
				"Lai",
				"Zan",
				"Si",
				"Chen",
				"Shang",
				"Tian",
				"Pei",
				"Geng",
				"Xian",
				"Mai",
				"Jian",
				"Sui",
				"Fu",
				"Tan",
				"Cong",
				"Cong",
				"Zhi",
				"Ji",
				"Zhang",
				"Du",
				"Jin",
				"Xiong",
				"Shun",
				"Yun",
				"Bao",
				"Zai",
				"Lai",
				"Feng",
				"Cang",
				"Ji",
				"Sheng",
				"Ai",
				"Zhuan",
				"Fu",
				"Gou",
				"Sai",
				"Ze",
				"Liao"
			],
			[
				"Wei",
				"Bai",
				"Chen",
				"Zhuan",
				"Zhi",
				"Zhui",
				"Biao",
				"Yun",
				"Zeng",
				"Tan",
				"Zan",
				"Yan",
				,
				"Shan",
				"Wan",
				"Ying",
				"Jin",
				"Gan",
				"Xian",
				"Zang",
				"Bi",
				"Du",
				"Shu",
				"Yan",
				,
				"Xuan",
				"Long",
				"Gan",
				"Zang",
				"Bei",
				"Zhen",
				"Fu",
				"Yuan",
				"Gong",
				"Cai",
				"Ze",
				"Xian",
				"Bai",
				"Zhang",
				"Huo",
				"Zhi",
				"Fan",
				"Tan",
				"Pin",
				"Bian",
				"Gou",
				"Zhu",
				"Guan",
				"Er",
				"Jian",
				"Bi",
				"Shi",
				"Tie",
				"Gui",
				"Kuang",
				"Dai",
				"Mao",
				"Fei",
				"He",
				"Yi",
				"Zei",
				"Zhi",
				"Jia",
				"Hui",
				"Zi",
				"Ren",
				"Lu",
				"Zang",
				"Zi",
				"Gai",
				"Jin",
				"Qiu",
				"Zhen",
				"Lai",
				"She",
				"Fu",
				"Du",
				"Ji",
				"Shu",
				"Shang",
				"Si",
				"Bi",
				"Zhou",
				"Geng",
				"Pei",
				"Tan",
				"Lai",
				"Feng",
				"Zhui",
				"Fu",
				"Zhuan",
				"Sai",
				"Ze",
				"Yan",
				"Zan",
				"Yun",
				"Zeng",
				"Shan",
				"Ying",
				"Gan",
				"Chi",
				"Xi",
				"She",
				"Nan",
				"Xiong",
				"Xi",
				"Cheng",
				"He",
				"Cheng",
				"Zhe",
				"Xia",
				"Tang",
				"Zou",
				"Zou",
				"Li",
				"Jiu",
				"Fu",
				"Zhao",
				"Gan",
				"Qi",
				"Shan",
				"Qiong",
				"Qin",
				"Xian",
				"Ci",
				"Jue",
				"Qin",
				"Chi",
				"Ci",
				"Chen",
				"Chen",
				"Die",
				"Ju",
				"Chao",
				"Di",
				"Se",
				"Zhan",
				"Zhu",
				"Yue",
				"Qu",
				"Jie",
				"Chi",
				"Chu",
				"Gua",
				"Xue",
				"Ci",
				"Tiao",
				"Duo",
				"Lie",
				"Gan",
				"Suo",
				"Cu",
				"Xi",
				"Zhao",
				"Su",
				"Yin",
				"Ju",
				"Jian",
				"Que",
				"Tang",
				"Chuo",
				"Cui",
				"Lu",
				"Qu",
				"Dang",
				"Qiu",
				"Zi",
				"Ti",
				"Qu",
				"Chi",
				"Huang",
				"Qiao",
				"Qiao",
				"Yao",
				"Zao",
				"Ti",
				,
				"Zan",
				"Zan",
				"Zu",
				"Pa",
				"Bao",
				"Ku",
				"Ke",
				"Dun",
				"Jue",
				"Fu",
				"Chen",
				"Jian",
				"Fang",
				"Zhi",
				"Sa",
				"Yue",
				"Pa",
				"Qi",
				"Yue",
				"Qiang",
				"Tuo",
				"Tai",
				"Yi",
				"Nian",
				"Ling",
				"Mei",
				"Ba",
				"Die",
				"Ku",
				"Tuo",
				"Jia",
				"Ci",
				"Pao",
				"Qia",
				"Zhu",
				"Ju",
				"Die",
				"Zhi",
				"Fu",
				"Pan",
				"Ju",
				"Shan",
				"Bo",
				"Ni",
				"Ju",
				"Li",
				"Gen",
				"Yi",
				"Ji",
				"Dai",
				"Xian",
				"Jiao",
				"Duo",
				"Zhu",
				"Zhuan",
				"Kua",
				"Zhuai",
				"Gui",
				"Qiong",
				"Kui",
				"Xiang",
				"Chi",
				"Lu",
				"Beng",
				"Zhi",
				"Jia",
				"Tiao",
				"Cai",
				"Jian",
				"Ta",
				"Qiao",
				"Bi",
				"Xian",
				"Duo",
				"Ji",
				"Ju",
				"Ji",
				"Shu",
				"Tu"
			],
			[
				"Chu",
				"Jing",
				"Nie",
				"Xiao",
				"Bo",
				"Chi",
				"Qun",
				"Mou",
				"Shu",
				"Lang",
				"Yong",
				"Jiao",
				"Chou",
				"Qiao",
				,
				"Ta",
				"Jian",
				"Qi",
				"Wo",
				"Wei",
				"Zhuo",
				"Jie",
				"Ji",
				"Nie",
				"Ju",
				"Ju",
				"Lun",
				"Lu",
				"Leng",
				"Huai",
				"Ju",
				"Chi",
				"Wan",
				"Quan",
				"Ti",
				"Bo",
				"Zu",
				"Qie",
				"Ji",
				"Cu",
				"Zong",
				"Cai",
				"Zong",
				"Peng",
				"Zhi",
				"Zheng",
				"Dian",
				"Zhi",
				"Yu",
				"Duo",
				"Dun",
				"Chun",
				"Yong",
				"Zhong",
				"Di",
				"Zhe",
				"Chen",
				"Chuai",
				"Jian",
				"Gua",
				"Tang",
				"Ju",
				"Fu",
				"Zu",
				"Die",
				"Pian",
				"Rou",
				"Nuo",
				"Ti",
				"Cha",
				"Tui",
				"Jian",
				"Dao",
				"Cuo",
				"Xi",
				"Ta",
				"Qiang",
				"Zhan",
				"Dian",
				"Ti",
				"Ji",
				"Nie",
				"Man",
				"Liu",
				"Zhan",
				"Bi",
				"Chong",
				"Lu",
				"Liao",
				"Cu",
				"Tang",
				"Dai",
				"Suo",
				"Xi",
				"Kui",
				"Ji",
				"Zhi",
				"Qiang",
				"Di",
				"Man",
				"Zong",
				"Lian",
				"Beng",
				"Zao",
				"Nian",
				"Bie",
				"Tui",
				"Ju",
				"Deng",
				"Ceng",
				"Xian",
				"Fan",
				"Chu",
				"Zhong",
				"Dun",
				"Bo",
				"Cu",
				"Zu",
				"Jue",
				"Jue",
				"Lin",
				"Ta",
				"Qiao",
				"Qiao",
				"Pu",
				"Liao",
				"Dun",
				"Cuan",
				"Kuang",
				"Zao",
				"Ta",
				"Bi",
				"Bi",
				"Zhu",
				"Ju",
				"Chu",
				"Qiao",
				"Dun",
				"Chou",
				"Ji",
				"Wu",
				"Yue",
				"Nian",
				"Lin",
				"Lie",
				"Zhi",
				"Li",
				"Zhi",
				"Chan",
				"Chu",
				"Duan",
				"Wei",
				"Long",
				"Lin",
				"Xian",
				"Wei",
				"Zuan",
				"Lan",
				"Xie",
				"Rang",
				"Xie",
				"Nie",
				"Ta",
				"Qu",
				"Jie",
				"Cuan",
				"Zuan",
				"Xi",
				"Kui",
				"Jue",
				"Lin",
				"Shen",
				"Gong",
				"Dan",
				"Segare",
				"Qu",
				"Ti",
				"Duo",
				"Duo",
				"Gong",
				"Lang",
				"Nerau",
				"Luo",
				"Ai",
				"Ji",
				"Ju",
				"Tang",
				"Utsuke",
				,
				"Yan",
				"Shitsuke",
				"Kang",
				"Qu",
				"Lou",
				"Lao",
				"Tuo",
				"Zhi",
				"Yagate",
				"Ti",
				"Dao",
				"Yagate",
				"Yu",
				"Che",
				"Ya",
				"Gui",
				"Jun",
				"Wei",
				"Yue",
				"Xin",
				"Di",
				"Xuan",
				"Fan",
				"Ren",
				"Shan",
				"Qiang",
				"Shu",
				"Tun",
				"Chen",
				"Dai",
				"E",
				"Na",
				"Qi",
				"Mao",
				"Ruan",
				"Ren",
				"Fan",
				"Zhuan",
				"Hong",
				"Hu",
				"Qu",
				"Huang",
				"Di",
				"Ling",
				"Dai",
				"Ao",
				"Zhen",
				"Fan",
				"Kuang",
				"Ang",
				"Peng",
				"Bei",
				"Gu",
				"Ku",
				"Pao",
				"Zhu",
				"Rong",
				"E",
				"Ba",
				"Zhou",
				"Zhi",
				"Yao",
				"Ke",
				"Yi",
				"Qing",
				"Shi",
				"Ping"
			],
			[
				"Er",
				"Qiong",
				"Ju",
				"Jiao",
				"Guang",
				"Lu",
				"Kai",
				"Quan",
				"Zhou",
				"Zai",
				"Zhi",
				"She",
				"Liang",
				"Yu",
				"Shao",
				"You",
				"Huan",
				"Yun",
				"Zhe",
				"Wan",
				"Fu",
				"Qing",
				"Zhou",
				"Ni",
				"Ling",
				"Zhe",
				"Zhan",
				"Liang",
				"Zi",
				"Hui",
				"Wang",
				"Chuo",
				"Guo",
				"Kan",
				"Yi",
				"Peng",
				"Qian",
				"Gun",
				"Nian",
				"Pian",
				"Guan",
				"Bei",
				"Lun",
				"Pai",
				"Liang",
				"Ruan",
				"Rou",
				"Ji",
				"Yang",
				"Xian",
				"Chuan",
				"Cou",
				"Qun",
				"Ge",
				"You",
				"Hong",
				"Shu",
				"Fu",
				"Zi",
				"Fu",
				"Wen",
				"Ben",
				"Zhan",
				"Yu",
				"Wen",
				"Tao",
				"Gu",
				"Zhen",
				"Xia",
				"Yuan",
				"Lu",
				"Jiu",
				"Chao",
				"Zhuan",
				"Wei",
				"Hun",
				"Sori",
				"Che",
				"Jiao",
				"Zhan",
				"Pu",
				"Lao",
				"Fen",
				"Fan",
				"Lin",
				"Ge",
				"Se",
				"Kan",
				"Huan",
				"Yi",
				"Ji",
				"Dui",
				"Er",
				"Yu",
				"Xian",
				"Hong",
				"Lei",
				"Pei",
				"Li",
				"Li",
				"Lu",
				"Lin",
				"Che",
				"Ya",
				"Gui",
				"Xuan",
				"Di",
				"Ren",
				"Zhuan",
				"E",
				"Lun",
				"Ruan",
				"Hong",
				"Ku",
				"Ke",
				"Lu",
				"Zhou",
				"Zhi",
				"Yi",
				"Hu",
				"Zhen",
				"Li",
				"Yao",
				"Qing",
				"Shi",
				"Zai",
				"Zhi",
				"Jiao",
				"Zhou",
				"Quan",
				"Lu",
				"Jiao",
				"Zhe",
				"Fu",
				"Liang",
				"Nian",
				"Bei",
				"Hui",
				"Gun",
				"Wang",
				"Liang",
				"Chuo",
				"Zi",
				"Cou",
				"Fu",
				"Ji",
				"Wen",
				"Shu",
				"Pei",
				"Yuan",
				"Xia",
				"Zhan",
				"Lu",
				"Che",
				"Lin",
				"Xin",
				"Gu",
				"Ci",
				"Ci",
				"Pi",
				"Zui",
				"Bian",
				"La",
				"La",
				"Ci",
				"Xue",
				"Ban",
				"Bian",
				"Bian",
				"Bian",
				,
				"Bian",
				"Ban",
				"Ci",
				"Bian",
				"Bian",
				"Chen",
				"Ru",
				"Nong",
				"Nong",
				"Zhen",
				"Chuo",
				"Chuo",
				"Suberu",
				"Reng",
				"Bian",
				"Bian",
				"Sip",
				"Ip",
				"Liao",
				"Da",
				"Chan",
				"Gan",
				"Qian",
				"Yu",
				"Yu",
				"Qi",
				"Xun",
				"Yi",
				"Guo",
				"Mai",
				"Qi",
				"Za",
				"Wang",
				"Jia",
				"Zhun",
				"Ying",
				"Ti",
				"Yun",
				"Jin",
				"Hang",
				"Ya",
				"Fan",
				"Wu",
				"Da",
				"E",
				"Huan",
				"Zhe",
				"Totemo",
				"Jin",
				"Yuan",
				"Wei",
				"Lian",
				"Chi",
				"Che",
				"Ni",
				"Tiao",
				"Zhi",
				"Yi",
				"Jiong",
				"Jia",
				"Chen",
				"Dai",
				"Er",
				"Di",
				"Po",
				"Wang",
				"Die",
				"Ze",
				"Tao",
				"Shu",
				"Tuo",
				"Kep",
				"Jing",
				"Hui",
				"Tong",
				"You",
				"Mi",
				"Beng",
				"Ji",
				"Nai",
				"Yi",
				"Jie",
				"Zhui",
				"Lie",
				"Xun"
			],
			[
				"Tui",
				"Song",
				"Gua",
				"Tao",
				"Pang",
				"Hou",
				"Ni",
				"Dun",
				"Jiong",
				"Xuan",
				"Xun",
				"Bu",
				"You",
				"Xiao",
				"Qiu",
				"Tou",
				"Zhu",
				"Qiu",
				"Di",
				"Di",
				"Tu",
				"Jing",
				"Ti",
				"Dou",
				"Yi",
				"Zhe",
				"Tong",
				"Guang",
				"Wu",
				"Shi",
				"Cheng",
				"Su",
				"Zao",
				"Qun",
				"Feng",
				"Lian",
				"Suo",
				"Hui",
				"Li",
				"Sako",
				"Lai",
				"Ben",
				"Cuo",
				"Jue",
				"Beng",
				"Huan",
				"Dai",
				"Lu",
				"You",
				"Zhou",
				"Jin",
				"Yu",
				"Chuo",
				"Kui",
				"Wei",
				"Ti",
				"Yi",
				"Da",
				"Yuan",
				"Luo",
				"Bi",
				"Nuo",
				"Yu",
				"Dang",
				"Sui",
				"Dun",
				"Sui",
				"Yan",
				"Chuan",
				"Chi",
				"Ti",
				"Yu",
				"Shi",
				"Zhen",
				"You",
				"Yun",
				"E",
				"Bian",
				"Guo",
				"E",
				"Xia",
				"Huang",
				"Qiu",
				"Dao",
				"Da",
				"Wei",
				"Appare",
				"Yi",
				"Gou",
				"Yao",
				"Chu",
				"Liu",
				"Xun",
				"Ta",
				"Di",
				"Chi",
				"Yuan",
				"Su",
				"Ta",
				"Qian",
				,
				"Yao",
				"Guan",
				"Zhang",
				"Ao",
				"Shi",
				"Ce",
				"Chi",
				"Su",
				"Zao",
				"Zhe",
				"Dun",
				"Di",
				"Lou",
				"Chi",
				"Cuo",
				"Lin",
				"Zun",
				"Rao",
				"Qian",
				"Xuan",
				"Yu",
				"Yi",
				"Wu",
				"Liao",
				"Ju",
				"Shi",
				"Bi",
				"Yao",
				"Mai",
				"Xie",
				"Sui",
				"Huan",
				"Zhan",
				"Teng",
				"Er",
				"Miao",
				"Bian",
				"Bian",
				"La",
				"Li",
				"Yuan",
				"Yao",
				"Luo",
				"Li",
				"Yi",
				"Ting",
				"Deng",
				"Qi",
				"Yong",
				"Shan",
				"Han",
				"Yu",
				"Mang",
				"Ru",
				"Qiong",
				,
				"Kuang",
				"Fu",
				"Kang",
				"Bin",
				"Fang",
				"Xing",
				"Na",
				"Xin",
				"Shen",
				"Bang",
				"Yuan",
				"Cun",
				"Huo",
				"Xie",
				"Bang",
				"Wu",
				"Ju",
				"You",
				"Han",
				"Tai",
				"Qiu",
				"Bi",
				"Pei",
				"Bing",
				"Shao",
				"Bei",
				"Wa",
				"Di",
				"Zou",
				"Ye",
				"Lin",
				"Kuang",
				"Gui",
				"Zhu",
				"Shi",
				"Ku",
				"Yu",
				"Gai",
				"Ge",
				"Xi",
				"Zhi",
				"Ji",
				"Xun",
				"Hou",
				"Xing",
				"Jiao",
				"Xi",
				"Gui",
				"Nuo",
				"Lang",
				"Jia",
				"Kuai",
				"Zheng",
				"Otoko",
				"Yun",
				"Yan",
				"Cheng",
				"Dou",
				"Chi",
				"Lu",
				"Fu",
				"Wu",
				"Fu",
				"Gao",
				"Hao",
				"Lang",
				"Jia",
				"Geng",
				"Jun",
				"Ying",
				"Bo",
				"Xi",
				"Bei",
				"Li",
				"Yun",
				"Bu",
				"Xiao",
				"Qi",
				"Pi",
				"Qing",
				"Guo",
				"Zhou",
				"Tan",
				"Zou",
				"Ping",
				"Lai",
				"Ni",
				"Chen",
				"You",
				"Bu",
				"Xiang",
				"Dan",
				"Ju",
				"Yong",
				"Qiao",
				"Yi",
				"Du",
				"Yan",
				"Mei"
			],
			[
				"Ruo",
				"Bei",
				"E",
				"Yu",
				"Juan",
				"Yu",
				"Yun",
				"Hou",
				"Kui",
				"Xiang",
				"Xiang",
				"Sou",
				"Tang",
				"Ming",
				"Xi",
				"Ru",
				"Chu",
				"Zi",
				"Zou",
				"Ju",
				"Wu",
				"Xiang",
				"Yun",
				"Hao",
				"Yong",
				"Bi",
				"Mo",
				"Chao",
				"Fu",
				"Liao",
				"Yin",
				"Zhuan",
				"Hu",
				"Qiao",
				"Yan",
				"Zhang",
				"Fan",
				"Qiao",
				"Xu",
				"Deng",
				"Bi",
				"Xin",
				"Bi",
				"Ceng",
				"Wei",
				"Zheng",
				"Mao",
				"Shan",
				"Lin",
				"Po",
				"Dan",
				"Meng",
				"Ye",
				"Cao",
				"Kuai",
				"Feng",
				"Meng",
				"Zou",
				"Kuang",
				"Lian",
				"Zan",
				"Chan",
				"You",
				"Qi",
				"Yan",
				"Chan",
				"Zan",
				"Ling",
				"Huan",
				"Xi",
				"Feng",
				"Zan",
				"Li",
				"You",
				"Ding",
				"Qiu",
				"Zhuo",
				"Pei",
				"Zhou",
				"Yi",
				"Hang",
				"Yu",
				"Jiu",
				"Yan",
				"Zui",
				"Mao",
				"Dan",
				"Xu",
				"Tou",
				"Zhen",
				"Fen",
				"Sakenomoto",
				,
				"Yun",
				"Tai",
				"Tian",
				"Qia",
				"Tuo",
				"Zuo",
				"Han",
				"Gu",
				"Su",
				"Po",
				"Chou",
				"Zai",
				"Ming",
				"Luo",
				"Chuo",
				"Chou",
				"You",
				"Tong",
				"Zhi",
				"Xian",
				"Jiang",
				"Cheng",
				"Yin",
				"Tu",
				"Xiao",
				"Mei",
				"Ku",
				"Suan",
				"Lei",
				"Pu",
				"Zui",
				"Hai",
				"Yan",
				"Xi",
				"Niang",
				"Wei",
				"Lu",
				"Lan",
				"Yan",
				"Tao",
				"Pei",
				"Zhan",
				"Chun",
				"Tan",
				"Zui",
				"Chuo",
				"Cu",
				"Kun",
				"Ti",
				"Mian",
				"Du",
				"Hu",
				"Xu",
				"Xing",
				"Tan",
				"Jiu",
				"Chun",
				"Yun",
				"Po",
				"Ke",
				"Sou",
				"Mi",
				"Quan",
				"Chou",
				"Cuo",
				"Yun",
				"Yong",
				"Ang",
				"Zha",
				"Hai",
				"Tang",
				"Jiang",
				"Piao",
				"Shan",
				"Yu",
				"Li",
				"Zao",
				"Lao",
				"Yi",
				"Jiang",
				"Pu",
				"Jiao",
				"Xi",
				"Tan",
				"Po",
				"Nong",
				"Yi",
				"Li",
				"Ju",
				"Jiao",
				"Yi",
				"Niang",
				"Ru",
				"Xun",
				"Chou",
				"Yan",
				"Ling",
				"Mi",
				"Mi",
				"Niang",
				"Xin",
				"Jiao",
				"Xi",
				"Mi",
				"Yan",
				"Bian",
				"Cai",
				"Shi",
				"You",
				"Shi",
				"Shi",
				"Li",
				"Chong",
				"Ye",
				"Liang",
				"Li",
				"Jin",
				"Jin",
				"Qiu",
				"Yi",
				"Diao",
				"Dao",
				"Zhao",
				"Ding",
				"Po",
				"Qiu",
				"He",
				"Fu",
				"Zhen",
				"Zhi",
				"Ba",
				"Luan",
				"Fu",
				"Nai",
				"Diao",
				"Shan",
				"Qiao",
				"Kou",
				"Chuan",
				"Zi",
				"Fan",
				"Yu",
				"Hua",
				"Han",
				"Gong",
				"Qi",
				"Mang",
				"Ri",
				"Di",
				"Si",
				"Xi",
				"Yi",
				"Chai",
				"Shi",
				"Tu",
				"Xi",
				"Nu",
				"Qian",
				"Ishiyumi",
				"Jian",
				"Pi",
				"Ye",
				"Yin"
			],
			[
				"Ba",
				"Fang",
				"Chen",
				"Xing",
				"Tou",
				"Yue",
				"Yan",
				"Fu",
				"Pi",
				"Na",
				"Xin",
				"E",
				"Jue",
				"Dun",
				"Gou",
				"Yin",
				"Qian",
				"Ban",
				"Ji",
				"Ren",
				"Chao",
				"Niu",
				"Fen",
				"Yun",
				"Ji",
				"Qin",
				"Pi",
				"Guo",
				"Hong",
				"Yin",
				"Jun",
				"Shi",
				"Yi",
				"Zhong",
				"Nie",
				"Gai",
				"Ri",
				"Huo",
				"Tai",
				"Kang",
				"Habaki",
				"Irori",
				"Ngaak",
				,
				"Duo",
				"Zi",
				"Ni",
				"Tu",
				"Shi",
				"Min",
				"Gu",
				"E",
				"Ling",
				"Bing",
				"Yi",
				"Gu",
				"Ba",
				"Pi",
				"Yu",
				"Si",
				"Zuo",
				"Bu",
				"You",
				"Dian",
				"Jia",
				"Zhen",
				"Shi",
				"Shi",
				"Tie",
				"Ju",
				"Zhan",
				"Shi",
				"She",
				"Xuan",
				"Zhao",
				"Bao",
				"He",
				"Bi",
				"Sheng",
				"Chu",
				"Shi",
				"Bo",
				"Zhu",
				"Chi",
				"Za",
				"Po",
				"Tong",
				"Qian",
				"Fu",
				"Zhai",
				"Liu",
				"Qian",
				"Fu",
				"Li",
				"Yue",
				"Pi",
				"Yang",
				"Ban",
				"Bo",
				"Jie",
				"Gou",
				"Shu",
				"Zheng",
				"Mu",
				"Ni",
				"Nie",
				"Di",
				"Jia",
				"Mu",
				"Dan",
				"Shen",
				"Yi",
				"Si",
				"Kuang",
				"Ka",
				"Bei",
				"Jian",
				"Tong",
				"Xing",
				"Hong",
				"Jiao",
				"Chi",
				"Er",
				"Ge",
				"Bing",
				"Shi",
				"Mou",
				"Jia",
				"Yin",
				"Jun",
				"Zhou",
				"Chong",
				"Shang",
				"Tong",
				"Mo",
				"Lei",
				"Ji",
				"Yu",
				"Xu",
				"Ren",
				"Zun",
				"Zhi",
				"Qiong",
				"Shan",
				"Chi",
				"Xian",
				"Xing",
				"Quan",
				"Pi",
				"Tie",
				"Zhu",
				"Hou",
				"Ming",
				"Kua",
				"Yao",
				"Xian",
				"Xian",
				"Xiu",
				"Jun",
				"Cha",
				"Lao",
				"Ji",
				"Pi",
				"Ru",
				"Mi",
				"Yi",
				"Yin",
				"Guang",
				"An",
				"Diou",
				"You",
				"Se",
				"Kao",
				"Qian",
				"Luan",
				"Kasugai",
				"Ai",
				"Diao",
				"Han",
				"Rui",
				"Shi",
				"Keng",
				"Qiu",
				"Xiao",
				"Zhe",
				"Xiu",
				"Zang",
				"Ti",
				"Cuo",
				"Gua",
				"Gong",
				"Zhong",
				"Dou",
				"Lu",
				"Mei",
				"Lang",
				"Wan",
				"Xin",
				"Yun",
				"Bei",
				"Wu",
				"Su",
				"Yu",
				"Chan",
				"Ting",
				"Bo",
				"Han",
				"Jia",
				"Hong",
				"Cuan",
				"Feng",
				"Chan",
				"Wan",
				"Zhi",
				"Si",
				"Xuan",
				"Wu",
				"Wu",
				"Tiao",
				"Gong",
				"Zhuo",
				"Lue",
				"Xing",
				"Qian",
				"Shen",
				"Han",
				"Lue",
				"Xie",
				"Chu",
				"Zheng",
				"Ju",
				"Xian",
				"Tie",
				"Mang",
				"Pu",
				"Li",
				"Pan",
				"Rui",
				"Cheng",
				"Gao",
				"Li",
				"Te",
				"Pyeng",
				"Zhu",
				,
				"Tu",
				"Liu",
				"Zui",
				"Ju",
				"Chang",
				"Yuan",
				"Jian",
				"Gang",
				"Diao",
				"Tao",
				"Chang"
			],
			[
				"Lun",
				"Kua",
				"Ling",
				"Bei",
				"Lu",
				"Li",
				"Qiang",
				"Pou",
				"Juan",
				"Min",
				"Zui",
				"Peng",
				"An",
				"Pi",
				"Xian",
				"Ya",
				"Zhui",
				"Lei",
				"A",
				"Kong",
				"Ta",
				"Kun",
				"Du",
				"Wei",
				"Chui",
				"Zi",
				"Zheng",
				"Ben",
				"Nie",
				"Cong",
				"Qun",
				"Tan",
				"Ding",
				"Qi",
				"Qian",
				"Zhuo",
				"Qi",
				"Yu",
				"Jin",
				"Guan",
				"Mao",
				"Chang",
				"Tian",
				"Xi",
				"Lian",
				"Tao",
				"Gu",
				"Cuo",
				"Shu",
				"Zhen",
				"Lu",
				"Meng",
				"Lu",
				"Hua",
				"Biao",
				"Ga",
				"Lai",
				"Ken",
				"Kazari",
				"Bu",
				"Nai",
				"Wan",
				"Zan",
				,
				"De",
				"Xian",
				,
				"Huo",
				"Liang",
				,
				"Men",
				"Kai",
				"Ying",
				"Di",
				"Lian",
				"Guo",
				"Xian",
				"Du",
				"Tu",
				"Wei",
				"Cong",
				"Fu",
				"Rou",
				"Ji",
				"E",
				"Rou",
				"Chen",
				"Ti",
				"Zha",
				"Hong",
				"Yang",
				"Duan",
				"Xia",
				"Yu",
				"Keng",
				"Xing",
				"Huang",
				"Wei",
				"Fu",
				"Zhao",
				"Cha",
				"Qie",
				"She",
				"Hong",
				"Kui",
				"Tian",
				"Mou",
				"Qiao",
				"Qiao",
				"Hou",
				"Tou",
				"Cong",
				"Huan",
				"Ye",
				"Min",
				"Jian",
				"Duan",
				"Jian",
				"Song",
				"Kui",
				"Hu",
				"Xuan",
				"Duo",
				"Jie",
				"Zhen",
				"Bian",
				"Zhong",
				"Zi",
				"Xiu",
				"Ye",
				"Mei",
				"Pai",
				"Ai",
				"Jie",
				,
				"Mei",
				"Chuo",
				"Ta",
				"Bang",
				"Xia",
				"Lian",
				"Suo",
				"Xi",
				"Liu",
				"Zu",
				"Ye",
				"Nou",
				"Weng",
				"Rong",
				"Tang",
				"Suo",
				"Qiang",
				"Ge",
				"Shuo",
				"Chui",
				"Bo",
				"Pan",
				"Sa",
				"Bi",
				"Sang",
				"Gang",
				"Zi",
				"Wu",
				"Ying",
				"Huang",
				"Tiao",
				"Liu",
				"Kai",
				"Sun",
				"Sha",
				"Sou",
				"Wan",
				"Hao",
				"Zhen",
				"Zhen",
				"Luo",
				"Yi",
				"Yuan",
				"Tang",
				"Nie",
				"Xi",
				"Jia",
				"Ge",
				"Ma",
				"Juan",
				"Kasugai",
				"Habaki",
				"Suo",
				,
				,
				,
				"Na",
				"Lu",
				"Suo",
				"Ou",
				"Zu",
				"Tuan",
				"Xiu",
				"Guan",
				"Xuan",
				"Lian",
				"Shou",
				"Ao",
				"Man",
				"Mo",
				"Luo",
				"Bi",
				"Wei",
				"Liu",
				"Di",
				"Qiao",
				"Cong",
				"Yi",
				"Lu",
				"Ao",
				"Keng",
				"Qiang",
				"Cui",
				"Qi",
				"Chang",
				"Tang",
				"Man",
				"Yong",
				"Chan",
				"Feng",
				"Jing",
				"Biao",
				"Shu",
				"Lou",
				"Xiu",
				"Cong",
				"Long",
				"Zan",
				"Jian",
				"Cao",
				"Li",
				"Xia",
				"Xi",
				"Kang",
				,
				"Beng",
				,
				,
				"Zheng",
				"Lu",
				"Hua",
				"Ji",
				"Pu",
				"Hui",
				"Qiang",
				"Po",
				"Lin",
				"Suo",
				"Xiu",
				"San",
				"Cheng"
			],
			[
				"Kui",
				"Si",
				"Liu",
				"Nao",
				"Heng",
				"Pie",
				"Sui",
				"Fan",
				"Qiao",
				"Quan",
				"Yang",
				"Tang",
				"Xiang",
				"Jue",
				"Jiao",
				"Zun",
				"Liao",
				"Jie",
				"Lao",
				"Dui",
				"Tan",
				"Zan",
				"Ji",
				"Jian",
				"Zhong",
				"Deng",
				"Ya",
				"Ying",
				"Dui",
				"Jue",
				"Nou",
				"Ti",
				"Pu",
				"Tie",
				,
				,
				"Ding",
				"Shan",
				"Kai",
				"Jian",
				"Fei",
				"Sui",
				"Lu",
				"Juan",
				"Hui",
				"Yu",
				"Lian",
				"Zhuo",
				"Qiao",
				"Qian",
				"Zhuo",
				"Lei",
				"Bi",
				"Tie",
				"Huan",
				"Ye",
				"Duo",
				"Guo",
				"Dang",
				"Ju",
				"Fen",
				"Da",
				"Bei",
				"Yi",
				"Ai",
				"Zong",
				"Xun",
				"Diao",
				"Zhu",
				"Heng",
				"Zhui",
				"Ji",
				"Nie",
				"Ta",
				"Huo",
				"Qing",
				"Bin",
				"Ying",
				"Kui",
				"Ning",
				"Xu",
				"Jian",
				"Jian",
				"Yari",
				"Cha",
				"Zhi",
				"Mie",
				"Li",
				"Lei",
				"Ji",
				"Zuan",
				"Kuang",
				"Shang",
				"Peng",
				"La",
				"Du",
				"Shuo",
				"Chuo",
				"Lu",
				"Biao",
				"Bao",
				"Lu",
				,
				,
				"Long",
				"E",
				"Lu",
				"Xin",
				"Jian",
				"Lan",
				"Bo",
				"Jian",
				"Yao",
				"Chan",
				"Xiang",
				"Jian",
				"Xi",
				"Guan",
				"Cang",
				"Nie",
				"Lei",
				"Cuan",
				"Qu",
				"Pan",
				"Luo",
				"Zuan",
				"Luan",
				"Zao",
				"Nie",
				"Jue",
				"Tang",
				"Shu",
				"Lan",
				"Jin",
				"Qiu",
				"Yi",
				"Zhen",
				"Ding",
				"Zhao",
				"Po",
				"Diao",
				"Tu",
				"Qian",
				"Chuan",
				"Shan",
				"Ji",
				"Fan",
				"Diao",
				"Men",
				"Nu",
				"Xi",
				"Chai",
				"Xing",
				"Gai",
				"Bu",
				"Tai",
				"Ju",
				"Dun",
				"Chao",
				"Zhong",
				"Na",
				"Bei",
				"Gang",
				"Ban",
				"Qian",
				"Yao",
				"Qin",
				"Jun",
				"Wu",
				"Gou",
				"Kang",
				"Fang",
				"Huo",
				"Tou",
				"Niu",
				"Ba",
				"Yu",
				"Qian",
				"Zheng",
				"Qian",
				"Gu",
				"Bo",
				"E",
				"Po",
				"Bu",
				"Ba",
				"Yue",
				"Zuan",
				"Mu",
				"Dan",
				"Jia",
				"Dian",
				"You",
				"Tie",
				"Bo",
				"Ling",
				"Shuo",
				"Qian",
				"Liu",
				"Bao",
				"Shi",
				"Xuan",
				"She",
				"Bi",
				"Ni",
				"Pi",
				"Duo",
				"Xing",
				"Kao",
				"Lao",
				"Er",
				"Mang",
				"Ya",
				"You",
				"Cheng",
				"Jia",
				"Ye",
				"Nao",
				"Zhi",
				"Dang",
				"Tong",
				"Lu",
				"Diao",
				"Yin",
				"Kai",
				"Zha",
				"Zhu",
				"Xian",
				"Ting",
				"Diu",
				"Xian",
				"Hua",
				"Quan",
				"Sha",
				"Jia",
				"Yao",
				"Ge",
				"Ming",
				"Zheng",
				"Se",
				"Jiao",
				"Yi",
				"Chan",
				"Chong",
				"Tang",
				"An",
				"Yin",
				"Ru",
				"Zhu",
				"Lao",
				"Pu",
				"Wu",
				"Lai",
				"Te",
				"Lian",
				"Keng"
			],
			[
				"Xiao",
				"Suo",
				"Li",
				"Zheng",
				"Chu",
				"Guo",
				"Gao",
				"Tie",
				"Xiu",
				"Cuo",
				"Lue",
				"Feng",
				"Xin",
				"Liu",
				"Kai",
				"Jian",
				"Rui",
				"Ti",
				"Lang",
				"Qian",
				"Ju",
				"A",
				"Qiang",
				"Duo",
				"Tian",
				"Cuo",
				"Mao",
				"Ben",
				"Qi",
				"De",
				"Kua",
				"Kun",
				"Chang",
				"Xi",
				"Gu",
				"Luo",
				"Chui",
				"Zhui",
				"Jin",
				"Zhi",
				"Xian",
				"Juan",
				"Huo",
				"Pou",
				"Tan",
				"Ding",
				"Jian",
				"Ju",
				"Meng",
				"Zi",
				"Qie",
				"Ying",
				"Kai",
				"Qiang",
				"Song",
				"E",
				"Cha",
				"Qiao",
				"Zhong",
				"Duan",
				"Sou",
				"Huang",
				"Huan",
				"Ai",
				"Du",
				"Mei",
				"Lou",
				"Zi",
				"Fei",
				"Mei",
				"Mo",
				"Zhen",
				"Bo",
				"Ge",
				"Nie",
				"Tang",
				"Juan",
				"Nie",
				"Na",
				"Liu",
				"Hao",
				"Bang",
				"Yi",
				"Jia",
				"Bin",
				"Rong",
				"Biao",
				"Tang",
				"Man",
				"Luo",
				"Beng",
				"Yong",
				"Jing",
				"Di",
				"Zu",
				"Xuan",
				"Liu",
				"Tan",
				"Jue",
				"Liao",
				"Pu",
				"Lu",
				"Dui",
				"Lan",
				"Pu",
				"Cuan",
				"Qiang",
				"Deng",
				"Huo",
				"Lei",
				"Huan",
				"Zhuo",
				"Lian",
				"Yi",
				"Cha",
				"Biao",
				"La",
				"Chan",
				"Xiang",
				"Chang",
				"Chang",
				"Jiu",
				"Ao",
				"Die",
				"Qu",
				"Liao",
				"Mi",
				"Chang",
				"Men",
				"Ma",
				"Shuan",
				"Shan",
				"Huo",
				"Men",
				"Yan",
				"Bi",
				"Han",
				"Bi",
				"San",
				"Kai",
				"Kang",
				"Beng",
				"Hong",
				"Run",
				"San",
				"Xian",
				"Xian",
				"Jian",
				"Min",
				"Xia",
				"Yuru",
				"Dou",
				"Zha",
				"Nao",
				"Jian",
				"Peng",
				"Xia",
				"Ling",
				"Bian",
				"Bi",
				"Run",
				"He",
				"Guan",
				"Ge",
				"Ge",
				"Fa",
				"Chu",
				"Hong",
				"Gui",
				"Min",
				"Se",
				"Kun",
				"Lang",
				"Lu",
				"Ting",
				"Sha",
				"Ju",
				"Yue",
				"Yue",
				"Chan",
				"Qu",
				"Lin",
				"Chang",
				"Shai",
				"Kun",
				"Yan",
				"Min",
				"Yan",
				"E",
				"Hun",
				"Yu",
				"Wen",
				"Xiang",
				"Bao",
				"Xiang",
				"Qu",
				"Yao",
				"Wen",
				"Ban",
				"An",
				"Wei",
				"Yin",
				"Kuo",
				"Que",
				"Lan",
				"Du",
				,
				"Phwung",
				"Tian",
				"Nie",
				"Ta",
				"Kai",
				"He",
				"Que",
				"Chuang",
				"Guan",
				"Dou",
				"Qi",
				"Kui",
				"Tang",
				"Guan",
				"Piao",
				"Kan",
				"Xi",
				"Hui",
				"Chan",
				"Pi",
				"Dang",
				"Huan",
				"Ta",
				"Wen",
				,
				"Men",
				"Shuan",
				"Shan",
				"Yan",
				"Han",
				"Bi",
				"Wen",
				"Chuang",
				"Run",
				"Wei",
				"Xian",
				"Hong",
				"Jian",
				"Min",
				"Kang",
				"Men",
				"Zha",
				"Nao",
				"Gui",
				"Wen",
				"Ta",
				"Min",
				"Lu",
				"Kai"
			],
			[
				"Fa",
				"Ge",
				"He",
				"Kun",
				"Jiu",
				"Yue",
				"Lang",
				"Du",
				"Yu",
				"Yan",
				"Chang",
				"Xi",
				"Wen",
				"Hun",
				"Yan",
				"E",
				"Chan",
				"Lan",
				"Qu",
				"Hui",
				"Kuo",
				"Que",
				"Ge",
				"Tian",
				"Ta",
				"Que",
				"Kan",
				"Huan",
				"Fu",
				"Fu",
				"Le",
				"Dui",
				"Xin",
				"Qian",
				"Wu",
				"Yi",
				"Tuo",
				"Yin",
				"Yang",
				"Dou",
				"E",
				"Sheng",
				"Ban",
				"Pei",
				"Keng",
				"Yun",
				"Ruan",
				"Zhi",
				"Pi",
				"Jing",
				"Fang",
				"Yang",
				"Yin",
				"Zhen",
				"Jie",
				"Cheng",
				"E",
				"Qu",
				"Di",
				"Zu",
				"Zuo",
				"Dian",
				"Ling",
				"A",
				"Tuo",
				"Tuo",
				"Po",
				"Bing",
				"Fu",
				"Ji",
				"Lu",
				"Long",
				"Chen",
				"Xing",
				"Duo",
				"Lou",
				"Mo",
				"Jiang",
				"Shu",
				"Duo",
				"Xian",
				"Er",
				"Gui",
				"Yu",
				"Gai",
				"Shan",
				"Xun",
				"Qiao",
				"Xing",
				"Chun",
				"Fu",
				"Bi",
				"Xia",
				"Shan",
				"Sheng",
				"Zhi",
				"Pu",
				"Dou",
				"Yuan",
				"Zhen",
				"Chu",
				"Xian",
				"Tou",
				"Nie",
				"Yun",
				"Xian",
				"Pei",
				"Pei",
				"Zou",
				"Yi",
				"Dui",
				"Lun",
				"Yin",
				"Ju",
				"Chui",
				"Chen",
				"Pi",
				"Ling",
				"Tao",
				"Xian",
				"Lu",
				"Sheng",
				"Xian",
				"Yin",
				"Zhu",
				"Yang",
				"Reng",
				"Shan",
				"Chong",
				"Yan",
				"Yin",
				"Yu",
				"Ti",
				"Yu",
				"Long",
				"Wei",
				"Wei",
				"Nie",
				"Dui",
				"Sui",
				"An",
				"Huang",
				"Jie",
				"Sui",
				"Yin",
				"Gai",
				"Yan",
				"Hui",
				"Ge",
				"Yun",
				"Wu",
				"Wei",
				"Ai",
				"Xi",
				"Tang",
				"Ji",
				"Zhang",
				"Dao",
				"Ao",
				"Xi",
				"Yin",
				,
				"Rao",
				"Lin",
				"Tui",
				"Deng",
				"Pi",
				"Sui",
				"Sui",
				"Yu",
				"Xian",
				"Fen",
				"Ni",
				"Er",
				"Ji",
				"Dao",
				"Xi",
				"Yin",
				"E",
				"Hui",
				"Long",
				"Xi",
				"Li",
				"Li",
				"Li",
				"Zhui",
				"He",
				"Zhi",
				"Zhun",
				"Jun",
				"Nan",
				"Yi",
				"Que",
				"Yan",
				"Qian",
				"Ya",
				"Xiong",
				"Ya",
				"Ji",
				"Gu",
				"Huan",
				"Zhi",
				"Gou",
				"Jun",
				"Ci",
				"Yong",
				"Ju",
				"Chu",
				"Hu",
				"Za",
				"Luo",
				"Yu",
				"Chou",
				"Diao",
				"Sui",
				"Han",
				"Huo",
				"Shuang",
				"Guan",
				"Chu",
				"Za",
				"Yong",
				"Ji",
				"Xi",
				"Chou",
				"Liu",
				"Li",
				"Nan",
				"Xue",
				"Za",
				"Ji",
				"Ji",
				"Yu",
				"Yu",
				"Xue",
				"Na",
				"Fou",
				"Se",
				"Mu",
				"Wen",
				"Fen",
				"Pang",
				"Yun",
				"Li",
				"Li",
				"Ang",
				"Ling",
				"Lei",
				"An",
				"Bao",
				"Meng",
				"Dian",
				"Dang",
				"Xing",
				"Wu",
				"Zhao"
			],
			[
				"Xu",
				"Ji",
				"Mu",
				"Chen",
				"Xiao",
				"Zha",
				"Ting",
				"Zhen",
				"Pei",
				"Mei",
				"Ling",
				"Qi",
				"Chou",
				"Huo",
				"Sha",
				"Fei",
				"Weng",
				"Zhan",
				"Yin",
				"Ni",
				"Chou",
				"Tun",
				"Lin",
				,
				"Dong",
				"Ying",
				"Wu",
				"Ling",
				"Shuang",
				"Ling",
				"Xia",
				"Hong",
				"Yin",
				"Mo",
				"Mai",
				"Yun",
				"Liu",
				"Meng",
				"Bin",
				"Wu",
				"Wei",
				"Huo",
				"Yin",
				"Xi",
				"Yi",
				"Ai",
				"Dan",
				"Deng",
				"Xian",
				"Yu",
				"Lu",
				"Long",
				"Dai",
				"Ji",
				"Pang",
				"Yang",
				"Ba",
				"Pi",
				"Wei",
				,
				"Xi",
				"Ji",
				"Mai",
				"Meng",
				"Meng",
				"Lei",
				"Li",
				"Huo",
				"Ai",
				"Fei",
				"Dai",
				"Long",
				"Ling",
				"Ai",
				"Feng",
				"Li",
				"Bao",
				,
				"He",
				"He",
				"Bing",
				"Qing",
				"Qing",
				"Jing",
				"Tian",
				"Zhen",
				"Jing",
				"Cheng",
				"Qing",
				"Jing",
				"Jing",
				"Dian",
				"Jing",
				"Tian",
				"Fei",
				"Fei",
				"Kao",
				"Mi",
				"Mian",
				"Mian",
				"Pao",
				"Ye",
				"Tian",
				"Hui",
				"Ye",
				"Ge",
				"Ding",
				"Cha",
				"Jian",
				"Ren",
				"Di",
				"Du",
				"Wu",
				"Ren",
				"Qin",
				"Jin",
				"Xue",
				"Niu",
				"Ba",
				"Yin",
				"Sa",
				"Na",
				"Mo",
				"Zu",
				"Da",
				"Ban",
				"Yi",
				"Yao",
				"Tao",
				"Tuo",
				"Jia",
				"Hong",
				"Pao",
				"Yang",
				"Tomo",
				"Yin",
				"Jia",
				"Tao",
				"Ji",
				"Xie",
				"An",
				"An",
				"Hen",
				"Gong",
				"Kohaze",
				"Da",
				"Qiao",
				"Ting",
				"Wan",
				"Ying",
				"Sui",
				"Tiao",
				"Qiao",
				"Xuan",
				"Kong",
				"Beng",
				"Ta",
				"Zhang",
				"Bing",
				"Kuo",
				"Ju",
				"La",
				"Xie",
				"Rou",
				"Bang",
				"Yi",
				"Qiu",
				"Qiu",
				"He",
				"Xiao",
				"Mu",
				"Ju",
				"Jian",
				"Bian",
				"Di",
				"Jian",
				"On",
				"Tao",
				"Gou",
				"Ta",
				"Bei",
				"Xie",
				"Pan",
				"Ge",
				"Bi",
				"Kuo",
				"Tang",
				"Lou",
				"Gui",
				"Qiao",
				"Xue",
				"Ji",
				"Jian",
				"Jiang",
				"Chan",
				"Da",
				"Huo",
				"Xian",
				"Qian",
				"Du",
				"Wa",
				"Jian",
				"Lan",
				"Wei",
				"Ren",
				"Fu",
				"Mei",
				"Juan",
				"Ge",
				"Wei",
				"Qiao",
				"Han",
				"Chang",
				,
				"Rou",
				"Xun",
				"She",
				"Wei",
				"Ge",
				"Bei",
				"Tao",
				"Gou",
				"Yun",
				,
				"Bi",
				"Wei",
				"Hui",
				"Du",
				"Wa",
				"Du",
				"Wei",
				"Ren",
				"Fu",
				"Han",
				"Wei",
				"Yun",
				"Tao",
				"Jiu",
				"Jiu",
				"Xian",
				"Xie",
				"Xian",
				"Ji",
				"Yin",
				"Za",
				"Yun",
				"Shao",
				"Le",
				"Peng",
				"Heng",
				"Ying",
				"Yun",
				"Peng",
				"Yin",
				"Yin",
				"Xiang"
			],
			[
				"Hu",
				"Ye",
				"Ding",
				"Qing",
				"Pan",
				"Xiang",
				"Shun",
				"Han",
				"Xu",
				"Yi",
				"Xu",
				"Gu",
				"Song",
				"Kui",
				"Qi",
				"Hang",
				"Yu",
				"Wan",
				"Ban",
				"Dun",
				"Di",
				"Dan",
				"Pan",
				"Po",
				"Ling",
				"Ce",
				"Jing",
				"Lei",
				"He",
				"Qiao",
				"E",
				"E",
				"Wei",
				"Jie",
				"Gua",
				"Shen",
				"Yi",
				"Shen",
				"Hai",
				"Dui",
				"Pian",
				"Ping",
				"Lei",
				"Fu",
				"Jia",
				"Tou",
				"Hui",
				"Kui",
				"Jia",
				"Le",
				"Tian",
				"Cheng",
				"Ying",
				"Jun",
				"Hu",
				"Han",
				"Jing",
				"Tui",
				"Tui",
				"Pin",
				"Lai",
				"Tui",
				"Zi",
				"Zi",
				"Chui",
				"Ding",
				"Lai",
				"Yan",
				"Han",
				"Jian",
				"Ke",
				"Cui",
				"Jiong",
				"Qin",
				"Yi",
				"Sai",
				"Ti",
				"E",
				"E",
				"Yan",
				"Hun",
				"Kan",
				"Yong",
				"Zhuan",
				"Yan",
				"Xian",
				"Xin",
				"Yi",
				"Yuan",
				"Sang",
				"Dian",
				"Dian",
				"Jiang",
				"Ku",
				"Lei",
				"Liao",
				"Piao",
				"Yi",
				"Man",
				"Qi",
				"Rao",
				"Hao",
				"Qiao",
				"Gu",
				"Xun",
				"Qian",
				"Hui",
				"Zhan",
				"Ru",
				"Hong",
				"Bin",
				"Xian",
				"Pin",
				"Lu",
				"Lan",
				"Nie",
				"Quan",
				"Ye",
				"Ding",
				"Qing",
				"Han",
				"Xiang",
				"Shun",
				"Xu",
				"Xu",
				"Wan",
				"Gu",
				"Dun",
				"Qi",
				"Ban",
				"Song",
				"Hang",
				"Yu",
				"Lu",
				"Ling",
				"Po",
				"Jing",
				"Jie",
				"Jia",
				"Tian",
				"Han",
				"Ying",
				"Jiong",
				"Hai",
				"Yi",
				"Pin",
				"Hui",
				"Tui",
				"Han",
				"Ying",
				"Ying",
				"Ke",
				"Ti",
				"Yong",
				"E",
				"Zhuan",
				"Yan",
				"E",
				"Nie",
				"Man",
				"Dian",
				"Sang",
				"Hao",
				"Lei",
				"Zhan",
				"Ru",
				"Pin",
				"Quan",
				"Feng",
				"Biao",
				"Oroshi",
				"Fu",
				"Xia",
				"Zhan",
				"Biao",
				"Sa",
				"Ba",
				"Tai",
				"Lie",
				"Gua",
				"Xuan",
				"Shao",
				"Ju",
				"Bi",
				"Si",
				"Wei",
				"Yang",
				"Yao",
				"Sou",
				"Kai",
				"Sao",
				"Fan",
				"Liu",
				"Xi",
				"Liao",
				"Piao",
				"Piao",
				"Liu",
				"Biao",
				"Biao",
				"Biao",
				"Liao",
				,
				"Se",
				"Feng",
				"Biao",
				"Feng",
				"Yang",
				"Zhan",
				"Biao",
				"Sa",
				"Ju",
				"Si",
				"Sou",
				"Yao",
				"Liu",
				"Piao",
				"Biao",
				"Biao",
				"Fei",
				"Fan",
				"Fei",
				"Fei",
				"Shi",
				"Shi",
				"Can",
				"Ji",
				"Ding",
				"Si",
				"Tuo",
				"Zhan",
				"Sun",
				"Xiang",
				"Tun",
				"Ren",
				"Yu",
				"Juan",
				"Chi",
				"Yin",
				"Fan",
				"Fan",
				"Sun",
				"Yin",
				"Zhu",
				"Yi",
				"Zhai",
				"Bi",
				"Jie",
				"Tao",
				"Liu",
				"Ci",
				"Tie",
				"Si",
				"Bao",
				"Shi",
				"Duo"
			],
			[
				"Hai",
				"Ren",
				"Tian",
				"Jiao",
				"Jia",
				"Bing",
				"Yao",
				"Tong",
				"Ci",
				"Xiang",
				"Yang",
				"Yang",
				"Er",
				"Yan",
				"Le",
				"Yi",
				"Can",
				"Bo",
				"Nei",
				"E",
				"Bu",
				"Jun",
				"Dou",
				"Su",
				"Yu",
				"Shi",
				"Yao",
				"Hun",
				"Guo",
				"Shi",
				"Jian",
				"Zhui",
				"Bing",
				"Xian",
				"Bu",
				"Ye",
				"Tan",
				"Fei",
				"Zhang",
				"Wei",
				"Guan",
				"E",
				"Nuan",
				"Hun",
				"Hu",
				"Huang",
				"Tie",
				"Hui",
				"Jian",
				"Hou",
				"He",
				"Xing",
				"Fen",
				"Wei",
				"Gu",
				"Cha",
				"Song",
				"Tang",
				"Bo",
				"Gao",
				"Xi",
				"Kui",
				"Liu",
				"Sou",
				"Tao",
				"Ye",
				"Yun",
				"Mo",
				"Tang",
				"Man",
				"Bi",
				"Yu",
				"Xiu",
				"Jin",
				"San",
				"Kui",
				"Zhuan",
				"Shan",
				"Chi",
				"Dan",
				"Yi",
				"Ji",
				"Rao",
				"Cheng",
				"Yong",
				"Tao",
				"Hui",
				"Xiang",
				"Zhan",
				"Fen",
				"Hai",
				"Meng",
				"Yan",
				"Mo",
				"Chan",
				"Xiang",
				"Luo",
				"Zuan",
				"Nang",
				"Shi",
				"Ding",
				"Ji",
				"Tuo",
				"Xing",
				"Tun",
				"Xi",
				"Ren",
				"Yu",
				"Chi",
				"Fan",
				"Yin",
				"Jian",
				"Shi",
				"Bao",
				"Si",
				"Duo",
				"Yi",
				"Er",
				"Rao",
				"Xiang",
				"Jia",
				"Le",
				"Jiao",
				"Yi",
				"Bing",
				"Bo",
				"Dou",
				"E",
				"Yu",
				"Nei",
				"Jun",
				"Guo",
				"Hun",
				"Xian",
				"Guan",
				"Cha",
				"Kui",
				"Gu",
				"Sou",
				"Chan",
				"Ye",
				"Mo",
				"Bo",
				"Liu",
				"Xiu",
				"Jin",
				"Man",
				"San",
				"Zhuan",
				"Nang",
				"Shou",
				"Kui",
				"Guo",
				"Xiang",
				"Fen",
				"Ba",
				"Ni",
				"Bi",
				"Bo",
				"Tu",
				"Han",
				"Fei",
				"Jian",
				"An",
				"Ai",
				"Fu",
				"Xian",
				"Wen",
				"Xin",
				"Fen",
				"Bin",
				"Xing",
				"Ma",
				"Yu",
				"Feng",
				"Han",
				"Di",
				"Tuo",
				"Tuo",
				"Chi",
				"Xun",
				"Zhu",
				"Zhi",
				"Pei",
				"Xin",
				"Ri",
				"Sa",
				"Yin",
				"Wen",
				"Zhi",
				"Dan",
				"Lu",
				"You",
				"Bo",
				"Bao",
				"Kuai",
				"Tuo",
				"Yi",
				"Qu",
				,
				"Qu",
				"Jiong",
				"Bo",
				"Zhao",
				"Yuan",
				"Peng",
				"Zhou",
				"Ju",
				"Zhu",
				"Nu",
				"Ju",
				"Pi",
				"Zang",
				"Jia",
				"Ling",
				"Zhen",
				"Tai",
				"Fu",
				"Yang",
				"Shi",
				"Bi",
				"Tuo",
				"Tuo",
				"Si",
				"Liu",
				"Ma",
				"Pian",
				"Tao",
				"Zhi",
				"Rong",
				"Teng",
				"Dong",
				"Xun",
				"Quan",
				"Shen",
				"Jiong",
				"Er",
				"Hai",
				"Bo",
				"Zhu",
				"Yin",
				"Luo",
				"Shuu",
				"Dan",
				"Xie",
				"Liu",
				"Ju",
				"Song",
				"Qin",
				"Mang",
				"Liang",
				"Han",
				"Tu",
				"Xuan",
				"Tui",
				"Jun"
			],
			[
				"E",
				"Cheng",
				"Xin",
				"Ai",
				"Lu",
				"Zhui",
				"Zhou",
				"She",
				"Pian",
				"Kun",
				"Tao",
				"Lai",
				"Zong",
				"Ke",
				"Qi",
				"Qi",
				"Yan",
				"Fei",
				"Sao",
				"Yan",
				"Jie",
				"Yao",
				"Wu",
				"Pian",
				"Cong",
				"Pian",
				"Qian",
				"Fei",
				"Huang",
				"Jian",
				"Huo",
				"Yu",
				"Ti",
				"Quan",
				"Xia",
				"Zong",
				"Kui",
				"Rou",
				"Si",
				"Gua",
				"Tuo",
				"Kui",
				"Sou",
				"Qian",
				"Cheng",
				"Zhi",
				"Liu",
				"Pang",
				"Teng",
				"Xi",
				"Cao",
				"Du",
				"Yan",
				"Yuan",
				"Zou",
				"Sao",
				"Shan",
				"Li",
				"Zhi",
				"Shuang",
				"Lu",
				"Xi",
				"Luo",
				"Zhang",
				"Mo",
				"Ao",
				"Can",
				"Piao",
				"Cong",
				"Qu",
				"Bi",
				"Zhi",
				"Yu",
				"Xu",
				"Hua",
				"Bo",
				"Su",
				"Xiao",
				"Lin",
				"Chan",
				"Dun",
				"Liu",
				"Tuo",
				"Zeng",
				"Tan",
				"Jiao",
				"Tie",
				"Yan",
				"Luo",
				"Zhan",
				"Jing",
				"Yi",
				"Ye",
				"Tuo",
				"Bin",
				"Zou",
				"Yan",
				"Peng",
				"Lu",
				"Teng",
				"Xiang",
				"Ji",
				"Shuang",
				"Ju",
				"Xi",
				"Huan",
				"Li",
				"Biao",
				"Ma",
				"Yu",
				"Tuo",
				"Xun",
				"Chi",
				"Qu",
				"Ri",
				"Bo",
				"Lu",
				"Zang",
				"Shi",
				"Si",
				"Fu",
				"Ju",
				"Zou",
				"Zhu",
				"Tuo",
				"Nu",
				"Jia",
				"Yi",
				"Tai",
				"Xiao",
				"Ma",
				"Yin",
				"Jiao",
				"Hua",
				"Luo",
				"Hai",
				"Pian",
				"Biao",
				"Li",
				"Cheng",
				"Yan",
				"Xin",
				"Qin",
				"Jun",
				"Qi",
				"Qi",
				"Ke",
				"Zhui",
				"Zong",
				"Su",
				"Can",
				"Pian",
				"Zhi",
				"Kui",
				"Sao",
				"Wu",
				"Ao",
				"Liu",
				"Qian",
				"Shan",
				"Piao",
				"Luo",
				"Cong",
				"Chan",
				"Zou",
				"Ji",
				"Shuang",
				"Xiang",
				"Gu",
				"Wei",
				"Wei",
				"Wei",
				"Yu",
				"Gan",
				"Yi",
				"Ang",
				"Tou",
				"Xie",
				"Bao",
				"Bi",
				"Chi",
				"Ti",
				"Di",
				"Ku",
				"Hai",
				"Qiao",
				"Gou",
				"Kua",
				"Ge",
				"Tui",
				"Geng",
				"Pian",
				"Bi",
				"Ke",
				"Ka",
				"Yu",
				"Sui",
				"Lou",
				"Bo",
				"Xiao",
				"Pang",
				"Bo",
				"Ci",
				"Kuan",
				"Bin",
				"Mo",
				"Liao",
				"Lou",
				"Nao",
				"Du",
				"Zang",
				"Sui",
				"Ti",
				"Bin",
				"Kuan",
				"Lu",
				"Gao",
				"Gao",
				"Qiao",
				"Kao",
				"Qiao",
				"Lao",
				"Zao",
				"Biao",
				"Kun",
				"Kun",
				"Ti",
				"Fang",
				"Xiu",
				"Ran",
				"Mao",
				"Dan",
				"Kun",
				"Bin",
				"Fa",
				"Tiao",
				"Peng",
				"Zi",
				"Fa",
				"Ran",
				"Ti",
				"Pao",
				"Pi",
				"Mao",
				"Fu",
				"Er",
				"Rong",
				"Qu",
				"Gong",
				"Xiu",
				"Gua",
				"Ji",
				"Peng",
				"Zhua",
				"Shao",
				"Sha"
			],
			[
				"Ti",
				"Li",
				"Bin",
				"Zong",
				"Ti",
				"Peng",
				"Song",
				"Zheng",
				"Quan",
				"Zong",
				"Shun",
				"Jian",
				"Duo",
				"Hu",
				"La",
				"Jiu",
				"Qi",
				"Lian",
				"Zhen",
				"Bin",
				"Peng",
				"Mo",
				"San",
				"Man",
				"Man",
				"Seng",
				"Xu",
				"Lie",
				"Qian",
				"Qian",
				"Nong",
				"Huan",
				"Kuai",
				"Ning",
				"Bin",
				"Lie",
				"Rang",
				"Dou",
				"Dou",
				"Nao",
				"Hong",
				"Xi",
				"Dou",
				"Han",
				"Dou",
				"Dou",
				"Jiu",
				"Chang",
				"Yu",
				"Yu",
				"Li",
				"Juan",
				"Fu",
				"Qian",
				"Gui",
				"Zong",
				"Liu",
				"Gui",
				"Shang",
				"Yu",
				"Gui",
				"Mei",
				"Ji",
				"Qi",
				"Jie",
				"Kui",
				"Hun",
				"Ba",
				"Po",
				"Mei",
				"Xu",
				"Yan",
				"Xiao",
				"Liang",
				"Yu",
				"Tui",
				"Qi",
				"Wang",
				"Liang",
				"Wei",
				"Jian",
				"Chi",
				"Piao",
				"Bi",
				"Mo",
				"Ji",
				"Xu",
				"Chou",
				"Yan",
				"Zhan",
				"Yu",
				"Dao",
				"Ren",
				"Ji",
				"Eri",
				"Gong",
				"Tuo",
				"Diao",
				"Ji",
				"Xu",
				"E",
				"E",
				"Sha",
				"Hang",
				"Tun",
				"Mo",
				"Jie",
				"Shen",
				"Fan",
				"Yuan",
				"Bi",
				"Lu",
				"Wen",
				"Hu",
				"Lu",
				"Za",
				"Fang",
				"Fen",
				"Na",
				"You",
				"Namazu",
				"Todo",
				"He",
				"Xia",
				"Qu",
				"Han",
				"Pi",
				"Ling",
				"Tuo",
				"Bo",
				"Qiu",
				"Ping",
				"Fu",
				"Bi",
				"Ji",
				"Wei",
				"Ju",
				"Diao",
				"Bo",
				"You",
				"Gun",
				"Pi",
				"Nian",
				"Xing",
				"Tai",
				"Bao",
				"Fu",
				"Zha",
				"Ju",
				"Gu",
				"Kajika",
				"Tong",
				,
				"Ta",
				"Jie",
				"Shu",
				"Hou",
				"Xiang",
				"Er",
				"An",
				"Wei",
				"Tiao",
				"Zhu",
				"Yin",
				"Lie",
				"Luo",
				"Tong",
				"Yi",
				"Qi",
				"Bing",
				"Wei",
				"Jiao",
				"Bu",
				"Gui",
				"Xian",
				"Ge",
				"Hui",
				"Bora",
				"Mate",
				"Kao",
				"Gori",
				"Duo",
				"Jun",
				"Ti",
				"Man",
				"Xiao",
				"Za",
				"Sha",
				"Qin",
				"Yu",
				"Nei",
				"Zhe",
				"Gun",
				"Geng",
				"Su",
				"Wu",
				"Qiu",
				"Ting",
				"Fu",
				"Wan",
				"You",
				"Li",
				"Sha",
				"Sha",
				"Gao",
				"Meng",
				"Ugui",
				"Asari",
				"Subashiri",
				"Kazunoko",
				"Yong",
				"Ni",
				"Zi",
				"Qi",
				"Qing",
				"Xiang",
				"Nei",
				"Chun",
				"Ji",
				"Diao",
				"Qie",
				"Gu",
				"Zhou",
				"Dong",
				"Lai",
				"Fei",
				"Ni",
				"Yi",
				"Kun",
				"Lu",
				"Jiu",
				"Chang",
				"Jing",
				"Lun",
				"Ling",
				"Zou",
				"Li",
				"Meng",
				"Zong",
				"Zhi",
				"Nian",
				"Shachi",
				"Dojou",
				"Sukesou",
				"Shi",
				"Shen",
				"Hun",
				"Shi",
				"Hou",
				"Xing",
				"Zhu",
				"La",
				"Zong",
				"Ji",
				"Bian",
				"Bian"
			],
			[
				"Huan",
				"Quan",
				"Ze",
				"Wei",
				"Wei",
				"Yu",
				"Qun",
				"Rou",
				"Die",
				"Huang",
				"Lian",
				"Yan",
				"Qiu",
				"Qiu",
				"Jian",
				"Bi",
				"E",
				"Yang",
				"Fu",
				"Sai",
				"Jian",
				"Xia",
				"Tuo",
				"Hu",
				"Muroaji",
				"Ruo",
				"Haraka",
				"Wen",
				"Jian",
				"Hao",
				"Wu",
				"Fang",
				"Sao",
				"Liu",
				"Ma",
				"Shi",
				"Shi",
				"Yin",
				"Z",
				"Teng",
				"Ta",
				"Yao",
				"Ge",
				"Rong",
				"Qian",
				"Qi",
				"Wen",
				"Ruo",
				"Hatahata",
				"Lian",
				"Ao",
				"Le",
				"Hui",
				"Min",
				"Ji",
				"Tiao",
				"Qu",
				"Jian",
				"Sao",
				"Man",
				"Xi",
				"Qiu",
				"Biao",
				"Ji",
				"Ji",
				"Zhu",
				"Jiang",
				"Qiu",
				"Zhuan",
				"Yong",
				"Zhang",
				"Kang",
				"Xue",
				"Bie",
				"Jue",
				"Qu",
				"Xiang",
				"Bo",
				"Jiao",
				"Xun",
				"Su",
				"Huang",
				"Zun",
				"Shan",
				"Shan",
				"Fan",
				"Jue",
				"Lin",
				"Xun",
				"Miao",
				"Xi",
				"Eso",
				"Kyou",
				"Fen",
				"Guan",
				"Hou",
				"Kuai",
				"Zei",
				"Sao",
				"Zhan",
				"Gan",
				"Gui",
				"Sheng",
				"Li",
				"Chang",
				"Hatahata",
				"Shiira",
				"Mutsu",
				"Ru",
				"Ji",
				"Xu",
				"Huo",
				"Shiira",
				"Li",
				"Lie",
				"Li",
				"Mie",
				"Zhen",
				"Xiang",
				"E",
				"Lu",
				"Guan",
				"Li",
				"Xian",
				"Yu",
				"Dao",
				"Ji",
				"You",
				"Tun",
				"Lu",
				"Fang",
				"Ba",
				"He",
				"Bo",
				"Ping",
				"Nian",
				"Lu",
				"You",
				"Zha",
				"Fu",
				"Bo",
				"Bao",
				"Hou",
				"Pi",
				"Tai",
				"Gui",
				"Jie",
				"Kao",
				"Wei",
				"Er",
				"Tong",
				"Ze",
				"Hou",
				"Kuai",
				"Ji",
				"Jiao",
				"Xian",
				"Za",
				"Xiang",
				"Xun",
				"Geng",
				"Li",
				"Lian",
				"Jian",
				"Li",
				"Shi",
				"Tiao",
				"Gun",
				"Sha",
				"Wan",
				"Jun",
				"Ji",
				"Yong",
				"Qing",
				"Ling",
				"Qi",
				"Zou",
				"Fei",
				"Kun",
				"Chang",
				"Gu",
				"Ni",
				"Nian",
				"Diao",
				"Jing",
				"Shen",
				"Shi",
				"Zi",
				"Fen",
				"Die",
				"Bi",
				"Chang",
				"Shi",
				"Wen",
				"Wei",
				"Sai",
				"E",
				"Qiu",
				"Fu",
				"Huang",
				"Quan",
				"Jiang",
				"Bian",
				"Sao",
				"Ao",
				"Qi",
				"Ta",
				"Yin",
				"Yao",
				"Fang",
				"Jian",
				"Le",
				"Biao",
				"Xue",
				"Bie",
				"Man",
				"Min",
				"Yong",
				"Wei",
				"Xi",
				"Jue",
				"Shan",
				"Lin",
				"Zun",
				"Huo",
				"Gan",
				"Li",
				"Zhan",
				"Guan",
				"Niao",
				"Yi",
				"Fu",
				"Li",
				"Jiu",
				"Bu",
				"Yan",
				"Fu",
				"Diao",
				"Ji",
				"Feng",
				"Nio",
				"Gan",
				"Shi",
				"Feng",
				"Ming",
				"Bao",
				"Yuan",
				"Zhi",
				"Hu",
				"Qin",
				"Fu",
				"Fen",
				"Wen",
				"Jian",
				"Shi",
				"Yu"
			],
			[
				"Fou",
				"Yiao",
				"Jue",
				"Jue",
				"Pi",
				"Huan",
				"Zhen",
				"Bao",
				"Yan",
				"Ya",
				"Zheng",
				"Fang",
				"Feng",
				"Wen",
				"Ou",
				"Te",
				"Jia",
				"Nu",
				"Ling",
				"Mie",
				"Fu",
				"Tuo",
				"Wen",
				"Li",
				"Bian",
				"Zhi",
				"Ge",
				"Yuan",
				"Zi",
				"Qu",
				"Xiao",
				"Zhi",
				"Dan",
				"Ju",
				"You",
				"Gu",
				"Zhong",
				"Yu",
				"Yang",
				"Rong",
				"Ya",
				"Tie",
				"Yu",
				"Shigi",
				"Ying",
				"Zhui",
				"Wu",
				"Er",
				"Gua",
				"Ai",
				"Zhi",
				"Yan",
				"Heng",
				"Jiao",
				"Ji",
				"Lie",
				"Zhu",
				"Ren",
				"Yi",
				"Hong",
				"Luo",
				"Ru",
				"Mou",
				"Ge",
				"Ren",
				"Jiao",
				"Xiu",
				"Zhou",
				"Zhi",
				"Luo",
				"Chidori",
				"Toki",
				"Ten",
				"Luan",
				"Jia",
				"Ji",
				"Yu",
				"Huan",
				"Tuo",
				"Bu",
				"Wu",
				"Juan",
				"Yu",
				"Bo",
				"Xun",
				"Xun",
				"Bi",
				"Xi",
				"Jun",
				"Ju",
				"Tu",
				"Jing",
				"Ti",
				"E",
				"E",
				"Kuang",
				"Hu",
				"Wu",
				"Shen",
				"Lai",
				"Ikaruga",
				"Kakesu",
				"Lu",
				"Ping",
				"Shu",
				"Fu",
				"An",
				"Zhao",
				"Peng",
				"Qin",
				"Qian",
				"Bei",
				"Diao",
				"Lu",
				"Que",
				"Jian",
				"Ju",
				"Tu",
				"Ya",
				"Yuan",
				"Qi",
				"Li",
				"Ye",
				"Zhui",
				"Kong",
				"Zhui",
				"Kun",
				"Sheng",
				"Qi",
				"Jing",
				"Yi",
				"Yi",
				"Jing",
				"Zi",
				"Lai",
				"Dong",
				"Qi",
				"Chun",
				"Geng",
				"Ju",
				"Qu",
				"Isuka",
				"Kikuitadaki",
				"Ji",
				"Shu",
				,
				"Chi",
				"Miao",
				"Rou",
				"An",
				"Qiu",
				"Ti",
				"Hu",
				"Ti",
				"E",
				"Jie",
				"Mao",
				"Fu",
				"Chun",
				"Tu",
				"Yan",
				"He",
				"Yuan",
				"Pian",
				"Yun",
				"Mei",
				"Hu",
				"Ying",
				"Dun",
				"Mu",
				"Ju",
				"Tsugumi",
				"Cang",
				"Fang",
				"Gu",
				"Ying",
				"Yuan",
				"Xuan",
				"Weng",
				"Shi",
				"He",
				"Chu",
				"Tang",
				"Xia",
				"Ruo",
				"Liu",
				"Ji",
				"Gu",
				"Jian",
				"Zhun",
				"Han",
				"Zi",
				"Zi",
				"Ni",
				"Yao",
				"Yan",
				"Ji",
				"Li",
				"Tian",
				"Kou",
				"Ti",
				"Ti",
				"Ni",
				"Tu",
				"Ma",
				"Jiao",
				"Gao",
				"Tian",
				"Chen",
				"Li",
				"Zhuan",
				"Zhe",
				"Ao",
				"Yao",
				"Yi",
				"Ou",
				"Chi",
				"Zhi",
				"Liao",
				"Rong",
				"Lou",
				"Bi",
				"Shuang",
				"Zhuo",
				"Yu",
				"Wu",
				"Jue",
				"Yin",
				"Quan",
				"Si",
				"Jiao",
				"Yi",
				"Hua",
				"Bi",
				"Ying",
				"Su",
				"Huang",
				"Fan",
				"Jiao",
				"Liao",
				"Yan",
				"Kao",
				"Jiu",
				"Xian",
				"Xian",
				"Tu",
				"Mai",
				"Zun",
				"Yu",
				"Ying",
				"Lu",
				"Tuan",
				"Xian",
				"Xue",
				"Yi",
				"Pi"
			],
			[
				"Shu",
				"Luo",
				"Qi",
				"Yi",
				"Ji",
				"Zhe",
				"Yu",
				"Zhan",
				"Ye",
				"Yang",
				"Pi",
				"Ning",
				"Huo",
				"Mi",
				"Ying",
				"Meng",
				"Di",
				"Yue",
				"Yu",
				"Lei",
				"Bao",
				"Lu",
				"He",
				"Long",
				"Shuang",
				"Yue",
				"Ying",
				"Guan",
				"Qu",
				"Li",
				"Luan",
				"Niao",
				"Jiu",
				"Ji",
				"Yuan",
				"Ming",
				"Shi",
				"Ou",
				"Ya",
				"Cang",
				"Bao",
				"Zhen",
				"Gu",
				"Dong",
				"Lu",
				"Ya",
				"Xiao",
				"Yang",
				"Ling",
				"Zhi",
				"Qu",
				"Yuan",
				"Xue",
				"Tuo",
				"Si",
				"Zhi",
				"Er",
				"Gua",
				"Xiu",
				"Heng",
				"Zhou",
				"Ge",
				"Luan",
				"Hong",
				"Wu",
				"Bo",
				"Li",
				"Juan",
				"Hu",
				"E",
				"Yu",
				"Xian",
				"Ti",
				"Wu",
				"Que",
				"Miao",
				"An",
				"Kun",
				"Bei",
				"Peng",
				"Qian",
				"Chun",
				"Geng",
				"Yuan",
				"Su",
				"Hu",
				"He",
				"E",
				"Gu",
				"Qiu",
				"Zi",
				"Mei",
				"Mu",
				"Ni",
				"Yao",
				"Weng",
				"Liu",
				"Ji",
				"Ni",
				"Jian",
				"He",
				"Yi",
				"Ying",
				"Zhe",
				"Liao",
				"Liao",
				"Jiao",
				"Jiu",
				"Yu",
				"Lu",
				"Xuan",
				"Zhan",
				"Ying",
				"Huo",
				"Meng",
				"Guan",
				"Shuang",
				"Lu",
				"Jin",
				"Ling",
				"Jian",
				"Xian",
				"Cuo",
				"Jian",
				"Jian",
				"Yan",
				"Cuo",
				"Lu",
				"You",
				"Cu",
				"Ji",
				"Biao",
				"Cu",
				"Biao",
				"Zhu",
				"Jun",
				"Zhu",
				"Jian",
				"Mi",
				"Mi",
				"Wu",
				"Liu",
				"Chen",
				"Jun",
				"Lin",
				"Ni",
				"Qi",
				"Lu",
				"Jiu",
				"Jun",
				"Jing",
				"Li",
				"Xiang",
				"Yan",
				"Jia",
				"Mi",
				"Li",
				"She",
				"Zhang",
				"Lin",
				"Jing",
				"Ji",
				"Ling",
				"Yan",
				"Cu",
				"Mai",
				"Mai",
				"Ge",
				"Chao",
				"Fu",
				"Mian",
				"Mian",
				"Fu",
				"Pao",
				"Qu",
				"Qu",
				"Mou",
				"Fu",
				"Xian",
				"Lai",
				"Qu",
				"Mian",
				,
				"Feng",
				"Fu",
				"Qu",
				"Mian",
				"Ma",
				"Mo",
				"Mo",
				"Hui",
				"Ma",
				"Zou",
				"Nen",
				"Fen",
				"Huang",
				"Huang",
				"Jin",
				"Guang",
				"Tian",
				"Tou",
				"Heng",
				"Xi",
				"Kuang",
				"Heng",
				"Shu",
				"Li",
				"Nian",
				"Chi",
				"Hei",
				"Hei",
				"Yi",
				"Qian",
				"Dan",
				"Xi",
				"Tuan",
				"Mo",
				"Mo",
				"Qian",
				"Dai",
				"Chu",
				"You",
				"Dian",
				"Yi",
				"Xia",
				"Yan",
				"Qu",
				"Mei",
				"Yan",
				"Jing",
				"Yu",
				"Li",
				"Dang",
				"Du",
				"Can",
				"Yin",
				"An",
				"Yan",
				"Tan",
				"An",
				"Zhen",
				"Dai",
				"Can",
				"Yi",
				"Mei",
				"Dan",
				"Yan",
				"Du",
				"Lu",
				"Zhi",
				"Fen",
				"Fu",
				"Fu",
				"Min",
				"Min",
				"Yuan"
			],
			[
				"Cu",
				"Qu",
				"Chao",
				"Wa",
				"Zhu",
				"Zhi",
				"Mang",
				"Ao",
				"Bie",
				"Tuo",
				"Bi",
				"Yuan",
				"Chao",
				"Tuo",
				"Ding",
				"Mi",
				"Nai",
				"Ding",
				"Zi",
				"Gu",
				"Gu",
				"Dong",
				"Fen",
				"Tao",
				"Yuan",
				"Pi",
				"Chang",
				"Gao",
				"Qi",
				"Yuan",
				"Tang",
				"Teng",
				"Shu",
				"Shu",
				"Fen",
				"Fei",
				"Wen",
				"Ba",
				"Diao",
				"Tuo",
				"Tong",
				"Qu",
				"Sheng",
				"Shi",
				"You",
				"Shi",
				"Ting",
				"Wu",
				"Nian",
				"Jing",
				"Hun",
				"Ju",
				"Yan",
				"Tu",
				"Ti",
				"Xi",
				"Xian",
				"Yan",
				"Lei",
				"Bi",
				"Yao",
				"Qiu",
				"Han",
				"Wu",
				"Wu",
				"Hou",
				"Xi",
				"Ge",
				"Zha",
				"Xiu",
				"Weng",
				"Zha",
				"Nong",
				"Nang",
				"Qi",
				"Zhai",
				"Ji",
				"Zi",
				"Ji",
				"Ji",
				"Qi",
				"Ji",
				"Chi",
				"Chen",
				"Chen",
				"He",
				"Ya",
				"Ken",
				"Xie",
				"Pao",
				"Cuo",
				"Shi",
				"Zi",
				"Chi",
				"Nian",
				"Ju",
				"Tiao",
				"Ling",
				"Ling",
				"Chu",
				"Quan",
				"Xie",
				"Ken",
				"Nie",
				"Jiu",
				"Yao",
				"Chuo",
				"Kun",
				"Yu",
				"Chu",
				"Yi",
				"Ni",
				"Cuo",
				"Zou",
				"Qu",
				"Nen",
				"Xian",
				"Ou",
				"E",
				"Wo",
				"Yi",
				"Chuo",
				"Zou",
				"Dian",
				"Chu",
				"Jin",
				"Ya",
				"Chi",
				"Chen",
				"He",
				"Ken",
				"Ju",
				"Ling",
				"Pao",
				"Tiao",
				"Zi",
				"Ken",
				"Yu",
				"Chuo",
				"Qu",
				"Wo",
				"Long",
				"Pang",
				"Gong",
				"Pang",
				"Yan",
				"Long",
				"Long",
				"Gong",
				"Kan",
				"Ta",
				"Ling",
				"Ta",
				"Long",
				"Gong",
				"Kan",
				"Gui",
				"Qiu",
				"Bie",
				"Gui",
				"Yue",
				"Chui",
				"He",
				"Jue",
				"Xie",
				"Yu"
			],
			[
				"it",
				"ix",
				"i",
				"ip",
				"iet",
				"iex",
				"ie",
				"iep",
				"at",
				"ax",
				"a",
				"ap",
				"uox",
				"uo",
				"uop",
				"ot",
				"ox",
				"o",
				"op",
				"ex",
				"e",
				"wu",
				"bit",
				"bix",
				"bi",
				"bip",
				"biet",
				"biex",
				"bie",
				"biep",
				"bat",
				"bax",
				"ba",
				"bap",
				"buox",
				"buo",
				"buop",
				"bot",
				"box",
				"bo",
				"bop",
				"bex",
				"be",
				"bep",
				"but",
				"bux",
				"bu",
				"bup",
				"burx",
				"bur",
				"byt",
				"byx",
				"by",
				"byp",
				"byrx",
				"byr",
				"pit",
				"pix",
				"pi",
				"pip",
				"piex",
				"pie",
				"piep",
				"pat",
				"pax",
				"pa",
				"pap",
				"puox",
				"puo",
				"puop",
				"pot",
				"pox",
				"po",
				"pop",
				"put",
				"pux",
				"pu",
				"pup",
				"purx",
				"pur",
				"pyt",
				"pyx",
				"py",
				"pyp",
				"pyrx",
				"pyr",
				"bbit",
				"bbix",
				"bbi",
				"bbip",
				"bbiet",
				"bbiex",
				"bbie",
				"bbiep",
				"bbat",
				"bbax",
				"bba",
				"bbap",
				"bbuox",
				"bbuo",
				"bbuop",
				"bbot",
				"bbox",
				"bbo",
				"bbop",
				"bbex",
				"bbe",
				"bbep",
				"bbut",
				"bbux",
				"bbu",
				"bbup",
				"bburx",
				"bbur",
				"bbyt",
				"bbyx",
				"bby",
				"bbyp",
				"nbit",
				"nbix",
				"nbi",
				"nbip",
				"nbiex",
				"nbie",
				"nbiep",
				"nbat",
				"nbax",
				"nba",
				"nbap",
				"nbot",
				"nbox",
				"nbo",
				"nbop",
				"nbut",
				"nbux",
				"nbu",
				"nbup",
				"nburx",
				"nbur",
				"nbyt",
				"nbyx",
				"nby",
				"nbyp",
				"nbyrx",
				"nbyr",
				"hmit",
				"hmix",
				"hmi",
				"hmip",
				"hmiex",
				"hmie",
				"hmiep",
				"hmat",
				"hmax",
				"hma",
				"hmap",
				"hmuox",
				"hmuo",
				"hmuop",
				"hmot",
				"hmox",
				"hmo",
				"hmop",
				"hmut",
				"hmux",
				"hmu",
				"hmup",
				"hmurx",
				"hmur",
				"hmyx",
				"hmy",
				"hmyp",
				"hmyrx",
				"hmyr",
				"mit",
				"mix",
				"mi",
				"mip",
				"miex",
				"mie",
				"miep",
				"mat",
				"max",
				"ma",
				"map",
				"muot",
				"muox",
				"muo",
				"muop",
				"mot",
				"mox",
				"mo",
				"mop",
				"mex",
				"me",
				"mut",
				"mux",
				"mu",
				"mup",
				"murx",
				"mur",
				"myt",
				"myx",
				"my",
				"myp",
				"fit",
				"fix",
				"fi",
				"fip",
				"fat",
				"fax",
				"fa",
				"fap",
				"fox",
				"fo",
				"fop",
				"fut",
				"fux",
				"fu",
				"fup",
				"furx",
				"fur",
				"fyt",
				"fyx",
				"fy",
				"fyp",
				"vit",
				"vix",
				"vi",
				"vip",
				"viet",
				"viex",
				"vie",
				"viep",
				"vat",
				"vax",
				"va",
				"vap",
				"vot",
				"vox",
				"vo",
				"vop",
				"vex",
				"vep",
				"vut",
				"vux",
				"vu",
				"vup",
				"vurx",
				"vur",
				"vyt",
				"vyx",
				"vy",
				"vyp",
				"vyrx",
				"vyr"
			],
			[
				"dit",
				"dix",
				"di",
				"dip",
				"diex",
				"die",
				"diep",
				"dat",
				"dax",
				"da",
				"dap",
				"duox",
				"duo",
				"dot",
				"dox",
				"do",
				"dop",
				"dex",
				"de",
				"dep",
				"dut",
				"dux",
				"du",
				"dup",
				"durx",
				"dur",
				"tit",
				"tix",
				"ti",
				"tip",
				"tiex",
				"tie",
				"tiep",
				"tat",
				"tax",
				"ta",
				"tap",
				"tuot",
				"tuox",
				"tuo",
				"tuop",
				"tot",
				"tox",
				"to",
				"top",
				"tex",
				"te",
				"tep",
				"tut",
				"tux",
				"tu",
				"tup",
				"turx",
				"tur",
				"ddit",
				"ddix",
				"ddi",
				"ddip",
				"ddiex",
				"ddie",
				"ddiep",
				"ddat",
				"ddax",
				"dda",
				"ddap",
				"dduox",
				"dduo",
				"dduop",
				"ddot",
				"ddox",
				"ddo",
				"ddop",
				"ddex",
				"dde",
				"ddep",
				"ddut",
				"ddux",
				"ddu",
				"ddup",
				"ddurx",
				"ddur",
				"ndit",
				"ndix",
				"ndi",
				"ndip",
				"ndiex",
				"ndie",
				"ndat",
				"ndax",
				"nda",
				"ndap",
				"ndot",
				"ndox",
				"ndo",
				"ndop",
				"ndex",
				"nde",
				"ndep",
				"ndut",
				"ndux",
				"ndu",
				"ndup",
				"ndurx",
				"ndur",
				"hnit",
				"hnix",
				"hni",
				"hnip",
				"hniet",
				"hniex",
				"hnie",
				"hniep",
				"hnat",
				"hnax",
				"hna",
				"hnap",
				"hnuox",
				"hnuo",
				"hnot",
				"hnox",
				"hnop",
				"hnex",
				"hne",
				"hnep",
				"hnut",
				"nit",
				"nix",
				"ni",
				"nip",
				"niex",
				"nie",
				"niep",
				"nax",
				"na",
				"nap",
				"nuox",
				"nuo",
				"nuop",
				"not",
				"nox",
				"no",
				"nop",
				"nex",
				"ne",
				"nep",
				"nut",
				"nux",
				"nu",
				"nup",
				"nurx",
				"nur",
				"hlit",
				"hlix",
				"hli",
				"hlip",
				"hliex",
				"hlie",
				"hliep",
				"hlat",
				"hlax",
				"hla",
				"hlap",
				"hluox",
				"hluo",
				"hluop",
				"hlox",
				"hlo",
				"hlop",
				"hlex",
				"hle",
				"hlep",
				"hlut",
				"hlux",
				"hlu",
				"hlup",
				"hlurx",
				"hlur",
				"hlyt",
				"hlyx",
				"hly",
				"hlyp",
				"hlyrx",
				"hlyr",
				"lit",
				"lix",
				"li",
				"lip",
				"liet",
				"liex",
				"lie",
				"liep",
				"lat",
				"lax",
				"la",
				"lap",
				"luot",
				"luox",
				"luo",
				"luop",
				"lot",
				"lox",
				"lo",
				"lop",
				"lex",
				"le",
				"lep",
				"lut",
				"lux",
				"lu",
				"lup",
				"lurx",
				"lur",
				"lyt",
				"lyx",
				"ly",
				"lyp",
				"lyrx",
				"lyr",
				"git",
				"gix",
				"gi",
				"gip",
				"giet",
				"giex",
				"gie",
				"giep",
				"gat",
				"gax",
				"ga",
				"gap",
				"guot",
				"guox",
				"guo",
				"guop",
				"got",
				"gox",
				"go",
				"gop",
				"get",
				"gex",
				"ge",
				"gep",
				"gut",
				"gux",
				"gu",
				"gup",
				"gurx",
				"gur",
				"kit",
				"kix",
				"ki",
				"kip",
				"kiex",
				"kie",
				"kiep",
				"kat"
			],
			[
				"kax",
				"ka",
				"kap",
				"kuox",
				"kuo",
				"kuop",
				"kot",
				"kox",
				"ko",
				"kop",
				"ket",
				"kex",
				"ke",
				"kep",
				"kut",
				"kux",
				"ku",
				"kup",
				"kurx",
				"kur",
				"ggit",
				"ggix",
				"ggi",
				"ggiex",
				"ggie",
				"ggiep",
				"ggat",
				"ggax",
				"gga",
				"ggap",
				"gguot",
				"gguox",
				"gguo",
				"gguop",
				"ggot",
				"ggox",
				"ggo",
				"ggop",
				"gget",
				"ggex",
				"gge",
				"ggep",
				"ggut",
				"ggux",
				"ggu",
				"ggup",
				"ggurx",
				"ggur",
				"mgiex",
				"mgie",
				"mgat",
				"mgax",
				"mga",
				"mgap",
				"mguox",
				"mguo",
				"mguop",
				"mgot",
				"mgox",
				"mgo",
				"mgop",
				"mgex",
				"mge",
				"mgep",
				"mgut",
				"mgux",
				"mgu",
				"mgup",
				"mgurx",
				"mgur",
				"hxit",
				"hxix",
				"hxi",
				"hxip",
				"hxiet",
				"hxiex",
				"hxie",
				"hxiep",
				"hxat",
				"hxax",
				"hxa",
				"hxap",
				"hxuot",
				"hxuox",
				"hxuo",
				"hxuop",
				"hxot",
				"hxox",
				"hxo",
				"hxop",
				"hxex",
				"hxe",
				"hxep",
				"ngiex",
				"ngie",
				"ngiep",
				"ngat",
				"ngax",
				"nga",
				"ngap",
				"nguot",
				"nguox",
				"nguo",
				"ngot",
				"ngox",
				"ngo",
				"ngop",
				"ngex",
				"nge",
				"ngep",
				"hit",
				"hiex",
				"hie",
				"hat",
				"hax",
				"ha",
				"hap",
				"huot",
				"huox",
				"huo",
				"huop",
				"hot",
				"hox",
				"ho",
				"hop",
				"hex",
				"he",
				"hep",
				"wat",
				"wax",
				"wa",
				"wap",
				"wuox",
				"wuo",
				"wuop",
				"wox",
				"wo",
				"wop",
				"wex",
				"we",
				"wep",
				"zit",
				"zix",
				"zi",
				"zip",
				"ziex",
				"zie",
				"ziep",
				"zat",
				"zax",
				"za",
				"zap",
				"zuox",
				"zuo",
				"zuop",
				"zot",
				"zox",
				"zo",
				"zop",
				"zex",
				"ze",
				"zep",
				"zut",
				"zux",
				"zu",
				"zup",
				"zurx",
				"zur",
				"zyt",
				"zyx",
				"zy",
				"zyp",
				"zyrx",
				"zyr",
				"cit",
				"cix",
				"ci",
				"cip",
				"ciet",
				"ciex",
				"cie",
				"ciep",
				"cat",
				"cax",
				"ca",
				"cap",
				"cuox",
				"cuo",
				"cuop",
				"cot",
				"cox",
				"co",
				"cop",
				"cex",
				"ce",
				"cep",
				"cut",
				"cux",
				"cu",
				"cup",
				"curx",
				"cur",
				"cyt",
				"cyx",
				"cy",
				"cyp",
				"cyrx",
				"cyr",
				"zzit",
				"zzix",
				"zzi",
				"zzip",
				"zziet",
				"zziex",
				"zzie",
				"zziep",
				"zzat",
				"zzax",
				"zza",
				"zzap",
				"zzox",
				"zzo",
				"zzop",
				"zzex",
				"zze",
				"zzep",
				"zzux",
				"zzu",
				"zzup",
				"zzurx",
				"zzur",
				"zzyt",
				"zzyx",
				"zzy",
				"zzyp",
				"zzyrx",
				"zzyr",
				"nzit",
				"nzix",
				"nzi",
				"nzip",
				"nziex",
				"nzie",
				"nziep",
				"nzat",
				"nzax",
				"nza",
				"nzap",
				"nzuox",
				"nzuo",
				"nzox",
				"nzop",
				"nzex",
				"nze",
				"nzux",
				"nzu"
			],
			[
				"nzup",
				"nzurx",
				"nzur",
				"nzyt",
				"nzyx",
				"nzy",
				"nzyp",
				"nzyrx",
				"nzyr",
				"sit",
				"six",
				"si",
				"sip",
				"siex",
				"sie",
				"siep",
				"sat",
				"sax",
				"sa",
				"sap",
				"suox",
				"suo",
				"suop",
				"sot",
				"sox",
				"so",
				"sop",
				"sex",
				"se",
				"sep",
				"sut",
				"sux",
				"su",
				"sup",
				"surx",
				"sur",
				"syt",
				"syx",
				"sy",
				"syp",
				"syrx",
				"syr",
				"ssit",
				"ssix",
				"ssi",
				"ssip",
				"ssiex",
				"ssie",
				"ssiep",
				"ssat",
				"ssax",
				"ssa",
				"ssap",
				"ssot",
				"ssox",
				"sso",
				"ssop",
				"ssex",
				"sse",
				"ssep",
				"ssut",
				"ssux",
				"ssu",
				"ssup",
				"ssyt",
				"ssyx",
				"ssy",
				"ssyp",
				"ssyrx",
				"ssyr",
				"zhat",
				"zhax",
				"zha",
				"zhap",
				"zhuox",
				"zhuo",
				"zhuop",
				"zhot",
				"zhox",
				"zho",
				"zhop",
				"zhet",
				"zhex",
				"zhe",
				"zhep",
				"zhut",
				"zhux",
				"zhu",
				"zhup",
				"zhurx",
				"zhur",
				"zhyt",
				"zhyx",
				"zhy",
				"zhyp",
				"zhyrx",
				"zhyr",
				"chat",
				"chax",
				"cha",
				"chap",
				"chuot",
				"chuox",
				"chuo",
				"chuop",
				"chot",
				"chox",
				"cho",
				"chop",
				"chet",
				"chex",
				"che",
				"chep",
				"chux",
				"chu",
				"chup",
				"churx",
				"chur",
				"chyt",
				"chyx",
				"chy",
				"chyp",
				"chyrx",
				"chyr",
				"rrax",
				"rra",
				"rruox",
				"rruo",
				"rrot",
				"rrox",
				"rro",
				"rrop",
				"rret",
				"rrex",
				"rre",
				"rrep",
				"rrut",
				"rrux",
				"rru",
				"rrup",
				"rrurx",
				"rrur",
				"rryt",
				"rryx",
				"rry",
				"rryp",
				"rryrx",
				"rryr",
				"nrat",
				"nrax",
				"nra",
				"nrap",
				"nrox",
				"nro",
				"nrop",
				"nret",
				"nrex",
				"nre",
				"nrep",
				"nrut",
				"nrux",
				"nru",
				"nrup",
				"nrurx",
				"nrur",
				"nryt",
				"nryx",
				"nry",
				"nryp",
				"nryrx",
				"nryr",
				"shat",
				"shax",
				"sha",
				"shap",
				"shuox",
				"shuo",
				"shuop",
				"shot",
				"shox",
				"sho",
				"shop",
				"shet",
				"shex",
				"she",
				"shep",
				"shut",
				"shux",
				"shu",
				"shup",
				"shurx",
				"shur",
				"shyt",
				"shyx",
				"shy",
				"shyp",
				"shyrx",
				"shyr",
				"rat",
				"rax",
				"ra",
				"rap",
				"ruox",
				"ruo",
				"ruop",
				"rot",
				"rox",
				"ro",
				"rop",
				"rex",
				"re",
				"rep",
				"rut",
				"rux",
				"ru",
				"rup",
				"rurx",
				"rur",
				"ryt",
				"ryx",
				"ry",
				"ryp",
				"ryrx",
				"ryr",
				"jit",
				"jix",
				"ji",
				"jip",
				"jiet",
				"jiex",
				"jie",
				"jiep",
				"juot",
				"juox",
				"juo",
				"juop",
				"jot",
				"jox",
				"jo",
				"jop",
				"jut",
				"jux",
				"ju",
				"jup",
				"jurx",
				"jur",
				"jyt",
				"jyx",
				"jy",
				"jyp",
				"jyrx",
				"jyr",
				"qit",
				"qix",
				"qi",
				"qip"
			],
			[
				"qiet",
				"qiex",
				"qie",
				"qiep",
				"quot",
				"quox",
				"quo",
				"quop",
				"qot",
				"qox",
				"qo",
				"qop",
				"qut",
				"qux",
				"qu",
				"qup",
				"qurx",
				"qur",
				"qyt",
				"qyx",
				"qy",
				"qyp",
				"qyrx",
				"qyr",
				"jjit",
				"jjix",
				"jji",
				"jjip",
				"jjiet",
				"jjiex",
				"jjie",
				"jjiep",
				"jjuox",
				"jjuo",
				"jjuop",
				"jjot",
				"jjox",
				"jjo",
				"jjop",
				"jjut",
				"jjux",
				"jju",
				"jjup",
				"jjurx",
				"jjur",
				"jjyt",
				"jjyx",
				"jjy",
				"jjyp",
				"njit",
				"njix",
				"nji",
				"njip",
				"njiet",
				"njiex",
				"njie",
				"njiep",
				"njuox",
				"njuo",
				"njot",
				"njox",
				"njo",
				"njop",
				"njux",
				"nju",
				"njup",
				"njurx",
				"njur",
				"njyt",
				"njyx",
				"njy",
				"njyp",
				"njyrx",
				"njyr",
				"nyit",
				"nyix",
				"nyi",
				"nyip",
				"nyiet",
				"nyiex",
				"nyie",
				"nyiep",
				"nyuox",
				"nyuo",
				"nyuop",
				"nyot",
				"nyox",
				"nyo",
				"nyop",
				"nyut",
				"nyux",
				"nyu",
				"nyup",
				"xit",
				"xix",
				"xi",
				"xip",
				"xiet",
				"xiex",
				"xie",
				"xiep",
				"xuox",
				"xuo",
				"xot",
				"xox",
				"xo",
				"xop",
				"xyt",
				"xyx",
				"xy",
				"xyp",
				"xyrx",
				"xyr",
				"yit",
				"yix",
				"yi",
				"yip",
				"yiet",
				"yiex",
				"yie",
				"yiep",
				"yuot",
				"yuox",
				"yuo",
				"yuop",
				"yot",
				"yox",
				"yo",
				"yop",
				"yut",
				"yux",
				"yu",
				"yup",
				"yurx",
				"yur",
				"yyt",
				"yyx",
				"yy",
				"yyp",
				"yyrx",
				"yyr",
				,
				,
				,
				"Qot",
				"Li",
				"Kit",
				"Nyip",
				"Cyp",
				"Ssi",
				"Ggop",
				"Gep",
				"Mi",
				"Hxit",
				"Lyr",
				"Bbut",
				"Mop",
				"Yo",
				"Put",
				"Hxuo",
				"Tat",
				"Ga",
				,
				,
				"Ddur",
				"Bur",
				"Gguo",
				"Nyop",
				"Tu",
				"Op",
				"Jjut",
				"Zot",
				"Pyt",
				"Hmo",
				"Yit",
				"Vur",
				"Shy",
				"Vep",
				"Za",
				"Jo",
				,
				"Jjy",
				"Got",
				"Jjie",
				"Wo",
				"Du",
				"Shur",
				"Lie",
				"Cy",
				"Cuop",
				"Cip",
				"Hxop",
				"Shat",
				,
				"Shop",
				"Che",
				"Zziet",
				,
				"Ke"
			],
			[],
			[],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"A",
				"a",
				"A",
				"a",
				"HENG",
				"heng",
				"TZ",
				"tz",
				"3",
				"3",
				"4",
				"4",
				"4",
				"4",
				"F",
				"S",
				"AA",
				"aa",
				"AO",
				"ao",
				"AU",
				"au",
				"AV",
				"av",
				"AV-",
				"av-",
				"AY",
				"ay",
				"C",
				"c",
				"K",
				"k",
				"K",
				"k",
				"K",
				"k",
				"L",
				"l",
				"L",
				"l",
				"O",
				"o",
				"O",
				"o",
				"OO",
				"oo",
				"P",
				"p",
				"P",
				"p",
				"P",
				"p",
				"Q",
				"q",
				"Q",
				"q",
				"R",
				"r",
				"R",
				"r",
				"V",
				"v",
				"VY",
				"vy",
				"Z",
				"z",
				"TH",
				"th",
				"TH",
				"th",
				"Y",
				"y",
				"ET",
				"et",
				"IS",
				"is",
				"CON",
				"con",
				"US",
				"us",
				"dum",
				"lum",
				"num",
				"rum",
				"RUM",
				"tum",
				"um",
				"D",
				"d",
				"F",
				"f",
				"G",
				"G",
				"g",
				"L",
				"l",
				"R",
				"r",
				"S",
				"s",
				"T",
				"t",
				"^",
				":",
				"=",
				"'",
				"'",
				"H",
				"l",
				".",
				"N",
				"n",
				"C",
				"c",
				"c",
				"h",
				"B",
				"b",
				"F",
				"f",
				"AE",
				"ae",
				"OE",
				"oe",
				"UE",
				"ue",
				"G",
				"g",
				"K",
				"k",
				"N",
				"n",
				"R",
				"r",
				"S",
				"s",
				"H",
				"E",
				"G",
				"L",
				"I",
				"Q",
				"K",
				"T",
				"J",
				"CHI",
				"B",
				"b",
				"O",
				"o",
				"U",
				"u",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"I",
				"H",
				"oe",
				"M",
				"F",
				"P",
				"M",
				"I",
				"M1"
			],
			[],
			[],
			[],
			[],
			[
				"ga",
				"gag",
				"gagg",
				"gags",
				"gan",
				"ganj",
				"ganh",
				"gad",
				"gal",
				"galg",
				"galm",
				"galb",
				"gals",
				"galt",
				"galp",
				"galh",
				"gam",
				"gab",
				"gabs",
				"gas",
				"gass",
				"gang",
				"gaj",
				"gac",
				"gak",
				"gat",
				"gap",
				"gah",
				"gae",
				"gaeg",
				"gaegg",
				"gaegs",
				"gaen",
				"gaenj",
				"gaenh",
				"gaed",
				"gael",
				"gaelg",
				"gaelm",
				"gaelb",
				"gaels",
				"gaelt",
				"gaelp",
				"gaelh",
				"gaem",
				"gaeb",
				"gaebs",
				"gaes",
				"gaess",
				"gaeng",
				"gaej",
				"gaec",
				"gaek",
				"gaet",
				"gaep",
				"gaeh",
				"gya",
				"gyag",
				"gyagg",
				"gyags",
				"gyan",
				"gyanj",
				"gyanh",
				"gyad",
				"gyal",
				"gyalg",
				"gyalm",
				"gyalb",
				"gyals",
				"gyalt",
				"gyalp",
				"gyalh",
				"gyam",
				"gyab",
				"gyabs",
				"gyas",
				"gyass",
				"gyang",
				"gyaj",
				"gyac",
				"gyak",
				"gyat",
				"gyap",
				"gyah",
				"gyae",
				"gyaeg",
				"gyaegg",
				"gyaegs",
				"gyaen",
				"gyaenj",
				"gyaenh",
				"gyaed",
				"gyael",
				"gyaelg",
				"gyaelm",
				"gyaelb",
				"gyaels",
				"gyaelt",
				"gyaelp",
				"gyaelh",
				"gyaem",
				"gyaeb",
				"gyaebs",
				"gyaes",
				"gyaess",
				"gyaeng",
				"gyaej",
				"gyaec",
				"gyaek",
				"gyaet",
				"gyaep",
				"gyaeh",
				"geo",
				"geog",
				"geogg",
				"geogs",
				"geon",
				"geonj",
				"geonh",
				"geod",
				"geol",
				"geolg",
				"geolm",
				"geolb",
				"geols",
				"geolt",
				"geolp",
				"geolh",
				"geom",
				"geob",
				"geobs",
				"geos",
				"geoss",
				"geong",
				"geoj",
				"geoc",
				"geok",
				"geot",
				"geop",
				"geoh",
				"ge",
				"geg",
				"gegg",
				"gegs",
				"gen",
				"genj",
				"genh",
				"ged",
				"gel",
				"gelg",
				"gelm",
				"gelb",
				"gels",
				"gelt",
				"gelp",
				"gelh",
				"gem",
				"geb",
				"gebs",
				"ges",
				"gess",
				"geng",
				"gej",
				"gec",
				"gek",
				"get",
				"gep",
				"geh",
				"gyeo",
				"gyeog",
				"gyeogg",
				"gyeogs",
				"gyeon",
				"gyeonj",
				"gyeonh",
				"gyeod",
				"gyeol",
				"gyeolg",
				"gyeolm",
				"gyeolb",
				"gyeols",
				"gyeolt",
				"gyeolp",
				"gyeolh",
				"gyeom",
				"gyeob",
				"gyeobs",
				"gyeos",
				"gyeoss",
				"gyeong",
				"gyeoj",
				"gyeoc",
				"gyeok",
				"gyeot",
				"gyeop",
				"gyeoh",
				"gye",
				"gyeg",
				"gyegg",
				"gyegs",
				"gyen",
				"gyenj",
				"gyenh",
				"gyed",
				"gyel",
				"gyelg",
				"gyelm",
				"gyelb",
				"gyels",
				"gyelt",
				"gyelp",
				"gyelh",
				"gyem",
				"gyeb",
				"gyebs",
				"gyes",
				"gyess",
				"gyeng",
				"gyej",
				"gyec",
				"gyek",
				"gyet",
				"gyep",
				"gyeh",
				"go",
				"gog",
				"gogg",
				"gogs",
				"gon",
				"gonj",
				"gonh",
				"god",
				"gol",
				"golg",
				"golm",
				"golb",
				"gols",
				"golt",
				"golp",
				"golh",
				"gom",
				"gob",
				"gobs",
				"gos",
				"goss",
				"gong",
				"goj",
				"goc",
				"gok",
				"got",
				"gop",
				"goh",
				"gwa",
				"gwag",
				"gwagg",
				"gwags"
			],
			[
				"gwan",
				"gwanj",
				"gwanh",
				"gwad",
				"gwal",
				"gwalg",
				"gwalm",
				"gwalb",
				"gwals",
				"gwalt",
				"gwalp",
				"gwalh",
				"gwam",
				"gwab",
				"gwabs",
				"gwas",
				"gwass",
				"gwang",
				"gwaj",
				"gwac",
				"gwak",
				"gwat",
				"gwap",
				"gwah",
				"gwae",
				"gwaeg",
				"gwaegg",
				"gwaegs",
				"gwaen",
				"gwaenj",
				"gwaenh",
				"gwaed",
				"gwael",
				"gwaelg",
				"gwaelm",
				"gwaelb",
				"gwaels",
				"gwaelt",
				"gwaelp",
				"gwaelh",
				"gwaem",
				"gwaeb",
				"gwaebs",
				"gwaes",
				"gwaess",
				"gwaeng",
				"gwaej",
				"gwaec",
				"gwaek",
				"gwaet",
				"gwaep",
				"gwaeh",
				"goe",
				"goeg",
				"goegg",
				"goegs",
				"goen",
				"goenj",
				"goenh",
				"goed",
				"goel",
				"goelg",
				"goelm",
				"goelb",
				"goels",
				"goelt",
				"goelp",
				"goelh",
				"goem",
				"goeb",
				"goebs",
				"goes",
				"goess",
				"goeng",
				"goej",
				"goec",
				"goek",
				"goet",
				"goep",
				"goeh",
				"gyo",
				"gyog",
				"gyogg",
				"gyogs",
				"gyon",
				"gyonj",
				"gyonh",
				"gyod",
				"gyol",
				"gyolg",
				"gyolm",
				"gyolb",
				"gyols",
				"gyolt",
				"gyolp",
				"gyolh",
				"gyom",
				"gyob",
				"gyobs",
				"gyos",
				"gyoss",
				"gyong",
				"gyoj",
				"gyoc",
				"gyok",
				"gyot",
				"gyop",
				"gyoh",
				"gu",
				"gug",
				"gugg",
				"gugs",
				"gun",
				"gunj",
				"gunh",
				"gud",
				"gul",
				"gulg",
				"gulm",
				"gulb",
				"guls",
				"gult",
				"gulp",
				"gulh",
				"gum",
				"gub",
				"gubs",
				"gus",
				"guss",
				"gung",
				"guj",
				"guc",
				"guk",
				"gut",
				"gup",
				"guh",
				"gweo",
				"gweog",
				"gweogg",
				"gweogs",
				"gweon",
				"gweonj",
				"gweonh",
				"gweod",
				"gweol",
				"gweolg",
				"gweolm",
				"gweolb",
				"gweols",
				"gweolt",
				"gweolp",
				"gweolh",
				"gweom",
				"gweob",
				"gweobs",
				"gweos",
				"gweoss",
				"gweong",
				"gweoj",
				"gweoc",
				"gweok",
				"gweot",
				"gweop",
				"gweoh",
				"gwe",
				"gweg",
				"gwegg",
				"gwegs",
				"gwen",
				"gwenj",
				"gwenh",
				"gwed",
				"gwel",
				"gwelg",
				"gwelm",
				"gwelb",
				"gwels",
				"gwelt",
				"gwelp",
				"gwelh",
				"gwem",
				"gweb",
				"gwebs",
				"gwes",
				"gwess",
				"gweng",
				"gwej",
				"gwec",
				"gwek",
				"gwet",
				"gwep",
				"gweh",
				"gwi",
				"gwig",
				"gwigg",
				"gwigs",
				"gwin",
				"gwinj",
				"gwinh",
				"gwid",
				"gwil",
				"gwilg",
				"gwilm",
				"gwilb",
				"gwils",
				"gwilt",
				"gwilp",
				"gwilh",
				"gwim",
				"gwib",
				"gwibs",
				"gwis",
				"gwiss",
				"gwing",
				"gwij",
				"gwic",
				"gwik",
				"gwit",
				"gwip",
				"gwih",
				"gyu",
				"gyug",
				"gyugg",
				"gyugs",
				"gyun",
				"gyunj",
				"gyunh",
				"gyud",
				"gyul",
				"gyulg",
				"gyulm",
				"gyulb",
				"gyuls",
				"gyult",
				"gyulp",
				"gyulh",
				"gyum",
				"gyub",
				"gyubs",
				"gyus",
				"gyuss",
				"gyung",
				"gyuj",
				"gyuc",
				"gyuk",
				"gyut",
				"gyup",
				"gyuh",
				"geu",
				"geug",
				"geugg",
				"geugs",
				"geun",
				"geunj",
				"geunh",
				"geud"
			],
			[
				"geul",
				"geulg",
				"geulm",
				"geulb",
				"geuls",
				"geult",
				"geulp",
				"geulh",
				"geum",
				"geub",
				"geubs",
				"geus",
				"geuss",
				"geung",
				"geuj",
				"geuc",
				"geuk",
				"geut",
				"geup",
				"geuh",
				"gyi",
				"gyig",
				"gyigg",
				"gyigs",
				"gyin",
				"gyinj",
				"gyinh",
				"gyid",
				"gyil",
				"gyilg",
				"gyilm",
				"gyilb",
				"gyils",
				"gyilt",
				"gyilp",
				"gyilh",
				"gyim",
				"gyib",
				"gyibs",
				"gyis",
				"gyiss",
				"gying",
				"gyij",
				"gyic",
				"gyik",
				"gyit",
				"gyip",
				"gyih",
				"gi",
				"gig",
				"gigg",
				"gigs",
				"gin",
				"ginj",
				"ginh",
				"gid",
				"gil",
				"gilg",
				"gilm",
				"gilb",
				"gils",
				"gilt",
				"gilp",
				"gilh",
				"gim",
				"gib",
				"gibs",
				"gis",
				"giss",
				"ging",
				"gij",
				"gic",
				"gik",
				"git",
				"gip",
				"gih",
				"gga",
				"ggag",
				"ggagg",
				"ggags",
				"ggan",
				"gganj",
				"gganh",
				"ggad",
				"ggal",
				"ggalg",
				"ggalm",
				"ggalb",
				"ggals",
				"ggalt",
				"ggalp",
				"ggalh",
				"ggam",
				"ggab",
				"ggabs",
				"ggas",
				"ggass",
				"ggang",
				"ggaj",
				"ggac",
				"ggak",
				"ggat",
				"ggap",
				"ggah",
				"ggae",
				"ggaeg",
				"ggaegg",
				"ggaegs",
				"ggaen",
				"ggaenj",
				"ggaenh",
				"ggaed",
				"ggael",
				"ggaelg",
				"ggaelm",
				"ggaelb",
				"ggaels",
				"ggaelt",
				"ggaelp",
				"ggaelh",
				"ggaem",
				"ggaeb",
				"ggaebs",
				"ggaes",
				"ggaess",
				"ggaeng",
				"ggaej",
				"ggaec",
				"ggaek",
				"ggaet",
				"ggaep",
				"ggaeh",
				"ggya",
				"ggyag",
				"ggyagg",
				"ggyags",
				"ggyan",
				"ggyanj",
				"ggyanh",
				"ggyad",
				"ggyal",
				"ggyalg",
				"ggyalm",
				"ggyalb",
				"ggyals",
				"ggyalt",
				"ggyalp",
				"ggyalh",
				"ggyam",
				"ggyab",
				"ggyabs",
				"ggyas",
				"ggyass",
				"ggyang",
				"ggyaj",
				"ggyac",
				"ggyak",
				"ggyat",
				"ggyap",
				"ggyah",
				"ggyae",
				"ggyaeg",
				"ggyaegg",
				"ggyaegs",
				"ggyaen",
				"ggyaenj",
				"ggyaenh",
				"ggyaed",
				"ggyael",
				"ggyaelg",
				"ggyaelm",
				"ggyaelb",
				"ggyaels",
				"ggyaelt",
				"ggyaelp",
				"ggyaelh",
				"ggyaem",
				"ggyaeb",
				"ggyaebs",
				"ggyaes",
				"ggyaess",
				"ggyaeng",
				"ggyaej",
				"ggyaec",
				"ggyaek",
				"ggyaet",
				"ggyaep",
				"ggyaeh",
				"ggeo",
				"ggeog",
				"ggeogg",
				"ggeogs",
				"ggeon",
				"ggeonj",
				"ggeonh",
				"ggeod",
				"ggeol",
				"ggeolg",
				"ggeolm",
				"ggeolb",
				"ggeols",
				"ggeolt",
				"ggeolp",
				"ggeolh",
				"ggeom",
				"ggeob",
				"ggeobs",
				"ggeos",
				"ggeoss",
				"ggeong",
				"ggeoj",
				"ggeoc",
				"ggeok",
				"ggeot",
				"ggeop",
				"ggeoh",
				"gge",
				"ggeg",
				"ggegg",
				"ggegs",
				"ggen",
				"ggenj",
				"ggenh",
				"gged",
				"ggel",
				"ggelg",
				"ggelm",
				"ggelb",
				"ggels",
				"ggelt",
				"ggelp",
				"ggelh",
				"ggem",
				"ggeb",
				"ggebs",
				"gges",
				"ggess",
				"ggeng",
				"ggej",
				"ggec",
				"ggek",
				"gget",
				"ggep",
				"ggeh",
				"ggyeo",
				"ggyeog",
				"ggyeogg",
				"ggyeogs",
				"ggyeon",
				"ggyeonj",
				"ggyeonh",
				"ggyeod",
				"ggyeol",
				"ggyeolg",
				"ggyeolm",
				"ggyeolb"
			],
			[
				"ggyeols",
				"ggyeolt",
				"ggyeolp",
				"ggyeolh",
				"ggyeom",
				"ggyeob",
				"ggyeobs",
				"ggyeos",
				"ggyeoss",
				"ggyeong",
				"ggyeoj",
				"ggyeoc",
				"ggyeok",
				"ggyeot",
				"ggyeop",
				"ggyeoh",
				"ggye",
				"ggyeg",
				"ggyegg",
				"ggyegs",
				"ggyen",
				"ggyenj",
				"ggyenh",
				"ggyed",
				"ggyel",
				"ggyelg",
				"ggyelm",
				"ggyelb",
				"ggyels",
				"ggyelt",
				"ggyelp",
				"ggyelh",
				"ggyem",
				"ggyeb",
				"ggyebs",
				"ggyes",
				"ggyess",
				"ggyeng",
				"ggyej",
				"ggyec",
				"ggyek",
				"ggyet",
				"ggyep",
				"ggyeh",
				"ggo",
				"ggog",
				"ggogg",
				"ggogs",
				"ggon",
				"ggonj",
				"ggonh",
				"ggod",
				"ggol",
				"ggolg",
				"ggolm",
				"ggolb",
				"ggols",
				"ggolt",
				"ggolp",
				"ggolh",
				"ggom",
				"ggob",
				"ggobs",
				"ggos",
				"ggoss",
				"ggong",
				"ggoj",
				"ggoc",
				"ggok",
				"ggot",
				"ggop",
				"ggoh",
				"ggwa",
				"ggwag",
				"ggwagg",
				"ggwags",
				"ggwan",
				"ggwanj",
				"ggwanh",
				"ggwad",
				"ggwal",
				"ggwalg",
				"ggwalm",
				"ggwalb",
				"ggwals",
				"ggwalt",
				"ggwalp",
				"ggwalh",
				"ggwam",
				"ggwab",
				"ggwabs",
				"ggwas",
				"ggwass",
				"ggwang",
				"ggwaj",
				"ggwac",
				"ggwak",
				"ggwat",
				"ggwap",
				"ggwah",
				"ggwae",
				"ggwaeg",
				"ggwaegg",
				"ggwaegs",
				"ggwaen",
				"ggwaenj",
				"ggwaenh",
				"ggwaed",
				"ggwael",
				"ggwaelg",
				"ggwaelm",
				"ggwaelb",
				"ggwaels",
				"ggwaelt",
				"ggwaelp",
				"ggwaelh",
				"ggwaem",
				"ggwaeb",
				"ggwaebs",
				"ggwaes",
				"ggwaess",
				"ggwaeng",
				"ggwaej",
				"ggwaec",
				"ggwaek",
				"ggwaet",
				"ggwaep",
				"ggwaeh",
				"ggoe",
				"ggoeg",
				"ggoegg",
				"ggoegs",
				"ggoen",
				"ggoenj",
				"ggoenh",
				"ggoed",
				"ggoel",
				"ggoelg",
				"ggoelm",
				"ggoelb",
				"ggoels",
				"ggoelt",
				"ggoelp",
				"ggoelh",
				"ggoem",
				"ggoeb",
				"ggoebs",
				"ggoes",
				"ggoess",
				"ggoeng",
				"ggoej",
				"ggoec",
				"ggoek",
				"ggoet",
				"ggoep",
				"ggoeh",
				"ggyo",
				"ggyog",
				"ggyogg",
				"ggyogs",
				"ggyon",
				"ggyonj",
				"ggyonh",
				"ggyod",
				"ggyol",
				"ggyolg",
				"ggyolm",
				"ggyolb",
				"ggyols",
				"ggyolt",
				"ggyolp",
				"ggyolh",
				"ggyom",
				"ggyob",
				"ggyobs",
				"ggyos",
				"ggyoss",
				"ggyong",
				"ggyoj",
				"ggyoc",
				"ggyok",
				"ggyot",
				"ggyop",
				"ggyoh",
				"ggu",
				"ggug",
				"ggugg",
				"ggugs",
				"ggun",
				"ggunj",
				"ggunh",
				"ggud",
				"ggul",
				"ggulg",
				"ggulm",
				"ggulb",
				"gguls",
				"ggult",
				"ggulp",
				"ggulh",
				"ggum",
				"ggub",
				"ggubs",
				"ggus",
				"gguss",
				"ggung",
				"gguj",
				"gguc",
				"gguk",
				"ggut",
				"ggup",
				"gguh",
				"ggweo",
				"ggweog",
				"ggweogg",
				"ggweogs",
				"ggweon",
				"ggweonj",
				"ggweonh",
				"ggweod",
				"ggweol",
				"ggweolg",
				"ggweolm",
				"ggweolb",
				"ggweols",
				"ggweolt",
				"ggweolp",
				"ggweolh",
				"ggweom",
				"ggweob",
				"ggweobs",
				"ggweos",
				"ggweoss",
				"ggweong",
				"ggweoj",
				"ggweoc",
				"ggweok",
				"ggweot",
				"ggweop",
				"ggweoh",
				"ggwe",
				"ggweg",
				"ggwegg",
				"ggwegs",
				"ggwen",
				"ggwenj",
				"ggwenh",
				"ggwed",
				"ggwel",
				"ggwelg",
				"ggwelm",
				"ggwelb",
				"ggwels",
				"ggwelt",
				"ggwelp",
				"ggwelh"
			],
			[
				"ggwem",
				"ggweb",
				"ggwebs",
				"ggwes",
				"ggwess",
				"ggweng",
				"ggwej",
				"ggwec",
				"ggwek",
				"ggwet",
				"ggwep",
				"ggweh",
				"ggwi",
				"ggwig",
				"ggwigg",
				"ggwigs",
				"ggwin",
				"ggwinj",
				"ggwinh",
				"ggwid",
				"ggwil",
				"ggwilg",
				"ggwilm",
				"ggwilb",
				"ggwils",
				"ggwilt",
				"ggwilp",
				"ggwilh",
				"ggwim",
				"ggwib",
				"ggwibs",
				"ggwis",
				"ggwiss",
				"ggwing",
				"ggwij",
				"ggwic",
				"ggwik",
				"ggwit",
				"ggwip",
				"ggwih",
				"ggyu",
				"ggyug",
				"ggyugg",
				"ggyugs",
				"ggyun",
				"ggyunj",
				"ggyunh",
				"ggyud",
				"ggyul",
				"ggyulg",
				"ggyulm",
				"ggyulb",
				"ggyuls",
				"ggyult",
				"ggyulp",
				"ggyulh",
				"ggyum",
				"ggyub",
				"ggyubs",
				"ggyus",
				"ggyuss",
				"ggyung",
				"ggyuj",
				"ggyuc",
				"ggyuk",
				"ggyut",
				"ggyup",
				"ggyuh",
				"ggeu",
				"ggeug",
				"ggeugg",
				"ggeugs",
				"ggeun",
				"ggeunj",
				"ggeunh",
				"ggeud",
				"ggeul",
				"ggeulg",
				"ggeulm",
				"ggeulb",
				"ggeuls",
				"ggeult",
				"ggeulp",
				"ggeulh",
				"ggeum",
				"ggeub",
				"ggeubs",
				"ggeus",
				"ggeuss",
				"ggeung",
				"ggeuj",
				"ggeuc",
				"ggeuk",
				"ggeut",
				"ggeup",
				"ggeuh",
				"ggyi",
				"ggyig",
				"ggyigg",
				"ggyigs",
				"ggyin",
				"ggyinj",
				"ggyinh",
				"ggyid",
				"ggyil",
				"ggyilg",
				"ggyilm",
				"ggyilb",
				"ggyils",
				"ggyilt",
				"ggyilp",
				"ggyilh",
				"ggyim",
				"ggyib",
				"ggyibs",
				"ggyis",
				"ggyiss",
				"ggying",
				"ggyij",
				"ggyic",
				"ggyik",
				"ggyit",
				"ggyip",
				"ggyih",
				"ggi",
				"ggig",
				"ggigg",
				"ggigs",
				"ggin",
				"gginj",
				"gginh",
				"ggid",
				"ggil",
				"ggilg",
				"ggilm",
				"ggilb",
				"ggils",
				"ggilt",
				"ggilp",
				"ggilh",
				"ggim",
				"ggib",
				"ggibs",
				"ggis",
				"ggiss",
				"gging",
				"ggij",
				"ggic",
				"ggik",
				"ggit",
				"ggip",
				"ggih",
				"na",
				"nag",
				"nagg",
				"nags",
				"nan",
				"nanj",
				"nanh",
				"nad",
				"nal",
				"nalg",
				"nalm",
				"nalb",
				"nals",
				"nalt",
				"nalp",
				"nalh",
				"nam",
				"nab",
				"nabs",
				"nas",
				"nass",
				"nang",
				"naj",
				"nac",
				"nak",
				"nat",
				"nap",
				"nah",
				"nae",
				"naeg",
				"naegg",
				"naegs",
				"naen",
				"naenj",
				"naenh",
				"naed",
				"nael",
				"naelg",
				"naelm",
				"naelb",
				"naels",
				"naelt",
				"naelp",
				"naelh",
				"naem",
				"naeb",
				"naebs",
				"naes",
				"naess",
				"naeng",
				"naej",
				"naec",
				"naek",
				"naet",
				"naep",
				"naeh",
				"nya",
				"nyag",
				"nyagg",
				"nyags",
				"nyan",
				"nyanj",
				"nyanh",
				"nyad",
				"nyal",
				"nyalg",
				"nyalm",
				"nyalb",
				"nyals",
				"nyalt",
				"nyalp",
				"nyalh",
				"nyam",
				"nyab",
				"nyabs",
				"nyas",
				"nyass",
				"nyang",
				"nyaj",
				"nyac",
				"nyak",
				"nyat",
				"nyap",
				"nyah",
				"nyae",
				"nyaeg",
				"nyaegg",
				"nyaegs",
				"nyaen",
				"nyaenj",
				"nyaenh",
				"nyaed",
				"nyael",
				"nyaelg",
				"nyaelm",
				"nyaelb",
				"nyaels",
				"nyaelt",
				"nyaelp",
				"nyaelh",
				"nyaem",
				"nyaeb",
				"nyaebs",
				"nyaes"
			],
			[
				"nyaess",
				"nyaeng",
				"nyaej",
				"nyaec",
				"nyaek",
				"nyaet",
				"nyaep",
				"nyaeh",
				"neo",
				"neog",
				"neogg",
				"neogs",
				"neon",
				"neonj",
				"neonh",
				"neod",
				"neol",
				"neolg",
				"neolm",
				"neolb",
				"neols",
				"neolt",
				"neolp",
				"neolh",
				"neom",
				"neob",
				"neobs",
				"neos",
				"neoss",
				"neong",
				"neoj",
				"neoc",
				"neok",
				"neot",
				"neop",
				"neoh",
				"ne",
				"neg",
				"negg",
				"negs",
				"nen",
				"nenj",
				"nenh",
				"ned",
				"nel",
				"nelg",
				"nelm",
				"nelb",
				"nels",
				"nelt",
				"nelp",
				"nelh",
				"nem",
				"neb",
				"nebs",
				"nes",
				"ness",
				"neng",
				"nej",
				"nec",
				"nek",
				"net",
				"nep",
				"neh",
				"nyeo",
				"nyeog",
				"nyeogg",
				"nyeogs",
				"nyeon",
				"nyeonj",
				"nyeonh",
				"nyeod",
				"nyeol",
				"nyeolg",
				"nyeolm",
				"nyeolb",
				"nyeols",
				"nyeolt",
				"nyeolp",
				"nyeolh",
				"nyeom",
				"nyeob",
				"nyeobs",
				"nyeos",
				"nyeoss",
				"nyeong",
				"nyeoj",
				"nyeoc",
				"nyeok",
				"nyeot",
				"nyeop",
				"nyeoh",
				"nye",
				"nyeg",
				"nyegg",
				"nyegs",
				"nyen",
				"nyenj",
				"nyenh",
				"nyed",
				"nyel",
				"nyelg",
				"nyelm",
				"nyelb",
				"nyels",
				"nyelt",
				"nyelp",
				"nyelh",
				"nyem",
				"nyeb",
				"nyebs",
				"nyes",
				"nyess",
				"nyeng",
				"nyej",
				"nyec",
				"nyek",
				"nyet",
				"nyep",
				"nyeh",
				"no",
				"nog",
				"nogg",
				"nogs",
				"non",
				"nonj",
				"nonh",
				"nod",
				"nol",
				"nolg",
				"nolm",
				"nolb",
				"nols",
				"nolt",
				"nolp",
				"nolh",
				"nom",
				"nob",
				"nobs",
				"nos",
				"noss",
				"nong",
				"noj",
				"noc",
				"nok",
				"not",
				"nop",
				"noh",
				"nwa",
				"nwag",
				"nwagg",
				"nwags",
				"nwan",
				"nwanj",
				"nwanh",
				"nwad",
				"nwal",
				"nwalg",
				"nwalm",
				"nwalb",
				"nwals",
				"nwalt",
				"nwalp",
				"nwalh",
				"nwam",
				"nwab",
				"nwabs",
				"nwas",
				"nwass",
				"nwang",
				"nwaj",
				"nwac",
				"nwak",
				"nwat",
				"nwap",
				"nwah",
				"nwae",
				"nwaeg",
				"nwaegg",
				"nwaegs",
				"nwaen",
				"nwaenj",
				"nwaenh",
				"nwaed",
				"nwael",
				"nwaelg",
				"nwaelm",
				"nwaelb",
				"nwaels",
				"nwaelt",
				"nwaelp",
				"nwaelh",
				"nwaem",
				"nwaeb",
				"nwaebs",
				"nwaes",
				"nwaess",
				"nwaeng",
				"nwaej",
				"nwaec",
				"nwaek",
				"nwaet",
				"nwaep",
				"nwaeh",
				"noe",
				"noeg",
				"noegg",
				"noegs",
				"noen",
				"noenj",
				"noenh",
				"noed",
				"noel",
				"noelg",
				"noelm",
				"noelb",
				"noels",
				"noelt",
				"noelp",
				"noelh",
				"noem",
				"noeb",
				"noebs",
				"noes",
				"noess",
				"noeng",
				"noej",
				"noec",
				"noek",
				"noet",
				"noep",
				"noeh",
				"nyo",
				"nyog",
				"nyogg",
				"nyogs",
				"nyon",
				"nyonj",
				"nyonh",
				"nyod",
				"nyol",
				"nyolg",
				"nyolm",
				"nyolb",
				"nyols",
				"nyolt",
				"nyolp",
				"nyolh",
				"nyom",
				"nyob",
				"nyobs",
				"nyos",
				"nyoss",
				"nyong",
				"nyoj",
				"nyoc"
			],
			[
				"nyok",
				"nyot",
				"nyop",
				"nyoh",
				"nu",
				"nug",
				"nugg",
				"nugs",
				"nun",
				"nunj",
				"nunh",
				"nud",
				"nul",
				"nulg",
				"nulm",
				"nulb",
				"nuls",
				"nult",
				"nulp",
				"nulh",
				"num",
				"nub",
				"nubs",
				"nus",
				"nuss",
				"nung",
				"nuj",
				"nuc",
				"nuk",
				"nut",
				"nup",
				"nuh",
				"nweo",
				"nweog",
				"nweogg",
				"nweogs",
				"nweon",
				"nweonj",
				"nweonh",
				"nweod",
				"nweol",
				"nweolg",
				"nweolm",
				"nweolb",
				"nweols",
				"nweolt",
				"nweolp",
				"nweolh",
				"nweom",
				"nweob",
				"nweobs",
				"nweos",
				"nweoss",
				"nweong",
				"nweoj",
				"nweoc",
				"nweok",
				"nweot",
				"nweop",
				"nweoh",
				"nwe",
				"nweg",
				"nwegg",
				"nwegs",
				"nwen",
				"nwenj",
				"nwenh",
				"nwed",
				"nwel",
				"nwelg",
				"nwelm",
				"nwelb",
				"nwels",
				"nwelt",
				"nwelp",
				"nwelh",
				"nwem",
				"nweb",
				"nwebs",
				"nwes",
				"nwess",
				"nweng",
				"nwej",
				"nwec",
				"nwek",
				"nwet",
				"nwep",
				"nweh",
				"nwi",
				"nwig",
				"nwigg",
				"nwigs",
				"nwin",
				"nwinj",
				"nwinh",
				"nwid",
				"nwil",
				"nwilg",
				"nwilm",
				"nwilb",
				"nwils",
				"nwilt",
				"nwilp",
				"nwilh",
				"nwim",
				"nwib",
				"nwibs",
				"nwis",
				"nwiss",
				"nwing",
				"nwij",
				"nwic",
				"nwik",
				"nwit",
				"nwip",
				"nwih",
				"nyu",
				"nyug",
				"nyugg",
				"nyugs",
				"nyun",
				"nyunj",
				"nyunh",
				"nyud",
				"nyul",
				"nyulg",
				"nyulm",
				"nyulb",
				"nyuls",
				"nyult",
				"nyulp",
				"nyulh",
				"nyum",
				"nyub",
				"nyubs",
				"nyus",
				"nyuss",
				"nyung",
				"nyuj",
				"nyuc",
				"nyuk",
				"nyut",
				"nyup",
				"nyuh",
				"neu",
				"neug",
				"neugg",
				"neugs",
				"neun",
				"neunj",
				"neunh",
				"neud",
				"neul",
				"neulg",
				"neulm",
				"neulb",
				"neuls",
				"neult",
				"neulp",
				"neulh",
				"neum",
				"neub",
				"neubs",
				"neus",
				"neuss",
				"neung",
				"neuj",
				"neuc",
				"neuk",
				"neut",
				"neup",
				"neuh",
				"nyi",
				"nyig",
				"nyigg",
				"nyigs",
				"nyin",
				"nyinj",
				"nyinh",
				"nyid",
				"nyil",
				"nyilg",
				"nyilm",
				"nyilb",
				"nyils",
				"nyilt",
				"nyilp",
				"nyilh",
				"nyim",
				"nyib",
				"nyibs",
				"nyis",
				"nyiss",
				"nying",
				"nyij",
				"nyic",
				"nyik",
				"nyit",
				"nyip",
				"nyih",
				"ni",
				"nig",
				"nigg",
				"nigs",
				"nin",
				"ninj",
				"ninh",
				"nid",
				"nil",
				"nilg",
				"nilm",
				"nilb",
				"nils",
				"nilt",
				"nilp",
				"nilh",
				"nim",
				"nib",
				"nibs",
				"nis",
				"niss",
				"ning",
				"nij",
				"nic",
				"nik",
				"nit",
				"nip",
				"nih",
				"da",
				"dag",
				"dagg",
				"dags",
				"dan",
				"danj",
				"danh",
				"dad",
				"dal",
				"dalg",
				"dalm",
				"dalb",
				"dals",
				"dalt",
				"dalp",
				"dalh",
				"dam",
				"dab",
				"dabs",
				"das",
				"dass",
				"dang",
				"daj",
				"dac",
				"dak",
				"dat",
				"dap",
				"dah"
			],
			[
				"dae",
				"daeg",
				"daegg",
				"daegs",
				"daen",
				"daenj",
				"daenh",
				"daed",
				"dael",
				"daelg",
				"daelm",
				"daelb",
				"daels",
				"daelt",
				"daelp",
				"daelh",
				"daem",
				"daeb",
				"daebs",
				"daes",
				"daess",
				"daeng",
				"daej",
				"daec",
				"daek",
				"daet",
				"daep",
				"daeh",
				"dya",
				"dyag",
				"dyagg",
				"dyags",
				"dyan",
				"dyanj",
				"dyanh",
				"dyad",
				"dyal",
				"dyalg",
				"dyalm",
				"dyalb",
				"dyals",
				"dyalt",
				"dyalp",
				"dyalh",
				"dyam",
				"dyab",
				"dyabs",
				"dyas",
				"dyass",
				"dyang",
				"dyaj",
				"dyac",
				"dyak",
				"dyat",
				"dyap",
				"dyah",
				"dyae",
				"dyaeg",
				"dyaegg",
				"dyaegs",
				"dyaen",
				"dyaenj",
				"dyaenh",
				"dyaed",
				"dyael",
				"dyaelg",
				"dyaelm",
				"dyaelb",
				"dyaels",
				"dyaelt",
				"dyaelp",
				"dyaelh",
				"dyaem",
				"dyaeb",
				"dyaebs",
				"dyaes",
				"dyaess",
				"dyaeng",
				"dyaej",
				"dyaec",
				"dyaek",
				"dyaet",
				"dyaep",
				"dyaeh",
				"deo",
				"deog",
				"deogg",
				"deogs",
				"deon",
				"deonj",
				"deonh",
				"deod",
				"deol",
				"deolg",
				"deolm",
				"deolb",
				"deols",
				"deolt",
				"deolp",
				"deolh",
				"deom",
				"deob",
				"deobs",
				"deos",
				"deoss",
				"deong",
				"deoj",
				"deoc",
				"deok",
				"deot",
				"deop",
				"deoh",
				"de",
				"deg",
				"degg",
				"degs",
				"den",
				"denj",
				"denh",
				"ded",
				"del",
				"delg",
				"delm",
				"delb",
				"dels",
				"delt",
				"delp",
				"delh",
				"dem",
				"deb",
				"debs",
				"des",
				"dess",
				"deng",
				"dej",
				"dec",
				"dek",
				"det",
				"dep",
				"deh",
				"dyeo",
				"dyeog",
				"dyeogg",
				"dyeogs",
				"dyeon",
				"dyeonj",
				"dyeonh",
				"dyeod",
				"dyeol",
				"dyeolg",
				"dyeolm",
				"dyeolb",
				"dyeols",
				"dyeolt",
				"dyeolp",
				"dyeolh",
				"dyeom",
				"dyeob",
				"dyeobs",
				"dyeos",
				"dyeoss",
				"dyeong",
				"dyeoj",
				"dyeoc",
				"dyeok",
				"dyeot",
				"dyeop",
				"dyeoh",
				"dye",
				"dyeg",
				"dyegg",
				"dyegs",
				"dyen",
				"dyenj",
				"dyenh",
				"dyed",
				"dyel",
				"dyelg",
				"dyelm",
				"dyelb",
				"dyels",
				"dyelt",
				"dyelp",
				"dyelh",
				"dyem",
				"dyeb",
				"dyebs",
				"dyes",
				"dyess",
				"dyeng",
				"dyej",
				"dyec",
				"dyek",
				"dyet",
				"dyep",
				"dyeh",
				"do",
				"dog",
				"dogg",
				"dogs",
				"don",
				"donj",
				"donh",
				"dod",
				"dol",
				"dolg",
				"dolm",
				"dolb",
				"dols",
				"dolt",
				"dolp",
				"dolh",
				"dom",
				"dob",
				"dobs",
				"dos",
				"doss",
				"dong",
				"doj",
				"doc",
				"dok",
				"dot",
				"dop",
				"doh",
				"dwa",
				"dwag",
				"dwagg",
				"dwags",
				"dwan",
				"dwanj",
				"dwanh",
				"dwad",
				"dwal",
				"dwalg",
				"dwalm",
				"dwalb",
				"dwals",
				"dwalt",
				"dwalp",
				"dwalh",
				"dwam",
				"dwab",
				"dwabs",
				"dwas",
				"dwass",
				"dwang",
				"dwaj",
				"dwac",
				"dwak",
				"dwat",
				"dwap",
				"dwah",
				"dwae",
				"dwaeg",
				"dwaegg",
				"dwaegs"
			],
			[
				"dwaen",
				"dwaenj",
				"dwaenh",
				"dwaed",
				"dwael",
				"dwaelg",
				"dwaelm",
				"dwaelb",
				"dwaels",
				"dwaelt",
				"dwaelp",
				"dwaelh",
				"dwaem",
				"dwaeb",
				"dwaebs",
				"dwaes",
				"dwaess",
				"dwaeng",
				"dwaej",
				"dwaec",
				"dwaek",
				"dwaet",
				"dwaep",
				"dwaeh",
				"doe",
				"doeg",
				"doegg",
				"doegs",
				"doen",
				"doenj",
				"doenh",
				"doed",
				"doel",
				"doelg",
				"doelm",
				"doelb",
				"doels",
				"doelt",
				"doelp",
				"doelh",
				"doem",
				"doeb",
				"doebs",
				"does",
				"doess",
				"doeng",
				"doej",
				"doec",
				"doek",
				"doet",
				"doep",
				"doeh",
				"dyo",
				"dyog",
				"dyogg",
				"dyogs",
				"dyon",
				"dyonj",
				"dyonh",
				"dyod",
				"dyol",
				"dyolg",
				"dyolm",
				"dyolb",
				"dyols",
				"dyolt",
				"dyolp",
				"dyolh",
				"dyom",
				"dyob",
				"dyobs",
				"dyos",
				"dyoss",
				"dyong",
				"dyoj",
				"dyoc",
				"dyok",
				"dyot",
				"dyop",
				"dyoh",
				"du",
				"dug",
				"dugg",
				"dugs",
				"dun",
				"dunj",
				"dunh",
				"dud",
				"dul",
				"dulg",
				"dulm",
				"dulb",
				"duls",
				"dult",
				"dulp",
				"dulh",
				"dum",
				"dub",
				"dubs",
				"dus",
				"duss",
				"dung",
				"duj",
				"duc",
				"duk",
				"dut",
				"dup",
				"duh",
				"dweo",
				"dweog",
				"dweogg",
				"dweogs",
				"dweon",
				"dweonj",
				"dweonh",
				"dweod",
				"dweol",
				"dweolg",
				"dweolm",
				"dweolb",
				"dweols",
				"dweolt",
				"dweolp",
				"dweolh",
				"dweom",
				"dweob",
				"dweobs",
				"dweos",
				"dweoss",
				"dweong",
				"dweoj",
				"dweoc",
				"dweok",
				"dweot",
				"dweop",
				"dweoh",
				"dwe",
				"dweg",
				"dwegg",
				"dwegs",
				"dwen",
				"dwenj",
				"dwenh",
				"dwed",
				"dwel",
				"dwelg",
				"dwelm",
				"dwelb",
				"dwels",
				"dwelt",
				"dwelp",
				"dwelh",
				"dwem",
				"dweb",
				"dwebs",
				"dwes",
				"dwess",
				"dweng",
				"dwej",
				"dwec",
				"dwek",
				"dwet",
				"dwep",
				"dweh",
				"dwi",
				"dwig",
				"dwigg",
				"dwigs",
				"dwin",
				"dwinj",
				"dwinh",
				"dwid",
				"dwil",
				"dwilg",
				"dwilm",
				"dwilb",
				"dwils",
				"dwilt",
				"dwilp",
				"dwilh",
				"dwim",
				"dwib",
				"dwibs",
				"dwis",
				"dwiss",
				"dwing",
				"dwij",
				"dwic",
				"dwik",
				"dwit",
				"dwip",
				"dwih",
				"dyu",
				"dyug",
				"dyugg",
				"dyugs",
				"dyun",
				"dyunj",
				"dyunh",
				"dyud",
				"dyul",
				"dyulg",
				"dyulm",
				"dyulb",
				"dyuls",
				"dyult",
				"dyulp",
				"dyulh",
				"dyum",
				"dyub",
				"dyubs",
				"dyus",
				"dyuss",
				"dyung",
				"dyuj",
				"dyuc",
				"dyuk",
				"dyut",
				"dyup",
				"dyuh",
				"deu",
				"deug",
				"deugg",
				"deugs",
				"deun",
				"deunj",
				"deunh",
				"deud",
				"deul",
				"deulg",
				"deulm",
				"deulb",
				"deuls",
				"deult",
				"deulp",
				"deulh",
				"deum",
				"deub",
				"deubs",
				"deus",
				"deuss",
				"deung",
				"deuj",
				"deuc",
				"deuk",
				"deut",
				"deup",
				"deuh",
				"dyi",
				"dyig",
				"dyigg",
				"dyigs",
				"dyin",
				"dyinj",
				"dyinh",
				"dyid"
			],
			[
				"dyil",
				"dyilg",
				"dyilm",
				"dyilb",
				"dyils",
				"dyilt",
				"dyilp",
				"dyilh",
				"dyim",
				"dyib",
				"dyibs",
				"dyis",
				"dyiss",
				"dying",
				"dyij",
				"dyic",
				"dyik",
				"dyit",
				"dyip",
				"dyih",
				"di",
				"dig",
				"digg",
				"digs",
				"din",
				"dinj",
				"dinh",
				"did",
				"dil",
				"dilg",
				"dilm",
				"dilb",
				"dils",
				"dilt",
				"dilp",
				"dilh",
				"dim",
				"dib",
				"dibs",
				"dis",
				"diss",
				"ding",
				"dij",
				"dic",
				"dik",
				"dit",
				"dip",
				"dih",
				"dda",
				"ddag",
				"ddagg",
				"ddags",
				"ddan",
				"ddanj",
				"ddanh",
				"ddad",
				"ddal",
				"ddalg",
				"ddalm",
				"ddalb",
				"ddals",
				"ddalt",
				"ddalp",
				"ddalh",
				"ddam",
				"ddab",
				"ddabs",
				"ddas",
				"ddass",
				"ddang",
				"ddaj",
				"ddac",
				"ddak",
				"ddat",
				"ddap",
				"ddah",
				"ddae",
				"ddaeg",
				"ddaegg",
				"ddaegs",
				"ddaen",
				"ddaenj",
				"ddaenh",
				"ddaed",
				"ddael",
				"ddaelg",
				"ddaelm",
				"ddaelb",
				"ddaels",
				"ddaelt",
				"ddaelp",
				"ddaelh",
				"ddaem",
				"ddaeb",
				"ddaebs",
				"ddaes",
				"ddaess",
				"ddaeng",
				"ddaej",
				"ddaec",
				"ddaek",
				"ddaet",
				"ddaep",
				"ddaeh",
				"ddya",
				"ddyag",
				"ddyagg",
				"ddyags",
				"ddyan",
				"ddyanj",
				"ddyanh",
				"ddyad",
				"ddyal",
				"ddyalg",
				"ddyalm",
				"ddyalb",
				"ddyals",
				"ddyalt",
				"ddyalp",
				"ddyalh",
				"ddyam",
				"ddyab",
				"ddyabs",
				"ddyas",
				"ddyass",
				"ddyang",
				"ddyaj",
				"ddyac",
				"ddyak",
				"ddyat",
				"ddyap",
				"ddyah",
				"ddyae",
				"ddyaeg",
				"ddyaegg",
				"ddyaegs",
				"ddyaen",
				"ddyaenj",
				"ddyaenh",
				"ddyaed",
				"ddyael",
				"ddyaelg",
				"ddyaelm",
				"ddyaelb",
				"ddyaels",
				"ddyaelt",
				"ddyaelp",
				"ddyaelh",
				"ddyaem",
				"ddyaeb",
				"ddyaebs",
				"ddyaes",
				"ddyaess",
				"ddyaeng",
				"ddyaej",
				"ddyaec",
				"ddyaek",
				"ddyaet",
				"ddyaep",
				"ddyaeh",
				"ddeo",
				"ddeog",
				"ddeogg",
				"ddeogs",
				"ddeon",
				"ddeonj",
				"ddeonh",
				"ddeod",
				"ddeol",
				"ddeolg",
				"ddeolm",
				"ddeolb",
				"ddeols",
				"ddeolt",
				"ddeolp",
				"ddeolh",
				"ddeom",
				"ddeob",
				"ddeobs",
				"ddeos",
				"ddeoss",
				"ddeong",
				"ddeoj",
				"ddeoc",
				"ddeok",
				"ddeot",
				"ddeop",
				"ddeoh",
				"dde",
				"ddeg",
				"ddegg",
				"ddegs",
				"dden",
				"ddenj",
				"ddenh",
				"dded",
				"ddel",
				"ddelg",
				"ddelm",
				"ddelb",
				"ddels",
				"ddelt",
				"ddelp",
				"ddelh",
				"ddem",
				"ddeb",
				"ddebs",
				"ddes",
				"ddess",
				"ddeng",
				"ddej",
				"ddec",
				"ddek",
				"ddet",
				"ddep",
				"ddeh",
				"ddyeo",
				"ddyeog",
				"ddyeogg",
				"ddyeogs",
				"ddyeon",
				"ddyeonj",
				"ddyeonh",
				"ddyeod",
				"ddyeol",
				"ddyeolg",
				"ddyeolm",
				"ddyeolb",
				"ddyeols",
				"ddyeolt",
				"ddyeolp",
				"ddyeolh",
				"ddyeom",
				"ddyeob",
				"ddyeobs",
				"ddyeos",
				"ddyeoss",
				"ddyeong",
				"ddyeoj",
				"ddyeoc",
				"ddyeok",
				"ddyeot",
				"ddyeop",
				"ddyeoh",
				"ddye",
				"ddyeg",
				"ddyegg",
				"ddyegs",
				"ddyen",
				"ddyenj",
				"ddyenh",
				"ddyed",
				"ddyel",
				"ddyelg",
				"ddyelm",
				"ddyelb"
			],
			[
				"ddyels",
				"ddyelt",
				"ddyelp",
				"ddyelh",
				"ddyem",
				"ddyeb",
				"ddyebs",
				"ddyes",
				"ddyess",
				"ddyeng",
				"ddyej",
				"ddyec",
				"ddyek",
				"ddyet",
				"ddyep",
				"ddyeh",
				"ddo",
				"ddog",
				"ddogg",
				"ddogs",
				"ddon",
				"ddonj",
				"ddonh",
				"ddod",
				"ddol",
				"ddolg",
				"ddolm",
				"ddolb",
				"ddols",
				"ddolt",
				"ddolp",
				"ddolh",
				"ddom",
				"ddob",
				"ddobs",
				"ddos",
				"ddoss",
				"ddong",
				"ddoj",
				"ddoc",
				"ddok",
				"ddot",
				"ddop",
				"ddoh",
				"ddwa",
				"ddwag",
				"ddwagg",
				"ddwags",
				"ddwan",
				"ddwanj",
				"ddwanh",
				"ddwad",
				"ddwal",
				"ddwalg",
				"ddwalm",
				"ddwalb",
				"ddwals",
				"ddwalt",
				"ddwalp",
				"ddwalh",
				"ddwam",
				"ddwab",
				"ddwabs",
				"ddwas",
				"ddwass",
				"ddwang",
				"ddwaj",
				"ddwac",
				"ddwak",
				"ddwat",
				"ddwap",
				"ddwah",
				"ddwae",
				"ddwaeg",
				"ddwaegg",
				"ddwaegs",
				"ddwaen",
				"ddwaenj",
				"ddwaenh",
				"ddwaed",
				"ddwael",
				"ddwaelg",
				"ddwaelm",
				"ddwaelb",
				"ddwaels",
				"ddwaelt",
				"ddwaelp",
				"ddwaelh",
				"ddwaem",
				"ddwaeb",
				"ddwaebs",
				"ddwaes",
				"ddwaess",
				"ddwaeng",
				"ddwaej",
				"ddwaec",
				"ddwaek",
				"ddwaet",
				"ddwaep",
				"ddwaeh",
				"ddoe",
				"ddoeg",
				"ddoegg",
				"ddoegs",
				"ddoen",
				"ddoenj",
				"ddoenh",
				"ddoed",
				"ddoel",
				"ddoelg",
				"ddoelm",
				"ddoelb",
				"ddoels",
				"ddoelt",
				"ddoelp",
				"ddoelh",
				"ddoem",
				"ddoeb",
				"ddoebs",
				"ddoes",
				"ddoess",
				"ddoeng",
				"ddoej",
				"ddoec",
				"ddoek",
				"ddoet",
				"ddoep",
				"ddoeh",
				"ddyo",
				"ddyog",
				"ddyogg",
				"ddyogs",
				"ddyon",
				"ddyonj",
				"ddyonh",
				"ddyod",
				"ddyol",
				"ddyolg",
				"ddyolm",
				"ddyolb",
				"ddyols",
				"ddyolt",
				"ddyolp",
				"ddyolh",
				"ddyom",
				"ddyob",
				"ddyobs",
				"ddyos",
				"ddyoss",
				"ddyong",
				"ddyoj",
				"ddyoc",
				"ddyok",
				"ddyot",
				"ddyop",
				"ddyoh",
				"ddu",
				"ddug",
				"ddugg",
				"ddugs",
				"ddun",
				"ddunj",
				"ddunh",
				"ddud",
				"ddul",
				"ddulg",
				"ddulm",
				"ddulb",
				"dduls",
				"ddult",
				"ddulp",
				"ddulh",
				"ddum",
				"ddub",
				"ddubs",
				"ddus",
				"dduss",
				"ddung",
				"dduj",
				"dduc",
				"dduk",
				"ddut",
				"ddup",
				"dduh",
				"ddweo",
				"ddweog",
				"ddweogg",
				"ddweogs",
				"ddweon",
				"ddweonj",
				"ddweonh",
				"ddweod",
				"ddweol",
				"ddweolg",
				"ddweolm",
				"ddweolb",
				"ddweols",
				"ddweolt",
				"ddweolp",
				"ddweolh",
				"ddweom",
				"ddweob",
				"ddweobs",
				"ddweos",
				"ddweoss",
				"ddweong",
				"ddweoj",
				"ddweoc",
				"ddweok",
				"ddweot",
				"ddweop",
				"ddweoh",
				"ddwe",
				"ddweg",
				"ddwegg",
				"ddwegs",
				"ddwen",
				"ddwenj",
				"ddwenh",
				"ddwed",
				"ddwel",
				"ddwelg",
				"ddwelm",
				"ddwelb",
				"ddwels",
				"ddwelt",
				"ddwelp",
				"ddwelh",
				"ddwem",
				"ddweb",
				"ddwebs",
				"ddwes",
				"ddwess",
				"ddweng",
				"ddwej",
				"ddwec",
				"ddwek",
				"ddwet",
				"ddwep",
				"ddweh",
				"ddwi",
				"ddwig",
				"ddwigg",
				"ddwigs",
				"ddwin",
				"ddwinj",
				"ddwinh",
				"ddwid",
				"ddwil",
				"ddwilg",
				"ddwilm",
				"ddwilb",
				"ddwils",
				"ddwilt",
				"ddwilp",
				"ddwilh"
			],
			[
				"ddwim",
				"ddwib",
				"ddwibs",
				"ddwis",
				"ddwiss",
				"ddwing",
				"ddwij",
				"ddwic",
				"ddwik",
				"ddwit",
				"ddwip",
				"ddwih",
				"ddyu",
				"ddyug",
				"ddyugg",
				"ddyugs",
				"ddyun",
				"ddyunj",
				"ddyunh",
				"ddyud",
				"ddyul",
				"ddyulg",
				"ddyulm",
				"ddyulb",
				"ddyuls",
				"ddyult",
				"ddyulp",
				"ddyulh",
				"ddyum",
				"ddyub",
				"ddyubs",
				"ddyus",
				"ddyuss",
				"ddyung",
				"ddyuj",
				"ddyuc",
				"ddyuk",
				"ddyut",
				"ddyup",
				"ddyuh",
				"ddeu",
				"ddeug",
				"ddeugg",
				"ddeugs",
				"ddeun",
				"ddeunj",
				"ddeunh",
				"ddeud",
				"ddeul",
				"ddeulg",
				"ddeulm",
				"ddeulb",
				"ddeuls",
				"ddeult",
				"ddeulp",
				"ddeulh",
				"ddeum",
				"ddeub",
				"ddeubs",
				"ddeus",
				"ddeuss",
				"ddeung",
				"ddeuj",
				"ddeuc",
				"ddeuk",
				"ddeut",
				"ddeup",
				"ddeuh",
				"ddyi",
				"ddyig",
				"ddyigg",
				"ddyigs",
				"ddyin",
				"ddyinj",
				"ddyinh",
				"ddyid",
				"ddyil",
				"ddyilg",
				"ddyilm",
				"ddyilb",
				"ddyils",
				"ddyilt",
				"ddyilp",
				"ddyilh",
				"ddyim",
				"ddyib",
				"ddyibs",
				"ddyis",
				"ddyiss",
				"ddying",
				"ddyij",
				"ddyic",
				"ddyik",
				"ddyit",
				"ddyip",
				"ddyih",
				"ddi",
				"ddig",
				"ddigg",
				"ddigs",
				"ddin",
				"ddinj",
				"ddinh",
				"ddid",
				"ddil",
				"ddilg",
				"ddilm",
				"ddilb",
				"ddils",
				"ddilt",
				"ddilp",
				"ddilh",
				"ddim",
				"ddib",
				"ddibs",
				"ddis",
				"ddiss",
				"dding",
				"ddij",
				"ddic",
				"ddik",
				"ddit",
				"ddip",
				"ddih",
				"ra",
				"rag",
				"ragg",
				"rags",
				"ran",
				"ranj",
				"ranh",
				"rad",
				"ral",
				"ralg",
				"ralm",
				"ralb",
				"rals",
				"ralt",
				"ralp",
				"ralh",
				"ram",
				"rab",
				"rabs",
				"ras",
				"rass",
				"rang",
				"raj",
				"rac",
				"rak",
				"rat",
				"rap",
				"rah",
				"rae",
				"raeg",
				"raegg",
				"raegs",
				"raen",
				"raenj",
				"raenh",
				"raed",
				"rael",
				"raelg",
				"raelm",
				"raelb",
				"raels",
				"raelt",
				"raelp",
				"raelh",
				"raem",
				"raeb",
				"raebs",
				"raes",
				"raess",
				"raeng",
				"raej",
				"raec",
				"raek",
				"raet",
				"raep",
				"raeh",
				"rya",
				"ryag",
				"ryagg",
				"ryags",
				"ryan",
				"ryanj",
				"ryanh",
				"ryad",
				"ryal",
				"ryalg",
				"ryalm",
				"ryalb",
				"ryals",
				"ryalt",
				"ryalp",
				"ryalh",
				"ryam",
				"ryab",
				"ryabs",
				"ryas",
				"ryass",
				"ryang",
				"ryaj",
				"ryac",
				"ryak",
				"ryat",
				"ryap",
				"ryah",
				"ryae",
				"ryaeg",
				"ryaegg",
				"ryaegs",
				"ryaen",
				"ryaenj",
				"ryaenh",
				"ryaed",
				"ryael",
				"ryaelg",
				"ryaelm",
				"ryaelb",
				"ryaels",
				"ryaelt",
				"ryaelp",
				"ryaelh",
				"ryaem",
				"ryaeb",
				"ryaebs",
				"ryaes",
				"ryaess",
				"ryaeng",
				"ryaej",
				"ryaec",
				"ryaek",
				"ryaet",
				"ryaep",
				"ryaeh",
				"reo",
				"reog",
				"reogg",
				"reogs",
				"reon",
				"reonj",
				"reonh",
				"reod",
				"reol",
				"reolg",
				"reolm",
				"reolb",
				"reols",
				"reolt",
				"reolp",
				"reolh",
				"reom",
				"reob",
				"reobs",
				"reos"
			],
			[
				"reoss",
				"reong",
				"reoj",
				"reoc",
				"reok",
				"reot",
				"reop",
				"reoh",
				"re",
				"reg",
				"regg",
				"regs",
				"ren",
				"renj",
				"renh",
				"red",
				"rel",
				"relg",
				"relm",
				"relb",
				"rels",
				"relt",
				"relp",
				"relh",
				"rem",
				"reb",
				"rebs",
				"res",
				"ress",
				"reng",
				"rej",
				"rec",
				"rek",
				"ret",
				"rep",
				"reh",
				"ryeo",
				"ryeog",
				"ryeogg",
				"ryeogs",
				"ryeon",
				"ryeonj",
				"ryeonh",
				"ryeod",
				"ryeol",
				"ryeolg",
				"ryeolm",
				"ryeolb",
				"ryeols",
				"ryeolt",
				"ryeolp",
				"ryeolh",
				"ryeom",
				"ryeob",
				"ryeobs",
				"ryeos",
				"ryeoss",
				"ryeong",
				"ryeoj",
				"ryeoc",
				"ryeok",
				"ryeot",
				"ryeop",
				"ryeoh",
				"rye",
				"ryeg",
				"ryegg",
				"ryegs",
				"ryen",
				"ryenj",
				"ryenh",
				"ryed",
				"ryel",
				"ryelg",
				"ryelm",
				"ryelb",
				"ryels",
				"ryelt",
				"ryelp",
				"ryelh",
				"ryem",
				"ryeb",
				"ryebs",
				"ryes",
				"ryess",
				"ryeng",
				"ryej",
				"ryec",
				"ryek",
				"ryet",
				"ryep",
				"ryeh",
				"ro",
				"rog",
				"rogg",
				"rogs",
				"ron",
				"ronj",
				"ronh",
				"rod",
				"rol",
				"rolg",
				"rolm",
				"rolb",
				"rols",
				"rolt",
				"rolp",
				"rolh",
				"rom",
				"rob",
				"robs",
				"ros",
				"ross",
				"rong",
				"roj",
				"roc",
				"rok",
				"rot",
				"rop",
				"roh",
				"rwa",
				"rwag",
				"rwagg",
				"rwags",
				"rwan",
				"rwanj",
				"rwanh",
				"rwad",
				"rwal",
				"rwalg",
				"rwalm",
				"rwalb",
				"rwals",
				"rwalt",
				"rwalp",
				"rwalh",
				"rwam",
				"rwab",
				"rwabs",
				"rwas",
				"rwass",
				"rwang",
				"rwaj",
				"rwac",
				"rwak",
				"rwat",
				"rwap",
				"rwah",
				"rwae",
				"rwaeg",
				"rwaegg",
				"rwaegs",
				"rwaen",
				"rwaenj",
				"rwaenh",
				"rwaed",
				"rwael",
				"rwaelg",
				"rwaelm",
				"rwaelb",
				"rwaels",
				"rwaelt",
				"rwaelp",
				"rwaelh",
				"rwaem",
				"rwaeb",
				"rwaebs",
				"rwaes",
				"rwaess",
				"rwaeng",
				"rwaej",
				"rwaec",
				"rwaek",
				"rwaet",
				"rwaep",
				"rwaeh",
				"roe",
				"roeg",
				"roegg",
				"roegs",
				"roen",
				"roenj",
				"roenh",
				"roed",
				"roel",
				"roelg",
				"roelm",
				"roelb",
				"roels",
				"roelt",
				"roelp",
				"roelh",
				"roem",
				"roeb",
				"roebs",
				"roes",
				"roess",
				"roeng",
				"roej",
				"roec",
				"roek",
				"roet",
				"roep",
				"roeh",
				"ryo",
				"ryog",
				"ryogg",
				"ryogs",
				"ryon",
				"ryonj",
				"ryonh",
				"ryod",
				"ryol",
				"ryolg",
				"ryolm",
				"ryolb",
				"ryols",
				"ryolt",
				"ryolp",
				"ryolh",
				"ryom",
				"ryob",
				"ryobs",
				"ryos",
				"ryoss",
				"ryong",
				"ryoj",
				"ryoc",
				"ryok",
				"ryot",
				"ryop",
				"ryoh",
				"ru",
				"rug",
				"rugg",
				"rugs",
				"run",
				"runj",
				"runh",
				"rud",
				"rul",
				"rulg",
				"rulm",
				"rulb",
				"ruls",
				"rult",
				"rulp",
				"rulh",
				"rum",
				"rub",
				"rubs",
				"rus",
				"russ",
				"rung",
				"ruj",
				"ruc"
			],
			[
				"ruk",
				"rut",
				"rup",
				"ruh",
				"rweo",
				"rweog",
				"rweogg",
				"rweogs",
				"rweon",
				"rweonj",
				"rweonh",
				"rweod",
				"rweol",
				"rweolg",
				"rweolm",
				"rweolb",
				"rweols",
				"rweolt",
				"rweolp",
				"rweolh",
				"rweom",
				"rweob",
				"rweobs",
				"rweos",
				"rweoss",
				"rweong",
				"rweoj",
				"rweoc",
				"rweok",
				"rweot",
				"rweop",
				"rweoh",
				"rwe",
				"rweg",
				"rwegg",
				"rwegs",
				"rwen",
				"rwenj",
				"rwenh",
				"rwed",
				"rwel",
				"rwelg",
				"rwelm",
				"rwelb",
				"rwels",
				"rwelt",
				"rwelp",
				"rwelh",
				"rwem",
				"rweb",
				"rwebs",
				"rwes",
				"rwess",
				"rweng",
				"rwej",
				"rwec",
				"rwek",
				"rwet",
				"rwep",
				"rweh",
				"rwi",
				"rwig",
				"rwigg",
				"rwigs",
				"rwin",
				"rwinj",
				"rwinh",
				"rwid",
				"rwil",
				"rwilg",
				"rwilm",
				"rwilb",
				"rwils",
				"rwilt",
				"rwilp",
				"rwilh",
				"rwim",
				"rwib",
				"rwibs",
				"rwis",
				"rwiss",
				"rwing",
				"rwij",
				"rwic",
				"rwik",
				"rwit",
				"rwip",
				"rwih",
				"ryu",
				"ryug",
				"ryugg",
				"ryugs",
				"ryun",
				"ryunj",
				"ryunh",
				"ryud",
				"ryul",
				"ryulg",
				"ryulm",
				"ryulb",
				"ryuls",
				"ryult",
				"ryulp",
				"ryulh",
				"ryum",
				"ryub",
				"ryubs",
				"ryus",
				"ryuss",
				"ryung",
				"ryuj",
				"ryuc",
				"ryuk",
				"ryut",
				"ryup",
				"ryuh",
				"reu",
				"reug",
				"reugg",
				"reugs",
				"reun",
				"reunj",
				"reunh",
				"reud",
				"reul",
				"reulg",
				"reulm",
				"reulb",
				"reuls",
				"reult",
				"reulp",
				"reulh",
				"reum",
				"reub",
				"reubs",
				"reus",
				"reuss",
				"reung",
				"reuj",
				"reuc",
				"reuk",
				"reut",
				"reup",
				"reuh",
				"ryi",
				"ryig",
				"ryigg",
				"ryigs",
				"ryin",
				"ryinj",
				"ryinh",
				"ryid",
				"ryil",
				"ryilg",
				"ryilm",
				"ryilb",
				"ryils",
				"ryilt",
				"ryilp",
				"ryilh",
				"ryim",
				"ryib",
				"ryibs",
				"ryis",
				"ryiss",
				"rying",
				"ryij",
				"ryic",
				"ryik",
				"ryit",
				"ryip",
				"ryih",
				"ri",
				"rig",
				"rigg",
				"rigs",
				"rin",
				"rinj",
				"rinh",
				"rid",
				"ril",
				"rilg",
				"rilm",
				"rilb",
				"rils",
				"rilt",
				"rilp",
				"rilh",
				"rim",
				"rib",
				"ribs",
				"ris",
				"riss",
				"ring",
				"rij",
				"ric",
				"rik",
				"rit",
				"rip",
				"rih",
				"ma",
				"mag",
				"magg",
				"mags",
				"man",
				"manj",
				"manh",
				"mad",
				"mal",
				"malg",
				"malm",
				"malb",
				"mals",
				"malt",
				"malp",
				"malh",
				"mam",
				"mab",
				"mabs",
				"mas",
				"mass",
				"mang",
				"maj",
				"mac",
				"mak",
				"mat",
				"map",
				"mah",
				"mae",
				"maeg",
				"maegg",
				"maegs",
				"maen",
				"maenj",
				"maenh",
				"maed",
				"mael",
				"maelg",
				"maelm",
				"maelb",
				"maels",
				"maelt",
				"maelp",
				"maelh",
				"maem",
				"maeb",
				"maebs",
				"maes",
				"maess",
				"maeng",
				"maej",
				"maec",
				"maek",
				"maet",
				"maep",
				"maeh"
			],
			[
				"mya",
				"myag",
				"myagg",
				"myags",
				"myan",
				"myanj",
				"myanh",
				"myad",
				"myal",
				"myalg",
				"myalm",
				"myalb",
				"myals",
				"myalt",
				"myalp",
				"myalh",
				"myam",
				"myab",
				"myabs",
				"myas",
				"myass",
				"myang",
				"myaj",
				"myac",
				"myak",
				"myat",
				"myap",
				"myah",
				"myae",
				"myaeg",
				"myaegg",
				"myaegs",
				"myaen",
				"myaenj",
				"myaenh",
				"myaed",
				"myael",
				"myaelg",
				"myaelm",
				"myaelb",
				"myaels",
				"myaelt",
				"myaelp",
				"myaelh",
				"myaem",
				"myaeb",
				"myaebs",
				"myaes",
				"myaess",
				"myaeng",
				"myaej",
				"myaec",
				"myaek",
				"myaet",
				"myaep",
				"myaeh",
				"meo",
				"meog",
				"meogg",
				"meogs",
				"meon",
				"meonj",
				"meonh",
				"meod",
				"meol",
				"meolg",
				"meolm",
				"meolb",
				"meols",
				"meolt",
				"meolp",
				"meolh",
				"meom",
				"meob",
				"meobs",
				"meos",
				"meoss",
				"meong",
				"meoj",
				"meoc",
				"meok",
				"meot",
				"meop",
				"meoh",
				"me",
				"meg",
				"megg",
				"megs",
				"men",
				"menj",
				"menh",
				"med",
				"mel",
				"melg",
				"melm",
				"melb",
				"mels",
				"melt",
				"melp",
				"melh",
				"mem",
				"meb",
				"mebs",
				"mes",
				"mess",
				"meng",
				"mej",
				"mec",
				"mek",
				"met",
				"mep",
				"meh",
				"myeo",
				"myeog",
				"myeogg",
				"myeogs",
				"myeon",
				"myeonj",
				"myeonh",
				"myeod",
				"myeol",
				"myeolg",
				"myeolm",
				"myeolb",
				"myeols",
				"myeolt",
				"myeolp",
				"myeolh",
				"myeom",
				"myeob",
				"myeobs",
				"myeos",
				"myeoss",
				"myeong",
				"myeoj",
				"myeoc",
				"myeok",
				"myeot",
				"myeop",
				"myeoh",
				"mye",
				"myeg",
				"myegg",
				"myegs",
				"myen",
				"myenj",
				"myenh",
				"myed",
				"myel",
				"myelg",
				"myelm",
				"myelb",
				"myels",
				"myelt",
				"myelp",
				"myelh",
				"myem",
				"myeb",
				"myebs",
				"myes",
				"myess",
				"myeng",
				"myej",
				"myec",
				"myek",
				"myet",
				"myep",
				"myeh",
				"mo",
				"mog",
				"mogg",
				"mogs",
				"mon",
				"monj",
				"monh",
				"mod",
				"mol",
				"molg",
				"molm",
				"molb",
				"mols",
				"molt",
				"molp",
				"molh",
				"mom",
				"mob",
				"mobs",
				"mos",
				"moss",
				"mong",
				"moj",
				"moc",
				"mok",
				"mot",
				"mop",
				"moh",
				"mwa",
				"mwag",
				"mwagg",
				"mwags",
				"mwan",
				"mwanj",
				"mwanh",
				"mwad",
				"mwal",
				"mwalg",
				"mwalm",
				"mwalb",
				"mwals",
				"mwalt",
				"mwalp",
				"mwalh",
				"mwam",
				"mwab",
				"mwabs",
				"mwas",
				"mwass",
				"mwang",
				"mwaj",
				"mwac",
				"mwak",
				"mwat",
				"mwap",
				"mwah",
				"mwae",
				"mwaeg",
				"mwaegg",
				"mwaegs",
				"mwaen",
				"mwaenj",
				"mwaenh",
				"mwaed",
				"mwael",
				"mwaelg",
				"mwaelm",
				"mwaelb",
				"mwaels",
				"mwaelt",
				"mwaelp",
				"mwaelh",
				"mwaem",
				"mwaeb",
				"mwaebs",
				"mwaes",
				"mwaess",
				"mwaeng",
				"mwaej",
				"mwaec",
				"mwaek",
				"mwaet",
				"mwaep",
				"mwaeh",
				"moe",
				"moeg",
				"moegg",
				"moegs"
			],
			[
				"moen",
				"moenj",
				"moenh",
				"moed",
				"moel",
				"moelg",
				"moelm",
				"moelb",
				"moels",
				"moelt",
				"moelp",
				"moelh",
				"moem",
				"moeb",
				"moebs",
				"moes",
				"moess",
				"moeng",
				"moej",
				"moec",
				"moek",
				"moet",
				"moep",
				"moeh",
				"myo",
				"myog",
				"myogg",
				"myogs",
				"myon",
				"myonj",
				"myonh",
				"myod",
				"myol",
				"myolg",
				"myolm",
				"myolb",
				"myols",
				"myolt",
				"myolp",
				"myolh",
				"myom",
				"myob",
				"myobs",
				"myos",
				"myoss",
				"myong",
				"myoj",
				"myoc",
				"myok",
				"myot",
				"myop",
				"myoh",
				"mu",
				"mug",
				"mugg",
				"mugs",
				"mun",
				"munj",
				"munh",
				"mud",
				"mul",
				"mulg",
				"mulm",
				"mulb",
				"muls",
				"mult",
				"mulp",
				"mulh",
				"mum",
				"mub",
				"mubs",
				"mus",
				"muss",
				"mung",
				"muj",
				"muc",
				"muk",
				"mut",
				"mup",
				"muh",
				"mweo",
				"mweog",
				"mweogg",
				"mweogs",
				"mweon",
				"mweonj",
				"mweonh",
				"mweod",
				"mweol",
				"mweolg",
				"mweolm",
				"mweolb",
				"mweols",
				"mweolt",
				"mweolp",
				"mweolh",
				"mweom",
				"mweob",
				"mweobs",
				"mweos",
				"mweoss",
				"mweong",
				"mweoj",
				"mweoc",
				"mweok",
				"mweot",
				"mweop",
				"mweoh",
				"mwe",
				"mweg",
				"mwegg",
				"mwegs",
				"mwen",
				"mwenj",
				"mwenh",
				"mwed",
				"mwel",
				"mwelg",
				"mwelm",
				"mwelb",
				"mwels",
				"mwelt",
				"mwelp",
				"mwelh",
				"mwem",
				"mweb",
				"mwebs",
				"mwes",
				"mwess",
				"mweng",
				"mwej",
				"mwec",
				"mwek",
				"mwet",
				"mwep",
				"mweh",
				"mwi",
				"mwig",
				"mwigg",
				"mwigs",
				"mwin",
				"mwinj",
				"mwinh",
				"mwid",
				"mwil",
				"mwilg",
				"mwilm",
				"mwilb",
				"mwils",
				"mwilt",
				"mwilp",
				"mwilh",
				"mwim",
				"mwib",
				"mwibs",
				"mwis",
				"mwiss",
				"mwing",
				"mwij",
				"mwic",
				"mwik",
				"mwit",
				"mwip",
				"mwih",
				"myu",
				"myug",
				"myugg",
				"myugs",
				"myun",
				"myunj",
				"myunh",
				"myud",
				"myul",
				"myulg",
				"myulm",
				"myulb",
				"myuls",
				"myult",
				"myulp",
				"myulh",
				"myum",
				"myub",
				"myubs",
				"myus",
				"myuss",
				"myung",
				"myuj",
				"myuc",
				"myuk",
				"myut",
				"myup",
				"myuh",
				"meu",
				"meug",
				"meugg",
				"meugs",
				"meun",
				"meunj",
				"meunh",
				"meud",
				"meul",
				"meulg",
				"meulm",
				"meulb",
				"meuls",
				"meult",
				"meulp",
				"meulh",
				"meum",
				"meub",
				"meubs",
				"meus",
				"meuss",
				"meung",
				"meuj",
				"meuc",
				"meuk",
				"meut",
				"meup",
				"meuh",
				"myi",
				"myig",
				"myigg",
				"myigs",
				"myin",
				"myinj",
				"myinh",
				"myid",
				"myil",
				"myilg",
				"myilm",
				"myilb",
				"myils",
				"myilt",
				"myilp",
				"myilh",
				"myim",
				"myib",
				"myibs",
				"myis",
				"myiss",
				"mying",
				"myij",
				"myic",
				"myik",
				"myit",
				"myip",
				"myih",
				"mi",
				"mig",
				"migg",
				"migs",
				"min",
				"minj",
				"minh",
				"mid"
			],
			[
				"mil",
				"milg",
				"milm",
				"milb",
				"mils",
				"milt",
				"milp",
				"milh",
				"mim",
				"mib",
				"mibs",
				"mis",
				"miss",
				"ming",
				"mij",
				"mic",
				"mik",
				"mit",
				"mip",
				"mih",
				"ba",
				"bag",
				"bagg",
				"bags",
				"ban",
				"banj",
				"banh",
				"bad",
				"bal",
				"balg",
				"balm",
				"balb",
				"bals",
				"balt",
				"balp",
				"balh",
				"bam",
				"bab",
				"babs",
				"bas",
				"bass",
				"bang",
				"baj",
				"bac",
				"bak",
				"bat",
				"bap",
				"bah",
				"bae",
				"baeg",
				"baegg",
				"baegs",
				"baen",
				"baenj",
				"baenh",
				"baed",
				"bael",
				"baelg",
				"baelm",
				"baelb",
				"baels",
				"baelt",
				"baelp",
				"baelh",
				"baem",
				"baeb",
				"baebs",
				"baes",
				"baess",
				"baeng",
				"baej",
				"baec",
				"baek",
				"baet",
				"baep",
				"baeh",
				"bya",
				"byag",
				"byagg",
				"byags",
				"byan",
				"byanj",
				"byanh",
				"byad",
				"byal",
				"byalg",
				"byalm",
				"byalb",
				"byals",
				"byalt",
				"byalp",
				"byalh",
				"byam",
				"byab",
				"byabs",
				"byas",
				"byass",
				"byang",
				"byaj",
				"byac",
				"byak",
				"byat",
				"byap",
				"byah",
				"byae",
				"byaeg",
				"byaegg",
				"byaegs",
				"byaen",
				"byaenj",
				"byaenh",
				"byaed",
				"byael",
				"byaelg",
				"byaelm",
				"byaelb",
				"byaels",
				"byaelt",
				"byaelp",
				"byaelh",
				"byaem",
				"byaeb",
				"byaebs",
				"byaes",
				"byaess",
				"byaeng",
				"byaej",
				"byaec",
				"byaek",
				"byaet",
				"byaep",
				"byaeh",
				"beo",
				"beog",
				"beogg",
				"beogs",
				"beon",
				"beonj",
				"beonh",
				"beod",
				"beol",
				"beolg",
				"beolm",
				"beolb",
				"beols",
				"beolt",
				"beolp",
				"beolh",
				"beom",
				"beob",
				"beobs",
				"beos",
				"beoss",
				"beong",
				"beoj",
				"beoc",
				"beok",
				"beot",
				"beop",
				"beoh",
				"be",
				"beg",
				"begg",
				"begs",
				"ben",
				"benj",
				"benh",
				"bed",
				"bel",
				"belg",
				"belm",
				"belb",
				"bels",
				"belt",
				"belp",
				"belh",
				"bem",
				"beb",
				"bebs",
				"bes",
				"bess",
				"beng",
				"bej",
				"bec",
				"bek",
				"bet",
				"bep",
				"beh",
				"byeo",
				"byeog",
				"byeogg",
				"byeogs",
				"byeon",
				"byeonj",
				"byeonh",
				"byeod",
				"byeol",
				"byeolg",
				"byeolm",
				"byeolb",
				"byeols",
				"byeolt",
				"byeolp",
				"byeolh",
				"byeom",
				"byeob",
				"byeobs",
				"byeos",
				"byeoss",
				"byeong",
				"byeoj",
				"byeoc",
				"byeok",
				"byeot",
				"byeop",
				"byeoh",
				"bye",
				"byeg",
				"byegg",
				"byegs",
				"byen",
				"byenj",
				"byenh",
				"byed",
				"byel",
				"byelg",
				"byelm",
				"byelb",
				"byels",
				"byelt",
				"byelp",
				"byelh",
				"byem",
				"byeb",
				"byebs",
				"byes",
				"byess",
				"byeng",
				"byej",
				"byec",
				"byek",
				"byet",
				"byep",
				"byeh",
				"bo",
				"bog",
				"bogg",
				"bogs",
				"bon",
				"bonj",
				"bonh",
				"bod",
				"bol",
				"bolg",
				"bolm",
				"bolb"
			],
			[
				"bols",
				"bolt",
				"bolp",
				"bolh",
				"bom",
				"bob",
				"bobs",
				"bos",
				"boss",
				"bong",
				"boj",
				"boc",
				"bok",
				"bot",
				"bop",
				"boh",
				"bwa",
				"bwag",
				"bwagg",
				"bwags",
				"bwan",
				"bwanj",
				"bwanh",
				"bwad",
				"bwal",
				"bwalg",
				"bwalm",
				"bwalb",
				"bwals",
				"bwalt",
				"bwalp",
				"bwalh",
				"bwam",
				"bwab",
				"bwabs",
				"bwas",
				"bwass",
				"bwang",
				"bwaj",
				"bwac",
				"bwak",
				"bwat",
				"bwap",
				"bwah",
				"bwae",
				"bwaeg",
				"bwaegg",
				"bwaegs",
				"bwaen",
				"bwaenj",
				"bwaenh",
				"bwaed",
				"bwael",
				"bwaelg",
				"bwaelm",
				"bwaelb",
				"bwaels",
				"bwaelt",
				"bwaelp",
				"bwaelh",
				"bwaem",
				"bwaeb",
				"bwaebs",
				"bwaes",
				"bwaess",
				"bwaeng",
				"bwaej",
				"bwaec",
				"bwaek",
				"bwaet",
				"bwaep",
				"bwaeh",
				"boe",
				"boeg",
				"boegg",
				"boegs",
				"boen",
				"boenj",
				"boenh",
				"boed",
				"boel",
				"boelg",
				"boelm",
				"boelb",
				"boels",
				"boelt",
				"boelp",
				"boelh",
				"boem",
				"boeb",
				"boebs",
				"boes",
				"boess",
				"boeng",
				"boej",
				"boec",
				"boek",
				"boet",
				"boep",
				"boeh",
				"byo",
				"byog",
				"byogg",
				"byogs",
				"byon",
				"byonj",
				"byonh",
				"byod",
				"byol",
				"byolg",
				"byolm",
				"byolb",
				"byols",
				"byolt",
				"byolp",
				"byolh",
				"byom",
				"byob",
				"byobs",
				"byos",
				"byoss",
				"byong",
				"byoj",
				"byoc",
				"byok",
				"byot",
				"byop",
				"byoh",
				"bu",
				"bug",
				"bugg",
				"bugs",
				"bun",
				"bunj",
				"bunh",
				"bud",
				"bul",
				"bulg",
				"bulm",
				"bulb",
				"buls",
				"bult",
				"bulp",
				"bulh",
				"bum",
				"bub",
				"bubs",
				"bus",
				"buss",
				"bung",
				"buj",
				"buc",
				"buk",
				"but",
				"bup",
				"buh",
				"bweo",
				"bweog",
				"bweogg",
				"bweogs",
				"bweon",
				"bweonj",
				"bweonh",
				"bweod",
				"bweol",
				"bweolg",
				"bweolm",
				"bweolb",
				"bweols",
				"bweolt",
				"bweolp",
				"bweolh",
				"bweom",
				"bweob",
				"bweobs",
				"bweos",
				"bweoss",
				"bweong",
				"bweoj",
				"bweoc",
				"bweok",
				"bweot",
				"bweop",
				"bweoh",
				"bwe",
				"bweg",
				"bwegg",
				"bwegs",
				"bwen",
				"bwenj",
				"bwenh",
				"bwed",
				"bwel",
				"bwelg",
				"bwelm",
				"bwelb",
				"bwels",
				"bwelt",
				"bwelp",
				"bwelh",
				"bwem",
				"bweb",
				"bwebs",
				"bwes",
				"bwess",
				"bweng",
				"bwej",
				"bwec",
				"bwek",
				"bwet",
				"bwep",
				"bweh",
				"bwi",
				"bwig",
				"bwigg",
				"bwigs",
				"bwin",
				"bwinj",
				"bwinh",
				"bwid",
				"bwil",
				"bwilg",
				"bwilm",
				"bwilb",
				"bwils",
				"bwilt",
				"bwilp",
				"bwilh",
				"bwim",
				"bwib",
				"bwibs",
				"bwis",
				"bwiss",
				"bwing",
				"bwij",
				"bwic",
				"bwik",
				"bwit",
				"bwip",
				"bwih",
				"byu",
				"byug",
				"byugg",
				"byugs",
				"byun",
				"byunj",
				"byunh",
				"byud",
				"byul",
				"byulg",
				"byulm",
				"byulb",
				"byuls",
				"byult",
				"byulp",
				"byulh"
			],
			[
				"byum",
				"byub",
				"byubs",
				"byus",
				"byuss",
				"byung",
				"byuj",
				"byuc",
				"byuk",
				"byut",
				"byup",
				"byuh",
				"beu",
				"beug",
				"beugg",
				"beugs",
				"beun",
				"beunj",
				"beunh",
				"beud",
				"beul",
				"beulg",
				"beulm",
				"beulb",
				"beuls",
				"beult",
				"beulp",
				"beulh",
				"beum",
				"beub",
				"beubs",
				"beus",
				"beuss",
				"beung",
				"beuj",
				"beuc",
				"beuk",
				"beut",
				"beup",
				"beuh",
				"byi",
				"byig",
				"byigg",
				"byigs",
				"byin",
				"byinj",
				"byinh",
				"byid",
				"byil",
				"byilg",
				"byilm",
				"byilb",
				"byils",
				"byilt",
				"byilp",
				"byilh",
				"byim",
				"byib",
				"byibs",
				"byis",
				"byiss",
				"bying",
				"byij",
				"byic",
				"byik",
				"byit",
				"byip",
				"byih",
				"bi",
				"big",
				"bigg",
				"bigs",
				"bin",
				"binj",
				"binh",
				"bid",
				"bil",
				"bilg",
				"bilm",
				"bilb",
				"bils",
				"bilt",
				"bilp",
				"bilh",
				"bim",
				"bib",
				"bibs",
				"bis",
				"biss",
				"bing",
				"bij",
				"bic",
				"bik",
				"bit",
				"bip",
				"bih",
				"bba",
				"bbag",
				"bbagg",
				"bbags",
				"bban",
				"bbanj",
				"bbanh",
				"bbad",
				"bbal",
				"bbalg",
				"bbalm",
				"bbalb",
				"bbals",
				"bbalt",
				"bbalp",
				"bbalh",
				"bbam",
				"bbab",
				"bbabs",
				"bbas",
				"bbass",
				"bbang",
				"bbaj",
				"bbac",
				"bbak",
				"bbat",
				"bbap",
				"bbah",
				"bbae",
				"bbaeg",
				"bbaegg",
				"bbaegs",
				"bbaen",
				"bbaenj",
				"bbaenh",
				"bbaed",
				"bbael",
				"bbaelg",
				"bbaelm",
				"bbaelb",
				"bbaels",
				"bbaelt",
				"bbaelp",
				"bbaelh",
				"bbaem",
				"bbaeb",
				"bbaebs",
				"bbaes",
				"bbaess",
				"bbaeng",
				"bbaej",
				"bbaec",
				"bbaek",
				"bbaet",
				"bbaep",
				"bbaeh",
				"bbya",
				"bbyag",
				"bbyagg",
				"bbyags",
				"bbyan",
				"bbyanj",
				"bbyanh",
				"bbyad",
				"bbyal",
				"bbyalg",
				"bbyalm",
				"bbyalb",
				"bbyals",
				"bbyalt",
				"bbyalp",
				"bbyalh",
				"bbyam",
				"bbyab",
				"bbyabs",
				"bbyas",
				"bbyass",
				"bbyang",
				"bbyaj",
				"bbyac",
				"bbyak",
				"bbyat",
				"bbyap",
				"bbyah",
				"bbyae",
				"bbyaeg",
				"bbyaegg",
				"bbyaegs",
				"bbyaen",
				"bbyaenj",
				"bbyaenh",
				"bbyaed",
				"bbyael",
				"bbyaelg",
				"bbyaelm",
				"bbyaelb",
				"bbyaels",
				"bbyaelt",
				"bbyaelp",
				"bbyaelh",
				"bbyaem",
				"bbyaeb",
				"bbyaebs",
				"bbyaes",
				"bbyaess",
				"bbyaeng",
				"bbyaej",
				"bbyaec",
				"bbyaek",
				"bbyaet",
				"bbyaep",
				"bbyaeh",
				"bbeo",
				"bbeog",
				"bbeogg",
				"bbeogs",
				"bbeon",
				"bbeonj",
				"bbeonh",
				"bbeod",
				"bbeol",
				"bbeolg",
				"bbeolm",
				"bbeolb",
				"bbeols",
				"bbeolt",
				"bbeolp",
				"bbeolh",
				"bbeom",
				"bbeob",
				"bbeobs",
				"bbeos",
				"bbeoss",
				"bbeong",
				"bbeoj",
				"bbeoc",
				"bbeok",
				"bbeot",
				"bbeop",
				"bbeoh",
				"bbe",
				"bbeg",
				"bbegg",
				"bbegs",
				"bben",
				"bbenj",
				"bbenh",
				"bbed",
				"bbel",
				"bbelg",
				"bbelm",
				"bbelb",
				"bbels",
				"bbelt",
				"bbelp",
				"bbelh",
				"bbem",
				"bbeb",
				"bbebs",
				"bbes"
			],
			[
				"bbess",
				"bbeng",
				"bbej",
				"bbec",
				"bbek",
				"bbet",
				"bbep",
				"bbeh",
				"bbyeo",
				"bbyeog",
				"bbyeogg",
				"bbyeogs",
				"bbyeon",
				"bbyeonj",
				"bbyeonh",
				"bbyeod",
				"bbyeol",
				"bbyeolg",
				"bbyeolm",
				"bbyeolb",
				"bbyeols",
				"bbyeolt",
				"bbyeolp",
				"bbyeolh",
				"bbyeom",
				"bbyeob",
				"bbyeobs",
				"bbyeos",
				"bbyeoss",
				"bbyeong",
				"bbyeoj",
				"bbyeoc",
				"bbyeok",
				"bbyeot",
				"bbyeop",
				"bbyeoh",
				"bbye",
				"bbyeg",
				"bbyegg",
				"bbyegs",
				"bbyen",
				"bbyenj",
				"bbyenh",
				"bbyed",
				"bbyel",
				"bbyelg",
				"bbyelm",
				"bbyelb",
				"bbyels",
				"bbyelt",
				"bbyelp",
				"bbyelh",
				"bbyem",
				"bbyeb",
				"bbyebs",
				"bbyes",
				"bbyess",
				"bbyeng",
				"bbyej",
				"bbyec",
				"bbyek",
				"bbyet",
				"bbyep",
				"bbyeh",
				"bbo",
				"bbog",
				"bbogg",
				"bbogs",
				"bbon",
				"bbonj",
				"bbonh",
				"bbod",
				"bbol",
				"bbolg",
				"bbolm",
				"bbolb",
				"bbols",
				"bbolt",
				"bbolp",
				"bbolh",
				"bbom",
				"bbob",
				"bbobs",
				"bbos",
				"bboss",
				"bbong",
				"bboj",
				"bboc",
				"bbok",
				"bbot",
				"bbop",
				"bboh",
				"bbwa",
				"bbwag",
				"bbwagg",
				"bbwags",
				"bbwan",
				"bbwanj",
				"bbwanh",
				"bbwad",
				"bbwal",
				"bbwalg",
				"bbwalm",
				"bbwalb",
				"bbwals",
				"bbwalt",
				"bbwalp",
				"bbwalh",
				"bbwam",
				"bbwab",
				"bbwabs",
				"bbwas",
				"bbwass",
				"bbwang",
				"bbwaj",
				"bbwac",
				"bbwak",
				"bbwat",
				"bbwap",
				"bbwah",
				"bbwae",
				"bbwaeg",
				"bbwaegg",
				"bbwaegs",
				"bbwaen",
				"bbwaenj",
				"bbwaenh",
				"bbwaed",
				"bbwael",
				"bbwaelg",
				"bbwaelm",
				"bbwaelb",
				"bbwaels",
				"bbwaelt",
				"bbwaelp",
				"bbwaelh",
				"bbwaem",
				"bbwaeb",
				"bbwaebs",
				"bbwaes",
				"bbwaess",
				"bbwaeng",
				"bbwaej",
				"bbwaec",
				"bbwaek",
				"bbwaet",
				"bbwaep",
				"bbwaeh",
				"bboe",
				"bboeg",
				"bboegg",
				"bboegs",
				"bboen",
				"bboenj",
				"bboenh",
				"bboed",
				"bboel",
				"bboelg",
				"bboelm",
				"bboelb",
				"bboels",
				"bboelt",
				"bboelp",
				"bboelh",
				"bboem",
				"bboeb",
				"bboebs",
				"bboes",
				"bboess",
				"bboeng",
				"bboej",
				"bboec",
				"bboek",
				"bboet",
				"bboep",
				"bboeh",
				"bbyo",
				"bbyog",
				"bbyogg",
				"bbyogs",
				"bbyon",
				"bbyonj",
				"bbyonh",
				"bbyod",
				"bbyol",
				"bbyolg",
				"bbyolm",
				"bbyolb",
				"bbyols",
				"bbyolt",
				"bbyolp",
				"bbyolh",
				"bbyom",
				"bbyob",
				"bbyobs",
				"bbyos",
				"bbyoss",
				"bbyong",
				"bbyoj",
				"bbyoc",
				"bbyok",
				"bbyot",
				"bbyop",
				"bbyoh",
				"bbu",
				"bbug",
				"bbugg",
				"bbugs",
				"bbun",
				"bbunj",
				"bbunh",
				"bbud",
				"bbul",
				"bbulg",
				"bbulm",
				"bbulb",
				"bbuls",
				"bbult",
				"bbulp",
				"bbulh",
				"bbum",
				"bbub",
				"bbubs",
				"bbus",
				"bbuss",
				"bbung",
				"bbuj",
				"bbuc",
				"bbuk",
				"bbut",
				"bbup",
				"bbuh",
				"bbweo",
				"bbweog",
				"bbweogg",
				"bbweogs",
				"bbweon",
				"bbweonj",
				"bbweonh",
				"bbweod",
				"bbweol",
				"bbweolg",
				"bbweolm",
				"bbweolb",
				"bbweols",
				"bbweolt",
				"bbweolp",
				"bbweolh",
				"bbweom",
				"bbweob",
				"bbweobs",
				"bbweos",
				"bbweoss",
				"bbweong",
				"bbweoj",
				"bbweoc"
			],
			[
				"bbweok",
				"bbweot",
				"bbweop",
				"bbweoh",
				"bbwe",
				"bbweg",
				"bbwegg",
				"bbwegs",
				"bbwen",
				"bbwenj",
				"bbwenh",
				"bbwed",
				"bbwel",
				"bbwelg",
				"bbwelm",
				"bbwelb",
				"bbwels",
				"bbwelt",
				"bbwelp",
				"bbwelh",
				"bbwem",
				"bbweb",
				"bbwebs",
				"bbwes",
				"bbwess",
				"bbweng",
				"bbwej",
				"bbwec",
				"bbwek",
				"bbwet",
				"bbwep",
				"bbweh",
				"bbwi",
				"bbwig",
				"bbwigg",
				"bbwigs",
				"bbwin",
				"bbwinj",
				"bbwinh",
				"bbwid",
				"bbwil",
				"bbwilg",
				"bbwilm",
				"bbwilb",
				"bbwils",
				"bbwilt",
				"bbwilp",
				"bbwilh",
				"bbwim",
				"bbwib",
				"bbwibs",
				"bbwis",
				"bbwiss",
				"bbwing",
				"bbwij",
				"bbwic",
				"bbwik",
				"bbwit",
				"bbwip",
				"bbwih",
				"bbyu",
				"bbyug",
				"bbyugg",
				"bbyugs",
				"bbyun",
				"bbyunj",
				"bbyunh",
				"bbyud",
				"bbyul",
				"bbyulg",
				"bbyulm",
				"bbyulb",
				"bbyuls",
				"bbyult",
				"bbyulp",
				"bbyulh",
				"bbyum",
				"bbyub",
				"bbyubs",
				"bbyus",
				"bbyuss",
				"bbyung",
				"bbyuj",
				"bbyuc",
				"bbyuk",
				"bbyut",
				"bbyup",
				"bbyuh",
				"bbeu",
				"bbeug",
				"bbeugg",
				"bbeugs",
				"bbeun",
				"bbeunj",
				"bbeunh",
				"bbeud",
				"bbeul",
				"bbeulg",
				"bbeulm",
				"bbeulb",
				"bbeuls",
				"bbeult",
				"bbeulp",
				"bbeulh",
				"bbeum",
				"bbeub",
				"bbeubs",
				"bbeus",
				"bbeuss",
				"bbeung",
				"bbeuj",
				"bbeuc",
				"bbeuk",
				"bbeut",
				"bbeup",
				"bbeuh",
				"bbyi",
				"bbyig",
				"bbyigg",
				"bbyigs",
				"bbyin",
				"bbyinj",
				"bbyinh",
				"bbyid",
				"bbyil",
				"bbyilg",
				"bbyilm",
				"bbyilb",
				"bbyils",
				"bbyilt",
				"bbyilp",
				"bbyilh",
				"bbyim",
				"bbyib",
				"bbyibs",
				"bbyis",
				"bbyiss",
				"bbying",
				"bbyij",
				"bbyic",
				"bbyik",
				"bbyit",
				"bbyip",
				"bbyih",
				"bbi",
				"bbig",
				"bbigg",
				"bbigs",
				"bbin",
				"bbinj",
				"bbinh",
				"bbid",
				"bbil",
				"bbilg",
				"bbilm",
				"bbilb",
				"bbils",
				"bbilt",
				"bbilp",
				"bbilh",
				"bbim",
				"bbib",
				"bbibs",
				"bbis",
				"bbiss",
				"bbing",
				"bbij",
				"bbic",
				"bbik",
				"bbit",
				"bbip",
				"bbih",
				"sa",
				"sag",
				"sagg",
				"sags",
				"san",
				"sanj",
				"sanh",
				"sad",
				"sal",
				"salg",
				"salm",
				"salb",
				"sals",
				"salt",
				"salp",
				"salh",
				"sam",
				"sab",
				"sabs",
				"sas",
				"sass",
				"sang",
				"saj",
				"sac",
				"sak",
				"sat",
				"sap",
				"sah",
				"sae",
				"saeg",
				"saegg",
				"saegs",
				"saen",
				"saenj",
				"saenh",
				"saed",
				"sael",
				"saelg",
				"saelm",
				"saelb",
				"saels",
				"saelt",
				"saelp",
				"saelh",
				"saem",
				"saeb",
				"saebs",
				"saes",
				"saess",
				"saeng",
				"saej",
				"saec",
				"saek",
				"saet",
				"saep",
				"saeh",
				"sya",
				"syag",
				"syagg",
				"syags",
				"syan",
				"syanj",
				"syanh",
				"syad",
				"syal",
				"syalg",
				"syalm",
				"syalb",
				"syals",
				"syalt",
				"syalp",
				"syalh",
				"syam",
				"syab",
				"syabs",
				"syas",
				"syass",
				"syang",
				"syaj",
				"syac",
				"syak",
				"syat",
				"syap",
				"syah"
			],
			[
				"syae",
				"syaeg",
				"syaegg",
				"syaegs",
				"syaen",
				"syaenj",
				"syaenh",
				"syaed",
				"syael",
				"syaelg",
				"syaelm",
				"syaelb",
				"syaels",
				"syaelt",
				"syaelp",
				"syaelh",
				"syaem",
				"syaeb",
				"syaebs",
				"syaes",
				"syaess",
				"syaeng",
				"syaej",
				"syaec",
				"syaek",
				"syaet",
				"syaep",
				"syaeh",
				"seo",
				"seog",
				"seogg",
				"seogs",
				"seon",
				"seonj",
				"seonh",
				"seod",
				"seol",
				"seolg",
				"seolm",
				"seolb",
				"seols",
				"seolt",
				"seolp",
				"seolh",
				"seom",
				"seob",
				"seobs",
				"seos",
				"seoss",
				"seong",
				"seoj",
				"seoc",
				"seok",
				"seot",
				"seop",
				"seoh",
				"se",
				"seg",
				"segg",
				"segs",
				"sen",
				"senj",
				"senh",
				"sed",
				"sel",
				"selg",
				"selm",
				"selb",
				"sels",
				"selt",
				"selp",
				"selh",
				"sem",
				"seb",
				"sebs",
				"ses",
				"sess",
				"seng",
				"sej",
				"sec",
				"sek",
				"set",
				"sep",
				"seh",
				"syeo",
				"syeog",
				"syeogg",
				"syeogs",
				"syeon",
				"syeonj",
				"syeonh",
				"syeod",
				"syeol",
				"syeolg",
				"syeolm",
				"syeolb",
				"syeols",
				"syeolt",
				"syeolp",
				"syeolh",
				"syeom",
				"syeob",
				"syeobs",
				"syeos",
				"syeoss",
				"syeong",
				"syeoj",
				"syeoc",
				"syeok",
				"syeot",
				"syeop",
				"syeoh",
				"sye",
				"syeg",
				"syegg",
				"syegs",
				"syen",
				"syenj",
				"syenh",
				"syed",
				"syel",
				"syelg",
				"syelm",
				"syelb",
				"syels",
				"syelt",
				"syelp",
				"syelh",
				"syem",
				"syeb",
				"syebs",
				"syes",
				"syess",
				"syeng",
				"syej",
				"syec",
				"syek",
				"syet",
				"syep",
				"syeh",
				"so",
				"sog",
				"sogg",
				"sogs",
				"son",
				"sonj",
				"sonh",
				"sod",
				"sol",
				"solg",
				"solm",
				"solb",
				"sols",
				"solt",
				"solp",
				"solh",
				"som",
				"sob",
				"sobs",
				"sos",
				"soss",
				"song",
				"soj",
				"soc",
				"sok",
				"sot",
				"sop",
				"soh",
				"swa",
				"swag",
				"swagg",
				"swags",
				"swan",
				"swanj",
				"swanh",
				"swad",
				"swal",
				"swalg",
				"swalm",
				"swalb",
				"swals",
				"swalt",
				"swalp",
				"swalh",
				"swam",
				"swab",
				"swabs",
				"swas",
				"swass",
				"swang",
				"swaj",
				"swac",
				"swak",
				"swat",
				"swap",
				"swah",
				"swae",
				"swaeg",
				"swaegg",
				"swaegs",
				"swaen",
				"swaenj",
				"swaenh",
				"swaed",
				"swael",
				"swaelg",
				"swaelm",
				"swaelb",
				"swaels",
				"swaelt",
				"swaelp",
				"swaelh",
				"swaem",
				"swaeb",
				"swaebs",
				"swaes",
				"swaess",
				"swaeng",
				"swaej",
				"swaec",
				"swaek",
				"swaet",
				"swaep",
				"swaeh",
				"soe",
				"soeg",
				"soegg",
				"soegs",
				"soen",
				"soenj",
				"soenh",
				"soed",
				"soel",
				"soelg",
				"soelm",
				"soelb",
				"soels",
				"soelt",
				"soelp",
				"soelh",
				"soem",
				"soeb",
				"soebs",
				"soes",
				"soess",
				"soeng",
				"soej",
				"soec",
				"soek",
				"soet",
				"soep",
				"soeh",
				"syo",
				"syog",
				"syogg",
				"syogs"
			],
			[
				"syon",
				"syonj",
				"syonh",
				"syod",
				"syol",
				"syolg",
				"syolm",
				"syolb",
				"syols",
				"syolt",
				"syolp",
				"syolh",
				"syom",
				"syob",
				"syobs",
				"syos",
				"syoss",
				"syong",
				"syoj",
				"syoc",
				"syok",
				"syot",
				"syop",
				"syoh",
				"su",
				"sug",
				"sugg",
				"sugs",
				"sun",
				"sunj",
				"sunh",
				"sud",
				"sul",
				"sulg",
				"sulm",
				"sulb",
				"suls",
				"sult",
				"sulp",
				"sulh",
				"sum",
				"sub",
				"subs",
				"sus",
				"suss",
				"sung",
				"suj",
				"suc",
				"suk",
				"sut",
				"sup",
				"suh",
				"sweo",
				"sweog",
				"sweogg",
				"sweogs",
				"sweon",
				"sweonj",
				"sweonh",
				"sweod",
				"sweol",
				"sweolg",
				"sweolm",
				"sweolb",
				"sweols",
				"sweolt",
				"sweolp",
				"sweolh",
				"sweom",
				"sweob",
				"sweobs",
				"sweos",
				"sweoss",
				"sweong",
				"sweoj",
				"sweoc",
				"sweok",
				"sweot",
				"sweop",
				"sweoh",
				"swe",
				"sweg",
				"swegg",
				"swegs",
				"swen",
				"swenj",
				"swenh",
				"swed",
				"swel",
				"swelg",
				"swelm",
				"swelb",
				"swels",
				"swelt",
				"swelp",
				"swelh",
				"swem",
				"sweb",
				"swebs",
				"swes",
				"swess",
				"sweng",
				"swej",
				"swec",
				"swek",
				"swet",
				"swep",
				"sweh",
				"swi",
				"swig",
				"swigg",
				"swigs",
				"swin",
				"swinj",
				"swinh",
				"swid",
				"swil",
				"swilg",
				"swilm",
				"swilb",
				"swils",
				"swilt",
				"swilp",
				"swilh",
				"swim",
				"swib",
				"swibs",
				"swis",
				"swiss",
				"swing",
				"swij",
				"swic",
				"swik",
				"swit",
				"swip",
				"swih",
				"syu",
				"syug",
				"syugg",
				"syugs",
				"syun",
				"syunj",
				"syunh",
				"syud",
				"syul",
				"syulg",
				"syulm",
				"syulb",
				"syuls",
				"syult",
				"syulp",
				"syulh",
				"syum",
				"syub",
				"syubs",
				"syus",
				"syuss",
				"syung",
				"syuj",
				"syuc",
				"syuk",
				"syut",
				"syup",
				"syuh",
				"seu",
				"seug",
				"seugg",
				"seugs",
				"seun",
				"seunj",
				"seunh",
				"seud",
				"seul",
				"seulg",
				"seulm",
				"seulb",
				"seuls",
				"seult",
				"seulp",
				"seulh",
				"seum",
				"seub",
				"seubs",
				"seus",
				"seuss",
				"seung",
				"seuj",
				"seuc",
				"seuk",
				"seut",
				"seup",
				"seuh",
				"syi",
				"syig",
				"syigg",
				"syigs",
				"syin",
				"syinj",
				"syinh",
				"syid",
				"syil",
				"syilg",
				"syilm",
				"syilb",
				"syils",
				"syilt",
				"syilp",
				"syilh",
				"syim",
				"syib",
				"syibs",
				"syis",
				"syiss",
				"sying",
				"syij",
				"syic",
				"syik",
				"syit",
				"syip",
				"syih",
				"si",
				"sig",
				"sigg",
				"sigs",
				"sin",
				"sinj",
				"sinh",
				"sid",
				"sil",
				"silg",
				"silm",
				"silb",
				"sils",
				"silt",
				"silp",
				"silh",
				"sim",
				"sib",
				"sibs",
				"sis",
				"siss",
				"sing",
				"sij",
				"sic",
				"sik",
				"sit",
				"sip",
				"sih",
				"ssa",
				"ssag",
				"ssagg",
				"ssags",
				"ssan",
				"ssanj",
				"ssanh",
				"ssad"
			],
			[
				"ssal",
				"ssalg",
				"ssalm",
				"ssalb",
				"ssals",
				"ssalt",
				"ssalp",
				"ssalh",
				"ssam",
				"ssab",
				"ssabs",
				"ssas",
				"ssass",
				"ssang",
				"ssaj",
				"ssac",
				"ssak",
				"ssat",
				"ssap",
				"ssah",
				"ssae",
				"ssaeg",
				"ssaegg",
				"ssaegs",
				"ssaen",
				"ssaenj",
				"ssaenh",
				"ssaed",
				"ssael",
				"ssaelg",
				"ssaelm",
				"ssaelb",
				"ssaels",
				"ssaelt",
				"ssaelp",
				"ssaelh",
				"ssaem",
				"ssaeb",
				"ssaebs",
				"ssaes",
				"ssaess",
				"ssaeng",
				"ssaej",
				"ssaec",
				"ssaek",
				"ssaet",
				"ssaep",
				"ssaeh",
				"ssya",
				"ssyag",
				"ssyagg",
				"ssyags",
				"ssyan",
				"ssyanj",
				"ssyanh",
				"ssyad",
				"ssyal",
				"ssyalg",
				"ssyalm",
				"ssyalb",
				"ssyals",
				"ssyalt",
				"ssyalp",
				"ssyalh",
				"ssyam",
				"ssyab",
				"ssyabs",
				"ssyas",
				"ssyass",
				"ssyang",
				"ssyaj",
				"ssyac",
				"ssyak",
				"ssyat",
				"ssyap",
				"ssyah",
				"ssyae",
				"ssyaeg",
				"ssyaegg",
				"ssyaegs",
				"ssyaen",
				"ssyaenj",
				"ssyaenh",
				"ssyaed",
				"ssyael",
				"ssyaelg",
				"ssyaelm",
				"ssyaelb",
				"ssyaels",
				"ssyaelt",
				"ssyaelp",
				"ssyaelh",
				"ssyaem",
				"ssyaeb",
				"ssyaebs",
				"ssyaes",
				"ssyaess",
				"ssyaeng",
				"ssyaej",
				"ssyaec",
				"ssyaek",
				"ssyaet",
				"ssyaep",
				"ssyaeh",
				"sseo",
				"sseog",
				"sseogg",
				"sseogs",
				"sseon",
				"sseonj",
				"sseonh",
				"sseod",
				"sseol",
				"sseolg",
				"sseolm",
				"sseolb",
				"sseols",
				"sseolt",
				"sseolp",
				"sseolh",
				"sseom",
				"sseob",
				"sseobs",
				"sseos",
				"sseoss",
				"sseong",
				"sseoj",
				"sseoc",
				"sseok",
				"sseot",
				"sseop",
				"sseoh",
				"sse",
				"sseg",
				"ssegg",
				"ssegs",
				"ssen",
				"ssenj",
				"ssenh",
				"ssed",
				"ssel",
				"sselg",
				"sselm",
				"sselb",
				"ssels",
				"sselt",
				"sselp",
				"sselh",
				"ssem",
				"sseb",
				"ssebs",
				"sses",
				"ssess",
				"sseng",
				"ssej",
				"ssec",
				"ssek",
				"sset",
				"ssep",
				"sseh",
				"ssyeo",
				"ssyeog",
				"ssyeogg",
				"ssyeogs",
				"ssyeon",
				"ssyeonj",
				"ssyeonh",
				"ssyeod",
				"ssyeol",
				"ssyeolg",
				"ssyeolm",
				"ssyeolb",
				"ssyeols",
				"ssyeolt",
				"ssyeolp",
				"ssyeolh",
				"ssyeom",
				"ssyeob",
				"ssyeobs",
				"ssyeos",
				"ssyeoss",
				"ssyeong",
				"ssyeoj",
				"ssyeoc",
				"ssyeok",
				"ssyeot",
				"ssyeop",
				"ssyeoh",
				"ssye",
				"ssyeg",
				"ssyegg",
				"ssyegs",
				"ssyen",
				"ssyenj",
				"ssyenh",
				"ssyed",
				"ssyel",
				"ssyelg",
				"ssyelm",
				"ssyelb",
				"ssyels",
				"ssyelt",
				"ssyelp",
				"ssyelh",
				"ssyem",
				"ssyeb",
				"ssyebs",
				"ssyes",
				"ssyess",
				"ssyeng",
				"ssyej",
				"ssyec",
				"ssyek",
				"ssyet",
				"ssyep",
				"ssyeh",
				"sso",
				"ssog",
				"ssogg",
				"ssogs",
				"sson",
				"ssonj",
				"ssonh",
				"ssod",
				"ssol",
				"ssolg",
				"ssolm",
				"ssolb",
				"ssols",
				"ssolt",
				"ssolp",
				"ssolh",
				"ssom",
				"ssob",
				"ssobs",
				"ssos",
				"ssoss",
				"ssong",
				"ssoj",
				"ssoc",
				"ssok",
				"ssot",
				"ssop",
				"ssoh",
				"sswa",
				"sswag",
				"sswagg",
				"sswags",
				"sswan",
				"sswanj",
				"sswanh",
				"sswad",
				"sswal",
				"sswalg",
				"sswalm",
				"sswalb"
			],
			[
				"sswals",
				"sswalt",
				"sswalp",
				"sswalh",
				"sswam",
				"sswab",
				"sswabs",
				"sswas",
				"sswass",
				"sswang",
				"sswaj",
				"sswac",
				"sswak",
				"sswat",
				"sswap",
				"sswah",
				"sswae",
				"sswaeg",
				"sswaegg",
				"sswaegs",
				"sswaen",
				"sswaenj",
				"sswaenh",
				"sswaed",
				"sswael",
				"sswaelg",
				"sswaelm",
				"sswaelb",
				"sswaels",
				"sswaelt",
				"sswaelp",
				"sswaelh",
				"sswaem",
				"sswaeb",
				"sswaebs",
				"sswaes",
				"sswaess",
				"sswaeng",
				"sswaej",
				"sswaec",
				"sswaek",
				"sswaet",
				"sswaep",
				"sswaeh",
				"ssoe",
				"ssoeg",
				"ssoegg",
				"ssoegs",
				"ssoen",
				"ssoenj",
				"ssoenh",
				"ssoed",
				"ssoel",
				"ssoelg",
				"ssoelm",
				"ssoelb",
				"ssoels",
				"ssoelt",
				"ssoelp",
				"ssoelh",
				"ssoem",
				"ssoeb",
				"ssoebs",
				"ssoes",
				"ssoess",
				"ssoeng",
				"ssoej",
				"ssoec",
				"ssoek",
				"ssoet",
				"ssoep",
				"ssoeh",
				"ssyo",
				"ssyog",
				"ssyogg",
				"ssyogs",
				"ssyon",
				"ssyonj",
				"ssyonh",
				"ssyod",
				"ssyol",
				"ssyolg",
				"ssyolm",
				"ssyolb",
				"ssyols",
				"ssyolt",
				"ssyolp",
				"ssyolh",
				"ssyom",
				"ssyob",
				"ssyobs",
				"ssyos",
				"ssyoss",
				"ssyong",
				"ssyoj",
				"ssyoc",
				"ssyok",
				"ssyot",
				"ssyop",
				"ssyoh",
				"ssu",
				"ssug",
				"ssugg",
				"ssugs",
				"ssun",
				"ssunj",
				"ssunh",
				"ssud",
				"ssul",
				"ssulg",
				"ssulm",
				"ssulb",
				"ssuls",
				"ssult",
				"ssulp",
				"ssulh",
				"ssum",
				"ssub",
				"ssubs",
				"ssus",
				"ssuss",
				"ssung",
				"ssuj",
				"ssuc",
				"ssuk",
				"ssut",
				"ssup",
				"ssuh",
				"ssweo",
				"ssweog",
				"ssweogg",
				"ssweogs",
				"ssweon",
				"ssweonj",
				"ssweonh",
				"ssweod",
				"ssweol",
				"ssweolg",
				"ssweolm",
				"ssweolb",
				"ssweols",
				"ssweolt",
				"ssweolp",
				"ssweolh",
				"ssweom",
				"ssweob",
				"ssweobs",
				"ssweos",
				"ssweoss",
				"ssweong",
				"ssweoj",
				"ssweoc",
				"ssweok",
				"ssweot",
				"ssweop",
				"ssweoh",
				"sswe",
				"ssweg",
				"sswegg",
				"sswegs",
				"sswen",
				"sswenj",
				"sswenh",
				"sswed",
				"sswel",
				"sswelg",
				"sswelm",
				"sswelb",
				"sswels",
				"sswelt",
				"sswelp",
				"sswelh",
				"sswem",
				"ssweb",
				"sswebs",
				"sswes",
				"sswess",
				"ssweng",
				"sswej",
				"sswec",
				"sswek",
				"sswet",
				"sswep",
				"ssweh",
				"sswi",
				"sswig",
				"sswigg",
				"sswigs",
				"sswin",
				"sswinj",
				"sswinh",
				"sswid",
				"sswil",
				"sswilg",
				"sswilm",
				"sswilb",
				"sswils",
				"sswilt",
				"sswilp",
				"sswilh",
				"sswim",
				"sswib",
				"sswibs",
				"sswis",
				"sswiss",
				"sswing",
				"sswij",
				"sswic",
				"sswik",
				"sswit",
				"sswip",
				"sswih",
				"ssyu",
				"ssyug",
				"ssyugg",
				"ssyugs",
				"ssyun",
				"ssyunj",
				"ssyunh",
				"ssyud",
				"ssyul",
				"ssyulg",
				"ssyulm",
				"ssyulb",
				"ssyuls",
				"ssyult",
				"ssyulp",
				"ssyulh",
				"ssyum",
				"ssyub",
				"ssyubs",
				"ssyus",
				"ssyuss",
				"ssyung",
				"ssyuj",
				"ssyuc",
				"ssyuk",
				"ssyut",
				"ssyup",
				"ssyuh",
				"sseu",
				"sseug",
				"sseugg",
				"sseugs",
				"sseun",
				"sseunj",
				"sseunh",
				"sseud",
				"sseul",
				"sseulg",
				"sseulm",
				"sseulb",
				"sseuls",
				"sseult",
				"sseulp",
				"sseulh"
			],
			[
				"sseum",
				"sseub",
				"sseubs",
				"sseus",
				"sseuss",
				"sseung",
				"sseuj",
				"sseuc",
				"sseuk",
				"sseut",
				"sseup",
				"sseuh",
				"ssyi",
				"ssyig",
				"ssyigg",
				"ssyigs",
				"ssyin",
				"ssyinj",
				"ssyinh",
				"ssyid",
				"ssyil",
				"ssyilg",
				"ssyilm",
				"ssyilb",
				"ssyils",
				"ssyilt",
				"ssyilp",
				"ssyilh",
				"ssyim",
				"ssyib",
				"ssyibs",
				"ssyis",
				"ssyiss",
				"ssying",
				"ssyij",
				"ssyic",
				"ssyik",
				"ssyit",
				"ssyip",
				"ssyih",
				"ssi",
				"ssig",
				"ssigg",
				"ssigs",
				"ssin",
				"ssinj",
				"ssinh",
				"ssid",
				"ssil",
				"ssilg",
				"ssilm",
				"ssilb",
				"ssils",
				"ssilt",
				"ssilp",
				"ssilh",
				"ssim",
				"ssib",
				"ssibs",
				"ssis",
				"ssiss",
				"ssing",
				"ssij",
				"ssic",
				"ssik",
				"ssit",
				"ssip",
				"ssih",
				"a",
				"ag",
				"agg",
				"ags",
				"an",
				"anj",
				"anh",
				"ad",
				"al",
				"alg",
				"alm",
				"alb",
				"als",
				"alt",
				"alp",
				"alh",
				"am",
				"ab",
				"abs",
				"as",
				"ass",
				"ang",
				"aj",
				"ac",
				"ak",
				"at",
				"ap",
				"ah",
				"ae",
				"aeg",
				"aegg",
				"aegs",
				"aen",
				"aenj",
				"aenh",
				"aed",
				"ael",
				"aelg",
				"aelm",
				"aelb",
				"aels",
				"aelt",
				"aelp",
				"aelh",
				"aem",
				"aeb",
				"aebs",
				"aes",
				"aess",
				"aeng",
				"aej",
				"aec",
				"aek",
				"aet",
				"aep",
				"aeh",
				"ya",
				"yag",
				"yagg",
				"yags",
				"yan",
				"yanj",
				"yanh",
				"yad",
				"yal",
				"yalg",
				"yalm",
				"yalb",
				"yals",
				"yalt",
				"yalp",
				"yalh",
				"yam",
				"yab",
				"yabs",
				"yas",
				"yass",
				"yang",
				"yaj",
				"yac",
				"yak",
				"yat",
				"yap",
				"yah",
				"yae",
				"yaeg",
				"yaegg",
				"yaegs",
				"yaen",
				"yaenj",
				"yaenh",
				"yaed",
				"yael",
				"yaelg",
				"yaelm",
				"yaelb",
				"yaels",
				"yaelt",
				"yaelp",
				"yaelh",
				"yaem",
				"yaeb",
				"yaebs",
				"yaes",
				"yaess",
				"yaeng",
				"yaej",
				"yaec",
				"yaek",
				"yaet",
				"yaep",
				"yaeh",
				"eo",
				"eog",
				"eogg",
				"eogs",
				"eon",
				"eonj",
				"eonh",
				"eod",
				"eol",
				"eolg",
				"eolm",
				"eolb",
				"eols",
				"eolt",
				"eolp",
				"eolh",
				"eom",
				"eob",
				"eobs",
				"eos",
				"eoss",
				"eong",
				"eoj",
				"eoc",
				"eok",
				"eot",
				"eop",
				"eoh",
				"e",
				"eg",
				"egg",
				"egs",
				"en",
				"enj",
				"enh",
				"ed",
				"el",
				"elg",
				"elm",
				"elb",
				"els",
				"elt",
				"elp",
				"elh",
				"em",
				"eb",
				"ebs",
				"es",
				"ess",
				"eng",
				"ej",
				"ec",
				"ek",
				"et",
				"ep",
				"eh",
				"yeo",
				"yeog",
				"yeogg",
				"yeogs",
				"yeon",
				"yeonj",
				"yeonh",
				"yeod",
				"yeol",
				"yeolg",
				"yeolm",
				"yeolb",
				"yeols",
				"yeolt",
				"yeolp",
				"yeolh",
				"yeom",
				"yeob",
				"yeobs",
				"yeos"
			],
			[
				"yeoss",
				"yeong",
				"yeoj",
				"yeoc",
				"yeok",
				"yeot",
				"yeop",
				"yeoh",
				"ye",
				"yeg",
				"yegg",
				"yegs",
				"yen",
				"yenj",
				"yenh",
				"yed",
				"yel",
				"yelg",
				"yelm",
				"yelb",
				"yels",
				"yelt",
				"yelp",
				"yelh",
				"yem",
				"yeb",
				"yebs",
				"yes",
				"yess",
				"yeng",
				"yej",
				"yec",
				"yek",
				"yet",
				"yep",
				"yeh",
				"o",
				"og",
				"ogg",
				"ogs",
				"on",
				"onj",
				"onh",
				"od",
				"ol",
				"olg",
				"olm",
				"olb",
				"ols",
				"olt",
				"olp",
				"olh",
				"om",
				"ob",
				"obs",
				"os",
				"oss",
				"ong",
				"oj",
				"oc",
				"ok",
				"ot",
				"op",
				"oh",
				"wa",
				"wag",
				"wagg",
				"wags",
				"wan",
				"wanj",
				"wanh",
				"wad",
				"wal",
				"walg",
				"walm",
				"walb",
				"wals",
				"walt",
				"walp",
				"walh",
				"wam",
				"wab",
				"wabs",
				"was",
				"wass",
				"wang",
				"waj",
				"wac",
				"wak",
				"wat",
				"wap",
				"wah",
				"wae",
				"waeg",
				"waegg",
				"waegs",
				"waen",
				"waenj",
				"waenh",
				"waed",
				"wael",
				"waelg",
				"waelm",
				"waelb",
				"waels",
				"waelt",
				"waelp",
				"waelh",
				"waem",
				"waeb",
				"waebs",
				"waes",
				"waess",
				"waeng",
				"waej",
				"waec",
				"waek",
				"waet",
				"waep",
				"waeh",
				"oe",
				"oeg",
				"oegg",
				"oegs",
				"oen",
				"oenj",
				"oenh",
				"oed",
				"oel",
				"oelg",
				"oelm",
				"oelb",
				"oels",
				"oelt",
				"oelp",
				"oelh",
				"oem",
				"oeb",
				"oebs",
				"oes",
				"oess",
				"oeng",
				"oej",
				"oec",
				"oek",
				"oet",
				"oep",
				"oeh",
				"yo",
				"yog",
				"yogg",
				"yogs",
				"yon",
				"yonj",
				"yonh",
				"yod",
				"yol",
				"yolg",
				"yolm",
				"yolb",
				"yols",
				"yolt",
				"yolp",
				"yolh",
				"yom",
				"yob",
				"yobs",
				"yos",
				"yoss",
				"yong",
				"yoj",
				"yoc",
				"yok",
				"yot",
				"yop",
				"yoh",
				"u",
				"ug",
				"ugg",
				"ugs",
				"un",
				"unj",
				"unh",
				"ud",
				"ul",
				"ulg",
				"ulm",
				"ulb",
				"uls",
				"ult",
				"ulp",
				"ulh",
				"um",
				"ub",
				"ubs",
				"us",
				"uss",
				"ung",
				"uj",
				"uc",
				"uk",
				"ut",
				"up",
				"uh",
				"weo",
				"weog",
				"weogg",
				"weogs",
				"weon",
				"weonj",
				"weonh",
				"weod",
				"weol",
				"weolg",
				"weolm",
				"weolb",
				"weols",
				"weolt",
				"weolp",
				"weolh",
				"weom",
				"weob",
				"weobs",
				"weos",
				"weoss",
				"weong",
				"weoj",
				"weoc",
				"weok",
				"weot",
				"weop",
				"weoh",
				"we",
				"weg",
				"wegg",
				"wegs",
				"wen",
				"wenj",
				"wenh",
				"wed",
				"wel",
				"welg",
				"welm",
				"welb",
				"wels",
				"welt",
				"welp",
				"welh",
				"wem",
				"web",
				"webs",
				"wes",
				"wess",
				"weng",
				"wej",
				"wec"
			],
			[
				"wek",
				"wet",
				"wep",
				"weh",
				"wi",
				"wig",
				"wigg",
				"wigs",
				"win",
				"winj",
				"winh",
				"wid",
				"wil",
				"wilg",
				"wilm",
				"wilb",
				"wils",
				"wilt",
				"wilp",
				"wilh",
				"wim",
				"wib",
				"wibs",
				"wis",
				"wiss",
				"wing",
				"wij",
				"wic",
				"wik",
				"wit",
				"wip",
				"wih",
				"yu",
				"yug",
				"yugg",
				"yugs",
				"yun",
				"yunj",
				"yunh",
				"yud",
				"yul",
				"yulg",
				"yulm",
				"yulb",
				"yuls",
				"yult",
				"yulp",
				"yulh",
				"yum",
				"yub",
				"yubs",
				"yus",
				"yuss",
				"yung",
				"yuj",
				"yuc",
				"yuk",
				"yut",
				"yup",
				"yuh",
				"eu",
				"eug",
				"eugg",
				"eugs",
				"eun",
				"eunj",
				"eunh",
				"eud",
				"eul",
				"eulg",
				"eulm",
				"eulb",
				"euls",
				"eult",
				"eulp",
				"eulh",
				"eum",
				"eub",
				"eubs",
				"eus",
				"euss",
				"eung",
				"euj",
				"euc",
				"euk",
				"eut",
				"eup",
				"euh",
				"yi",
				"yig",
				"yigg",
				"yigs",
				"yin",
				"yinj",
				"yinh",
				"yid",
				"yil",
				"yilg",
				"yilm",
				"yilb",
				"yils",
				"yilt",
				"yilp",
				"yilh",
				"yim",
				"yib",
				"yibs",
				"yis",
				"yiss",
				"ying",
				"yij",
				"yic",
				"yik",
				"yit",
				"yip",
				"yih",
				"i",
				"ig",
				"igg",
				"igs",
				"in",
				"inj",
				"inh",
				"id",
				"il",
				"ilg",
				"ilm",
				"ilb",
				"ils",
				"ilt",
				"ilp",
				"ilh",
				"im",
				"ib",
				"ibs",
				"is",
				"iss",
				"ing",
				"ij",
				"ic",
				"ik",
				"it",
				"ip",
				"ih",
				"ja",
				"jag",
				"jagg",
				"jags",
				"jan",
				"janj",
				"janh",
				"jad",
				"jal",
				"jalg",
				"jalm",
				"jalb",
				"jals",
				"jalt",
				"jalp",
				"jalh",
				"jam",
				"jab",
				"jabs",
				"jas",
				"jass",
				"jang",
				"jaj",
				"jac",
				"jak",
				"jat",
				"jap",
				"jah",
				"jae",
				"jaeg",
				"jaegg",
				"jaegs",
				"jaen",
				"jaenj",
				"jaenh",
				"jaed",
				"jael",
				"jaelg",
				"jaelm",
				"jaelb",
				"jaels",
				"jaelt",
				"jaelp",
				"jaelh",
				"jaem",
				"jaeb",
				"jaebs",
				"jaes",
				"jaess",
				"jaeng",
				"jaej",
				"jaec",
				"jaek",
				"jaet",
				"jaep",
				"jaeh",
				"jya",
				"jyag",
				"jyagg",
				"jyags",
				"jyan",
				"jyanj",
				"jyanh",
				"jyad",
				"jyal",
				"jyalg",
				"jyalm",
				"jyalb",
				"jyals",
				"jyalt",
				"jyalp",
				"jyalh",
				"jyam",
				"jyab",
				"jyabs",
				"jyas",
				"jyass",
				"jyang",
				"jyaj",
				"jyac",
				"jyak",
				"jyat",
				"jyap",
				"jyah",
				"jyae",
				"jyaeg",
				"jyaegg",
				"jyaegs",
				"jyaen",
				"jyaenj",
				"jyaenh",
				"jyaed",
				"jyael",
				"jyaelg",
				"jyaelm",
				"jyaelb",
				"jyaels",
				"jyaelt",
				"jyaelp",
				"jyaelh",
				"jyaem",
				"jyaeb",
				"jyaebs",
				"jyaes",
				"jyaess",
				"jyaeng",
				"jyaej",
				"jyaec",
				"jyaek",
				"jyaet",
				"jyaep",
				"jyaeh"
			],
			[
				"jeo",
				"jeog",
				"jeogg",
				"jeogs",
				"jeon",
				"jeonj",
				"jeonh",
				"jeod",
				"jeol",
				"jeolg",
				"jeolm",
				"jeolb",
				"jeols",
				"jeolt",
				"jeolp",
				"jeolh",
				"jeom",
				"jeob",
				"jeobs",
				"jeos",
				"jeoss",
				"jeong",
				"jeoj",
				"jeoc",
				"jeok",
				"jeot",
				"jeop",
				"jeoh",
				"je",
				"jeg",
				"jegg",
				"jegs",
				"jen",
				"jenj",
				"jenh",
				"jed",
				"jel",
				"jelg",
				"jelm",
				"jelb",
				"jels",
				"jelt",
				"jelp",
				"jelh",
				"jem",
				"jeb",
				"jebs",
				"jes",
				"jess",
				"jeng",
				"jej",
				"jec",
				"jek",
				"jet",
				"jep",
				"jeh",
				"jyeo",
				"jyeog",
				"jyeogg",
				"jyeogs",
				"jyeon",
				"jyeonj",
				"jyeonh",
				"jyeod",
				"jyeol",
				"jyeolg",
				"jyeolm",
				"jyeolb",
				"jyeols",
				"jyeolt",
				"jyeolp",
				"jyeolh",
				"jyeom",
				"jyeob",
				"jyeobs",
				"jyeos",
				"jyeoss",
				"jyeong",
				"jyeoj",
				"jyeoc",
				"jyeok",
				"jyeot",
				"jyeop",
				"jyeoh",
				"jye",
				"jyeg",
				"jyegg",
				"jyegs",
				"jyen",
				"jyenj",
				"jyenh",
				"jyed",
				"jyel",
				"jyelg",
				"jyelm",
				"jyelb",
				"jyels",
				"jyelt",
				"jyelp",
				"jyelh",
				"jyem",
				"jyeb",
				"jyebs",
				"jyes",
				"jyess",
				"jyeng",
				"jyej",
				"jyec",
				"jyek",
				"jyet",
				"jyep",
				"jyeh",
				"jo",
				"jog",
				"jogg",
				"jogs",
				"jon",
				"jonj",
				"jonh",
				"jod",
				"jol",
				"jolg",
				"jolm",
				"jolb",
				"jols",
				"jolt",
				"jolp",
				"jolh",
				"jom",
				"job",
				"jobs",
				"jos",
				"joss",
				"jong",
				"joj",
				"joc",
				"jok",
				"jot",
				"jop",
				"joh",
				"jwa",
				"jwag",
				"jwagg",
				"jwags",
				"jwan",
				"jwanj",
				"jwanh",
				"jwad",
				"jwal",
				"jwalg",
				"jwalm",
				"jwalb",
				"jwals",
				"jwalt",
				"jwalp",
				"jwalh",
				"jwam",
				"jwab",
				"jwabs",
				"jwas",
				"jwass",
				"jwang",
				"jwaj",
				"jwac",
				"jwak",
				"jwat",
				"jwap",
				"jwah",
				"jwae",
				"jwaeg",
				"jwaegg",
				"jwaegs",
				"jwaen",
				"jwaenj",
				"jwaenh",
				"jwaed",
				"jwael",
				"jwaelg",
				"jwaelm",
				"jwaelb",
				"jwaels",
				"jwaelt",
				"jwaelp",
				"jwaelh",
				"jwaem",
				"jwaeb",
				"jwaebs",
				"jwaes",
				"jwaess",
				"jwaeng",
				"jwaej",
				"jwaec",
				"jwaek",
				"jwaet",
				"jwaep",
				"jwaeh",
				"joe",
				"joeg",
				"joegg",
				"joegs",
				"joen",
				"joenj",
				"joenh",
				"joed",
				"joel",
				"joelg",
				"joelm",
				"joelb",
				"joels",
				"joelt",
				"joelp",
				"joelh",
				"joem",
				"joeb",
				"joebs",
				"joes",
				"joess",
				"joeng",
				"joej",
				"joec",
				"joek",
				"joet",
				"joep",
				"joeh",
				"jyo",
				"jyog",
				"jyogg",
				"jyogs",
				"jyon",
				"jyonj",
				"jyonh",
				"jyod",
				"jyol",
				"jyolg",
				"jyolm",
				"jyolb",
				"jyols",
				"jyolt",
				"jyolp",
				"jyolh",
				"jyom",
				"jyob",
				"jyobs",
				"jyos",
				"jyoss",
				"jyong",
				"jyoj",
				"jyoc",
				"jyok",
				"jyot",
				"jyop",
				"jyoh",
				"ju",
				"jug",
				"jugg",
				"jugs"
			],
			[
				"jun",
				"junj",
				"junh",
				"jud",
				"jul",
				"julg",
				"julm",
				"julb",
				"juls",
				"jult",
				"julp",
				"julh",
				"jum",
				"jub",
				"jubs",
				"jus",
				"juss",
				"jung",
				"juj",
				"juc",
				"juk",
				"jut",
				"jup",
				"juh",
				"jweo",
				"jweog",
				"jweogg",
				"jweogs",
				"jweon",
				"jweonj",
				"jweonh",
				"jweod",
				"jweol",
				"jweolg",
				"jweolm",
				"jweolb",
				"jweols",
				"jweolt",
				"jweolp",
				"jweolh",
				"jweom",
				"jweob",
				"jweobs",
				"jweos",
				"jweoss",
				"jweong",
				"jweoj",
				"jweoc",
				"jweok",
				"jweot",
				"jweop",
				"jweoh",
				"jwe",
				"jweg",
				"jwegg",
				"jwegs",
				"jwen",
				"jwenj",
				"jwenh",
				"jwed",
				"jwel",
				"jwelg",
				"jwelm",
				"jwelb",
				"jwels",
				"jwelt",
				"jwelp",
				"jwelh",
				"jwem",
				"jweb",
				"jwebs",
				"jwes",
				"jwess",
				"jweng",
				"jwej",
				"jwec",
				"jwek",
				"jwet",
				"jwep",
				"jweh",
				"jwi",
				"jwig",
				"jwigg",
				"jwigs",
				"jwin",
				"jwinj",
				"jwinh",
				"jwid",
				"jwil",
				"jwilg",
				"jwilm",
				"jwilb",
				"jwils",
				"jwilt",
				"jwilp",
				"jwilh",
				"jwim",
				"jwib",
				"jwibs",
				"jwis",
				"jwiss",
				"jwing",
				"jwij",
				"jwic",
				"jwik",
				"jwit",
				"jwip",
				"jwih",
				"jyu",
				"jyug",
				"jyugg",
				"jyugs",
				"jyun",
				"jyunj",
				"jyunh",
				"jyud",
				"jyul",
				"jyulg",
				"jyulm",
				"jyulb",
				"jyuls",
				"jyult",
				"jyulp",
				"jyulh",
				"jyum",
				"jyub",
				"jyubs",
				"jyus",
				"jyuss",
				"jyung",
				"jyuj",
				"jyuc",
				"jyuk",
				"jyut",
				"jyup",
				"jyuh",
				"jeu",
				"jeug",
				"jeugg",
				"jeugs",
				"jeun",
				"jeunj",
				"jeunh",
				"jeud",
				"jeul",
				"jeulg",
				"jeulm",
				"jeulb",
				"jeuls",
				"jeult",
				"jeulp",
				"jeulh",
				"jeum",
				"jeub",
				"jeubs",
				"jeus",
				"jeuss",
				"jeung",
				"jeuj",
				"jeuc",
				"jeuk",
				"jeut",
				"jeup",
				"jeuh",
				"jyi",
				"jyig",
				"jyigg",
				"jyigs",
				"jyin",
				"jyinj",
				"jyinh",
				"jyid",
				"jyil",
				"jyilg",
				"jyilm",
				"jyilb",
				"jyils",
				"jyilt",
				"jyilp",
				"jyilh",
				"jyim",
				"jyib",
				"jyibs",
				"jyis",
				"jyiss",
				"jying",
				"jyij",
				"jyic",
				"jyik",
				"jyit",
				"jyip",
				"jyih",
				"ji",
				"jig",
				"jigg",
				"jigs",
				"jin",
				"jinj",
				"jinh",
				"jid",
				"jil",
				"jilg",
				"jilm",
				"jilb",
				"jils",
				"jilt",
				"jilp",
				"jilh",
				"jim",
				"jib",
				"jibs",
				"jis",
				"jiss",
				"jing",
				"jij",
				"jic",
				"jik",
				"jit",
				"jip",
				"jih",
				"jja",
				"jjag",
				"jjagg",
				"jjags",
				"jjan",
				"jjanj",
				"jjanh",
				"jjad",
				"jjal",
				"jjalg",
				"jjalm",
				"jjalb",
				"jjals",
				"jjalt",
				"jjalp",
				"jjalh",
				"jjam",
				"jjab",
				"jjabs",
				"jjas",
				"jjass",
				"jjang",
				"jjaj",
				"jjac",
				"jjak",
				"jjat",
				"jjap",
				"jjah",
				"jjae",
				"jjaeg",
				"jjaegg",
				"jjaegs",
				"jjaen",
				"jjaenj",
				"jjaenh",
				"jjaed"
			],
			[
				"jjael",
				"jjaelg",
				"jjaelm",
				"jjaelb",
				"jjaels",
				"jjaelt",
				"jjaelp",
				"jjaelh",
				"jjaem",
				"jjaeb",
				"jjaebs",
				"jjaes",
				"jjaess",
				"jjaeng",
				"jjaej",
				"jjaec",
				"jjaek",
				"jjaet",
				"jjaep",
				"jjaeh",
				"jjya",
				"jjyag",
				"jjyagg",
				"jjyags",
				"jjyan",
				"jjyanj",
				"jjyanh",
				"jjyad",
				"jjyal",
				"jjyalg",
				"jjyalm",
				"jjyalb",
				"jjyals",
				"jjyalt",
				"jjyalp",
				"jjyalh",
				"jjyam",
				"jjyab",
				"jjyabs",
				"jjyas",
				"jjyass",
				"jjyang",
				"jjyaj",
				"jjyac",
				"jjyak",
				"jjyat",
				"jjyap",
				"jjyah",
				"jjyae",
				"jjyaeg",
				"jjyaegg",
				"jjyaegs",
				"jjyaen",
				"jjyaenj",
				"jjyaenh",
				"jjyaed",
				"jjyael",
				"jjyaelg",
				"jjyaelm",
				"jjyaelb",
				"jjyaels",
				"jjyaelt",
				"jjyaelp",
				"jjyaelh",
				"jjyaem",
				"jjyaeb",
				"jjyaebs",
				"jjyaes",
				"jjyaess",
				"jjyaeng",
				"jjyaej",
				"jjyaec",
				"jjyaek",
				"jjyaet",
				"jjyaep",
				"jjyaeh",
				"jjeo",
				"jjeog",
				"jjeogg",
				"jjeogs",
				"jjeon",
				"jjeonj",
				"jjeonh",
				"jjeod",
				"jjeol",
				"jjeolg",
				"jjeolm",
				"jjeolb",
				"jjeols",
				"jjeolt",
				"jjeolp",
				"jjeolh",
				"jjeom",
				"jjeob",
				"jjeobs",
				"jjeos",
				"jjeoss",
				"jjeong",
				"jjeoj",
				"jjeoc",
				"jjeok",
				"jjeot",
				"jjeop",
				"jjeoh",
				"jje",
				"jjeg",
				"jjegg",
				"jjegs",
				"jjen",
				"jjenj",
				"jjenh",
				"jjed",
				"jjel",
				"jjelg",
				"jjelm",
				"jjelb",
				"jjels",
				"jjelt",
				"jjelp",
				"jjelh",
				"jjem",
				"jjeb",
				"jjebs",
				"jjes",
				"jjess",
				"jjeng",
				"jjej",
				"jjec",
				"jjek",
				"jjet",
				"jjep",
				"jjeh",
				"jjyeo",
				"jjyeog",
				"jjyeogg",
				"jjyeogs",
				"jjyeon",
				"jjyeonj",
				"jjyeonh",
				"jjyeod",
				"jjyeol",
				"jjyeolg",
				"jjyeolm",
				"jjyeolb",
				"jjyeols",
				"jjyeolt",
				"jjyeolp",
				"jjyeolh",
				"jjyeom",
				"jjyeob",
				"jjyeobs",
				"jjyeos",
				"jjyeoss",
				"jjyeong",
				"jjyeoj",
				"jjyeoc",
				"jjyeok",
				"jjyeot",
				"jjyeop",
				"jjyeoh",
				"jjye",
				"jjyeg",
				"jjyegg",
				"jjyegs",
				"jjyen",
				"jjyenj",
				"jjyenh",
				"jjyed",
				"jjyel",
				"jjyelg",
				"jjyelm",
				"jjyelb",
				"jjyels",
				"jjyelt",
				"jjyelp",
				"jjyelh",
				"jjyem",
				"jjyeb",
				"jjyebs",
				"jjyes",
				"jjyess",
				"jjyeng",
				"jjyej",
				"jjyec",
				"jjyek",
				"jjyet",
				"jjyep",
				"jjyeh",
				"jjo",
				"jjog",
				"jjogg",
				"jjogs",
				"jjon",
				"jjonj",
				"jjonh",
				"jjod",
				"jjol",
				"jjolg",
				"jjolm",
				"jjolb",
				"jjols",
				"jjolt",
				"jjolp",
				"jjolh",
				"jjom",
				"jjob",
				"jjobs",
				"jjos",
				"jjoss",
				"jjong",
				"jjoj",
				"jjoc",
				"jjok",
				"jjot",
				"jjop",
				"jjoh",
				"jjwa",
				"jjwag",
				"jjwagg",
				"jjwags",
				"jjwan",
				"jjwanj",
				"jjwanh",
				"jjwad",
				"jjwal",
				"jjwalg",
				"jjwalm",
				"jjwalb",
				"jjwals",
				"jjwalt",
				"jjwalp",
				"jjwalh",
				"jjwam",
				"jjwab",
				"jjwabs",
				"jjwas",
				"jjwass",
				"jjwang",
				"jjwaj",
				"jjwac",
				"jjwak",
				"jjwat",
				"jjwap",
				"jjwah",
				"jjwae",
				"jjwaeg",
				"jjwaegg",
				"jjwaegs",
				"jjwaen",
				"jjwaenj",
				"jjwaenh",
				"jjwaed",
				"jjwael",
				"jjwaelg",
				"jjwaelm",
				"jjwaelb"
			],
			[
				"jjwaels",
				"jjwaelt",
				"jjwaelp",
				"jjwaelh",
				"jjwaem",
				"jjwaeb",
				"jjwaebs",
				"jjwaes",
				"jjwaess",
				"jjwaeng",
				"jjwaej",
				"jjwaec",
				"jjwaek",
				"jjwaet",
				"jjwaep",
				"jjwaeh",
				"jjoe",
				"jjoeg",
				"jjoegg",
				"jjoegs",
				"jjoen",
				"jjoenj",
				"jjoenh",
				"jjoed",
				"jjoel",
				"jjoelg",
				"jjoelm",
				"jjoelb",
				"jjoels",
				"jjoelt",
				"jjoelp",
				"jjoelh",
				"jjoem",
				"jjoeb",
				"jjoebs",
				"jjoes",
				"jjoess",
				"jjoeng",
				"jjoej",
				"jjoec",
				"jjoek",
				"jjoet",
				"jjoep",
				"jjoeh",
				"jjyo",
				"jjyog",
				"jjyogg",
				"jjyogs",
				"jjyon",
				"jjyonj",
				"jjyonh",
				"jjyod",
				"jjyol",
				"jjyolg",
				"jjyolm",
				"jjyolb",
				"jjyols",
				"jjyolt",
				"jjyolp",
				"jjyolh",
				"jjyom",
				"jjyob",
				"jjyobs",
				"jjyos",
				"jjyoss",
				"jjyong",
				"jjyoj",
				"jjyoc",
				"jjyok",
				"jjyot",
				"jjyop",
				"jjyoh",
				"jju",
				"jjug",
				"jjugg",
				"jjugs",
				"jjun",
				"jjunj",
				"jjunh",
				"jjud",
				"jjul",
				"jjulg",
				"jjulm",
				"jjulb",
				"jjuls",
				"jjult",
				"jjulp",
				"jjulh",
				"jjum",
				"jjub",
				"jjubs",
				"jjus",
				"jjuss",
				"jjung",
				"jjuj",
				"jjuc",
				"jjuk",
				"jjut",
				"jjup",
				"jjuh",
				"jjweo",
				"jjweog",
				"jjweogg",
				"jjweogs",
				"jjweon",
				"jjweonj",
				"jjweonh",
				"jjweod",
				"jjweol",
				"jjweolg",
				"jjweolm",
				"jjweolb",
				"jjweols",
				"jjweolt",
				"jjweolp",
				"jjweolh",
				"jjweom",
				"jjweob",
				"jjweobs",
				"jjweos",
				"jjweoss",
				"jjweong",
				"jjweoj",
				"jjweoc",
				"jjweok",
				"jjweot",
				"jjweop",
				"jjweoh",
				"jjwe",
				"jjweg",
				"jjwegg",
				"jjwegs",
				"jjwen",
				"jjwenj",
				"jjwenh",
				"jjwed",
				"jjwel",
				"jjwelg",
				"jjwelm",
				"jjwelb",
				"jjwels",
				"jjwelt",
				"jjwelp",
				"jjwelh",
				"jjwem",
				"jjweb",
				"jjwebs",
				"jjwes",
				"jjwess",
				"jjweng",
				"jjwej",
				"jjwec",
				"jjwek",
				"jjwet",
				"jjwep",
				"jjweh",
				"jjwi",
				"jjwig",
				"jjwigg",
				"jjwigs",
				"jjwin",
				"jjwinj",
				"jjwinh",
				"jjwid",
				"jjwil",
				"jjwilg",
				"jjwilm",
				"jjwilb",
				"jjwils",
				"jjwilt",
				"jjwilp",
				"jjwilh",
				"jjwim",
				"jjwib",
				"jjwibs",
				"jjwis",
				"jjwiss",
				"jjwing",
				"jjwij",
				"jjwic",
				"jjwik",
				"jjwit",
				"jjwip",
				"jjwih",
				"jjyu",
				"jjyug",
				"jjyugg",
				"jjyugs",
				"jjyun",
				"jjyunj",
				"jjyunh",
				"jjyud",
				"jjyul",
				"jjyulg",
				"jjyulm",
				"jjyulb",
				"jjyuls",
				"jjyult",
				"jjyulp",
				"jjyulh",
				"jjyum",
				"jjyub",
				"jjyubs",
				"jjyus",
				"jjyuss",
				"jjyung",
				"jjyuj",
				"jjyuc",
				"jjyuk",
				"jjyut",
				"jjyup",
				"jjyuh",
				"jjeu",
				"jjeug",
				"jjeugg",
				"jjeugs",
				"jjeun",
				"jjeunj",
				"jjeunh",
				"jjeud",
				"jjeul",
				"jjeulg",
				"jjeulm",
				"jjeulb",
				"jjeuls",
				"jjeult",
				"jjeulp",
				"jjeulh",
				"jjeum",
				"jjeub",
				"jjeubs",
				"jjeus",
				"jjeuss",
				"jjeung",
				"jjeuj",
				"jjeuc",
				"jjeuk",
				"jjeut",
				"jjeup",
				"jjeuh",
				"jjyi",
				"jjyig",
				"jjyigg",
				"jjyigs",
				"jjyin",
				"jjyinj",
				"jjyinh",
				"jjyid",
				"jjyil",
				"jjyilg",
				"jjyilm",
				"jjyilb",
				"jjyils",
				"jjyilt",
				"jjyilp",
				"jjyilh"
			],
			[
				"jjyim",
				"jjyib",
				"jjyibs",
				"jjyis",
				"jjyiss",
				"jjying",
				"jjyij",
				"jjyic",
				"jjyik",
				"jjyit",
				"jjyip",
				"jjyih",
				"jji",
				"jjig",
				"jjigg",
				"jjigs",
				"jjin",
				"jjinj",
				"jjinh",
				"jjid",
				"jjil",
				"jjilg",
				"jjilm",
				"jjilb",
				"jjils",
				"jjilt",
				"jjilp",
				"jjilh",
				"jjim",
				"jjib",
				"jjibs",
				"jjis",
				"jjiss",
				"jjing",
				"jjij",
				"jjic",
				"jjik",
				"jjit",
				"jjip",
				"jjih",
				"ca",
				"cag",
				"cagg",
				"cags",
				"can",
				"canj",
				"canh",
				"cad",
				"cal",
				"calg",
				"calm",
				"calb",
				"cals",
				"calt",
				"calp",
				"calh",
				"cam",
				"cab",
				"cabs",
				"cas",
				"cass",
				"cang",
				"caj",
				"cac",
				"cak",
				"cat",
				"cap",
				"cah",
				"cae",
				"caeg",
				"caegg",
				"caegs",
				"caen",
				"caenj",
				"caenh",
				"caed",
				"cael",
				"caelg",
				"caelm",
				"caelb",
				"caels",
				"caelt",
				"caelp",
				"caelh",
				"caem",
				"caeb",
				"caebs",
				"caes",
				"caess",
				"caeng",
				"caej",
				"caec",
				"caek",
				"caet",
				"caep",
				"caeh",
				"cya",
				"cyag",
				"cyagg",
				"cyags",
				"cyan",
				"cyanj",
				"cyanh",
				"cyad",
				"cyal",
				"cyalg",
				"cyalm",
				"cyalb",
				"cyals",
				"cyalt",
				"cyalp",
				"cyalh",
				"cyam",
				"cyab",
				"cyabs",
				"cyas",
				"cyass",
				"cyang",
				"cyaj",
				"cyac",
				"cyak",
				"cyat",
				"cyap",
				"cyah",
				"cyae",
				"cyaeg",
				"cyaegg",
				"cyaegs",
				"cyaen",
				"cyaenj",
				"cyaenh",
				"cyaed",
				"cyael",
				"cyaelg",
				"cyaelm",
				"cyaelb",
				"cyaels",
				"cyaelt",
				"cyaelp",
				"cyaelh",
				"cyaem",
				"cyaeb",
				"cyaebs",
				"cyaes",
				"cyaess",
				"cyaeng",
				"cyaej",
				"cyaec",
				"cyaek",
				"cyaet",
				"cyaep",
				"cyaeh",
				"ceo",
				"ceog",
				"ceogg",
				"ceogs",
				"ceon",
				"ceonj",
				"ceonh",
				"ceod",
				"ceol",
				"ceolg",
				"ceolm",
				"ceolb",
				"ceols",
				"ceolt",
				"ceolp",
				"ceolh",
				"ceom",
				"ceob",
				"ceobs",
				"ceos",
				"ceoss",
				"ceong",
				"ceoj",
				"ceoc",
				"ceok",
				"ceot",
				"ceop",
				"ceoh",
				"ce",
				"ceg",
				"cegg",
				"cegs",
				"cen",
				"cenj",
				"cenh",
				"ced",
				"cel",
				"celg",
				"celm",
				"celb",
				"cels",
				"celt",
				"celp",
				"celh",
				"cem",
				"ceb",
				"cebs",
				"ces",
				"cess",
				"ceng",
				"cej",
				"cec",
				"cek",
				"cet",
				"cep",
				"ceh",
				"cyeo",
				"cyeog",
				"cyeogg",
				"cyeogs",
				"cyeon",
				"cyeonj",
				"cyeonh",
				"cyeod",
				"cyeol",
				"cyeolg",
				"cyeolm",
				"cyeolb",
				"cyeols",
				"cyeolt",
				"cyeolp",
				"cyeolh",
				"cyeom",
				"cyeob",
				"cyeobs",
				"cyeos",
				"cyeoss",
				"cyeong",
				"cyeoj",
				"cyeoc",
				"cyeok",
				"cyeot",
				"cyeop",
				"cyeoh",
				"cye",
				"cyeg",
				"cyegg",
				"cyegs",
				"cyen",
				"cyenj",
				"cyenh",
				"cyed",
				"cyel",
				"cyelg",
				"cyelm",
				"cyelb",
				"cyels",
				"cyelt",
				"cyelp",
				"cyelh",
				"cyem",
				"cyeb",
				"cyebs",
				"cyes"
			],
			[
				"cyess",
				"cyeng",
				"cyej",
				"cyec",
				"cyek",
				"cyet",
				"cyep",
				"cyeh",
				"co",
				"cog",
				"cogg",
				"cogs",
				"con",
				"conj",
				"conh",
				"cod",
				"col",
				"colg",
				"colm",
				"colb",
				"cols",
				"colt",
				"colp",
				"colh",
				"com",
				"cob",
				"cobs",
				"cos",
				"coss",
				"cong",
				"coj",
				"coc",
				"cok",
				"cot",
				"cop",
				"coh",
				"cwa",
				"cwag",
				"cwagg",
				"cwags",
				"cwan",
				"cwanj",
				"cwanh",
				"cwad",
				"cwal",
				"cwalg",
				"cwalm",
				"cwalb",
				"cwals",
				"cwalt",
				"cwalp",
				"cwalh",
				"cwam",
				"cwab",
				"cwabs",
				"cwas",
				"cwass",
				"cwang",
				"cwaj",
				"cwac",
				"cwak",
				"cwat",
				"cwap",
				"cwah",
				"cwae",
				"cwaeg",
				"cwaegg",
				"cwaegs",
				"cwaen",
				"cwaenj",
				"cwaenh",
				"cwaed",
				"cwael",
				"cwaelg",
				"cwaelm",
				"cwaelb",
				"cwaels",
				"cwaelt",
				"cwaelp",
				"cwaelh",
				"cwaem",
				"cwaeb",
				"cwaebs",
				"cwaes",
				"cwaess",
				"cwaeng",
				"cwaej",
				"cwaec",
				"cwaek",
				"cwaet",
				"cwaep",
				"cwaeh",
				"coe",
				"coeg",
				"coegg",
				"coegs",
				"coen",
				"coenj",
				"coenh",
				"coed",
				"coel",
				"coelg",
				"coelm",
				"coelb",
				"coels",
				"coelt",
				"coelp",
				"coelh",
				"coem",
				"coeb",
				"coebs",
				"coes",
				"coess",
				"coeng",
				"coej",
				"coec",
				"coek",
				"coet",
				"coep",
				"coeh",
				"cyo",
				"cyog",
				"cyogg",
				"cyogs",
				"cyon",
				"cyonj",
				"cyonh",
				"cyod",
				"cyol",
				"cyolg",
				"cyolm",
				"cyolb",
				"cyols",
				"cyolt",
				"cyolp",
				"cyolh",
				"cyom",
				"cyob",
				"cyobs",
				"cyos",
				"cyoss",
				"cyong",
				"cyoj",
				"cyoc",
				"cyok",
				"cyot",
				"cyop",
				"cyoh",
				"cu",
				"cug",
				"cugg",
				"cugs",
				"cun",
				"cunj",
				"cunh",
				"cud",
				"cul",
				"culg",
				"culm",
				"culb",
				"culs",
				"cult",
				"culp",
				"culh",
				"cum",
				"cub",
				"cubs",
				"cus",
				"cuss",
				"cung",
				"cuj",
				"cuc",
				"cuk",
				"cut",
				"cup",
				"cuh",
				"cweo",
				"cweog",
				"cweogg",
				"cweogs",
				"cweon",
				"cweonj",
				"cweonh",
				"cweod",
				"cweol",
				"cweolg",
				"cweolm",
				"cweolb",
				"cweols",
				"cweolt",
				"cweolp",
				"cweolh",
				"cweom",
				"cweob",
				"cweobs",
				"cweos",
				"cweoss",
				"cweong",
				"cweoj",
				"cweoc",
				"cweok",
				"cweot",
				"cweop",
				"cweoh",
				"cwe",
				"cweg",
				"cwegg",
				"cwegs",
				"cwen",
				"cwenj",
				"cwenh",
				"cwed",
				"cwel",
				"cwelg",
				"cwelm",
				"cwelb",
				"cwels",
				"cwelt",
				"cwelp",
				"cwelh",
				"cwem",
				"cweb",
				"cwebs",
				"cwes",
				"cwess",
				"cweng",
				"cwej",
				"cwec",
				"cwek",
				"cwet",
				"cwep",
				"cweh",
				"cwi",
				"cwig",
				"cwigg",
				"cwigs",
				"cwin",
				"cwinj",
				"cwinh",
				"cwid",
				"cwil",
				"cwilg",
				"cwilm",
				"cwilb",
				"cwils",
				"cwilt",
				"cwilp",
				"cwilh",
				"cwim",
				"cwib",
				"cwibs",
				"cwis",
				"cwiss",
				"cwing",
				"cwij",
				"cwic"
			],
			[
				"cwik",
				"cwit",
				"cwip",
				"cwih",
				"cyu",
				"cyug",
				"cyugg",
				"cyugs",
				"cyun",
				"cyunj",
				"cyunh",
				"cyud",
				"cyul",
				"cyulg",
				"cyulm",
				"cyulb",
				"cyuls",
				"cyult",
				"cyulp",
				"cyulh",
				"cyum",
				"cyub",
				"cyubs",
				"cyus",
				"cyuss",
				"cyung",
				"cyuj",
				"cyuc",
				"cyuk",
				"cyut",
				"cyup",
				"cyuh",
				"ceu",
				"ceug",
				"ceugg",
				"ceugs",
				"ceun",
				"ceunj",
				"ceunh",
				"ceud",
				"ceul",
				"ceulg",
				"ceulm",
				"ceulb",
				"ceuls",
				"ceult",
				"ceulp",
				"ceulh",
				"ceum",
				"ceub",
				"ceubs",
				"ceus",
				"ceuss",
				"ceung",
				"ceuj",
				"ceuc",
				"ceuk",
				"ceut",
				"ceup",
				"ceuh",
				"cyi",
				"cyig",
				"cyigg",
				"cyigs",
				"cyin",
				"cyinj",
				"cyinh",
				"cyid",
				"cyil",
				"cyilg",
				"cyilm",
				"cyilb",
				"cyils",
				"cyilt",
				"cyilp",
				"cyilh",
				"cyim",
				"cyib",
				"cyibs",
				"cyis",
				"cyiss",
				"cying",
				"cyij",
				"cyic",
				"cyik",
				"cyit",
				"cyip",
				"cyih",
				"ci",
				"cig",
				"cigg",
				"cigs",
				"cin",
				"cinj",
				"cinh",
				"cid",
				"cil",
				"cilg",
				"cilm",
				"cilb",
				"cils",
				"cilt",
				"cilp",
				"cilh",
				"cim",
				"cib",
				"cibs",
				"cis",
				"ciss",
				"cing",
				"cij",
				"cic",
				"cik",
				"cit",
				"cip",
				"cih",
				"ka",
				"kag",
				"kagg",
				"kags",
				"kan",
				"kanj",
				"kanh",
				"kad",
				"kal",
				"kalg",
				"kalm",
				"kalb",
				"kals",
				"kalt",
				"kalp",
				"kalh",
				"kam",
				"kab",
				"kabs",
				"kas",
				"kass",
				"kang",
				"kaj",
				"kac",
				"kak",
				"kat",
				"kap",
				"kah",
				"kae",
				"kaeg",
				"kaegg",
				"kaegs",
				"kaen",
				"kaenj",
				"kaenh",
				"kaed",
				"kael",
				"kaelg",
				"kaelm",
				"kaelb",
				"kaels",
				"kaelt",
				"kaelp",
				"kaelh",
				"kaem",
				"kaeb",
				"kaebs",
				"kaes",
				"kaess",
				"kaeng",
				"kaej",
				"kaec",
				"kaek",
				"kaet",
				"kaep",
				"kaeh",
				"kya",
				"kyag",
				"kyagg",
				"kyags",
				"kyan",
				"kyanj",
				"kyanh",
				"kyad",
				"kyal",
				"kyalg",
				"kyalm",
				"kyalb",
				"kyals",
				"kyalt",
				"kyalp",
				"kyalh",
				"kyam",
				"kyab",
				"kyabs",
				"kyas",
				"kyass",
				"kyang",
				"kyaj",
				"kyac",
				"kyak",
				"kyat",
				"kyap",
				"kyah",
				"kyae",
				"kyaeg",
				"kyaegg",
				"kyaegs",
				"kyaen",
				"kyaenj",
				"kyaenh",
				"kyaed",
				"kyael",
				"kyaelg",
				"kyaelm",
				"kyaelb",
				"kyaels",
				"kyaelt",
				"kyaelp",
				"kyaelh",
				"kyaem",
				"kyaeb",
				"kyaebs",
				"kyaes",
				"kyaess",
				"kyaeng",
				"kyaej",
				"kyaec",
				"kyaek",
				"kyaet",
				"kyaep",
				"kyaeh",
				"keo",
				"keog",
				"keogg",
				"keogs",
				"keon",
				"keonj",
				"keonh",
				"keod",
				"keol",
				"keolg",
				"keolm",
				"keolb",
				"keols",
				"keolt",
				"keolp",
				"keolh",
				"keom",
				"keob",
				"keobs",
				"keos",
				"keoss",
				"keong",
				"keoj",
				"keoc",
				"keok",
				"keot",
				"keop",
				"keoh"
			],
			[
				"ke",
				"keg",
				"kegg",
				"kegs",
				"ken",
				"kenj",
				"kenh",
				"ked",
				"kel",
				"kelg",
				"kelm",
				"kelb",
				"kels",
				"kelt",
				"kelp",
				"kelh",
				"kem",
				"keb",
				"kebs",
				"kes",
				"kess",
				"keng",
				"kej",
				"kec",
				"kek",
				"ket",
				"kep",
				"keh",
				"kyeo",
				"kyeog",
				"kyeogg",
				"kyeogs",
				"kyeon",
				"kyeonj",
				"kyeonh",
				"kyeod",
				"kyeol",
				"kyeolg",
				"kyeolm",
				"kyeolb",
				"kyeols",
				"kyeolt",
				"kyeolp",
				"kyeolh",
				"kyeom",
				"kyeob",
				"kyeobs",
				"kyeos",
				"kyeoss",
				"kyeong",
				"kyeoj",
				"kyeoc",
				"kyeok",
				"kyeot",
				"kyeop",
				"kyeoh",
				"kye",
				"kyeg",
				"kyegg",
				"kyegs",
				"kyen",
				"kyenj",
				"kyenh",
				"kyed",
				"kyel",
				"kyelg",
				"kyelm",
				"kyelb",
				"kyels",
				"kyelt",
				"kyelp",
				"kyelh",
				"kyem",
				"kyeb",
				"kyebs",
				"kyes",
				"kyess",
				"kyeng",
				"kyej",
				"kyec",
				"kyek",
				"kyet",
				"kyep",
				"kyeh",
				"ko",
				"kog",
				"kogg",
				"kogs",
				"kon",
				"konj",
				"konh",
				"kod",
				"kol",
				"kolg",
				"kolm",
				"kolb",
				"kols",
				"kolt",
				"kolp",
				"kolh",
				"kom",
				"kob",
				"kobs",
				"kos",
				"koss",
				"kong",
				"koj",
				"koc",
				"kok",
				"kot",
				"kop",
				"koh",
				"kwa",
				"kwag",
				"kwagg",
				"kwags",
				"kwan",
				"kwanj",
				"kwanh",
				"kwad",
				"kwal",
				"kwalg",
				"kwalm",
				"kwalb",
				"kwals",
				"kwalt",
				"kwalp",
				"kwalh",
				"kwam",
				"kwab",
				"kwabs",
				"kwas",
				"kwass",
				"kwang",
				"kwaj",
				"kwac",
				"kwak",
				"kwat",
				"kwap",
				"kwah",
				"kwae",
				"kwaeg",
				"kwaegg",
				"kwaegs",
				"kwaen",
				"kwaenj",
				"kwaenh",
				"kwaed",
				"kwael",
				"kwaelg",
				"kwaelm",
				"kwaelb",
				"kwaels",
				"kwaelt",
				"kwaelp",
				"kwaelh",
				"kwaem",
				"kwaeb",
				"kwaebs",
				"kwaes",
				"kwaess",
				"kwaeng",
				"kwaej",
				"kwaec",
				"kwaek",
				"kwaet",
				"kwaep",
				"kwaeh",
				"koe",
				"koeg",
				"koegg",
				"koegs",
				"koen",
				"koenj",
				"koenh",
				"koed",
				"koel",
				"koelg",
				"koelm",
				"koelb",
				"koels",
				"koelt",
				"koelp",
				"koelh",
				"koem",
				"koeb",
				"koebs",
				"koes",
				"koess",
				"koeng",
				"koej",
				"koec",
				"koek",
				"koet",
				"koep",
				"koeh",
				"kyo",
				"kyog",
				"kyogg",
				"kyogs",
				"kyon",
				"kyonj",
				"kyonh",
				"kyod",
				"kyol",
				"kyolg",
				"kyolm",
				"kyolb",
				"kyols",
				"kyolt",
				"kyolp",
				"kyolh",
				"kyom",
				"kyob",
				"kyobs",
				"kyos",
				"kyoss",
				"kyong",
				"kyoj",
				"kyoc",
				"kyok",
				"kyot",
				"kyop",
				"kyoh",
				"ku",
				"kug",
				"kugg",
				"kugs",
				"kun",
				"kunj",
				"kunh",
				"kud",
				"kul",
				"kulg",
				"kulm",
				"kulb",
				"kuls",
				"kult",
				"kulp",
				"kulh",
				"kum",
				"kub",
				"kubs",
				"kus",
				"kuss",
				"kung",
				"kuj",
				"kuc",
				"kuk",
				"kut",
				"kup",
				"kuh",
				"kweo",
				"kweog",
				"kweogg",
				"kweogs"
			],
			[
				"kweon",
				"kweonj",
				"kweonh",
				"kweod",
				"kweol",
				"kweolg",
				"kweolm",
				"kweolb",
				"kweols",
				"kweolt",
				"kweolp",
				"kweolh",
				"kweom",
				"kweob",
				"kweobs",
				"kweos",
				"kweoss",
				"kweong",
				"kweoj",
				"kweoc",
				"kweok",
				"kweot",
				"kweop",
				"kweoh",
				"kwe",
				"kweg",
				"kwegg",
				"kwegs",
				"kwen",
				"kwenj",
				"kwenh",
				"kwed",
				"kwel",
				"kwelg",
				"kwelm",
				"kwelb",
				"kwels",
				"kwelt",
				"kwelp",
				"kwelh",
				"kwem",
				"kweb",
				"kwebs",
				"kwes",
				"kwess",
				"kweng",
				"kwej",
				"kwec",
				"kwek",
				"kwet",
				"kwep",
				"kweh",
				"kwi",
				"kwig",
				"kwigg",
				"kwigs",
				"kwin",
				"kwinj",
				"kwinh",
				"kwid",
				"kwil",
				"kwilg",
				"kwilm",
				"kwilb",
				"kwils",
				"kwilt",
				"kwilp",
				"kwilh",
				"kwim",
				"kwib",
				"kwibs",
				"kwis",
				"kwiss",
				"kwing",
				"kwij",
				"kwic",
				"kwik",
				"kwit",
				"kwip",
				"kwih",
				"kyu",
				"kyug",
				"kyugg",
				"kyugs",
				"kyun",
				"kyunj",
				"kyunh",
				"kyud",
				"kyul",
				"kyulg",
				"kyulm",
				"kyulb",
				"kyuls",
				"kyult",
				"kyulp",
				"kyulh",
				"kyum",
				"kyub",
				"kyubs",
				"kyus",
				"kyuss",
				"kyung",
				"kyuj",
				"kyuc",
				"kyuk",
				"kyut",
				"kyup",
				"kyuh",
				"keu",
				"keug",
				"keugg",
				"keugs",
				"keun",
				"keunj",
				"keunh",
				"keud",
				"keul",
				"keulg",
				"keulm",
				"keulb",
				"keuls",
				"keult",
				"keulp",
				"keulh",
				"keum",
				"keub",
				"keubs",
				"keus",
				"keuss",
				"keung",
				"keuj",
				"keuc",
				"keuk",
				"keut",
				"keup",
				"keuh",
				"kyi",
				"kyig",
				"kyigg",
				"kyigs",
				"kyin",
				"kyinj",
				"kyinh",
				"kyid",
				"kyil",
				"kyilg",
				"kyilm",
				"kyilb",
				"kyils",
				"kyilt",
				"kyilp",
				"kyilh",
				"kyim",
				"kyib",
				"kyibs",
				"kyis",
				"kyiss",
				"kying",
				"kyij",
				"kyic",
				"kyik",
				"kyit",
				"kyip",
				"kyih",
				"ki",
				"kig",
				"kigg",
				"kigs",
				"kin",
				"kinj",
				"kinh",
				"kid",
				"kil",
				"kilg",
				"kilm",
				"kilb",
				"kils",
				"kilt",
				"kilp",
				"kilh",
				"kim",
				"kib",
				"kibs",
				"kis",
				"kiss",
				"king",
				"kij",
				"kic",
				"kik",
				"kit",
				"kip",
				"kih",
				"ta",
				"tag",
				"tagg",
				"tags",
				"tan",
				"tanj",
				"tanh",
				"tad",
				"tal",
				"talg",
				"talm",
				"talb",
				"tals",
				"talt",
				"talp",
				"talh",
				"tam",
				"tab",
				"tabs",
				"tas",
				"tass",
				"tang",
				"taj",
				"tac",
				"tak",
				"tat",
				"tap",
				"tah",
				"tae",
				"taeg",
				"taegg",
				"taegs",
				"taen",
				"taenj",
				"taenh",
				"taed",
				"tael",
				"taelg",
				"taelm",
				"taelb",
				"taels",
				"taelt",
				"taelp",
				"taelh",
				"taem",
				"taeb",
				"taebs",
				"taes",
				"taess",
				"taeng",
				"taej",
				"taec",
				"taek",
				"taet",
				"taep",
				"taeh",
				"tya",
				"tyag",
				"tyagg",
				"tyags",
				"tyan",
				"tyanj",
				"tyanh",
				"tyad"
			],
			[
				"tyal",
				"tyalg",
				"tyalm",
				"tyalb",
				"tyals",
				"tyalt",
				"tyalp",
				"tyalh",
				"tyam",
				"tyab",
				"tyabs",
				"tyas",
				"tyass",
				"tyang",
				"tyaj",
				"tyac",
				"tyak",
				"tyat",
				"tyap",
				"tyah",
				"tyae",
				"tyaeg",
				"tyaegg",
				"tyaegs",
				"tyaen",
				"tyaenj",
				"tyaenh",
				"tyaed",
				"tyael",
				"tyaelg",
				"tyaelm",
				"tyaelb",
				"tyaels",
				"tyaelt",
				"tyaelp",
				"tyaelh",
				"tyaem",
				"tyaeb",
				"tyaebs",
				"tyaes",
				"tyaess",
				"tyaeng",
				"tyaej",
				"tyaec",
				"tyaek",
				"tyaet",
				"tyaep",
				"tyaeh",
				"teo",
				"teog",
				"teogg",
				"teogs",
				"teon",
				"teonj",
				"teonh",
				"teod",
				"teol",
				"teolg",
				"teolm",
				"teolb",
				"teols",
				"teolt",
				"teolp",
				"teolh",
				"teom",
				"teob",
				"teobs",
				"teos",
				"teoss",
				"teong",
				"teoj",
				"teoc",
				"teok",
				"teot",
				"teop",
				"teoh",
				"te",
				"teg",
				"tegg",
				"tegs",
				"ten",
				"tenj",
				"tenh",
				"ted",
				"tel",
				"telg",
				"telm",
				"telb",
				"tels",
				"telt",
				"telp",
				"telh",
				"tem",
				"teb",
				"tebs",
				"tes",
				"tess",
				"teng",
				"tej",
				"tec",
				"tek",
				"tet",
				"tep",
				"teh",
				"tyeo",
				"tyeog",
				"tyeogg",
				"tyeogs",
				"tyeon",
				"tyeonj",
				"tyeonh",
				"tyeod",
				"tyeol",
				"tyeolg",
				"tyeolm",
				"tyeolb",
				"tyeols",
				"tyeolt",
				"tyeolp",
				"tyeolh",
				"tyeom",
				"tyeob",
				"tyeobs",
				"tyeos",
				"tyeoss",
				"tyeong",
				"tyeoj",
				"tyeoc",
				"tyeok",
				"tyeot",
				"tyeop",
				"tyeoh",
				"tye",
				"tyeg",
				"tyegg",
				"tyegs",
				"tyen",
				"tyenj",
				"tyenh",
				"tyed",
				"tyel",
				"tyelg",
				"tyelm",
				"tyelb",
				"tyels",
				"tyelt",
				"tyelp",
				"tyelh",
				"tyem",
				"tyeb",
				"tyebs",
				"tyes",
				"tyess",
				"tyeng",
				"tyej",
				"tyec",
				"tyek",
				"tyet",
				"tyep",
				"tyeh",
				"to",
				"tog",
				"togg",
				"togs",
				"ton",
				"tonj",
				"tonh",
				"tod",
				"tol",
				"tolg",
				"tolm",
				"tolb",
				"tols",
				"tolt",
				"tolp",
				"tolh",
				"tom",
				"tob",
				"tobs",
				"tos",
				"toss",
				"tong",
				"toj",
				"toc",
				"tok",
				"tot",
				"top",
				"toh",
				"twa",
				"twag",
				"twagg",
				"twags",
				"twan",
				"twanj",
				"twanh",
				"twad",
				"twal",
				"twalg",
				"twalm",
				"twalb",
				"twals",
				"twalt",
				"twalp",
				"twalh",
				"twam",
				"twab",
				"twabs",
				"twas",
				"twass",
				"twang",
				"twaj",
				"twac",
				"twak",
				"twat",
				"twap",
				"twah",
				"twae",
				"twaeg",
				"twaegg",
				"twaegs",
				"twaen",
				"twaenj",
				"twaenh",
				"twaed",
				"twael",
				"twaelg",
				"twaelm",
				"twaelb",
				"twaels",
				"twaelt",
				"twaelp",
				"twaelh",
				"twaem",
				"twaeb",
				"twaebs",
				"twaes",
				"twaess",
				"twaeng",
				"twaej",
				"twaec",
				"twaek",
				"twaet",
				"twaep",
				"twaeh",
				"toe",
				"toeg",
				"toegg",
				"toegs",
				"toen",
				"toenj",
				"toenh",
				"toed",
				"toel",
				"toelg",
				"toelm",
				"toelb"
			],
			[
				"toels",
				"toelt",
				"toelp",
				"toelh",
				"toem",
				"toeb",
				"toebs",
				"toes",
				"toess",
				"toeng",
				"toej",
				"toec",
				"toek",
				"toet",
				"toep",
				"toeh",
				"tyo",
				"tyog",
				"tyogg",
				"tyogs",
				"tyon",
				"tyonj",
				"tyonh",
				"tyod",
				"tyol",
				"tyolg",
				"tyolm",
				"tyolb",
				"tyols",
				"tyolt",
				"tyolp",
				"tyolh",
				"tyom",
				"tyob",
				"tyobs",
				"tyos",
				"tyoss",
				"tyong",
				"tyoj",
				"tyoc",
				"tyok",
				"tyot",
				"tyop",
				"tyoh",
				"tu",
				"tug",
				"tugg",
				"tugs",
				"tun",
				"tunj",
				"tunh",
				"tud",
				"tul",
				"tulg",
				"tulm",
				"tulb",
				"tuls",
				"tult",
				"tulp",
				"tulh",
				"tum",
				"tub",
				"tubs",
				"tus",
				"tuss",
				"tung",
				"tuj",
				"tuc",
				"tuk",
				"tut",
				"tup",
				"tuh",
				"tweo",
				"tweog",
				"tweogg",
				"tweogs",
				"tweon",
				"tweonj",
				"tweonh",
				"tweod",
				"tweol",
				"tweolg",
				"tweolm",
				"tweolb",
				"tweols",
				"tweolt",
				"tweolp",
				"tweolh",
				"tweom",
				"tweob",
				"tweobs",
				"tweos",
				"tweoss",
				"tweong",
				"tweoj",
				"tweoc",
				"tweok",
				"tweot",
				"tweop",
				"tweoh",
				"twe",
				"tweg",
				"twegg",
				"twegs",
				"twen",
				"twenj",
				"twenh",
				"twed",
				"twel",
				"twelg",
				"twelm",
				"twelb",
				"twels",
				"twelt",
				"twelp",
				"twelh",
				"twem",
				"tweb",
				"twebs",
				"twes",
				"twess",
				"tweng",
				"twej",
				"twec",
				"twek",
				"twet",
				"twep",
				"tweh",
				"twi",
				"twig",
				"twigg",
				"twigs",
				"twin",
				"twinj",
				"twinh",
				"twid",
				"twil",
				"twilg",
				"twilm",
				"twilb",
				"twils",
				"twilt",
				"twilp",
				"twilh",
				"twim",
				"twib",
				"twibs",
				"twis",
				"twiss",
				"twing",
				"twij",
				"twic",
				"twik",
				"twit",
				"twip",
				"twih",
				"tyu",
				"tyug",
				"tyugg",
				"tyugs",
				"tyun",
				"tyunj",
				"tyunh",
				"tyud",
				"tyul",
				"tyulg",
				"tyulm",
				"tyulb",
				"tyuls",
				"tyult",
				"tyulp",
				"tyulh",
				"tyum",
				"tyub",
				"tyubs",
				"tyus",
				"tyuss",
				"tyung",
				"tyuj",
				"tyuc",
				"tyuk",
				"tyut",
				"tyup",
				"tyuh",
				"teu",
				"teug",
				"teugg",
				"teugs",
				"teun",
				"teunj",
				"teunh",
				"teud",
				"teul",
				"teulg",
				"teulm",
				"teulb",
				"teuls",
				"teult",
				"teulp",
				"teulh",
				"teum",
				"teub",
				"teubs",
				"teus",
				"teuss",
				"teung",
				"teuj",
				"teuc",
				"teuk",
				"teut",
				"teup",
				"teuh",
				"tyi",
				"tyig",
				"tyigg",
				"tyigs",
				"tyin",
				"tyinj",
				"tyinh",
				"tyid",
				"tyil",
				"tyilg",
				"tyilm",
				"tyilb",
				"tyils",
				"tyilt",
				"tyilp",
				"tyilh",
				"tyim",
				"tyib",
				"tyibs",
				"tyis",
				"tyiss",
				"tying",
				"tyij",
				"tyic",
				"tyik",
				"tyit",
				"tyip",
				"tyih",
				"ti",
				"tig",
				"tigg",
				"tigs",
				"tin",
				"tinj",
				"tinh",
				"tid",
				"til",
				"tilg",
				"tilm",
				"tilb",
				"tils",
				"tilt",
				"tilp",
				"tilh"
			],
			[
				"tim",
				"tib",
				"tibs",
				"tis",
				"tiss",
				"ting",
				"tij",
				"tic",
				"tik",
				"tit",
				"tip",
				"tih",
				"pa",
				"pag",
				"pagg",
				"pags",
				"pan",
				"panj",
				"panh",
				"pad",
				"pal",
				"palg",
				"palm",
				"palb",
				"pals",
				"palt",
				"palp",
				"palh",
				"pam",
				"pab",
				"pabs",
				"pas",
				"pass",
				"pang",
				"paj",
				"pac",
				"pak",
				"pat",
				"pap",
				"pah",
				"pae",
				"paeg",
				"paegg",
				"paegs",
				"paen",
				"paenj",
				"paenh",
				"paed",
				"pael",
				"paelg",
				"paelm",
				"paelb",
				"paels",
				"paelt",
				"paelp",
				"paelh",
				"paem",
				"paeb",
				"paebs",
				"paes",
				"paess",
				"paeng",
				"paej",
				"paec",
				"paek",
				"paet",
				"paep",
				"paeh",
				"pya",
				"pyag",
				"pyagg",
				"pyags",
				"pyan",
				"pyanj",
				"pyanh",
				"pyad",
				"pyal",
				"pyalg",
				"pyalm",
				"pyalb",
				"pyals",
				"pyalt",
				"pyalp",
				"pyalh",
				"pyam",
				"pyab",
				"pyabs",
				"pyas",
				"pyass",
				"pyang",
				"pyaj",
				"pyac",
				"pyak",
				"pyat",
				"pyap",
				"pyah",
				"pyae",
				"pyaeg",
				"pyaegg",
				"pyaegs",
				"pyaen",
				"pyaenj",
				"pyaenh",
				"pyaed",
				"pyael",
				"pyaelg",
				"pyaelm",
				"pyaelb",
				"pyaels",
				"pyaelt",
				"pyaelp",
				"pyaelh",
				"pyaem",
				"pyaeb",
				"pyaebs",
				"pyaes",
				"pyaess",
				"pyaeng",
				"pyaej",
				"pyaec",
				"pyaek",
				"pyaet",
				"pyaep",
				"pyaeh",
				"peo",
				"peog",
				"peogg",
				"peogs",
				"peon",
				"peonj",
				"peonh",
				"peod",
				"peol",
				"peolg",
				"peolm",
				"peolb",
				"peols",
				"peolt",
				"peolp",
				"peolh",
				"peom",
				"peob",
				"peobs",
				"peos",
				"peoss",
				"peong",
				"peoj",
				"peoc",
				"peok",
				"peot",
				"peop",
				"peoh",
				"pe",
				"peg",
				"pegg",
				"pegs",
				"pen",
				"penj",
				"penh",
				"ped",
				"pel",
				"pelg",
				"pelm",
				"pelb",
				"pels",
				"pelt",
				"pelp",
				"pelh",
				"pem",
				"peb",
				"pebs",
				"pes",
				"pess",
				"peng",
				"pej",
				"pec",
				"pek",
				"pet",
				"pep",
				"peh",
				"pyeo",
				"pyeog",
				"pyeogg",
				"pyeogs",
				"pyeon",
				"pyeonj",
				"pyeonh",
				"pyeod",
				"pyeol",
				"pyeolg",
				"pyeolm",
				"pyeolb",
				"pyeols",
				"pyeolt",
				"pyeolp",
				"pyeolh",
				"pyeom",
				"pyeob",
				"pyeobs",
				"pyeos",
				"pyeoss",
				"pyeong",
				"pyeoj",
				"pyeoc",
				"pyeok",
				"pyeot",
				"pyeop",
				"pyeoh",
				"pye",
				"pyeg",
				"pyegg",
				"pyegs",
				"pyen",
				"pyenj",
				"pyenh",
				"pyed",
				"pyel",
				"pyelg",
				"pyelm",
				"pyelb",
				"pyels",
				"pyelt",
				"pyelp",
				"pyelh",
				"pyem",
				"pyeb",
				"pyebs",
				"pyes",
				"pyess",
				"pyeng",
				"pyej",
				"pyec",
				"pyek",
				"pyet",
				"pyep",
				"pyeh",
				"po",
				"pog",
				"pogg",
				"pogs",
				"pon",
				"ponj",
				"ponh",
				"pod",
				"pol",
				"polg",
				"polm",
				"polb",
				"pols",
				"polt",
				"polp",
				"polh",
				"pom",
				"pob",
				"pobs",
				"pos"
			],
			[
				"poss",
				"pong",
				"poj",
				"poc",
				"pok",
				"pot",
				"pop",
				"poh",
				"pwa",
				"pwag",
				"pwagg",
				"pwags",
				"pwan",
				"pwanj",
				"pwanh",
				"pwad",
				"pwal",
				"pwalg",
				"pwalm",
				"pwalb",
				"pwals",
				"pwalt",
				"pwalp",
				"pwalh",
				"pwam",
				"pwab",
				"pwabs",
				"pwas",
				"pwass",
				"pwang",
				"pwaj",
				"pwac",
				"pwak",
				"pwat",
				"pwap",
				"pwah",
				"pwae",
				"pwaeg",
				"pwaegg",
				"pwaegs",
				"pwaen",
				"pwaenj",
				"pwaenh",
				"pwaed",
				"pwael",
				"pwaelg",
				"pwaelm",
				"pwaelb",
				"pwaels",
				"pwaelt",
				"pwaelp",
				"pwaelh",
				"pwaem",
				"pwaeb",
				"pwaebs",
				"pwaes",
				"pwaess",
				"pwaeng",
				"pwaej",
				"pwaec",
				"pwaek",
				"pwaet",
				"pwaep",
				"pwaeh",
				"poe",
				"poeg",
				"poegg",
				"poegs",
				"poen",
				"poenj",
				"poenh",
				"poed",
				"poel",
				"poelg",
				"poelm",
				"poelb",
				"poels",
				"poelt",
				"poelp",
				"poelh",
				"poem",
				"poeb",
				"poebs",
				"poes",
				"poess",
				"poeng",
				"poej",
				"poec",
				"poek",
				"poet",
				"poep",
				"poeh",
				"pyo",
				"pyog",
				"pyogg",
				"pyogs",
				"pyon",
				"pyonj",
				"pyonh",
				"pyod",
				"pyol",
				"pyolg",
				"pyolm",
				"pyolb",
				"pyols",
				"pyolt",
				"pyolp",
				"pyolh",
				"pyom",
				"pyob",
				"pyobs",
				"pyos",
				"pyoss",
				"pyong",
				"pyoj",
				"pyoc",
				"pyok",
				"pyot",
				"pyop",
				"pyoh",
				"pu",
				"pug",
				"pugg",
				"pugs",
				"pun",
				"punj",
				"punh",
				"pud",
				"pul",
				"pulg",
				"pulm",
				"pulb",
				"puls",
				"pult",
				"pulp",
				"pulh",
				"pum",
				"pub",
				"pubs",
				"pus",
				"puss",
				"pung",
				"puj",
				"puc",
				"puk",
				"put",
				"pup",
				"puh",
				"pweo",
				"pweog",
				"pweogg",
				"pweogs",
				"pweon",
				"pweonj",
				"pweonh",
				"pweod",
				"pweol",
				"pweolg",
				"pweolm",
				"pweolb",
				"pweols",
				"pweolt",
				"pweolp",
				"pweolh",
				"pweom",
				"pweob",
				"pweobs",
				"pweos",
				"pweoss",
				"pweong",
				"pweoj",
				"pweoc",
				"pweok",
				"pweot",
				"pweop",
				"pweoh",
				"pwe",
				"pweg",
				"pwegg",
				"pwegs",
				"pwen",
				"pwenj",
				"pwenh",
				"pwed",
				"pwel",
				"pwelg",
				"pwelm",
				"pwelb",
				"pwels",
				"pwelt",
				"pwelp",
				"pwelh",
				"pwem",
				"pweb",
				"pwebs",
				"pwes",
				"pwess",
				"pweng",
				"pwej",
				"pwec",
				"pwek",
				"pwet",
				"pwep",
				"pweh",
				"pwi",
				"pwig",
				"pwigg",
				"pwigs",
				"pwin",
				"pwinj",
				"pwinh",
				"pwid",
				"pwil",
				"pwilg",
				"pwilm",
				"pwilb",
				"pwils",
				"pwilt",
				"pwilp",
				"pwilh",
				"pwim",
				"pwib",
				"pwibs",
				"pwis",
				"pwiss",
				"pwing",
				"pwij",
				"pwic",
				"pwik",
				"pwit",
				"pwip",
				"pwih",
				"pyu",
				"pyug",
				"pyugg",
				"pyugs",
				"pyun",
				"pyunj",
				"pyunh",
				"pyud",
				"pyul",
				"pyulg",
				"pyulm",
				"pyulb",
				"pyuls",
				"pyult",
				"pyulp",
				"pyulh",
				"pyum",
				"pyub",
				"pyubs",
				"pyus",
				"pyuss",
				"pyung",
				"pyuj",
				"pyuc"
			],
			[
				"pyuk",
				"pyut",
				"pyup",
				"pyuh",
				"peu",
				"peug",
				"peugg",
				"peugs",
				"peun",
				"peunj",
				"peunh",
				"peud",
				"peul",
				"peulg",
				"peulm",
				"peulb",
				"peuls",
				"peult",
				"peulp",
				"peulh",
				"peum",
				"peub",
				"peubs",
				"peus",
				"peuss",
				"peung",
				"peuj",
				"peuc",
				"peuk",
				"peut",
				"peup",
				"peuh",
				"pyi",
				"pyig",
				"pyigg",
				"pyigs",
				"pyin",
				"pyinj",
				"pyinh",
				"pyid",
				"pyil",
				"pyilg",
				"pyilm",
				"pyilb",
				"pyils",
				"pyilt",
				"pyilp",
				"pyilh",
				"pyim",
				"pyib",
				"pyibs",
				"pyis",
				"pyiss",
				"pying",
				"pyij",
				"pyic",
				"pyik",
				"pyit",
				"pyip",
				"pyih",
				"pi",
				"pig",
				"pigg",
				"pigs",
				"pin",
				"pinj",
				"pinh",
				"pid",
				"pil",
				"pilg",
				"pilm",
				"pilb",
				"pils",
				"pilt",
				"pilp",
				"pilh",
				"pim",
				"pib",
				"pibs",
				"pis",
				"piss",
				"ping",
				"pij",
				"pic",
				"pik",
				"pit",
				"pip",
				"pih",
				"ha",
				"hag",
				"hagg",
				"hags",
				"han",
				"hanj",
				"hanh",
				"had",
				"hal",
				"halg",
				"halm",
				"halb",
				"hals",
				"halt",
				"halp",
				"halh",
				"ham",
				"hab",
				"habs",
				"has",
				"hass",
				"hang",
				"haj",
				"hac",
				"hak",
				"hat",
				"hap",
				"hah",
				"hae",
				"haeg",
				"haegg",
				"haegs",
				"haen",
				"haenj",
				"haenh",
				"haed",
				"hael",
				"haelg",
				"haelm",
				"haelb",
				"haels",
				"haelt",
				"haelp",
				"haelh",
				"haem",
				"haeb",
				"haebs",
				"haes",
				"haess",
				"haeng",
				"haej",
				"haec",
				"haek",
				"haet",
				"haep",
				"haeh",
				"hya",
				"hyag",
				"hyagg",
				"hyags",
				"hyan",
				"hyanj",
				"hyanh",
				"hyad",
				"hyal",
				"hyalg",
				"hyalm",
				"hyalb",
				"hyals",
				"hyalt",
				"hyalp",
				"hyalh",
				"hyam",
				"hyab",
				"hyabs",
				"hyas",
				"hyass",
				"hyang",
				"hyaj",
				"hyac",
				"hyak",
				"hyat",
				"hyap",
				"hyah",
				"hyae",
				"hyaeg",
				"hyaegg",
				"hyaegs",
				"hyaen",
				"hyaenj",
				"hyaenh",
				"hyaed",
				"hyael",
				"hyaelg",
				"hyaelm",
				"hyaelb",
				"hyaels",
				"hyaelt",
				"hyaelp",
				"hyaelh",
				"hyaem",
				"hyaeb",
				"hyaebs",
				"hyaes",
				"hyaess",
				"hyaeng",
				"hyaej",
				"hyaec",
				"hyaek",
				"hyaet",
				"hyaep",
				"hyaeh",
				"heo",
				"heog",
				"heogg",
				"heogs",
				"heon",
				"heonj",
				"heonh",
				"heod",
				"heol",
				"heolg",
				"heolm",
				"heolb",
				"heols",
				"heolt",
				"heolp",
				"heolh",
				"heom",
				"heob",
				"heobs",
				"heos",
				"heoss",
				"heong",
				"heoj",
				"heoc",
				"heok",
				"heot",
				"heop",
				"heoh",
				"he",
				"heg",
				"hegg",
				"hegs",
				"hen",
				"henj",
				"henh",
				"hed",
				"hel",
				"helg",
				"helm",
				"helb",
				"hels",
				"helt",
				"help",
				"helh",
				"hem",
				"heb",
				"hebs",
				"hes",
				"hess",
				"heng",
				"hej",
				"hec",
				"hek",
				"het",
				"hep",
				"heh"
			],
			[
				"hyeo",
				"hyeog",
				"hyeogg",
				"hyeogs",
				"hyeon",
				"hyeonj",
				"hyeonh",
				"hyeod",
				"hyeol",
				"hyeolg",
				"hyeolm",
				"hyeolb",
				"hyeols",
				"hyeolt",
				"hyeolp",
				"hyeolh",
				"hyeom",
				"hyeob",
				"hyeobs",
				"hyeos",
				"hyeoss",
				"hyeong",
				"hyeoj",
				"hyeoc",
				"hyeok",
				"hyeot",
				"hyeop",
				"hyeoh",
				"hye",
				"hyeg",
				"hyegg",
				"hyegs",
				"hyen",
				"hyenj",
				"hyenh",
				"hyed",
				"hyel",
				"hyelg",
				"hyelm",
				"hyelb",
				"hyels",
				"hyelt",
				"hyelp",
				"hyelh",
				"hyem",
				"hyeb",
				"hyebs",
				"hyes",
				"hyess",
				"hyeng",
				"hyej",
				"hyec",
				"hyek",
				"hyet",
				"hyep",
				"hyeh",
				"ho",
				"hog",
				"hogg",
				"hogs",
				"hon",
				"honj",
				"honh",
				"hod",
				"hol",
				"holg",
				"holm",
				"holb",
				"hols",
				"holt",
				"holp",
				"holh",
				"hom",
				"hob",
				"hobs",
				"hos",
				"hoss",
				"hong",
				"hoj",
				"hoc",
				"hok",
				"hot",
				"hop",
				"hoh",
				"hwa",
				"hwag",
				"hwagg",
				"hwags",
				"hwan",
				"hwanj",
				"hwanh",
				"hwad",
				"hwal",
				"hwalg",
				"hwalm",
				"hwalb",
				"hwals",
				"hwalt",
				"hwalp",
				"hwalh",
				"hwam",
				"hwab",
				"hwabs",
				"hwas",
				"hwass",
				"hwang",
				"hwaj",
				"hwac",
				"hwak",
				"hwat",
				"hwap",
				"hwah",
				"hwae",
				"hwaeg",
				"hwaegg",
				"hwaegs",
				"hwaen",
				"hwaenj",
				"hwaenh",
				"hwaed",
				"hwael",
				"hwaelg",
				"hwaelm",
				"hwaelb",
				"hwaels",
				"hwaelt",
				"hwaelp",
				"hwaelh",
				"hwaem",
				"hwaeb",
				"hwaebs",
				"hwaes",
				"hwaess",
				"hwaeng",
				"hwaej",
				"hwaec",
				"hwaek",
				"hwaet",
				"hwaep",
				"hwaeh",
				"hoe",
				"hoeg",
				"hoegg",
				"hoegs",
				"hoen",
				"hoenj",
				"hoenh",
				"hoed",
				"hoel",
				"hoelg",
				"hoelm",
				"hoelb",
				"hoels",
				"hoelt",
				"hoelp",
				"hoelh",
				"hoem",
				"hoeb",
				"hoebs",
				"hoes",
				"hoess",
				"hoeng",
				"hoej",
				"hoec",
				"hoek",
				"hoet",
				"hoep",
				"hoeh",
				"hyo",
				"hyog",
				"hyogg",
				"hyogs",
				"hyon",
				"hyonj",
				"hyonh",
				"hyod",
				"hyol",
				"hyolg",
				"hyolm",
				"hyolb",
				"hyols",
				"hyolt",
				"hyolp",
				"hyolh",
				"hyom",
				"hyob",
				"hyobs",
				"hyos",
				"hyoss",
				"hyong",
				"hyoj",
				"hyoc",
				"hyok",
				"hyot",
				"hyop",
				"hyoh",
				"hu",
				"hug",
				"hugg",
				"hugs",
				"hun",
				"hunj",
				"hunh",
				"hud",
				"hul",
				"hulg",
				"hulm",
				"hulb",
				"huls",
				"hult",
				"hulp",
				"hulh",
				"hum",
				"hub",
				"hubs",
				"hus",
				"huss",
				"hung",
				"huj",
				"huc",
				"huk",
				"hut",
				"hup",
				"huh",
				"hweo",
				"hweog",
				"hweogg",
				"hweogs",
				"hweon",
				"hweonj",
				"hweonh",
				"hweod",
				"hweol",
				"hweolg",
				"hweolm",
				"hweolb",
				"hweols",
				"hweolt",
				"hweolp",
				"hweolh",
				"hweom",
				"hweob",
				"hweobs",
				"hweos",
				"hweoss",
				"hweong",
				"hweoj",
				"hweoc",
				"hweok",
				"hweot",
				"hweop",
				"hweoh",
				"hwe",
				"hweg",
				"hwegg",
				"hwegs"
			],
			[
				"hwen",
				"hwenj",
				"hwenh",
				"hwed",
				"hwel",
				"hwelg",
				"hwelm",
				"hwelb",
				"hwels",
				"hwelt",
				"hwelp",
				"hwelh",
				"hwem",
				"hweb",
				"hwebs",
				"hwes",
				"hwess",
				"hweng",
				"hwej",
				"hwec",
				"hwek",
				"hwet",
				"hwep",
				"hweh",
				"hwi",
				"hwig",
				"hwigg",
				"hwigs",
				"hwin",
				"hwinj",
				"hwinh",
				"hwid",
				"hwil",
				"hwilg",
				"hwilm",
				"hwilb",
				"hwils",
				"hwilt",
				"hwilp",
				"hwilh",
				"hwim",
				"hwib",
				"hwibs",
				"hwis",
				"hwiss",
				"hwing",
				"hwij",
				"hwic",
				"hwik",
				"hwit",
				"hwip",
				"hwih",
				"hyu",
				"hyug",
				"hyugg",
				"hyugs",
				"hyun",
				"hyunj",
				"hyunh",
				"hyud",
				"hyul",
				"hyulg",
				"hyulm",
				"hyulb",
				"hyuls",
				"hyult",
				"hyulp",
				"hyulh",
				"hyum",
				"hyub",
				"hyubs",
				"hyus",
				"hyuss",
				"hyung",
				"hyuj",
				"hyuc",
				"hyuk",
				"hyut",
				"hyup",
				"hyuh",
				"heu",
				"heug",
				"heugg",
				"heugs",
				"heun",
				"heunj",
				"heunh",
				"heud",
				"heul",
				"heulg",
				"heulm",
				"heulb",
				"heuls",
				"heult",
				"heulp",
				"heulh",
				"heum",
				"heub",
				"heubs",
				"heus",
				"heuss",
				"heung",
				"heuj",
				"heuc",
				"heuk",
				"heut",
				"heup",
				"heuh",
				"hyi",
				"hyig",
				"hyigg",
				"hyigs",
				"hyin",
				"hyinj",
				"hyinh",
				"hyid",
				"hyil",
				"hyilg",
				"hyilm",
				"hyilb",
				"hyils",
				"hyilt",
				"hyilp",
				"hyilh",
				"hyim",
				"hyib",
				"hyibs",
				"hyis",
				"hyiss",
				"hying",
				"hyij",
				"hyic",
				"hyik",
				"hyit",
				"hyip",
				"hyih",
				"hi",
				"hig",
				"higg",
				"higs",
				"hin",
				"hinj",
				"hinh",
				"hid",
				"hil",
				"hilg",
				"hilm",
				"hilb",
				"hils",
				"hilt",
				"hilp",
				"hilh",
				"him",
				"hib",
				"hibs",
				"his",
				"hiss",
				"hing",
				"hij",
				"hic",
				"hik",
				"hit",
				"hip",
				"hih"
			],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[
				"Kay",
				"Kayng",
				"Ke",
				"Ko",
				"Kol",
				"Koc",
				"Kwi",
				"Kwi",
				"Kyun",
				"Kul",
				"Kum",
				"Na",
				"Na",
				"Na",
				"La",
				"Na",
				"Na",
				"Na",
				"Na",
				"Na",
				"Nak",
				"Nak",
				"Nak",
				"Nak",
				"Nak",
				"Nak",
				"Nak",
				"Nan",
				"Nan",
				"Nan",
				"Nan",
				"Nan",
				"Nan",
				"Nam",
				"Nam",
				"Nam",
				"Nam",
				"Nap",
				"Nap",
				"Nap",
				"Nang",
				"Nang",
				"Nang",
				"Nang",
				"Nang",
				"Nay",
				"Nayng",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"No",
				"Nok",
				"Nok",
				"Nok",
				"Nok",
				"Nok",
				"Nok",
				"Non",
				"Nong",
				"Nong",
				"Nong",
				"Nong",
				"Noy",
				"Noy",
				"Noy",
				"Noy",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nwu",
				"Nuk",
				"Nuk",
				"Num",
				"Nung",
				"Nung",
				"Nung",
				"Nung",
				"Nung",
				"Twu",
				"La",
				"Lak",
				"Lak",
				"Lan",
				"Lyeng",
				"Lo",
				"Lyul",
				"Li",
				"Pey",
				"Pen",
				"Pyen",
				"Pwu",
				"Pwul",
				"Pi",
				"Sak",
				"Sak",
				"Sam",
				"Sayk",
				"Sayng",
				"Sep",
				"Sey",
				"Sway",
				"Sin",
				"Sim",
				"Sip",
				"Ya",
				"Yak",
				"Yak",
				"Yang",
				"Yang",
				"Yang",
				"Yang",
				"Yang",
				"Yang",
				"Yang",
				"Yang",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Ye",
				"Yek",
				"Yek",
				"Yek",
				"Yek",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yen",
				"Yel",
				"Yel",
				"Yel",
				"Yel",
				"Yel",
				"Yel",
				"Yem",
				"Yem",
				"Yem",
				"Yem",
				"Yem",
				"Yep",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yeng",
				"Yey",
				"Yey",
				"Yey",
				"Yey",
				"O",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yo",
				"Yong",
				"Wun",
				"Wen",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yu",
				"Yuk",
				"Yuk",
				"Yuk",
				"Yun",
				"Yun",
				"Yun",
				"Yun",
				"Yul",
				"Yul",
				"Yul",
				"Yul",
				"Yung",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"I",
				"Ik",
				"Ik",
				"In",
				"In",
				"In",
				"In",
				"In",
				"In",
				"In",
				"Im",
				"Im",
				"Im",
				"Ip",
				"Ip",
				"Ip",
				"Cang",
				"Cek",
				"Ci",
				"Cip",
				"Cha",
				"Chek"
			],
			[
				"Chey",
				"Thak",
				"Thak",
				"Thang",
				"Thayk",
				"Thong",
				"Pho",
				"Phok",
				"Hang",
				"Hang",
				"Hyen",
				"Hwak",
				"Wu",
				"Huo",
				,
				,
				"Zhong",
				,
				"Qing",
				,
				,
				"Xi",
				"Zhu",
				"Yi",
				"Li",
				"Shen",
				"Xiang",
				"Fu",
				"Jing",
				"Jing",
				"Yu",
				,
				"Hagi",
				,
				"Zhu",
				,
				,
				"Yi",
				"Du",
				,
				,
				,
				"Fan",
				"Si",
				"Guan"
			],
			[
				"ff",
				"fi",
				"fl",
				"ffi",
				"ffl",
				"st",
				"st",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"mn",
				"me",
				"mi",
				"vn",
				"mkh",
				,
				,
				,
				,
				,
				"yi",
				,
				"ay",
				"`",
				,
				"d",
				"h",
				"k",
				"l",
				"m",
				"m",
				"t",
				"+",
				"sh",
				"s",
				"sh",
				"s",
				"a",
				"a",
				,
				"b",
				"g",
				"d",
				"h",
				"v",
				"z",
				,
				"t",
				"y",
				"k",
				"k",
				"l",
				,
				"l",
				,
				"n",
				"n",
				,
				"p",
				"p",
				,
				"ts",
				"ts",
				"r",
				"sh",
				"t",
				"vo",
				"b",
				"k",
				"p",
				"l"
			],
			[],
			[],
			[
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"~",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"..",
				"--",
				"-",
				"_",
				"_",
				"(",
				") ",
				"{",
				"} ",
				"[",
				"] ",
				"[(",
				")] ",
				"<<",
				">> ",
				"<",
				"> ",
				"[",
				"] ",
				"{",
				"}",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				",",
				",",
				".",
				,
				";",
				":",
				"?",
				"!",
				"-",
				"(",
				")",
				"{",
				"}",
				"{",
				"}",
				"#",
				"&",
				"*",
				"+",
				"-",
				"<",
				">",
				"=",
				,
				"\\",
				"$",
				"%",
				"@"
			],
			[
				,
				"!",
				"\"",
				"#",
				"$",
				"%",
				"&",
				"'",
				"(",
				")",
				"*",
				"+",
				",",
				"-",
				".",
				"/",
				"0",
				"1",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				":",
				";",
				"<",
				"=",
				">",
				"?",
				"@",
				"A",
				"B",
				"C",
				"D",
				"E",
				"F",
				"G",
				"H",
				"I",
				"J",
				"K",
				"L",
				"M",
				"N",
				"O",
				"P",
				"Q",
				"R",
				"S",
				"T",
				"U",
				"V",
				"W",
				"X",
				"Y",
				"Z",
				"[",
				"\\",
				"]",
				"^",
				"_",
				"`",
				"a",
				"b",
				"c",
				"d",
				"e",
				"f",
				"g",
				"h",
				"i",
				"j",
				"k",
				"l",
				"m",
				"n",
				"o",
				"p",
				"q",
				"r",
				"s",
				"t",
				"u",
				"v",
				"w",
				"x",
				"y",
				"z",
				"{",
				"|",
				"}",
				"~",
				,
				,
				".",
				"[",
				"]",
				",",
				"*",
				"wo",
				"a",
				"i",
				"u",
				"e",
				"o",
				"ya",
				"yu",
				"yo",
				"tu",
				"+",
				"a",
				"i",
				"u",
				"e",
				"o",
				"ka",
				"ki",
				"ku",
				"ke",
				"ko",
				"sa",
				"si",
				"su",
				"se",
				"so",
				"ta",
				"ti",
				"tu",
				"te",
				"to",
				"na",
				"ni",
				"nu",
				"ne",
				"no",
				"ha",
				"hi",
				"hu",
				"he",
				"ho",
				"ma",
				"mi",
				"mu",
				"me",
				"mo",
				"ya",
				"yu",
				"yo",
				"ra",
				"ri",
				"ru",
				"re",
				"ro",
				"wa",
				"n",
				":",
				";",
				,
				"g",
				"gg",
				"gs",
				"n",
				"nj",
				"nh",
				"d",
				"dd",
				"r",
				"lg",
				"lm",
				"lb",
				"ls",
				"lt",
				"lp",
				"rh",
				"m",
				"b",
				"bb",
				"bs",
				"s",
				"ss",
				,
				"j",
				"jj",
				"c",
				"k",
				"t",
				"p",
				"h",
				,
				,
				,
				"a",
				"ae",
				"ya",
				"yae",
				"eo",
				"e",
				,
				,
				"yeo",
				"ye",
				"o",
				"wa",
				"wae",
				"oe",
				,
				,
				"yo",
				"u",
				"weo",
				"we",
				"wi",
				"yu",
				,
				,
				"eu",
				"yi",
				"i",
				,
				,
				,
				"/C",
				"PS",
				"!",
				"-",
				"|",
				"Y=",
				"W=",
				,
				"|",
				"-",
				"|",
				"-",
				"|",
				"#",
				"O",
				,
				,
				,
				,
				,
				,
				,
				,
				,
				,
				"{",
				"|",
				"}"
			]
		], Xu = {}, Du = 0; Du < ku.length; Du++) for (var Hu = 0; Hu < ku[Du].length; Hu++) {
			var Tu = ku[Du][Hu];
			if ("string" == typeof Tu && Tu.length) {
				var Qu = String.fromCharCode((Du << 8) + Hu);
				Xu[Qu] = Tu;
			}
		}
		ku = void 0;
		var Bu = function(n$7, a$2) {
			var i$3 = [][n$7];
			return !!i$3 && t$1((function() {
				i$3.call(null, a$2 || function() {
					return 1;
				}, 1);
			}));
		}, Mu = ca.indexOf, Gu = S$1([].indexOf), Fu = !!Gu && 1 / Gu([1], 1, -0) < 0, Pu = Bu("indexOf");
		fa({
			target: "Array",
			proto: !0,
			forced: Fu || !Pu
		}, { indexOf: function(n$7) {
			var a$2 = arguments.length > 1 ? arguments[1] : void 0;
			return Fu ? Gu(this, n$7, a$2) || 0 : Mu(this, n$7, a$2);
		} });
		var Nu = TypeError, fu = function(n$7, a$2) {
			if (!delete n$7[a$2]) throw Nu("Cannot delete property " + q$1(a$2) + " of " + q$1(n$7));
		}, Wu = function(n$7, a$2, i$3) {
			var e$2 = Ln(a$2);
			e$2 in n$7 ? Pn.f(n$7, e$2, c$1(0, i$3)) : n$7[e$2] = i$3;
		}, Ku = Array, xu = Math.max, Ru = function(n$7, a$2, i$3) {
			for (var e$2 = pa(n$7), u$2 = da(a$2, e$2), o$2 = da(void 0 === i$3 ? e$2 : i$3, e$2), g$4 = Ku(xu(o$2 - u$2, 0)), h$2 = 0; u$2 < o$2; u$2++, h$2++) Wu(g$4, h$2, n$7[u$2]);
			return g$4.length = h$2, g$4;
		}, Eu = Math.floor, Au = function(n$7, a$2) {
			var i$3 = n$7.length, e$2 = Eu(i$3 / 2);
			return i$3 < 8 ? vu(n$7, a$2) : zu(n$7, Au(Ru(n$7, 0, e$2), a$2), Au(Ru(n$7, e$2), a$2), a$2);
		}, vu = function(n$7, a$2) {
			for (var i$3, e$2, u$2 = n$7.length, o$2 = 1; o$2 < u$2;) {
				for (e$2 = o$2, i$3 = n$7[o$2]; e$2 && a$2(n$7[e$2 - 1], i$3) > 0;) n$7[e$2] = n$7[--e$2];
				e$2 !== o$2++ && (n$7[e$2] = i$3);
			}
			return n$7;
		}, zu = function(n$7, a$2, i$3, e$2) {
			for (var u$2 = a$2.length, o$2 = i$3.length, g$4 = 0, h$2 = 0; g$4 < u$2 || h$2 < o$2;) n$7[g$4 + h$2] = g$4 < u$2 && h$2 < o$2 ? e$2(a$2[g$4], i$3[h$2]) <= 0 ? a$2[g$4++] : i$3[h$2++] : g$4 < u$2 ? a$2[g$4++] : i$3[h$2++];
			return n$7;
		}, Ou = Au, Iu = W$1.match(/firefox\/(\d+)/i), Uu = !!Iu && +Iu[1], qu = /MSIE|Trident/.test(W$1), Vu = W$1.match(/AppleWebKit\/(\d+)\./), _u = !!Vu && +Vu[1], $u = [], no = S$1($u.sort), ao = S$1($u.push), io = t$1((function() {
			$u.sort(void 0);
		})), eo = t$1((function() {
			$u.sort(null);
		})), uo = Bu("sort"), oo = !t$1((function() {
			if (A$1) return A$1 < 70;
			if (!(Uu && Uu > 3)) {
				if (qu) return !0;
				if (_u) return _u < 603;
				var n$7, a$2, i$3, e$2, u$2 = "";
				for (n$7 = 65; n$7 < 76; n$7++) {
					switch (a$2 = String.fromCharCode(n$7), n$7) {
						case 66:
						case 69:
						case 70:
						case 72:
							i$3 = 3;
							break;
						case 68:
						case 71:
							i$3 = 4;
							break;
						default: i$3 = 2;
					}
					for (e$2 = 0; e$2 < 47; e$2++) $u.push({
						k: a$2 + e$2,
						v: i$3
					});
				}
				for ($u.sort((function(n$8, a$3) {
					return a$3.v - n$8.v;
				})), e$2 = 0; e$2 < $u.length; e$2++) a$2 = $u[e$2].k.charAt(0), u$2.charAt(u$2.length - 1) !== a$2 && (u$2 += a$2);
				return "DGBEFHACIJK" !== u$2;
			}
		}));
		fa({
			target: "Array",
			proto: !0,
			forced: io || !eo || !uo || !oo
		}, { sort: function(n$7) {
			void 0 !== n$7 && _$1(n$7);
			var a$2 = hn(this);
			if (oo) return void 0 === n$7 ? no(a$2) : no(a$2, n$7);
			var i$3, e$2, u$2 = [], o$2 = pa(a$2);
			for (e$2 = 0; e$2 < o$2; e$2++) e$2 in a$2 && ao(u$2, a$2[e$2]);
			for (Ou(u$2, function(n$8) {
				return function(a$3, i$4) {
					return void 0 === i$4 ? -1 : void 0 === a$3 ? 1 : void 0 !== n$8 ? +n$8(a$3, i$4) || 0 : ai(a$3) > ai(i$4) ? 1 : -1;
				};
			}(n$7)), i$3 = u$2.length, e$2 = 0; e$2 < i$3;) a$2[e$2] = u$2[e$2++];
			for (; e$2 < o$2;) fu(a$2, e$2++);
			return a$2;
		} });
		var go = nu.forEach, ho = Bu("forEach") ? [].forEach : function(n$7) {
			return go(this, n$7, arguments.length > 1 ? arguments[1] : void 0);
		};
		fa({
			target: "Array",
			proto: !0,
			forced: [].forEach != ho
		}, { forEach: ho });
		var so = {
			CSSRuleList: 0,
			CSSStyleDeclaration: 0,
			CSSValueList: 0,
			ClientRectList: 0,
			DOMRectList: 0,
			DOMStringList: 0,
			DOMTokenList: 1,
			DataTransferItemList: 0,
			FileList: 0,
			HTMLAllCollection: 0,
			HTMLCollection: 0,
			HTMLFormElement: 0,
			HTMLSelectElement: 0,
			MediaList: 0,
			MimeTypeArray: 0,
			NamedNodeMap: 0,
			NodeList: 1,
			PaintRequestList: 0,
			Plugin: 0,
			PluginArray: 0,
			SVGLengthList: 0,
			SVGNumberList: 0,
			SVGPathSegList: 0,
			SVGPointList: 0,
			SVGStringList: 0,
			SVGTransformList: 0,
			SourceBufferList: 0,
			StyleSheetList: 0,
			TextTrackCueList: 0,
			TextTrackList: 0,
			TouchList: 0
		}, yo = Cn("span").classList, lo = yo && yo.constructor && yo.constructor.prototype, to = lo === Object.prototype ? void 0 : lo, bo = function(n$7) {
			if (n$7 && n$7.forEach !== ho) try {
				Nn(n$7, "forEach", ho);
			} catch (a$2) {
				n$7.forEach = ho;
			}
		};
		for (var wo in so) so[wo] && bo(l$2[wo] && l$2[wo].prototype);
		bo(to);
		var jo = S$1([].slice), ro = iu("slice"), po = Yn("species"), Yo = Array, co = Math.max;
		fa({
			target: "Array",
			proto: !0,
			forced: !ro
		}, { slice: function(n$7, a$2) {
			var i$3, e$2, u$2, o$2 = M$1(this), g$4 = pa(o$2), h$2 = da(n$7, g$4), s$3 = da(void 0 === a$2 ? g$4 : a$2, g$4);
			if (We(o$2) && (i$3 = o$2.constructor, (Ie(i$3) && (i$3 === Yo || We(i$3.prototype)) || F$1(i$3) && null === (i$3 = i$3[po])) && (i$3 = void 0), i$3 === Yo || void 0 === i$3)) return jo(o$2, h$2, s$3);
			for (e$2 = new (void 0 === i$3 ? Yo : i$3)(co(s$3 - h$2, 0)), u$2 = 0; h$2 < s$3; h$2++, u$2++) h$2 in o$2 && Wu(e$2, u$2, o$2[h$2]);
			return e$2.length = u$2, e$2;
		} });
		var mo = S$1([].join), Zo = T$1 != Object, Lo = Bu("join", ",");
		function Jo(n$7) {
			return (n$7 || "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
		}
		function So(n$7) {
			return /[\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DBF\u4E00-\u9FFC\uF900-\uFA6D\uFA70-\uFAD9]|\uD81B[\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]/.test(n$7);
		}
		function Co(n$7) {
			return /[\s!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/.test(n$7);
		}
		function ko(n$7) {
			switch (!0) {
				case n$7 instanceof Array:
					for (var a$2 = [], i$3 = 0; i$3 < n$7.length; i$3++) a$2[i$3] = ko(n$7[i$3]);
					return a$2;
				case n$7 instanceof Date: return new Date(n$7.valueOf());
				case n$7 instanceof RegExp: return new RegExp(n$7.source, n$7.flags);
				case n$7 instanceof Object:
					var e$2 = {};
					for (var u$2 in n$7) Object.prototype.hasOwnProperty.call(n$7, u$2) && (e$2[u$2] = ko(n$7[u$2]));
					return e$2;
				default: return n$7;
			}
		}
		function Xo(n$7, a$2) {
			if (0 === a$2.length) return !1;
			var i$3 = Math.floor(a$2.length / 2);
			switch (function(n$8, a$3) {
				switch (!0) {
					case n$8 < a$3[0]: return -1;
					case n$8 > a$3[1]: return 1;
				}
				return 0;
			}(n$7, a$2[i$3])) {
				case -1: return Xo(n$7, a$2.slice(0, i$3));
				case 1: return Xo(n$7, a$2.slice(i$3 + 1));
			}
			return !0;
		}
		function Do(n$7, a$2, i$3, e$2) {
			void 0 === e$2 && (e$2 = []);
			for (var u$2 = e$2.length ? RegExp(e$2.map(Jo).join("|"), "g") : null, o$2 = RegExp(a$2.source, a$2.flags.replace("g", "") + "g"), g$4 = "", h$2 = 0;;) {
				var s$3 = o$2.exec(n$7), y$2 = "", l$3 = 0;
				if (!s$3) {
					g$4 += n$7.substring(h$2, n$7.length);
					break;
				}
				for (;;) {
					var t$2 = u$2 ? u$2.exec(s$3[0]) : null;
					if (!t$2) {
						y$2 += s$3[0].length > l$3 ? i$3 : "";
						break;
					}
					y$2 += t$2.index > l$3 ? i$3 : "", y$2 += t$2[0], l$3 = u$2.lastIndex;
				}
				g$4 += n$7.substring(h$2, s$3.index) + y$2, h$2 = o$2.lastIndex;
			}
			return g$4;
		}
		fa({
			target: "Array",
			proto: !0,
			forced: Zo || !Lo
		}, { join: function(n$7) {
			return mo(M$1(this), void 0 === n$7 ? "," : n$7);
		} });
		var Ho = {
			ignore: [],
			replace: [],
			replaceAfter: [],
			trim: !1,
			unknown: "",
			fixChineseSpacing: !0
		}, To = function() {
			function n$7(n$8, a$3) {
				void 0 === n$8 && (n$8 = ko(Ho)), void 0 === a$3 && (a$3 = Xu), this.confOptions = n$8, this.map = a$3;
			}
			var a$2 = n$7.prototype;
			return a$2.config = function(n$8, a$3) {
				return void 0 === a$3 && (a$3 = !1), a$3 && (this.confOptions = {}), n$8 && "object" == typeof n$8 && (this.confOptions = ko(n$8)), this.confOptions;
			}, a$2.codeMapReplace = function(n$8, a$3, i$3) {
				var e$2 = this;
				void 0 === a$3 && (a$3 = []);
				for (var o$2 = 0, g$4 = "", h$2 = i$3.fixChineseSpacing && So(n$8), s$3 = !1, y$2 = 0; y$2 < n$8.length; y$2++) {
					var l$3 = /[\uD800-\uDBFF]/.test(n$8[y$2]) && /[\uDC00-\uDFFF]/.test(n$8[y$2 + 1]) ? n$8[y$2] + n$8[y$2 + 1] : n$8[y$2], t$2 = void 0, b$6 = !1;
					switch (!0) {
						case Xo(o$2, a$3):
						case 2 === l$3.length && Xo(o$2 + 1, a$3):
							t$2 = l$3, a$3.find(function(n$9) {
								return u$1(this, e$2), n$9[1] >= o$2 && n$9[0] === o$2;
							}.bind(this)) || (b$6 = !0);
							break;
						default: t$2 = this.map[l$3] || i$3.unknown || "";
					}
					h$2 && (!s$3 || b$6 || Co(t$2) || (t$2 = " " + t$2), s$3 = !!t$2 && So(l$3)), g$4 += t$2, o$2 += l$3.length, y$2 += l$3.length - 1;
				}
				return g$4;
			}, a$2.formatReplaceOption = function(n$8) {
				if (n$8 instanceof Array) return ko(n$8);
				var a$3 = [];
				for (var i$3 in n$8) Object.prototype.hasOwnProperty.call(n$8, i$3) && a$3.push([i$3, n$8[i$3]]);
				return a$3;
			}, a$2.replaceString = function(n$8, a$3, i$3) {
				void 0 === i$3 && (i$3 = []);
				for (var e$2 = ko(a$3), u$2 = n$8, o$2 = 0; o$2 < e$2.length; o$2++) {
					var g$4 = e$2[o$2];
					switch (!0) {
						case g$4[0] instanceof RegExp:
							g$4[0] = RegExp(g$4[0].source, g$4[0].flags.replace("g", "") + "g");
							break;
						case "string" == typeof g$4[0] && g$4[0].length > 0:
							g$4[0] = RegExp(Jo(g$4[0]), "g");
							break;
						default: g$4[0] = /[^\s\S]/;
					}
					u$2 = Do(u$2, g$4[0], g$4[1], i$3);
				}
				return u$2;
			}, a$2.setData = function(n$8, a$3) {
				if (void 0 === a$3 && (a$3 = !1), a$3 && (this.map = ko(Xu)), n$8 && "object" == typeof n$8 && Object.keys(n$8).length) for (var i$3 in this.map = ko(this.map), n$8) Object.prototype.hasOwnProperty.call(n$8, i$3) && i$3.length < 3 && i$3 <= "􏿿" && (this.map[i$3] = n$8[i$3]);
				return this.map;
			}, a$2.transliterate = function(n$8, a$3) {
				a$3 = "object" == typeof a$3 ? a$3 : {};
				var i$3 = ko(Object.assign(Object.assign({}, this.options), a$3)), e$2 = "string" == typeof n$8 ? n$8 : String(n$8), o$2 = this.formatReplaceOption(i$3.replace);
				o$2.length && (e$2 = this.replaceString(e$2, o$2, i$3.ignore));
				var g$4 = i$3.ignore && i$3.ignore.length > 0 ? function(n$9, a$4) {
					for (var i$4 = this, e$3 = [], o$3 = 0; o$3 < a$4.length; o$3++) for (var g$5 = a$4[o$3], h$3 = -1; (h$3 = n$9.indexOf(g$5, h$3 + 1)) > -1;) e$3.push([h$3, h$3 + g$5.length - 1]);
					var s$3, y$2 = e$3.sort(function(n$10, a$5) {
						return u$1(this, i$4), n$10[0] - a$5[0] || n$10[1] - a$5[1];
					}.bind(this));
					return e$3 = [], y$2.forEach(function(n$10) {
						return u$1(this, i$4), !s$3 || n$10[0] > s$3[1] + 1 ? e$3.push(s$3 = n$10) : n$10[1] > s$3[1] && (s$3[1] = n$10[1]);
					}.bind(this)), e$3;
				}(e$2, i$3.ignore) : [];
				e$2 = this.codeMapReplace(e$2, g$4, i$3), i$3.trim && (e$2 = e$2.trim());
				var h$2 = this.formatReplaceOption(i$3.replaceAfter);
				return h$2.length && (e$2 = this.replaceString(e$2, h$2)), e$2;
			}, i$2(n$7, [{
				key: "options",
				get: function() {
					return ko(Object.assign(Object.assign({}, Ho), this.confOptions));
				}
			}]), n$7;
		}(), Qo = Object.assign(Object.assign({}, ko(Ho)), {
			allowedChars: "a-zA-Z0-9-_.~",
			lowercase: !0,
			separator: "-",
			uppercase: !1,
			fixChineseSpacing: !0
		}), Bo = function(n$7) {
			var a$2, u$2;
			function o$2() {
				return n$7.apply(this, arguments) || this;
			}
			u$2 = n$7, (a$2 = o$2).prototype = Object.create(u$2.prototype), a$2.prototype.constructor = a$2, e$1(a$2, u$2);
			var g$4 = o$2.prototype;
			return g$4.config = function(n$8, a$3) {
				return void 0 === a$3 && (a$3 = !1), a$3 && (this.confOptions = {}), n$8 && "object" == typeof n$8 && (this.confOptions = ko(n$8)), this.confOptions;
			}, g$4.slugify = function(n$8, a$3) {
				a$3 = "object" == typeof a$3 ? a$3 : {};
				var i$3 = ko(Object.assign(Object.assign({}, this.options), a$3)), e$2 = i$3.separator ? Jo(i$3.separator) : "", u$3 = this.transliterate(n$8, i$3);
				return u$3 = Do(u$3, RegExp("[^" + i$3.allowedChars + "]+", "g"), i$3.separator, i$3.ignore), e$2 && (u$3 = u$3.replace(RegExp("^" + e$2 + "+|" + e$2 + "$", "g"), "")), i$3.lowercase && (u$3 = u$3.toLowerCase()), i$3.uppercase && (u$3 = u$3.toUpperCase()), u$3;
			}, i$2(o$2, [{
				key: "options",
				get: function() {
					return ko(Object.assign(Object.assign({}, Qo), this.confOptions));
				}
			}]), o$2;
		}(To), Mo = new To(), Go = Mo.transliterate.bind(Mo);
		Go.config = Mo.config.bind(Mo), Go.setData = Mo.setData.bind(Mo);
		var Fo = new Bo(), Po = Fo.slugify.bind(Fo);
		Po.config = Fo.config.bind(Fo), Po.setData = Fo.setData.bind(Fo), n$6.slugify = Po, n$6.transl = Go, n$6.transliterate = Go, Object.defineProperty(n$6, "__esModule", { value: !0 });
	}));
}));
function format$1(value, extraArgs) {
	const [locales = "en-US", config$1 = {}] = extraArgs;
	return new Intl.NumberFormat(locales, config$1).format(value);
}
function isEven(value) {
	if (!Number.isInteger(value)) throw new ExpressionExtensionError("isEven() is only callable on integers");
	return value % 2 === 0;
}
function isOdd(value) {
	if (!Number.isInteger(value)) throw new ExpressionExtensionError("isOdd() is only callable on integers");
	return Math.abs(value) % 2 === 1;
}
function floor(value) {
	return Math.floor(value);
}
function ceil(value) {
	return Math.ceil(value);
}
function abs(value) {
	return Math.abs(value);
}
function isInteger(value) {
	return Number.isInteger(value);
}
function round(value, extraArgs) {
	const [decimalPlaces = 0] = extraArgs;
	return +value.toFixed(decimalPlaces);
}
function toBoolean$2(value) {
	return value !== 0;
}
function toInt$2(value) {
	return round(value, []);
}
function toFloat$2(value) {
	return value;
}
function toDateTime$2(value, extraArgs) {
	const [valueFormat = "ms"] = extraArgs;
	if (![
		"ms",
		"s",
		"us",
		"excel"
	].includes(valueFormat)) throw new ExpressionExtensionError(`Unsupported format '${String(valueFormat)}'. toDateTime() supports 'ms', 's', 'us' and 'excel'.`);
	switch (valueFormat) {
		case "excel": return DateTime.fromSeconds((value - 25569) * 86400);
		case "s": return DateTime.fromSeconds(value);
		case "us": return DateTime.fromMillis(value / 1e3);
		case "ms":
		default: return DateTime.fromMillis(value);
	}
}
ceil.doc = {
	name: "ceil",
	description: "Rounds the number up to the next whole number",
	examples: [{
		example: "(1.234).ceil()",
		evaluated: "2"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-ceil"
};
floor.doc = {
	name: "floor",
	description: "Rounds the number down to the nearest whole number",
	examples: [{
		example: "(1.234).floor()",
		evaluated: "1"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-floor"
};
isEven.doc = {
	name: "isEven",
	description: "Returns <code>true</code> if the number is even or <code>false</code> if not. Throws an error if the number isn't a whole number.",
	examples: [{
		example: "(33).isEven()",
		evaluated: "false"
	}, {
		example: "(42).isEven()",
		evaluated: "true"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isEven"
};
isOdd.doc = {
	name: "isOdd",
	description: "Returns <code>true</code> if the number is odd or <code>false</code> if not. Throws an error if the number isn't a whole number.",
	examples: [{
		example: "(33).isOdd()",
		evaluated: "true"
	}, {
		example: "(42).isOdd()",
		evaluated: "false"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isOdd"
};
format$1.doc = {
	name: "format",
	description: "Returns a formatted string representing the number. Useful for formatting for a specific language or currency. The same as <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat”><code>Intl.NumberFormat()</code></a>.",
	examples: [{
		example: "(123456.789).format('de-DE')",
		evaluated: "123.456,789"
	}, {
		example: "(123456.789).format('de-DE', {'style': 'currency', 'currency': 'EUR'})",
		evaluated: "123.456,79 €"
	}],
	returnType: "string",
	args: [{
		name: "locale",
		optional: true,
		description: "A <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument”>locale tag</a> for formatting the number, e.g. <code>fr-FR</code>, <code>en-GB</code>, <code>pr-BR</code>",
		default: "\"en-US\"",
		type: "string"
	}, {
		name: "options",
		optional: true,
		description: "Configuration options for number formatting. <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat\" target=\"_blank\">More info</a>",
		type: "object"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-format"
};
round.doc = {
	name: "round",
	description: "Rounds the number to the nearest integer (or decimal place)",
	examples: [
		{
			example: "(1.256).round()",
			evaluated: "1"
		},
		{
			example: "(1.256).round(1)",
			evaluated: "1.3"
		},
		{
			example: "(1.256).round(2)",
			evaluated: "1.26"
		}
	],
	returnType: "number",
	args: [{
		name: "decimalPlaces",
		optional: true,
		description: "The number of decimal places to round to",
		default: "0",
		type: "number"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-round"
};
toBoolean$2.doc = {
	name: "toBoolean",
	description: "Returns <code>false</code> for <code>0</code> and <code>true</code> for any other number (including negative numbers).",
	examples: [
		{
			example: "(12).toBoolean()",
			evaluated: "true"
		},
		{
			example: "(0).toBoolean()",
			evaluated: "false"
		},
		{
			example: "(-1.3).toBoolean()",
			evaluated: "true"
		}
	],
	section: "cast",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-toBoolean"
};
toDateTime$2.doc = {
	name: "toDateTime",
	description: "Converts a numerical timestamp into a <a target=\"_blank\" href=\"https://moment.github.io/luxon/api-docs/\">Luxon</a> DateTime. The format of the timestamp must be specified if it's not in milliseconds. Uses the timezone specified in workflow settings if available; otherwise, it defaults to the timezone set for the instance.",
	examples: [
		{
			example: "(1708695471).toDateTime('s')",
			evaluated: "2024-02-23T14:37:51.000+01:00"
		},
		{
			example: "(1708695471000).toDateTime('ms')",
			evaluated: "2024-02-23T14:37:51.000+01:00"
		},
		{
			example: "(1708695471000000).toDateTime('us')",
			evaluated: "2024-02-23T14:37:51.000+01:00"
		},
		{
			example: "(45345).toDateTime('excel')",
			evaluated: "2024-02-23T01:00:00.000+01:00"
		}
	],
	section: "cast",
	returnType: "DateTime",
	args: [{
		name: "format",
		optional: true,
		description: "The type of timestamp to convert. Options are <code>ms</code> (for Unix timestamp in milliseconds), <code>s</code> (for Unix timestamp in seconds), <code>us</code> (for Unix timestamp in microseconds) or <code>excel</code> (for days since 1900).",
		default: "\"ms\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-toDateTime"
};
abs.doc = {
	name: "abs",
	description: "Returns the number's absolute value, i.e. removes any minus sign",
	examples: [{
		example: "(-1.7).abs()",
		evaluated: "1.7"
	}, {
		example: "(1.7).abs()",
		evaluated: "1.7"
	}],
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-abs"
};
isInteger.doc = {
	name: "isInteger",
	description: "Returns <code>true</code> if the number is a whole number",
	examples: [
		{
			example: "(4).isInteger()",
			evaluated: "true"
		},
		{
			example: "(4.12).isInteger()",
			evaluated: "false"
		},
		{
			example: "(-4).isInteger()",
			evaluated: "true"
		}
	],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isInteger"
};
const numberExtensions = {
	typeName: "Number",
	functions: {
		ceil,
		floor,
		format: format$1,
		round,
		abs,
		isInteger,
		isEven,
		isOdd,
		toBoolean: toBoolean$2,
		toInt: toInt$2,
		toFloat: toFloat$2,
		toDateTime: toDateTime$2
	}
};
var import_md5 = /* @__PURE__ */ __toESM(require_md5());
var import_bundle_umd_min = /* @__PURE__ */ __toESM(require_bundle_umd_min());
const SupportedHashAlgorithms = [
	"md5",
	"sha1",
	"sha224",
	"sha256",
	"sha384",
	"sha512",
	"sha3"
];
var CURRENCY_REGEXP = /(\u004c\u0065\u006b|\u060b|\u0024|\u0192|\u20bc|\u0042\u0072|\u0042\u005a\u0024|\u0024\u0062|\u004b\u004d|\u0050|\u043b\u0432|\u0052\u0024|\u17db|\u00a5|\u20a1|\u006b\u006e|\u20b1|\u004b\u010d|\u006b\u0072|\u0052\u0044\u0024|\u00a3|\u20ac|\u00a2|\u0051|\u004c|\u0046\u0074|\u20b9|\u0052\u0070|\ufdfc|\u20aa|\u004a\u0024|\u20a9|\u20ad|\u0434\u0435\u043d|\u0052\u004d|\u20a8|\u20ae|\u004d\u0054|\u0043\u0024|\u20a6|\u0042\u002f\u002e|\u0047\u0073|\u0053\u002f\u002e|\u007a\u0142|\u006c\u0065\u0069|\u20bd|\u0414\u0438\u043d\u002e|\u0053|\u0052|\u0043\u0048\u0046|\u004e\u0054\u0024|\u0e3f|\u0054\u0054\u0024|\u20ba|\u20b4|\u0024\u0055|\u0042\u0073|\u20ab|\u005a\u0024)/gu;
var DOMAIN_EXTRACT_REGEXP = /^(?:(?:https?|ftp):\/\/)?(?:mailto:)?(?:\/\/)?((?:www\.)?(?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;
var DOMAIN_REGEXP = /^(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;
var EMAIL_REGEXP = /(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@(?<domain>(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
var URL_REGEXP_EXACT = /^(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*$/i;
var URL_REGEXP = /(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*/i;
var CHAR_TEST_REGEXP = /\p{L}/u;
var PUNC_TEST_REGEXP = /[!?.]/;
function hash(value, extraArgs) {
	const algorithm = extraArgs[0]?.toLowerCase() ?? "md5";
	switch (algorithm) {
		case "base64": return encode(value);
		case "md5": return (0, import_md5.default)(value);
		case "sha1":
		case "sha224":
		case "sha256":
		case "sha384":
		case "sha512":
		case "sha3":
			const variant = {
				sha1: "SHA-1",
				sha224: "SHA-224",
				sha256: "SHA-256",
				sha384: "SHA-384",
				sha512: "SHA-512",
				sha3: "SHA3-512"
			}[algorithm];
			return new ht(variant, "TEXT").update(value).getHash("HEX");
		default: throw new ExpressionExtensionError(`Unknown algorithm ${algorithm}. Available algorithms are: ${SupportedHashAlgorithms.join()}, and Base64.`);
	}
}
function isEmpty$2(value) {
	return value === "";
}
function isNotEmpty$2(value) {
	return !isEmpty$2(value);
}
function length(value) {
	return value.length;
}
function toJsonString(value) {
	return JSON.stringify(value);
}
function removeMarkdown(value) {
	let output = value;
	try {
		output = output.replace(/^([\s\t]*)([*\-+]|\d\.)\s+/gm, "$1");
		output = output.replace(/\n={2,}/g, "\n").replace(/~~/g, "").replace(/`{3}.*\n/g, "");
		output = output.replace(/<[\w|\s|=|'|"|:|(|)|,|;|/|0-9|.|-]+[>|\\>]/g, "").replace(/^[=-]{2,}\s*$/g, "").replace(/\[\^.+?\](: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/!\[.*?\][[(].*?[\])]/g, "").replace(/\[(.*?)\][[(].*?[\])]/g, "$1").replace(/>/g, "").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^#{1,6}\s*([^#]*)\s*(#{1,6})?/gm, "$1").replace(/([*_]{1,3})(\S.*?\S)\1/g, "$2").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/^-{3,}\s*$/g, "").replace(/`(.+?)`/g, "$1").replace(/\n{2,}/g, "\n\n");
	} catch (e$1) {
		return value;
	}
	return output;
}
function removeTags(value) {
	return value.replace(/<[^>]*>?/gm, "");
}
function toDate(value) {
	const date = new Date(Date.parse(value));
	if (date.toString() === "Invalid Date") throw new ExpressionExtensionError("cannot convert to date");
	if (!/:/.test(value)) date.setHours(0, 0, 0);
	return date;
}
function toDateTime(value, extraArgs = [""]) {
	try {
		const [valueFormat] = extraArgs;
		if (valueFormat) {
			if (valueFormat === "ms" || valueFormat === "s" || valueFormat === "us" || valueFormat === "excel") return toDateTime$2(Number(value), [valueFormat]);
			return DateTime.fromFormat(value, valueFormat);
		}
		return tryToParseDateTime(value);
	} catch (error$1) {
		throw new ExpressionExtensionError("cannot convert to Luxon DateTime");
	}
}
function urlDecode(value, extraArgs) {
	const [entireString = false] = extraArgs;
	if (entireString) return decodeURI(value.toString());
	return decodeURIComponent(value.toString());
}
function urlEncode(value, extraArgs) {
	const [entireString = false] = extraArgs;
	if (entireString) return encodeURI(value.toString());
	return encodeURIComponent(value.toString());
}
function toInt$1(value, extraArgs) {
	const [radix] = extraArgs;
	const int$1 = parseInt(value.replace(CURRENCY_REGEXP, ""), radix);
	if (isNaN(int$1)) throw new ExpressionExtensionError("cannot convert to integer");
	return int$1;
}
function toFloat$1(value) {
	if (value.includes(",")) throw new ExpressionExtensionError("cannot convert to float, expected . as decimal separator");
	const float = parseFloat(value.replace(CURRENCY_REGEXP, ""));
	if (isNaN(float)) throw new ExpressionExtensionError("cannot convert to float");
	return float;
}
function toNumber(value) {
	const num = Number(value.replace(CURRENCY_REGEXP, ""));
	if (isNaN(num)) throw new ExpressionExtensionError("cannot convert to number");
	return num;
}
function quote(value, extraArgs) {
	const [quoteChar = "\""] = extraArgs;
	return `${quoteChar}${value.replace(/\\/g, "\\\\").replace(new RegExp(`\\${quoteChar}`, "g"), `\\${quoteChar}`)}${quoteChar}`;
}
function isNumeric(value) {
	if (value.includes(" ")) return false;
	return !isNaN(value) && !isNaN(parseFloat(value));
}
function isUrl(value) {
	return URL_REGEXP_EXACT.test(value);
}
function isDomain(value) {
	return DOMAIN_REGEXP.test(value);
}
function isEmail(value) {
	const result = EMAIL_REGEXP.test(value);
	if (result && value.includes(" ")) return false;
	return result;
}
function toTitleCase(value) {
	return titleCase(value);
}
function replaceSpecialChars(value) {
	return (0, import_bundle_umd_min.transliterate)(value, { unknown: "?" });
}
function toSentenceCase(value) {
	let current = value.slice();
	let buffer$1 = "";
	while (CHAR_TEST_REGEXP.test(current)) {
		const charIndex = current.search(CHAR_TEST_REGEXP);
		current = current.slice(0, charIndex) + current[charIndex].toLocaleUpperCase() + current.slice(charIndex + 1).toLocaleLowerCase();
		const puncIndex = current.search(PUNC_TEST_REGEXP);
		if (puncIndex === -1) {
			buffer$1 += current;
			current = "";
			break;
		}
		buffer$1 += current.slice(0, puncIndex + 1);
		current = current.slice(puncIndex + 1);
	}
	return buffer$1;
}
function toSnakeCase(value) {
	return value.toLocaleLowerCase().replace(/[ \-]/g, "_").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,.\/:;<=>?@\[\]^`{|}~]/g, "");
}
function extractEmail(value) {
	const matched = EMAIL_REGEXP.exec(value);
	if (!matched) return;
	return matched[0];
}
function extractDomain(value) {
	if (isEmail(value)) {
		const matched = EMAIL_REGEXP.exec(value);
		if (!matched) return;
		return matched.groups?.domain;
	}
	const domainMatch = value.match(DOMAIN_EXTRACT_REGEXP);
	if (domainMatch) return domainMatch[1];
}
function extractUrl(value) {
	const matched = URL_REGEXP.exec(value);
	if (!matched) return;
	return matched[0];
}
function extractUrlPath(value) {
	try {
		return new URL(value).pathname;
	} catch (error$1) {
		return;
	}
}
function parseJson(value) {
	try {
		return JSON.parse(value);
	} catch (error$1) {
		if (value.includes("'")) throw new ExpressionExtensionError("Parsing failed. Check you're using double quotes");
		throw new ExpressionExtensionError("Parsing failed");
	}
}
function toBoolean$1(value) {
	const normalized = value.toLowerCase();
	const FALSY = new Set([
		"false",
		"no",
		"0"
	]);
	return normalized.length > 0 && !FALSY.has(normalized);
}
function base64Encode(value) {
	return encode(value);
}
function base64Decode(value) {
	return decode(value);
}
removeMarkdown.doc = {
	name: "removeMarkdown",
	description: "Removes any Markdown formatting from the string. Also removes HTML tags.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeMarkdown",
	examples: [{
		example: "\"*bold*, [link]()\".removeMarkdown()",
		evaluated: "\"bold, link\""
	}]
};
removeTags.doc = {
	name: "removeTags",
	description: "Removes tags, such as HTML or XML, from the string.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeTags",
	examples: [{
		example: "\"<b>bold</b>, <a>link</a>\".removeTags()",
		evaluated: "\"bold, link\""
	}]
};
toDate.doc = {
	name: "toDate",
	description: "Converts a string to a date.",
	section: "cast",
	returnType: "Date",
	hidden: true,
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDate"
};
toDateTime.doc = {
	name: "toDateTime",
	description: "Converts the string to a <a target=\"_blank\" href=\"https://moment.github.io/luxon/api-docs/\">Luxon</a> DateTime. Useful for further transformation. Supported formats for the string are ISO 8601, HTTP, RFC2822, SQL and Unix timestamp in milliseconds. To parse other formats, use <a target=\"_blank\" href=”https://moment.github.io/luxon/api-docs/index.html#datetimefromformat”> <code>DateTime.fromFormat()</code></a>.",
	section: "cast",
	returnType: "DateTime",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDateTime",
	examples: [
		{ example: "\"2024-03-29T18:06:31.798+01:00\".toDateTime()" },
		{ example: "\"Fri, 29 Mar 2024 18:08:01 +0100\".toDateTime()" },
		{ example: "\"20240329\".toDateTime()" },
		{ example: "\"1711732132990\".toDateTime(\"ms\")" },
		{ example: "\"31-01-2024\".toDateTime(\"dd-MM-yyyy\")" }
	],
	args: [{
		name: "format",
		optional: true,
		description: "The format of the date string. Options are <code>ms</code> (for Unix timestamp in milliseconds), <code>s</code> (for Unix timestamp in seconds), <code>us</code> (for Unix timestamp in microseconds) or <code>excel</code> (for days since 1900). Custom formats can be specified using <a href=\"https://moment.github.io/luxon/#/formatting?id=table-of-tokens\">Luxon tokens</a>.",
		type: "string"
	}]
};
toBoolean$1.doc = {
	name: "toBoolean",
	description: "Converts the string to a boolean value. <code>0</code>, <code>false</code> and <code>no</code> resolve to <code>false</code>, everything else to <code>true</code>. Case-insensitive.",
	section: "cast",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toBoolean",
	examples: [
		{
			example: "\"true\".toBoolean()",
			evaluated: "true"
		},
		{
			example: "\"false\".toBoolean()",
			evaluated: "false"
		},
		{
			example: "\"0\".toBoolean()",
			evaluated: "false"
		},
		{
			example: "\"hello\".toBoolean()",
			evaluated: "true"
		}
	]
};
toFloat$1.doc = {
	name: "toFloat",
	description: "Converts a string to a decimal number.",
	section: "cast",
	returnType: "number",
	aliases: ["toDecimalNumber"],
	hidden: true,
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDecimalNumber"
};
toInt$1.doc = {
	name: "toInt",
	description: "Converts a string to an integer.",
	section: "cast",
	returnType: "number",
	args: [{
		name: "radix?",
		type: "number"
	}],
	aliases: ["toWholeNumber"],
	hidden: true,
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toInt"
};
toSentenceCase.doc = {
	name: "toSentenceCase",
	description: "Changes the capitalization of the string to sentence case. The first letter of each sentence is capitalized and all others are lowercased.",
	examples: [{
		example: "\"quick! brown FOX\".toSentenceCase()",
		evaluated: "\"Quick! Brown fox\""
	}],
	section: "case",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSentenceCase"
};
toSnakeCase.doc = {
	name: "toSnakeCase",
	description: "Changes the format of the string to snake case. Spaces and dashes are replaced by <code>_</code>, symbols are removed and all letters are lowercased.",
	examples: [{
		example: "\"quick brown $FOX\".toSnakeCase()",
		evaluated: "\"quick_brown_fox\""
	}],
	section: "case",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSnakeCase"
};
toTitleCase.doc = {
	name: "toTitleCase",
	description: "Changes the capitalization of the string to title case. The first letter of each word is capitalized and the others left unchanged. Short prepositions and conjunctions aren't capitalized (e.g. 'a', 'the').",
	examples: [{
		example: "\"quick a brown FOX\".toTitleCase()",
		evaluated: "\"Quick a Brown Fox\""
	}],
	section: "case",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toTitleCase"
};
urlEncode.doc = {
	name: "urlEncode",
	description: "Encodes the string so that it can be used in a URL. Spaces and special characters are replaced with codes of the form <code>%XX</code>.",
	section: "edit",
	args: [{
		name: "allChars",
		optional: true,
		description: "Whether to encode characters that are part of the URI syntax (e.g. <code>=</code>, <code>?</code>)",
		default: "false",
		type: "boolean"
	}],
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlEncode",
	examples: [{
		example: "\"name=Nathan Automat\".urlEncode()",
		evaluated: "\"name%3DNathan%20Automat\""
	}, {
		example: "\"name=Nathan Automat\".urlEncode(true)",
		evaluated: "\"name=Nathan%20Automat\""
	}]
};
urlDecode.doc = {
	name: "urlDecode",
	description: "Decodes a URL-encoded string. Replaces any character codes in the form of <code>%XX</code> with their corresponding characters.",
	args: [{
		name: "allChars",
		optional: true,
		description: "Whether to decode characters that are part of the URI syntax (e.g. <code>=</code>, <code>?</code>)",
		default: "false",
		type: "boolean"
	}],
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlDecode",
	examples: [{
		example: "\"name%3DNathan%20Automat\".urlDecode()",
		evaluated: "\"name=Nathan Automat\""
	}, {
		example: "\"name%3DNathan%20Automat\".urlDecode(true)",
		evaluated: "\"name%3DNathan Automat\""
	}]
};
replaceSpecialChars.doc = {
	name: "replaceSpecialChars",
	description: "Replaces special characters in the string with the closest ASCII character",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-replaceSpecialChars",
	examples: [{
		example: "\"déjà\".replaceSpecialChars()",
		evaluated: "\"deja\""
	}]
};
length.doc = {
	name: "length",
	section: "query",
	hidden: true,
	description: "Returns the character count of a string.",
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings"
};
isDomain.doc = {
	name: "isDomain",
	description: "Returns <code>true</code> if a string is a domain.",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isDomain",
	examples: [
		{
			example: "\"n8n.io\".isDomain()",
			evaluated: "true"
		},
		{
			example: "\"http://n8n.io\".isDomain()",
			evaluated: "false"
		},
		{
			example: "\"hello\".isDomain()",
			evaluated: "false"
		}
	]
};
isEmail.doc = {
	name: "isEmail",
	description: "Returns <code>true</code> if the string is an email.",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmail",
	examples: [
		{
			example: "\"me@example.com\".isEmail()",
			evaluated: "true"
		},
		{
			example: "\"It's me@example.com\".isEmail()",
			evaluated: "false"
		},
		{
			example: "\"hello\".isEmail()",
			evaluated: "false"
		}
	]
};
isNumeric.doc = {
	name: "isNumeric",
	description: "Returns <code>true</code> if the string represents a number.",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNumeric",
	examples: [
		{
			example: "\"1.2234\".isNumeric()",
			evaluated: "true"
		},
		{
			example: "\"hello\".isNumeric()",
			evaluated: "false"
		},
		{
			example: "\"123E23\".isNumeric()",
			evaluated: "true"
		}
	]
};
isUrl.doc = {
	name: "isUrl",
	description: "Returns <code>true</code> if a string is a valid URL",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isUrl",
	examples: [
		{
			example: "\"https://n8n.io\".isUrl()",
			evaluated: "true"
		},
		{
			example: "\"n8n.io\".isUrl()",
			evaluated: "false"
		},
		{
			example: "\"hello\".isUrl()",
			evaluated: "false"
		}
	]
};
isEmpty$2.doc = {
	name: "isEmpty",
	description: "Returns <code>true</code> if the string has no characters or is <code>null</code>",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmpty",
	examples: [{
		example: "\"\".isEmpty()",
		evaluated: "true"
	}, {
		example: "\"hello\".isEmpty()",
		evaluated: "false"
	}]
};
isNotEmpty$2.doc = {
	name: "isNotEmpty",
	description: "Returns <code>true</code> if the string has at least one character.",
	section: "validation",
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNotEmpty",
	examples: [{
		example: "\"hello\".isNotEmpty()",
		evaluated: "true"
	}, {
		example: "\"\".isNotEmpty()",
		evaluated: "false"
	}]
};
toJsonString.doc = {
	name: "toJsonString",
	description: "Prepares the string to be inserted into a JSON object. Escapes any quotes and special characters (e.g. new lines), and wraps the string in quotes.The same as JavaScript’s JSON.stringify().",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toJsonString",
	examples: [{
		example: "The \"best\" colours: red\nbrown.toJsonString()",
		evaluated: "\"The \\\"best\\\" colours: red\\nbrown\""
	}, {
		example: "foo.toJsonString()",
		evaluated: "\"foo\""
	}]
};
extractEmail.doc = {
	name: "extractEmail",
	description: "Extracts the first email found in the string. Returns <code>undefined</code> if none is found.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractEmail",
	examples: [{
		example: "\"My email is me@example.com\".extractEmail()",
		evaluated: "'me@example.com'"
	}]
};
extractDomain.doc = {
	name: "extractDomain",
	description: "If the string is an email address or URL, returns its domain (or <code>undefined</code> if nothing found). If the string also contains other content, try using <code>extractEmail()</code> or <code>extractUrl()</code> first.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractDomain",
	examples: [
		{
			example: "\"me@example.com\".extractDomain()",
			evaluated: "'example.com'"
		},
		{
			example: "\"http://n8n.io/workflows\".extractDomain()",
			evaluated: "'n8n.io'"
		},
		{
			example: "\"It's me@example.com\".extractEmail().extractDomain()",
			evaluated: "'example.com'"
		}
	]
};
extractUrl.doc = {
	name: "extractUrl",
	description: "Extracts the first URL found in the string. Returns <code>undefined</code> if none is found. Only recognizes full URLs, e.g. those starting with <code>http</code>.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractUrl",
	examples: [{
		example: "\"Check out http://n8n.io\".extractUrl()",
		evaluated: "'http://n8n.io'"
	}]
};
extractUrlPath.doc = {
	name: "extractUrlPath",
	description: "Returns the part of a URL after the domain, or <code>undefined</code> if no URL found. If the string also contains other content, try using <code>extractUrl()</code> first.",
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractUrlPath",
	examples: [{
		example: "\"http://n8n.io/workflows\".extractUrlPath()",
		evaluated: "'/workflows'"
	}, {
		example: "\"Check out http://n8n.io/workflows\".extractUrl().extractUrlPath()",
		evaluated: "'/workflows'"
	}]
};
hash.doc = {
	name: "hash",
	description: "Returns the string hashed with the given algorithm. Defaults to md5 if not specified.",
	section: "edit",
	returnType: "string",
	args: [{
		name: "algo",
		optional: true,
		description: "The hashing algorithm to use. One of <code>md5</code>, <code>base64</code>, <code>sha1</code>, <code>sha224</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code>, <code>sha3</code>, <code>ripemd160</code>\n        ",
		default: "\"md5\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-hash",
	examples: [{
		example: "\"hello\".hash()",
		evaluated: "'5d41402abc4b2a76b9719d911017c592'"
	}]
};
quote.doc = {
	name: "quote",
	description: "Wraps a string in quotation marks, and escapes any quotation marks already in the string. Useful when constructing JSON, SQL, etc.",
	section: "edit",
	returnType: "string",
	args: [{
		name: "mark",
		optional: true,
		description: "The type of quotation mark to use",
		default: "\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-quote",
	examples: [{
		example: "'Nathan says \"hi\"'.quote()",
		evaluated: "'\"Nathan says \\\"hi\\\"\"'"
	}]
};
parseJson.doc = {
	name: "parseJson",
	description: "Returns the JavaScript value or object represented by the string, or <code>undefined</code> if the string isn't valid JSON. Single-quoted JSON is not supported.",
	section: "cast",
	returnType: "any",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-parseJson",
	examples: [
		{
			example: "'{\"name\":\"Nathan\"}'.parseJson()",
			evaluated: "'{\"name\":\"Nathan\"}'"
		},
		{
			example: "\"{'name':'Nathan'}\".parseJson()",
			evaluated: "undefined"
		},
		{
			example: "'hello'.parseJson()",
			evaluated: "undefined"
		}
	]
};
base64Encode.doc = {
	name: "base64Encode",
	description: "Converts plain text to a base64-encoded string",
	examples: [{
		example: "\"hello\".base64Encode()",
		evaluated: "\"aGVsbG8=\""
	}],
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-base64Encode"
};
base64Decode.doc = {
	name: "base64Decode",
	description: "Converts a base64-encoded string to plain text",
	examples: [{
		example: "\"aGVsbG8=\".base64Decode()",
		evaluated: "\"hello\""
	}],
	section: "edit",
	returnType: "string",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-base64Decode"
};
toNumber.doc = {
	name: "toNumber",
	description: "Converts a string representing a number to a number. Errors if the string doesn't start with a valid number.",
	section: "cast",
	returnType: "number",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toNumber",
	examples: [{
		example: "\"123\".toNumber()",
		evaluated: "123"
	}, {
		example: "\"1.23E10\".toNumber()",
		evaluated: "12300000000"
	}]
};
const stringExtensions = {
	typeName: "String",
	functions: {
		hash,
		removeMarkdown,
		removeTags,
		toDate,
		toDateTime,
		toBoolean: toBoolean$1,
		toDecimalNumber: toFloat$1.bind({}),
		toNumber,
		toFloat: toFloat$1,
		toInt: toInt$1,
		toWholeNumber: toInt$1.bind({}),
		toSentenceCase,
		toSnakeCase,
		toTitleCase,
		urlDecode,
		urlEncode,
		quote,
		replaceSpecialChars,
		length,
		isDomain,
		isEmail,
		isNumeric,
		isUrl,
		isEmpty: isEmpty$2,
		isNotEmpty: isNotEmpty$2,
		toJsonString,
		extractEmail,
		extractDomain,
		extractUrl,
		extractUrlPath,
		parseJson,
		base64Encode,
		base64Decode
	}
};
const convertToDateTime = (value) => {
	let converted;
	if (typeof value === "string") {
		converted = DateTime.fromJSDate(new Date(value));
		if (converted.invalidReason !== null) return;
	} else if (value instanceof Date) converted = DateTime.fromJSDate(value);
	else if (DateTime.isDateTime(value)) converted = value;
	return converted;
};
function checkIfValueDefinedOrThrow(value, functionName) {
	if (value === void 0 || value === null) throw new ExpressionExtensionError(`${functionName} can't be used on ${String(value)} value`, { description: `To ignore this error, add a ? to the variable before this function, e.g. my_var?.${functionName}` });
}
var durationUnits = [
	"milliseconds",
	"seconds",
	"minutes",
	"hours",
	"days",
	"weeks",
	"months",
	"quarters",
	"years"
];
var dateParts = [
	"day",
	"week",
	"month",
	"year",
	"hour",
	"minute",
	"second",
	"millisecond",
	"weekNumber",
	"yearDayNumber",
	"weekday"
];
var DURATION_MAP = {
	day: "days",
	month: "months",
	year: "years",
	week: "weeks",
	hour: "hours",
	minute: "minutes",
	second: "seconds",
	millisecond: "milliseconds",
	ms: "milliseconds",
	sec: "seconds",
	secs: "seconds",
	hr: "hours",
	hrs: "hours",
	min: "minutes",
	mins: "minutes"
};
var DATETIMEUNIT_MAP = {
	days: "day",
	months: "month",
	years: "year",
	hours: "hour",
	minutes: "minute",
	seconds: "second",
	milliseconds: "millisecond",
	hrs: "hour",
	hr: "hour",
	mins: "minute",
	min: "minute",
	secs: "second",
	sec: "second",
	ms: "millisecond"
};
function isDateTime(date) {
	return date ? DateTime.isDateTime(date) : false;
}
function toDateTime$1(date) {
	if (isDateTime(date)) return date;
	if (typeof date === "string") return toDateTime(date);
	return DateTime.fromJSDate(date);
}
function generateDurationObject(durationValue, unit) {
	return { [`${DURATION_MAP[unit] || unit}`]: durationValue };
}
function beginningOf(date, extraArgs) {
	const [rawUnit = "week"] = extraArgs;
	const unit = DATETIMEUNIT_MAP[rawUnit] || rawUnit;
	if (isDateTime(date)) return date.startOf(unit);
	return DateTime.fromJSDate(date).startOf(unit).toJSDate();
}
function endOfMonth(date) {
	if (isDateTime(date)) return date.endOf("month");
	return DateTime.fromJSDate(date).endOf("month").toJSDate();
}
function extract(date, args) {
	let [part = "week"] = args;
	if (part === "yearDayNumber") {
		date = isDateTime(date) ? date.toJSDate() : date;
		const firstDayOfTheYear = new Date(date.getFullYear(), 0, 0);
		const diff = date.getTime() - firstDayOfTheYear.getTime() + (firstDayOfTheYear.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1e3;
		return Math.floor(diff / (1e3 * 60 * 60 * 24));
	}
	if (part === "week") part = "weekNumber";
	const unit = DATETIMEUNIT_MAP[part] || part;
	if (isDateTime(date)) return date.get(unit);
	return DateTime.fromJSDate(date).get(unit);
}
function format(date, extraArgs) {
	const [dateFormat, localeOpts = {}] = extraArgs;
	if (isDateTime(date)) return date.toFormat(dateFormat, { ...localeOpts });
	return DateTime.fromJSDate(date).toFormat(dateFormat, { ...localeOpts });
}
function isBetween(date, extraArgs) {
	if (extraArgs.length !== 2) throw new ExpressionExtensionError("isBetween(): expected exactly two args");
	const [first$1, second] = extraArgs;
	const firstDate = convertToDateTime(first$1);
	const secondDate = convertToDateTime(second);
	if (!firstDate || !secondDate) return;
	if (firstDate > secondDate) return secondDate < date && date < firstDate;
	return secondDate > date && date > firstDate;
}
function isDst(date) {
	if (isDateTime(date)) return date.isInDST;
	return DateTime.fromJSDate(date).isInDST;
}
function isInLast(date, extraArgs) {
	const [durationValue = 0, unit = "minutes"] = extraArgs;
	const dateInThePast = DateTime.now().minus(generateDurationObject(durationValue, unit));
	let thisDate = date;
	if (!isDateTime(thisDate)) thisDate = DateTime.fromJSDate(thisDate);
	return dateInThePast <= thisDate && thisDate <= DateTime.now();
}
var WEEKEND_DAYS = [6, 7];
function isWeekend(date) {
	const { weekday } = isDateTime(date) ? date : DateTime.fromJSDate(date);
	return WEEKEND_DAYS.includes(weekday);
}
function minus(date, args) {
	if (args.length === 1) {
		const [arg] = args;
		if (isDateTime(date)) return date.minus(arg);
		return DateTime.fromJSDate(date).minus(arg).toJSDate();
	}
	const [durationValue = 0, unit = "minutes"] = args;
	const duration = generateDurationObject(durationValue, unit);
	if (isDateTime(date)) return date.minus(duration);
	return DateTime.fromJSDate(date).minus(duration).toJSDate();
}
function plus(date, args) {
	if (args.length === 1) {
		const [arg] = args;
		if (isDateTime(date)) return date.plus(arg);
		return DateTime.fromJSDate(date).plus(arg).toJSDate();
	}
	const [durationValue = 0, unit = "minutes"] = args;
	const duration = generateDurationObject(durationValue, unit);
	if (isDateTime(date)) return date.plus(duration);
	return DateTime.fromJSDate(date).plus(duration).toJSDate();
}
function diffTo(date, args) {
	const [otherDate, unit = "days"] = args;
	let units = Array.isArray(unit) ? unit : [unit];
	if (units.length === 0) units = ["days"];
	const allowedUnitSet = new Set([...dateParts, ...durationUnits]);
	const errorUnit = units.find((u$1) => !allowedUnitSet.has(u$1));
	if (errorUnit) throw new ExpressionExtensionError(`Unsupported unit '${String(errorUnit)}'. Supported: ${durationUnits.map((u$1) => `'${u$1}'`).join(", ")}.`);
	const diffResult = date.diff(toDateTime$1(otherDate), units);
	if (units.length > 1) return diffResult.toObject();
	return diffResult.as(units[0]);
}
function diffToNow(date, args) {
	const [unit] = args;
	return diffTo(date, [DateTime.now(), unit]);
}
function toInt(date) {
	if (isDateTime(date)) return date.toMillis();
	return date.getTime();
}
var toFloat = toInt;
function toBoolean() {}
function isEmpty$1() {
	return false;
}
function isNotEmpty$1() {
	return true;
}
endOfMonth.doc = {
	name: "endOfMonth",
	returnType: "DateTime",
	hidden: true,
	description: "Transforms a date to the last possible moment that lies within the month.",
	section: "edit",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-endOfMonth"
};
isDst.doc = {
	name: "isDst",
	returnType: "boolean",
	hidden: true,
	description: "Checks if a Date is within Daylight Savings Time.",
	section: "query",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isDst"
};
isWeekend.doc = {
	name: "isWeekend",
	returnType: "boolean",
	hidden: true,
	description: "Checks if the Date falls on a Saturday or Sunday.",
	section: "query",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isWeekend"
};
beginningOf.doc = {
	name: "beginningOf",
	description: "Transform a Date to the start of the given time period. Default unit is `week`.",
	section: "edit",
	hidden: true,
	returnType: "DateTime",
	args: [{
		name: "unit?",
		type: "DurationUnit"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-beginningOf"
};
extract.doc = {
	name: "extract",
	description: "Extracts a part of the date or time, e.g. the month, as a number. To extract textual names instead, see <code>format()</code>.",
	examples: [{
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.extract('month')",
		evaluated: "3"
	}, {
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.extract('hour')",
		evaluated: "18"
	}],
	section: "query",
	returnType: "number",
	args: [{
		name: "unit",
		optional: true,
		description: "The part of the date or time to return. One of: <code>year</code>, <code>month</code>, <code>week</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>",
		default: "\"week\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-extract"
};
format.doc = {
	name: "format",
	description: "Converts the DateTime to a string, using the format specified. <a target=\"_blank\" href=\"https://moment.github.io/luxon/#/formatting?id=table-of-tokens\">Formatting guide</a>. For common formats, <code>toLocaleString()</code> may be easier.",
	examples: [
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format('dd/LL/yyyy')",
			evaluated: "'30/04/2024'"
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format('dd LLL yy')",
			evaluated: "'30 Apr 24'"
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.setLocale('fr').format('dd LLL yyyy')",
			evaluated: "'30 avr. 2024'"
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format(\"HH 'hours and' mm 'minutes'\")",
			evaluated: "'18 hours and 49 minutes'"
		}
	],
	returnType: "string",
	section: "format",
	args: [{
		name: "fmt",
		description: "The <a target=\"_blank\" href=\"https://moment.github.io/luxon/#/formatting?id=table-of-tokens\">format</a> of the string to return ",
		default: "'yyyy-MM-dd'",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-format"
};
isBetween.doc = {
	name: "isBetween",
	description: "Returns <code>true</code> if the DateTime lies between the two moments specified",
	examples: [{
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.isBetween('2020-06-01', '2025-06-01')",
		evaluated: "true"
	}, {
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.isBetween('2020', '2025')",
		evaluated: "true"
	}],
	section: "compare",
	returnType: "boolean",
	args: [{
		name: "date1",
		description: "The moment that the base DateTime must be after. Can be an ISO date string or a Luxon DateTime.",
		type: "string | DateTime"
	}, {
		name: "date2",
		description: "The moment that the base DateTime must be before. Can be an ISO date string or a Luxon DateTime.",
		type: "string | DateTime"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isBetween"
};
isInLast.doc = {
	name: "isInLast",
	hidden: true,
	description: "Checks if a Date is within a given time period. Default unit is `minute`.",
	section: "query",
	returnType: "boolean",
	args: [{
		name: "n",
		type: "number"
	}, {
		name: "unit?",
		type: "DurationUnit"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isInLast"
};
toDateTime$1.doc = {
	name: "toDateTime",
	description: "Converts a JavaScript Date to a Luxon DateTime. The DateTime contains the same information, but is easier to manipulate.",
	examples: [{
		example: "jsDate = new Date('2024-03-30T18:49')\njsDate.toDateTime().plus(5, 'days')",
		evaluated: "[DateTime: 2024-05-05T18:49:00.000Z]"
	}],
	returnType: "DateTime",
	hidden: true,
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-toDateTime"
};
minus.doc = {
	name: "minus",
	description: "Subtracts a given period of time from the DateTime",
	examples: [{
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.minus(7, 'days')",
		evaluated: "[DateTime: 2024-04-23T18:49:00.000Z]"
	}, {
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.minus(4, 'years')",
		evaluated: "[DateTime: 2020-04-30T18:49:00.000Z]"
	}],
	section: "edit",
	returnType: "DateTime",
	args: [{
		name: "n",
		description: "The number of units to subtract. Or use a Luxon <a target=\"_blank\" href=”https://moment.github.io/luxon/api-docs/index.html#duration”>Duration</a> object to subtract multiple units at once.",
		type: "number | object"
	}, {
		name: "unit",
		optional: true,
		description: "The units of the number. One of: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>",
		default: "\"milliseconds\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-minus"
};
plus.doc = {
	name: "plus",
	description: "Adds a given period of time to the DateTime",
	examples: [{
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.plus(7, 'days')",
		evaluated: "[DateTime: 2024-04-07T18:49:00.000Z]"
	}, {
		example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.plus(4, 'years')",
		evaluated: "[DateTime: 2028-03-30T18:49:00.000Z]"
	}],
	section: "edit",
	returnType: "DateTime",
	args: [{
		name: "n",
		description: "The number of units to add. Or use a Luxon <a target=\"_blank\" href=”https://moment.github.io/luxon/api-docs/index.html#duration”>Duration</a> object to add multiple units at once.",
		type: "number | object"
	}, {
		name: "unit",
		optional: true,
		description: "The units of the number. One of: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>",
		default: "\"milliseconds\"",
		type: "string"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-plus"
};
diffTo.doc = {
	name: "diffTo",
	description: "Returns the difference between two DateTimes, in the given unit(s)",
	examples: [{
		example: "dt = '2025-01-01'.toDateTime()\ndt.diffTo('2024-03-30T18:49:07.234', 'days')",
		evaluated: "276.21"
	}, {
		example: "dt1 = '2025-01-01T00:00:00.000'.toDateTime();\ndt2 = '2024-03-30T18:49:07.234'.toDateTime();\ndt1.diffTo(dt2, ['months', 'days'])",
		evaluated: "{ months: 9, days: 1.21 }"
	}],
	section: "compare",
	returnType: "number | Record<DurationUnit, number>",
	args: [{
		name: "otherDateTime",
		default: "$now",
		description: "The moment to subtract the base DateTime from. Can be an ISO date string or a Luxon DateTime.",
		type: "string | DateTime"
	}, {
		name: "unit",
		default: "'days'",
		description: "The unit, or array of units, to return the result in. Possible values: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>.",
		type: "string | string[]"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-diffTo"
};
diffToNow.doc = {
	name: "diffToNow",
	description: "Returns the difference between the current moment and the DateTime, in the given unit(s). For a textual representation, use <code>toRelative()</code> instead.",
	examples: [{
		example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.diffToNow('days')",
		evaluated: "371.9"
	}, {
		example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.diffToNow(['months', 'days'])",
		evaluated: "{ months: 12, days: 5.9 }"
	}],
	section: "compare",
	returnType: "number | Record<DurationUnit, number>",
	args: [{
		name: "unit",
		description: "The unit, or array of units, to return the result in. Possible values: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>.",
		default: "'days'",
		type: "string | string[]"
	}],
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-diffToNow"
};
isEmpty$1.doc = {
	name: "isEmpty",
	description: "Returns <code>false</code> for all DateTimes. Returns <code>true</code> for <code>null</code>.",
	examples: [{
		example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.isEmpty()",
		evaluated: "false"
	}, {
		example: "dt = null\ndt.isEmpty()",
		evaluated: "true"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isEmpty"
};
isNotEmpty$1.doc = {
	name: "isNotEmpty",
	description: "Returns <code>true</code> for all DateTimes. Returns <code>false</code> for <code>null</code>.",
	examples: [{
		example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.isNotEmpty()",
		evaluated: "true"
	}, {
		example: "dt = null\ndt.isNotEmpty()",
		evaluated: "false"
	}],
	returnType: "boolean",
	docURL: "https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isNotEmpty"
};
const dateExtensions = {
	typeName: "Date",
	functions: {
		beginningOf,
		endOfMonth,
		extract,
		isBetween,
		isDst,
		isInLast,
		isWeekend,
		minus,
		plus,
		format,
		toDateTime: toDateTime$1,
		diffTo,
		diffToNow,
		toInt,
		toFloat,
		toBoolean,
		isEmpty: isEmpty$1,
		isNotEmpty: isNotEmpty$1
	}
};
var OPEN_BRACKET = /(?<escape>\\|)(?<brackets>\{\{)/;
var CLOSE_BRACKET = /(?<escape>\\|)(?<brackets>\}\})/;
const escapeCode = (text) => {
	return text.replace("\\}}", "}}");
};
const splitExpression = (expression) => {
	const chunks = [];
	let searchingFor = "open";
	let activeRegex = OPEN_BRACKET;
	let buffer$1 = "";
	let index = 0;
	while (index < expression.length) {
		const expr = expression.slice(index);
		const res = activeRegex.exec(expr);
		if (!res?.groups) {
			buffer$1 += expr;
			if (searchingFor === "open") chunks.push({
				type: "text",
				text: buffer$1
			});
			else chunks.push({
				type: "code",
				text: escapeCode(buffer$1),
				hasClosingBrackets: false
			});
			break;
		}
		if (res.groups.escape) {
			buffer$1 += expr.slice(0, res.index + 3);
			index += res.index + 3;
		} else {
			buffer$1 += expr.slice(0, res.index);
			if (searchingFor === "open") {
				chunks.push({
					type: "text",
					text: buffer$1
				});
				searchingFor = "close";
				activeRegex = CLOSE_BRACKET;
			} else {
				chunks.push({
					type: "code",
					text: escapeCode(buffer$1),
					hasClosingBrackets: true
				});
				searchingFor = "open";
				activeRegex = OPEN_BRACKET;
			}
			index += res.index + 2;
			buffer$1 = "";
		}
	}
	return chunks;
};
var escapeTmplExpression = (part) => {
	return part.replace("}}", "\\}}");
};
const joinExpression = (parts) => {
	return parts.map((chunk$1) => {
		if (chunk$1.type === "code") return `{{${escapeTmplExpression(chunk$1.text)}${chunk$1.hasClosingBrackets ? "}}" : ""}`;
		return chunk$1.text;
	}).join("");
};
var import_main = /* @__PURE__ */ __toESM(require_main$1());
var import_util = /* @__PURE__ */ __toESM(require_util());
var EXPRESSION_EXTENDER = "extend";
var EXPRESSION_EXTENDER_OPTIONAL = "extendOptional";
function isEmpty(value) {
	return value === null || value === void 0 || !value;
}
function isNotEmpty(value) {
	return !isEmpty(value);
}
const EXTENSION_OBJECTS = [
	arrayExtensions,
	dateExtensions,
	numberExtensions,
	objectExtensions,
	stringExtensions,
	booleanExtensions
];
var genericExtensions = {
	isEmpty,
	isNotEmpty
};
var EXPRESSION_EXTENSION_METHODS = Array.from(new Set([
	...Object.keys(stringExtensions.functions),
	...Object.keys(numberExtensions.functions),
	...Object.keys(dateExtensions.functions),
	...Object.keys(arrayExtensions.functions),
	...Object.keys(objectExtensions.functions),
	...Object.keys(booleanExtensions.functions),
	...Object.keys(genericExtensions)
]));
var EXPRESSION_EXTENSION_REGEX = /* @__PURE__ */ new RegExp(`(\\$if|\\.(${EXPRESSION_EXTENSION_METHODS.join("|")})\\s*(\\?\\.)?)\\s*\\(`);
var isExpressionExtension = (str) => EXPRESSION_EXTENSION_METHODS.some((m$1) => m$1 === str);
const hasExpressionExtension = (str) => EXPRESSION_EXTENSION_REGEX.test(str);
const hasNativeMethod = (method$1) => {
	if (hasExpressionExtension(method$1)) return false;
	return method$1.replace(/[^\w\s]/gi, " ").split(" ").filter(Boolean).every((methodName) => {
		return [
			String.prototype,
			Array.prototype,
			Number.prototype,
			Date.prototype
		].some((nativeType) => {
			if (methodName in nativeType) return true;
			return false;
		});
	});
};
function parseWithEsprimaNext(source, options) {
	return parse(source, {
		loc: true,
		locations: true,
		comment: true,
		range: (0, import_util.getOption)(options, "range", false),
		tolerant: (0, import_util.getOption)(options, "tolerant", true),
		tokens: true,
		jsx: (0, import_util.getOption)(options, "jsx", false),
		sourceType: (0, import_util.getOption)(options, "sourceType", "module")
	});
}
const extendTransform = (expression) => {
	try {
		const ast = (0, import_main.parse)(expression, { parser: { parse: parseWithEsprimaNext } });
		let currentChain = 1;
		(0, import_main.visit)(ast, { visitChainExpression(path) {
			this.traverse(path);
			const chainNumber = currentChain;
			currentChain += 1;
			const globalIdentifier$1 = import_main.types.builders.identifier(typeof window !== "object" ? "global" : "window");
			const undefinedIdentifier = import_main.types.builders.identifier("undefined");
			const cancelIdentifier = import_main.types.builders.identifier(`chainCancelToken${chainNumber}`);
			const valueIdentifier = import_main.types.builders.identifier(`chainValue${chainNumber}`);
			const cancelMemberExpression = import_main.types.builders.memberExpression(globalIdentifier$1, cancelIdentifier);
			const valueMemberExpression = import_main.types.builders.memberExpression(globalIdentifier$1, valueIdentifier);
			const patchedStack = [];
			const buildCancelCheckWrapper = (node) => {
				return import_main.types.builders.conditionalExpression(import_main.types.builders.binaryExpression("===", cancelMemberExpression, import_main.types.builders.booleanLiteral(true)), undefinedIdentifier, node);
			};
			const buildValueAssignWrapper = (node) => {
				return import_main.types.builders.assignmentExpression("=", valueMemberExpression, node);
			};
			const buildOptionalWrapper = (node) => {
				return import_main.types.builders.binaryExpression("===", import_main.types.builders.logicalExpression("??", buildValueAssignWrapper(node), undefinedIdentifier), undefinedIdentifier);
			};
			const buildCancelAssignWrapper = (node) => {
				return import_main.types.builders.assignmentExpression("=", cancelMemberExpression, node);
			};
			let currentNode = path.node.expression;
			let currentPatch = null;
			let patchTop = null;
			let wrapNextTopInOptionalExtend = false;
			const updatePatch = (toPatch, node) => {
				if (toPatch.type === "MemberExpression" || toPatch.type === "OptionalMemberExpression") toPatch.object = node;
				else if (toPatch.type === "CallExpression" || toPatch.type === "OptionalCallExpression") toPatch.callee = node;
			};
			while (true) if (currentNode.type === "MemberExpression" || currentNode.type === "OptionalMemberExpression" || currentNode.type === "CallExpression" || currentNode.type === "OptionalCallExpression") {
				let patchNode;
				if (currentNode.type === "MemberExpression" || currentNode.type === "OptionalMemberExpression") patchNode = import_main.types.builders.memberExpression(valueMemberExpression, currentNode.property);
				else patchNode = import_main.types.builders.callExpression(valueMemberExpression, currentNode.arguments);
				if (currentPatch) updatePatch(currentPatch, patchNode);
				if (!patchTop) patchTop = patchNode;
				currentPatch = patchNode;
				if (currentNode.optional) {
					if (wrapNextTopInOptionalExtend) {
						wrapNextTopInOptionalExtend = false;
						if (patchTop.type === "MemberExpression" && patchTop.property.type === "Identifier") patchTop = import_main.types.builders.callExpression(import_main.types.builders.identifier(EXPRESSION_EXTENDER_OPTIONAL), [patchTop.object, import_main.types.builders.stringLiteral(patchTop.property.name)]);
					}
					patchedStack.push(patchTop);
					patchTop = null;
					currentPatch = null;
					if ((currentNode.type === "CallExpression" || currentNode.type === "OptionalCallExpression") && (currentNode.callee.type === "MemberExpression" || currentNode.callee.type === "OptionalMemberExpression") && currentNode.callee.property.type === "Identifier" && isExpressionExtension(currentNode.callee.property.name)) wrapNextTopInOptionalExtend = true;
				}
				if (currentNode.type === "MemberExpression" || currentNode.type === "OptionalMemberExpression") currentNode = currentNode.object;
				else currentNode = currentNode.callee;
			} else {
				if (currentPatch) {
					updatePatch(currentPatch, currentNode);
					if (!patchTop) patchTop = currentPatch;
				}
				if (wrapNextTopInOptionalExtend) {
					wrapNextTopInOptionalExtend = false;
					if (patchTop?.type === "MemberExpression" && patchTop.property.type === "Identifier") patchTop = import_main.types.builders.callExpression(import_main.types.builders.identifier(EXPRESSION_EXTENDER_OPTIONAL), [patchTop.object, import_main.types.builders.stringLiteral(patchTop.property.name)]);
				}
				if (patchTop) patchedStack.push(patchTop);
				else patchedStack.push(currentNode);
				break;
			}
			patchedStack.reverse();
			for (let i$2 = 0; i$2 < patchedStack.length; i$2++) {
				let node = patchedStack[i$2];
				if (i$2 !== patchedStack.length - 1) node = buildCancelAssignWrapper(buildOptionalWrapper(node));
				if (i$2 !== 0) node = buildCancelCheckWrapper(node);
				patchedStack[i$2] = node;
			}
			const sequenceNode = import_main.types.builders.sequenceExpression(patchedStack);
			path.replace(sequenceNode);
		} });
		(0, import_main.visit)(ast, { visitCallExpression(path) {
			this.traverse(path);
			if (path.node.callee.type === "MemberExpression" && path.node.callee.property.type === "Identifier" && isExpressionExtension(path.node.callee.property.name)) path.replace(import_main.types.builders.callExpression(import_main.types.builders.identifier(EXPRESSION_EXTENDER), [
				path.node.callee.object,
				import_main.types.builders.stringLiteral(path.node.callee.property.name),
				import_main.types.builders.arrayExpression(path.node.arguments)
			]));
			else if (path.node.callee.type === "Identifier" && path.node.callee.name === "$if" && path.node.arguments.every((v$3) => v$3.type !== "SpreadElement")) {
				if (path.node.arguments.length < 2) throw new ExpressionExtensionError("$if requires at least 2 parameters: test, value_if_true[, and value_if_false]");
				const test = path.node.arguments[0];
				const consequent = path.node.arguments[1];
				const alternative = path.node.arguments[2] === void 0 ? import_main.types.builders.booleanLiteral(false) : path.node.arguments[2];
				path.replace(import_main.types.builders.conditionalExpression(test, consequent, alternative));
			}
		} });
		return (0, import_main.print)(ast);
	} catch (e$1) {
		return;
	}
};
function isDate(input) {
	if (typeof input !== "string" || !input.length) return false;
	if (!/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(input)) return false;
	const d$1 = new Date(input);
	return d$1 instanceof Date && !isNaN(d$1.valueOf()) && d$1.toISOString() === input;
}
function findExtendedFunction(input, functionName) {
	let foundFunction;
	if (Array.isArray(input)) foundFunction = arrayExtensions.functions[functionName];
	else if (isDate(input) && functionName !== "toDate" && functionName !== "toDateTime") {
		input = new Date(input);
		foundFunction = dateExtensions.functions[functionName];
	} else if (typeof input === "string") foundFunction = stringExtensions.functions[functionName];
	else if (typeof input === "number") foundFunction = numberExtensions.functions[functionName];
	else if (input && (DateTime.isDateTime(input) || input instanceof Date)) foundFunction = dateExtensions.functions[functionName];
	else if (input !== null && typeof input === "object") foundFunction = objectExtensions.functions[functionName];
	else if (typeof input === "boolean") foundFunction = booleanExtensions.functions[functionName];
	if (!foundFunction) {
		const inputAny = input;
		if (inputAny && functionName && typeof inputAny[functionName] === "function") return {
			type: "native",
			function: inputAny[functionName]
		};
		foundFunction = genericExtensions[functionName];
	}
	if (!foundFunction) return;
	return {
		type: "extended",
		function: foundFunction
	};
}
function extend(input, functionName, args) {
	const foundFunction = findExtendedFunction(input, functionName);
	if (!foundFunction) {
		checkIfValueDefinedOrThrow(input, functionName);
		const haveFunction = EXTENSION_OBJECTS.filter((v$3) => functionName in v$3.functions);
		if (!haveFunction.length) throw new ExpressionExtensionError(`Unknown expression function: ${functionName}`);
		if (haveFunction.length > 1) {
			const lastType = `"${haveFunction.pop().typeName}"`;
			throw new ExpressionExtensionError(`${functionName}() is only callable on types ${`${haveFunction.map((v$3) => `"${v$3.typeName}"`).join(", ")}, and ${lastType}`}`);
		} else throw new ExpressionExtensionError(`${functionName}() is only callable on type "${haveFunction[0].typeName}"`);
	}
	if (foundFunction.type === "native") return foundFunction.function.apply(input, args);
	return foundFunction.function(input, args);
}
function extendOptional(input, functionName) {
	const foundFunction = findExtendedFunction(input, functionName);
	if (!foundFunction) return;
	if (foundFunction.type === "native") return foundFunction.function.bind(input);
	return (...args) => {
		return foundFunction.function(input, args);
	};
}
var EXTENDED_SYNTAX_CACHE = {};
function extendSyntax(bracketedExpression, forceExtend = false) {
	const chunks = splitExpression(bracketedExpression);
	if ((!chunks.filter((c$1) => c$1.type === "code").map((c$1) => c$1.text.replace(/("|').*?("|')/, "").trim()).some(hasExpressionExtension) || hasNativeMethod(bracketedExpression)) && !forceExtend) return bracketedExpression;
	if (bracketedExpression in EXTENDED_SYNTAX_CACHE) return EXTENDED_SYNTAX_CACHE[bracketedExpression];
	const expression = joinExpression(chunks.map((chunk$1) => {
		if (chunk$1.type === "code") {
			let output = extendTransform(chunk$1.text);
			if (!output?.code && chunk$1.text.trim()[0] === "{") output = extendTransform(`(${chunk$1.text})`);
			if (!output?.code) throw new ExpressionExtensionError("invalid syntax");
			let text = output.code;
			if (text.trim().endsWith(";")) text = text.trim().slice(0, -1);
			return {
				...chunk$1,
				text
			};
		}
		return chunk$1;
	}));
	EXTENDED_SYNTAX_CACHE[bracketedExpression] = expression;
	return expression;
}
var min = Math.min;
var max = Math.max;
var numberList = (start, end) => {
	const size = Math.abs(start - end) + 1;
	const arr = new Array(size);
	let curr = start;
	for (let i$2 = 0; i$2 < size; i$2++) if (start < end) arr[i$2] = curr++;
	else arr[i$2] = curr--;
	return arr;
};
var zip = (keys$9, values$1) => {
	if (keys$9.length !== values$1.length) throw new ExpressionExtensionError("keys and values not of equal length");
	return keys$9.reduce((p$1, c$1, i$2) => {
		p$1[c$1] = values$1[i$2];
		return p$1;
	}, {});
};
var average$1 = (...args) => {
	return average(args);
};
var not = (value) => {
	return !value;
};
function ifEmpty(value, defaultValue) {
	if (arguments.length !== 2) throw new ExpressionError("expected two arguments (value, defaultValue) for this function");
	if (value === void 0 || value === null || value === "") return defaultValue;
	if (typeof value === "object") {
		if (Array.isArray(value) && !value.length) return defaultValue;
		if (!Object.keys(value).length) return defaultValue;
	}
	return value;
}
ifEmpty.doc = {
	name: "ifEmpty",
	description: "Returns the default value if the value is empty. Empty values are undefined, null, empty strings, arrays without elements and objects without keys.",
	returnType: "any",
	args: [{
		name: "value",
		type: "any"
	}, {
		name: "defaultValue",
		type: "any"
	}],
	docURL: "https://docs.n8n.io/code/builtin/convenience"
};
const extendedFunctions = {
	min,
	max,
	not,
	average: average$1,
	numberList,
	zip,
	$min: min,
	$max: max,
	$average: average$1,
	$not: not,
	$ifEmpty: ifEmpty
};
var require_jmespath = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function(exports$1) {
		function isArray$11(obj) {
			if (obj !== null) return Object.prototype.toString.call(obj) === "[object Array]";
			else return false;
		}
		function isObject$8(obj) {
			if (obj !== null) return Object.prototype.toString.call(obj) === "[object Object]";
			else return false;
		}
		function strictDeepEqual(first$1, second) {
			if (first$1 === second) return true;
			if (Object.prototype.toString.call(first$1) !== Object.prototype.toString.call(second)) return false;
			if (isArray$11(first$1) === true) {
				if (first$1.length !== second.length) return false;
				for (var i$2 = 0; i$2 < first$1.length; i$2++) if (strictDeepEqual(first$1[i$2], second[i$2]) === false) return false;
				return true;
			}
			if (isObject$8(first$1) === true) {
				var keysSeen = {};
				for (var key in first$1) if (hasOwnProperty.call(first$1, key)) {
					if (strictDeepEqual(first$1[key], second[key]) === false) return false;
					keysSeen[key] = true;
				}
				for (var key2 in second) if (hasOwnProperty.call(second, key2)) {
					if (keysSeen[key2] !== true) return false;
				}
				return true;
			}
			return false;
		}
		function isFalse(obj) {
			if (obj === "" || obj === false || obj === null) return true;
			else if (isArray$11(obj) && obj.length === 0) return true;
			else if (isObject$8(obj)) {
				for (var key in obj) if (obj.hasOwnProperty(key)) return false;
				return true;
			} else return false;
		}
		function objValues(obj) {
			var keys$9 = Object.keys(obj);
			var values$1 = [];
			for (var i$2 = 0; i$2 < keys$9.length; i$2++) values$1.push(obj[keys$9[i$2]]);
			return values$1;
		}
		var trimLeft;
		if (typeof String.prototype.trimLeft === "function") trimLeft = function(str) {
			return str.trimLeft();
		};
		else trimLeft = function(str) {
			return str.match(/^\s*(.*)/)[1];
		};
		var TYPE_NUMBER = 0;
		var TYPE_ANY = 1;
		var TYPE_STRING = 2;
		var TYPE_ARRAY = 3;
		var TYPE_OBJECT = 4;
		var TYPE_BOOLEAN = 5;
		var TYPE_EXPREF = 6;
		var TYPE_NULL = 7;
		var TYPE_ARRAY_NUMBER = 8;
		var TYPE_ARRAY_STRING = 9;
		var TYPE_NAME_TABLE = {
			0: "number",
			1: "any",
			2: "string",
			3: "array",
			4: "object",
			5: "boolean",
			6: "expression",
			7: "null",
			8: "Array<number>",
			9: "Array<string>"
		};
		var TOK_EOF = "EOF";
		var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
		var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
		var TOK_RBRACKET = "Rbracket";
		var TOK_RPAREN = "Rparen";
		var TOK_COMMA = "Comma";
		var TOK_COLON = "Colon";
		var TOK_RBRACE = "Rbrace";
		var TOK_NUMBER = "Number";
		var TOK_CURRENT = "Current";
		var TOK_EXPREF = "Expref";
		var TOK_PIPE = "Pipe";
		var TOK_OR = "Or";
		var TOK_AND = "And";
		var TOK_EQ = "EQ";
		var TOK_GT = "GT";
		var TOK_LT = "LT";
		var TOK_GTE = "GTE";
		var TOK_LTE = "LTE";
		var TOK_NE = "NE";
		var TOK_FLATTEN = "Flatten";
		var TOK_STAR = "Star";
		var TOK_FILTER = "Filter";
		var TOK_DOT = "Dot";
		var TOK_NOT = "Not";
		var TOK_LBRACE = "Lbrace";
		var TOK_LBRACKET = "Lbracket";
		var TOK_LPAREN = "Lparen";
		var TOK_LITERAL = "Literal";
		var basicTokens = {
			".": TOK_DOT,
			"*": TOK_STAR,
			",": TOK_COMMA,
			":": TOK_COLON,
			"{": TOK_LBRACE,
			"}": TOK_RBRACE,
			"]": TOK_RBRACKET,
			"(": TOK_LPAREN,
			")": TOK_RPAREN,
			"@": TOK_CURRENT
		};
		var operatorStartToken = {
			"<": true,
			">": true,
			"=": true,
			"!": true
		};
		var skipChars$1 = {
			" ": true,
			"	": true,
			"\n": true
		};
		function isAlpha(ch) {
			return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
		}
		function isNum(ch) {
			return ch >= "0" && ch <= "9" || ch === "-";
		}
		function isAlphaNum(ch) {
			return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
		}
		function Lexer() {}
		Lexer.prototype = {
			tokenize: function(stream) {
				var tokens = [];
				this._current = 0;
				var start;
				var identifier;
				var token;
				while (this._current < stream.length) if (isAlpha(stream[this._current])) {
					start = this._current;
					identifier = this._consumeUnquotedIdentifier(stream);
					tokens.push({
						type: TOK_UNQUOTEDIDENTIFIER,
						value: identifier,
						start
					});
				} else if (basicTokens[stream[this._current]] !== void 0) {
					tokens.push({
						type: basicTokens[stream[this._current]],
						value: stream[this._current],
						start: this._current
					});
					this._current++;
				} else if (isNum(stream[this._current])) {
					token = this._consumeNumber(stream);
					tokens.push(token);
				} else if (stream[this._current] === "[") {
					token = this._consumeLBracket(stream);
					tokens.push(token);
				} else if (stream[this._current] === "\"") {
					start = this._current;
					identifier = this._consumeQuotedIdentifier(stream);
					tokens.push({
						type: TOK_QUOTEDIDENTIFIER,
						value: identifier,
						start
					});
				} else if (stream[this._current] === "'") {
					start = this._current;
					identifier = this._consumeRawStringLiteral(stream);
					tokens.push({
						type: TOK_LITERAL,
						value: identifier,
						start
					});
				} else if (stream[this._current] === "`") {
					start = this._current;
					var literal = this._consumeLiteral(stream);
					tokens.push({
						type: TOK_LITERAL,
						value: literal,
						start
					});
				} else if (operatorStartToken[stream[this._current]] !== void 0) tokens.push(this._consumeOperator(stream));
				else if (skipChars$1[stream[this._current]] !== void 0) this._current++;
				else if (stream[this._current] === "&") {
					start = this._current;
					this._current++;
					if (stream[this._current] === "&") {
						this._current++;
						tokens.push({
							type: TOK_AND,
							value: "&&",
							start
						});
					} else tokens.push({
						type: TOK_EXPREF,
						value: "&",
						start
					});
				} else if (stream[this._current] === "|") {
					start = this._current;
					this._current++;
					if (stream[this._current] === "|") {
						this._current++;
						tokens.push({
							type: TOK_OR,
							value: "||",
							start
						});
					} else tokens.push({
						type: TOK_PIPE,
						value: "|",
						start
					});
				} else {
					var error$1 = /* @__PURE__ */ new Error("Unknown character:" + stream[this._current]);
					error$1.name = "LexerError";
					throw error$1;
				}
				return tokens;
			},
			_consumeUnquotedIdentifier: function(stream) {
				var start = this._current;
				this._current++;
				while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current++;
				return stream.slice(start, this._current);
			},
			_consumeQuotedIdentifier: function(stream) {
				var start = this._current;
				this._current++;
				var maxLength$1 = stream.length;
				while (stream[this._current] !== "\"" && this._current < maxLength$1) {
					var current = this._current;
					if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "\"")) current += 2;
					else current++;
					this._current = current;
				}
				this._current++;
				return JSON.parse(stream.slice(start, this._current));
			},
			_consumeRawStringLiteral: function(stream) {
				var start = this._current;
				this._current++;
				var maxLength$1 = stream.length;
				while (stream[this._current] !== "'" && this._current < maxLength$1) {
					var current = this._current;
					if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) current += 2;
					else current++;
					this._current = current;
				}
				this._current++;
				return stream.slice(start + 1, this._current - 1).replace("\\'", "'");
			},
			_consumeNumber: function(stream) {
				var start = this._current;
				this._current++;
				var maxLength$1 = stream.length;
				while (isNum(stream[this._current]) && this._current < maxLength$1) this._current++;
				return {
					type: TOK_NUMBER,
					value: parseInt(stream.slice(start, this._current)),
					start
				};
			},
			_consumeLBracket: function(stream) {
				var start = this._current;
				this._current++;
				if (stream[this._current] === "?") {
					this._current++;
					return {
						type: TOK_FILTER,
						value: "[?",
						start
					};
				} else if (stream[this._current] === "]") {
					this._current++;
					return {
						type: TOK_FLATTEN,
						value: "[]",
						start
					};
				} else return {
					type: TOK_LBRACKET,
					value: "[",
					start
				};
			},
			_consumeOperator: function(stream) {
				var start = this._current;
				var startingChar = stream[start];
				this._current++;
				if (startingChar === "!") if (stream[this._current] === "=") {
					this._current++;
					return {
						type: TOK_NE,
						value: "!=",
						start
					};
				} else return {
					type: TOK_NOT,
					value: "!",
					start
				};
				else if (startingChar === "<") if (stream[this._current] === "=") {
					this._current++;
					return {
						type: TOK_LTE,
						value: "<=",
						start
					};
				} else return {
					type: TOK_LT,
					value: "<",
					start
				};
				else if (startingChar === ">") if (stream[this._current] === "=") {
					this._current++;
					return {
						type: TOK_GTE,
						value: ">=",
						start
					};
				} else return {
					type: TOK_GT,
					value: ">",
					start
				};
				else if (startingChar === "=") {
					if (stream[this._current] === "=") {
						this._current++;
						return {
							type: TOK_EQ,
							value: "==",
							start
						};
					}
				}
			},
			_consumeLiteral: function(stream) {
				this._current++;
				var start = this._current;
				var maxLength$1 = stream.length;
				var literal;
				while (stream[this._current] !== "`" && this._current < maxLength$1) {
					var current = this._current;
					if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) current += 2;
					else current++;
					this._current = current;
				}
				var literalString = trimLeft(stream.slice(start, this._current));
				literalString = literalString.replace("\\`", "`");
				if (this._looksLikeJSON(literalString)) literal = JSON.parse(literalString);
				else literal = JSON.parse("\"" + literalString + "\"");
				this._current++;
				return literal;
			},
			_looksLikeJSON: function(literalString) {
				var startingChars = "[{\"";
				var jsonLiterals = [
					"true",
					"false",
					"null"
				];
				var numberLooking = "-0123456789";
				if (literalString === "") return false;
				else if (startingChars.indexOf(literalString[0]) >= 0) return true;
				else if (jsonLiterals.indexOf(literalString) >= 0) return true;
				else if (numberLooking.indexOf(literalString[0]) >= 0) try {
					JSON.parse(literalString);
					return true;
				} catch (ex) {
					return false;
				}
				else return false;
			}
		};
		var bindingPower = {};
		bindingPower[TOK_EOF] = 0;
		bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
		bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
		bindingPower[TOK_RBRACKET] = 0;
		bindingPower[TOK_RPAREN] = 0;
		bindingPower[TOK_COMMA] = 0;
		bindingPower[TOK_RBRACE] = 0;
		bindingPower[TOK_NUMBER] = 0;
		bindingPower[TOK_CURRENT] = 0;
		bindingPower[TOK_EXPREF] = 0;
		bindingPower[TOK_PIPE] = 1;
		bindingPower[TOK_OR] = 2;
		bindingPower[TOK_AND] = 3;
		bindingPower[TOK_EQ] = 5;
		bindingPower[TOK_GT] = 5;
		bindingPower[TOK_LT] = 5;
		bindingPower[TOK_GTE] = 5;
		bindingPower[TOK_LTE] = 5;
		bindingPower[TOK_NE] = 5;
		bindingPower[TOK_FLATTEN] = 9;
		bindingPower[TOK_STAR] = 20;
		bindingPower[TOK_FILTER] = 21;
		bindingPower[TOK_DOT] = 40;
		bindingPower[TOK_NOT] = 45;
		bindingPower[TOK_LBRACE] = 50;
		bindingPower[TOK_LBRACKET] = 55;
		bindingPower[TOK_LPAREN] = 60;
		function Parser$1() {}
		Parser$1.prototype = {
			parse: function(expression) {
				this._loadTokens(expression);
				this.index = 0;
				var ast = this.expression(0);
				if (this._lookahead(0) !== TOK_EOF) {
					var t$1 = this._lookaheadToken(0);
					var error$1 = /* @__PURE__ */ new Error("Unexpected token type: " + t$1.type + ", value: " + t$1.value);
					error$1.name = "ParserError";
					throw error$1;
				}
				return ast;
			},
			_loadTokens: function(expression) {
				var tokens = new Lexer().tokenize(expression);
				tokens.push({
					type: TOK_EOF,
					value: "",
					start: expression.length
				});
				this.tokens = tokens;
			},
			expression: function(rbp) {
				var leftToken = this._lookaheadToken(0);
				this._advance();
				var left = this.nud(leftToken);
				var currentToken = this._lookahead(0);
				while (rbp < bindingPower[currentToken]) {
					this._advance();
					left = this.led(currentToken, left);
					currentToken = this._lookahead(0);
				}
				return left;
			},
			_lookahead: function(number) {
				return this.tokens[this.index + number].type;
			},
			_lookaheadToken: function(number) {
				return this.tokens[this.index + number];
			},
			_advance: function() {
				this.index++;
			},
			nud: function(token) {
				var left;
				var right;
				var expression;
				switch (token.type) {
					case TOK_LITERAL: return {
						type: "Literal",
						value: token.value
					};
					case TOK_UNQUOTEDIDENTIFIER: return {
						type: "Field",
						name: token.value
					};
					case TOK_QUOTEDIDENTIFIER:
						var node = {
							type: "Field",
							name: token.value
						};
						if (this._lookahead(0) === TOK_LPAREN) throw new Error("Quoted identifier not allowed for function names.");
						return node;
					case TOK_NOT:
						right = this.expression(bindingPower.Not);
						return {
							type: "NotExpression",
							children: [right]
						};
					case TOK_STAR:
						left = { type: "Identity" };
						right = null;
						if (this._lookahead(0) === TOK_RBRACKET) right = { type: "Identity" };
						else right = this._parseProjectionRHS(bindingPower.Star);
						return {
							type: "ValueProjection",
							children: [left, right]
						};
					case TOK_FILTER: return this.led(token.type, { type: "Identity" });
					case TOK_LBRACE: return this._parseMultiselectHash();
					case TOK_FLATTEN:
						left = {
							type: TOK_FLATTEN,
							children: [{ type: "Identity" }]
						};
						right = this._parseProjectionRHS(bindingPower.Flatten);
						return {
							type: "Projection",
							children: [left, right]
						};
					case TOK_LBRACKET:
						if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
							right = this._parseIndexExpression();
							return this._projectIfSlice({ type: "Identity" }, right);
						} else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
							this._advance();
							this._advance();
							right = this._parseProjectionRHS(bindingPower.Star);
							return {
								type: "Projection",
								children: [{ type: "Identity" }, right]
							};
						}
						return this._parseMultiselectList();
					case TOK_CURRENT: return { type: TOK_CURRENT };
					case TOK_EXPREF:
						expression = this.expression(bindingPower.Expref);
						return {
							type: "ExpressionReference",
							children: [expression]
						};
					case TOK_LPAREN:
						var args = [];
						while (this._lookahead(0) !== TOK_RPAREN) {
							if (this._lookahead(0) === TOK_CURRENT) {
								expression = { type: TOK_CURRENT };
								this._advance();
							} else expression = this.expression(0);
							args.push(expression);
						}
						this._match(TOK_RPAREN);
						return args[0];
					default: this._errorToken(token);
				}
			},
			led: function(tokenName, left) {
				var right;
				switch (tokenName) {
					case TOK_DOT:
						var rbp = bindingPower.Dot;
						if (this._lookahead(0) !== TOK_STAR) {
							right = this._parseDotRHS(rbp);
							return {
								type: "Subexpression",
								children: [left, right]
							};
						}
						this._advance();
						right = this._parseProjectionRHS(rbp);
						return {
							type: "ValueProjection",
							children: [left, right]
						};
					case TOK_PIPE:
						right = this.expression(bindingPower.Pipe);
						return {
							type: TOK_PIPE,
							children: [left, right]
						};
					case TOK_OR:
						right = this.expression(bindingPower.Or);
						return {
							type: "OrExpression",
							children: [left, right]
						};
					case TOK_AND:
						right = this.expression(bindingPower.And);
						return {
							type: "AndExpression",
							children: [left, right]
						};
					case TOK_LPAREN:
						var name = left.name;
						var args = [];
						var expression, node;
						while (this._lookahead(0) !== TOK_RPAREN) {
							if (this._lookahead(0) === TOK_CURRENT) {
								expression = { type: TOK_CURRENT };
								this._advance();
							} else expression = this.expression(0);
							if (this._lookahead(0) === TOK_COMMA) this._match(TOK_COMMA);
							args.push(expression);
						}
						this._match(TOK_RPAREN);
						node = {
							type: "Function",
							name,
							children: args
						};
						return node;
					case TOK_FILTER:
						var condition = this.expression(0);
						this._match(TOK_RBRACKET);
						if (this._lookahead(0) === TOK_FLATTEN) right = { type: "Identity" };
						else right = this._parseProjectionRHS(bindingPower.Filter);
						return {
							type: "FilterProjection",
							children: [
								left,
								right,
								condition
							]
						};
					case TOK_FLATTEN: return {
						type: "Projection",
						children: [{
							type: TOK_FLATTEN,
							children: [left]
						}, this._parseProjectionRHS(bindingPower.Flatten)]
					};
					case TOK_EQ:
					case TOK_NE:
					case TOK_GT:
					case TOK_GTE:
					case TOK_LT:
					case TOK_LTE: return this._parseComparator(left, tokenName);
					case TOK_LBRACKET:
						var token = this._lookaheadToken(0);
						if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
							right = this._parseIndexExpression();
							return this._projectIfSlice(left, right);
						}
						this._match(TOK_STAR);
						this._match(TOK_RBRACKET);
						right = this._parseProjectionRHS(bindingPower.Star);
						return {
							type: "Projection",
							children: [left, right]
						};
					default: this._errorToken(this._lookaheadToken(0));
				}
			},
			_match: function(tokenType) {
				if (this._lookahead(0) === tokenType) this._advance();
				else {
					var t$1 = this._lookaheadToken(0);
					var error$1 = /* @__PURE__ */ new Error("Expected " + tokenType + ", got: " + t$1.type);
					error$1.name = "ParserError";
					throw error$1;
				}
			},
			_errorToken: function(token) {
				var error$1 = /* @__PURE__ */ new Error("Invalid token (" + token.type + "): \"" + token.value + "\"");
				error$1.name = "ParserError";
				throw error$1;
			},
			_parseIndexExpression: function() {
				if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) return this._parseSliceExpression();
				else {
					var node = {
						type: "Index",
						value: this._lookaheadToken(0).value
					};
					this._advance();
					this._match(TOK_RBRACKET);
					return node;
				}
			},
			_projectIfSlice: function(left, right) {
				var indexExpr = {
					type: "IndexExpression",
					children: [left, right]
				};
				if (right.type === "Slice") return {
					type: "Projection",
					children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
				};
				else return indexExpr;
			},
			_parseSliceExpression: function() {
				var parts = [
					null,
					null,
					null
				];
				var index = 0;
				var currentToken = this._lookahead(0);
				while (currentToken !== TOK_RBRACKET && index < 3) {
					if (currentToken === TOK_COLON) {
						index++;
						this._advance();
					} else if (currentToken === TOK_NUMBER) {
						parts[index] = this._lookaheadToken(0).value;
						this._advance();
					} else {
						var t$1 = this._lookahead(0);
						var error$1 = /* @__PURE__ */ new Error("Syntax error, unexpected token: " + t$1.value + "(" + t$1.type + ")");
						error$1.name = "Parsererror";
						throw error$1;
					}
					currentToken = this._lookahead(0);
				}
				this._match(TOK_RBRACKET);
				return {
					type: "Slice",
					children: parts
				};
			},
			_parseComparator: function(left, comparator) {
				return {
					type: "Comparator",
					name: comparator,
					children: [left, this.expression(bindingPower[comparator])]
				};
			},
			_parseDotRHS: function(rbp) {
				var lookahead = this._lookahead(0);
				if ([
					TOK_UNQUOTEDIDENTIFIER,
					TOK_QUOTEDIDENTIFIER,
					TOK_STAR
				].indexOf(lookahead) >= 0) return this.expression(rbp);
				else if (lookahead === TOK_LBRACKET) {
					this._match(TOK_LBRACKET);
					return this._parseMultiselectList();
				} else if (lookahead === TOK_LBRACE) {
					this._match(TOK_LBRACE);
					return this._parseMultiselectHash();
				}
			},
			_parseProjectionRHS: function(rbp) {
				var right;
				if (bindingPower[this._lookahead(0)] < 10) right = { type: "Identity" };
				else if (this._lookahead(0) === TOK_LBRACKET) right = this.expression(rbp);
				else if (this._lookahead(0) === TOK_FILTER) right = this.expression(rbp);
				else if (this._lookahead(0) === TOK_DOT) {
					this._match(TOK_DOT);
					right = this._parseDotRHS(rbp);
				} else {
					var t$1 = this._lookaheadToken(0);
					var error$1 = /* @__PURE__ */ new Error("Sytanx error, unexpected token: " + t$1.value + "(" + t$1.type + ")");
					error$1.name = "ParserError";
					throw error$1;
				}
				return right;
			},
			_parseMultiselectList: function() {
				var expressions = [];
				while (this._lookahead(0) !== TOK_RBRACKET) {
					var expression = this.expression(0);
					expressions.push(expression);
					if (this._lookahead(0) === TOK_COMMA) {
						this._match(TOK_COMMA);
						if (this._lookahead(0) === TOK_RBRACKET) throw new Error("Unexpected token Rbracket");
					}
				}
				this._match(TOK_RBRACKET);
				return {
					type: "MultiSelectList",
					children: expressions
				};
			},
			_parseMultiselectHash: function() {
				var pairs = [];
				var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
				var keyToken, keyName, value, node;
				for (;;) {
					keyToken = this._lookaheadToken(0);
					if (identifierTypes.indexOf(keyToken.type) < 0) throw new Error("Expecting an identifier token, got: " + keyToken.type);
					keyName = keyToken.value;
					this._advance();
					this._match(TOK_COLON);
					value = this.expression(0);
					node = {
						type: "KeyValuePair",
						name: keyName,
						value
					};
					pairs.push(node);
					if (this._lookahead(0) === TOK_COMMA) this._match(TOK_COMMA);
					else if (this._lookahead(0) === TOK_RBRACE) {
						this._match(TOK_RBRACE);
						break;
					}
				}
				return {
					type: "MultiSelectHash",
					children: pairs
				};
			}
		};
		function TreeInterpreter(runtime) {
			this.runtime = runtime;
		}
		TreeInterpreter.prototype = {
			search: function(node, value) {
				return this.visit(node, value);
			},
			visit: function(node, value) {
				var matched, current, result, first$1, second, field, left, right, collected, i$2;
				switch (node.type) {
					case "Field":
						if (value !== null && isObject$8(value)) {
							field = value[node.name];
							if (field === void 0) return null;
							else return field;
						}
						return null;
					case "Subexpression":
						result = this.visit(node.children[0], value);
						for (i$2 = 1; i$2 < node.children.length; i$2++) {
							result = this.visit(node.children[1], result);
							if (result === null) return null;
						}
						return result;
					case "IndexExpression":
						left = this.visit(node.children[0], value);
						right = this.visit(node.children[1], left);
						return right;
					case "Index":
						if (!isArray$11(value)) return null;
						var index = node.value;
						if (index < 0) index = value.length + index;
						result = value[index];
						if (result === void 0) result = null;
						return result;
					case "Slice":
						if (!isArray$11(value)) return null;
						var sliceParams = node.children.slice(0);
						var computed = this.computeSliceParams(value.length, sliceParams);
						var start = computed[0];
						var stop = computed[1];
						var step = computed[2];
						result = [];
						if (step > 0) for (i$2 = start; i$2 < stop; i$2 += step) result.push(value[i$2]);
						else for (i$2 = start; i$2 > stop; i$2 += step) result.push(value[i$2]);
						return result;
					case "Projection":
						var base = this.visit(node.children[0], value);
						if (!isArray$11(base)) return null;
						collected = [];
						for (i$2 = 0; i$2 < base.length; i$2++) {
							current = this.visit(node.children[1], base[i$2]);
							if (current !== null) collected.push(current);
						}
						return collected;
					case "ValueProjection":
						base = this.visit(node.children[0], value);
						if (!isObject$8(base)) return null;
						collected = [];
						var values$1 = objValues(base);
						for (i$2 = 0; i$2 < values$1.length; i$2++) {
							current = this.visit(node.children[1], values$1[i$2]);
							if (current !== null) collected.push(current);
						}
						return collected;
					case "FilterProjection":
						base = this.visit(node.children[0], value);
						if (!isArray$11(base)) return null;
						var filtered = [];
						var finalResults = [];
						for (i$2 = 0; i$2 < base.length; i$2++) {
							matched = this.visit(node.children[2], base[i$2]);
							if (!isFalse(matched)) filtered.push(base[i$2]);
						}
						for (var j$1 = 0; j$1 < filtered.length; j$1++) {
							current = this.visit(node.children[1], filtered[j$1]);
							if (current !== null) finalResults.push(current);
						}
						return finalResults;
					case "Comparator":
						first$1 = this.visit(node.children[0], value);
						second = this.visit(node.children[1], value);
						switch (node.name) {
							case TOK_EQ:
								result = strictDeepEqual(first$1, second);
								break;
							case TOK_NE:
								result = !strictDeepEqual(first$1, second);
								break;
							case TOK_GT:
								result = first$1 > second;
								break;
							case TOK_GTE:
								result = first$1 >= second;
								break;
							case TOK_LT:
								result = first$1 < second;
								break;
							case TOK_LTE:
								result = first$1 <= second;
								break;
							default: throw new Error("Unknown comparator: " + node.name);
						}
						return result;
					case TOK_FLATTEN:
						var original = this.visit(node.children[0], value);
						if (!isArray$11(original)) return null;
						var merged = [];
						for (i$2 = 0; i$2 < original.length; i$2++) {
							current = original[i$2];
							if (isArray$11(current)) merged.push.apply(merged, current);
							else merged.push(current);
						}
						return merged;
					case "Identity": return value;
					case "MultiSelectList":
						if (value === null) return null;
						collected = [];
						for (i$2 = 0; i$2 < node.children.length; i$2++) collected.push(this.visit(node.children[i$2], value));
						return collected;
					case "MultiSelectHash":
						if (value === null) return null;
						collected = {};
						var child;
						for (i$2 = 0; i$2 < node.children.length; i$2++) {
							child = node.children[i$2];
							collected[child.name] = this.visit(child.value, value);
						}
						return collected;
					case "OrExpression":
						matched = this.visit(node.children[0], value);
						if (isFalse(matched)) matched = this.visit(node.children[1], value);
						return matched;
					case "AndExpression":
						first$1 = this.visit(node.children[0], value);
						if (isFalse(first$1) === true) return first$1;
						return this.visit(node.children[1], value);
					case "NotExpression":
						first$1 = this.visit(node.children[0], value);
						return isFalse(first$1);
					case "Literal": return node.value;
					case TOK_PIPE:
						left = this.visit(node.children[0], value);
						return this.visit(node.children[1], left);
					case TOK_CURRENT: return value;
					case "Function":
						var resolvedArgs = [];
						for (i$2 = 0; i$2 < node.children.length; i$2++) resolvedArgs.push(this.visit(node.children[i$2], value));
						return this.runtime.callFunction(node.name, resolvedArgs);
					case "ExpressionReference":
						var refNode = node.children[0];
						refNode.jmespathType = TOK_EXPREF;
						return refNode;
					default: throw new Error("Unknown node type: " + node.type);
				}
			},
			computeSliceParams: function(arrayLength, sliceParams) {
				var start = sliceParams[0];
				var stop = sliceParams[1];
				var step = sliceParams[2];
				var computed = [
					null,
					null,
					null
				];
				if (step === null) step = 1;
				else if (step === 0) {
					var error$1 = /* @__PURE__ */ new Error("Invalid slice, step cannot be 0");
					error$1.name = "RuntimeError";
					throw error$1;
				}
				var stepValueNegative = step < 0 ? true : false;
				if (start === null) start = stepValueNegative ? arrayLength - 1 : 0;
				else start = this.capSliceRange(arrayLength, start, step);
				if (stop === null) stop = stepValueNegative ? -1 : arrayLength;
				else stop = this.capSliceRange(arrayLength, stop, step);
				computed[0] = start;
				computed[1] = stop;
				computed[2] = step;
				return computed;
			},
			capSliceRange: function(arrayLength, actualValue, step) {
				if (actualValue < 0) {
					actualValue += arrayLength;
					if (actualValue < 0) actualValue = step < 0 ? -1 : 0;
				} else if (actualValue >= arrayLength) actualValue = step < 0 ? arrayLength - 1 : arrayLength;
				return actualValue;
			}
		};
		function Runtime(interpreter) {
			this._interpreter = interpreter;
			this.functionTable = {
				abs: {
					_func: this._functionAbs,
					_signature: [{ types: [TYPE_NUMBER] }]
				},
				avg: {
					_func: this._functionAvg,
					_signature: [{ types: [TYPE_ARRAY_NUMBER] }]
				},
				ceil: {
					_func: this._functionCeil,
					_signature: [{ types: [TYPE_NUMBER] }]
				},
				contains: {
					_func: this._functionContains,
					_signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }, { types: [TYPE_ANY] }]
				},
				"ends_with": {
					_func: this._functionEndsWith,
					_signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
				},
				floor: {
					_func: this._functionFloor,
					_signature: [{ types: [TYPE_NUMBER] }]
				},
				length: {
					_func: this._functionLength,
					_signature: [{ types: [
						TYPE_STRING,
						TYPE_ARRAY,
						TYPE_OBJECT
					] }]
				},
				map: {
					_func: this._functionMap,
					_signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
				},
				max: {
					_func: this._functionMax,
					_signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
				},
				"merge": {
					_func: this._functionMerge,
					_signature: [{
						types: [TYPE_OBJECT],
						variadic: true
					}]
				},
				"max_by": {
					_func: this._functionMaxBy,
					_signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
				},
				sum: {
					_func: this._functionSum,
					_signature: [{ types: [TYPE_ARRAY_NUMBER] }]
				},
				"starts_with": {
					_func: this._functionStartsWith,
					_signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
				},
				min: {
					_func: this._functionMin,
					_signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
				},
				"min_by": {
					_func: this._functionMinBy,
					_signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
				},
				type: {
					_func: this._functionType,
					_signature: [{ types: [TYPE_ANY] }]
				},
				keys: {
					_func: this._functionKeys,
					_signature: [{ types: [TYPE_OBJECT] }]
				},
				values: {
					_func: this._functionValues,
					_signature: [{ types: [TYPE_OBJECT] }]
				},
				sort: {
					_func: this._functionSort,
					_signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }]
				},
				"sort_by": {
					_func: this._functionSortBy,
					_signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
				},
				join: {
					_func: this._functionJoin,
					_signature: [{ types: [TYPE_STRING] }, { types: [TYPE_ARRAY_STRING] }]
				},
				reverse: {
					_func: this._functionReverse,
					_signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
				},
				"to_array": {
					_func: this._functionToArray,
					_signature: [{ types: [TYPE_ANY] }]
				},
				"to_string": {
					_func: this._functionToString,
					_signature: [{ types: [TYPE_ANY] }]
				},
				"to_number": {
					_func: this._functionToNumber,
					_signature: [{ types: [TYPE_ANY] }]
				},
				"not_null": {
					_func: this._functionNotNull,
					_signature: [{
						types: [TYPE_ANY],
						variadic: true
					}]
				}
			};
		}
		Runtime.prototype = {
			callFunction: function(name, resolvedArgs) {
				var functionEntry = this.functionTable[name];
				if (functionEntry === void 0) throw new Error("Unknown function: " + name + "()");
				this._validateArgs(name, resolvedArgs, functionEntry._signature);
				return functionEntry._func.call(this, resolvedArgs);
			},
			_validateArgs: function(name, args, signature) {
				var pluralized;
				if (signature[signature.length - 1].variadic) {
					if (args.length < signature.length) {
						pluralized = signature.length === 1 ? " argument" : " arguments";
						throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
					}
				} else if (args.length !== signature.length) {
					pluralized = signature.length === 1 ? " argument" : " arguments";
					throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
				}
				var currentSpec;
				var actualType;
				var typeMatched;
				for (var i$2 = 0; i$2 < signature.length; i$2++) {
					typeMatched = false;
					currentSpec = signature[i$2].types;
					actualType = this._getTypeName(args[i$2]);
					for (var j$1 = 0; j$1 < currentSpec.length; j$1++) if (this._typeMatches(actualType, currentSpec[j$1], args[i$2])) {
						typeMatched = true;
						break;
					}
					if (!typeMatched) {
						var expected = currentSpec.map(function(typeIdentifier) {
							return TYPE_NAME_TABLE[typeIdentifier];
						}).join(",");
						throw new Error("TypeError: " + name + "() expected argument " + (i$2 + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
					}
				}
			},
			_typeMatches: function(actual, expected, argValue) {
				if (expected === TYPE_ANY) return true;
				if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
					if (expected === TYPE_ARRAY) return actual === TYPE_ARRAY;
					else if (actual === TYPE_ARRAY) {
						var subtype;
						if (expected === TYPE_ARRAY_NUMBER) subtype = TYPE_NUMBER;
						else if (expected === TYPE_ARRAY_STRING) subtype = TYPE_STRING;
						for (var i$2 = 0; i$2 < argValue.length; i$2++) if (!this._typeMatches(this._getTypeName(argValue[i$2]), subtype, argValue[i$2])) return false;
						return true;
					}
				} else return actual === expected;
			},
			_getTypeName: function(obj) {
				switch (Object.prototype.toString.call(obj)) {
					case "[object String]": return TYPE_STRING;
					case "[object Number]": return TYPE_NUMBER;
					case "[object Array]": return TYPE_ARRAY;
					case "[object Boolean]": return TYPE_BOOLEAN;
					case "[object Null]": return TYPE_NULL;
					case "[object Object]": if (obj.jmespathType === TOK_EXPREF) return TYPE_EXPREF;
					else return TYPE_OBJECT;
				}
			},
			_functionStartsWith: function(resolvedArgs) {
				return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
			},
			_functionEndsWith: function(resolvedArgs) {
				var searchStr = resolvedArgs[0];
				var suffix = resolvedArgs[1];
				return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
			},
			_functionReverse: function(resolvedArgs) {
				if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
					var originalStr = resolvedArgs[0];
					var reversedStr = "";
					for (var i$2 = originalStr.length - 1; i$2 >= 0; i$2--) reversedStr += originalStr[i$2];
					return reversedStr;
				} else {
					var reversedArray = resolvedArgs[0].slice(0);
					reversedArray.reverse();
					return reversedArray;
				}
			},
			_functionAbs: function(resolvedArgs) {
				return Math.abs(resolvedArgs[0]);
			},
			_functionCeil: function(resolvedArgs) {
				return Math.ceil(resolvedArgs[0]);
			},
			_functionAvg: function(resolvedArgs) {
				var sum$1 = 0;
				var inputArray = resolvedArgs[0];
				for (var i$2 = 0; i$2 < inputArray.length; i$2++) sum$1 += inputArray[i$2];
				return sum$1 / inputArray.length;
			},
			_functionContains: function(resolvedArgs) {
				return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
			},
			_functionFloor: function(resolvedArgs) {
				return Math.floor(resolvedArgs[0]);
			},
			_functionLength: function(resolvedArgs) {
				if (!isObject$8(resolvedArgs[0])) return resolvedArgs[0].length;
				else return Object.keys(resolvedArgs[0]).length;
			},
			_functionMap: function(resolvedArgs) {
				var mapped = [];
				var interpreter = this._interpreter;
				var exprefNode = resolvedArgs[0];
				var elements = resolvedArgs[1];
				for (var i$2 = 0; i$2 < elements.length; i$2++) mapped.push(interpreter.visit(exprefNode, elements[i$2]));
				return mapped;
			},
			_functionMerge: function(resolvedArgs) {
				var merged = {};
				for (var i$2 = 0; i$2 < resolvedArgs.length; i$2++) {
					var current = resolvedArgs[i$2];
					for (var key in current) merged[key] = current[key];
				}
				return merged;
			},
			_functionMax: function(resolvedArgs) {
				if (resolvedArgs[0].length > 0) if (this._getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER) return Math.max.apply(Math, resolvedArgs[0]);
				else {
					var elements = resolvedArgs[0];
					var maxElement = elements[0];
					for (var i$2 = 1; i$2 < elements.length; i$2++) if (maxElement.localeCompare(elements[i$2]) < 0) maxElement = elements[i$2];
					return maxElement;
				}
				else return null;
			},
			_functionMin: function(resolvedArgs) {
				if (resolvedArgs[0].length > 0) if (this._getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER) return Math.min.apply(Math, resolvedArgs[0]);
				else {
					var elements = resolvedArgs[0];
					var minElement = elements[0];
					for (var i$2 = 1; i$2 < elements.length; i$2++) if (elements[i$2].localeCompare(minElement) < 0) minElement = elements[i$2];
					return minElement;
				}
				else return null;
			},
			_functionSum: function(resolvedArgs) {
				var sum$1 = 0;
				var listToSum = resolvedArgs[0];
				for (var i$2 = 0; i$2 < listToSum.length; i$2++) sum$1 += listToSum[i$2];
				return sum$1;
			},
			_functionType: function(resolvedArgs) {
				switch (this._getTypeName(resolvedArgs[0])) {
					case TYPE_NUMBER: return "number";
					case TYPE_STRING: return "string";
					case TYPE_ARRAY: return "array";
					case TYPE_OBJECT: return "object";
					case TYPE_BOOLEAN: return "boolean";
					case TYPE_EXPREF: return "expref";
					case TYPE_NULL: return "null";
				}
			},
			_functionKeys: function(resolvedArgs) {
				return Object.keys(resolvedArgs[0]);
			},
			_functionValues: function(resolvedArgs) {
				var obj = resolvedArgs[0];
				var keys$9 = Object.keys(obj);
				var values$1 = [];
				for (var i$2 = 0; i$2 < keys$9.length; i$2++) values$1.push(obj[keys$9[i$2]]);
				return values$1;
			},
			_functionJoin: function(resolvedArgs) {
				var joinChar = resolvedArgs[0];
				return resolvedArgs[1].join(joinChar);
			},
			_functionToArray: function(resolvedArgs) {
				if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) return resolvedArgs[0];
				else return [resolvedArgs[0]];
			},
			_functionToString: function(resolvedArgs) {
				if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) return resolvedArgs[0];
				else return JSON.stringify(resolvedArgs[0]);
			},
			_functionToNumber: function(resolvedArgs) {
				var typeName = this._getTypeName(resolvedArgs[0]);
				var convertedValue;
				if (typeName === TYPE_NUMBER) return resolvedArgs[0];
				else if (typeName === TYPE_STRING) {
					convertedValue = +resolvedArgs[0];
					if (!isNaN(convertedValue)) return convertedValue;
				}
				return null;
			},
			_functionNotNull: function(resolvedArgs) {
				for (var i$2 = 0; i$2 < resolvedArgs.length; i$2++) if (this._getTypeName(resolvedArgs[i$2]) !== TYPE_NULL) return resolvedArgs[i$2];
				return null;
			},
			_functionSort: function(resolvedArgs) {
				var sortedArray = resolvedArgs[0].slice(0);
				sortedArray.sort();
				return sortedArray;
			},
			_functionSortBy: function(resolvedArgs) {
				var sortedArray = resolvedArgs[0].slice(0);
				if (sortedArray.length === 0) return sortedArray;
				var interpreter = this._interpreter;
				var exprefNode = resolvedArgs[1];
				var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
				if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) throw new Error("TypeError");
				var that = this;
				var decorated = [];
				for (var i$2 = 0; i$2 < sortedArray.length; i$2++) decorated.push([i$2, sortedArray[i$2]]);
				decorated.sort(function(a$1, b$5) {
					var exprA = interpreter.visit(exprefNode, a$1[1]);
					var exprB = interpreter.visit(exprefNode, b$5[1]);
					if (that._getTypeName(exprA) !== requiredType) throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA));
					else if (that._getTypeName(exprB) !== requiredType) throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB));
					if (exprA > exprB) return 1;
					else if (exprA < exprB) return -1;
					else return a$1[0] - b$5[0];
				});
				for (var j$1 = 0; j$1 < decorated.length; j$1++) sortedArray[j$1] = decorated[j$1][1];
				return sortedArray;
			},
			_functionMaxBy: function(resolvedArgs) {
				var exprefNode = resolvedArgs[1];
				var resolvedArray = resolvedArgs[0];
				var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
				var maxNumber = -Infinity;
				var maxRecord;
				var current;
				for (var i$2 = 0; i$2 < resolvedArray.length; i$2++) {
					current = keyFunction(resolvedArray[i$2]);
					if (current > maxNumber) {
						maxNumber = current;
						maxRecord = resolvedArray[i$2];
					}
				}
				return maxRecord;
			},
			_functionMinBy: function(resolvedArgs) {
				var exprefNode = resolvedArgs[1];
				var resolvedArray = resolvedArgs[0];
				var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
				var minNumber = Infinity;
				var minRecord;
				var current;
				for (var i$2 = 0; i$2 < resolvedArray.length; i$2++) {
					current = keyFunction(resolvedArray[i$2]);
					if (current < minNumber) {
						minNumber = current;
						minRecord = resolvedArray[i$2];
					}
				}
				return minRecord;
			},
			createKeyFunction: function(exprefNode, allowedTypes) {
				var that = this;
				var interpreter = this._interpreter;
				var keyFunc = function(x$1) {
					var current = interpreter.visit(exprefNode, x$1);
					if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
						var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
						throw new Error(msg);
					}
					return current;
				};
				return keyFunc;
			}
		};
		function compile(stream) {
			return new Parser$1().parse(stream);
		}
		function tokenize(stream) {
			return new Lexer().tokenize(stream);
		}
		function search(data, expression) {
			var parser = new Parser$1();
			var runtime = new Runtime();
			var interpreter = new TreeInterpreter(runtime);
			runtime._interpreter = interpreter;
			var node = parser.parse(expression);
			return interpreter.search(node, data);
		}
		exports$1.tokenize = tokenize;
		exports$1.compile = compile;
		exports$1.search = search;
		exports$1.strictDeepEqual = strictDeepEqual;
	})(typeof exports === "undefined" ? exports.jmespath = {} : exports);
}));
var defaultPropertyDescriptor = Object.freeze({
	enumerable: true,
	configurable: true
});
var { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
var augmentedObjects = /* @__PURE__ */ new WeakSet();
function augment(value) {
	if (typeof value !== "object" || value === null || value instanceof RegExp) return value;
	if (value instanceof Date) return new Date(value.valueOf());
	if (value instanceof Uint8Array) return value.slice();
	if (Array.isArray(value)) return augmentArray(value);
	return augmentObject(value);
}
function augmentArray(data) {
	if (augmentedObjects.has(data)) return data;
	let newData = void 0;
	function getData() {
		if (newData === void 0) newData = [...data];
		return newData;
	}
	const proxy = new Proxy(data, {
		deleteProperty(_target, key) {
			return Reflect.deleteProperty(getData(), key);
		},
		get(target, key, receiver) {
			if (key === "constructor") return Array;
			const value = Reflect.get(newData ?? target, key, receiver);
			const newValue = augment(value);
			if (newValue !== value) {
				newData = getData();
				Reflect.set(newData, key, newValue);
				return newValue;
			}
			return value;
		},
		getOwnPropertyDescriptor(target, key) {
			if (newData === void 0) return Reflect.getOwnPropertyDescriptor(target, key);
			if (key === "length") return Reflect.getOwnPropertyDescriptor(newData, key);
			return Object.getOwnPropertyDescriptor(data, key) ?? defaultPropertyDescriptor;
		},
		has(target, key) {
			return Reflect.has(newData ?? target, key);
		},
		ownKeys(target) {
			return Reflect.ownKeys(newData ?? target);
		},
		set(_target, key, newValue) {
			return Reflect.set(getData(), key, augment(newValue));
		}
	});
	augmentedObjects.add(proxy);
	return proxy;
}
function augmentObject(data) {
	if (augmentedObjects.has(data)) return data;
	const newData = {};
	const deletedProperties = /* @__PURE__ */ new Set();
	const proxy = new Proxy(data, {
		get(target, key, receiver) {
			if (key === "constructor") return Object;
			if (deletedProperties.has(key)) return;
			if (hasOwnProperty$2.call(newData, key)) return newData[key];
			const value = Reflect.get(target, key, receiver);
			if (typeof value !== "object" || value === null) return value;
			if (value instanceof RegExp) return value.toString();
			if ("toJSON" in value && typeof value.toJSON === "function") return value.toJSON();
			const newValue = augment(value);
			if (newValue !== value) {
				Object.assign(newData, { [key]: newValue });
				return newValue;
			}
			return value;
		},
		deleteProperty(_target, key) {
			if (hasOwnProperty$2.call(newData, key)) delete newData[key];
			if (hasOwnProperty$2.call(data, key)) deletedProperties.add(key);
			return true;
		},
		set(target, key, newValue) {
			if (newValue === void 0) {
				if (key in newData) delete newData[key];
				if (key in target) deletedProperties.add(key);
				return true;
			}
			newData[key] = newValue;
			if (deletedProperties.has(key)) deletedProperties.delete(key);
			return true;
		},
		has(_target, key) {
			if (deletedProperties.has(key)) return false;
			const target = hasOwnProperty$2.call(newData, key) ? newData : data;
			return Reflect.has(target, key);
		},
		ownKeys(target) {
			const originalKeys$1 = Reflect.ownKeys(target);
			const newKeys = Object.keys(newData);
			return [...new Set([...originalKeys$1, ...newKeys])].filter((key) => !deletedProperties.has(key));
		},
		getOwnPropertyDescriptor(_target, key) {
			if (deletedProperties.has(key)) return void 0;
			const target = hasOwnProperty$2.call(newData, key) ? newData : data;
			return Object.getOwnPropertyDescriptor(target, key);
		}
	});
	augmentedObjects.add(proxy);
	return proxy;
}
const createResultOk = (data) => ({
	ok: true,
	result: data
});
const createResultError = (error$1) => ({
	ok: false,
	error: error$1
});
init_dist$1();
function createEnvProviderState() {
	const isProcessAvailable = typeof process$1 !== "undefined";
	const isEnvAccessBlocked = isProcessAvailable ? {}.N8N_BLOCK_ENV_ACCESS_IN_NODE === "true" : false;
	return {
		isProcessAvailable,
		isEnvAccessBlocked,
		env: !isProcessAvailable || isEnvAccessBlocked ? {} : {}
	};
}
function createEnvProvider(runIndex, itemIndex, providerState) {
	return new Proxy({}, {
		has() {
			return true;
		},
		get(_$1, name) {
			if (name === "isProxy") return true;
			if (!providerState.isProcessAvailable) throw new ExpressionError("not accessible via UI, please run node", {
				runIndex,
				itemIndex
			});
			if (providerState.isEnvAccessBlocked) throw new ExpressionError("access to env vars denied", {
				causeDetailed: "If you need access please contact the administrator to remove the environment variable ‘N8N_BLOCK_ENV_ACCESS_IN_NODE‘",
				runIndex,
				itemIndex
			});
			return providerState.env[name.toString()];
		}
	});
}
function getPinDataIfManualExecution(workflow, nodeName, mode) {
	if (mode !== "manual") return;
	return workflow.getPinDataOfNode(nodeName);
}
var import_jmespath = /* @__PURE__ */ __toESM(require_jmespath());
var isScriptingNode = (nodeName, workflow) => {
	const node = workflow.getNode(nodeName);
	return node && SCRIPTING_NODE_TYPES.includes(node.type);
};
var PAIRED_ITEM_METHOD = {
	PAIRED_ITEM: "pairedItem",
	ITEM_MATCHING: "itemMatching",
	ITEM: "item",
	$GET_PAIRED_ITEM: "$getPairedItem"
};
var WorkflowDataProxy = class WorkflowDataProxy {
	workflow;
	runIndex;
	itemIndex;
	activeNodeName;
	siblingParameters;
	mode;
	additionalKeys;
	executeData;
	defaultReturnRunIndex;
	selfData;
	contextNodeName;
	envProviderState;
	runExecutionData;
	connectionInputData;
	timezone;
	constructor(workflow, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, siblingParameters, mode, additionalKeys, executeData, defaultReturnRunIndex = -1, selfData = {}, contextNodeName = activeNodeName, envProviderState) {
		this.workflow = workflow;
		this.runIndex = runIndex;
		this.itemIndex = itemIndex;
		this.activeNodeName = activeNodeName;
		this.siblingParameters = siblingParameters;
		this.mode = mode;
		this.additionalKeys = additionalKeys;
		this.executeData = executeData;
		this.defaultReturnRunIndex = defaultReturnRunIndex;
		this.selfData = selfData;
		this.contextNodeName = contextNodeName;
		this.envProviderState = envProviderState;
		this.runExecutionData = isScriptingNode(this.contextNodeName, workflow) ? runExecutionData !== null ? augmentObject(runExecutionData) : null : runExecutionData;
		this.connectionInputData = isScriptingNode(this.contextNodeName, workflow) ? augmentArray(connectionInputData) : connectionInputData;
		this.timezone = workflow.settings?.timezone ?? getGlobalState().defaultTimezone;
		Settings.defaultZone = this.timezone;
	}
	nodeContextGetter(nodeName) {
		const that = this;
		const node = this.workflow.nodes[nodeName];
		if (!that.runExecutionData?.executionData && that.connectionInputData.length > 0) return {};
		if (!that.runExecutionData?.executionData && !that.runExecutionData?.resultData) throw new ExpressionError("The workflow hasn't been executed yet, so you can't reference any context data", {
			runIndex: that.runIndex,
			itemIndex: that.itemIndex,
			type: "no_execution_data"
		});
		return new Proxy({}, {
			has: () => true,
			ownKeys(target) {
				if (Reflect.ownKeys(target).length === 0) Object.assign(target, getContext(that.runExecutionData, "node", node));
				return Reflect.ownKeys(target);
			},
			getOwnPropertyDescriptor() {
				return {
					enumerable: true,
					configurable: true
				};
			},
			get(_$1, name) {
				if (name === "isProxy") return true;
				name = name.toString();
				return getContext(that.runExecutionData, "node", node)[name];
			}
		});
	}
	selfGetter() {
		const that = this;
		return new Proxy({}, {
			has: () => true,
			ownKeys(target) {
				return Reflect.ownKeys(target);
			},
			get(_$1, name) {
				if (name === "isProxy") return true;
				name = name.toString();
				return that.selfData[name];
			}
		});
	}
	buildAgentToolInfo(node) {
		const nodeType = this.workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
		const type = nodeType.description.displayName;
		const params = getNodeParameters(nodeType.description.properties, node.parameters, true, false, node, nodeType.description);
		const resourceKey = params?.resource;
		const operationKey = params?.operation;
		const resource = nodeType.description.properties.find((nodeProperties) => nodeProperties.name === "resource")?.options?.find((option) => "value" in option && option.value === resourceKey)?.name ?? null;
		const operation = nodeType.description.properties.find((nodeProperty) => nodeProperty.name === "operation" && nodeProperty.displayOptions?.show?.resource?.some((y$1) => y$1 === resourceKey))?.options?.find((y$1) => "value" in y$1 && y$1.value === operationKey)?.name ?? null;
		const hasCredentials = !isObjectEmpty(node.credentials ?? {});
		const hasValidCalendar = nodeType.description.name.includes("googleCalendar") ? isResourceLocatorValue(node.parameters.calendar) && node.parameters.calendar.value !== "" : void 0;
		const aiDefinedFields = Object.entries(node.parameters).map(([key, value]) => [key, isResourceLocatorValue(value) ? value.value : value]).filter(([_$1, value]) => value?.toString().toLowerCase().includes("$fromai")).map(([key]) => nodeType.description.properties.find((property$2) => property$2.name === key)?.displayName);
		return {
			name: node.name,
			type,
			resource,
			operation,
			hasCredentials,
			hasValidCalendar,
			aiDefinedFields
		};
	}
	agentInfo() {
		const agentNode = this.workflow.getNode(this.activeNodeName);
		if (!agentNode || agentNode.type !== "@n8n/n8n-nodes-langchain.agent") return void 0;
		const connectedTools = this.workflow.getParentNodes(this.activeNodeName, NodeConnectionTypes.AiTool).map((nodeName) => this.workflow.getNode(nodeName)).filter((node) => node);
		const memoryConnectedToAgent = this.workflow.getParentNodes(this.activeNodeName, NodeConnectionTypes.AiMemory).length > 0;
		const unconnectedTools = this.workflow.queryNodes((nodeType) => {
			return nodeType.description.name.toLowerCase().includes("tool");
		}).filter((node) => this.workflow.getChildNodes(node.name, NodeConnectionTypes.AiTool, 1).length === 0).filter((node) => !connectedTools.includes(node));
		return {
			memoryConnectedToAgent,
			tools: [...connectedTools.map((node) => ({
				connected: true,
				...this.buildAgentToolInfo(node)
			})), ...unconnectedTools.map((node) => ({
				connected: false,
				...this.buildAgentToolInfo(node)
			}))]
		};
	}
	nodeParameterGetter(nodeName, resolveValue = true) {
		const that = this;
		const node = this.workflow.nodes[nodeName];
		return new Proxy(node?.parameters ?? {}, {
			has: () => true,
			ownKeys(target) {
				return Reflect.ownKeys(target);
			},
			getOwnPropertyDescriptor() {
				return {
					enumerable: true,
					configurable: true
				};
			},
			get(target, name) {
				if (name === "isProxy") return true;
				if (name === "toJSON") return () => deepCopy(target);
				name = name.toString();
				let returnValue;
				if (name[0] === "&") {
					const key = name.slice(1);
					if (!that.siblingParameters.hasOwnProperty(key)) throw new ApplicationError("Could not find sibling parameter on node", { extra: {
						nodeName,
						parameter: key
					} });
					returnValue = that.siblingParameters[key];
				} else {
					if (!node.parameters.hasOwnProperty(name)) return;
					returnValue = node.parameters[name];
				}
				if (returnValue === `={{ $parameter.${name} }}`) return void 0;
				if (isResourceLocatorValue(returnValue)) if (returnValue.__regex && typeof returnValue.value === "string") {
					const extracted = new RegExp(returnValue.__regex).exec(returnValue.value);
					if (extracted && extracted.length >= 2) returnValue = extracted[1];
					else return returnValue.value;
				} else returnValue = returnValue.value;
				if (resolveValue && typeof returnValue === "string" && returnValue.charAt(0) === "=") return that.workflow.expression.getParameterValue(returnValue, that.runExecutionData, that.runIndex, that.itemIndex, that.activeNodeName, that.connectionInputData, that.mode, that.additionalKeys, that.executeData, false, {}, that.contextNodeName);
				return returnValue;
			}
		});
	}
	getNodeExecutionOrPinnedData({ nodeName, branchIndex, runIndex, shortSyntax = false }) {
		try {
			return this.getNodeExecutionData(nodeName, shortSyntax, branchIndex, runIndex);
		} catch (e$1) {
			const pinData = getPinDataIfManualExecution(this.workflow, nodeName, this.mode);
			if (pinData) return pinData;
			throw e$1;
		}
	}
	getNodeExecutionData(nodeName, shortSyntax = false, outputIndex, runIndex) {
		const that = this;
		let executionData;
		if (!shortSyntax) {
			if (that.runExecutionData === null) throw new ExpressionError("The workflow hasn't been executed yet, so you can't reference any output data", {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			if (!that.workflow.getNode(nodeName)) throw new ExpressionError("Referenced node doesn't exist", {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex,
				nodeCause: nodeName,
				descriptionKey: "nodeNotFound"
			});
			if (!that.runExecutionData.resultData.runData.hasOwnProperty(nodeName) && !getPinDataIfManualExecution(that.workflow, nodeName, that.mode)) throw new ExpressionError(`Node '${nodeName}' hasn't been executed`, {
				messageTemplate: "An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $(\"{{nodeName}}\").isExecuted, <action_if_executed>, \"\") }}",
				functionality: "pairedItem",
				descriptionKey: isScriptingNode(nodeName, that.workflow) ? "pairedItemNoConnectionCodeNode" : "pairedItemNoConnection",
				type: "no_execution_data",
				nodeCause: nodeName,
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			runIndex = runIndex === void 0 ? that.defaultReturnRunIndex : runIndex;
			runIndex = runIndex === -1 ? that.runExecutionData.resultData.runData[nodeName].length - 1 : runIndex;
			if (that.runExecutionData.resultData.runData[nodeName].length <= runIndex) throw new ExpressionError(`Run ${runIndex} of node "${nodeName}" not found`, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			const taskData = that.runExecutionData.resultData.runData[nodeName][runIndex].data;
			if (!taskData.main?.length || taskData.main[0] === null) throw new ExpressionError("No data found from `main` input", {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			if (outputIndex === void 0) {
				const nodeConnection = that.workflow.getNodeConnectionIndexes(that.contextNodeName, nodeName, NodeConnectionTypes.Main);
				if (nodeConnection === void 0) throw new ExpressionError(`connect "${that.contextNodeName}" to "${nodeName}"`, {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex
				});
				outputIndex = nodeConnection.sourceIndex;
			}
			if (outputIndex === void 0) outputIndex = 0;
			if (taskData.main.length <= outputIndex) throw new ExpressionError(`Node "${nodeName}" has no branch with index ${outputIndex}.`, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			executionData = taskData.main[outputIndex];
		} else executionData = that.connectionInputData;
		return executionData;
	}
	nodeDataGetter(nodeName, shortSyntax = false, throwOnMissingExecutionData = true) {
		const that = this;
		const node = this.workflow.nodes[nodeName];
		return new Proxy({
			binary: void 0,
			data: void 0,
			json: void 0
		}, {
			has: () => true,
			get(target, name, receiver) {
				if (name === "isProxy") return true;
				name = name.toString();
				if (!node) throw new ExpressionError("Referenced node does not exist", {
					messageTemplate: "Make sure to double-check the node name for typos",
					functionality: "pairedItem",
					descriptionKey: isScriptingNode(nodeName, that.workflow) ? "pairedItemNoConnectionCodeNode" : "pairedItemNoConnection",
					type: "paired_item_no_connection",
					nodeCause: nodeName,
					runIndex: that.runIndex,
					itemIndex: that.itemIndex
				});
				if ([
					"binary",
					"data",
					"json"
				].includes(name)) {
					const executionData = that.getNodeExecutionOrPinnedData({
						nodeName,
						shortSyntax
					});
					if (executionData.length === 0 && !throwOnMissingExecutionData) return;
					if (executionData.length === 0) throw new ExpressionError(`Node '${nodeName}' hasn't been executed`, {
						messageTemplate: "An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $(\"{{nodeName}}\").isExecuted, <action_if_executed>, \"\") }}",
						functionality: "pairedItem",
						descriptionKey: isScriptingNode(nodeName, that.workflow) ? "pairedItemNoConnectionCodeNode" : "pairedItemNoConnection",
						type: "no_execution_data",
						nodeCause: nodeName,
						runIndex: that.runIndex,
						itemIndex: that.itemIndex
					});
					if (executionData.length <= that.itemIndex) throw new ExpressionError(`"${nodeName}" node has ${executionData.length} item(s) but you're trying to access item ${that.itemIndex}`, {
						messageTemplate: "Adjust your expression to access an existing item index (0-{{maxIndex}})",
						functionality: "pairedItem",
						descriptionKey: "pairedItemInvalidIndex",
						type: "no_execution_data",
						nodeCause: nodeName,
						runIndex: that.runIndex,
						itemIndex: that.itemIndex
					});
					if (["data", "json"].includes(name)) return executionData[that.itemIndex].json;
					if (name === "binary") {
						const returnData = {};
						if (!executionData[that.itemIndex].binary) return returnData;
						const binaryKeyData = executionData[that.itemIndex].binary;
						for (const keyName of Object.keys(binaryKeyData)) {
							returnData[keyName] = {};
							const binaryData = binaryKeyData[keyName];
							for (const propertyName in binaryData) {
								if (propertyName === "data") continue;
								returnData[keyName][propertyName] = binaryData[propertyName];
							}
						}
						return returnData;
					}
				} else if (name === "context") return that.nodeContextGetter(nodeName);
				else if (name === "parameter") return that.nodeParameterGetter(nodeName);
				else if (name === "runIndex") {
					if (!that.runExecutionData?.resultData.runData[nodeName]) return -1;
					return that.runExecutionData.resultData.runData[nodeName].length - 1;
				}
				return Reflect.get(target, name, receiver);
			}
		});
	}
	prevNodeGetter() {
		const allowedValues = [
			"name",
			"outputIndex",
			"runIndex"
		];
		const that = this;
		return new Proxy({}, {
			has: () => true,
			ownKeys() {
				return allowedValues;
			},
			getOwnPropertyDescriptor() {
				return {
					enumerable: true,
					configurable: true
				};
			},
			get(target, name, receiver) {
				if (name === "isProxy") return true;
				if (!that.executeData?.source) return;
				const sourceData = that.executeData.source.main[0];
				if (name === "name") return sourceData.previousNode;
				if (name === "outputIndex") return sourceData.previousNodeOutput || 0;
				if (name === "runIndex") return sourceData.previousNodeRun || 0;
				return Reflect.get(target, name, receiver);
			}
		});
	}
	workflowGetter() {
		const allowedValues = [
			"active",
			"id",
			"name"
		];
		const that = this;
		return new Proxy({}, {
			has: () => true,
			ownKeys() {
				return allowedValues;
			},
			getOwnPropertyDescriptor() {
				return {
					enumerable: true,
					configurable: true
				};
			},
			get(target, name, receiver) {
				if (name === "isProxy") return true;
				if (allowedValues.includes(name.toString())) {
					const value = that.workflow[name];
					if (value === void 0 && name === "id") throw new ExpressionError("save workflow to view", {
						description: "Please save the workflow first to use $workflow",
						runIndex: that.runIndex,
						itemIndex: that.itemIndex
					});
					return value;
				}
				return Reflect.get(target, name, receiver);
			}
		});
	}
	nodeGetter() {
		const that = this;
		return new Proxy({}, {
			has: () => true,
			get(_$1, name) {
				if (name === "isProxy") return true;
				const nodeName = name.toString();
				if (that.workflow.getNode(nodeName) === null) throw new ExpressionError("Referenced node doesn't exist", {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
					nodeCause: nodeName,
					descriptionKey: "nodeNotFound"
				});
				return that.nodeDataGetter(nodeName);
			}
		});
	}
	getDataProxy(opts) {
		const that = this;
		const jmespathWrapper = (data, query) => {
			if (typeof data !== "object" || typeof query !== "string") throw new ExpressionError("expected two arguments (Object, string) for this function", {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex
			});
			if (!Array.isArray(data) && typeof data === "object") return import_jmespath.search({ ...data }, query);
			return import_jmespath.search(data, query);
		};
		const createExpressionError = (message, context) => {
			if (isScriptingNode(that.activeNodeName, that.workflow) && context?.functionOverrides) {
				message = context.functionOverrides.message || message;
				context.description = context.functionOverrides.description || context.description;
				context.messageTemplate = void 0;
			}
			if (context?.nodeCause) {
				const nodeName = context.nodeCause;
				const pinData = getPinDataIfManualExecution(that.workflow, nodeName, that.mode);
				if (pinData) {
					if (!context) context = {};
					message = `Unpin '${nodeName}' to execute`;
					context.messageTemplate = void 0;
					context.descriptionKey = "pairedItemPinned";
				}
				if (context.moreInfoLink && (pinData || isScriptingNode(nodeName, that.workflow))) {
					const moreInfoLink = " <a target=\"_blank\" href=\"https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/\">More info</a>";
					context.description += moreInfoLink;
					if (context.descriptionTemplate) context.descriptionTemplate += moreInfoLink;
				}
			}
			return new ExpressionError(message, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex,
				...context
			});
		};
		const createInvalidPairedItemError = ({ nodeName }) => {
			return createExpressionError("Can't get data for expression", {
				messageTemplate: "Expression info invalid",
				functionality: "pairedItem",
				functionOverrides: { message: "Can't get data" },
				nodeCause: nodeName,
				descriptionKey: "pairedItemInvalidInfo",
				type: "paired_item_invalid_info"
			});
		};
		const createMissingPairedItemError = (nodeCause, usedMethodName = PAIRED_ITEM_METHOD.PAIRED_ITEM) => {
			return new ExpressionError(getPinDataIfManualExecution(that.workflow, nodeCause, that.mode) ? `Using the ${usedMethodName} method doesn't work with pinned data in this scenario. Please unpin '${nodeCause}' and try again.` : `Paired item data for ${usedMethodName} from node '${nodeCause}' is unavailable. Ensure '${nodeCause}' is providing the required output.`, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex,
				functionality: "pairedItem",
				descriptionKey: isScriptingNode(nodeCause, that.workflow) ? "pairedItemNoInfoCodeNode" : "pairedItemNoInfo",
				nodeCause,
				causeDetailed: `Missing pairedItem data (node '${nodeCause}' probably didn't supply it)`,
				type: "paired_item_no_info"
			});
		};
		const createNoConnectionError = (nodeCause) => {
			return createExpressionError("Invalid expression", {
				messageTemplate: "No path back to referenced node",
				functionality: "pairedItem",
				descriptionKey: isScriptingNode(nodeCause, that.workflow) ? "pairedItemNoConnectionCodeNode" : "pairedItemNoConnection",
				type: "paired_item_no_connection",
				moreInfoLink: true,
				nodeCause
			});
		};
		function createBranchNotFoundError(node, item, cause) {
			return createExpressionError("Branch not found", {
				messageTemplate: "Paired item references non-existent branch",
				functionality: "pairedItem",
				nodeCause: cause,
				functionOverrides: { message: "Invalid branch reference" },
				description: `Item ${item} in node ${node} references a branch that doesn't exist.`,
				type: "paired_item_invalid_info"
			});
		}
		function createPairedItemNotFound(destNode, cause) {
			return createExpressionError("Paired item resolution failed", {
				messageTemplate: "Unable to find paired item source",
				functionality: "pairedItem",
				nodeCause: cause,
				functionOverrides: { message: "Data not found" },
				description: `Could not trace back to node '${destNode}'`,
				type: "paired_item_no_info",
				moreInfoLink: true
			});
		}
		function createPairedItemMultipleItemsFound(destNode, itemIndex) {
			return createExpressionError("Multiple matches found", {
				messageTemplate: `Multiple matching items for item [${itemIndex}]`,
				functionality: "pairedItem",
				functionOverrides: { message: "Multiple matches" },
				nodeCause: destNode,
				descriptionKey: isScriptingNode(destNode, that.workflow) ? "pairedItemMultipleMatchesCodeNode" : "pairedItemMultipleMatches",
				type: "paired_item_multiple_matches"
			});
		}
		function normalizeInputs(pairedItem, sourceData) {
			if (typeof pairedItem === "number") pairedItem = { item: pairedItem };
			const finalSource = pairedItem.sourceOverwrite || sourceData;
			return [pairedItem, finalSource];
		}
		function pinDataToTask(pinData) {
			if (!pinData) return void 0;
			return {
				data: { main: [pinData] },
				startTime: 0,
				executionTime: 0,
				executionIndex: 0,
				source: []
			};
		}
		function getTaskData(source) {
			return that.runExecutionData?.resultData?.runData?.[source.previousNode]?.[source.previousNodeRun || 0] ?? pinDataToTask(getPinDataIfManualExecution(that.workflow, source.previousNode, that.mode));
		}
		function getNodeOutput(taskData, source, nodeCause) {
			const outputIndex = source.previousNodeOutput || 0;
			const outputs = taskData?.data?.main?.[outputIndex];
			if (!outputs) throw createExpressionError("Can’t get data for expression", {
				messageTemplate: "Missing output data",
				functionOverrides: { message: "Missing output" },
				nodeCause,
				description: `Expected output #${outputIndex} from node ${source.previousNode}`,
				type: "internal"
			});
			return outputs;
		}
		const normalizePairedItem = (paired) => {
			if (paired === null || paired === void 0) return [];
			return (Array.isArray(paired) ? paired : [paired]).map((p$1) => typeof p$1 === "number" ? { item: p$1 } : p$1);
		};
		const getPairedItem = (destinationNodeName, incomingSourceData, initialPairedItem, usedMethodName = PAIRED_ITEM_METHOD.$GET_PAIRED_ITEM, nodeBeforeLast) => {
			const [pairedItem, sourceData] = normalizeInputs(initialPairedItem, incomingSourceData);
			if (!sourceData) throw createPairedItemNotFound(destinationNodeName, nodeBeforeLast);
			const taskData = getTaskData(sourceData);
			const outputData = getNodeOutput(taskData, sourceData, nodeBeforeLast);
			const item = outputData[pairedItem.item];
			const sourceArray = taskData?.source ?? [];
			if (sourceData.previousNode === destinationNodeName) {
				if (pairedItem.item >= outputData.length) throw createInvalidPairedItemError({ nodeName: sourceData.previousNode });
				return item;
			}
			const nextPairedItems = normalizePairedItem(item.pairedItem);
			if (nextPairedItems.length === 0) throw createMissingPairedItemError(sourceData.previousNode, usedMethodName);
			const results = nextPairedItems.flatMap((nextPairedItem) => {
				const inputIndex = nextPairedItem.input ?? 0;
				if (inputIndex >= sourceArray.length) return [];
				const nextSource = nextPairedItem.sourceOverwrite ?? sourceArray[inputIndex];
				try {
					return createResultOk(getPairedItem(destinationNodeName, nextSource, {
						...nextPairedItem,
						input: inputIndex
					}, usedMethodName, sourceData.previousNode));
				} catch (error$1) {
					return createResultError(error$1);
				}
			});
			if (results.every((result) => !result.ok)) throw results[0].error;
			const matchedItems = results.filter((result) => result.ok).map((result) => result.result);
			if (matchedItems.length === 0) {
				if (sourceArray.length === 0) throw createNoConnectionError(destinationNodeName);
				throw createBranchNotFoundError(sourceData.previousNode, pairedItem.item, nodeBeforeLast);
			}
			const [first$1, ...rest] = matchedItems;
			if (rest.some((r$1) => r$1 !== first$1)) throw createPairedItemMultipleItemsFound(destinationNodeName, pairedItem.item);
			return first$1;
		};
		const handleFromAi = (name, _description, _type = "string", defaultValue) => {
			const { itemIndex, runIndex } = that;
			if (!name || name === "") throw new ExpressionError("Add a key, e.g. $fromAI('placeholder_name')", {
				runIndex,
				itemIndex
			});
			if (!/^[a-zA-Z0-9_-]{0,64}$/.test(name)) throw new ExpressionError("Invalid parameter key, must be between 1 and 64 characters long and only contain lowercase letters, uppercase letters, numbers, underscores, and hyphens", {
				runIndex,
				itemIndex
			});
			const resultData = that.runExecutionData?.resultData.runData[that.activeNodeName]?.[runIndex];
			let inputData;
			let placeholdersDataInputData;
			if (!resultData) {
				inputData = this.connectionInputData?.[runIndex];
				placeholdersDataInputData = inputData.json;
			} else {
				inputData = that.runExecutionData?.resultData.runData[that.activeNodeName]?.[runIndex].inputOverride;
				placeholdersDataInputData = inputData?.[NodeConnectionTypes.AiTool]?.[0]?.[itemIndex].json;
			}
			if (!placeholdersDataInputData) throw new ExpressionError("No execution data available", {
				runIndex,
				itemIndex,
				type: "no_execution_data"
			});
			return placeholdersDataInputData?.query?.[name] ?? placeholdersDataInputData?.[name] ?? defaultValue;
		};
		const base = {
			$: (nodeName) => {
				if (!nodeName) throw createExpressionError("When calling $(), please specify a node");
				if (that.workflow.getNode(nodeName) === null) throw createExpressionError("Referenced node doesn't exist", {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
					nodeCause: nodeName,
					descriptionKey: "nodeNotFound"
				});
				const ensureNodeExecutionData = () => {
					if (!that?.runExecutionData?.resultData?.runData.hasOwnProperty(nodeName) && !getPinDataIfManualExecution(that.workflow, nodeName, that.mode)) throw createExpressionError(`Node '${nodeName}' hasn't been executed`, {
						messageTemplate: "An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $(\"{{nodeName}}\").isExecuted, <action_if_executed>, \"\") }}",
						functionality: "pairedItem",
						descriptionKey: isScriptingNode(nodeName, that.workflow) ? "pairedItemNoConnectionCodeNode" : "pairedItemNoConnection",
						type: "no_execution_data",
						nodeCause: nodeName,
						runIndex: that.runIndex,
						itemIndex: that.itemIndex
					});
				};
				return new Proxy({}, {
					has: () => true,
					ownKeys() {
						return [
							PAIRED_ITEM_METHOD.PAIRED_ITEM,
							"isExecuted",
							PAIRED_ITEM_METHOD.ITEM_MATCHING,
							PAIRED_ITEM_METHOD.ITEM,
							"first",
							"last",
							"all",
							"context",
							"params"
						];
					},
					get(target, property$2, receiver) {
						if (property$2 === "isProxy") return true;
						if (property$2 === "isExecuted") return that?.runExecutionData?.resultData?.runData.hasOwnProperty(nodeName) ?? false;
						if (property$2 === PAIRED_ITEM_METHOD.PAIRED_ITEM || property$2 === PAIRED_ITEM_METHOD.ITEM_MATCHING || property$2 === PAIRED_ITEM_METHOD.ITEM) {
							const activeNode = that.workflow.getNode(that.activeNodeName);
							let contextNode = that.contextNodeName;
							if (activeNode) contextNode = that.workflow.getParentMainInputNode(activeNode)?.name ?? contextNode;
							if (!that.workflow.getParentNodes(contextNode).includes(nodeName)) throw createNoConnectionError(nodeName);
							ensureNodeExecutionData();
							const pairedItemMethod = (itemIndex) => {
								if (itemIndex === void 0) {
									if (property$2 === PAIRED_ITEM_METHOD.ITEM_MATCHING) throw createExpressionError("Missing item index for .itemMatching()", { itemIndex });
									itemIndex = that.itemIndex;
								}
								if (!that.connectionInputData.length) {
									const pinnedData = getPinDataIfManualExecution(that.workflow, nodeName, that.mode);
									if (pinnedData) return pinnedData[itemIndex];
								}
								const input = that.connectionInputData?.[itemIndex];
								if (!input) throw createExpressionError("Can’t get data for expression", {
									messageTemplate: "Can’t get data for expression under ‘%%PARAMETER%%’ field",
									functionality: "pairedItem",
									functionOverrides: {
										description: `Some intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong>‘ have not executed yet.`,
										message: "Can’t get data"
									},
									description: `Some intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong>‘ have not executed yet.`,
									causeDetailed: `pairedItem can\'t be found when intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong> have not executed yet.`,
									itemIndex,
									type: "paired_item_intermediate_nodes"
								});
								const pairedItem = input.pairedItem;
								if (pairedItem === void 0) throw createMissingPairedItemError(that.activeNodeName, property$2);
								if (!that.executeData?.source) throw createExpressionError("Can’t get data for expression", {
									messageTemplate: "Can’t get data for expression under ‘%%PARAMETER%%’ field",
									functionality: "pairedItem",
									functionOverrides: { message: "Can’t get data" },
									description: "Apologies, this is an internal error. See details for more information",
									causeDetailed: "Missing sourceData (probably an internal error)",
									itemIndex
								});
								return getPairedItem(nodeName, that.executeData.source.main[pairedItem.input || 0] ?? that.executeData.source.main[0], pairedItem, property$2);
							};
							if (property$2 === PAIRED_ITEM_METHOD.ITEM) return pairedItemMethod();
							return pairedItemMethod;
						}
						if (property$2 === "first") {
							ensureNodeExecutionData();
							return (branchIndex, runIndex) => {
								branchIndex = branchIndex ?? that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)?.sourceIndex ?? 0;
								const executionData = that.getNodeExecutionOrPinnedData({
									nodeName,
									branchIndex,
									runIndex
								});
								if (executionData[0]) return executionData[0];
							};
						}
						if (property$2 === "last") {
							ensureNodeExecutionData();
							return (branchIndex, runIndex) => {
								branchIndex = branchIndex ?? that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)?.sourceIndex ?? 0;
								const executionData = that.getNodeExecutionOrPinnedData({
									nodeName,
									branchIndex,
									runIndex
								});
								if (!executionData.length) return void 0;
								if (executionData[executionData.length - 1]) return executionData[executionData.length - 1];
							};
						}
						if (property$2 === "all") {
							ensureNodeExecutionData();
							return (branchIndex, runIndex) => {
								branchIndex = branchIndex ?? that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)?.sourceIndex ?? 0;
								return that.getNodeExecutionOrPinnedData({
									nodeName,
									branchIndex,
									runIndex
								});
							};
						}
						if (property$2 === "context") return that.nodeContextGetter(nodeName);
						if (property$2 === "params") return that.workflow.getNode(nodeName)?.parameters;
						return Reflect.get(target, property$2, receiver);
					}
				});
			},
			$input: new Proxy({}, {
				has: () => true,
				ownKeys() {
					return [
						"all",
						"context",
						"first",
						"item",
						"last",
						"params"
					];
				},
				getOwnPropertyDescriptor() {
					return {
						enumerable: true,
						configurable: true
					};
				},
				get(target, property$2, receiver) {
					if (property$2 === "isProxy") return true;
					if (that.connectionInputData.length === 0) throw createExpressionError("No execution data available", {
						runIndex: that.runIndex,
						itemIndex: that.itemIndex,
						type: "no_execution_data"
					});
					if (property$2 === "item") return that.connectionInputData[that.itemIndex];
					if (property$2 === "first") return (...args) => {
						if (args.length) throw createExpressionError("$input.first() should have no arguments");
						const result = that.connectionInputData;
						if (result[0]) return result[0];
					};
					if (property$2 === "last") return (...args) => {
						if (args.length) throw createExpressionError("$input.last() should have no arguments");
						const result = that.connectionInputData;
						if (result.length && result[result.length - 1]) return result[result.length - 1];
					};
					if (property$2 === "all") return () => {
						const result = that.connectionInputData;
						if (result.length) return result;
						return [];
					};
					if (["context", "params"].includes(property$2)) {
						if (!that.executeData?.source) throw createExpressionError("Can’t get data for expression", {
							messageTemplate: "Can’t get data for expression under ‘%%PARAMETER%%’ field",
							functionOverrides: { message: "Can’t get data" },
							description: "Apologies, this is an internal error. See details for more information",
							causeDetailed: "Missing sourceData (probably an internal error)",
							runIndex: that.runIndex
						});
						const sourceData = that.executeData.source.main[0];
						if (property$2 === "context") return that.nodeContextGetter(sourceData.previousNode);
						if (property$2 === "params") return that.workflow.getNode(sourceData.previousNode)?.parameters;
					}
					return Reflect.get(target, property$2, receiver);
				}
			}),
			$binary: {},
			$data: {},
			$env: createEnvProvider(that.runIndex, that.itemIndex, that.envProviderState ?? createEnvProviderState()),
			$evaluateExpression: (expression, itemIndex) => {
				itemIndex = itemIndex || that.itemIndex;
				return that.workflow.expression.getParameterValue(`=${expression}`, that.runExecutionData, that.runIndex, itemIndex, that.activeNodeName, that.connectionInputData, that.mode, that.additionalKeys, that.executeData, false, {}, that.contextNodeName);
			},
			$item: (itemIndex, runIndex) => {
				const defaultReturnRunIndex = runIndex === void 0 ? -1 : runIndex;
				return new WorkflowDataProxy(this.workflow, this.runExecutionData, this.runIndex, itemIndex, this.activeNodeName, this.connectionInputData, that.siblingParameters, that.mode, that.additionalKeys, that.executeData, defaultReturnRunIndex, {}, that.contextNodeName).getDataProxy();
			},
			$fromAI: handleFromAi,
			$fromai: handleFromAi,
			$fromAi: handleFromAi,
			$items: (nodeName, outputIndex, runIndex) => {
				if (nodeName === void 0) {
					nodeName = that.prevNodeGetter().name;
					const node = this.workflow.nodes[nodeName];
					let result = that.connectionInputData;
					if (node.executeOnce === true) result = result.slice(0, 1);
					if (result.length) return result;
					return [];
				}
				outputIndex = outputIndex || 0;
				runIndex = runIndex === void 0 ? -1 : runIndex;
				return that.getNodeExecutionData(nodeName, false, outputIndex, runIndex);
			},
			$json: {},
			$node: this.nodeGetter(),
			$self: this.selfGetter(),
			$parameter: this.nodeParameterGetter(this.activeNodeName),
			$rawParameter: this.nodeParameterGetter(this.activeNodeName, false),
			$prevNode: this.prevNodeGetter(),
			$runIndex: this.runIndex,
			$mode: this.mode,
			$workflow: this.workflowGetter(),
			$itemIndex: this.itemIndex,
			$now: DateTime.now(),
			$today: DateTime.now().set({
				hour: 0,
				minute: 0,
				second: 0,
				millisecond: 0
			}),
			$jmesPath: jmespathWrapper,
			DateTime,
			Interval,
			Duration,
			...that.additionalKeys,
			$getPairedItem: getPairedItem,
			$jmespath: jmespathWrapper,
			$position: this.itemIndex,
			$thisItem: that.connectionInputData[that.itemIndex],
			$thisItemIndex: this.itemIndex,
			$thisRunIndex: this.runIndex,
			$nodeVersion: that.workflow.getNode(that.activeNodeName)?.typeVersion,
			$nodeId: that.workflow.getNode(that.activeNodeName)?.id,
			$agentInfo: this.agentInfo(),
			$webhookId: that.workflow.getNode(that.activeNodeName)?.webhookId
		};
		const throwOnMissingExecutionData = opts?.throwOnMissingExecutionData ?? true;
		return new Proxy(base, {
			has: () => true,
			get(target, name, receiver) {
				if (name === "isProxy") return true;
				if (["$data", "$json"].includes(name)) return that.nodeDataGetter(that.contextNodeName, true, throwOnMissingExecutionData)?.json;
				if (name === "$binary") return that.nodeDataGetter(that.contextNodeName, true, throwOnMissingExecutionData)?.binary;
				return Reflect.get(target, name, receiver);
			}
		});
	}
};
init_dist$1();
var IS_FRONTEND_IN_DEV_MODE = typeof process$1 === "object" && Object.keys(process$1).length === 1 && "env" in process$1 && Object.keys({}).length === 0;
var IS_FRONTEND = typeof process$1 === "undefined" || IS_FRONTEND_IN_DEV_MODE;
var isSyntaxError = (error$1) => error$1 instanceof SyntaxError || error$1 instanceof Error && error$1.name === "SyntaxError";
var isExpressionError = (error$1) => error$1 instanceof ExpressionError || error$1 instanceof ExpressionExtensionError;
var isTypeError = (error$1) => error$1 instanceof TypeError || error$1 instanceof Error && error$1.name === "TypeError";
setErrorHandler((error$1) => {
	if (isExpressionError(error$1)) throw error$1;
});
var Expression = class {
	workflow;
	constructor(workflow) {
		this.workflow = workflow;
	}
	static resolveWithoutWorkflow(expression, data = {}) {
		return evaluateExpression(expression, data);
	}
	convertObjectValueToString(value) {
		if (value instanceof DateTime && value.invalidReason !== null) throw new ApplicationError("invalid DateTime");
		if (value === null) return "null";
		let typeName = value.constructor.name ?? "Object";
		if (DateTime.isDateTime(value)) typeName = "DateTime";
		let result = "";
		if (value instanceof Date) result = DateTime.fromJSDate(value, { zone: this.workflow.settings?.timezone ?? getGlobalState().defaultTimezone }).toISO();
		else if (DateTime.isDateTime(value)) result = value.toString();
		else result = JSON.stringify(value);
		result = result.replace(/,"/g, ", \"").replace(/":/g, "\": ");
		return `[${typeName}: ${result}]`;
	}
	resolveSimpleParameterValue(parameterValue, siblingParameters, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, mode, additionalKeys, executeData, returnObjectAsString = false, selfData = {}, contextNodeName) {
		if (!isExpression(parameterValue)) return parameterValue;
		parameterValue = parameterValue.substr(1);
		const data = new WorkflowDataProxy(this.workflow, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, siblingParameters, mode, additionalKeys, executeData, -1, selfData, contextNodeName).getDataProxy();
		data.process = typeof process$1 !== "undefined" ? {
			arch: process$1.arch,
			env: {}.N8N_BLOCK_ENV_ACCESS_IN_NODE === "true" ? {} : {},
			platform: process$1.platform,
			pid: process$1.pid,
			ppid: process$1.ppid,
			release: process$1.release,
			version: process$1.pid,
			versions: process$1.versions
		} : {};
		data.document = {};
		data.global = {};
		data.window = {};
		data.Window = {};
		data.this = {};
		data.globalThis = {};
		data.self = {};
		data.alert = {};
		data.prompt = {};
		data.confirm = {};
		data.eval = {};
		data.uneval = {};
		data.setTimeout = {};
		data.setInterval = {};
		data.Function = {};
		data.fetch = {};
		data.XMLHttpRequest = {};
		data.Promise = {};
		data.Generator = {};
		data.GeneratorFunction = {};
		data.AsyncFunction = {};
		data.AsyncGenerator = {};
		data.AsyncGeneratorFunction = {};
		data.WebAssembly = {};
		data.Reflect = {};
		data.Proxy = {};
		data.escape = {};
		data.unescape = {};
		data.Date = Date;
		data.DateTime = DateTime;
		data.Interval = Interval;
		data.Duration = Duration;
		data.Object = Object;
		data.Array = Array;
		data.Int8Array = Int8Array;
		data.Uint8Array = Uint8Array;
		data.Uint8ClampedArray = Uint8ClampedArray;
		data.Int16Array = Int16Array;
		data.Uint16Array = Uint16Array;
		data.Int32Array = Int32Array;
		data.Uint32Array = Uint32Array;
		data.Float32Array = Float32Array;
		data.Float64Array = Float64Array;
		data.BigInt64Array = typeof BigInt64Array !== "undefined" ? BigInt64Array : {};
		data.BigUint64Array = typeof BigUint64Array !== "undefined" ? BigUint64Array : {};
		data.Map = typeof Map !== "undefined" ? Map : {};
		data.WeakMap = typeof WeakMap !== "undefined" ? WeakMap : {};
		data.Set = typeof Set !== "undefined" ? Set : {};
		data.WeakSet = typeof WeakSet !== "undefined" ? WeakSet : {};
		data.Error = Error;
		data.TypeError = TypeError;
		data.SyntaxError = SyntaxError;
		data.EvalError = EvalError;
		data.RangeError = RangeError;
		data.ReferenceError = ReferenceError;
		data.URIError = URIError;
		data.Intl = typeof Intl !== "undefined" ? Intl : {};
		data.String = String;
		data.RegExp = RegExp;
		data.Math = Math;
		data.Number = Number;
		data.BigInt = typeof BigInt !== "undefined" ? BigInt : {};
		data.Infinity = Infinity;
		data.NaN = NaN;
		data.isFinite = Number.isFinite;
		data.isNaN = Number.isNaN;
		data.parseFloat = parseFloat;
		data.parseInt = parseInt;
		data.JSON = JSON;
		data.ArrayBuffer = typeof ArrayBuffer !== "undefined" ? ArrayBuffer : {};
		data.SharedArrayBuffer = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : {};
		data.Atomics = typeof Atomics !== "undefined" ? Atomics : {};
		data.DataView = typeof DataView !== "undefined" ? DataView : {};
		data.encodeURI = encodeURI;
		data.encodeURIComponent = encodeURIComponent;
		data.decodeURI = decodeURI;
		data.decodeURIComponent = decodeURIComponent;
		data.Boolean = Boolean;
		data.Symbol = Symbol;
		data.extend = extend;
		data.extendOptional = extendOptional;
		data[sanitizerName] = sanitizer;
		Object.assign(data, extendedFunctions);
		const constructorValidation = /* @__PURE__ */ new RegExp(/\.\s*constructor/gm);
		if (parameterValue.match(constructorValidation)) throw new ExpressionError("Expression contains invalid constructor function call", {
			causeDetailed: "Constructor override attempt is not allowed due to security concerns",
			runIndex,
			itemIndex
		});
		const extendedExpression = extendSyntax(parameterValue);
		const returnValue = this.renderExpression(extendedExpression, data);
		if (typeof returnValue === "function") {
			if (returnValue.name === "DateTime") throw new ApplicationError("this is a DateTime, please access its methods");
			throw new ApplicationError("this is a function, please add ()");
		} else if (typeof returnValue === "string") return returnValue;
		else if (returnValue !== null && typeof returnValue === "object") {
			if (returnObjectAsString) return this.convertObjectValueToString(returnValue);
		}
		return returnValue;
	}
	renderExpression(expression, data) {
		try {
			return evaluateExpression(expression, data);
		} catch (error$1) {
			if (isExpressionError(error$1)) throw error$1;
			if (isSyntaxError(error$1)) throw new ApplicationError("invalid syntax");
			if (isTypeError(error$1) && IS_FRONTEND && error$1.message.endsWith("is not a function")) {
				const match$1 = error$1.message.match(/(?<msg>[^.]+is not a function)/);
				if (!match$1?.groups?.msg) return null;
				throw new ApplicationError(match$1.groups.msg);
			}
		}
		return null;
	}
	getSimpleParameterValue(node, parameterValue, mode, additionalKeys, executeData, defaultValue) {
		if (parameterValue === void 0) return defaultValue;
		return this.getParameterValue(parameterValue, { resultData: { runData: {} } }, 0, 0, node.name, [], mode, additionalKeys, executeData);
	}
	getComplexParameterValue(node, parameterValue, mode, additionalKeys, executeData, defaultValue = void 0, selfData = {}) {
		if (parameterValue === void 0) return defaultValue;
		const runIndex = 0;
		const itemIndex = 0;
		const connectionInputData = [];
		const runData = { resultData: { runData: {} } };
		const returnData = this.getParameterValue(parameterValue, runData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys, executeData, false, selfData);
		return this.getParameterValue(returnData, runData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys, executeData, false, selfData);
	}
	getParameterValue(parameterValue, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, mode, additionalKeys, executeData, returnObjectAsString = false, selfData = {}, contextNodeName) {
		const isComplexParameter = (value) => {
			return typeof value === "object";
		};
		const resolveParameterValue = (value, siblingParameters) => {
			if (isComplexParameter(value)) return this.getParameterValue(value, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, mode, additionalKeys, executeData, returnObjectAsString, selfData, contextNodeName);
			return this.resolveSimpleParameterValue(value, siblingParameters, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, mode, additionalKeys, executeData, returnObjectAsString, selfData, contextNodeName);
		};
		if (!isComplexParameter(parameterValue)) return this.resolveSimpleParameterValue(parameterValue, {}, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, mode, additionalKeys, executeData, returnObjectAsString, selfData, contextNodeName);
		if (Array.isArray(parameterValue)) return parameterValue.map((item) => resolveParameterValue(item, {}));
		if (parameterValue === null || parameterValue === void 0) return parameterValue;
		if (typeof parameterValue !== "object") return {};
		const returnData = {};
		for (const [key, value] of Object.entries(parameterValue)) returnData[key] = resolveParameterValue(value, parameterValue);
		if (returnObjectAsString && typeof returnData === "object") return this.convertObjectValueToString(returnData);
		return returnData;
	}
};
var util;
(function(util$10) {
	util$10.assertEqual = (_$1) => {};
	function assertIs(_arg) {}
	util$10.assertIs = assertIs;
	function assertNever$1(_x) {
		throw new Error();
	}
	util$10.assertNever = assertNever$1;
	util$10.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) obj[item] = item;
		return obj;
	};
	util$10.getValidEnumValues = (obj) => {
		const validKeys = util$10.objectKeys(obj).filter((k$1) => typeof obj[obj[k$1]] !== "number");
		const filtered = {};
		for (const k$1 of validKeys) filtered[k$1] = obj[k$1];
		return util$10.objectValues(filtered);
	};
	util$10.objectValues = (obj) => {
		return util$10.objectKeys(obj).map(function(e$1) {
			return obj[e$1];
		});
	};
	util$10.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
		const keys$9 = [];
		for (const key in object) if (Object.prototype.hasOwnProperty.call(object, key)) keys$9.push(key);
		return keys$9;
	};
	util$10.find = (arr, checker) => {
		for (const item of arr) if (checker(item)) return item;
	};
	util$10.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$10.joinValues = joinValues;
	util$10.jsonStringifyReplacer = (_$1, value) => {
		if (typeof value === "bigint") return value.toString();
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first$1, second) => {
		return {
			...first$1,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
const getParsedType = (data) => {
	switch (typeof data) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data)) return ZodParsedType.array;
			if (data === null) return ZodParsedType.null;
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
			if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
			if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
			if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};
const ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
var ZodError = class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		this.name = "ZodError";
		this.issues = issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue) {
			return issue.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error$1) => {
			for (const issue of error$1.issues) if (issue.code === "invalid_union") issue.unionErrors.map(processError);
			else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
			else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
			else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
			else {
				let curr = fieldErrors;
				let i$2 = 0;
				while (i$2 < issue.path.length) {
					const el = issue.path[i$2];
					if (!(i$2 === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue));
					}
					curr = curr[el];
					i$2++;
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) if (sub.path.length > 0) {
			fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
			fieldErrors[sub.path[0]].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	return new ZodError(issues);
};
var errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) message = "Required";
			else message = `Expected ${issue.expected}, received ${issue.received}`;
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") if ("includes" in issue.validation) {
				message = `Invalid input: must include "${issue.validation.includes}"`;
				if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
			} else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
			else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
			else util.assertNever(issue.validation);
			else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
			else message = "Invalid";
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue);
	}
	return { message };
};
var en_default = errorMap;
var overrideErrorMap = en_default;
function getErrorMap() {
	return overrideErrorMap;
}
const makeIssue = (params) => {
	const { data, path, errorMaps, issueData } = params;
	const fullPath = [...path, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	if (issueData.message !== void 0) return {
		...issueData,
		path: fullPath,
		message: issueData.message
	};
	let errorMessage = "";
	const maps = errorMaps.filter((m$1) => !!m$1).slice().reverse();
	for (const map of maps) errorMessage = map(fullIssue, {
		data,
		defaultError: errorMessage
	}).message;
	return {
		...issueData,
		path: fullPath,
		message: errorMessage
	};
};
function addIssueToContext(ctx, issueData) {
	const overrideMap = getErrorMap();
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			overrideMap,
			overrideMap === en_default ? void 0 : en_default
		].filter((x$1) => !!x$1)
	});
	ctx.common.issues.push(issue);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		const arrayValue = [];
		for (const s$2 of results) {
			if (s$2.status === "aborted") return INVALID;
			if (s$2.status === "dirty") status.dirty();
			arrayValue.push(s$2.value);
		}
		return {
			status: status.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status, pairs) {
		const syncPairs = [];
		for (const pair of pairs) {
			const key = await pair.key;
			const value = await pair.value;
			syncPairs.push({
				key,
				value
			});
		}
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
		}
		return {
			status: status.value,
			value: finalObject
		};
	}
};
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({
	status: "dirty",
	value
});
const OK = (value) => ({
	status: "valid",
	value
});
const isAborted = (x$1) => x$1.status === "aborted";
const isDirty = (x$1) => x$1.status === "dirty";
const isValid = (x$1) => x$1.status === "valid";
const isAsync = (x$1) => typeof Promise !== "undefined" && x$1 instanceof Promise;
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
	constructor(parent, value, path, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
		else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
};
var handleResult = (ctx, result) => {
	if (isValid(result)) return {
		success: true,
		data: result.value
	};
	else {
		if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				this._error = new ZodError(ctx.common.issues);
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		const { message } = params;
		if (iss.code === "invalid_enum_value") return { message: message ?? ctx.defaultError };
		if (typeof ctx.data === "undefined") return { message: message ?? required_error ?? ctx.defaultError };
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		return { message: message ?? invalid_type_error ?? ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		const result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		const ctx = {
			common: {
				issues: [],
				async: params?.async ?? false,
				contextualErrorMap: params?.errorMap
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		return handleResult(ctx, this._parseSync({
			data,
			path: ctx.path,
			parent: ctx
		}));
	}
	"~validate"(data) {
		const ctx = {
			common: {
				issues: [],
				async: !!this["~standard"].async
			},
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		if (!this["~standard"].async) try {
			const result = this._parseSync({
				data,
				path: [],
				parent: ctx
			});
			return isValid(result) ? { value: result.value } : { issues: ctx.common.issues };
		} catch (err) {
			if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
			ctx.common = {
				issues: [],
				async: true
			};
		}
		return this._parseAsync({
			data,
			path: [],
			parent: ctx
		}).then((result) => isValid(result) ? { value: result.value } : { issues: ctx.common.issues });
	}
	async parseAsync(data, params) {
		const result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params?.errorMap,
				async: true
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const maybeAsyncResult = this._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult)));
	}
	refine(check, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			const result = check(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data) => {
				if (!data) {
					setError();
					return false;
				} else return true;
			});
			if (!result) {
				setError();
				return false;
			} else return true;
		});
	}
	refinement(check, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else return true;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
		this["~standard"] = {
			version: 1,
			vendor: "zod",
			validate: (data) => this["~validate"](data)
		};
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = /* @__PURE__ */ new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let secondsRegexSource = `[0-5]\\d`;
	if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	const secondsQuantifier = args.precision ? "+" : "?";
	return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
	return /* @__PURE__ */ new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	const opts = [];
	opts.push(args.local ? `Z?` : `Z`);
	if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
	regex = `${regex}(${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
	if ((version === "v4" || !version) && ipv4Regex.test(ip)) return true;
	if ((version === "v6" || !version) && ipv6Regex.test(ip)) return true;
	return false;
}
function isValidJWT(jwt, alg) {
	if (!jwtRegex.test(jwt)) return false;
	try {
		const [header] = jwt.split(".");
		const base64$2 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
		const decoded = JSON.parse(atob(base64$2));
		if (typeof decoded !== "object" || decoded === null) return false;
		if ("typ" in decoded && decoded?.typ !== "JWT") return false;
		if (!decoded.alg) return false;
		if (alg && decoded.alg !== alg) return false;
		return true;
	} catch {
		return false;
	}
}
function isValidCidr(ip, version) {
	if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return true;
	if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return true;
	return false;
}
var ZodString = class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.length < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.length > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "length") {
			const tooBig = input.data.length > check.value;
			const tooSmall = input.data.length < check.value;
			if (tooBig || tooSmall) {
				ctx = this._getOrReturnCtx(input, ctx);
				if (tooBig) addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				else if (tooSmall) addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "email") {
			if (!emailRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "email",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "emoji") {
			if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
			if (!emojiRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "emoji",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "uuid") {
			if (!uuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "uuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "nanoid") {
			if (!nanoidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "nanoid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid") {
			if (!cuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid2") {
			if (!cuid2Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid2",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ulid") {
			if (!ulidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ulid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "url") try {
			new URL(input.data);
		} catch {
			ctx = this._getOrReturnCtx(input, ctx);
			addIssueToContext(ctx, {
				validation: "url",
				code: ZodIssueCode.invalid_string,
				message: check.message
			});
			status.dirty();
		}
		else if (check.kind === "regex") {
			check.regex.lastIndex = 0;
			if (!check.regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "regex",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "trim") input.data = input.data.trim();
		else if (check.kind === "includes") {
			if (!input.data.includes(check.value, check.position)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: {
						includes: check.value,
						position: check.position
					},
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
		else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
		else if (check.kind === "startsWith") {
			if (!input.data.startsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { startsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "endsWith") {
			if (!input.data.endsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { endsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "datetime") {
			if (!datetimeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "datetime",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "date") {
			if (!dateRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "date",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "time") {
			if (!timeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "time",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "duration") {
			if (!durationRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "duration",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ip") {
			if (!isValidIP(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ip",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "jwt") {
			if (!isValidJWT(input.data, check.alg)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "jwt",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cidr") {
			if (!isValidCidr(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cidr",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "base64") {
			if (!base64Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "base64url") {
			if (!base64urlRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64url",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_regex(regex, validation, message) {
		return this.refinement((data) => regex.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
	}
	_addCheck(check) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	nanoid(message) {
		return this._addCheck({
			kind: "nanoid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	base64(message) {
		return this._addCheck({
			kind: "base64",
			...errorUtil.errToObj(message)
		});
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message)
		});
	}
	jwt(options) {
		return this._addCheck({
			kind: "jwt",
			...errorUtil.errToObj(options)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	cidr(options) {
		return this._addCheck({
			kind: "cidr",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "datetime",
			precision: null,
			offset: false,
			local: false,
			message: options
		});
		return this._addCheck({
			kind: "datetime",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			offset: options?.offset ?? false,
			local: options?.local ?? false,
			...errorUtil.errToObj(options?.message)
		});
	}
	date(message) {
		return this._addCheck({
			kind: "date",
			message
		});
	}
	time(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "time",
			precision: null,
			message: options
		});
		return this._addCheck({
			kind: "time",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			...errorUtil.errToObj(options?.message)
		});
	}
	duration(message) {
		return this._addCheck({
			kind: "duration",
			...errorUtil.errToObj(message)
		});
	}
	regex(regex, message) {
		return this._addCheck({
			kind: "regex",
			regex,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options?.position,
			...errorUtil.errToObj(options?.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength$1, message) {
		return this._addCheck({
			kind: "min",
			value: minLength$1,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength$1, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength$1,
			...errorUtil.errToObj(message)
		});
	}
	length(len$1, message) {
		return this._addCheck({
			kind: "length",
			value: len$1,
			...errorUtil.errToObj(message)
		});
	}
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min$2 === null || ch.value > min$2) min$2 = ch.value;
		}
		return min$2;
	}
	get maxLength() {
		let max$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max$2 === null || ch.value < max$2) max$2 = ch.value;
		}
		return max$2;
	}
};
ZodString.create = (params) => {
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "int") {
			if (!util.isInteger(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: "integer",
					received: "float",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (floatSafeRemainder(input.data, check.value) !== 0) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "finite") {
			if (!Number.isFinite(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_finite,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min$2 === null || ch.value > min$2) min$2 = ch.value;
		}
		return min$2;
	}
	get maxValue() {
		let max$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max$2 === null || ch.value < max$2) max$2 = ch.value;
		}
		return max$2;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
	}
	get isFinite() {
		let max$2 = null;
		let min$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
		else if (ch.kind === "min") {
			if (min$2 === null || ch.value > min$2) min$2 = ch.value;
		} else if (ch.kind === "max") {
			if (max$2 === null || ch.value < max$2) max$2 = ch.value;
		}
		return Number.isFinite(min$2) && Number.isFinite(max$2);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) try {
			input.data = BigInt(input.data);
		} catch {
			return this._getInvalidInput(input);
		}
		if (this._getType(input) !== ZodParsedType.bigint) return this._getInvalidInput(input);
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					type: "bigint",
					minimum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					type: "bigint",
					maximum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (input.data % check.value !== BigInt(0)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_getInvalidInput(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.bigint,
			received: ctx.parsedType
		});
		return INVALID;
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min$2 === null || ch.value > min$2) min$2 = ch.value;
		}
		return min$2;
	}
	get maxValue() {
		let max$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max$2 === null || ch.value < max$2) max$2 = ch.value;
		}
		return max$2;
	}
};
ZodBigInt.create = (params) => {
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (Number.isNaN(input.data.getTime())) {
			addIssueToContext(this._getOrReturnCtx(input), { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.getTime() < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					message: check.message,
					inclusive: true,
					exact: false,
					minimum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.getTime() > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					message: check.message,
					inclusive: true,
					exact: false,
					maximum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min$2 === null || ch.value > min$2) min$2 = ch.value;
		}
		return min$2 != null ? new Date(min$2) : null;
	}
	get maxDate() {
		let max$2 = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max$2 === null || ch.value < max$2) max$2 = ch.value;
		}
		return max$2 != null ? new Date(max$2) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: params?.coerce || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status.dirty();
			}
		}
		if (ctx.common.async) return Promise.all([...ctx.data].map((item, i$2) => {
			return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i$2));
		})).then((result$1) => {
			return ParseStatus.mergeArray(status, result$1);
		});
		const result = [...ctx.data].map((item, i$2) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i$2));
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength$1, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength$1,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength$1, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength$1,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len$1, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len$1,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) return new ZodArray({
		...schema._def,
		type: deepPartialify(schema.element)
	});
	else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		this.nonstrict = this.passthrough;
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		this._cached = {
			shape,
			keys: util.objectKeys(shape)
		};
		return this._cached;
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) if (!shapeKeys.includes(key)) extraKeys.push(key);
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") for (const key of extraKeys) pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: {
					status: "valid",
					value: ctx.data[key]
				}
			});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status.dirty();
				}
			} else if (unknownKeys === "strip") {} else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
		} else {
			const catchall = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: {
						status: "valid",
						value: key
					},
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data
				});
			}
		}
		if (ctx.common.async) return Promise.resolve().then(async () => {
			const syncPairs = [];
			for (const pair of pairs) {
				const key = await pair.key;
				const value = await pair.value;
				syncPairs.push({
					key,
					value,
					alwaysSet: pair.alwaysSet
				});
			}
			return syncPairs;
		}).then((syncPairs) => {
			return ParseStatus.mergeObjectSync(status, syncPairs);
		});
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== void 0 ? { errorMap: (issue, ctx) => {
				const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
				if (issue.code === "unrecognized_keys") return { message: errorUtil.errToObj(message).message ?? defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		for (const key of util.objectKeys(mask)) if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		for (const key of util.objectKeys(this.shape)) if (!mask[key]) shape[key] = this.shape[key];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) newShape[key] = fieldSchema;
			else newShape[key] = fieldSchema.optional();
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) if (mask && !mask[key]) newShape[key] = this.shape[key];
		else {
			let newField = this.shape[key];
			while (newField instanceof ZodOptional) newField = newField._def.innerType;
			newShape[key] = newField;
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) if (result.result.status === "valid") return result.result;
			for (const result of results) if (result.result.status === "dirty") {
				ctx.common.issues.push(...result.ctx.common.issues);
				return result.result;
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) return Promise.all(options.map(async (option) => {
			const childCtx = {
				...ctx,
				common: {
					...ctx.common,
					issues: []
				},
				parent: null
			};
			return {
				result: await option._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				}),
				ctx: childCtx
			};
		})).then(handleResults);
		else {
			let dirty = void 0;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty) dirty = {
					result,
					ctx: childCtx
				};
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types$8, params) => {
	return new ZodUnion({
		options: types$8,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
var getDiscriminator = (type) => {
	if (type instanceof ZodLazy) return getDiscriminator(type.schema);
	else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
	else if (type instanceof ZodLiteral) return [type.value];
	else if (type instanceof ZodEnum) return type.options;
	else if (type instanceof ZodNativeEnum) return util.objectValues(type.enum);
	else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
	else if (type instanceof ZodUndefined) return [void 0];
	else if (type instanceof ZodNull) return [null];
	else if (type instanceof ZodOptional) return [void 0, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodNullable) return [null, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
	else return [];
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) return option._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
		else return option._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	static create(discriminator, options, params) {
		const optionsMap = /* @__PURE__ */ new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a$1, b$5) {
	const aType = getParsedType(a$1);
	const bType = getParsedType(b$5);
	if (a$1 === b$5) return {
		valid: true,
		data: a$1
	};
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b$5);
		const sharedKeys = util.objectKeys(a$1).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a$1,
			...b$5
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a$1[key], b$5[key]);
			if (!sharedValue.valid) return { valid: false };
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a$1.length !== b$5.length) return { valid: false };
		const newArray = [];
		for (let index = 0; index < a$1.length; index++) {
			const itemA = a$1[index];
			const itemB = b$5[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: false };
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a$1 === +b$5) return {
		valid: true,
		data: a$1
	};
	else return { valid: false };
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
			return {
				status: status.value,
				value: merged.data
			};
		};
		if (ctx.common.async) return Promise.all([this._def.left._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		})]).then(([left, right]) => handleParsed(left, right));
		else return handleParsed(this._def.left._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}));
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		if (!this._def.rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x$1) => !!x$1);
		if (ctx.common.async) return Promise.all(items).then((results) => {
			return ParseStatus.mergeArray(status, results);
		});
		else return ParseStatus.mergeArray(status, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) pairs.push({
			key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
			value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
			alwaysSet: key in ctx.data
		});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first$1, second, third) {
		if (second instanceof ZodType) return new ZodRecord({
			keyType: first$1,
			valueType: second,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(third)
		});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first$1,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = /* @__PURE__ */ new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") return INVALID;
					if (key.status === "dirty" || value.status === "dirty") status.dirty();
					finalMap.set(key.value, value.value);
				}
				return {
					status: status.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = /* @__PURE__ */ new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") return INVALID;
				if (key.status === "dirty" || value.status === "dirty") status.dirty();
				finalMap.set(key.value, value.value);
			}
			return {
				status: status.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = /* @__PURE__ */ new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i$2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i$2)));
		if (ctx.common.async) return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error$1) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x$1) => !!x$1),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error$1
				}
			});
		}
		function makeReturnsIssue(returns, error$1) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x$1) => !!x$1),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error$1
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn$1 = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function(...args) {
				const error$1 = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e$1) => {
					error$1.addIssue(makeArgsIssue(args, e$1));
					throw error$1;
				});
				const result = await Reflect.apply(fn$1, this, parsedArgs);
				return await me._def.returns._def.type.parseAsync(result, params).catch((e$1) => {
					error$1.addIssue(makeReturnsIssue(result, e$1));
					throw error$1;
				});
			});
		} else {
			const me = this;
			return OK(function(...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				const result = Reflect.apply(fn$1, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		return this._def.getter()._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values$1, params) {
	return new ZodEnum({
		values: values$1,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(this._def.values);
		if (!this._cache.has(input.data)) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values$1, newDef = this._def) {
		return ZodEnum.create(values$1, {
			...this._def,
			...newDef
		});
	}
	exclude(values$1, newDef = this._def) {
		return ZodEnum.create(this.options.filter((opt) => !values$1.includes(opt)), {
			...this._def,
			...newDef
		});
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(util.getValidEnumValues(this._def.values));
		if (!this._cache.has(input.data)) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values$1, params) => {
	return new ZodNativeEnum({
		values: values$1,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK((ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data)).then((data) => {
			return this._def.type.parseAsync(data, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) status.abort();
				else status.dirty();
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async) return Promise.resolve(processed).then(async (processed$1) => {
				if (status.value === "aborted") return INVALID;
				const result = await this._def.schema._parseAsync({
					data: processed$1,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			});
			else {
				if (status.value === "aborted") return INVALID;
				const result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				executeRefinement(inner.value);
				return {
					status: status.value,
					value: inner.value
				};
			} else return this._def.schema._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}).then((inner) => {
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				return executeRefinement(inner.value).then(() => {
					return {
						status: status.value,
						value: inner.value
					};
				});
			});
		}
		if (effect.type === "transform") if (ctx.common.async === false) {
			const base = this._def.schema._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (!isValid(base)) return INVALID;
			const result = effect.transform(base.value, checkCtx);
			if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
			return {
				status: status.value,
				value: result
			};
		} else return this._def.schema._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}).then((base) => {
			if (!isValid(base)) return INVALID;
			return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
				status: status.value,
				value: result
			}));
		});
		util.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
		return this._def.innerType._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) return result.then((result$1) => {
			return {
				status: "valid",
				value: result$1.status === "valid" ? result$1.value : this._def.catchValue({
					get error() {
						return new ZodError(newCtx.common.issues);
					},
					input: newCtx.data
				})
			};
		});
		else return {
			status: "valid",
			value: result.status === "valid" ? result.value : this._def.catchValue({
				get error() {
					return new ZodError(newCtx.common.issues);
				},
				input: newCtx.data
			})
		};
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data = ctx.data;
		return this._def.type._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status.dirty();
					return DIRTY(inResult.value);
				} else return this._def.out._parseAsync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else return this._def.out._parseSync({
				data: inResult.value,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	static create(a$1, b$5) {
		return new ZodPipeline({
			in: a$1,
			out: b$5,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var ZodReadonly = class extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		const freeze = (data) => {
			if (isValid(data)) data.value = Object.freeze(data.value);
			return data;
		};
		return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate;
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {
	ZodFirstPartyTypeKind$1["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$1["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$1["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$1["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$1["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$1["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$1["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$1["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$1["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$1["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$1["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$1["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$1["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$1["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$1["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$1["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$1["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$1["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$1["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$1["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$1["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$1["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$1["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$1["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$1["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$1["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$1["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$1["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$1["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$1["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$1["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$1["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$1["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$1["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$1["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind$1["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
ZodNaN.create;
ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
ZodSymbol.create;
ZodUndefined.create;
var nullType = ZodNull.create;
ZodAny.create;
ZodUnknown.create;
ZodNever.create;
ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
ZodObject.strictCreate;
var unionType = ZodUnion.create;
ZodDiscriminatedUnion.create;
ZodIntersection.create;
ZodTuple.create;
var recordType = ZodRecord.create;
ZodMap.create;
ZodSet.create;
ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
ZodNativeEnum.create;
ZodPromise.create;
ZodEffects.create;
ZodOptional.create;
ZodNullable.create;
ZodEffects.createWithPreprocess;
ZodPipeline.create;
const NEVER = INVALID;
var ParseError = class extends Error {};
function isFromAIArgumentType(value) {
	return [
		"string",
		"number",
		"boolean",
		"json"
	].includes(value.toLowerCase());
}
function parseDefaultValue(value, type = "string") {
	if (value === void 0) return value;
	const lowerValue = value.toLowerCase();
	if (type === "string") return value.toString();
	if (type === "boolean" && (lowerValue === "true" || lowerValue === "false")) return lowerValue === "true";
	if (type === "number" && !isNaN(Number(value))) return Number(value);
	try {
		return jsonParse(value);
	} catch {
		return value;
	}
}
function parseArguments(argsString) {
	const args = [];
	let currentArg = "";
	let inQuotes = false;
	let quoteChar = "";
	let escapeNext = false;
	for (let i$2 = 0; i$2 < argsString.length; i$2++) {
		const char = argsString[i$2];
		if (escapeNext) {
			currentArg += char;
			escapeNext = false;
			continue;
		}
		if (char === "\\") {
			escapeNext = true;
			continue;
		}
		if ([
			"\"",
			"'",
			"`"
		].includes(char)) {
			if (!inQuotes) {
				inQuotes = true;
				quoteChar = char;
				currentArg += char;
			} else if (char === quoteChar) {
				inQuotes = false;
				quoteChar = "";
				currentArg += char;
			} else currentArg += char;
			continue;
		}
		if (char === "," && !inQuotes) {
			args.push(currentArg.trim());
			currentArg = "";
			continue;
		}
		currentArg += char;
	}
	if (currentArg) args.push(currentArg.trim());
	const cleanArgs = args.map((arg) => {
		const trimmed = arg.trim();
		if (trimmed.startsWith("'") && trimmed.endsWith("'") || trimmed.startsWith("`") && trimmed.endsWith("`") || trimmed.startsWith("\"") && trimmed.endsWith("\"")) return trimmed.slice(1, -1).replace(/\\'/g, "'").replace(/\\`/g, "`").replace(/\\"/g, "\"").replace(/\\\\/g, "\\");
		return trimmed;
	});
	const type = cleanArgs?.[2] ?? "string";
	if (!isFromAIArgumentType(type)) throw new ParseError(`Invalid type: ${type}`);
	return {
		key: cleanArgs[0] || "",
		description: cleanArgs[1],
		type,
		defaultValue: parseDefaultValue(cleanArgs[3], type)
	};
}
function extractFromAICalls(str) {
	const args = [];
	const pattern = /\$fromAI\s*\(\s*/gi;
	let match$1;
	while ((match$1 = pattern.exec(str)) !== null) {
		const startIndex = match$1.index + match$1[0].length;
		let current = startIndex;
		let inQuotes = false;
		let quoteChar = "";
		let parenthesesCount = 1;
		let argsString = "";
		while (current < str.length && parenthesesCount > 0) {
			const char = str[current];
			if (inQuotes) {
				if (char === "\\" && current + 1 < str.length) {
					argsString += char + str[current + 1];
					current += 2;
					continue;
				}
				if (char === quoteChar) {
					inQuotes = false;
					quoteChar = "";
				}
				argsString += char;
			} else {
				if ([
					"\"",
					"'",
					"`"
				].includes(char)) {
					inQuotes = true;
					quoteChar = char;
				} else if (char === "(") parenthesesCount++;
				else if (char === ")") parenthesesCount--;
				if (parenthesesCount > 0 || char !== ")") argsString += char;
			}
			current++;
		}
		if (parenthesesCount === 0) try {
			const parsedArgs = parseArguments(argsString);
			args.push(parsedArgs);
		} catch (error$1) {
			throw new ParseError(`Failed to parse $fromAI arguments: ${argsString}: ${String(error$1)}`);
		}
		else throw new ParseError(`Unbalanced parentheses while parsing $fromAI call: ${str.slice(startIndex)}`);
	}
	return args;
}
function traverseNodeParameters(payload, collectedArgs) {
	if (typeof payload === "string") extractFromAICalls(payload).forEach((call$1) => collectedArgs.push(call$1));
	else if (Array.isArray(payload)) payload.forEach((item) => traverseNodeParameters(item, collectedArgs));
	else if (typeof payload === "object" && payload !== null) Object.values(payload).forEach((value) => traverseNodeParameters(value, collectedArgs));
}
var require__arrayEach = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayEach$1(array, iteratee) {
		var index = -1, length$1 = array == null ? 0 : array.length;
		while (++index < length$1) if (iteratee(array[index], index, array) === false) break;
		return array;
	}
	module.exports = arrayEach$1;
}));
var require__baseAssign = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var copyObject$3 = require__copyObject(), keys$3 = require_keys();
	function baseAssign$1(object, source) {
		return object && copyObject$3(source, keys$3(source), object);
	}
	module.exports = baseAssign$1;
}));
var require__baseAssignIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var copyObject$2 = require__copyObject(), keysIn$2 = require_keysIn();
	function baseAssignIn$1(object, source) {
		return object && copyObject$2(source, keysIn$2(source), object);
	}
	module.exports = baseAssignIn$1;
}));
var require__copySymbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var copyObject$1 = require__copyObject(), getSymbols$1 = require__getSymbols();
	function copySymbols$1(source, object) {
		return copyObject$1(source, getSymbols$1(source), object);
	}
	module.exports = copySymbols$1;
}));
var require__getSymbolsIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush = require__arrayPush(), getPrototype = require__getPrototype(), getSymbols = require__getSymbols(), stubArray = require_stubArray();
	module.exports = !Object.getOwnPropertySymbols ? stubArray : function(object) {
		var result = [];
		while (object) {
			arrayPush(result, getSymbols(object));
			object = getPrototype(object);
		}
		return result;
	};
}));
var require__copySymbolsIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var copyObject = require__copyObject(), getSymbolsIn$1 = require__getSymbolsIn();
	function copySymbolsIn$1(source, object) {
		return copyObject(source, getSymbolsIn$1(source), object);
	}
	module.exports = copySymbolsIn$1;
}));
var require__getAllKeysIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetAllKeys = require__baseGetAllKeys(), getSymbolsIn = require__getSymbolsIn(), keysIn$1 = require_keysIn();
	function getAllKeysIn$1(object) {
		return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
	}
	module.exports = getAllKeysIn$1;
}));
var require__initCloneArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	function initCloneArray$1(array) {
		var length$1 = array.length, result = new array.constructor(length$1);
		if (length$1 && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
			result.index = array.index;
			result.input = array.input;
		}
		return result;
	}
	module.exports = initCloneArray$1;
}));
var require__cloneDataView = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var cloneArrayBuffer$1 = require__cloneArrayBuffer();
	function cloneDataView$1(dataView, isDeep) {
		var buffer$1 = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
		return new dataView.constructor(buffer$1, dataView.byteOffset, dataView.byteLength);
	}
	module.exports = cloneDataView$1;
}));
var require__cloneRegExp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reFlags = /\w*$/;
	function cloneRegExp$1(regexp) {
		var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		result.lastIndex = regexp.lastIndex;
		return result;
	}
	module.exports = cloneRegExp$1;
}));
var require__cloneSymbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$1 = require__Symbol();
	var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
	function cloneSymbol$1(symbol) {
		return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}
	module.exports = cloneSymbol$1;
}));
var require__initCloneByTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var cloneArrayBuffer = require__cloneArrayBuffer(), cloneDataView = require__cloneDataView(), cloneRegExp = require__cloneRegExp(), cloneSymbol = require__cloneSymbol(), cloneTypedArray = require__cloneTypedArray();
	var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
	var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
	function initCloneByTag$1(object, tag, isDeep) {
		var Ctor = object.constructor;
		switch (tag) {
			case arrayBufferTag$1: return cloneArrayBuffer(object);
			case boolTag$1:
			case dateTag$1: return new Ctor(+object);
			case dataViewTag$1: return cloneDataView(object, isDeep);
			case float32Tag$1:
			case float64Tag$1:
			case int8Tag$1:
			case int16Tag$1:
			case int32Tag$1:
			case uint8Tag$1:
			case uint8ClampedTag$1:
			case uint16Tag$1:
			case uint32Tag$1: return cloneTypedArray(object, isDeep);
			case mapTag$2: return new Ctor();
			case numberTag$1:
			case stringTag$1: return new Ctor(object);
			case regexpTag$1: return cloneRegExp(object);
			case setTag$2: return new Ctor();
			case symbolTag$1: return cloneSymbol(object);
		}
	}
	module.exports = initCloneByTag$1;
}));
var require__baseIsMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getTag$2 = require__getTag(), isObjectLike$1 = require_isObjectLike();
	var mapTag$1 = "[object Map]";
	function baseIsMap$1(value) {
		return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
	}
	module.exports = baseIsMap$1;
}));
var require_isMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsMap = require__baseIsMap(), baseUnary$1 = require__baseUnary(), nodeUtil$1 = require__nodeUtil();
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
	module.exports = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
}));
var require__baseIsSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getTag$1 = require__getTag(), isObjectLike = require_isObjectLike();
	var setTag$1 = "[object Set]";
	function baseIsSet$1(value) {
		return isObjectLike(value) && getTag$1(value) == setTag$1;
	}
	module.exports = baseIsSet$1;
}));
var require_isSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsSet = require__baseIsSet(), baseUnary = require__baseUnary(), nodeUtil = require__nodeUtil();
	var nodeIsSet = nodeUtil && nodeUtil.isSet;
	module.exports = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
}));
var require__baseClone = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack$1 = require__Stack(), arrayEach = require__arrayEach(), assignValue = require__assignValue(), baseAssign = require__baseAssign(), baseAssignIn = require__baseAssignIn(), cloneBuffer = require__cloneBuffer(), copyArray = require__copyArray(), copySymbols = require__copySymbols(), copySymbolsIn = require__copySymbolsIn(), getAllKeys = require__getAllKeys(), getAllKeysIn = require__getAllKeysIn(), getTag = require__getTag(), initCloneArray = require__initCloneArray(), initCloneByTag = require__initCloneByTag(), initCloneObject = require__initCloneObject(), isArray$2 = require_isArray(), isBuffer = require_isBuffer(), isMap = require_isMap(), isObject$1 = require_isObject(), isSet = require_isSet(), keys$2 = require_keys(), keysIn = require_keysIn();
	var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
	function baseClone$1(value, bitmask, customizer, key, object, stack) {
		var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
		if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
		if (result !== void 0) return result;
		if (!isObject$1(value)) return value;
		var isArr = isArray$2(value);
		if (isArr) {
			result = initCloneArray(value);
			if (!isDeep) return copyArray(value, result);
		} else {
			var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
			if (isBuffer(value)) return cloneBuffer(value, isDeep);
			if (tag == objectTag || tag == argsTag || isFunc && !object) {
				result = isFlat || isFunc ? {} : initCloneObject(value);
				if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
			} else {
				if (!cloneableTags[tag]) return object ? value : {};
				result = initCloneByTag(value, tag, isDeep);
			}
		}
		stack || (stack = new Stack$1());
		var stacked = stack.get(value);
		if (stacked) return stacked;
		stack.set(value, result);
		if (isSet(value)) value.forEach(function(subValue) {
			result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
		});
		else if (isMap(value)) value.forEach(function(subValue, key$1) {
			result.set(key$1, baseClone$1(subValue, bitmask, customizer, key$1, value, stack));
		});
		var props = isArr ? void 0 : (isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$2)(value);
		arrayEach(props || value, function(subValue, key$1) {
			if (props) {
				key$1 = subValue;
				subValue = value[key$1];
			}
			assignValue(result, key$1, baseClone$1(subValue, bitmask, customizer, key$1, value, stack));
		});
		return result;
	}
	module.exports = baseClone$1;
}));
var require_cloneDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseClone = require__baseClone();
	var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
	function cloneDeep$1(value) {
		return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}
	module.exports = cloneDeep$1;
}));
var require_escapeRegExp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toString = require_toString();
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
	function escapeRegExp$1(string) {
		string = toString(string);
		return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
	}
	module.exports = escapeRegExp$1;
}));
var require__baseForOwn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFor = require__baseFor(), keys$1 = require_keys();
	function baseForOwn$1(object, iteratee) {
		return object && baseFor(object, iteratee, keys$1);
	}
	module.exports = baseForOwn$1;
}));
var require__baseIsMatch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack = require__Stack(), baseIsEqual$1 = require__baseIsEqual();
	var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
	function baseIsMatch$1(object, source, matchData, customizer) {
		var index = matchData.length, length$1 = index, noCustomizer = !customizer;
		if (object == null) return !length$1;
		object = Object(object);
		while (index--) {
			var data = matchData[index];
			if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
		}
		while (++index < length$1) {
			data = matchData[index];
			var key = data[0], objValue = object[key], srcValue = data[1];
			if (noCustomizer && data[2]) {
				if (objValue === void 0 && !(key in object)) return false;
			} else {
				var stack = new Stack();
				if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
				if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) return false;
			}
		}
		return true;
	}
	module.exports = baseIsMatch$1;
}));
var require__isStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject = require_isObject();
	function isStrictComparable$2(value) {
		return value === value && !isObject(value);
	}
	module.exports = isStrictComparable$2;
}));
var require__getMatchData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isStrictComparable$1 = require__isStrictComparable(), keys = require_keys();
	function getMatchData$1(object) {
		var result = keys(object), length$1 = result.length;
		while (length$1--) {
			var key = result[length$1], value = object[key];
			result[length$1] = [
				key,
				value,
				isStrictComparable$1(value)
			];
		}
		return result;
	}
	module.exports = getMatchData$1;
}));
var require__matchesStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function matchesStrictComparable$2(key, srcValue) {
		return function(object) {
			if (object == null) return false;
			return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
		};
	}
	module.exports = matchesStrictComparable$2;
}));
var require__baseMatches = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsMatch = require__baseIsMatch(), getMatchData = require__getMatchData(), matchesStrictComparable$1 = require__matchesStrictComparable();
	function baseMatches$1(source) {
		var matchData = getMatchData(source);
		if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
		return function(object) {
			return object === source || baseIsMatch(object, source, matchData);
		};
	}
	module.exports = baseMatches$1;
}));
var require__baseHasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseHasIn$1(object, key) {
		return object != null && key in Object(object);
	}
	module.exports = baseHasIn$1;
}));
var require__hasPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath = require__castPath(), isArguments = require_isArguments$1(), isArray$1 = require_isArray(), isIndex = require__isIndex(), isLength = require_isLength(), toKey$2 = require__toKey();
	function hasPath$2(object, path, hasFunc) {
		path = castPath(path, object);
		var index = -1, length$1 = path.length, result = false;
		while (++index < length$1) {
			var key = toKey$2(path[index]);
			if (!(result = object != null && hasFunc(object, key))) break;
			object = object[key];
		}
		if (result || ++index != length$1) return result;
		length$1 = object == null ? 0 : object.length;
		return !!length$1 && isLength(length$1) && isIndex(key, length$1) && (isArray$1(object) || isArguments(object));
	}
	module.exports = hasPath$2;
}));
var require_hasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseHasIn = require__baseHasIn(), hasPath$1 = require__hasPath();
	function hasIn$1(object, path) {
		return object != null && hasPath$1(object, path, baseHasIn);
	}
	module.exports = hasIn$1;
}));
var require__baseMatchesProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual = require__baseIsEqual(), get = require_get(), hasIn = require_hasIn(), isKey$1 = require__isKey(), isStrictComparable = require__isStrictComparable(), matchesStrictComparable = require__matchesStrictComparable(), toKey$1 = require__toKey();
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function baseMatchesProperty$1(path, srcValue) {
		if (isKey$1(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey$1(path), srcValue);
		return function(object) {
			var objValue = get(object, path);
			return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		};
	}
	module.exports = baseMatchesProperty$1;
}));
var require__baseProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseProperty$1(key) {
		return function(object) {
			return object == null ? void 0 : object[key];
		};
	}
	module.exports = baseProperty$1;
}));
var require__basePropertyDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet = require__baseGet();
	function basePropertyDeep$1(path) {
		return function(object) {
			return baseGet(object, path);
		};
	}
	module.exports = basePropertyDeep$1;
}));
var require_property = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseProperty = require__baseProperty(), basePropertyDeep = require__basePropertyDeep(), isKey = require__isKey(), toKey = require__toKey();
	function property$1(path) {
		return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	module.exports = property$1;
}));
var require__baseIteratee = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseMatches = require__baseMatches(), baseMatchesProperty = require__baseMatchesProperty(), identity = require_identity(), isArray = require_isArray(), property = require_property();
	function baseIteratee$1(value) {
		if (typeof value == "function") return value;
		if (value == null) return identity;
		if (typeof value == "object") return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
		return property(value);
	}
	module.exports = baseIteratee$1;
}));
var require_mapValues = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseAssignValue = require__baseAssignValue(), baseForOwn = require__baseForOwn(), baseIteratee = require__baseIteratee();
	function mapValues$1(object, iteratee) {
		var result = {};
		iteratee = baseIteratee(iteratee, 3);
		baseForOwn(object, function(value, key, object$1) {
			baseAssignValue(result, key, iteratee(value, key, object$1));
		});
		return result;
	}
	module.exports = mapValues$1;
}));
var import_cloneDeep = /* @__PURE__ */ __toESM(require_cloneDeep());
var import_escapeRegExp = /* @__PURE__ */ __toESM(require_escapeRegExp());
var import_isEqual = /* @__PURE__ */ __toESM(require_isEqual());
var import_mapValues = /* @__PURE__ */ __toESM(require_mapValues());
var LazyRegExp = class {
	pattern;
	flags;
	regExp;
	constructor(pattern, flags) {
		this.pattern = pattern;
		this.flags = flags;
	}
	get() {
		if (!this.regExp) this.regExp = new RegExp(this.pattern(), this.flags);
		return this.regExp;
	}
};
var DOT_REFERENCEABLE_JS_VARIABLE = /\w[\w\d_\$]*/;
var INVALID_JS_DOT_PATH = /[^\.\w\d_\$]/;
var INVALID_JS_DOT_NAME = /[^\w\d_\$]/;
var ITEM_TO_DATA_ACCESSORS = [
	/^first\(\)/,
	/^last\(\)/,
	/^all\(\)/,
	/^itemMatching\(\d+\)/,
	/^item/
];
var SPLIT_OUT_NODE_TYPE$1 = "n8n-nodes-base.splitOut";
var ITEM_ACCESSORS = ["params", "isExecuted"];
var DATA_ACCESSORS = ["json", "binary"];
function hasDotNotationBannedChar(nodeName) {
	return /^(\d)|[\\ `!@#$%^&*()_+\-=[\]{};':"\\|,.<>?~]/g.test(nodeName);
}
function backslashEscape(nodeName) {
	return nodeName.replace(/[.*+?^${}()|[\]\\]/g, (char) => `\\${char}`);
}
function dollarEscape(nodeName) {
	return nodeName.replace(new RegExp("\\$", "g"), "$$$$");
}
var ACCESS_PATTERNS = [
	{
		checkPattern: "$(",
		replacePattern: (s$2) => String.raw`(\$\(['"])${s$2}(['"]\))`
	},
	{
		checkPattern: "$node[",
		replacePattern: (s$2) => String.raw`(\$node\[['"])${s$2}(['"]\])`
	},
	{
		checkPattern: "$node.",
		replacePattern: (s$2) => String.raw`(\$node\.)${s$2}(\.?)`,
		customCallback: (expression, newName, escapedNewName) => {
			if (hasDotNotationBannedChar(newName)) {
				const regex = new RegExp(`.${backslashEscape(newName)}( |\\.)`, "g");
				return expression.replace(regex, `["${escapedNewName}"]$1`);
			}
			return expression;
		}
	},
	{
		checkPattern: "$items(",
		replacePattern: (s$2) => String.raw`(\$items\(['"])${s$2}(['"],|['"]\))`
	}
];
function applyAccessPatterns(expression, previousName, newName) {
	if (!expression.includes(previousName)) return expression;
	const escapedOldName = backslashEscape(previousName);
	const escapedNewName = dollarEscape(newName);
	for (const pattern of ACCESS_PATTERNS) if (expression.includes(pattern.checkPattern)) {
		expression = expression.replace(new RegExp(pattern.replacePattern(escapedOldName), "g"), `$1${escapedNewName}$2`);
		if (pattern.customCallback) expression = pattern.customCallback(expression, newName, escapedNewName);
	}
	return expression;
}
function convertToUniqueJsDotName(nodeName, allNodeNames) {
	let jsLegal = nodeName.replaceAll(" ", "_").split("").filter((x$1) => !INVALID_JS_DOT_NAME.test(x$1)).join("");
	if (nodeName === jsLegal) return jsLegal;
	while (allNodeNames.includes(jsLegal)) jsLegal += `_${allNodeNames.indexOf(nodeName)}`;
	return jsLegal;
}
function convertDataAccessorName(name) {
	const [fnName, maybeDigits] = name.split("(");
	switch (fnName.toLowerCase()) {
		case "item": return fnName;
		case "first":
		case "last": return `${fnName}Item`;
		case "all": return `${fnName}Items`;
	}
	return `${fnName}_${maybeDigits?.slice(0, -1) ?? "unknown"}`;
}
function parseExpressionMapping(isolatedExpression, nodeNameInExpression, nodeNamePlainJs, startNodeName) {
	const splitExpr = isolatedExpression.split(".");
	const dotsInName = nodeNameInExpression?.split("").filter((x$1) => x$1 === ".").length ?? 0;
	const dotInAccessorsOffset = isolatedExpression.startsWith("$node.") ? 1 : 0;
	const exprStart = splitExpr.slice(0, dotInAccessorsOffset + dotsInName + 1).join(".");
	const parts = splitExpr.slice(dotInAccessorsOffset + dotsInName + 1);
	if (exprStart === "$json") {
		let partsIdx = 0;
		for (; partsIdx < parts.length; ++partsIdx) if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx])) break;
		return {
			nodeNameInExpression: null,
			originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join(".")}`,
			replacementPrefix: `${exprStart}`,
			replacementName: `${parts.slice(0, partsIdx).join("_")}`
		};
	}
	if (parts.length === 0) return null;
	const accessorPrefix = parts[0] === "all()" ? "first()" : parts[0];
	if (ITEM_TO_DATA_ACCESSORS.some((x$1) => parts[0].match(x$1))) if (parts.length === 1) {
		const originalName = parts[0];
		return {
			nodeNameInExpression,
			originalExpression: `${exprStart}.${parts[0]}`,
			replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`,
			replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(originalName)}`
		};
	} else if (DATA_ACCESSORS.some((x$1) => parts[1] === x$1)) {
		let partsIdx = 2;
		for (; partsIdx < parts.length; ++partsIdx) if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx])) break;
		const replacementPostfix = parts[0] === "item" ? "" : `_${convertDataAccessorName(parts[0])}`;
		return {
			nodeNameInExpression,
			originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join(".")}`,
			replacementPrefix: `$('${startNodeName}').${accessorPrefix}.${parts[1]}`,
			replacementName: parts.slice(2, partsIdx).join("_") + replacementPostfix
		};
	} else return {
		nodeNameInExpression,
		originalExpression: `${exprStart}.${parts[0]}`,
		replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`,
		replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(parts[0])}`
	};
	if (ITEM_ACCESSORS.flatMap((x$1) => x$1 === parts[0] ? x$1 : [])[0] !== void 0) return {
		nodeNameInExpression,
		originalExpression: `${exprStart}.${parts[0]}`,
		replacementPrefix: `$('${startNodeName}').first().json`,
		replacementName: `${nodeNamePlainJs}_${parts[0]}`
	};
	return null;
}
function extractExpressionCandidate(expression, startIndex, endIndex) {
	let after_accessor_idx = endIndex + (ITEM_TO_DATA_ACCESSORS.map((x$1) => x$1.exec(expression.slice(endIndex))).filter((x$1) => x$1 !== null)[0]?.[0].length ?? -1);
	if (expression[after_accessor_idx + 1] === ".") after_accessor_idx += 1;
	const after_accessor = expression.slice(after_accessor_idx);
	const firstInvalidCharMatch = INVALID_JS_DOT_PATH.exec(after_accessor);
	if (!firstInvalidCharMatch) return null;
	return expression.slice(startIndex, after_accessor_idx + firstInvalidCharMatch.index);
}
function parseCandidateMatch(match$1, expression, nodeNames, startNodeName) {
	const startIndex = match$1.index;
	const endIndex = startIndex + match$1[0].length + 1;
	const nodeNameInExpression = match$1[2];
	if (!nodeNames.includes(nodeNameInExpression)) return null;
	const candidate = extractExpressionCandidate(expression, startIndex, endIndex);
	if (candidate === null) return null;
	return parseExpressionMapping(candidate, nodeNameInExpression, convertToUniqueJsDotName(nodeNameInExpression, nodeNames), startNodeName);
}
function parse$jsonMatch(match$1, expression, startNodeName) {
	const candidate = extractExpressionCandidate(expression, match$1.index, match$1.index + match$1[0].length + 1);
	if (candidate === null) return null;
	return parseExpressionMapping(candidate, null, null, startNodeName);
}
function parseReferencingExpressions(expression, nodeRegexps, nodeNames, startNodeName, parse$json) {
	const result = [];
	for (const [pattern, regexp] of nodeRegexps) {
		if (!expression.includes(pattern)) continue;
		const matches = [...expression.matchAll(regexp.get())];
		result.push(...matches.map((x$1) => parseCandidateMatch(x$1, expression, nodeNames, startNodeName)).filter((x$1) => x$1 !== null));
	}
	if (parse$json && expression.includes("$json")) for (const match$1 of expression.matchAll(/\$json/gi)) {
		const res = parse$jsonMatch(match$1, expression, startNodeName);
		if (res) result.push(res);
	}
	return result;
}
function applyParameterMapping(parameterValue, mapper, keyOfValue) {
	const result = {};
	if (typeof parameterValue !== "object" || parameterValue === null) {
		if (typeof parameterValue === "string" && (parameterValue.charAt(0) === "=" || keyOfValue === "jsCode")) {
			const mapping = mapper(parameterValue);
			return [mapping, mapping];
		}
		return [void 0, []];
	}
	const allMappings = [];
	for (const [key, value] of Object.entries(parameterValue)) {
		const [mapping, all$1] = applyParameterMapping(value, mapper, key);
		result[key] = mapping;
		allMappings.push(...all$1);
	}
	return [result, allMappings];
}
function resolveDuplicates(data, allNodeNames) {
	const triggerArgumentMap = /* @__PURE__ */ new Map();
	const originalExpressionMap = /* @__PURE__ */ new Map();
	for (const mapping of data) {
		const { nodeNameInExpression, originalExpression, replacementPrefix } = mapping;
		let { replacementName } = mapping;
		const hasKeyAndCollides = (key$1) => {
			const value = triggerArgumentMap.get(key$1);
			if (!value) return false;
			return !(0, import_isEqual.default)(value, mapping);
		};
		const key = () => `${replacementPrefix}.${replacementName}`;
		if (hasKeyAndCollides(key()) && nodeNameInExpression) replacementName = `${convertToUniqueJsDotName(nodeNameInExpression, allNodeNames)}_${replacementName}`;
		while (hasKeyAndCollides(key())) replacementName += "_1";
		triggerArgumentMap.set(key(), {
			originalExpression,
			nodeNameInExpression,
			replacementName,
			replacementPrefix
		});
		originalExpressionMap.set(originalExpression, key());
	}
	return {
		triggerArgumentMap,
		originalExpressionMap
	};
}
function applyExtractMappingToNode(node, parameterExtractMapping) {
	const usedMappings = [];
	const applyMapping = (parameters$1, mapping) => {
		if (!mapping) return parameters$1;
		if (typeof parameters$1 !== "object" || parameters$1 === null) {
			if (Array.isArray(mapping) && typeof parameters$1 === "string") for (const mapper of mapping) {
				if (!parameters$1.includes(mapper.originalExpression)) continue;
				parameters$1 = parameters$1.replaceAll(mapper.originalExpression, `${mapper.replacementPrefix}.${mapper.replacementName}`);
				usedMappings.push(mapper);
			}
			return parameters$1;
		}
		if (Array.isArray(mapping)) return parameters$1;
		if (Array.isArray(parameters$1) && typeof mapping === "object" && !Array.isArray(mapping)) return parameters$1.map((x$1, i$2) => applyMapping(x$1, mapping[i$2]));
		return (0, import_mapValues.default)(parameters$1, (v$3, k$1) => applyMapping(v$3, mapping[k$1]));
	};
	const parameters = applyMapping(node.parameters, parameterExtractMapping);
	return {
		result: {
			...node,
			parameters
		},
		usedMappings
	};
}
function applyCanonicalMapping(mapping, getCanonicalData) {
	if (!mapping) return;
	if (Array.isArray(mapping)) return mapping.map(getCanonicalData).filter((x$1) => x$1 !== void 0).sort((a$1, b$5) => b$5.originalExpression.length - a$1.originalExpression.length);
	return (0, import_mapValues.default)(mapping, (v$3) => applyCanonicalMapping(v$3, getCanonicalData));
}
function extractReferencesInNodeExpressions(subGraph, nodeNames, insertedStartName, graphInputNodeNames) {
	const [start] = graphInputNodeNames ?? [];
	const subGraphNames = subGraph.map((x$1) => x$1.name);
	if (subGraphNames.includes(insertedStartName)) throw new OperationalError(`StartNodeName ${insertedStartName} already exists in nodeNames: ${JSON.stringify(subGraphNames)}`);
	if (subGraphNames.some((x$1) => !nodeNames.includes(x$1))) throw new OperationalError(`extractReferencesInNodeExpressions called with node in subGraph ${JSON.stringify(subGraphNames)} whose name is not in provided 'nodeNames' list ${JSON.stringify(nodeNames)}.`);
	const namesRegexp = "(" + nodeNames.map(import_escapeRegExp.default).join("|") + ")";
	const nodeRegexps = ACCESS_PATTERNS.map((pattern) => [pattern.checkPattern, new LazyRegExp(() => pattern.replacePattern(namesRegexp), "g")]);
	const parameterTreeMappingByNode = /* @__PURE__ */ new Map();
	const allData = [];
	const extraVariableCandidates = [];
	for (const node of subGraph) {
		const [parameterMapping, allMappings] = applyParameterMapping(node.parameters, (s$2) => parseReferencingExpressions(s$2, nodeRegexps, nodeNames, insertedStartName, graphInputNodeNames?.includes(node.name) ?? false));
		parameterTreeMappingByNode.set(node.name, parameterMapping);
		allData.push(...allMappings);
		if (node.name === start && node.type === SPLIT_OUT_NODE_TYPE$1) {
			const raw = node.parameters?.fieldToSplitOut;
			if (typeof raw === "string" && raw.trim() !== "") {
				const trimmed = raw.trim();
				const isExpression$1 = trimmed.startsWith("=");
				if (isExpression$1) throw new OperationalError(`Extracting sub-workflow from Split Out node with 'fieldToSplitOut' parameter having expression "${trimmed}" is not supported.`);
				const fields = isExpression$1 ? [trimmed] : trimmed.split(",").map((field) => `={{$json.${field.trim()}}}`);
				for (const expression of fields) {
					const mappingsFromField = parseReferencingExpressions(expression, nodeRegexps, nodeNames, insertedStartName, graphInputNodeNames?.includes(node.name) ?? false);
					extraVariableCandidates.push(...mappingsFromField);
				}
			}
		}
	}
	const subGraphNodeNames = new Set(subGraphNames);
	const { originalExpressionMap, triggerArgumentMap } = resolveDuplicates([...allData, ...extraVariableCandidates].filter((x$1) => !x$1.nodeNameInExpression || !subGraphNodeNames.has(x$1.nodeNameInExpression)), nodeNames);
	const getCanonicalData = (e$1) => {
		const key = originalExpressionMap.get(e$1.originalExpression);
		if (!key) return void 0;
		return triggerArgumentMap.get(key);
	};
	for (const [key, value] of parameterTreeMappingByNode.entries()) parameterTreeMappingByNode.set(key, applyCanonicalMapping(value, getCanonicalData));
	const allUsedMappings = [];
	const output = [];
	for (const node of subGraph) {
		const { result, usedMappings } = applyExtractMappingToNode((0, import_cloneDeep.default)(node), parameterTreeMappingByNode.get(node.name));
		allUsedMappings.push(...usedMappings);
		output.push(result);
	}
	for (const candidate of extraVariableCandidates) {
		const key = originalExpressionMap.get(candidate.originalExpression);
		if (!key) continue;
		const canonical = triggerArgumentMap.get(key);
		if (!canonical) continue;
		if (!allUsedMappings.some((u$1) => u$1.replacementName === canonical.replacementName)) allUsedMappings.push(canonical);
	}
	return {
		nodes: output,
		variables: new Map(allUsedMappings.map((m$1) => [m$1.replacementName, m$1.originalExpression]))
	};
}
function responseHasSubworkflowData(response) {
	return ["executionId", "workflowId"].every((x$1) => hasKey(response, x$1) && typeof response[x$1] === "string");
}
function parseErrorResponseWorkflowMetadata(response) {
	if (!responseHasSubworkflowData(response)) return void 0;
	return {
		subExecution: {
			executionId: response.executionId,
			workflowId: response.workflowId
		},
		subExecutionsCount: 1
	};
}
function parseErrorMetadata(error$1) {
	if (hasKey(error$1, "errorResponse")) return parseErrorResponseWorkflowMetadata(error$1.errorResponse);
	return parseErrorResponseWorkflowMetadata(error$1);
}
function renameFormFields(node, renameField) {
	const formFields = node.parameters?.formFields;
	const values$1 = formFields && typeof formFields === "object" && "values" in formFields && typeof formFields.values === "object" && Array.isArray(formFields.values) ? formFields.values ?? [] : [];
	for (const formFieldValue of values$1) {
		if (!formFieldValue || typeof formFieldValue !== "object") continue;
		if ("fieldType" in formFieldValue && formFieldValue.fieldType === "html") {
			if ("html" in formFieldValue) formFieldValue.html = renameField(formFieldValue.html);
		}
	}
}
function dedupe(arr) {
	return [...new Set(arr)];
}
var Workflow = class {
	id;
	name;
	nodes = {};
	connectionsBySourceNode = {};
	connectionsByDestinationNode = {};
	nodeTypes;
	expression;
	active;
	settings = {};
	timezone;
	staticData;
	testStaticData;
	pinData;
	constructor(parameters) {
		this.id = parameters.id;
		this.name = parameters.name;
		this.nodeTypes = parameters.nodeTypes;
		let nodeType;
		for (const node of parameters.nodes) {
			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (nodeType === void 0) continue;
			const nodeParameters = getNodeParameters(nodeType.description.properties, node.parameters, true, false, node, nodeType.description);
			node.parameters = nodeParameters !== null ? nodeParameters : {};
		}
		this.setNodes(parameters.nodes);
		this.setConnections(parameters.connections);
		this.setPinData(parameters.pinData);
		this.setSettings(parameters.settings ?? {});
		this.active = parameters.active || false;
		this.staticData = create(parameters.staticData || {}, void 0, { ignoreEmptyOnFirstChild: true });
		this.timezone = this.settings.timezone ?? getGlobalState().defaultTimezone;
		this.expression = new Expression(this);
	}
	setNodes(nodes) {
		this.nodes = {};
		for (const node of nodes) this.nodes[node.name] = node;
	}
	setConnections(connections) {
		this.connectionsBySourceNode = connections;
		this.connectionsByDestinationNode = mapConnectionsByDestination(this.connectionsBySourceNode);
	}
	setPinData(pinData) {
		this.pinData = pinData;
	}
	setSettings(settings) {
		this.settings = settings;
	}
	overrideStaticData(staticData) {
		this.staticData = create(staticData || {}, void 0, { ignoreEmptyOnFirstChild: true });
		this.staticData.__dataChanged = true;
	}
	static getConnectionsByDestination(connections) {
		const returnConnection = {};
		let connectionInfo;
		let maxIndex;
		for (const sourceNode in connections) {
			if (!connections.hasOwnProperty(sourceNode)) continue;
			for (const type of Object.keys(connections[sourceNode])) {
				if (!connections[sourceNode].hasOwnProperty(type)) continue;
				for (const inputIndex in connections[sourceNode][type]) {
					if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) continue;
					for (connectionInfo of connections[sourceNode][type][inputIndex] ?? []) {
						if (!returnConnection.hasOwnProperty(connectionInfo.node)) returnConnection[connectionInfo.node] = {};
						if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) returnConnection[connectionInfo.node][connectionInfo.type] = [];
						maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
						for (let j$1 = maxIndex; j$1 < connectionInfo.index; j$1++) returnConnection[connectionInfo.node][connectionInfo.type].push([]);
						returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index]?.push({
							node: sourceNode,
							type,
							index: parseInt(inputIndex, 10)
						});
					}
				}
			}
		}
		return returnConnection;
	}
	getStaticData(type, node) {
		let key;
		if (type === "global") key = "global";
		else if (type === "node") {
			if (node === void 0) throw new ApplicationError("The request data of context type \"node\" the node parameter has to be set!");
			key = `node:${node.name}`;
		} else throw new ApplicationError("Unknown context type. Only `global` and `node` are supported.", { extra: { contextType: type } });
		if (this.testStaticData?.[key]) return this.testStaticData[key];
		if (this.staticData[key] === void 0) this.staticData[key] = create({}, this.staticData);
		return this.staticData[key];
	}
	setTestStaticData(testStaticData) {
		this.testStaticData = testStaticData;
	}
	getTriggerNodes() {
		return this.queryNodes((nodeType) => !!nodeType.trigger);
	}
	getPollNodes() {
		return this.queryNodes((nodeType) => !!nodeType.poll);
	}
	queryNodes(checkFunction) {
		const returnNodes = [];
		let node;
		let nodeType;
		for (const nodeName of Object.keys(this.nodes)) {
			node = this.nodes[nodeName];
			if (node.disabled === true) continue;
			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (nodeType !== void 0 && checkFunction(nodeType)) returnNodes.push(node);
		}
		return returnNodes;
	}
	getNode(nodeName) {
		return this.nodes[nodeName] ?? null;
	}
	getNodes(nodeNames) {
		const nodes = [];
		for (const name of nodeNames) {
			const node = this.getNode(name);
			if (!node) {
				console.warn(`Could not find a node with the name ${name} in the workflow. This was passed in as a dirty node name.`);
				continue;
			}
			nodes.push(node);
		}
		return nodes;
	}
	getPinDataOfNode(nodeName) {
		return this.pinData ? this.pinData[nodeName] : void 0;
	}
	renameNodeInParameterValue(parameterValue, currentName, newName, { hasRenamableContent } = { hasRenamableContent: false }) {
		if (typeof parameterValue !== "object") {
			if (typeof parameterValue === "string" && (parameterValue.charAt(0) === "=" || hasRenamableContent)) parameterValue = applyAccessPatterns(parameterValue, currentName, newName);
			return parameterValue;
		}
		if (Array.isArray(parameterValue)) {
			const returnArray = [];
			for (const currentValue of parameterValue) returnArray.push(this.renameNodeInParameterValue(currentValue, currentName, newName));
			return returnArray;
		}
		const returnData = {};
		for (const parameterName of Object.keys(parameterValue || {})) returnData[parameterName] = this.renameNodeInParameterValue(parameterValue[parameterName], currentName, newName, { hasRenamableContent });
		return returnData;
	}
	renameNode(currentName, newName) {
		const restrictedKeys = [
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"toLocaleString",
			"toString",
			"valueOf",
			"constructor",
			"prototype",
			"__proto__",
			"__defineGetter__",
			"__defineSetter__",
			"__lookupGetter__",
			"__lookupSetter__"
		];
		if (restrictedKeys.map((k$1) => k$1.toLowerCase()).includes(newName.toLowerCase())) throw new UserError(`Node name "${newName}" is a restricted name.`, { description: `Node names cannot be any of the following: ${restrictedKeys.join(", ")}` });
		if (this.nodes[currentName] !== void 0) {
			this.nodes[newName] = this.nodes[currentName];
			this.nodes[newName].name = newName;
			delete this.nodes[currentName];
		}
		for (const node of Object.values(this.nodes)) {
			node.parameters = this.renameNodeInParameterValue(node.parameters, currentName, newName);
			if (NODES_WITH_RENAMABLE_CONTENT.has(node.type)) node.parameters.jsCode = this.renameNodeInParameterValue(node.parameters.jsCode, currentName, newName, { hasRenamableContent: true });
			if (NODES_WITH_RENAMEABLE_TOPLEVEL_HTML_CONTENT.has(node.type)) node.parameters.html = this.renameNodeInParameterValue(node.parameters.html, currentName, newName, { hasRenamableContent: true });
			if (NODES_WITH_RENAMABLE_FORM_HTML_CONTENT.has(node.type)) renameFormFields(node, (p$1) => this.renameNodeInParameterValue(p$1, currentName, newName, { hasRenamableContent: true }));
		}
		if (this.connectionsBySourceNode.hasOwnProperty(currentName)) {
			this.connectionsBySourceNode[newName] = this.connectionsBySourceNode[currentName];
			delete this.connectionsBySourceNode[currentName];
		}
		let sourceNode;
		let type;
		let sourceIndex;
		let connectionIndex;
		let connectionData;
		for (sourceNode of Object.keys(this.connectionsBySourceNode)) for (type of Object.keys(this.connectionsBySourceNode[sourceNode])) for (sourceIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type])) for (connectionIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)] || [])) {
			connectionData = this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)]?.[parseInt(connectionIndex, 10)];
			if (connectionData?.node === currentName) connectionData.node = newName;
		}
	}
	getHighestNode(nodeName, nodeConnectionIndex, checkedNodes) {
		const currentHighest = [];
		if (this.nodes[nodeName].disabled === false) currentHighest.push(nodeName);
		if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) return currentHighest;
		if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(NodeConnectionTypes.Main)) return currentHighest;
		checkedNodes = checkedNodes || [];
		if (checkedNodes.includes(nodeName)) return currentHighest;
		checkedNodes.push(nodeName);
		const returnNodes = [];
		let addNodes;
		let connectionsByIndex;
		for (let connectionIndex = 0; connectionIndex < this.connectionsByDestinationNode[nodeName][NodeConnectionTypes.Main].length; connectionIndex++) {
			if (nodeConnectionIndex !== void 0 && nodeConnectionIndex !== connectionIndex) continue;
			connectionsByIndex = this.connectionsByDestinationNode[nodeName][NodeConnectionTypes.Main][connectionIndex];
			connectionsByIndex?.forEach((connection) => {
				if (checkedNodes.includes(connection.node)) return;
				if (!(connection.node in this.nodes)) return;
				addNodes = this.getHighestNode(connection.node, void 0, checkedNodes);
				if (addNodes.length === 0) {
					if (this.nodes[connection.node].disabled !== true) addNodes = [connection.node];
				}
				addNodes.forEach((name) => {
					if (returnNodes.indexOf(name) === -1) returnNodes.push(name);
				});
			});
		}
		return returnNodes;
	}
	getChildNodes(nodeName, type = NodeConnectionTypes.Main, depth = -1) {
		return getChildNodes(this.connectionsBySourceNode, nodeName, type, depth);
	}
	getParentNodes(nodeName, type = NodeConnectionTypes.Main, depth = -1) {
		return getParentNodes(this.connectionsByDestinationNode, nodeName, type, depth);
	}
	getConnectedNodes(connections, nodeName, connectionType = NodeConnectionTypes.Main, depth = -1, checkedNodesIncoming) {
		return getConnectedNodes(connections, nodeName, connectionType, depth, checkedNodesIncoming);
	}
	getParentNodesByDepth(nodeName, maxDepth = -1) {
		return this.searchNodesBFS(this.connectionsByDestinationNode, nodeName, maxDepth);
	}
	searchNodesBFS(connections, sourceNode, maxDepth = -1) {
		const returnConns = [];
		const type = NodeConnectionTypes.Main;
		let queue = [];
		queue.push({
			name: sourceNode,
			depth: 0,
			indicies: []
		});
		const visited = {};
		let depth = 0;
		while (queue.length > 0) {
			if (maxDepth !== -1 && depth > maxDepth) break;
			depth++;
			const toAdd = [...queue];
			queue = [];
			toAdd.forEach((curr) => {
				if (visited[curr.name]) {
					visited[curr.name].indicies = dedupe(visited[curr.name].indicies.concat(curr.indicies));
					return;
				}
				visited[curr.name] = curr;
				if (curr.name !== sourceNode) returnConns.push(curr);
				if (!connections.hasOwnProperty(curr.name) || !connections[curr.name].hasOwnProperty(type)) return;
				connections[curr.name][type].forEach((connectionsByIndex) => {
					connectionsByIndex?.forEach((connection) => {
						queue.push({
							name: connection.node,
							indicies: [connection.index],
							depth
						});
					});
				});
			});
		}
		return returnConns;
	}
	getParentMainInputNode(node) {
		if (node) {
			const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (!nodeType?.description.outputs) return node;
			const outputs = getNodeOutputs(this, node, nodeType.description);
			const nonMainConnectionTypes = [];
			for (const output of outputs) {
				const type = typeof output === "string" ? output : output.type;
				if (type !== NodeConnectionTypes.Main) nonMainConnectionTypes.push(type);
			}
			nonMainConnectionTypes.sort();
			if (nonMainConnectionTypes.length > 0) {
				const nonMainNodesConnected = [];
				const nodeConnections = this.connectionsBySourceNode[node.name];
				for (const type of nonMainConnectionTypes) if (nodeConnections?.[type]) {
					const childNodes = this.getChildNodes(node.name, type);
					if (childNodes.length > 0) nonMainNodesConnected.push(...childNodes);
				}
				if (nonMainNodesConnected.length) {
					nonMainNodesConnected.sort();
					const returnNode = this.getNode(nonMainNodesConnected[0]);
					if (!returnNode) throw new ApplicationError(`Node "${nonMainNodesConnected[0]}" not found`);
					return this.getParentMainInputNode(returnNode);
				}
			}
		}
		return node;
	}
	getNodeConnectionIndexes(nodeName, parentNodeName, type = NodeConnectionTypes.Main) {
		if (this.getNode(parentNodeName) === null) return;
		const visitedNodes = /* @__PURE__ */ new Set();
		const queue = [nodeName];
		const connectionsByDest = this.connectionsByDestinationNode;
		while (queue.length > 0) {
			const currentNodeName = queue.shift();
			if (visitedNodes.has(currentNodeName)) continue;
			visitedNodes.add(currentNodeName);
			const typeConnections = connectionsByDest[currentNodeName]?.[type];
			if (!typeConnections) continue;
			for (let typedConnectionIdx = 0; typedConnectionIdx < typeConnections.length; typedConnectionIdx++) {
				const connectionsByIndex = typeConnections[typedConnectionIdx];
				if (!connectionsByIndex) continue;
				for (let destinationIndex = 0; destinationIndex < connectionsByIndex.length; destinationIndex++) {
					const connection = connectionsByIndex[destinationIndex];
					if (parentNodeName === connection.node) return {
						sourceIndex: connection.index,
						destinationIndex
					};
					if (!visitedNodes.has(connection.node)) queue.push(connection.node);
				}
			}
		}
	}
	__getStartNode(nodeNames) {
		let node;
		let nodeType;
		if (nodeNames.length === 1) {
			node = this.nodes[nodeNames[0]];
			if (node && !node.disabled) return node;
		}
		for (const nodeName of nodeNames) {
			node = this.nodes[nodeName];
			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (nodeType.description.name === "@n8n/n8n-nodes-langchain.manualChatTrigger") continue;
			if (nodeType && (nodeType.trigger !== void 0 || nodeType.poll !== void 0)) {
				if (node.disabled === true) continue;
				return node;
			}
		}
		const sortedNodeNames = Object.values(this.nodes).sort((a$1, b$5) => STARTING_NODE_TYPES.indexOf(a$1.type) - STARTING_NODE_TYPES.indexOf(b$5.type)).map((n$6) => n$6.name);
		for (const nodeName of sortedNodeNames) {
			node = this.nodes[nodeName];
			if (STARTING_NODE_TYPES.includes(node.type)) {
				if (node.disabled === true) continue;
				return node;
			}
		}
	}
	getStartNode(destinationNode) {
		if (destinationNode) {
			const nodeNames = this.getHighestNode(destinationNode);
			if (nodeNames.length === 0) nodeNames.push(destinationNode);
			const node = this.__getStartNode(nodeNames);
			if (node !== void 0) return node;
			return this.nodes[nodeNames[0]];
		}
		return this.__getStartNode(Object.keys(this.nodes));
	}
	getConnectionsBetweenNodes(sources, targets) {
		const result = [];
		for (const source of sources) for (const type of Object.keys(this.connectionsBySourceNode[source] ?? {})) for (const sourceIndex of Object.keys(this.connectionsBySourceNode[source][type])) for (const connectionIndex of Object.keys(this.connectionsBySourceNode[source][type][parseInt(sourceIndex, 10)] ?? [])) {
			const targetConnectionData = this.connectionsBySourceNode[source][type][parseInt(sourceIndex, 10)]?.[parseInt(connectionIndex, 10)];
			if (targetConnectionData && targets.includes(targetConnectionData?.node)) result.push([{
				node: source,
				index: parseInt(sourceIndex, 10),
				type
			}, targetConnectionData]);
		}
		return result;
	}
};
function getInputEdges(graphIds, adjacencyList) {
	const result = [];
	for (const [from$2, tos] of adjacencyList.entries()) {
		if (graphIds.has(from$2)) continue;
		for (const to of tos) if (graphIds.has(to.node)) result.push([from$2, to]);
	}
	return result;
}
function getOutputEdges(graphIds, adjacencyList) {
	const result = [];
	for (const [from$2, tos] of adjacencyList.entries()) {
		if (!graphIds.has(from$2)) continue;
		for (const to of tos) if (!graphIds.has(to.node)) result.push([from$2, to]);
	}
	return result;
}
function intersection(a$1, b$5) {
	const result = /* @__PURE__ */ new Set();
	for (const x$1 of a$1) if (b$5.has(x$1)) result.add(x$1);
	return result;
}
function union(a$1, b$5) {
	const result = /* @__PURE__ */ new Set();
	for (const x$1 of a$1) result.add(x$1);
	for (const x$1 of b$5) result.add(x$1);
	return result;
}
function difference(minuend, subtrahend) {
	const result = new Set(minuend.values());
	for (const x$1 of subtrahend) result.delete(x$1);
	return result;
}
function getRootNodes(graphIds, adjacencyList) {
	let innerNodes = /* @__PURE__ */ new Set();
	for (const nodeId of graphIds) innerNodes = union(innerNodes, new Set([...adjacencyList.get(nodeId) ?? []].filter((x$1) => x$1.type === "main" && x$1.node !== nodeId).map((x$1) => x$1.node)));
	return difference(graphIds, innerNodes);
}
function getLeafNodes(graphIds, adjacencyList) {
	const result = /* @__PURE__ */ new Set();
	for (const nodeId of graphIds) if (intersection(new Set([...adjacencyList.get(nodeId) ?? []].filter((x$1) => x$1.type === "main" && x$1.node !== nodeId).map((x$1) => x$1.node)), graphIds).size === 0) result.add(nodeId);
	return result;
}
function hasPath(start, end, adjacencyList) {
	const seen = /* @__PURE__ */ new Set();
	const paths = [start];
	while (true) {
		const next = paths.pop();
		if (next === end) return true;
		if (next === void 0) return false;
		seen.add(next);
		paths.push(...difference(new Set([...adjacencyList.get(next) ?? []].filter((x$1) => x$1.type === "main").map((x$1) => x$1.node)), seen));
	}
}
function buildAdjacencyList(connectionsBySourceNode) {
	const result = /* @__PURE__ */ new Map();
	const addOrCreate = (k$1, v$3) => result.set(k$1, union(result.get(k$1) ?? /* @__PURE__ */ new Set(), new Set([v$3])));
	for (const sourceNode of Object.keys(connectionsBySourceNode)) for (const type of Object.keys(connectionsBySourceNode[sourceNode])) for (const sourceIndex of Object.keys(connectionsBySourceNode[sourceNode][type])) for (const connectionIndex of Object.keys(connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)] ?? [])) {
		const connection = connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)]?.[parseInt(connectionIndex, 10)];
		if (connection) addOrCreate(sourceNode, connection);
	}
	return result;
}
function parseExtractableSubgraphSelection(graphIds, adjacencyList) {
	const errors = [];
	const inputEdges = getInputEdges(graphIds, adjacencyList);
	const inputNodes = new Set(inputEdges.filter((x$1) => x$1[1].type === "main").map((x$1) => x$1[1].node));
	let rootNodes = getRootNodes(graphIds, adjacencyList);
	if (rootNodes.size === 0 && inputNodes.size === 1) rootNodes = inputNodes;
	for (const inputNode of difference(inputNodes, rootNodes).values()) errors.push({
		errorCode: "Input Edge To Non-Root Node",
		node: inputNode
	});
	const rootInputNodes = intersection(rootNodes, inputNodes);
	if (rootInputNodes.size > 1) errors.push({
		errorCode: "Multiple Input Nodes",
		nodes: rootInputNodes
	});
	const outputEdges = getOutputEdges(graphIds, adjacencyList);
	const outputNodes = new Set(outputEdges.filter((x$1) => x$1[1].type === "main").map((x$1) => x$1[0]));
	let leafNodes = getLeafNodes(graphIds, adjacencyList);
	if (leafNodes.size === 0 && outputNodes.size === 1) leafNodes = outputNodes;
	for (const outputNode of difference(outputNodes, leafNodes).values()) errors.push({
		errorCode: "Output Edge From Non-Leaf Node",
		node: outputNode
	});
	const leafOutputNodes = intersection(leafNodes, outputNodes);
	if (leafOutputNodes.size > 1) errors.push({
		errorCode: "Multiple Output Nodes",
		nodes: leafOutputNodes
	});
	const start = rootInputNodes.values().next().value;
	const end = leafOutputNodes.values().next().value;
	if (start && end && !hasPath(start, end, adjacencyList)) errors.push({
		errorCode: "No Continuous Path From Root To Leaf In Selection",
		start,
		end
	});
	return errors.length > 0 ? errors : {
		start,
		end
	};
}
var NATIVE_METHODS = [
	{
		typeName: "String",
		properties: { length: { doc: {
			name: "length",
			description: "The number of characters in the string",
			examples: [{
				example: "\"hello\".length",
				evaluated: "5"
			}],
			section: "query",
			docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length",
			returnType: "number"
		} } },
		functions: {
			concat: { doc: {
				name: "concat",
				description: "Joins one or more strings onto the end of the base string. Alternatively, use the <code>+</code> operator (see examples).",
				examples: [
					{
						example: "'sea'.concat('food')",
						evaluated: "'seafood'"
					},
					{
						example: "'sea' + 'food'",
						evaluated: "'seafood'"
					},
					{
						example: "'work'.concat('a', 'holic')",
						evaluated: "'workaholic'"
					}
				],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat",
				args: [{
					name: "strings",
					optional: false,
					variadic: true,
					description: "The strings to append, in order",
					type: "string[]"
				}],
				returnType: "string"
			} },
			endsWith: { doc: {
				name: "endsWith",
				description: "Returns <code>true</code> if the string ends with <code>searchString</code>. Case-sensitive.",
				examples: [
					{
						example: "'team'.endsWith('eam')",
						evaluated: "true"
					},
					{
						example: "'team'.endsWith('Eam')",
						evaluated: "false"
					},
					{
						example: "'teaM'.toLowerCase().endsWith('eam')",
						evaluated: "true",
						description: "Returns false if the case doesn't match, so consider using .toLowerCase() first"
					}
				],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith",
				returnType: "boolean",
				args: [{
					name: "searchString",
					optional: false,
					description: "The text to check against the end of the base string",
					type: "string"
				}, {
					name: "end",
					optional: true,
					description: "The end position (index) to start searching from",
					type: "number"
				}]
			} },
			indexOf: { doc: {
				name: "indexOf",
				description: "Returns the index (position) of the first occurrence of <code>searchString</code> within the base string, or -1 if not found. Case-sensitive.",
				examples: [
					{
						example: "'steam'.indexOf('tea')",
						evaluated: "1"
					},
					{
						example: "'steam'.indexOf('i')",
						evaluated: "-1"
					},
					{
						example: "'STEAM'.indexOf('tea')",
						evaluated: "-1",
						description: "Returns -1 if the case doesn't match, so consider using .toLowerCase() first"
					},
					{
						example: "'STEAM'.toLowerCase().indexOf('tea')",
						evaluated: "1"
					}
				],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf",
				returnType: "number",
				args: [{
					name: "searchString",
					optional: false,
					description: "The text to search for",
					type: "string"
				}, {
					name: "start",
					optional: true,
					description: "The position (index) to start searching from",
					default: "0",
					type: "number"
				}]
			} },
			lastIndexOf: { doc: {
				name: "lastIndexOf",
				description: "Returns the index (position) of the last occurrence of <code>searchString</code> within the base string, or -1 if not found. Case-sensitive.",
				examples: [
					{
						example: "'canal'.lastIndexOf('a')",
						evaluated: "3"
					},
					{
						example: "'canal'.lastIndexOf('i')",
						evaluated: "-1"
					},
					{
						example: "'CANAL'.lastIndexOf('a')",
						evaluated: "-1",
						description: "Returns -1 if the case doesn't match, so consider using .toLowerCase() first"
					},
					{
						example: "'CANAL'.toLowerCase().lastIndexOf('a')",
						evaluated: "3"
					}
				],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf",
				returnType: "number",
				args: [{
					name: "searchString",
					optional: false,
					description: "The text to search for",
					type: "string"
				}, {
					name: "end",
					optional: true,
					description: "The position (index) to stop searching at",
					default: "0",
					type: "number"
				}]
			} },
			match: { doc: {
				name: "match",
				description: "Matches the string against a <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a>. Returns an array containing the first match, or all matches if the <code>g</code> flag is set in the regular expression. Returns <code>null</code> if no matches are found. \n\nFor checking whether text is present, consider <code>includes()</code> instead.",
				examples: [
					{
						example: "\"rock and roll\".match(/r[^ ]*/g)",
						evaluated: "['rock', 'roll']",
						description: "Match all words starting with 'r'"
					},
					{
						example: "\"rock and roll\".match(/r[^ ]*/)",
						evaluated: "['rock']",
						description: "Match first word starting with 'r' (no 'g' flag)"
					},
					{
						example: "\"ROCK and roll\".match(/r[^ ]*/ig)",
						evaluated: "['ROCK', 'roll']",
						description: "For case-insensitive, add 'i' flag"
					}
				],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match",
				returnType: "string[]",
				args: [{
					name: "regexp",
					optional: false,
					description: "A <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a> with the pattern to look for. Will look for multiple matches if the <code>g</code> flag is present (see examples).",
					type: "RegExp"
				}]
			} },
			includes: { doc: {
				name: "includes",
				description: "Returns <code>true</code> if the string contains the <code>searchString</code>. Case-sensitive.",
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes",
				returnType: "boolean",
				args: [{
					name: "searchString",
					optional: false,
					description: "The text to search for",
					type: "string"
				}, {
					name: "start",
					optional: true,
					description: "The position (index) to start searching from",
					default: "0",
					type: "number"
				}],
				examples: [
					{
						example: "'team'.includes('tea')",
						evaluated: "true"
					},
					{
						example: "'team'.includes('i')",
						evaluated: "false"
					},
					{
						example: "'team'.includes('Tea')",
						evaluated: "false",
						description: "Returns false if the case doesn't match, so consider using .toLowerCase() first"
					},
					{
						example: "'Team'.toLowerCase().includes('tea')",
						evaluated: "true"
					}
				]
			} },
			replace: { doc: {
				name: "replace",
				description: "Returns a string with the first occurrence of <code>pattern</code> replaced by <code>replacement</code>. \n\nTo replace all occurrences, use <code>replaceAll()</code> instead.",
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace",
				returnType: "string",
				args: [{
					name: "pattern",
					optional: false,
					description: "The pattern in the string to replace. Can be a string to match or a <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a>.",
					type: "string|RegExp"
				}, {
					name: "replacement",
					optional: false,
					description: "The new text to replace with",
					type: "string"
				}],
				examples: [
					{
						example: "'Red or blue or green'.replace('or', 'and')",
						evaluated: "'Red and blue or green'"
					},
					{
						example: "let text = \"Mr Blue has a blue house and a blue car\";\ntext.replace(/blue/gi, \"red\");",
						evaluated: "'Mr red has a red house and a red car'",
						description: "A global, case-insensitive replacement:"
					},
					{
						example: "let text = \"Mr Blue has a blue house and a blue car\";\ntext.replace(/blue|house|car/gi, (t) => t.toUpperCase());",
						evaluated: "'Mr BLUE has a BLUE HOUSE and a BLUE CAR'",
						description: "A function to return the replacement text:"
					}
				]
			} },
			replaceAll: { doc: {
				name: "replaceAll",
				description: "Returns a string with all occurrences of <code>pattern</code> replaced by <code>replacement</code>",
				examples: [
					{
						example: "'Red or blue or green'.replaceAll('or', 'and')",
						evaluated: "'Red and blue and green'"
					},
					{
						example: "text = 'Mr Blue has a blue car';\ntext.replaceAll(/blue|car/gi, t => t.toUpperCase())",
						description: "Uppercase any occurrences of 'blue' or 'car' (You must include the 'g' flag when using a regex)",
						evaluated: "'Mr BLUE has a BLUE CAR'"
					},
					{
						example: "text.replaceAll(/blue|car/gi, function(x){return x.toUpperCase()})",
						evaluated: "'Mr BLUE has a BLUE CAR'",
						description: "Or with traditional function notation:"
					}
				],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll",
				returnType: "string",
				args: [{
					name: "pattern",
					optional: false,
					description: "The pattern in the string to replace. Can be a string to match or a <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a>.",
					type: "string|RegExp"
				}, {
					name: "replacement",
					optional: false,
					description: "The new text to replace with. Can be a string or a function that returns a string (see examples).",
					type: "string|Function"
				}]
			} },
			search: { doc: {
				name: "search",
				description: "Returns the index (position) of the first occurrence of a pattern within the string, or -1 if not found. The pattern is specified using a <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a>. To use text instead, see <code>indexOf()</code>.",
				examples: [{
					example: "\"Neat n8n node\".search(/n[^ ]*/)",
					evaluated: "5",
					description: "Pos of first word starting with 'n'"
				}, {
					example: "\"Neat n8n node\".search(/n[^ ]*/i)",
					evaluated: "0",
					description: "Case-insensitive match with 'i'\nPos of first word starting with 'n' or 'N'"
				}],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search",
				returnType: "string",
				args: [{
					name: "regexp",
					optional: false,
					description: "A <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions\">regular expression</a> with the pattern to look for",
					type: "RegExp"
				}]
			} },
			slice: { doc: {
				name: "slice",
				description: "Extracts a fragment of the string at the given position. For more advanced extraction, see <code>match()</code>.",
				examples: [
					{
						example: "'Hello from n8n'.slice(0, 5)",
						evaluated: "'Hello'"
					},
					{
						example: "'Hello from n8n'.slice(6)",
						evaluated: "'from n8n'"
					},
					{
						example: "'Hello from n8n'.slice(-3)",
						evaluated: "'n8n'"
					}
				],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice",
				returnType: "string",
				args: [{
					name: "start",
					optional: false,
					description: "The position to start from. Positions start at 0. Negative numbers count back from the end of the string.",
					type: "number"
				}, {
					name: "end",
					optional: true,
					description: "The position to select up to. The character at the end position is not included. Negative numbers select from the end of the string. If omitted, will extract to the end of the string.",
					type: "string"
				}]
			} },
			split: { doc: {
				name: "split",
				description: "Splits the string into an array of substrings. Each split is made at the <code>separator</code>, and the separator isn't included in the output. \n\nThe opposite of using <code>join()</code> on an array.",
				examples: [
					{
						example: "\"wind,fire,water\".split(\",\")",
						evaluated: "['wind', 'fire', 'water']"
					},
					{
						example: "\"me and you and her\".split(\"and\")",
						evaluated: "['me ', ' you ', ' her']"
					},
					{
						example: "\"me? you, and her\".split(/[ ,?]+/)",
						evaluated: "['me', 'you', 'and', 'her']",
						description: "Split one or more of space, comma and '?' using a regular expression"
					}
				],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split",
				returnType: "string[]",
				args: [{
					name: "separator",
					optional: true,
					description: "The string (or regular expression) to use for splitting. If omitted, an array with the original string is returned.",
					type: "string"
				}, {
					name: "limit",
					optional: true,
					description: "The max number of array elements to return. Returns all elements if omitted.",
					type: "number"
				}]
			} },
			startsWith: { doc: {
				name: "startsWith",
				description: "Returns <code>true</code> if the string starts with <code>searchString</code>. Case-sensitive.",
				examples: [
					{
						example: "'team'.startsWith('tea')",
						evaluated: "true"
					},
					{
						example: "'team'.startsWith('Tea')",
						evaluated: "false"
					},
					{
						example: "'Team'.toLowerCase().startsWith('tea')",
						evaluated: "true",
						description: "Returns false if the case doesn't match, so consider using .toLowerCase() first"
					}
				],
				section: "query",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith",
				returnType: "boolean",
				args: [{
					name: "searchString",
					optional: false,
					description: "The text to check against the start of the base string",
					type: "string"
				}, {
					name: "start",
					optional: true,
					description: "The position (index) to start searching from",
					default: "0",
					type: "number"
				}]
			} },
			substring: { doc: {
				name: "substring",
				description: "Extracts a fragment of the string at the given position. For more advanced extraction, see <code>match()</code>.",
				examples: [{
					example: "'Hello from n8n'.substring(0, 5)",
					evaluated: "'Hello'"
				}, {
					example: "'Hello from n8n'.substring(6)",
					evaluated: "'from n8n'"
				}],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring",
				returnType: "string",
				args: [{
					name: "start",
					optional: false,
					description: "The position to start from. Positions start at 0.",
					type: "number"
				}, {
					name: "end",
					optional: true,
					description: "The position to select up to. The character at the end position is not included. If omitted, will extract to the end of the string.",
					type: "string"
				}]
			} },
			toLowerCase: { doc: {
				name: "toLowerCase",
				description: "Converts all letters in the string to lower case",
				section: "case",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase",
				returnType: "string",
				examples: [{
					example: "\"I'm SHOUTing\".toLowerCase()",
					evaluated: "\"i'm shouting\""
				}]
			} },
			toUpperCase: { doc: {
				name: "toUpperCase",
				description: "Converts all letters in the string to upper case (capitals)",
				examples: [{
					example: "\"I'm not angry\".toUpperCase()",
					evaluated: "\"I'M NOT ANGRY\""
				}],
				section: "case",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase",
				returnType: "string"
			} },
			trim: { doc: {
				name: "trim",
				description: "Removes whitespace from both ends of the string. Whitespace includes new lines, tabs, spaces, etc.",
				examples: [{
					example: "'   lonely   '.trim()",
					evaluated: "'lonely'"
				}],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim",
				returnType: "string"
			} },
			trimEnd: { doc: {
				name: "trimEnd",
				description: "Removes whitespace from the end of a string and returns a new string. Whitespace includes new lines, tabs, spaces, etc.",
				examples: [{
					example: "'   lonely   '.trimEnd()",
					evaluated: "'   lonely'"
				}],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd",
				returnType: "string"
			} },
			trimStart: { doc: {
				name: "trimStart",
				description: "Removes whitespace from the beginning of a string and returns a new string. Whitespace includes new lines, tabs, spaces, etc.",
				examples: [{
					example: "'   lonely   '.trimStart()",
					evaluated: "'lonely   '"
				}],
				section: "edit",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart",
				returnType: "string"
			} }
		}
	},
	{
		typeName: "Array",
		properties: { length: { doc: {
			name: "length",
			description: "The number of elements in the array",
			examples: [{
				example: "['Bob', 'Bill', 'Nat'].length",
				evaluated: "3"
			}],
			docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length",
			returnType: "number"
		} } },
		functions: {
			concat: { doc: {
				name: "concat",
				description: "Joins one or more arrays onto the end of the base array",
				examples: [{
					example: "['Nathan', 'Jan'].concat(['Steve', 'Bill'])",
					evaluated: "['Nathan', 'Jan', 'Steve', 'Bill']"
				}, {
					example: "[5, 4].concat([100, 101], ['a', 'b'])",
					evaluated: "[5, 4, 100, 101, 'a', 'b']"
				}],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat",
				returnType: "Array",
				args: [{
					name: "arrays",
					variadic: true,
					description: "The arrays to be joined on the end of the base array, in order",
					type: "Array"
				}]
			} },
			filter: { doc: {
				name: "filter",
				description: "Returns an array with only the elements satisfying a condition. The condition is a function that returns <code>true</code> or <code>false</code>.",
				examples: [
					{
						example: "[12, 33, 16, 40].filter(age => age > 18)",
						evaluated: "[33, 40]",
						description: "Keep ages over 18 (using arrow function notation)"
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].filter(name => name.length < 5)",
						evaluated: "['Bob']",
						description: "Keep names under 5 letters long (using arrow function notation)"
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].filter(function(name) { return name.length < 5 })",
						evaluated: "['Bob']",
						description: "Or using traditional function notation"
					},
					{
						example: "[1, 7, 3, 10, 5].filter((num, index) =>  index % 2 !== 0)",
						evaluated: "[7, 10]",
						description: "Keep numbers at odd indexes"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter",
				returnType: "Array",
				args: [{
					name: "function",
					description: "A function to run for each array element. If it returns <code>true</code>, the element will be kept. Consider using <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.",
					type: "Function",
					default: "item => true",
					args: [
						{
							name: "element",
							description: "The value of the current element",
							type: "any"
						},
						{
							name: "index",
							optional: true,
							description: "The position of the current element in the array (starting at 0)",
							type: "number"
						},
						{
							name: "array",
							optional: true,
							description: "The array being processed. Rarely needed.",
							type: "Array"
						},
						{
							name: "thisValue",
							optional: true,
							description: "A value passed to the function as its <code>this</code> value. Rarely needed.",
							type: "any"
						}
					]
				}]
			} },
			find: { doc: {
				name: "find",
				description: "Returns the first element from the array that satisfies the provided condition. The condition is a function that returns <code>true</code> or <code>false</code>. Returns <code>undefined</code> if no matches are found.\n\nIf you need all matching elements, use <code>filter()</code>.",
				examples: [
					{
						example: "[12, 33, 16, 40].find(age => age > 18)",
						evaluated: "33",
						description: "Find first age over 18 (using arrow function notation)"
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].find(name => name.length < 5)",
						evaluated: "'Bob'",
						description: "Find first name under 5 letters long (using arrow function notation)"
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].find(function(name) { return name.length < 5 })",
						evaluated: "'Bob'",
						description: "Or using traditional function notation"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find",
				returnType: "Array | undefined",
				args: [{
					name: "function",
					description: "A function to run for each array element. As soon as it returns <code>true</code>, that element will be returned. Consider using <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.",
					type: "Function",
					default: "item => true",
					args: [
						{
							name: "element",
							description: "The value of the current element",
							type: "any"
						},
						{
							name: "index",
							optional: true,
							description: "The position of the current element in the array (starting at 0)",
							type: "number"
						},
						{
							name: "array",
							optional: true,
							description: "The array being processed. Rarely needed.",
							type: "Array"
						},
						{
							name: "thisValue",
							optional: true,
							description: "A value passed to the function as its <code>this</code> value. Rarely needed.",
							type: "any"
						}
					]
				}]
			} },
			findIndex: { doc: {
				name: "findIndex",
				hidden: true,
				description: "Returns the index of the first element in an array that passes the test `fn`. If none are found, -1 is returned.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex",
				returnType: "number",
				args: [{
					name: "fn",
					type: "Function"
				}]
			} },
			findLast: { doc: {
				name: "findLast",
				hidden: true,
				description: "Returns the value of the last element that passes the test `fn`.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast",
				returnType: "any | undefined",
				args: [{
					name: "fn",
					type: "Function"
				}]
			} },
			findLastIndex: { doc: {
				name: "findLastIndex",
				hidden: true,
				description: "Returns the index of the last element that satisfies the provided testing function. If none are found, -1 is returned.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex",
				returnType: "number",
				args: [{
					name: "fn",
					type: "Function"
				}]
			} },
			indexOf: { doc: {
				name: "indexOf",
				description: "Returns the position of the first matching element in the array, or -1 if the element isn't found. Positions start at 0.",
				examples: [{
					example: "['Bob', 'Bill', 'Nat'].indexOf('Nat')",
					evaluated: "2"
				}, {
					example: "['Bob', 'Bill', 'Nat'].indexOf('Nathan')",
					evaluated: "-1"
				}],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf",
				returnType: "number",
				args: [{
					name: "element",
					description: "The value to look for",
					type: "any"
				}, {
					name: "start",
					optional: true,
					description: "The index to start looking from",
					default: "0",
					type: "number"
				}]
			} },
			includes: { doc: {
				name: "includes",
				description: "Returns <code>true</code> if the array contains the specified element",
				examples: [{
					example: "['Bob', 'Bill', 'Nat'].includes('Nat')",
					evaluated: "true"
				}, {
					example: "['Bob', 'Bill', 'Nat'].includes('Nathan')",
					evaluated: "false"
				}],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes",
				returnType: "boolean",
				args: [{
					name: "element",
					description: "The value to search the array for",
					type: "any"
				}, {
					name: "start",
					optional: true,
					description: "The index to start looking from",
					default: "0",
					type: "number"
				}]
			} },
			join: { doc: {
				name: "join",
				description: "Merges all elements of the array into a single string, with an optional separator between each element.\n\nThe opposite of <code>String.split()</code>.",
				examples: [
					{
						example: "['Wind', 'Water', 'Fire'].join(' + ')",
						evaluated: "'Wind + Water + Fire'"
					},
					{
						example: "['Wind', 'Water', 'Fire'].join()",
						evaluated: "'Wind,Water,Fire'"
					},
					{
						example: "['Wind', 'Water', 'Fire'].join('')",
						evaluated: "'WindWaterFire'"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join",
				returnType: "string",
				args: [{
					name: "separator",
					optional: true,
					description: "The character(s) to insert between each element",
					default: "','",
					type: "string"
				}]
			} },
			map: { doc: {
				name: "map",
				description: "Creates a new array by applying a function to each element of the original array",
				examples: [
					{
						example: "[12, 33, 16].map(num => num * 2)",
						evaluated: "[24, 66, 32]",
						description: "Double all numbers (using arrow function notation)"
					},
					{
						example: "['hello', 'old', 'chap'].map(word => word.toUpperCase())",
						evaluated: "['HELLO', 'OLD', 'CHAP']]",
						description: "Convert elements to uppercase (using arrow function notation)"
					},
					{
						example: "['hello', 'old', 'chap'].map(function(word) { return word.toUpperCase() })",
						evaluated: "['HELLO', 'OLD', 'CHAP']]",
						description: "Or using traditional function notation"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",
				returnType: "Array",
				args: [{
					name: "function",
					description: "A function to run for each array element. In the new array, the output of this function takes the place of the element. Consider using <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.",
					type: "Function",
					default: "item => item",
					args: [
						{
							name: "element",
							description: "The value of the current element",
							type: "any"
						},
						{
							name: "index",
							optional: true,
							description: "The position of the current element in the array (starting at 0)",
							type: "number"
						},
						{
							name: "array",
							optional: true,
							description: "The array being processed. Rarely needed.",
							type: "Array"
						},
						{
							name: "thisValue",
							optional: true,
							description: "A value passed to the function as its <code>this</code> value. Rarely needed.",
							type: "any"
						}
					]
				}]
			} },
			reverse: { doc: {
				name: "reverse",
				description: "Reverses the order of the elements in the array",
				examples: [{
					example: "['dog', 'bites', 'man'].reverse()",
					evaluated: "['man', 'bites', 'dog']"
				}],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse",
				returnType: "Array"
			} },
			reduce: { doc: {
				name: "reduce",
				description: "Executes a \"reducer\" function `fn` on each element of the array. Passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce",
				returnType: "any",
				args: [{
					name: "function",
					description: "A function to run for each array element. Takes the accumulated result and the current element, and returns a new accumulated result. Consider using <a target=\"_blank\" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.",
					type: "Function",
					default: "item => item",
					args: [
						{
							name: "prevResult",
							description: "The accumulated result from applying the function to previous elements. When processing the first element, it’s set to <code>initResult</code> (or the first array element if not specified).",
							type: "any"
						},
						{
							name: "currentElem",
							description: "The value in the array currently being processed",
							type: "any"
						},
						{
							name: "index",
							optional: true,
							description: "The position of the current element in the array (starting at 0)",
							type: "number"
						},
						{
							name: "array",
							optional: true,
							description: "The array being processed. Rarely needed.",
							type: "Array"
						}
					]
				}, {
					name: "initResult",
					optional: true,
					description: "The initial value of the prevResult, used when calling the function on the first array element. When not specified it's set to the first array element, and the first function call is on the second array element instead of the first.",
					type: "any"
				}]
			} },
			slice: { doc: {
				name: "slice",
				description: "Returns a portion of the array, from the <code>start</code> index up to (but not including) the <code>end</code> index. Indexes start at 0.",
				examples: [
					{
						example: "[1, 2, 3, 4, 5].slice(2, 4)",
						evaluated: "[3, 4]"
					},
					{
						example: "[1, 2, 3, 4, 5].slice(2)",
						evaluated: "[3, 4, 5]"
					},
					{
						example: "[1, 2, 3, 4, 5].slice(-2)",
						evaluated: "[4, 5]"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice",
				returnType: "Array",
				args: [{
					name: "start",
					optional: true,
					description: "The position to start from. Positions start at 0. Negative numbers count back from the end of the array.",
					default: "0",
					type: "number"
				}, {
					name: "end",
					optional: true,
					description: "The position to select up to. The element at the end position is not included. Negative numbers select from the end of the array. If omitted, will extract to the end of the array.",
					type: "number"
				}]
			} },
			sort: { doc: {
				name: "sort",
				description: "Reorders the elements of the array. For sorting strings alphabetically, no parameter is required. For sorting numbers or Objects, see examples.",
				examples: [
					{
						example: "['d', 'a', 'c', 'b'].sort()",
						evaluated: "['a', 'b', 'c', 'd']",
						description: "No need for a param when sorting strings"
					},
					{
						example: "[4, 2, 1, 3].sort((a, b) => (a - b))",
						evaluated: "[1, 2, 3, 4]",
						description: "To sort numbers, you must use a function"
					},
					{
						example: "[4, 2, 1, 3].sort(function(a, b) { return a - b })",
						evaluated: "[1, 2, 3, 4]",
						description: "Or using traditional function notation"
					},
					{ example: "Sort in reverse alphabetical order" },
					{ example: "arr = ['d', 'a', 'c', 'b']" },
					{
						example: "arr.sort((a, b) => b.localeCompare(a))",
						evaluated: "['d', 'c', 'b', 'a']",
						description: "Sort in reverse alphabetical order"
					},
					{
						example: "[{name:'Zak'}, {name:'Abe'}, {name:'Bob'}].sort((a, b) => a.name.localeCompare(b.name))",
						evaluated: "[{name:'Abe'}, {name:'Bob'}, {name:'Zak'}]",
						description: "Sort array of objects by a property"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort",
				returnType: "Array",
				args: [{
					name: "compare",
					optional: true,
					description: "A function to compare two array elements and return a number indicating which one comes first:\n<b>Return < 0</b>: <code>a</code> comes before <code>b</code>\n<b>Return 0</b>: <code>a</code> and <code>b</code> are equal (leave order unchanged)\n<b>Return > 0</b>: <code>b</code> comes before <code>a</code>\n\nIf no function is specified, converts all values to strings and compares their character codes.",
					default: "\"\"",
					type: "(a, b) => number",
					args: [{
						name: "a",
						description: "The first element to compare in the function",
						type: "any"
					}, {
						name: "b",
						description: "The second element to compare in the function",
						type: "any"
					}]
				}]
			} },
			splice: { doc: {
				name: "splice",
				description: "Changes the contents of an array by removing or replacing existing elements.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice",
				returnType: "Array",
				hidden: true,
				args: [
					{
						name: "start",
						type: "number"
					},
					{
						name: "deleteCount?",
						type: "number"
					},
					{
						name: "item1?",
						type: "Element"
					},
					{ name: "..." },
					{
						name: "itemN?",
						type: "Element"
					}
				]
			} },
			toString: { doc: {
				name: "toString",
				hidden: true,
				description: "Returns a string representing the specified array and its elements.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString",
				returnType: "string"
			} },
			toSpliced: { doc: {
				name: "toSpliced",
				description: "Adds and/or removes array elements at a given position. \n\nSee also <code>slice()</code> and <code>append()</code>.",
				examples: [
					{
						example: "['Jan', 'Mar'.toSpliced(1, 0, 'Feb')",
						evaluated: "['Jan', 'Feb', 'Mar']",
						description: "Insert element at index 1"
					},
					{
						example: "[\"don't\", \"make\", \"me\", \"do\", \"this\"].toSpliced(1, 2)",
						evaluated: "[\"don't\", \"do\", \"this\"]",
						description: "Delete 2 elements starting at index 1"
					},
					{
						example: "[\"don't\", \"be\", \"evil\"].toSpliced(1, 2, \"eat\", \"slugs\")",
						evaluated: "[\"don't\", \"eat\", \"slugs\"]",
						description: "Replace 2 elements starting at index 1"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced",
				returnType: "Array",
				args: [
					{
						name: "start",
						description: "The index (position) to add or remove elements at.  New elements are inserted before the element at this index. A negative index counts back from the end of the array. ",
						type: "number"
					},
					{
						name: "deleteCount",
						optional: true,
						description: "The number of elements to remove. If omitted, removes all elements from the <code>start</code> index onwards.",
						type: "number"
					},
					{
						name: "elements",
						optional: true,
						variadic: true,
						description: "The elements to be added, in order",
						type: "any"
					}
				]
			} }
		}
	},
	{
		typeName: "Number",
		functions: {
			toFixed: { doc: {
				name: "toFixed",
				hidden: true,
				description: "Formats a number using fixed-point notation. `digits` defaults to null if not given.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed",
				returnType: "string",
				args: [{
					name: "digits?",
					type: "number"
				}]
			} },
			toPrecision: { doc: {
				name: "toPrecision",
				hidden: true,
				description: "Returns a string representing the number to the specified precision.",
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision",
				returnType: "string",
				args: [{
					name: "precision?",
					type: "number"
				}]
			} },
			toString: { doc: {
				name: "toString",
				description: "Converts the number to a string. For more formatting options, see <code>toLocaleString()</code>.",
				examples: [
					{
						example: "(2).toString()",
						evaluated: "'2'"
					},
					{
						example: "(50.125).toString()",
						evaluated: "'50.125'"
					},
					{
						example: "(5).toString(2)",
						evaluated: "'101'"
					},
					{
						example: "(412).toString(16)",
						evaluated: "'19c'"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString",
				args: [{
					name: "base",
					optional: true,
					description: "The base to use. Must be an integer between 2 and 36. E.g. base <code>2</code> is binary and base <code>16</code> is hexadecimal.",
					default: "10",
					type: "number"
				}],
				returnType: "string"
			} },
			toLocaleString: { doc: {
				name: "toLocaleString",
				description: "Returns a localized string representing the number, i.e. in the language and format corresponding to its locale. Defaults to the system's locale if none specified.",
				examples: [
					{
						example: "(500000.125).toLocaleString()",
						evaluated: "'500,000.125' (if in US English locale)"
					},
					{
						example: "(500000.125).toLocaleString('fr-FR')",
						evaluated: "'500 000,125'"
					},
					{
						example: "(500000.125).toLocaleString('fr-FR', {style:'currency', currency:'EUR'})",
						evaluated: "'500 000,13 €'"
					}
				],
				docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString",
				args: [{
					name: "locale(s)",
					optional: true,
					description: "The locale to use, e.g. 'en-GB' for British English or 'pt-BR' for Brazilian Portuguese. See <a target=\"_blank\" href=\"https://www.localeplanet.com/icu/\">full list</a> (unofficial). Also accepts an <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument\">array of locales</a>. Defaults to the system locale if not specified.",
					type: "string | string[]"
				}, {
					name: "options",
					optional: true,
					description: "An object with <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters\">formatting options</a>",
					type: "object"
				}],
				returnType: "string"
			} }
		}
	},
	{
		typeName: "Object",
		functions: {}
	},
	{
		typeName: "Boolean",
		functions: { toString: { doc: {
			name: "toString",
			description: "Converts <code>true</code> to the string <code>'true'</code> and <code>false</code> to the string <code>'false'</code>.",
			examples: [{
				example: "true.toString()",
				evaluated: "'true'"
			}, {
				example: "false.toString()",
				evaluated: "'false'"
			}],
			docURL: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean/toString",
			returnType: "string"
		} } }
	}
];
function resolveRelativePath(fullPathWithParameters, candidateRelativePath) {
	if (candidateRelativePath.startsWith("&")) {
		const resolvedLeaf = candidateRelativePath.slice(1);
		const pathToLeaf = fullPathWithParameters.split(".").slice(1, -1).join(".");
		if (!pathToLeaf) return resolvedLeaf;
		return `${pathToLeaf}.${resolvedLeaf}`;
	}
	return candidateRelativePath;
}
var schemaValidator = lazyType(() => objectType({
	type: enumType([
		"string",
		"number",
		"boolean",
		"bigint",
		"symbol",
		"array",
		"object",
		"function",
		"null",
		"undefined"
	]),
	key: stringType().optional(),
	value: unionType([stringType(), lazyType(() => schemaValidator.array())]),
	path: stringType()
}));
numberType().min(1).refine((val) => {
	const parts = String(val).split(".");
	return parts.length === 1 && !isNaN(Number(parts[0])) || parts.length === 2 && !isNaN(Number(parts[0])) && !isNaN(Number(parts[1]));
}, { message: "Invalid node version. Must be in format: major.minor" });
const DEFAULT_OPERATIONS = [
	"create",
	"read",
	"update",
	"delete",
	"list"
];
const RESOURCES = {
	annotationTag: [...DEFAULT_OPERATIONS],
	auditLogs: ["manage"],
	banner: ["dismiss"],
	community: ["register"],
	communityPackage: [
		"install",
		"uninstall",
		"update",
		"list",
		"manage"
	],
	credential: [
		"share",
		"move",
		...DEFAULT_OPERATIONS
	],
	externalSecretsProvider: ["sync", ...DEFAULT_OPERATIONS],
	externalSecret: ["list", "use"],
	eventBusDestination: ["test", ...DEFAULT_OPERATIONS],
	ldap: ["sync", "manage"],
	license: ["manage"],
	logStreaming: ["manage"],
	orchestration: ["read", "list"],
	project: [...DEFAULT_OPERATIONS],
	saml: ["manage"],
	securityAudit: ["generate"],
	sourceControl: [
		"pull",
		"push",
		"manage"
	],
	tag: [...DEFAULT_OPERATIONS],
	user: [
		"resetPassword",
		"changeRole",
		"enforceMfa",
		...DEFAULT_OPERATIONS
	],
	variable: [...DEFAULT_OPERATIONS],
	projectVariable: [...DEFAULT_OPERATIONS],
	workersView: ["manage"],
	workflow: [
		"share",
		"execute",
		"move",
		"activate",
		"deactivate",
		...DEFAULT_OPERATIONS
	],
	folder: [...DEFAULT_OPERATIONS, "move"],
	insights: ["list"],
	oidc: ["manage"],
	provisioning: ["manage"],
	dataTable: [
		...DEFAULT_OPERATIONS,
		"readRow",
		"writeRow",
		"listProject"
	],
	execution: [
		"delete",
		"read",
		"retry",
		"list",
		"get"
	],
	workflowTags: ["update", "list"],
	role: ["manage"],
	mcp: ["manage"],
	mcpApiKey: ["create", "rotate"],
	chatHub: ["manage", "message"]
};
const API_KEY_RESOURCES = {
	tag: [...DEFAULT_OPERATIONS],
	workflow: [
		...DEFAULT_OPERATIONS,
		"move",
		"activate",
		"deactivate"
	],
	variable: [
		"create",
		"update",
		"delete",
		"list"
	],
	securityAudit: ["generate"],
	project: [
		"create",
		"update",
		"delete",
		"list"
	],
	user: [
		"read",
		"list",
		"create",
		"changeRole",
		"delete",
		"enforceMfa"
	],
	execution: [
		"delete",
		"read",
		"retry",
		"list",
		"get"
	],
	credential: [
		"create",
		"move",
		"delete"
	],
	sourceControl: ["pull"],
	workflowTags: ["update", "list"]
};
const PROJECT_OWNER_ROLE_SLUG = "project:personalOwner";
const PROJECT_ADMIN_ROLE_SLUG = "project:admin";
const PROJECT_EDITOR_ROLE_SLUG = "project:editor";
const PROJECT_VIEWER_ROLE_SLUG = "project:viewer";
function buildResourceScopes() {
	const resourceScopes = Object.entries(RESOURCES).flatMap(([resource, operations]) => [...operations.map((op) => `${resource}:${op}`), `${resource}:*`]);
	resourceScopes.push("*");
	return resourceScopes;
}
function buildApiKeyScopes() {
	const apiKeyScopes = Object.entries(API_KEY_RESOURCES).flatMap(([resource, operations]) => [...operations.map((op) => `${resource}:${op}`)]);
	return new Set(apiKeyScopes);
}
const ALL_SCOPES = buildResourceScopes();
buildApiKeyScopes();
const GLOBAL_OWNER_SCOPES = [
	"annotationTag:create",
	"annotationTag:read",
	"annotationTag:update",
	"annotationTag:delete",
	"annotationTag:list",
	"auditLogs:manage",
	"banner:dismiss",
	"credential:create",
	"credential:read",
	"credential:update",
	"credential:delete",
	"credential:list",
	"credential:share",
	"credential:move",
	"community:register",
	"communityPackage:install",
	"communityPackage:uninstall",
	"communityPackage:update",
	"communityPackage:list",
	"eventBusDestination:create",
	"eventBusDestination:read",
	"eventBusDestination:update",
	"eventBusDestination:delete",
	"eventBusDestination:list",
	"eventBusDestination:test",
	"externalSecretsProvider:create",
	"externalSecretsProvider:read",
	"externalSecretsProvider:update",
	"externalSecretsProvider:delete",
	"externalSecretsProvider:list",
	"externalSecretsProvider:sync",
	"externalSecret:list",
	"externalSecret:use",
	"ldap:manage",
	"ldap:sync",
	"license:manage",
	"logStreaming:manage",
	"orchestration:read",
	"saml:manage",
	"securityAudit:generate",
	"sourceControl:pull",
	"sourceControl:push",
	"sourceControl:manage",
	"tag:create",
	"tag:read",
	"tag:update",
	"tag:delete",
	"tag:list",
	"user:create",
	"user:read",
	"user:update",
	"user:delete",
	"user:list",
	"user:resetPassword",
	"user:changeRole",
	"user:enforceMfa",
	"variable:create",
	"variable:read",
	"variable:update",
	"variable:delete",
	"variable:list",
	"projectVariable:create",
	"projectVariable:read",
	"projectVariable:update",
	"projectVariable:delete",
	"projectVariable:list",
	"workflow:create",
	"workflow:read",
	"workflow:update",
	"workflow:delete",
	"workflow:list",
	"workflow:share",
	"workflow:execute",
	"workflow:move",
	"workersView:manage",
	"project:list",
	"project:create",
	"project:read",
	"project:update",
	"project:delete",
	"insights:list",
	"folder:move",
	"folder:read",
	"folder:update",
	"folder:delete",
	"folder:create",
	"folder:list",
	"oidc:manage",
	"provisioning:manage",
	"dataTable:list",
	"role:manage",
	"mcp:manage",
	"mcpApiKey:create",
	"mcpApiKey:rotate",
	"chatHub:manage",
	"chatHub:message"
];
const GLOBAL_ADMIN_SCOPES = GLOBAL_OWNER_SCOPES.concat();
const GLOBAL_MEMBER_SCOPES = [
	"annotationTag:create",
	"annotationTag:read",
	"annotationTag:update",
	"annotationTag:delete",
	"annotationTag:list",
	"eventBusDestination:list",
	"eventBusDestination:test",
	"tag:create",
	"tag:read",
	"tag:update",
	"tag:list",
	"user:list",
	"variable:list",
	"variable:read",
	"dataTable:list",
	"mcpApiKey:create",
	"mcpApiKey:rotate",
	"chatHub:message"
];
const CREDENTIALS_SHARING_OWNER_SCOPES = [
	"credential:read",
	"credential:update",
	"credential:delete",
	"credential:share",
	"credential:move"
];
const CREDENTIALS_SHARING_USER_SCOPES = ["credential:read"];
const REGULAR_PROJECT_ADMIN_SCOPES = [
	"workflow:create",
	"workflow:read",
	"workflow:update",
	"workflow:delete",
	"workflow:list",
	"workflow:execute",
	"workflow:move",
	"credential:create",
	"credential:read",
	"credential:update",
	"credential:delete",
	"credential:list",
	"credential:move",
	"credential:share",
	"project:list",
	"project:read",
	"project:update",
	"project:delete",
	"folder:create",
	"folder:read",
	"folder:update",
	"folder:delete",
	"folder:list",
	"folder:move",
	"sourceControl:push",
	"dataTable:create",
	"dataTable:delete",
	"dataTable:read",
	"dataTable:update",
	"dataTable:listProject",
	"dataTable:readRow",
	"dataTable:writeRow",
	"projectVariable:list",
	"projectVariable:read",
	"projectVariable:create",
	"projectVariable:update",
	"projectVariable:delete"
];
const PERSONAL_PROJECT_OWNER_SCOPES = [
	"workflow:create",
	"workflow:read",
	"workflow:update",
	"workflow:delete",
	"workflow:list",
	"workflow:execute",
	"workflow:share",
	"workflow:move",
	"credential:create",
	"credential:read",
	"credential:update",
	"credential:delete",
	"credential:list",
	"credential:share",
	"credential:move",
	"project:list",
	"project:read",
	"folder:create",
	"folder:read",
	"folder:update",
	"folder:delete",
	"folder:list",
	"folder:move",
	"dataTable:create",
	"dataTable:delete",
	"dataTable:read",
	"dataTable:update",
	"dataTable:listProject",
	"dataTable:readRow",
	"dataTable:writeRow"
];
const PROJECT_EDITOR_SCOPES = [
	"workflow:create",
	"workflow:read",
	"workflow:update",
	"workflow:delete",
	"workflow:list",
	"workflow:execute",
	"credential:create",
	"credential:read",
	"credential:update",
	"credential:delete",
	"credential:list",
	"project:list",
	"project:read",
	"folder:create",
	"folder:read",
	"folder:update",
	"folder:delete",
	"folder:list",
	"dataTable:create",
	"dataTable:delete",
	"dataTable:read",
	"dataTable:update",
	"dataTable:listProject",
	"dataTable:readRow",
	"dataTable:writeRow",
	"projectVariable:list",
	"projectVariable:read",
	"projectVariable:create",
	"projectVariable:update",
	"projectVariable:delete"
];
const PROJECT_VIEWER_SCOPES = [
	"credential:list",
	"credential:read",
	"project:list",
	"project:read",
	"workflow:list",
	"workflow:read",
	"folder:read",
	"folder:list",
	"dataTable:listProject",
	"dataTable:read",
	"dataTable:readRow",
	"projectVariable:list",
	"projectVariable:read"
];
const WORKFLOW_SHARING_OWNER_SCOPES = [
	"workflow:read",
	"workflow:update",
	"workflow:delete",
	"workflow:execute",
	"workflow:share",
	"workflow:move"
];
const WORKFLOW_SHARING_EDITOR_SCOPES = [
	"workflow:read",
	"workflow:update",
	"workflow:execute"
];
const GLOBAL_SCOPE_MAP = {
	"global:owner": GLOBAL_OWNER_SCOPES,
	"global:admin": GLOBAL_ADMIN_SCOPES,
	"global:member": GLOBAL_MEMBER_SCOPES
};
const PROJECT_SCOPE_MAP = {
	"project:admin": REGULAR_PROJECT_ADMIN_SCOPES,
	"project:personalOwner": PERSONAL_PROJECT_OWNER_SCOPES,
	"project:editor": PROJECT_EDITOR_SCOPES,
	"project:viewer": PROJECT_VIEWER_SCOPES
};
const CREDENTIALS_SHARING_SCOPE_MAP = {
	"credential:owner": CREDENTIALS_SHARING_OWNER_SCOPES,
	"credential:user": CREDENTIALS_SHARING_USER_SCOPES
};
const WORKFLOW_SHARING_SCOPE_MAP = {
	"workflow:owner": WORKFLOW_SHARING_OWNER_SCOPES,
	"workflow:editor": WORKFLOW_SHARING_EDITOR_SCOPES
};
const ALL_ROLE_MAPS = {
	global: GLOBAL_SCOPE_MAP,
	project: PROJECT_SCOPE_MAP,
	credential: CREDENTIALS_SHARING_SCOPE_MAP,
	workflow: WORKFLOW_SHARING_SCOPE_MAP
};
const COMBINED_ROLE_MAP = Object.fromEntries(Object.values(ALL_ROLE_MAPS).flatMap((o$1) => Object.entries(o$1)));
function getRoleScopes(role, filters) {
	let scopes = COMBINED_ROLE_MAP[role];
	if (filters) scopes = scopes.filter((s$2) => filters.includes(s$2.split(":")[0]));
	return scopes;
}
var ROLE_NAMES = {
	"global:owner": "Owner",
	"global:admin": "Admin",
	"global:member": "Member",
	[PROJECT_OWNER_ROLE_SLUG]: "Project Owner",
	[PROJECT_ADMIN_ROLE_SLUG]: "Project Admin",
	[PROJECT_EDITOR_ROLE_SLUG]: "Project Editor",
	[PROJECT_VIEWER_ROLE_SLUG]: "Project Viewer",
	"credential:user": "Credential User",
	"credential:owner": "Credential Owner",
	"workflow:owner": "Workflow Owner",
	"workflow:editor": "Workflow Editor"
};
var ROLE_DESCRIPTIONS = {
	"global:owner": "Owner",
	"global:admin": "Admin",
	"global:member": "Member",
	[PROJECT_OWNER_ROLE_SLUG]: "Project Owner",
	[PROJECT_ADMIN_ROLE_SLUG]: "Full control of settings, members, workflows, credentials and executions",
	[PROJECT_EDITOR_ROLE_SLUG]: "Create, edit, and delete workflows, credentials, and executions",
	[PROJECT_VIEWER_ROLE_SLUG]: "Read-only access to workflows, credentials, and executions",
	"credential:user": "Credential User",
	"credential:owner": "Credential Owner",
	"workflow:owner": "Workflow Owner",
	"workflow:editor": "Workflow Editor"
};
var mapToRoleObject = (roles, roleType) => Object.keys(roles).map((role) => ({
	slug: role,
	displayName: ROLE_NAMES[role],
	scopes: getRoleScopes(role),
	description: ROLE_DESCRIPTIONS[role],
	licensed: false,
	systemRole: true,
	roleType
}));
mapToRoleObject(GLOBAL_SCOPE_MAP, "global"), mapToRoleObject(PROJECT_SCOPE_MAP, "project"), mapToRoleObject(CREDENTIALS_SHARING_SCOPE_MAP, "credential"), mapToRoleObject(WORKFLOW_SHARING_SCOPE_MAP, "workflow");
const roleNamespaceSchema = enumType([
	"global",
	"project",
	"credential",
	"workflow"
]);
const globalRoleSchema = enumType([
	"global:owner",
	"global:admin",
	"global:member"
]);
var customGlobalRoleSchema = stringType().nonempty().refine((val) => !globalRoleSchema.safeParse(val).success, { message: "This global role value is not assignable" });
const assignableGlobalRoleSchema = unionType([globalRoleSchema.exclude(["global:owner"]), customGlobalRoleSchema]);
const personalRoleSchema = enumType(["project:personalOwner"]);
const teamRoleSchema = enumType([
	"project:admin",
	"project:editor",
	"project:viewer"
]);
const customProjectRoleSchema = stringType().nonempty().refine((val) => val !== "project:personalOwner" && !teamRoleSchema.safeParse(val).success, { message: "This global role value is not assignable" });
const systemProjectRoleSchema = unionType([personalRoleSchema, teamRoleSchema]);
const assignableProjectRoleSchema = unionType([teamRoleSchema, customProjectRoleSchema]);
const projectRoleSchema = unionType([systemProjectRoleSchema, customProjectRoleSchema]);
enumType(["credential:owner", "credential:user"]);
enumType(["workflow:owner", "workflow:editor"]);
var ALL_SCOPES_LOOKUP_SET = new Set(ALL_SCOPES);
const scopeSchema = stringType().refine((val) => ALL_SCOPES_LOOKUP_SET.has(val), { message: "Invalid scope" });
objectType({
	slug: stringType().min(1),
	displayName: stringType().min(1),
	description: stringType().nullable(),
	systemRole: booleanType(),
	roleType: roleNamespaceSchema,
	licensed: booleanType(),
	scopes: arrayType(scopeSchema),
	createdAt: dateType().optional(),
	updatedAt: dateType().optional(),
	usedByUsers: numberType().optional()
});
function combineScopes(userScopes, masks) {
	const maskedScopes = Object.fromEntries(Object.entries(userScopes).map((e$1) => [e$1[0], [...e$1[1]]]));
	if (masks?.sharing) {
		if (maskedScopes.project) maskedScopes.project = maskedScopes.project.filter((v$3) => masks.sharing.includes(v$3));
		if (maskedScopes.resource) maskedScopes.resource = maskedScopes.resource.filter((v$3) => masks.sharing.includes(v$3));
	}
	return new Set(Object.values(maskedScopes).flat());
}
const hasScope = (scope$1, userScopes, masks, options = { mode: "oneOf" }) => {
	if (!Array.isArray(scope$1)) scope$1 = [scope$1];
	const userScopeSet = combineScopes(userScopes, masks);
	return options.mode === "allOf" ? !!scope$1.length && scope$1.every((s$2) => userScopeSet.has(s$2)) : scope$1.some((s$2) => userScopeSet.has(s$2));
};
const getResourcePermissions = (resourceScopes = []) => Object.keys(RESOURCES).reduce((permissions, key) => ({
	...permissions,
	[key]: resourceScopes.reduce((resourcePermissions, scope$1) => {
		const [prefix, suffix] = scope$1.split(":");
		if (prefix === key) return {
			...resourcePermissions,
			[suffix]: true
		};
		return resourcePermissions;
	}, {})
}), {});
arrayType(objectType({
	email: stringType().email(),
	role: assignableGlobalRoleSchema.default("global:member")
}));
var minLength = 8;
var maxLength = 64;
stringType().min(minLength, `Password must be ${minLength} to ${maxLength} characters long.`).max(maxLength, `Password must be ${minLength} to ${maxLength} characters long.`).refine((password) => /\d/.test(password), { message: "Password must contain at least 1 number." }).refine((password) => /[A-Z]/.test(password), { message: "Password must contain at least 1 uppercase letter." });
enumType([
	"V1",
	"TRIAL_OVER",
	"TRIAL",
	"NON_PRODUCTION_LICENSE",
	"EMAIL_CONFIRMATION",
	"DATA_TABLE_STORAGE_LIMIT_WARNING",
	"DATA_TABLE_STORAGE_LIMIT_ERROR"
]);
stringType().min(10, "Token too short");
const projectNameSchema = stringType().min(1).max(255);
enumType(["personal", "team"]);
const projectIconSchema = objectType({
	type: enumType(["emoji", "icon"]),
	value: stringType().min(1)
});
const projectDescriptionSchema = stringType().max(512);
objectType({
	userId: stringType().min(1),
	role: assignableProjectRoleSchema
});
projectNameSchema.optional(), projectIconSchema.optional(), projectDescriptionSchema.optional();
enumType(["redirect", "post"]);
objectType({
	prefix: stringType().default("ds"),
	location: objectType({
		reference: stringType(),
		action: enumType([
			"before",
			"after",
			"prepend",
			"append"
		])
	})
});
require_lib$1();
var FileTypeSchema = enumType([
	"credential",
	"workflow",
	"tags",
	"variables",
	"file",
	"folders",
	"project"
]);
const SOURCE_CONTROL_FILE_TYPE = FileTypeSchema.Values;
var FileStatusSchema = enumType([
	"new",
	"modified",
	"deleted",
	"created",
	"renamed",
	"conflicted",
	"ignored",
	"staged",
	"unknown"
]);
const SOURCE_CONTROL_FILE_STATUS = FileStatusSchema.Values;
var FileLocationSchema = enumType(["local", "remote"]);
const SOURCE_CONTROL_FILE_LOCATION = FileLocationSchema.Values;
var ResourceOwnerSchema = objectType({
	type: enumType(["personal", "team"]),
	projectId: stringType(),
	projectName: stringType()
});
objectType({
	file: stringType(),
	id: stringType(),
	name: stringType(),
	type: FileTypeSchema,
	status: FileStatusSchema,
	location: FileLocationSchema,
	conflict: booleanType(),
	updatedAt: stringType(),
	pushed: booleanType().optional(),
	owner: ResourceOwnerSchema.optional()
});
const KEY_NAME_REGEX = /^[A-Za-z0-9_]+$/;
const VALUE_MAX_LENGTH = 1e3;
const TYPE_ENUM = ["string"];
const TYPE_DEFAULT = "string";
stringType().min(1, "key must be at least 1 character long").max(50, "key cannot be longer than 50 characters").regex(KEY_NAME_REGEX, "key can only contain characters A-Za-z0-9_");
stringType().max(VALUE_MAX_LENGTH, `value cannot be longer than ${VALUE_MAX_LENGTH} characters`);
enumType(TYPE_ENUM).default(TYPE_DEFAULT);
enumType(["true", "false"]).transform((value) => value === "true");
arrayType(stringType().regex(/^[a-zA-Z]+:[a-zA-Z]+$/, "Each scope must follow the format '{resource}:{scope}' with only letters (e.g., 'workflow:create')")).min(1).transform((scopes) => {
	return scopes;
});
require_lib$1();
var illegalCharacterRegex = /[[\]^\\/:*?"<>|]/;
var dotsOnlyRegex = /^\.+$/;
var FOLDER_NAME_MAX_LENGTH = 128;
stringType().trim().superRefine((name, ctx) => {
	if (name === "") {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Folder name cannot be empty"
		});
		return;
	}
	if (illegalCharacterRegex.test(name)) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Folder name contains invalid characters"
		});
		return;
	}
	if (dotsOnlyRegex.test(name)) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Folder name cannot consist of dots only"
		});
		return;
	}
	if (name.startsWith(".")) ctx.addIssue({
		code: ZodIssueCode.custom,
		message: "Folder name cannot start with a dot"
	});
}).pipe(stringType().max(FOLDER_NAME_MAX_LENGTH, { message: `Folder name cannot be longer than ${FOLDER_NAME_MAX_LENGTH} characters` }));
stringType().max(36);
var VALID_SELECT_FIELDS = [
	"id",
	"name",
	"createdAt",
	"updatedAt",
	"project",
	"tags",
	"parentFolder",
	"workflowCount",
	"subFolderCount",
	"path"
];
var VALID_SORT_OPTIONS$2 = [
	"name:asc",
	"name:desc",
	"createdAt:asc",
	"createdAt:desc",
	"updatedAt:asc",
	"updatedAt:desc"
];
const filterSchema$1 = objectType({
	parentFolderId: stringType().optional(),
	name: stringType().optional(),
	tags: arrayType(stringType()).optional(),
	excludeFolderIdAndDescendants: stringType().optional()
}).strict();
stringType().optional().transform((val, ctx) => {
	if (!val) return void 0;
	try {
		const parsed = jsonParse(val);
		try {
			return filterSchema$1.parse(parsed);
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: "Invalid filter fields",
				path: ["filter"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid filter format",
			path: ["filter"]
		});
		return NEVER;
	}
});
stringType().optional().transform((val) => val ? parseInt(val, 10) : 0).refine((val) => !isNaN(val), { message: "Skip must be a valid number" });
stringType().optional().transform((val) => val ? parseInt(val, 10) : 10).refine((val) => !isNaN(val), { message: "Take must be a valid number" });
var selectFieldsValidator = arrayType(enumType(VALID_SELECT_FIELDS));
stringType().optional().transform((val, ctx) => {
	if (!val) return void 0;
	try {
		const parsed = JSON.parse(val);
		try {
			const selectFields = selectFieldsValidator.parse(parsed);
			if (selectFields.length === 0) return void 0;
			return selectFields.reduce((acc, field) => ({
				...acc,
				[field]: true
			}), {});
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: `Invalid select fields. Valid fields are: ${VALID_SELECT_FIELDS.join(", ")}`,
				path: ["select"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid select format",
			path: ["select"]
		});
		return NEVER;
	}
});
enumType(VALID_SORT_OPTIONS$2, { message: `sortBy must be one of: ${VALID_SORT_OPTIONS$2.join(", ")}` }).optional();
enumType([
	"total",
	"failed",
	"failureRate",
	"timeSaved",
	"averageRunTime"
]);
enumType([
	"count",
	"ratio",
	"millisecond",
	"minute"
]);
objectType({
	total: objectType({
		value: numberType(),
		deviation: unionType([nullType(), numberType()]),
		unit: literalType("count")
	}),
	failed: objectType({
		value: numberType(),
		deviation: unionType([nullType(), numberType()]),
		unit: literalType("count")
	}),
	failureRate: objectType({
		value: numberType(),
		deviation: unionType([nullType(), numberType()]),
		unit: literalType("ratio")
	}),
	timeSaved: objectType({
		value: numberType(),
		deviation: unionType([nullType(), numberType()]),
		unit: literalType("minute")
	}),
	averageRunTime: objectType({
		value: numberType(),
		deviation: unionType([nullType(), numberType()]),
		unit: literalType("millisecond")
	})
}).strict();
objectType({
	count: numberType(),
	data: arrayType(objectType({
		workflowId: stringType().nullable(),
		workflowName: stringType(),
		projectId: stringType().nullable(),
		projectName: stringType(),
		total: numberType(),
		succeeded: numberType(),
		failed: numberType(),
		failureRate: numberType(),
		runTime: numberType(),
		averageRunTime: numberType(),
		timeSaved: numberType()
	}).strict())
}).strict();
objectType({
	date: stringType().refine((val) => !isNaN(Date.parse(val)) && new Date(val).toISOString() === val, { message: "Invalid date format, must be ISO 8601 format" }),
	values: objectType({
		total: numberType(),
		succeeded: numberType(),
		failed: numberType(),
		failureRate: numberType(),
		averageRunTime: numberType(),
		timeSaved: numberType()
	}).strict()
}).strict();
objectType({
	date: stringType().refine((val) => !isNaN(Date.parse(val)) && new Date(val).toISOString() === val, { message: "Invalid date format, must be ISO 8601 format" }),
	values: objectType({ timeSaved: numberType() }).strict()
}).strict();
var VALID_DATE_RANGE_OPTIONS = objectType({
	key: enumType([
		"day",
		"week",
		"2weeks",
		"month",
		"quarter",
		"6months",
		"year"
	]),
	licensed: booleanType(),
	granularity: enumType([
		"hour",
		"day",
		"week"
	])
}).strict().shape.key.options;
enumType(VALID_DATE_RANGE_OPTIONS).optional();
stringType().optional().transform((val) => val ? parseInt(val, 10) : 0).refine((val) => !isNaN(val) && Number.isInteger(val), { message: "Param `skip` must be a valid integer" }).refine((val) => val >= 0, { message: "Param `skip` must be a non-negative integer" });
const createTakeValidator = (maxItems, allowInfinity = false) => stringType().optional().transform((val) => val ? parseInt(val, 10) : 10).refine((val) => !isNaN(val) && Number.isInteger(val), { message: "Param `take` must be a valid integer" }).refine((val) => {
	if (!allowInfinity) return val >= 0;
	return true;
}, { message: "Param `take` must be a non-negative integer" }).transform((val) => Math.min(val, maxItems));
createTakeValidator(50);
var VALID_SORT_OPTIONS$1 = [
	"total:asc",
	"total:desc",
	"succeeded:asc",
	"succeeded:desc",
	"failed:asc",
	"failed:desc",
	"failureRate:asc",
	"failureRate:desc",
	"timeSaved:asc",
	"timeSaved:desc",
	"runTime:asc",
	"runTime:desc",
	"averageRunTime:asc",
	"averageRunTime:desc",
	"workflowName:asc",
	"workflowName:desc"
];
enumType(VALID_SORT_OPTIONS$1, { message: `sortBy must be one of: ${VALID_SORT_OPTIONS$1.join(", ")}` }).optional();
const USERS_LIST_SORT_OPTIONS = [
	"firstName:asc",
	"firstName:desc",
	"lastName:asc",
	"lastName:desc",
	"email:asc",
	"email:desc",
	"role:asc",
	"role:desc",
	"mfaEnabled:asc",
	"mfaEnabled:desc",
	"lastActiveAt:asc",
	"lastActiveAt:desc"
];
arrayType(enumType(USERS_LIST_SORT_OPTIONS, { message: `sortBy must be one of: ${USERS_LIST_SORT_OPTIONS.join(", ")}` })).optional();
arrayType(enumType([
	"id",
	"firstName",
	"lastName",
	"email",
	"disabled",
	"mfaEnabled",
	"role"
]));
var userFilterSchema = objectType({
	isOwner: booleanType().optional(),
	firstName: stringType().optional(),
	lastName: stringType().optional(),
	email: stringType().optional(),
	mfaEnabled: booleanType().optional(),
	fullText: stringType().optional()
});
stringType().optional().transform((val, ctx) => {
	if (!val) return void 0;
	try {
		const parsed = jsonParse(val);
		try {
			return userFilterSchema.parse(parsed);
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: "Invalid filter fields",
				path: ["filter"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid filter format",
			path: ["filter"]
		});
		return NEVER;
	}
});
arrayType(enumType(["projectRelations"]));
unionType([
	literalType("all"),
	literalType("count"),
	literalType("id")
]);
const dataTableNameSchema = stringType().trim().min(1).max(128);
const dataTableIdSchema = stringType().max(36);
const DATA_TABLE_COLUMN_REGEX = /^[a-zA-Z][a-zA-Z0-9_]*$/;
const dataTableColumnNameSchema = stringType().trim().min(1).max(63).regex(DATA_TABLE_COLUMN_REGEX, "Only alphabetical characters and non-leading numbers and underscores are allowed for column names, and the maximum length is 63 characters.");
objectType({
	id: dataTableIdSchema,
	name: dataTableNameSchema,
	columns: arrayType(objectType({
		name: dataTableColumnNameSchema,
		type: enumType([
			"string",
			"number",
			"boolean",
			"date"
		]),
		index: numberType().optional()
	}).extend({ dataTableId: dataTableIdSchema })),
	createdAt: stringType().datetime(),
	updatedAt: stringType().datetime()
});
stringType().datetime({ offset: true }).transform((s$2) => new Date(s$2)).pipe(dateType());
const dataTableColumnValueSchema = unionType([
	stringType(),
	numberType(),
	booleanType(),
	nullType(),
	dateType()
]);
const dataTableFilterRecordSchema = objectType({
	columnName: dataTableColumnNameSchema,
	condition: unionType([
		literalType("eq"),
		literalType("neq"),
		literalType("like"),
		literalType("ilike"),
		literalType("gt"),
		literalType("gte"),
		literalType("lt"),
		literalType("lte")
	]).default("eq"),
	value: unionType([
		stringType(),
		numberType(),
		booleanType(),
		dateType(),
		nullType()
	])
});
const dataTableFilterSchema = objectType({
	type: unionType([literalType("and"), literalType("or")]).default("and"),
	filters: arrayType(dataTableFilterRecordSchema).default([])
});
dataTableFilterSchema.refine((filter) => filter.filters.length > 0, { message: "filter must not be empty" }), recordType(dataTableColumnNameSchema, dataTableColumnValueSchema).refine((obj) => Object.keys(obj).length > 0, { message: "data must not be empty" }), booleanType().optional().default(false), booleanType().optional().default(false);
stringType().transform((val, ctx) => {
	if (!val) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Filter is required for delete operations",
			path: ["filter"]
		});
		return NEVER;
	}
	try {
		const parsed = jsonParse(val);
		try {
			const result = dataTableFilterSchema.parse(parsed);
			if (!result.filters || result.filters.length === 0) {
				ctx.addIssue({
					code: ZodIssueCode.custom,
					message: "At least one filter condition is required for delete operations",
					path: ["filter"]
				});
				return NEVER;
			}
			return result;
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: "Invalid filter fields",
				path: ["filter"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid filter format",
			path: ["filter"]
		});
		return NEVER;
	}
});
unionType([stringType(), booleanType()]).optional().transform((val) => {
	if (typeof val === "string") return val === "true";
	return val ?? false;
});
dataTableFilterSchema.refine((filter) => filter.filters.length > 0, { message: "filter must not be empty" }), recordType(dataTableColumnNameSchema, dataTableColumnValueSchema).refine((obj) => Object.keys(obj).length > 0, { message: "data must not be empty" }), booleanType().optional().default(false), booleanType().optional().default(false);
var VALID_SORT_OPTIONS = [
	"name:asc",
	"name:desc",
	"createdAt:asc",
	"createdAt:desc",
	"updatedAt:asc",
	"updatedAt:desc",
	"sizeBytes:asc",
	"sizeBytes:desc"
];
var filterSchema = objectType({
	id: unionType([stringType(), arrayType(stringType())]).optional(),
	name: unionType([stringType(), arrayType(stringType())]).optional(),
	projectId: unionType([stringType(), arrayType(stringType())]).optional()
}).strict();
stringType().optional().transform((val, ctx) => {
	if (!val) return void 0;
	try {
		const parsed = jsonParse(val);
		try {
			return filterSchema.parse(parsed);
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: "Invalid filter fields",
				path: ["filter"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid filter format",
			path: ["filter"]
		});
		return NEVER;
	}
});
enumType(VALID_SORT_OPTIONS, { message: `sortBy must be one of: ${VALID_SORT_OPTIONS.join(", ")}` }).optional();
stringType().optional().transform((val, ctx) => {
	if (!val) return void 0;
	try {
		const parsed = jsonParse(val);
		try {
			return dataTableFilterSchema.parse(parsed);
		} catch (e$1) {
			ctx.addIssue({
				code: ZodIssueCode.custom,
				message: "Invalid filter fields",
				path: ["filter"]
			});
			return NEVER;
		}
	} catch (e$1) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid filter format",
			path: ["filter"]
		});
		return NEVER;
	}
});
stringType().optional().transform((val, ctx) => {
	if (val === void 0) return val;
	if (!val.includes(":")) {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid sort format, expected <columnName>:<asc/desc>",
			path: ["sort"]
		});
		return NEVER;
	}
	let [column, direction] = val.split(":");
	try {
		column = dataTableColumnNameSchema.parse(column);
	} catch {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid sort columnName",
			path: ["sort"]
		});
		return NEVER;
	}
	direction = direction?.toUpperCase();
	if (direction !== "ASC" && direction !== "DESC") {
		ctx.addIssue({
			code: ZodIssueCode.custom,
			message: "Invalid sort direction",
			path: ["sort"]
		});
		return NEVER;
	}
	return [column, direction];
});
const chatHubProviderSchema = enumType([
	"openai",
	"anthropic",
	"google"
]);
const PROVIDER_CREDENTIAL_TYPE_MAP = {
	openai: "openAiApi",
	anthropic: "anthropicApi",
	google: "googlePalmApi"
};
const chatHubConversationModelSchema = objectType({
	provider: chatHubProviderSchema,
	model: stringType(),
	workflowId: stringType().nullable().default(null)
});
objectType({ credentials: recordType(chatHubProviderSchema, stringType().nullable()) });
objectType({ type: literalType("heartbeat") });
const createHeartbeatMessage = () => ({ type: "heartbeat" });
const ViewableMimeTypes = [
	"application/json",
	"audio/mpeg",
	"audio/ogg",
	"audio/wav",
	"image/bmp",
	"image/gif",
	"image/jpeg",
	"image/jpg",
	"image/png",
	"image/tiff",
	"image/webp",
	"text/css",
	"text/csv",
	"text/markdown",
	"text/plain",
	"video/mp4",
	"video/ogg",
	"video/webm"
];
const npsSurveySchema = unionType([objectType({
	lastShownAt: numberType(),
	responded: literalType(true)
}), objectType({
	lastShownAt: numberType(),
	waitingForResponse: literalType(true),
	ignoredCount: numberType()
})]);
const userSettingsSchema = objectType({
	isOnboarded: booleanType().optional(),
	firstSuccessfulWorkflowId: stringType().optional(),
	userActivated: booleanType().optional(),
	userActivatedAt: numberType().optional(),
	allowSSOManualLogin: booleanType().optional(),
	npsSurvey: npsSurveySchema.optional(),
	easyAIWorkflowOnboarded: booleanType().optional(),
	userClaimedAiCredits: booleanType().optional(),
	dismissedCallouts: recordType(booleanType()).optional()
});
const ROLE = {
	Owner: "global:owner",
	Member: "global:member",
	Admin: "global:admin",
	Default: "default"
};
const roleSchema = enumType(Object.values(ROLE));
const userProjectSchema = objectType({
	id: stringType(),
	role: projectRoleSchema,
	name: stringType()
});
const userDetailSchema = objectType({
	id: stringType(),
	firstName: stringType().nullable().optional(),
	lastName: stringType().nullable().optional(),
	email: stringType().email().nullable().optional(),
	role: roleSchema.optional()
}).extend({
	isPending: booleanType().optional(),
	isOwner: booleanType().optional(),
	signInType: stringType().optional(),
	settings: userSettingsSchema.nullable().optional(),
	personalizationAnswers: objectType({}).passthrough().nullable().optional(),
	projectRelations: arrayType(userProjectSchema).nullable().optional(),
	mfaEnabled: booleanType().optional(),
	lastActiveAt: stringType().nullable().optional(),
	inviteAcceptUrl: stringType().optional()
});
objectType({
	count: numberType(),
	items: arrayType(userDetailSchema)
});
const DATA_TABLE_VIEW = "data-tables";
const PROJECT_DATA_TABLES = "project-data-tables";
const DATA_TABLE_DETAILS = "data-table-details";
const DATA_TABLE_STORE = "dataTableStore";
const DEFAULT_DATA_TABLE_PAGE_SIZE = 10;
const DATA_TABLE_ID_COLUMN_WIDTH = 60;
const DEFAULT_COLUMN_WIDTH = 250;
const DATA_TABLE_HEADER_HEIGHT = 36;
const DATA_TABLE_ROW_HEIGHT = 33;
const ADD_ROW_ROW_ID = "__n8n_add_row__";
const DATA_TABLE_CARD_ACTIONS = {
	RENAME: "rename",
	DELETE: "delete",
	CLEAR: "clear"
};
const ADD_DATA_TABLE_MODAL_KEY = "addDataTableModal";
const DEFAULT_ID_COLUMN_NAME = "id";
const MAX_COLUMN_NAME_LENGTH = 128;
const COLUMN_NAME_REGEX = DATA_TABLE_COLUMN_REGEX;
const MIN_LOADING_TIME = 500;
const NULL_VALUE = "Null";
const EMPTY_VALUE = "Empty";
const DATA_TABLE_MODULE_NAME = "data-table";
const NUMBER_WITH_SPACES_REGEX = /\B(?=(\d{3})+(?!\d))/g;
const NUMBER_THOUSAND_SEPARATOR = " ";
const NUMBER_DECIMAL_SEPARATOR = ".";
const LOOSE_DATE_REGEX = /^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:[ T]([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2}))?)?$/;
const MAX_WORKFLOW_SIZE = 1024 * 1024 * 16;
const MAX_EXPECTED_REQUEST_SIZE = 2048;
const MAX_PINNED_DATA_SIZE = 1024 * 1024 * 12;
const MAX_DISPLAY_DATA_SIZE = 1024 * 1024;
const MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW = 1024 * 1024 * 4;
const PLACEHOLDER_FILLED_AT_EXECUTION_TIME = "[filled at execution time]";
const IN_PROGRESS_EXECUTION_ID = "__IN_PROGRESS__";
const CUSTOM_API_CALL_KEY = "__CUSTOM_API_CALL__";
const PLACEHOLDER_EMPTY_WORKFLOW_ID = "__EMPTY__";
const NEW_WORKFLOW_ID = "new";
const DEFAULT_NODETYPE_VERSION = 1;
const DEFAULT_NEW_WORKFLOW_NAME = "My workflow";
const MAX_WORKFLOW_NAME_LENGTH = 128;
const DUPLICATE_POSTFFIX = " copy";
const DEFAULT_WORKFLOW_PAGE_SIZE = 50;
const MAX_TAG_NAME_LENGTH = 24;
const ABOUT_MODAL_KEY = "about";
const CHAT_EMBED_MODAL_KEY = "chatEmbed";
const CHANGE_PASSWORD_MODAL_KEY = "changePassword";
const CONFIRM_PASSWORD_MODAL_KEY = "confirmPassword";
const DUPLICATE_MODAL_KEY = "duplicate";
const IMPORT_WORKFLOW_URL_MODAL_KEY = "importWorkflowUrl";
const TAGS_MANAGER_MODAL_KEY = "tagsManager";
const ANNOTATION_TAGS_MANAGER_MODAL_KEY = "annotationTagsManager";
const VERSIONS_MODAL_KEY = "versions";
const WORKFLOW_SETTINGS_MODAL_KEY = "settings";
const WORKFLOW_SHARE_MODAL_KEY = "workflowShare";
const CONTACT_PROMPT_MODAL_KEY = "contactPrompt";
const NODE_PINNING_MODAL_KEY = "nodePinning";
const NPS_SURVEY_MODAL_KEY = "npsSurvey";
const WORKFLOW_ACTIVE_MODAL_KEY = "activation";
const IMPORT_CURL_MODAL_KEY = "importCurl";
const LOG_STREAM_MODAL_KEY = "settingsLogStream";
const MFA_SETUP_MODAL_KEY = "mfaSetup";
const PROMPT_MFA_CODE_MODAL_KEY = "promptMfaCode";
const WORKFLOW_HISTORY_VERSION_RESTORE = "workflowHistoryVersionRestore";
const SETUP_CREDENTIALS_MODAL_KEY = "setupCredentials";
const NEW_ASSISTANT_SESSION_MODAL = "newAssistantSession";
const EXTERNAL_SECRETS_PROVIDER_MODAL_KEY = "externalSecretsProvider";
const WORKFLOW_ACTIVATION_CONFLICTING_WEBHOOK_MODAL_KEY = "workflowActivationConflictingWebhook";
const FROM_AI_PARAMETERS_MODAL_KEY = "fromAiParameters";
const WORKFLOW_EXTRACTION_NAME_MODAL_KEY = "workflowExtractionName";
const WHATS_NEW_MODAL_KEY = "whatsNew";
const WORKFLOW_DIFF_MODAL_KEY = "workflowDiff";
const PRE_BUILT_AGENTS_MODAL_KEY = "preBuiltAgents";
const CHAT_HUB_SIDE_MENU_DRAWER_MODAL_KEY = "chatHubSideMenuDrawer";
const EXPERIMENT_TEMPLATE_RECO_V2_KEY = "templateRecoV2";
const EXPERIMENT_TEMPLATE_RECO_V3_KEY = "templateRecoV3";
const BREAKPOINT_SM = 768;
const BREAKPOINT_MD = 992;
const BREAKPOINT_LG = 1200;
const BREAKPOINT_XL = 1920;
const DOCS_DOMAIN = "docs.n8n.io";
const BUILTIN_NODES_DOCS_URL = `https://${DOCS_DOMAIN}/integrations/builtin/`;
const BUILTIN_CREDENTIALS_DOCS_URL = `https://${DOCS_DOMAIN}/integrations/builtin/credentials/`;
const DATA_PINNING_DOCS_URL = `https://${DOCS_DOMAIN}/data/data-pinning/`;
const DATA_EDITING_DOCS_URL = `https://${DOCS_DOMAIN}/data/data-editing/`;
const SCHEMA_PREVIEW_DOCS_URL = `https://${DOCS_DOMAIN}/data/schema-preview/`;
const MFA_DOCS_URL = `https://${DOCS_DOMAIN}/user-management/two-factor-auth/`;
const NPM_PACKAGE_DOCS_BASE_URL = "https://www.npmjs.com/package/";
`${DOCS_DOMAIN}`;
const CUSTOM_NODES_DOCS_URL = `https://${DOCS_DOMAIN}/integrations/creating-nodes/code/create-n8n-nodes-module/`;
`${DOCS_DOMAIN}`;
const EVALUATIONS_DOCS_URL = `https://${DOCS_DOMAIN}/advanced-ai/evaluations/overview/`;
const ERROR_WORKFLOW_DOCS_URL = `https://${DOCS_DOMAIN}/flow-logic/error-handling/#create-and-set-an-error-workflow`;
const TIME_SAVED_DOCS_URL = `https://${DOCS_DOMAIN}/insights/#setting-the-time-saved-by-a-workflow`;
const N8N_PRICING_PAGE_URL = "https://n8n.io/pricing";
const N8N_MAIN_GITHUB_REPO_URL = "https://github.com/n8n-io/n8n";
const NODE_MIN_INPUT_ITEMS_COUNT = 4;
const BAMBOO_HR_NODE_TYPE = "n8n-nodes-base.bambooHr";
const CALENDLY_TRIGGER_NODE_TYPE = "n8n-nodes-base.calendlyTrigger";
const CODE_NODE_TYPE = "n8n-nodes-base.code";
const AI_CODE_NODE_TYPE = "@n8n/n8n-nodes-langchain.code";
const AI_MCP_TOOL_NODE_TYPE = "@n8n/n8n-nodes-langchain.mcpClientTool";
const WIKIPEDIA_TOOL_NODE_TYPE = "@n8n/n8n-nodes-langchain.toolWikipedia";
const CRON_NODE_TYPE = "n8n-nodes-base.cron";
const CLEARBIT_NODE_TYPE = "n8n-nodes-base.clearbit";
const FILTER_NODE_TYPE = "n8n-nodes-base.filter";
const GITHUB_TRIGGER_NODE_TYPE = "n8n-nodes-base.githubTrigger";
const GOOGLE_SHEETS_NODE_TYPE = "n8n-nodes-base.googleSheets";
const ERROR_TRIGGER_NODE_TYPE = "n8n-nodes-base.errorTrigger";
const ELASTIC_SECURITY_NODE_TYPE = "n8n-nodes-base.elasticSecurity";
const EMAIL_SEND_NODE_TYPE = "n8n-nodes-base.emailSend";
const EMAIL_IMAP_NODE_TYPE = "n8n-nodes-base.emailReadImap";
const EXECUTE_COMMAND_NODE_TYPE = "n8n-nodes-base.executeCommand";
const FORM_TRIGGER_NODE_TYPE = "n8n-nodes-base.formTrigger";
const HTML_NODE_TYPE = "n8n-nodes-base.html";
const HTTP_REQUEST_NODE_TYPE = "n8n-nodes-base.httpRequest";
const HTTP_REQUEST_TOOL_NODE_TYPE = "n8n-nodes-base.httpRequestTool";
const HUBSPOT_TRIGGER_NODE_TYPE = "n8n-nodes-base.hubspotTrigger";
const IF_NODE_TYPE = "n8n-nodes-base.if";
const INTERVAL_NODE_TYPE = "n8n-nodes-base.interval";
const ITEM_LISTS_NODE_TYPE = "n8n-nodes-base.itemLists";
const JIRA_NODE_TYPE = "n8n-nodes-base.jira";
const JIRA_TRIGGER_NODE_TYPE = "n8n-nodes-base.jiraTrigger";
const MICROSOFT_EXCEL_NODE_TYPE = "n8n-nodes-base.microsoftExcel";
const MANUAL_TRIGGER_NODE_TYPE = "n8n-nodes-base.manualTrigger";
const MANUAL_CHAT_TRIGGER_NODE_TYPE = "@n8n/n8n-nodes-langchain.manualChatTrigger";
const MCP_TRIGGER_NODE_TYPE = "@n8n/n8n-nodes-langchain.mcpTrigger";
const CHAT_TRIGGER_NODE_TYPE = "@n8n/n8n-nodes-langchain.chatTrigger";
const AGENT_NODE_TYPE = "@n8n/n8n-nodes-langchain.agent";
const OPEN_AI_NODE_TYPE = "@n8n/n8n-nodes-langchain.openAi";
const OPEN_AI_NODE_MESSAGE_ASSISTANT_TYPE = "@n8n/n8n-nodes-langchain.openAi.assistant.message";
const OPEN_AI_ASSISTANT_NODE_TYPE = "@n8n/n8n-nodes-langchain.openAiAssistant";
const BASIC_CHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.chainLlm";
const QA_CHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.chainRetrievalQa";
const MICROSOFT_TEAMS_NODE_TYPE = "n8n-nodes-base.microsoftTeams";
const NO_OP_NODE_TYPE = "n8n-nodes-base.noOp";
const STICKY_NODE_TYPE = "n8n-nodes-base.stickyNote";
const NOTION_TRIGGER_NODE_TYPE = "n8n-nodes-base.notionTrigger";
const PAGERDUTY_NODE_TYPE = "n8n-nodes-base.pagerDuty";
const SALESFORCE_NODE_TYPE = "n8n-nodes-base.salesforce";
const SEGMENT_NODE_TYPE = "n8n-nodes-base.segment";
const SET_NODE_TYPE = "n8n-nodes-base.set";
const SCHEDULE_TRIGGER_NODE_TYPE = "n8n-nodes-base.scheduleTrigger";
const SERVICENOW_NODE_TYPE = "n8n-nodes-base.serviceNow";
const SLACK_NODE_TYPE = "n8n-nodes-base.slack";
const SPREADSHEET_FILE_NODE_TYPE = "n8n-nodes-base.spreadsheetFile";
const SPLIT_IN_BATCHES_NODE_TYPE = "n8n-nodes-base.splitInBatches";
const START_NODE_TYPE = "n8n-nodes-base.start";
const SWITCH_NODE_TYPE = "n8n-nodes-base.switch";
const TELEGRAM_NODE_TYPE = "n8n-nodes-base.telegram";
const THE_HIVE_TRIGGER_NODE_TYPE = "n8n-nodes-base.theHiveTrigger";
const QUICKBOOKS_NODE_TYPE = "n8n-nodes-base.quickbooks";
const WAIT_NODE_TYPE = "n8n-nodes-base.wait";
const WEBHOOK_NODE_TYPE = "n8n-nodes-base.webhook";
const WORKABLE_TRIGGER_NODE_TYPE = "n8n-nodes-base.workableTrigger";
const WORKFLOW_TRIGGER_NODE_TYPE = "n8n-nodes-base.workflowTrigger";
const EXECUTE_WORKFLOW_NODE_TYPE = "n8n-nodes-base.executeWorkflow";
const EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE = "n8n-nodes-base.executeWorkflowTrigger";
const WOOCOMMERCE_TRIGGER_NODE_TYPE = "n8n-nodes-base.wooCommerceTrigger";
const XERO_NODE_TYPE = "n8n-nodes-base.xero";
const ZENDESK_NODE_TYPE = "n8n-nodes-base.zendesk";
const ZENDESK_TRIGGER_NODE_TYPE = "n8n-nodes-base.zendeskTrigger";
const DISCORD_NODE_TYPE = "n8n-nodes-base.discord";
const EXTRACT_FROM_FILE_NODE_TYPE = "n8n-nodes-base.extractFromFile";
const CONVERT_TO_FILE_NODE_TYPE = "n8n-nodes-base.convertToFile";
const DATETIME_NODE_TYPE = "n8n-nodes-base.dateTime";
const REMOVE_DUPLICATES_NODE_TYPE = "n8n-nodes-base.removeDuplicates";
const SPLIT_OUT_NODE_TYPE = "n8n-nodes-base.splitOut";
const LIMIT_NODE_TYPE = "n8n-nodes-base.limit";
const SUMMARIZE_NODE_TYPE = "n8n-nodes-base.summarize";
const AGGREGATE_NODE_TYPE = "n8n-nodes-base.aggregate";
const MERGE_NODE_TYPE = "n8n-nodes-base.merge";
const MARKDOWN_NODE_TYPE = "n8n-nodes-base.markdown";
const XML_NODE_TYPE = "n8n-nodes-base.xml";
const CRYPTO_NODE_TYPE = "n8n-nodes-base.crypto";
const RSS_READ_NODE_TYPE = "n8n-nodes-base.rssFeedRead";
const COMPRESSION_NODE_TYPE = "n8n-nodes-base.compression";
const EDIT_IMAGE_NODE_TYPE = "n8n-nodes-base.editImage";
const SIMULATE_NODE_TYPE = "n8n-nodes-base.simulate";
const SIMULATE_TRIGGER_NODE_TYPE = "n8n-nodes-base.simulateTrigger";
const AI_TRANSFORM_NODE_TYPE = "n8n-nodes-base.aiTransform";
const FORM_NODE_TYPE = "n8n-nodes-base.form";
const SLACK_TRIGGER_NODE_TYPE = "n8n-nodes-base.slackTrigger";
const TELEGRAM_TRIGGER_NODE_TYPE = "n8n-nodes-base.telegramTrigger";
const FACEBOOK_LEAD_ADS_TRIGGER_NODE_TYPE = "n8n-nodes-base.facebookLeadAdsTrigger";
const RESPOND_TO_WEBHOOK_NODE_TYPE = "n8n-nodes-base.respondToWebhook";
const DATA_TABLE_NODE_TYPE = "n8n-nodes-base.dataTable";
const DATA_TABLE_TOOL_NODE_TYPE = "n8n-nodes-base.dataTableTool";
const CREDENTIAL_ONLY_NODE_PREFIX = "n8n-creds-base";
const CREDENTIAL_ONLY_HTTP_NODE_VERSION = 4.1;
const TEMPLATE_CATEGORY_AI = "categories/ai";
const DATA_TABLE_NODES = [DATA_TABLE_NODE_TYPE, DATA_TABLE_TOOL_NODE_TYPE];
const EXECUTABLE_TRIGGER_NODE_TYPES = [
	START_NODE_TYPE,
	MANUAL_TRIGGER_NODE_TYPE,
	SCHEDULE_TRIGGER_NODE_TYPE,
	CRON_NODE_TYPE,
	INTERVAL_NODE_TYPE
];
const NON_ACTIVATABLE_TRIGGER_NODE_TYPES = [
	ERROR_TRIGGER_NODE_TYPE,
	MANUAL_TRIGGER_NODE_TYPE,
	EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE,
	MANUAL_CHAT_TRIGGER_NODE_TYPE
];
const NODES_USING_CODE_NODE_EDITOR = [
	CODE_NODE_TYPE,
	AI_CODE_NODE_TYPE,
	AI_TRANSFORM_NODE_TYPE
];
const MODULE_ENABLED_NODES = [...DATA_TABLE_NODES.map((nodeType) => ({
	nodeType,
	module: DATA_TABLE_MODULE_NAME
}))];
const NODE_POSITION_CONFLICT_ALLOWLIST = [STICKY_NODE_TYPE];
const PIN_DATA_NODE_TYPES_DENYLIST = [SPLIT_IN_BATCHES_NODE_TYPE, STICKY_NODE_TYPE];
const OPEN_URL_PANEL_TRIGGER_NODE_TYPES = [
	WEBHOOK_NODE_TYPE,
	FORM_TRIGGER_NODE_TYPE,
	CHAT_TRIGGER_NODE_TYPE,
	MCP_TRIGGER_NODE_TYPE
];
const SINGLE_WEBHOOK_TRIGGERS = [
	TELEGRAM_TRIGGER_NODE_TYPE,
	SLACK_TRIGGER_NODE_TYPE,
	FACEBOOK_LEAD_ADS_TRIGGER_NODE_TYPE
];
const LIST_LIKE_NODE_OPERATIONS = [
	"getAll",
	"getMany",
	"read",
	"search"
];
const PRODUCTION_ONLY_TRIGGER_NODE_TYPES = [CHAT_TRIGGER_NODE_TYPE];
const NODE_CREATOR_OPEN_SOURCES = {
	NO_TRIGGER_EXECUTION_TOOLTIP: "no_trigger_execution_tooltip",
	PLUS_ENDPOINT: "plus_endpoint",
	ADD_INPUT_ENDPOINT: "add_input_endpoint",
	TRIGGER_PLACEHOLDER_BUTTON: "trigger_placeholder_button",
	ADD_NODE_BUTTON: "add_node_button",
	TAB: "tab",
	NODE_CONNECTION_ACTION: "node_connection_action",
	REPLACE_NODE_ACTION: "replace_node_action",
	NODE_CONNECTION_DROP: "node_connection_drop",
	NOTICE_ERROR_MESSAGE: "notice_error_message",
	CONTEXT_MENU: "context_menu",
	ADD_EVALUATION_NODE_BUTTON: "add_evaluation_node_button",
	ADD_EVALUATION_TRIGGER_BUTTON: "add_evaluation_trigger_button",
	TEMPLATES_CALLOUT: "templates_callout",
	"": ""
};
const CORE_NODES_CATEGORY = "Core Nodes";
const HUMAN_IN_THE_LOOP_CATEGORY = "HITL";
const DEFAULT_SUBCATEGORY = "*";
const AI_OTHERS_NODE_CREATOR_VIEW = "AI Other";
const AI_NODE_CREATOR_VIEW = "AI";
const REGULAR_NODE_CREATOR_VIEW = "Regular";
const TRIGGER_NODE_CREATOR_VIEW = "Trigger";
const OTHER_TRIGGER_NODES_SUBCATEGORY = "Other Trigger Nodes";
const TRANSFORM_DATA_SUBCATEGORY = "Data Transformation";
const FLOWS_CONTROL_SUBCATEGORY = "Flow";
const AI_SUBCATEGORY = "AI";
const HELPERS_SUBCATEGORY = "Helpers";
const HITL_SUBCATEGORY = "Human in the Loop";
const AI_CATEGORY_AGENTS = "Agents";
const AI_CATEGORY_CHAINS = "Chains";
const AI_CATEGORY_LANGUAGE_MODELS = "Language Models";
const AI_CATEGORY_MEMORY = "Memory";
const AI_CATEGORY_OUTPUTPARSER = "Output Parsers";
const AI_CATEGORY_TOOLS = "Tools";
const AI_CATEGORY_VECTOR_STORES = "Vector Stores";
const AI_CATEGORY_RETRIEVERS = "Retrievers";
const AI_CATEGORY_EMBEDDING = "Embeddings";
const AI_CATEGORY_DOCUMENT_LOADERS = "Document Loaders";
const AI_CATEGORY_TEXT_SPLITTERS = "Text Splitters";
const AI_CATEGORY_OTHER_TOOLS = "Other Tools";
const AI_CATEGORY_ROOT_NODES = "Root Nodes";
const AI_CATEGORY_MCP_NODES = "Model Context Protocol";
const AI_EVALUATION = "Evaluation";
const AI_UNCATEGORIZED_CATEGORY = "Miscellaneous";
const AI_CODE_TOOL_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.toolCode";
const AI_WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE = "@n8n/n8n-nodes-langchain.toolWorkflow";
const REQUEST_NODE_FORM_URL = "https://n8n-community.typeform.com/to/K1fBVTZ3";
const PRE_BUILT_AGENTS_COLLECTION = "pre-built-agents-collection";
NodeConnectionTypes.AiTool, NodeConnectionTypes.Main;
const DATA_TYPE_ICON_MAP = {
	["string"]: "type",
	["number"]: "hash",
	["boolean"]: "square-check",
	date: "calendar",
	array: "list",
	object: "box",
	file: "file"
};
const MODAL_CANCEL = "cancel";
const MODAL_CONFIRM = "confirm";
const MODAL_CLOSE = "close";
const VALID_EMAIL_REGEX = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const VALID_WORKFLOW_IMPORT_URL_REGEX = /^https?:\/\/.+/i;
const LOCAL_STORAGE_ACTIVATION_FLAG = "N8N_HIDE_ACTIVATION_ALERT";
const LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG = "N8N_PIN_DATA_DISCOVERY_NDV";
const LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG = "N8N_PIN_DATA_DISCOVERY_CANVAS";
const LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH = "N8N_MAIN_PANEL_RELATIVE_WIDTH";
const LOCAL_STORAGE_THEME = "N8N_THEME";
const LOCAL_STORAGE_EXPERIMENT_OVERRIDES = "N8N_EXPERIMENT_OVERRIDES";
const LOCAL_STORAGE_HIDE_GITHUB_STAR_BUTTON = "N8N_HIDE_HIDE_GITHUB_STAR_BUTTON";
const LOCAL_STORAGE_LOGS_PANEL_OPEN = "N8N_LOGS_PANEL_OPEN";
const LOCAL_STORAGE_LOGS_SYNC_SELECTION = "N8N_LOGS_SYNC_SELECTION_ENABLED";
const LOCAL_STORAGE_LOGS_PANEL_DETAILS_PANEL = "N8N_LOGS_DETAILS_PANEL";
const LOCAL_STORAGE_LOGS_PANEL_DETAILS_PANEL_SUB_NODE = "N8N_LOGS_DETAILS_PANEL_SUB_NODE";
const LOCAL_STORAGE_WORKFLOW_LIST_PREFERENCES_KEY = "N8N_WORKFLOWS_LIST_PREFERENCES";
const LOCAL_STORAGE_READ_WHATS_NEW_ARTICLES = "N8N_READ_WHATS_NEW_ARTICLES";
const LOCAL_STORAGE_DISMISSED_WHATS_NEW_CALLOUT = "N8N_DISMISSED_WHATS_NEW_CALLOUT";
const LOCAL_STORAGE_FOCUS_PANEL = "N8N_FOCUS_PANEL";
const LOCAL_STORAGE_EXPERIMENTAL_DISMISSED_SUGGESTED_WORKFLOWS = "N8N_EXPERIMENTAL_DISMISSED_SUGGESTED_WORKFLOWS";
const LOCAL_STORAGE_RUN_DATA_WORKER = "N8N_RUN_DATA_WORKER";
const LOCAL_STORAGE_CHAT_HUB_SELECTED_MODEL = (userId) => `${userId}_N8N_CHAT_HUB_SELECTED_MODEL`;
const LOCAL_STORAGE_CHAT_HUB_CREDENTIALS = (userId) => `${userId}_N8N_CHAT_HUB_CREDENTIALS`;
const LOCAL_STORAGE_CHAT_HUB_STATIC_SIDEBAR = (userId) => `${userId}_N8N_CHAT_HUB_STATIC_SIDEBAR`;
const BASE_NODE_SURVEY_URL = "https://n8n-community.typeform.com/to/BvmzxqYv#nodename=";
const RELEASE_NOTES_URL = "https://docs.n8n.io/release-notes/";
const HIRING_BANNER = `
                                                                    //////
                                                                 ///////////
                                                               /////      ////
                                               ///////////////////         ////
                                             //////////////////////       ////
     ///////               ///////          ////                /////////////
  ////////////          ////////////       ////                    ///////
 ////       ////       ////       ////    ////
/////        /////////////         //////////
 /////     ////       ////       ////     ////
  ////////////          ////////////       ////           ////////
    ///////                //////           ////        /////////////
                                             /////////////        ////
                                                //////////        ////
                                                       ////      ////
                                                        ///////////
                                                          //////

Love n8n? Help us build the future of automation! https://n8n.io/careers?utm_source=n8n_user&utm_medium=console_output
`;
const TEMPLATES_NODES_FILTER = ["n8n-nodes-base.start", "n8n-nodes-base.respondToWebhook"];
let VIEWS = /* @__PURE__ */ function(VIEWS$1) {
	VIEWS$1["HOMEPAGE"] = "Homepage";
	VIEWS$1["COLLECTION"] = "TemplatesCollectionView";
	VIEWS$1["EXECUTIONS"] = "Executions";
	VIEWS$1["EXECUTION_PREVIEW"] = "ExecutionPreview";
	VIEWS$1["EXECUTION_DEBUG"] = "ExecutionDebug";
	VIEWS$1["EXECUTION_HOME"] = "ExecutionsLandingPage";
	VIEWS$1["TEMPLATE"] = "TemplatesWorkflowView";
	VIEWS$1["TEMPLATE_SETUP"] = "TemplatesWorkflowSetupView";
	VIEWS$1["TEMPLATES"] = "TemplatesSearchView";
	VIEWS$1["CREDENTIALS"] = "CredentialsView";
	VIEWS$1["VARIABLES"] = "VariablesView";
	VIEWS$1["NEW_WORKFLOW"] = "NodeViewNew";
	VIEWS$1["WORKFLOW"] = "NodeViewExisting";
	VIEWS$1["DEMO"] = "WorkflowDemo";
	VIEWS$1["TEMPLATE_IMPORT"] = "WorkflowTemplate";
	VIEWS$1["WORKFLOW_ONBOARDING"] = "WorkflowOnboarding";
	VIEWS$1["SIGNIN"] = "SigninView";
	VIEWS$1["SIGNUP"] = "SignupView";
	VIEWS$1["SIGNOUT"] = "SignoutView";
	VIEWS$1["SETUP"] = "SetupView";
	VIEWS$1["FORGOT_PASSWORD"] = "ForgotMyPasswordView";
	VIEWS$1["CHANGE_PASSWORD"] = "ChangePasswordView";
	VIEWS$1["SETTINGS"] = "Settings";
	VIEWS$1["USERS_SETTINGS"] = "UsersSettings";
	VIEWS$1["LDAP_SETTINGS"] = "LdapSettings";
	VIEWS$1["PERSONAL_SETTINGS"] = "PersonalSettings";
	VIEWS$1["API_SETTINGS"] = "APISettings";
	VIEWS$1["NOT_FOUND"] = "NotFoundView";
	VIEWS$1["COMMUNITY_NODES"] = "CommunityNodes";
	VIEWS$1["WORKFLOWS"] = "WorkflowsView";
	VIEWS$1["WORKFLOW_EXECUTIONS"] = "WorkflowExecutions";
	VIEWS$1["EVALUATION"] = "Evaluation";
	VIEWS$1["EVALUATION_EDIT"] = "EvaluationEdit";
	VIEWS$1["EVALUATION_RUNS_DETAIL"] = "EvaluationRunsDetail";
	VIEWS$1["USAGE"] = "Usage";
	VIEWS$1["LOG_STREAMING_SETTINGS"] = "LogStreamingSettingsView";
	VIEWS$1["SSO_SETTINGS"] = "SSoSettings";
	VIEWS$1["EXTERNAL_SECRETS_SETTINGS"] = "ExternalSecretsSettings";
	VIEWS$1["PROVISIONING_SETTINGS"] = "ProvisioningSettings";
	VIEWS$1["SAML_ONBOARDING"] = "SamlOnboarding";
	VIEWS$1["SOURCE_CONTROL"] = "SourceControl";
	VIEWS$1["MFA_VIEW"] = "MfaView";
	VIEWS$1["WORKFLOW_HISTORY"] = "WorkflowHistory";
	VIEWS$1["WORKER_VIEW"] = "WorkerView";
	VIEWS$1["PROJECTS"] = "Projects";
	VIEWS$1["PROJECT_DETAILS"] = "ProjectDetails";
	VIEWS$1["PROJECTS_WORKFLOWS"] = "ProjectsWorkflows";
	VIEWS$1["PROJECTS_CREDENTIALS"] = "ProjectsCredentials";
	VIEWS$1["PROJECT_SETTINGS"] = "ProjectSettings";
	VIEWS$1["PROJECTS_EXECUTIONS"] = "ProjectsExecutions";
	VIEWS$1["PROJECT_ROLES_SETTINGS"] = "ProjectRolesSettingsView";
	VIEWS$1["PROJECT_ROLE_SETTINGS"] = "ProjectRoleSettingsView";
	VIEWS$1["PROJECT_NEW_ROLE"] = "ProjectNewRoleView";
	VIEWS$1["PROJECTS_VARIABLES"] = "ProjectsVariables";
	VIEWS$1["HOME_VARIABLES"] = "HomeVariables";
	VIEWS$1["FOLDERS"] = "Folders";
	VIEWS$1["PROJECTS_FOLDERS"] = "ProjectsFolders";
	VIEWS$1["INSIGHTS"] = "Insights";
	VIEWS$1["SHARED_WITH_ME"] = "SharedWithMe";
	VIEWS$1["SHARED_WORKFLOWS"] = "SharedWorkflows";
	VIEWS$1["SHARED_CREDENTIALS"] = "SharedCredentials";
	VIEWS$1["ENTITY_NOT_FOUND"] = "EntityNotFound";
	VIEWS$1["ENTITY_UNAUTHORIZED"] = "EntityUnAuthorized";
	VIEWS$1["PRE_BUILT_AGENT_TEMPLATES"] = "PreBuiltAgentTemplates";
	return VIEWS$1;
}({});
const EDITABLE_CANVAS_VIEWS = [
	VIEWS.WORKFLOW,
	VIEWS.NEW_WORKFLOW,
	VIEWS.EXECUTION_DEBUG
];
const TEST_PIN_DATA = [{
	name: "First item",
	code: 1
}, {
	name: "Second item",
	code: 2
}];
const MAPPING_PARAMS = [
	"$binary",
	"$data",
	"$env",
	"$evaluateExpression",
	"$execution",
	"$ifEmpty",
	"$input",
	"$item",
	"$jmespath",
	"$fromAI",
	"$json",
	"$node",
	"$now",
	"$parameter",
	"$parameters",
	"$position",
	"$prevNode",
	"$resumeWebhookUrl",
	"$runIndex",
	"$today",
	"$vars",
	"$workflow",
	"$nodeVersion"
];
const DEFAULT_STICKY_HEIGHT = 160;
const DEFAULT_STICKY_WIDTH = 240;
let WORKFLOW_MENU_ACTIONS = /* @__PURE__ */ function(WORKFLOW_MENU_ACTIONS$1) {
	WORKFLOW_MENU_ACTIONS$1["DUPLICATE"] = "duplicate";
	WORKFLOW_MENU_ACTIONS$1["DOWNLOAD"] = "download";
	WORKFLOW_MENU_ACTIONS$1["IMPORT_FROM_URL"] = "import-from-url";
	WORKFLOW_MENU_ACTIONS$1["IMPORT_FROM_FILE"] = "import-from-file";
	WORKFLOW_MENU_ACTIONS$1["PUSH"] = "push";
	WORKFLOW_MENU_ACTIONS$1["SETTINGS"] = "settings";
	WORKFLOW_MENU_ACTIONS$1["DELETE"] = "delete";
	WORKFLOW_MENU_ACTIONS$1["ARCHIVE"] = "archive";
	WORKFLOW_MENU_ACTIONS$1["UNARCHIVE"] = "unarchive";
	WORKFLOW_MENU_ACTIONS$1["RENAME"] = "rename";
	WORKFLOW_MENU_ACTIONS$1["CHANGE_OWNER"] = "change-owner";
	return WORKFLOW_MENU_ACTIONS$1;
}({});
const EnterpriseEditionFeature = {
	AdvancedExecutionFilters: "advancedExecutionFilters",
	Sharing: "sharing",
	Ldap: "ldap",
	LogStreaming: "logStreaming",
	Variables: "variables",
	Saml: "saml",
	Oidc: "oidc",
	EnforceMFA: "mfaEnforcement",
	SourceControl: "sourceControl",
	ExternalSecrets: "externalSecrets",
	AuditLogs: "auditLogs",
	DebugInEditor: "debugInEditor",
	WorkflowHistory: "workflowHistory",
	WorkerView: "workerView",
	AdvancedPermissions: "advancedPermissions",
	ApiKeyScopes: "apiKeyScopes",
	Provisioning: "provisioning"
};
const MAIN_NODE_PANEL_WIDTH = 390;
let MAIN_HEADER_TABS = /* @__PURE__ */ function(MAIN_HEADER_TABS$1) {
	MAIN_HEADER_TABS$1["WORKFLOW"] = "workflow";
	MAIN_HEADER_TABS$1["EXECUTIONS"] = "executions";
	MAIN_HEADER_TABS$1["SETTINGS"] = "settings";
	MAIN_HEADER_TABS$1["EVALUATION"] = "evaluation";
	return MAIN_HEADER_TABS$1;
}({});
const CURL_IMPORT_NOT_SUPPORTED_PROTOCOLS = [
	"ftp",
	"ftps",
	"dict",
	"imap",
	"imaps",
	"ldap",
	"ldaps",
	"mqtt",
	"pop",
	"pop3s",
	"rtmp",
	"rtsp",
	"scp",
	"sftp",
	"smb",
	"smbs",
	"smtp",
	"smtps",
	"telnet",
	"tftp"
];
const CURL_IMPORT_NODES_PROTOCOLS = {
	ftp: "FTP",
	ftps: "FTP",
	ldap: "LDAP",
	ldaps: "LDAP",
	mqtt: "MQTT",
	imap: "IMAP",
	imaps: "IMAP"
};
const EXPRESSION_EDITOR_PARSER_TIMEOUT = 15e3;
const KEEP_AUTH_IN_NDV_FOR_NODES = [
	HTTP_REQUEST_NODE_TYPE,
	HTTP_REQUEST_TOOL_NODE_TYPE,
	WEBHOOK_NODE_TYPE,
	WAIT_NODE_TYPE,
	DISCORD_NODE_TYPE,
	CHAT_TRIGGER_NODE_TYPE,
	FORM_TRIGGER_NODE_TYPE
];
const MAIN_AUTH_FIELD_NAME = "authentication";
const CANVAS_ZOOMED_VIEW_EXPERIMENT = {
	name: "canvas_zoomed_view",
	control: "control",
	variant: "variant"
};
const NDV_IN_FOCUS_PANEL_EXPERIMENT = {
	name: "ndv_in_focus_panel",
	control: "control",
	variant: "variant"
};
const COMMAND_BAR_EXPERIMENT = {
	name: "command_bar",
	control: "control",
	variant: "variant"
};
const NDV_UI_OVERHAUL_EXPERIMENT = {
	name: "029_ndv_ui_overhaul",
	control: "control",
	variant: "variant"
};
const WORKFLOW_BUILDER_RELEASE_EXPERIMENT = {
	name: "043_workflow_builder_release",
	control: "control",
	variant: "variant"
};
const WORKFLOW_BUILDER_DEPRECATED_EXPERIMENT = {
	name: "036_workflow_builder_agent",
	control: "control",
	variant: "variant"
};
const EXTRA_TEMPLATE_LINKS_EXPERIMENT = {
	name: "034_extra_template_links",
	control: "control",
	variant: "variant"
};
const TEMPLATE_ONBOARDING_EXPERIMENT = {
	name: "035_template_onboarding",
	control: "control",
	variantStarterPack: "variant-starter-pack",
	variantSuggestedTemplates: "variant-suggested-templates"
};
const BATCH_11AUG_EXPERIMENT = {
	name: "37_onboarding_experiments_batch_aug11",
	control: "control",
	variantReadyToRun: "variant-ready-to-run-workflows",
	variantReadyToRun2: "variant-ready-to-run-workflows_v2",
	variantReadyToRun3: "variant-ready-to-run-workflows_v3"
};
const PRE_BUILT_AGENTS_EXPERIMENT = {
	name: "038_pre_built_agents",
	control: "control",
	variant: "variant"
};
const TEMPLATE_RECO_V2 = {
	name: "039_template_onboarding_v2",
	control: "control",
	variant: "variant"
};
const READY_TO_RUN_V2_PART2_EXPERIMENT = {
	name: "045_ready-to-run-worfklow_v2-2",
	control: "control",
	variant3: "variant-3",
	variant4: "variant-4"
};
const PERSONALIZED_TEMPLATES_V3 = {
	name: "044_template_reco_v3",
	control: "control",
	variant: "variant"
};
const PROJECT_VARIABLES_EXPERIMENT = {
	name: "046_project_variables",
	control: "control",
	variant: "variant"
};
const EXPERIMENTS_TO_TRACK = [
	WORKFLOW_BUILDER_DEPRECATED_EXPERIMENT.name,
	WORKFLOW_BUILDER_RELEASE_EXPERIMENT.name,
	EXTRA_TEMPLATE_LINKS_EXPERIMENT.name,
	TEMPLATE_ONBOARDING_EXPERIMENT.name,
	NDV_UI_OVERHAUL_EXPERIMENT.name,
	BATCH_11AUG_EXPERIMENT.name,
	PRE_BUILT_AGENTS_EXPERIMENT.name,
	TEMPLATE_RECO_V2.name,
	PROJECT_VARIABLES_EXPERIMENT.name
];
const MFA_FORM = {
	MFA_TOKEN: "MFA_TOKEN",
	MFA_RECOVERY_CODE: "MFA_RECOVERY_CODE"
};
const MFA_AUTHENTICATION_REQUIRED_ERROR_CODE = 998;
const MFA_AUTHENTICATION_CODE_WINDOW_EXPIRED = 997;
const MFA_AUTHENTICATION_CODE_INPUT_MAX_LENGTH = 6;
const MFA_AUTHENTICATION_RECOVERY_CODE_INPUT_MAX_LENGTH = 36;
const NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND = [
	FILTER_NODE_TYPE,
	SWITCH_NODE_TYPE,
	REMOVE_DUPLICATES_NODE_TYPE,
	RESPOND_TO_WEBHOOK_NODE_TYPE
];
const ALLOWED_HTML_ATTRIBUTES = [
	"href",
	"name",
	"target",
	"title",
	"class",
	"id",
	"style"
];
const ALLOWED_HTML_TAGS = [
	"p",
	"strong",
	"b",
	"code",
	"a",
	"br",
	"i",
	"ul",
	"li",
	"em",
	"small",
	"details",
	"summary",
	"mark"
];
window.location.host.includes("stage-app.n8n.cloud");
const CLOUD_TRIAL_CHECK_INTERVAL = 5e3;
const nonExistingJsonPath = "_!^&*";
const ASK_AI_MAX_PROMPT_LENGTH = 600;
const ASK_AI_MIN_PROMPT_LENGTH = 15;
const ASK_AI_LOADING_DURATION_MS = 12e3;
const ASK_AI_SLIDE_OUT_DURATION_MS = 200;
const APPEND_ATTRIBUTION_DEFAULT_PATH = "parameters.options.appendAttribution";
const DRAG_EVENT_DATA_KEY = "nodesAndConnections";
const NOT_DUPLICATABLE_NODE_TYPES = [FORM_TRIGGER_NODE_TYPE];
const UPDATE_WEBHOOK_ID_NODE_TYPES = [FORM_TRIGGER_NODE_TYPE];
const CREATOR_HUB_URL = "https://creators.n8n.io/hub";
const TIME = {
	SECOND: 1e3,
	MINUTE: 60 * 1e3,
	HOUR: 3600 * 1e3,
	DAY: 1440 * 60 * 1e3
};
const THREE_DAYS_IN_MILLIS = 3 * TIME.DAY;
const SEVEN_DAYS_IN_MILLIS = 7 * TIME.DAY;
const SIX_MONTHS_IN_MILLIS = 180 * TIME.DAY;
const TEMPLATES_URLS = {
	DEFAULT_API_HOST: "https://api.n8n.io/api/",
	BASE_WEBSITE_URL: "https://n8n.io/workflows/",
	UTM_QUERY: {
		utm_source: "n8n_app",
		utm_medium: "template_library"
	}
};
const INSECURE_CONNECTION_WARNING = `
<body style="margin-top: 20px; font-family: 'Open Sans', sans-serif; text-align: center;">
<h1 style="font-size: 40px">&#x1F6AB;</h1>
<h2>Your n8n server is configured to use a secure cookie, <br/>however you are either visiting this via an insecure URL, or using Safari.
</h2>
<br/>
<div style="font-size: 18px; max-width: 640px; text-align: left; margin: 10px auto">
	To fix this, please consider the following options:
	<ul>
		<li>Setup TLS/HTTPS (<strong>recommended</strong>), or</li>
		<li>If you are running this locally, and not using Safari, try using <a href="http://localhost:5678">localhost</a> instead</li>
		<li>If you prefer to disable this security feature (<strong>not recommended</strong>), set the environment variable <code>N8N_SECURE_COOKIE</code> to <code>false</code></li>
	</ul>
</div>
</body>`;
const CanvasKey = "canvas";
const CanvasNodeKey = "canvasNode";
const CanvasNodeHandleKey = "canvasNodeHandle";
const PopOutWindowKey = Symbol("PopOutWindow");
const ExpressionLocalResolveContextSymbol = Symbol("ExpressionLocalResolveContext");
const TelemetryContextSymbol = Symbol("TelemetryContext");
const WorkflowStateKey = Symbol("WorkflowState");
const APP_MODALS_ELEMENT_ID = "app-modals";
const CODEMIRROR_TOOLTIP_CONTAINER_ELEMENT_ID = "cm-tooltip-container";
const AI_NODES_PACKAGE_NAME = "@n8n/n8n-nodes-langchain";
const AI_ASSISTANT_MAX_CONTENT_LENGTH = 100;
const RUN_DATA_DEFAULT_PAGE_SIZE = 25;
const LOGS_EXECUTION_DATA_THROTTLE_DURATION = 1e3;
const CANVAS_EXECUTION_DATA_THROTTLE_DURATION = 500;
const BINARY_DATA_ACCESS_TOOLTIP = "Specify the property name of the binary data in the input item or use an expression to access the binary data in previous nodes, e.g. {{ $('Target Node').item.binary.data }}";
export { CHANGE_PASSWORD_MODAL_KEY as $, PROVIDER_CREDENTIAL_TYPE_MAP as $a, TRANSFORM_DATA_SUBCATEGORY as $i, LOCAL_STORAGE_WORKFLOW_LIST_PREFERENCES_KEY as $n, getNodeParametersIssues as $o, OTHER_TRIGGER_NODES_SUBCATEGORY as $r, PROJECT_ROOT as $s, EXPERIMENTS_TO_TRACK as $t, ALLOWED_HTML_ATTRIBUTES as A, COLUMN_NAME_REGEX as Aa, SIMULATE_TRIGGER_NODE_TYPE as Ai, JIRA_TRIGGER_NODE_TYPE as An, splitExpression as Ao, MODULE_ENABLED_NODES as Ar, parseScript as As, DEFAULT_NEW_WORKFLOW_NAME as At, BASE_NODE_SURVEY_URL as B, DEFAULT_ID_COLUMN_NAME as Ba, SWITCH_NODE_TYPE as Bi, LOCAL_STORAGE_EXPERIMENT_OVERRIDES as Bn, defaultMessageEventBusDestinationWebhookOptions as Bo, NODE_PINNING_MODAL_KEY as Br, AI_TRANSFORM_NODE_TYPE$1 as Bs, DUPLICATE_POSTFFIX as Bt, AI_NODES_PACKAGE_NAME as C, XERO_NODE_TYPE as Ca, SCHEMA_PREVIEW_DOCS_URL as Ci, IMPORT_CURL_MODAL_KEY as Cn, nullType as Co, MFA_FORM as Cr, isObjectEmpty as Cs, CanvasNodeHandleKey as Ct, AI_TRANSFORM_NODE_TYPE as D, nonExistingJsonPath as Da, SET_NODE_TYPE as Di, IN_PROGRESS_EXECUTION_ID as Dn, createResultError as Do, MODAL_CANCEL as Dr, randomString as Ds, DATA_TABLE_NODES as Dt, AI_SUBCATEGORY as E, ZENDESK_TRIGGER_NODE_TYPE as Ea, SETUP_CREDENTIALS_MODAL_KEY as Ei, INTERVAL_NODE_TYPE as En, Expression as Eo, MICROSOFT_TEAMS_NODE_TYPE as Er, randomInt as Es, DATA_PINNING_DOCS_URL as Et, ASK_AI_LOADING_DURATION_MS as F, DATA_TABLE_ROW_HEIGHT as Fa, SPLIT_OUT_NODE_TYPE as Fi, LOCAL_STORAGE_CHAT_HUB_CREDENTIALS as Fn, isExpression as Fo, NEW_ASSISTANT_SESSION_MODAL as Fr, ApplicationError as Fs, DEFAULT_WORKFLOW_PAGE_SIZE as Ft, BREAKPOINT_MD as G, NULL_VALUE as Ga, TEMPLATE_CATEGORY_AI as Gi, LOCAL_STORAGE_LOGS_PANEL_OPEN as Gn, getChildNodes as Go, NOT_DUPLICATABLE_NODE_TYPES as Gr, EVALUATION_TRIGGER_NODE_TYPE as Gs, EMAIL_SEND_NODE_TYPE as Gt, BATCH_11AUG_EXPERIMENT as H, LOOSE_DATE_REGEX as Ha, TELEGRAM_NODE_TYPE as Hi, LOCAL_STORAGE_HIDE_GITHUB_STAR_BUTTON as Hn, setGlobalState as Ho, NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND as Hr, CHAT_TRIGGER_NODE_TYPE$1 as Hs, EDIT_IMAGE_NODE_TYPE as Ht, ASK_AI_MAX_PROMPT_LENGTH as I, DATA_TABLE_STORE as Ia, SPREADSHEET_FILE_NODE_TYPE as Ii, LOCAL_STORAGE_CHAT_HUB_SELECTED_MODEL as In, MessageEventBusDestinationTypeNames as Io, NEW_WORKFLOW_ID as Ir, ADD_FORM_NOTICE as Is, DISCORD_NODE_TYPE as It, BUILTIN_CREDENTIALS_DOCS_URL as J, NUMBER_WITH_SPACES_REGEX as Ja, TEST_PIN_DATA as Ji, LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG as Jn, displayParameterPath as Jo, NPS_SURVEY_MODAL_KEY as Jr, FROM_AI_AUTO_GENERATED_MARKER as Js, EVALUATIONS_DOCS_URL as Jt, BREAKPOINT_SM as K, NUMBER_DECIMAL_SEPARATOR as Ka, TEMPLATE_ONBOARDING_EXPERIMENT as Ki, LOCAL_STORAGE_LOGS_SYNC_SELECTION as Kn, generateNodesGraph as Ko, NO_OP_NODE_TYPE as Kr, EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE$1 as Ks, ERROR_TRIGGER_NODE_TYPE as Kt, ASK_AI_MIN_PROMPT_LENGTH as L, DATA_TABLE_VIEW as La, START_NODE_TYPE as Li, LOCAL_STORAGE_CHAT_HUB_STATIC_SIDEBAR as Ln, defaultMessageEventBusDestinationOptions as Lo, NODES_USING_CODE_NODE_EDITOR as Lr, AGENT_LANGCHAIN_NODE_TYPE as Ls, DOCS_DOMAIN as Lt, ANNOTATION_TAGS_MANAGER_MODAL_KEY as M, DATA_TABLE_DETAILS as Ma, SIX_MONTHS_IN_MILLIS as Mi, LIMIT_NODE_TYPE as Mn, require__arrayIncludesWith as Mo, N8N_PRICING_PAGE_URL as Mr, DateTime as Ms, DEFAULT_STICKY_HEIGHT as Mt, APPEND_ATTRIBUTION_DEFAULT_PATH as N, DATA_TABLE_HEADER_HEIGHT as Na, SLACK_NODE_TYPE as Ni, LIST_LIKE_NODE_OPERATIONS as Nn, require__arrayIncludes as No, NDV_IN_FOCUS_PANEL_EXPERIMENT as Nr, NodeConnectionTypes as Ns, DEFAULT_STICKY_WIDTH as Nt, AI_UNCATEGORIZED_CATEGORY as O, ADD_DATA_TABLE_MODAL_KEY as Oa, SEVEN_DAYS_IN_MILLIS as Oi, ITEM_LISTS_NODE_TYPE as On, createResultOk as Oo, MODAL_CLOSE as Or, sleep as Os, DATA_TYPE_ICON_MAP as Ot, APP_MODALS_ELEMENT_ID as P, DATA_TABLE_ID_COLUMN_WIDTH as Pa, SPLIT_IN_BATCHES_NODE_TYPE as Pi, LOCAL_STORAGE_ACTIVATION_FLAG as Pn, require__baseFindIndex as Po, NDV_UI_OVERHAUL_EXPERIMENT as Pr, nodeConnectionTypes as Ps, DEFAULT_SUBCATEGORY as Pt, CANVAS_ZOOMED_VIEW_EXPERIMENT as Q, createHeartbeatMessage as Qa, TIME_SAVED_DOCS_URL as Qi, LOCAL_STORAGE_THEME as Qn, getNodeParameters as Qo, OPEN_URL_PANEL_TRIGGER_NODE_TYPES as Qr, OPEN_AI_API_CREDENTIAL_TYPE as Qs, EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE as Qt, ASK_AI_SLIDE_OUT_DURATION_MS as R, DEFAULT_COLUMN_WIDTH as Ra, STICKY_NODE_TYPE as Ri, LOCAL_STORAGE_DISMISSED_WHATS_NEW_CALLOUT as Rn, defaultMessageEventBusDestinationSentryOptions as Ro, NODE_CREATOR_OPEN_SOURCES as Rr, AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT as Rs, DRAG_EVENT_DATA_KEY as Rt, AI_MCP_TOOL_NODE_TYPE as S, WorkflowStateKey as Sa, SCHEDULE_TRIGGER_NODE_TYPE as Si, IF_NODE_TYPE as Sn, traverseNodeParameters as So, MFA_DOCS_URL as Sr, isCommunityPackageName as Ss, CanvasKey as St, AI_OTHERS_NODE_CREATOR_VIEW as T, ZENDESK_NODE_TYPE as Ta, SERVICENOW_NODE_TYPE as Ti, INSECURE_CONNECTION_WARNING as Tn, stringType as To, MICROSOFT_EXCEL_NODE_TYPE as Tr, jsonStringify as Ts, DATA_EDITING_DOCS_URL as Tt, BINARY_DATA_ACCESS_TOOLTIP as U, MAX_COLUMN_NAME_LENGTH as Ua, TEMPLATES_NODES_FILTER as Ui, LOCAL_STORAGE_LOGS_PANEL_DETAILS_PANEL as Un, mapConnectionsByDestination as Uo, NON_ACTIVATABLE_TRIGGER_NODE_TYPES as Ur, CREDENTIAL_EMPTY_VALUE as Us, ELASTIC_SECURITY_NODE_TYPE as Ut, BASIC_CHAIN_NODE_TYPE as V, EMPTY_VALUE as Va, TAGS_MANAGER_MODAL_KEY as Vi, LOCAL_STORAGE_FOCUS_PANEL as Vn, messageEventBusDestinationTypeNames as Vo, NODE_POSITION_CONFLICT_ALLOWLIST as Vr, CHAIN_LLM_LANGCHAIN_NODE_TYPE as Vs, EDITABLE_CANVAS_VIEWS as Vt, BREAKPOINT_LG as W, MIN_LOADING_TIME as Wa, TEMPLATES_URLS as Wi, LOCAL_STORAGE_LOGS_PANEL_DETAILS_PANEL_SUB_NODE as Wn, getNodeByName as Wo, NOTION_TRIGGER_NODE_TYPE as Wr, EVALUATION_NODE_TYPE as Ws, EMAIL_IMAP_NODE_TYPE as Wt, CALENDLY_TRIGGER_NODE_TYPE as X, ROLE as Xa, THREE_DAYS_IN_MILLIS as Xi, LOCAL_STORAGE_READ_WHATS_NEW_ARTICLES as Xn, getNodeInputs as Xo, OPEN_AI_NODE_MESSAGE_ASSISTANT_TYPE as Xr, HTTP_REQUEST_NODE_TYPE$1 as Xs, EXECUTE_COMMAND_NODE_TYPE as Xt, BUILTIN_NODES_DOCS_URL as Y, PROJECT_DATA_TABLES as Ya, THE_HIVE_TRIGGER_NODE_TYPE as Yi, LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG as Yn, getConnectionTypes as Yo, OPEN_AI_ASSISTANT_NODE_TYPE as Yr, HTML_NODE_TYPE$1 as Ys, EXECUTABLE_TRIGGER_NODE_TYPES as Yt, CANVAS_EXECUTION_DATA_THROTTLE_DURATION as Z, ViewableMimeTypes as Za, TIME as Zi, LOCAL_STORAGE_RUN_DATA_WORKER as Zn, getNodeOutputs as Zo, OPEN_AI_NODE_TYPE as Zr, MANUAL_TRIGGER_NODE_TYPE$1 as Zs, EXECUTE_WORKFLOW_NODE_TYPE as Zt, AI_CATEGORY_TOOLS as _, WORKFLOW_HISTORY_VERSION_RESTORE as _a, require_is_callable as _c, REMOVE_DUPLICATES_NODE_TYPE as _i, HITL_SUBCATEGORY as _n, require_hasIn as _o, MERGE_NODE_TYPE as _r, FilterError as _s, CRYPTO_NODE_TYPE as _t, AI_CATEGORY_AGENTS as a, VERSIONS_MODAL_KEY as aa, require__getTag as ac, PRE_BUILT_AGENTS_COLLECTION as ai, EXTRA_TEMPLATE_LINKS_EXPERIMENT as an, SOURCE_CONTROL_FILE_TYPE as ao, MANUAL_CHAT_TRIGGER_NODE_TYPE as ar, isDefaultNodeName as as, CODEMIRROR_TOOLTIP_CONTAINER_ELEMENT_ID as at, AI_CODE_TOOL_LANGCHAIN_NODE_TYPE as b, WORKFLOW_SHARE_MODAL_KEY as ba, RUN_DATA_DEFAULT_PAGE_SIZE as bi, HUBSPOT_TRIGGER_NODE_TYPE as bn, require__getAllKeysIn as bo, MFA_AUTHENTICATION_RECOVERY_CODE_INPUT_MAX_LENGTH as br, base64DecodeUTF8 as bs, CUSTOM_API_CALL_KEY as bt, AI_CATEGORY_EMBEDDING as c, WEBHOOK_NODE_TYPE as ca, require__arrayPush as cc, PRODUCTION_ONLY_TRIGGER_NODE_TYPES as ci, FILTER_NODE_TYPE as cn, PROJECT_OWNER_ROLE_SLUG as co, MARKDOWN_NODE_TYPE as cr, isSubNodeType as cs, COMPRESSION_NODE_TYPE as ct, AI_CATEGORY_MEMORY as d, WOOCOMMERCE_TRIGGER_NODE_TYPE as da, require_callBound as dc, PopOutWindowKey as di, FORM_TRIGGER_NODE_TYPE as dn, buildAdjacencyList as do, MAX_EXPECTED_REQUEST_SIZE as dr, mergeIssues as ds, CONVERT_TO_FILE_NODE_TYPE as dt, TRIGGER_NODE_CREATOR_VIEW as ea, SEND_AND_WAIT_OPERATION as ec, PAGERDUTY_NODE_TYPE as ei, EXPERIMENT_TEMPLATE_RECO_V2_KEY as en, chatHubConversationModelSchema as eo, LOGS_EXECUTION_DATA_THROTTLE_DURATION as er, getNodeWebhookUrl as es, CHAT_EMBED_MODAL_KEY as et, AI_CATEGORY_OTHER_TOOLS as f, WORKABLE_TRIGGER_NODE_TYPE as fa, require_call_bind as fc, QA_CHAIN_NODE_TYPE as fi, FROM_AI_PARAMETERS_MODAL_KEY as fn, parseExtractableSubgraphSelection as fo, MAX_PINNED_DATA_SIZE as fr, mergeNodeProperties as fs, CORE_NODES_CATEGORY as ft, AI_CATEGORY_TEXT_SPLITTERS as g, WORKFLOW_EXTRACTION_NAME_MODAL_KEY as ga, require_call_bound as gc, RELEASE_NOTES_URL as gi, HIRING_BANNER as gn, require__baseIteratee as go, MCP_TRIGGER_NODE_TYPE as gr, isResourceLocatorValue as gs, CRON_NODE_TYPE as gt, AI_CATEGORY_ROOT_NODES as h, WORKFLOW_DIFF_MODAL_KEY as ha, require_shams as hc, REGULAR_NODE_CREATOR_VIEW as hi, HELPERS_SUBCATEGORY as hn, extractReferencesInNodeExpressions as ho, MAX_WORKFLOW_SIZE as hr, isINodePropertyOptionsList as hs, CREDENTIAL_ONLY_NODE_PREFIX as ht, AI_ASSISTANT_MAX_CONTENT_LENGTH as i, VALID_WORKFLOW_IMPORT_URL_REGEX as ia, require_isEqual as ic, PLACEHOLDER_FILLED_AT_EXECUTION_TIME as ii, EXTRACT_FROM_FILE_NODE_TYPE as in, SOURCE_CONTROL_FILE_STATUS as io, MAIN_NODE_PANEL_WIDTH as ir, getUpdatedToolDescription as is, CLOUD_TRIAL_CHECK_INTERVAL as it, ALLOWED_HTML_TAGS as j, DATA_TABLE_CARD_ACTIONS as ja, SINGLE_WEBHOOK_TRIGGERS as ji, KEEP_AUTH_IN_NDV_FOR_NODES as jn, require__baseUniq as jo, N8N_MAIN_GITHUB_REPO_URL as jr, ExpressionError as js, DEFAULT_NODETYPE_VERSION as jt, AI_WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE as k, ADD_ROW_ROW_ID as ka, SIMULATE_NODE_TYPE as ki, JIRA_NODE_TYPE as kn, EXTENSION_OBJECTS as ko, MODAL_CONFIRM as kr, Syntax as ks, DATETIME_NODE_TYPE as kt, AI_CATEGORY_LANGUAGE_MODELS as l, WHATS_NEW_MODAL_KEY as la, require__cacheHas as lc, PROJECT_VARIABLES_EXPERIMENT as li, FLOWS_CONTROL_SUBCATEGORY as ln, resolveRelativePath as lo, MAX_DISPLAY_DATA_SIZE as lr, isTriggerNode as ls, CONFIRM_PASSWORD_MODAL_KEY as lt, AI_CATEGORY_RETRIEVERS as m, WORKFLOW_ACTIVE_MODAL_KEY as ma, require_is_regex as mc, READY_TO_RUN_V2_PART2_EXPERIMENT as mi, GOOGLE_SHEETS_NODE_TYPE as mn, parseErrorMetadata as mo, MAX_WORKFLOW_NAME_LENGTH as mr, isINodePropertyCollectionList as ms, CREDENTIAL_ONLY_HTTP_NODE_VERSION as mt, AGENT_NODE_TYPE as n, UPDATE_WEBHOOK_ID_NODE_TYPES as na, WAIT_INDEFINITELY as nc, PIN_DATA_NODE_TYPES_DENYLIST as ni, EXPRESSION_EDITOR_PARSER_TIMEOUT as nn, USERS_LIST_SORT_OPTIONS as no, MAIN_AUTH_FIELD_NAME as nr, getParameterValueByPath as ns, CHAT_TRIGGER_NODE_TYPE as nt, AI_CATEGORY_CHAINS as o, VIEWS as oa, require_keys as oc, PRE_BUILT_AGENTS_EXPERIMENT as oi, EnterpriseEditionFeature as on, getResourcePermissions as oo, MANUAL_TRIGGER_NODE_TYPE as or, isExecutable as os, CODE_NODE_TYPE as ot, AI_CATEGORY_OUTPUTPARSER as p, WORKFLOW_ACTIVATION_CONFLICTING_WEBHOOK_MODAL_KEY as pa, require_safe_regex_test as pc, QUICKBOOKS_NODE_TYPE as pi, GITHUB_TRIGGER_NODE_TYPE as pn, Workflow as po, MAX_TAG_NAME_LENGTH as pr, isINodePropertiesList as ps, CREATOR_HUB_URL as pt, BREAKPOINT_XL as q, NUMBER_THOUSAND_SEPARATOR as qa, TEMPLATE_RECO_V2 as qi, LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH as qn, displayParameter as qo, NPM_PACKAGE_DOCS_BASE_URL as qr, FORM_TRIGGER_NODE_TYPE$1 as qs, ERROR_WORKFLOW_DOCS_URL as qt, AGGREGATE_NODE_TYPE as r, VALID_EMAIL_REGEX as ra, WEBHOOK_NODE_TYPE$1 as rc, PLACEHOLDER_EMPTY_WORKFLOW_ID as ri, EXTERNAL_SECRETS_PROVIDER_MODAL_KEY as rn, SOURCE_CONTROL_FILE_LOCATION as ro, MAIN_HEADER_TABS as rr, getSubworkflowId as rs, CLEARBIT_NODE_TYPE as rt, AI_CATEGORY_DOCUMENT_LOADERS as s, WAIT_NODE_TYPE as sa, require__baseKeys as sc, PRE_BUILT_AGENTS_MODAL_KEY as si, ExpressionLocalResolveContextSymbol as sn, hasScope as so, MAPPING_PARAMS as sr, isNodeWithWorkflowSelector as ss, COMMAND_BAR_EXPERIMENT as st, ABOUT_MODAL_KEY as t, TelemetryContextSymbol as ta, TRIMMED_TASK_DATA_CONNECTIONS_KEY as tc, PERSONALIZED_TEMPLATES_V3 as ti, EXPERIMENT_TEMPLATE_RECO_V3_KEY as tn, chatHubProviderSchema as to, LOG_STREAM_MODAL_KEY as tr, getParameterIssues as ts, CHAT_HUB_SIDE_MENU_DRAWER_MODAL_KEY as tt, AI_CATEGORY_MCP_NODES as u, WIKIPEDIA_TOOL_NODE_TYPE as ua, require__SetCache as uc, PROMPT_MFA_CODE_MODAL_KEY as ui, FORM_NODE_TYPE as un, NATIVE_METHODS as uo, MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW as ur, makeNodeName as us, CONTACT_PROMPT_MODAL_KEY as ut, AI_CATEGORY_VECTOR_STORES as v, WORKFLOW_MENU_ACTIONS as va, require_define_properties as vc, REQUEST_NODE_FORM_URL as vi, HTML_NODE_TYPE as vn, require__baseForOwn as vo, MFA_AUTHENTICATION_CODE_INPUT_MAX_LENGTH as vr, executeFilterCondition as vs, CURL_IMPORT_NODES_PROTOCOLS as vt, AI_NODE_CREATOR_VIEW as w, XML_NODE_TYPE as wa, SEGMENT_NODE_TYPE as wi, IMPORT_WORKFLOW_URL_MODAL_KEY as wn, recordType as wo, MFA_SETUP_MODAL_KEY as wr, jsonParse as ws, CanvasNodeKey as wt, AI_EVALUATION as x, WORKFLOW_TRIGGER_NODE_TYPE as xa, SALESFORCE_NODE_TYPE as xi, HUMAN_IN_THE_LOOP_CATEGORY as xn, extractFromAICalls as xo, MFA_AUTHENTICATION_REQUIRED_ERROR_CODE as xr, deepCopy as xs, CUSTOM_NODES_DOCS_URL as xt, AI_CODE_NODE_TYPE as y, WORKFLOW_SETTINGS_MODAL_KEY as ya, RSS_READ_NODE_TYPE as yi, HTTP_REQUEST_NODE_TYPE as yn, require_cloneDeep as yo, MFA_AUTHENTICATION_CODE_WINDOW_EXPIRED as yr, validateFieldType as ys, CURL_IMPORT_NOT_SUPPORTED_PROTOCOLS as yt, BAMBOO_HR_NODE_TYPE as z, DEFAULT_DATA_TABLE_PAGE_SIZE as za, SUMMARIZE_NODE_TYPE as zi, LOCAL_STORAGE_EXPERIMENTAL_DISMISSED_SUGGESTED_WORKFLOWS as zn, defaultMessageEventBusDestinationSyslogOptions as zo, NODE_MIN_INPUT_ITEMS_COUNT as zr, AI_TRANSFORM_JS_CODE as zs, DUPLICATE_MODAL_KEY as zt };
