import { o as __toESM } from "./chunk-r2Y0G7H8.js";
import { $t as hasOwn, C as computed, Cn as toDisplayString, D as createElementBlock, E as createCommentVNode, G as nextTick, Gt as unref, It as ref, J as onBeforeUnmount, L as h, M as createVNode, P as defineComponent, T as createBlock, Z as onMounted, _ as Fragment, _t as watch, at as renderSlot, bn as normalizeStyle, bt as withCtx, c as useCssModule, ct as resolveDynamicComponent, en as hyphenate, et as openBlock, it as renderList, j as createTextVNode, k as createSlots, mt as useTemplateRef, nt as provide, ot as resolveComponent, p as vShow, q as onBeforeMount, tn as init_shared_esm_bundler, v as KeepAlive, vn as normalizeClass, w as createBaseVNode, xt as withDirectives, z as inject, zt as shallowRef } from "./vue.runtime.esm-bundler-XtMkEjzB.js";
import { M as useLocalStorage, w as useDocumentVisibility, yt as useI18n } from "./_MapCache-Bq6g7eJk.js";
import { At as N8nBadge_default, Ci as useRoute, D as N8nUserStack_default, Dt as N8nActionDropdown_default, Hi as N8nButton_default, Ki as __vitePreload, M as SuggestedActions_default, Mi as N8nIconButton_default, N as N8nTag_default, Ni as AskAssistantButton_default, Oi as N8nTooltip_default, Ui as N8nIcon_default, _i as RouterLink, _t as createEventBus, d as N8nInlineTextEdit_default, fi as AskAssistantAvatar_default, wi as useRouter, z as N8nRadioButtons_default } from "./src-Vlm7Mxf-.js";
import { t as __plugin_vue_export_helper_default } from "./_plugin-vue_export-helper-DltO58Gh.js";
import "./sanitize-html-JHjOJhXQ.js";
import { At as disposeWorkflowDocumentStore, Bt as useNDVStore, C as useNodeTypesStore, Dr as useWorkflowHistoryStore, Ft as useEnvironmentsStore, Gt as useProjectsStore, Ht as useWorkflowState, K as getSampleWorkflowByTemplateId, Kc as getBannerRowHeight, Kt as ProjectTypes, Lt as useTelemetry, Ma as PROJECT_MOVE_RESOURCE_MODAL, Or as require_FileSaver_min, Ot as useTagsStore, Rr as useWorkflowsListStore, T as useEvaluationStore, Ti as ResourceType, Tr as useMessage, Tt as useWorkflowHelpers, Vt as injectWorkflowState, br as useStyles, fi as useHistoryStore, fn as useDocumentTitle, ga as nodeViewEventBus, hn as useWorkflowSaveStore, ji as getActivatableTriggerNodes, jt as useWorkflowDocumentStore, kt as createWorkflowDocumentId, pn as useWorkflowSaving, r as useUIStore, rt as useCredentialsStore, s as useWorkflowsStore, t as useUsersStore, un as useBuilderStore, ur as hasPermission, wr as useSourceControlStore, ws as useSettingsStore, xr as useExternalHooks, yr as useToast, zt as telemetry } from "./users.store-BwYRQvCY.js";
import "./MainSidebarHeader-BuxreDGw.js";
import { t as BaseLayout_default } from "./BaseLayout-DRnUeQfL.js";
import { $s as LOCAL_STORAGE_HIDE_GITHUB_STAR_BUTTON, Bs as WORKFLOW_PUBLISH_MODAL_KEY, Ec as WorkflowStateKey, Hs as WORKFLOW_SHARE_MODAL_KEY, Is as WORKFLOW_HISTORY_NAME_VERSION_MODAL_KEY, Ms as WORKFLOW_ACTIVE_MODAL_KEY, Ns as WORKFLOW_DESCRIPTION_MODAL_KEY, Ss as MODAL_CONFIRM, T as TIME_SAVED_DOCS_URL, Tc as WorkflowIdKey, Vs as WORKFLOW_SETTINGS_MODAL_KEY, Yc as EnterpriseEditionFeature, _ as EVALUATIONS_DOCS_URL, _s as IMPORT_WORKFLOW_URL_MODAL_KEY, br as TIME_SAVED_NODE_TYPE, ds as DUPLICATE_MODAL_KEY, el as LOADING_ANIMATION_MIN_DURATION, g as ERROR_WORKFLOW_DOCS_URL, hr as STICKY_NODE_TYPE, ns as MAIN_HEADER_TABS, o as MAX_WORKFLOW_NAME_LENGTH, qo as getResourcePermissions, rs as VIEWS, t as AutoSaveState, wc as WorkflowDocumentStoreKey, xl as WORKFLOW_MENU_ACTIONS, y as N8N_MAIN_GITHUB_REPO_URL, zs as WORKFLOW_HISTORY_VERSION_UNPUBLISH } from "./constants-RiJkz47J.js";
import "./merge-CLls_idn.js";
import { r as useRootStore } from "./_baseOrderBy-BE23B-S3.js";
import { t as useBannersStore } from "./banners.store-DdxlUUS2.js";
import "./dateformat-Bc6vycUF.js";
import { n as require_debounce, t as useDebounce } from "./useDebounce-BghtiK4X.js";
import "./versions.store-C9Ch1_0N.js";
import "./usePageRedirectionHelper-CR50q2Bt.js";
import "./dataTable.store-BEsKD9h6.js";
import "./useClipboard-BYpnCAGs.js";
import "./useBugReporting-D-qlUawL.js";
import { t as useExecutionsStore } from "./executions.store-CrIhMc4b.js";
import { t as useAssistantStore } from "./assistant.store-BTYElwjc.js";
import { t as useChatPanelStore } from "./chatPanel.store-yTWZP9H2.js";
import "./RunData-DoLiVaik.js";
import "./NDVEmptyState-H24YyLF4.js";
import "./useEnvFeatureFlag-B-aCettH.js";
import { t as useExternalSecretsStore } from "./externalSecrets.ee.store-B6OogwlK.js";
import "./uniqBy-MGaViHTj.js";
import "./usePinnedData-BH7clGFt.js";
import "./nodeIcon-BqHYqRCI.js";
import "./canvas.utils-BI57Gahu.js";
import "./nodeCreator.store-tiiu6Zuw.js";
import { n as useParentFolder, t as useCanvasOperations } from "./useCanvasOperations-NgUCm3TB.js";
import { t as useFoldersStore } from "./folders.store-BY8Vuq5D.js";
import "./ProjectIcon-DSgmszLL.js";
import "./useDynamicCredentials-DoTPXWtP.js";
import "./RunDataHtml-Cw8vfNJ3.js";
import "./NodeIcon-BdHBfPBt.js";
import "./useRunWorkflow-juGxUJAw.js";
import "./pushConnection.store-DEbstjnC.js";
import "./vue-json-pretty-CuBVqeNj.js";
import { t as useCollaborationStore } from "./collaboration.store-NTtbhQMS.js";
import "./dateFormatter-DCnAq71P.js";
import "./useExecutionHelpers-BOOTTweM.js";
import { t as TimeAgo_default } from "./TimeAgo-DXYgDjKy.js";
import "./roles.store-CnmTuWAs.js";
import "./KeyboardShortcutTooltip-BU16z1Q2.js";
import "./TagsDropdown-BNCsZvMf.js";
import { t as WorkflowTagsDropdown_default } from "./WorkflowTagsDropdown-Bp150m0d.js";
import { t as sanitizeFilename } from "./dist-CkSZ-RAZ.js";
import "./sso.store-CYzwTRBb.js";
import { t as router_default } from "./router-CwYP0MuY.js";
import "./insights.store-CLtsoNb5.js";
import "./insights.constants-DxLIjLji.js";
import "./insights.utils-BASoBGEw.js";
import { a as MCP_DOCS_PAGE_URL, s as MCP_SETTINGS_VIEW } from "./mcp.constants-BWjeHDaU.js";
import "./sourceControl.eventBus-CPeWfug7.js";
import { i as getLastPublishedVersion, r as generateVersionName } from "./utils-DlUruFxQ.js";
import { t as useMcp } from "./useMcp-DH5GXgOW.js";
import { t as useKeybindings } from "./useKeybindings-BrHKmGZk.js";
import { t as injectStrict } from "./injectStrict-DRL1gb3N.js";
import { t as useWorkflowActivate } from "./useWorkflowActivate-DsrXBqKN.js";
import "./useGlobalEntityCreation-CVsL3s3m.js";
import { t as LoadingView_default } from "./LoadingView-CugGjCO7.js";
import "./useSettingsItems-BPnNaxkj.js";
import { t as AppSidebar_default } from "./AppSidebar-0yg_pWGM.js";
import "./readyToRun.store-2wJgp99Y.js";
import "./resourceCenter.store-BUDGMFRL.js";
import "./useLogsTreeExpand-C5r2tV0R.js";
import { t as LogsPanel_default } from "./LogsPanel-DQmueNJk.js";
import "./AnimatedSpinner-DxjSO1-I.js";
import "./useResizablePanel-DE9WHFOF.js";
import { t as useAITemplatesStarterCollectionStore } from "./aiTemplatesStarterCollection.store-D7vqaGyU.js";
import { n as useReadyToRunWorkflowsStore, t as FolderBreadcrumbs_default } from "./FolderBreadcrumbs-CHStNoyV.js";
import { t as useExecutionDebugging } from "./useExecutionDebugging-pMrbkd3g.js";
import "./ProjectBreadcrumb-DnKbX_sP.js";
import { t as ConnectionTracker_default } from "./ConnectionTracker-CNPbWS99.js";
import { t as useWorkflowSettingsCache } from "./useWorkflowsCache-TiozQ1uR.js";
import { t as usePushConnection } from "./usePushConnection-DH5jnkU9.js";
function useLayoutProps() {
	const route = useRoute();
	return { layoutProps: computed(() => {
		return route.meta.layoutProps ?? {};
	}) };
}
function useWorkflowInitialization(workflowState) {
	const route = useRoute();
	const router = useRouter();
	const i18n = useI18n();
	const toast = useToast();
	const documentTitle = useDocumentTitle();
	const externalHooks = useExternalHooks();
	const workflowsStore = useWorkflowsStore();
	const workflowsListStore = useWorkflowsListStore();
	const uiStore = useUIStore();
	const nodeTypesStore = useNodeTypesStore();
	const credentialsStore = useCredentialsStore();
	const environmentsStore = useEnvironmentsStore();
	const externalSecretsStore = useExternalSecretsStore();
	const settingsStore = useSettingsStore();
	const projectsStore = useProjectsStore();
	const historyStore = useHistoryStore();
	const builderStore = useBuilderStore();
	const aiTemplatesStarterCollectionStore = useAITemplatesStarterCollectionStore();
	const readyToRunWorkflowsStore = useReadyToRunWorkflowsStore();
	const telemetry$1 = useTelemetry();
	const { resetWorkspace, initializeWorkspace, fitView, openWorkflowTemplate, openWorkflowTemplateFromJSON } = useCanvasOperations();
	const { fetchAndSetParentFolder } = useParentFolder();
	const { applyExecutionData } = useExecutionDebugging(workflowState);
	const isLoading = ref(true);
	const initializedWorkflowId = ref();
	const currentWorkflowDocumentStore = shallowRef(null);
	function disposeCurrentWorkflowDocumentStore() {
		if (currentWorkflowDocumentStore.value) {
			disposeWorkflowDocumentStore(createWorkflowDocumentId(currentWorkflowDocumentStore.value.workflowId, currentWorkflowDocumentStore.value.workflowVersion));
			currentWorkflowDocumentStore.value = null;
		}
	}
	const workflowId = computed(() => {
		const name = route.params.name;
		return (Array.isArray(name) ? name[0] : name) ?? "";
	});
	const isNewWorkflowRoute = computed(() => route.query.new === "true");
	const isDemoRoute = computed(() => route.name === VIEWS.DEMO);
	const isTemplateRoute = computed(() => route.name === VIEWS.TEMPLATE_IMPORT);
	const isOnboardingRoute = computed(() => route.name === VIEWS.WORKFLOW_ONBOARDING);
	const isDebugRoute = computed(() => route.name === VIEWS.EXECUTION_DEBUG);
	async function loadCredentials() {
		let options;
		if (workflowId.value && !isNewWorkflowRoute.value) options = { workflowId: workflowId.value };
		else {
			const projectId = (typeof route.query?.projectId === "string" ? route.query?.projectId : void 0) ?? projectsStore.personalProject?.id;
			if (projectId === void 0) throw new Error("Could not find projectId in the query nor could I find the personal project in the project store");
			options = { projectId };
		}
		await credentialsStore.fetchAllCredentialsForWorkflow(options);
	}
	async function handleTemplateImportRoute() {
		if (!isTemplateRoute.value) return false;
		const templateId = route.params.id;
		if (!templateId) return false;
		disposeCurrentWorkflowDocumentStore();
		if (route.query.fromJson === "true") {
			const workflow = getSampleWorkflowByTemplateId(templateId.toString());
			if (!workflow) {
				toast.showError(new Error(i18n.baseText("nodeView.couldntLoadWorkflow.invalidWorkflowObject")), i18n.baseText("nodeView.couldntImportWorkflow"));
				await router.replace({ name: VIEWS.NEW_WORKFLOW });
				return true;
			}
			await openWorkflowTemplateFromJSON(workflow);
		} else await openWorkflowTemplate(templateId.toString());
		const currentWorkflowId = workflowsStore.workflowId;
		if (currentWorkflowId) currentWorkflowDocumentStore.value = useWorkflowDocumentStore(createWorkflowDocumentId(currentWorkflowId));
		return true;
	}
	async function handleDebugModeRoute() {
		if (!isDebugRoute.value) return;
		documentTitle.setDocumentTitle(workflowsStore.workflowName, "DEBUG");
		if (!workflowsStore.isInDebugMode) {
			const executionId = route.params.executionId;
			if (typeof executionId === "string") {
				await applyExecutionData(executionId);
				workflowsStore.isInDebugMode = true;
			}
		}
	}
	async function initializeData() {
		const isPreviewPage = settingsStore.isPreviewMode && isDemoRoute.value;
		const loadPromises = (() => {
			if (isPreviewPage) return [];
			const promises = [
				workflowsListStore.fetchActiveWorkflows(),
				credentialsStore.fetchCredentialTypes(true),
				loadCredentials()
			];
			if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Variables]) promises.push(environmentsStore.fetchAllVariables());
			if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.ExternalSecrets]) {
				promises.push(externalSecretsStore.fetchGlobalSecrets());
				if (projectsStore.currentProjectId !== projectsStore.personalProject?.id && typeof projectsStore.currentProjectId === "string") promises.push(externalSecretsStore.fetchProjectSecrets(projectsStore.currentProjectId));
			}
			return promises;
		})();
		if (nodeTypesStore.allNodeTypes.length === 0) loadPromises.push(nodeTypesStore.getNodeTypes());
		try {
			if (isPreviewPage) loadPromises.push(nodeTypesStore.fetchCommunityNodePreviews());
			else nodeTypesStore.fetchCommunityNodePreviews();
			await Promise.all(loadPromises);
		} catch (error) {
			toast.showError(error, i18n.baseText("nodeView.showError.mounted1.title"), i18n.baseText("nodeView.showError.mounted1.message") + ":");
		}
	}
	async function openWorkflow(data) {
		disposeCurrentWorkflowDocumentStore();
		resetWorkspace();
		if (builderStore.streaming) documentTitle.setDocumentTitle(data.name, "AI_BUILDING");
		else documentTitle.setDocumentTitle(data.name, "IDLE");
		const { workflowDocumentStore } = await initializeWorkspace(data);
		currentWorkflowDocumentStore.value = workflowDocumentStore;
		externalHooks.run("workflow.open", {
			workflowId: data.id,
			workflowName: data.name
		});
		fitView();
	}
	async function initializeWorkspaceForNewWorkflow() {
		disposeCurrentWorkflowDocumentStore();
		resetWorkspace();
		const parentFolderId = route.query.parentFolderId;
		await workflowState.getNewWorkflowDataAndMakeShareable(void 0, projectsStore.currentProjectId, parentFolderId);
		workflowState.setWorkflowId(workflowId.value);
		currentWorkflowDocumentStore.value = useWorkflowDocumentStore(createWorkflowDocumentId(workflowId.value));
		await projectsStore.refreshCurrentProject();
		await fetchAndSetParentFolder(parentFolderId);
		uiStore.nodeViewInitialized = true;
		initializedWorkflowId.value = workflowId.value;
		fitView();
	}
	async function initializeWorkspaceForExistingWorkflow(id) {
		try {
			const workflowData = await workflowsListStore.fetchWorkflow(id);
			await openWorkflow(workflowData);
			if (workflowData.parentFolder) workflowsStore.setParentFolder(workflowData.parentFolder);
			if (workflowData.meta?.onboardingId) telemetry$1.track(`User opened workflow from onboarding template with ID ${workflowData.meta.onboardingId}`, { workflow_id: id });
			if (workflowData.meta?.templateId?.startsWith("035_template_onboarding")) aiTemplatesStarterCollectionStore.trackUserOpenedWorkflow(workflowData.meta.templateId.split("-").pop() ?? "");
			if (workflowData.meta?.templateId?.startsWith("37_onboarding_experiments_batch_aug11")) readyToRunWorkflowsStore.trackOpenWorkflow(workflowData.meta.templateId.split("-").pop() ?? "");
			await projectsStore.setProjectNavActiveIdByWorkflowHomeProject(workflowData.homeProject, workflowData.sharedWithProjects);
			workflowsStore.fetchLastSuccessfulExecution();
		} catch (error) {
			if (error.httpStatusCode === 404) return await router.replace({
				name: VIEWS.ENTITY_NOT_FOUND,
				params: { entityType: "workflow" }
			});
			if (error.httpStatusCode === 403) return await router.replace({
				name: VIEWS.ENTITY_UNAUTHORIZED,
				params: { entityType: "workflow" }
			});
			toast.showError(error, i18n.baseText("openWorkflow.workflowNotFoundError"));
			router.push({ name: VIEWS.NEW_WORKFLOW });
		} finally {
			uiStore.nodeViewInitialized = true;
			initializedWorkflowId.value = workflowId.value;
		}
	}
	async function initializeWorkflow(force = false) {
		if (uiStore.isBlankRedirect) {
			uiStore.isBlankRedirect = false;
			isLoading.value = false;
			return;
		}
		if (await handleTemplateImportRoute()) {
			isLoading.value = false;
			return;
		}
		if (!workflowId.value) {
			isLoading.value = false;
			return;
		}
		if (!force && initializedWorkflowId.value && initializedWorkflowId.value === workflowId.value) {
			await handleDebugModeRoute();
			isLoading.value = false;
			return;
		}
		isLoading.value = true;
		try {
			historyStore.reset();
			if (isDemoRoute.value) {
				await initializeWorkspaceForNewWorkflow();
				return;
			}
			if (isNewWorkflowRoute.value) if (!await workflowsListStore.checkWorkflowExists(workflowId.value) && route.meta?.nodeView === true) {
				await initializeWorkspaceForNewWorkflow();
				return;
			} else await router.replace({
				...route,
				query: {
					...route.query,
					new: void 0
				}
			});
			await initializeWorkspaceForExistingWorkflow(workflowId.value);
			await handleDebugModeRoute();
		} finally {
			isLoading.value = false;
		}
	}
	function cleanup() {
		disposeCurrentWorkflowDocumentStore();
		resetWorkspace();
		uiStore.nodeViewInitialized = false;
	}
	return {
		isLoading,
		initializedWorkflowId,
		workflowId,
		currentWorkflowDocumentStore,
		isNewWorkflowRoute,
		isDemoRoute,
		isTemplateRoute,
		isOnboardingRoute,
		isDebugRoute,
		loadCredentials,
		initializeData,
		openWorkflow,
		initializeWorkspaceForNewWorkflow,
		initializeWorkspaceForExistingWorkflow,
		handleTemplateImportRoute,
		handleDebugModeRoute,
		initializeWorkflow,
		cleanup
	};
}
var AskAssistantFloatingButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AskAssistantFloatingButton",
	setup(__props) {
		const assistantStore = useAssistantStore();
		const builderStore = useBuilderStore();
		const chatPanelStore = useChatPanelStore();
		const settingsStore = useSettingsStore();
		const i18n = useI18n();
		const { APP_Z_INDEXES } = useStyles();
		const lastUnread = computed(() => {
			const msg = assistantStore.lastUnread;
			if (msg?.type === "block") return msg.title;
			if (msg?.type === "text") return msg.content;
			if (msg?.type === "code-diff") return msg.description;
			return "";
		});
		const allowSendingParameterValues = computed(() => settingsStore.settings.ai.allowSendingParameterValues);
		const onClick = async () => {
			if (builderStore.isAIBuilderEnabled && allowSendingParameterValues.value) if (chatPanelStore.isOpen && chatPanelStore.isBuilderModeActive) chatPanelStore.close();
			else await chatPanelStore.open({ mode: "builder" });
			else await chatPanelStore.toggle({ mode: "assistant" });
			if (chatPanelStore.isOpen) assistantStore.trackUserOpenedAssistant({
				source: "canvas",
				task: "placeholder",
				has_existing_session: !assistantStore.isSessionEnded
			});
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "ask-assistant-floating-button"
			}, [createVNode(unref(N8nTooltip_default), {
				"z-index": unref(APP_Z_INDEXES).ASK_ASSISTANT_FLOATING_BUTTON_TOOLTIP,
				placement: "top",
				visible: !!lastUnread.value,
				"popper-class": _ctx.$style.tooltip
			}, {
				content: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.text) }, toDisplayString(lastUnread.value), 3), createBaseVNode("div", { class: normalizeClass(_ctx.$style.assistant) }, [createVNode(unref(AskAssistantAvatar_default), { size: "mini" }), createBaseVNode("span", null, toDisplayString(unref(i18n).baseText("aiAssistant.name")), 1)], 2)]),
				default: withCtx(() => [createVNode(unref(AskAssistantButton_default), {
					"unread-count": unref(assistantStore).unreadCount,
					onClick
				}, null, 8, ["unread-count"])]),
				_: 1
			}, 8, [
				"z-index",
				"visible",
				"popper-class"
			])], 2);
		};
	}
});
var AskAssistantFloatingButton_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_m8h8t_125",
	tooltip: "_tooltip_m8h8t_132",
	assistant: "_assistant_m8h8t_138",
	text: "_text_m8h8t_148"
};
var AskAssistantFloatingButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AskAssistantFloatingButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AskAssistantFloatingButton_vue_vue_type_style_index_0_lang_module_default }]]);
var TabBar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TabBar",
	props: {
		items: {},
		modelValue: { default: MAIN_HEADER_TABS.WORKFLOW }
	},
	emits: ["update:modelValue"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		function onUpdateModelValue(tab, event) {
			emit("update:modelValue", tab, event);
		}
		return (_ctx, _cache) => {
			return __props.items ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass({
					[_ctx.$style.container]: true,
					["tab-bar-container"]: true
				})
			}, [createVNode(unref(N8nRadioButtons_default), {
				"model-value": __props.modelValue,
				options: __props.items,
				"onUpdate:modelValue": onUpdateModelValue
			}, null, 8, ["model-value", "options"])], 2)) : createCommentVNode("", true);
		};
	}
});
var TabBar_vue_vue_type_style_index_0_lang_module_default = { container: "_container_11dda_125" };
var TabBar_default = /* @__PURE__ */ __plugin_vue_export_helper_default(TabBar_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": TabBar_vue_vue_type_style_index_0_lang_module_default }]]);
var BreakpointsObserver_default = /* @__PURE__ */ defineComponent({
	__name: "BreakpointsObserver",
	props: {
		valueXS: {},
		valueXL: {},
		valueLG: {},
		valueMD: {},
		valueSM: {},
		valueDefault: {}
	},
	setup(__props) {
		const props = __props;
		const { callDebounced } = useDebounce();
		const bannersStore = useBannersStore();
		const width = ref(window.innerWidth);
		const bp = computed(() => {
			if (width.value < 768) return "XS";
			if (width.value >= 1920) return "XL";
			if (width.value >= 1200) return "LG";
			if (width.value >= 992) return "MD";
			return "SM";
		});
		const value = computed(() => {
			if (props.valueXS && width.value < 768) return props.valueXS;
			if (props.valueXL && width.value >= 1920) return props.valueXL;
			if (props.valueLG && width.value >= 1200) return props.valueLG;
			if (props.valueMD && width.value >= 992) return props.valueMD;
			if (props.valueSM) return props.valueSM;
			return props.valueDefault;
		});
		const onResize = () => {
			callDebounced(onResizeEnd, { debounceTime: 50 });
		};
		const onResizeEnd = async () => {
			width.value = window.innerWidth;
			await nextTick();
			const bannerHeight = await getBannerRowHeight();
			bannersStore.updateBannersHeight(bannerHeight);
		};
		onMounted(() => {
			window.addEventListener("resize", onResize);
		});
		onBeforeUnmount(() => {
			window.removeEventListener("resize", onResize);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", null, [renderSlot(_ctx.$slots, "default", {
				bp: bp.value,
				value: value.value
			})]);
		};
	}
});
var WorkflowProductionChecklist_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowProductionChecklist",
	props: { workflow: {} },
	setup(__props) {
		const props = __props;
		const i18n = useI18n();
		const router = useRouter();
		const evaluationStore = useEvaluationStore();
		const nodeTypesStore = useNodeTypesStore();
		const workflowsCache = useWorkflowSettingsCache();
		const uiStore = useUIStore();
		const message = useMessage();
		const telemetry$1 = useTelemetry();
		const sourceControlStore = useSourceControlStore();
		const settingsStore = useSettingsStore();
		const { isEligibleForMcpAccess } = useMcp();
		const usersStore = useUsersStore();
		const isPopoverOpen = ref(false);
		const cachedSettings = ref(null);
		const hasAINode = computed(() => {
			return props.workflow.nodes.some((node) => {
				return nodeTypesStore.getNodeType(node.type, node.typeVersion)?.codex?.categories?.includes("AI");
			});
		});
		const hasEvaluationSetOutputsNode = computed(() => {
			return evaluationStore.evaluationSetOutputsNodeExist;
		});
		const hasErrorWorkflow = computed(() => {
			return !!props.workflow.settings?.errorWorkflow;
		});
		const hasSavedTimeNodes = computed(() => {
			if (!props.workflow?.nodes) return false;
			return props.workflow.nodes.some((node) => node.type === "n8n-nodes-base.timeSaved" && node.disabled !== true);
		});
		const hasTimeSaved = computed(() => {
			return props.workflow.settings?.timeSavedPerExecution !== void 0 || hasSavedTimeNodes.value;
		});
		const isActivationModalOpen = computed(() => {
			return uiStore.isModalActiveById[WORKFLOW_ACTIVE_MODAL_KEY];
		});
		const isProtectedEnvironment = computed(() => {
			return sourceControlStore.preferences.branchReadOnly;
		});
		const isOwner = computed(() => usersStore.isInstanceOwner);
		const isAdmin = computed(() => usersStore.isAdmin);
		const isMcpModuleEnabled = computed(() => {
			return settingsStore.isModuleActive("mcp");
		});
		const isMcpAccessEnabled = computed(() => {
			return settingsStore.moduleSettings.mcp?.mcpAccessEnabled ?? false;
		});
		const isWorkflowEligibleForMcpAccess = computed(() => {
			return isEligibleForMcpAccess(props.workflow);
		});
		const canToggleInstanceMCPAccess = computed(() => isOwner.value || isAdmin.value);
		const availableActions = computed(() => {
			if (props.workflow.activeVersionId === null || workflowsCache.isCacheLoading.value) return [];
			const actions = [];
			const suggestedActionSettings = cachedSettings.value?.suggestedActions ?? {};
			if (!suggestedActionSettings.errorWorkflow?.ignored) actions.push({
				id: "errorWorkflow",
				title: i18n.baseText("workflowProductionChecklist.errorWorkflow.title"),
				description: i18n.baseText("workflowProductionChecklist.errorWorkflow.description"),
				moreInfoLink: ERROR_WORKFLOW_DOCS_URL,
				completed: hasErrorWorkflow.value
			});
			if (hasAINode.value && evaluationStore.isEvaluationEnabled && !suggestedActionSettings.evaluations?.ignored) actions.push({
				id: "evaluations",
				title: i18n.baseText("workflowProductionChecklist.evaluations.title"),
				description: i18n.baseText("workflowProductionChecklist.evaluations.description"),
				moreInfoLink: EVALUATIONS_DOCS_URL,
				completed: hasEvaluationSetOutputsNode.value
			});
			if (!suggestedActionSettings.timeSaved?.ignored) actions.push({
				id: "timeSaved",
				title: i18n.baseText("workflowProductionChecklist.timeSaved.title"),
				description: i18n.baseText("workflowProductionChecklist.timeSaved.description"),
				moreInfoLink: TIME_SAVED_DOCS_URL,
				completed: hasTimeSaved.value
			});
			const mcpAction = getMcpAction();
			if (mcpAction) actions.push(mcpAction);
			return actions;
			function getMcpAction() {
				if (!isMcpModuleEnabled.value || !isWorkflowEligibleForMcpAccess.value) return null;
				const baseAction = {
					title: i18n.baseText("mcp.productionChecklist.title"),
					moreInfoLink: MCP_DOCS_PAGE_URL
				};
				if (!isMcpAccessEnabled.value) {
					if (!canToggleInstanceMCPAccess.value || suggestedActionSettings["instance-mcp-access"]?.ignored) return null;
					return {
						...baseAction,
						id: "instance-mcp-access",
						description: i18n.baseText("mcp.productionChecklist.instance.description"),
						completed: false
					};
				}
				if (suggestedActionSettings["workflow-mcp-access"]?.ignored) return null;
				return {
					...baseAction,
					id: "workflow-mcp-access",
					description: i18n.baseText("mcp.productionChecklist.workflow.description"),
					completed: props.workflow.settings?.availableInMCP ?? false
				};
			}
		});
		async function loadWorkflowSettings() {
			if (props.workflow.id) cachedSettings.value = await workflowsCache.getMergedWorkflowSettings(props.workflow.id);
		}
		async function handleActionClick(actionId) {
			switch (actionId) {
				case "evaluations":
					await router.push({
						name: VIEWS.EVALUATION_EDIT,
						params: { name: props.workflow.id }
					});
					break;
				case "errorWorkflow":
				case "timeSaved":
				case "workflow-mcp-access":
					uiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);
					break;
				case "instance-mcp-access":
					await router.push({ name: MCP_SETTINGS_VIEW });
					break;
				default: break;
			}
			isPopoverOpen.value = false;
		}
		function isValidAction(action) {
			return [
				"evaluations",
				"errorWorkflow",
				"timeSaved",
				"workflow-mcp-access",
				"instance-mcp-access"
			].includes(action);
		}
		async function handleIgnoreClick(actionId) {
			if (!isValidAction(actionId)) return;
			await workflowsCache.ignoreSuggestedAction(props.workflow.id, actionId);
			await loadWorkflowSettings();
			telemetry$1.track("user clicked ignore suggested action", { actionId });
		}
		async function handleIgnoreAll() {
			if (await message.confirm(i18n.baseText("workflowProductionChecklist.ignoreAllConfirmation.description"), i18n.baseText("workflowProductionChecklist.ignoreAllConfirmation.title"), { confirmButtonText: i18n.baseText("workflowProductionChecklist.ignoreAllConfirmation.confirm") }) === "confirm") {
				await workflowsCache.ignoreAllSuggestedActionsForAllWorkflows(availableActions.value.map((action) => action.id));
				await loadWorkflowSettings();
				telemetry$1.track("user clicked ignore suggested actions for all workflows");
			}
		}
		function openSuggestedActions() {
			isPopoverOpen.value = true;
		}
		function onPopoverOpened() {
			telemetry$1.track("user opened suggested actions checklist");
		}
		function handlePopoverOpenChange(open) {
			if (open) {
				isPopoverOpen.value = true;
				onPopoverOpened();
			} else if (!isActivationModalOpen.value) isPopoverOpen.value = false;
		}
		watch(() => !!props.workflow.activeVersionId, async (isActive, wasActive) => {
			if (isActive && !wasActive) {
				if (!cachedSettings.value?.firstActivatedAt) setTimeout(() => {
					openSuggestedActions();
				}, 0);
				await workflowsCache.updateFirstActivatedAt(props.workflow.id);
			}
		});
		onMounted(async () => {
			await loadWorkflowSettings();
		});
		return (_ctx, _cache) => {
			return availableActions.value.length > 0 ? (openBlock(), createBlock(unref(SuggestedActions_default), {
				key: 0,
				open: isPopoverOpen.value,
				title: unref(i18n).baseText("workflowProductionChecklist.title"),
				actions: availableActions.value,
				"ignore-all-label": unref(i18n).baseText("workflowProductionChecklist.turnOffWorkflowSuggestions"),
				notice: isProtectedEnvironment.value ? unref(i18n).baseText("workflowProductionChecklist.readOnlyNotice") : "",
				"popover-alignment": "end",
				onActionClick: handleActionClick,
				onIgnoreClick: handleIgnoreClick,
				onIgnoreAll: handleIgnoreAll,
				"onUpdate:open": handlePopoverOpenChange
			}, null, 8, [
				"open",
				"title",
				"actions",
				"ignore-all-label",
				"notice"
			])) : createCommentVNode("", true);
		};
	}
});
var IntersectionObserver_default = /* @__PURE__ */ defineComponent({
	__name: "IntersectionObserver",
	props: {
		threshold: { default: 0 },
		enabled: {
			type: Boolean,
			default: false
		},
		eventBus: {}
	},
	emits: ["observed"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const observer = ref(null);
		const root = ref(null);
		onBeforeUnmount(() => {
			if (props.enabled && observer.value) observer.value.disconnect();
		});
		onMounted(() => {
			if (!props.enabled) return;
			const options = {
				root: root.value,
				rootMargin: "0px",
				threshold: props.threshold
			};
			const intersectionObserver = new IntersectionObserver((entries) => {
				entries.forEach(({ target, isIntersecting }) => {
					emit("observed", {
						el: target,
						isIntersecting
					});
				});
			}, options);
			observer.value = intersectionObserver;
			props.eventBus.on("observe", (observed) => {
				if (observed) intersectionObserver.observe(observed);
			});
			props.eventBus.on("unobserve", (observed) => {
				intersectionObserver.unobserve(observed);
			});
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "root",
				ref: root
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});
var IntersectionObserved_default = /* @__PURE__ */ defineComponent({
	__name: "IntersectionObserved",
	props: {
		enabled: {
			type: Boolean,
			default: false
		},
		eventBus: {}
	},
	setup(__props) {
		const props = __props;
		const observed = ref(null);
		onMounted(async () => {
			if (!props.enabled) return;
			await nextTick();
			props.eventBus.emit("observe", observed.value);
		});
		onBeforeUnmount(() => {
			if (props.enabled) props.eventBus.emit("unobserve", observed.value);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("span", {
				ref_key: "observed",
				ref: observed
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});
var import_debounce = /* @__PURE__ */ __toESM(require_debounce(), 1);
var _hoisted_1$3 = { class: "tags" };
var _hoisted_2$2 = ["onClick"];
var TagsContainer_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	__name: "TagsContainer",
	props: {
		tagIds: {},
		tagsById: {},
		limit: { default: 20 },
		clickable: {
			type: Boolean,
			default: false
		},
		responsive: {
			type: Boolean,
			default: false
		}
	},
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const maxWidth = ref(320);
		const intersectionEventBus = createEventBus();
		const visibility = ref({});
		const tagsContainer = ref();
		const style = computed(() => ({ "max-width": `${maxWidth.value}px` }));
		const tags = computed(() => {
			const allTags = props.tagIds.map((tagId) => props.tagsById[tagId]).filter(Boolean);
			let toDisplay = props.limit ? allTags.slice(0, props.limit) : allTags;
			toDisplay = toDisplay.map((tag) => ({
				...tag,
				hidden: props.responsive && !visibility.value[tag.id]
			}));
			let visibleCount = toDisplay.length;
			if (props.responsive) visibleCount = Object.values(visibility.value).reduce((accu, val) => val ? accu + 1 : accu, 0);
			if (visibleCount < allTags.length) {
				const hidden = allTags.slice(visibleCount);
				const hiddenTitle = hidden.reduce((accu, tag) => accu ? `${accu}, ${tag.name}` : tag.name, "");
				const countTag = {
					id: "count",
					name: `+${hidden.length}`,
					title: hiddenTitle,
					isCount: true
				};
				toDisplay.splice(visibleCount, 0, countTag);
			}
			return toDisplay;
		});
		const setMaxWidth = () => {
			const parent = (tagsContainer.value?.$el)?.parentNode;
			if (parent) {
				maxWidth.value = 0;
				nextTick(() => {
					maxWidth.value = parent.clientWidth;
				});
			}
		};
		const debouncedSetMaxWidth = (0, import_debounce.default)(setMaxWidth, 100);
		const onObserved = ({ el, isIntersecting }) => {
			if (el.dataset.id) visibility.value = {
				...visibility.value,
				[el.dataset.id]: isIntersecting
			};
		};
		const onClick = (e, tag) => {
			if (props.clickable) e.stopPropagation();
			if (!tag.hidden) emit("click", tag.id);
		};
		onMounted(() => {
			setMaxWidth();
			window.addEventListener("resize", debouncedSetMaxWidth);
		});
		onBeforeUnmount(() => {
			window.removeEventListener("resize", debouncedSetMaxWidth);
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(IntersectionObserver_default, {
				ref_key: "tagsContainer",
				ref: tagsContainer,
				threshold: 1,
				class: "tags-container",
				style: normalizeStyle(style.value),
				enabled: __props.responsive,
				"event-bus": unref(intersectionEventBus),
				onObserved
			}, {
				default: withCtx(() => [createBaseVNode("span", _hoisted_1$3, [(openBlock(true), createElementBlock(Fragment, null, renderList(tags.value, (tag) => {
					return openBlock(), createElementBlock("span", {
						key: tag.id,
						class: normalizeClass({ clickable: !tag.hidden }),
						onClick: (e) => onClick(e, tag)
					}, [tag.isCount ? (openBlock(), createBlock(unref(N8nTag_default), {
						key: 0,
						title: tag.title,
						text: tag.name,
						clickable: false,
						class: "count-container"
					}, null, 8, ["title", "text"])) : (openBlock(), createBlock(IntersectionObserved_default, {
						key: 1,
						class: normalizeClass({ hideTag: tag.hidden }),
						"data-id": tag.id,
						enabled: __props.responsive,
						"event-bus": unref(intersectionEventBus)
					}, {
						default: withCtx(() => [createVNode(unref(N8nTag_default), {
							title: tag.name,
							text: tag.name,
							clickable: __props.clickable
						}, null, 8, [
							"title",
							"text",
							"clickable"
						])]),
						_: 2
					}, 1032, [
						"class",
						"data-id",
						"enabled",
						"event-bus"
					]))], 10, _hoisted_2$2);
				}), 128))])]),
				_: 1
			}, 8, [
				"style",
				"enabled",
				"event-bus"
			]);
		};
	}
}), [["__scopeId", "data-v-8ecf8b55"]]);
var WorkflowTagsContainer_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowTagsContainer",
	props: {
		tagIds: {},
		limit: {},
		clickable: { type: Boolean },
		responsive: { type: Boolean }
	},
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const annotationTagsStore = useTagsStore();
		const tagsById = computed(() => annotationTagsStore.tagsById);
		function onClick(tagId) {
			emit("click", tagId);
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(TagsContainer_default, {
				"tag-ids": __props.tagIds,
				"tags-by-id": tagsById.value,
				limit: __props.limit,
				clickable: __props.clickable,
				responsive: __props.responsive,
				onClick
			}, null, 8, [
				"tag-ids",
				"tags-by-id",
				"limit",
				"clickable",
				"responsive"
			]);
		};
	}
});
var import_FileSaver_min = /* @__PURE__ */ __toESM(require_FileSaver_min(), 1);
const getWorkflowId = (propId, routeName) => {
	return propId ?? (typeof routeName === "string" ? routeName : void 0);
};
var ActionsDropdownMenu_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ActionsDropdownMenu",
	props: {
		workflowPermissions: {},
		isNewWorkflow: { type: Boolean },
		isArchived: { type: Boolean },
		id: {},
		name: {},
		tags: {},
		currentFolder: {},
		meta: {}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const importFileRef = ref();
		const toast = useToast();
		const locale = useI18n();
		const route = useRoute();
		const projectsStore = useProjectsStore();
		const sourceControlStore = useSourceControlStore();
		const collaborationStore = useCollaborationStore();
		const workflowsListStore = useWorkflowsListStore();
		const uiStore = useUIStore();
		const $style = useCssModule();
		const rootStore = useRootStore();
		const tagsStore = useTagsStore();
		const settingsStore = useSettingsStore();
		const usersStore = useUsersStore();
		const workflowHelpers = useWorkflowHelpers();
		const changeOwnerEventBus = createEventBus();
		const workflowTelemetry = useTelemetry();
		const onWorkflowPage = computed(() => {
			return route.meta && (route.meta.nodeView || route.meta.keepWorkflowAlive === true);
		});
		const onExecutionsTab = computed(() => {
			return [
				VIEWS.EXECUTION_HOME.toString(),
				VIEWS.WORKFLOW_EXECUTIONS.toString(),
				VIEWS.EXECUTION_PREVIEW
			].includes(route.name || "");
		});
		const collaborationReadOnly = computed(() => collaborationStore.shouldBeReadOnly);
		const isSharingEnabled = computed(() => settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]);
		function handleFileImport() {
			const inputRef = importFileRef.value;
			if (inputRef?.files && inputRef.files.length !== 0) {
				const reader = new FileReader();
				reader.onload = () => {
					let workflowData;
					try {
						workflowData = JSON.parse(reader.result);
					} catch (error) {
						toast.showMessage({
							title: locale.baseText("mainSidebar.showMessage.handleFileImport.title"),
							message: locale.baseText("mainSidebar.showMessage.handleFileImport.message"),
							type: "error"
						});
						return;
					} finally {
						reader.onload = null;
						inputRef.value = "";
					}
					nodeViewEventBus.emit("importWorkflowData", { data: workflowData });
				};
				reader.readAsText(inputRef.files[0]);
			}
		}
		const workflowMenuItems = computed(() => {
			const actions = [{
				id: WORKFLOW_MENU_ACTIONS.DOWNLOAD,
				label: locale.baseText("menuActions.download"),
				disabled: !onWorkflowPage.value
			}];
			if (isSharingEnabled.value) actions.push({
				id: WORKFLOW_MENU_ACTIONS.SHARE,
				label: locale.baseText("workflowDetails.share"),
				disabled: !onWorkflowPage.value
			});
			if (props.workflowPermissions.move && projectsStore.isTeamProjectFeatureEnabled) actions.push({
				id: WORKFLOW_MENU_ACTIONS.CHANGE_OWNER,
				label: locale.baseText("workflows.item.changeOwner"),
				disabled: props.isNewWorkflow
			});
			if (!collaborationReadOnly.value && !props.isArchived && !sourceControlStore.preferences.branchReadOnly) actions.push({
				id: WORKFLOW_MENU_ACTIONS.RENAME,
				label: locale.baseText("generic.rename"),
				disabled: !onWorkflowPage.value || props.workflowPermissions.update !== true
			});
			if (props.workflowPermissions.update === true && !collaborationReadOnly.value && !props.isArchived && !sourceControlStore.preferences.branchReadOnly || props.isNewWorkflow) {
				actions.unshift({
					id: WORKFLOW_MENU_ACTIONS.DUPLICATE,
					label: locale.baseText("menuActions.duplicate"),
					disabled: !onWorkflowPage.value || !props.id
				});
				actions.unshift({
					id: WORKFLOW_MENU_ACTIONS.EDIT_DESCRIPTION,
					label: locale.baseText("menuActions.editDescription"),
					disabled: !onWorkflowPage.value || !props.id
				});
				actions.push({
					id: WORKFLOW_MENU_ACTIONS.IMPORT_FROM_URL,
					label: locale.baseText("menuActions.importFromUrl"),
					disabled: !onWorkflowPage.value || onExecutionsTab.value
				}, {
					id: WORKFLOW_MENU_ACTIONS.IMPORT_FROM_FILE,
					label: locale.baseText("menuActions.importFromFile"),
					disabled: !onWorkflowPage.value || onExecutionsTab.value
				});
			}
			if (hasPermission(["rbac"], { rbac: { scope: "sourceControl:push" } })) actions.push({
				id: WORKFLOW_MENU_ACTIONS.PUSH,
				label: locale.baseText("menuActions.push"),
				disabled: !sourceControlStore.isEnterpriseSourceControlEnabled || !onWorkflowPage.value || onExecutionsTab.value || sourceControlStore.preferences.branchReadOnly
			});
			actions.push({
				id: WORKFLOW_MENU_ACTIONS.SETTINGS,
				label: locale.baseText("generic.settings"),
				disabled: !onWorkflowPage.value || props.isNewWorkflow
			});
			if (props.workflowPermissions.delete === true && !collaborationReadOnly.value && !sourceControlStore.preferences.branchReadOnly || props.isNewWorkflow) if (props.isArchived) {
				actions.push({
					id: WORKFLOW_MENU_ACTIONS.UNARCHIVE,
					label: locale.baseText("menuActions.unarchive"),
					disabled: !onWorkflowPage.value || props.isNewWorkflow
				});
				actions.push({
					id: WORKFLOW_MENU_ACTIONS.DELETE,
					label: locale.baseText("menuActions.delete"),
					disabled: !onWorkflowPage.value || props.isNewWorkflow,
					customClass: $style.deleteItem,
					divided: true
				});
			} else actions.push({
				id: WORKFLOW_MENU_ACTIONS.ARCHIVE,
				label: locale.baseText("menuActions.archive"),
				disabled: !onWorkflowPage.value || props.isNewWorkflow,
				customClass: $style.deleteItem,
				divided: true
			});
			return actions;
		});
		async function onWorkflowMenuSelect(action) {
			switch (action) {
				case WORKFLOW_MENU_ACTIONS.EDIT_DESCRIPTION: {
					const workflowId = getWorkflowId(props.id, route.params.name);
					if (!workflowId) return;
					const workflowDescription = workflowsListStore.getWorkflowById(workflowId).description;
					uiStore.openModalWithData({
						name: WORKFLOW_DESCRIPTION_MODAL_KEY,
						data: {
							workflowId,
							workflowDescription
						}
					});
					break;
				}
				case WORKFLOW_MENU_ACTIONS.DUPLICATE:
					uiStore.openModalWithData({
						name: DUPLICATE_MODAL_KEY,
						data: {
							id: props.id,
							name: props.name,
							tags: props.tags,
							parentFolderId: props.currentFolder?.id
						}
					});
					break;
				case WORKFLOW_MENU_ACTIONS.RENAME:
					nodeViewEventBus.emit("renameWorkflow");
					break;
				case WORKFLOW_MENU_ACTIONS.DOWNLOAD: {
					const workflowData = await workflowHelpers.getWorkflowDataToSave();
					const { tags, ...data } = workflowData;
					const exportData = {
						...data,
						meta: {
							...props.meta,
							instanceId: rootStore.instanceId
						},
						tags: (tags ?? []).map((tagId) => {
							const { usageCount, ...tag } = tagsStore.tagsById[tagId];
							return tag;
						})
					};
					const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json;charset=utf-8" });
					let name = props.name || "unsaved_workflow";
					name = sanitizeFilename(name);
					telemetry.track("User exported workflow", { workflow_id: workflowData.id });
					(0, import_FileSaver_min.default)(blob, name + ".json");
					break;
				}
				case WORKFLOW_MENU_ACTIONS.IMPORT_FROM_URL:
					uiStore.openModal(IMPORT_WORKFLOW_URL_MODAL_KEY);
					break;
				case WORKFLOW_MENU_ACTIONS.IMPORT_FROM_FILE:
					nodeViewEventBus.emit("importWorkflowFromFile");
					break;
				case WORKFLOW_MENU_ACTIONS.PUSH:
					try {
						router_default.push({ query: {
							...route.query,
							sourceControl: "push"
						} });
					} catch (error) {
						switch (error.message) {
							case "source_control_not_connected":
								toast.showError({
									...error,
									message: ""
								}, locale.baseText("settings.sourceControl.error.not.connected.title"), locale.baseText("settings.sourceControl.error.not.connected.message"));
								break;
							default: toast.showError(error, locale.baseText("error"));
						}
					}
					break;
				case WORKFLOW_MENU_ACTIONS.SETTINGS:
					uiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);
					break;
				case WORKFLOW_MENU_ACTIONS.SHARE:
					uiStore.openModalWithData({
						name: WORKFLOW_SHARE_MODAL_KEY,
						data: { id: props.id }
					});
					workflowTelemetry.track("User opened sharing modal", {
						workflow_id: props.id,
						user_id_sharer: usersStore.currentUser?.id,
						sub_view: route.name === VIEWS.WORKFLOWS ? "Workflows listing" : "Workflow editor"
					});
					break;
				case WORKFLOW_MENU_ACTIONS.ARCHIVE:
					nodeViewEventBus.emit("archiveWorkflow");
					break;
				case WORKFLOW_MENU_ACTIONS.UNARCHIVE:
					nodeViewEventBus.emit("unarchiveWorkflow");
					break;
				case WORKFLOW_MENU_ACTIONS.DELETE:
					nodeViewEventBus.emit("deleteWorkflow");
					break;
				case WORKFLOW_MENU_ACTIONS.CHANGE_OWNER: {
					const workflowId = getWorkflowId(props.id, route.params.name);
					if (!workflowId) return;
					changeOwnerEventBus.once("resource-moved", async () => await router_default.push({ name: VIEWS.WORKFLOWS }));
					uiStore.openModalWithData({
						name: PROJECT_MOVE_RESOURCE_MODAL,
						data: {
							resource: workflowsListStore.workflowsById[workflowId],
							resourceType: ResourceType.Workflow,
							resourceTypeLabel: locale.baseText("generic.workflow").toLowerCase(),
							eventBus: changeOwnerEventBus
						}
					});
					break;
				}
				default: break;
			}
		}
		__expose({ importFileRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass([unref($style).group]) }, [createBaseVNode("input", {
				ref_key: "importFileRef",
				ref: importFileRef,
				class: normalizeClass(unref($style).hiddenInput),
				type: "file",
				"data-test-id": "workflow-import-input",
				onChange: _cache[0] || (_cache[0] = ($event) => handleFileImport())
			}, null, 34), createVNode(unref(N8nActionDropdown_default), {
				items: workflowMenuItems.value,
				"data-test-id": "workflow-menu",
				onSelect: onWorkflowMenuSelect
			}, null, 8, ["items"])], 2);
		};
	}
});
var ActionsDropdownMenu_vue_vue_type_style_index_0_lang_module_default = {
	deleteItem: "_deleteItem_ldsb8_125",
	group: "_group_ldsb8_129",
	hiddenInput: "_hiddenInput_ldsb8_134"
};
var ActionsDropdownMenu_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ActionsDropdownMenu_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ActionsDropdownMenu_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$2 = { key: 0 };
var _hoisted_2$1 = { key: 1 };
var _hoisted_3 = { key: 2 };
var _hoisted_4 = { key: 3 };
var WorkflowHistoryButton_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowHistoryButton",
	props: {
		workflowId: {},
		isNewWorkflow: { type: Boolean }
	},
	setup(__props) {
		const locale = useI18n();
		const props = __props;
		const uiStore = useUIStore();
		const saveStore = useWorkflowSaveStore();
		const isWorkflowSaving = ref(false);
		const { debounce: debounce$1 } = useDebounce();
		const debouncedRemoveSaveIndicator = debounce$1(() => {
			isWorkflowSaving.value = false;
		}, {
			debounceTime: LOADING_ANIMATION_MIN_DURATION,
			trailing: true
		});
		watch(() => uiStore.isActionActive.workflowSaving, (isSaving) => {
			if (isSaving) isWorkflowSaving.value = true;
			else debouncedRemoveSaveIndicator();
		});
		const workflowHistoryRoute = computed(() => ({
			name: VIEWS.WORKFLOW_HISTORY,
			params: { workflowId: props.workflowId }
		}));
		const isScheduled = computed(() => saveStore.autoSaveState === AutoSaveState.Scheduled);
		const isDisabled = computed(() => props.isNewWorkflow || isScheduled.value || isWorkflowSaving.value);
		return (_ctx, _cache) => {
			return __props.workflowId ? (openBlock(), createBlock(unref(N8nTooltip_default), {
				key: 0,
				placement: "bottom",
				"show-after": 300
			}, {
				content: withCtx(() => [__props.isNewWorkflow ? (openBlock(), createElementBlock("span", _hoisted_1$2, toDisplayString(unref(locale).baseText("workflowHistory.button.tooltip.empty")), 1)) : isScheduled.value ? (openBlock(), createElementBlock("span", _hoisted_2$1, toDisplayString(unref(locale).baseText("workflowHistory.button.tooltip.scheduled")), 1)) : isWorkflowSaving.value ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(unref(locale).baseText("workflowHistory.button.tooltip.saving")), 1)) : (openBlock(), createElementBlock("span", _hoisted_4, toDisplayString(unref(locale).baseText("workflowHistory.button.tooltip")), 1))]),
				default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(isDisabled.value ? "div" : unref(RouterLink)), { to: isDisabled.value ? void 0 : workflowHistoryRoute.value }, {
					default: withCtx(() => [createVNode(unref(N8nIconButton_default), {
						class: "n8n-button--highlight",
						variant: "ghost",
						disabled: isDisabled.value,
						loading: isWorkflowSaving.value,
						"data-test-id": "workflow-history-button",
						icon: "history",
						size: "medium"
					}, null, 8, ["disabled", "loading"])]),
					_: 1
				}, 8, ["to"]))]),
				_: 1
			})) : createCommentVNode("", true);
		};
	}
});
var CollaborationPane_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CollaborationPane",
	setup(__props) {
		const collaborationStore = useCollaborationStore();
		const usersStore = useUsersStore();
		watch(useDocumentVisibility(), (visibilityState) => {
			if (visibilityState === "hidden") collaborationStore.stopHeartbeat();
			else collaborationStore.startHeartbeat();
		});
		const showUserStack = computed(() => collaborationStore.collaborators.length > 1);
		const collaboratorsSorted = computed(() => {
			const users = collaborationStore.collaborators.map(({ user }) => user);
			const index = users.findIndex((user) => user.id === usersStore.currentUser?.id);
			if (index < 1) return { defaultGroup: users };
			const [currentUser] = users.splice(index, 1);
			return { defaultGroup: [currentUser, ...users] };
		});
		const currentUserEmail = computed(() => usersStore.currentUser?.email);
		onMounted(() => {
			collaborationStore.initialize();
		});
		onBeforeUnmount(() => {
			collaborationStore.terminate();
		});
		return (_ctx, _cache) => {
			return showUserStack.value ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(`collaboration-pane-container ${_ctx.$style.container}`),
				"data-test-id": "collaboration-pane"
			}, [createVNode(unref(N8nUserStack_default), {
				users: collaboratorsSorted.value,
				"current-user-email": currentUserEmail.value
			}, null, 8, ["users", "current-user-email"])], 2)) : createCommentVNode("", true);
		};
	}
});
var CollaborationPane_vue_vue_type_style_index_0_lang_module_default = { container: "_container_cvwuq_125" };
var CollaborationPane_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CollaborationPane_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CollaborationPane_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$1 = { "data-test-id": "workflow-active-version-info" };
var VERSION_ACTIONS = /* @__PURE__ */ function(VERSION_ACTIONS$1) {
	VERSION_ACTIONS$1["PUBLISH"] = "publish";
	VERSION_ACTIONS$1["NAME_VERSION"] = "name-version";
	VERSION_ACTIONS$1["UNPUBLISH"] = "unpublish";
	return VERSION_ACTIONS$1;
}(VERSION_ACTIONS || {});
var WorkflowHeaderDraftPublishActions_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowHeaderDraftPublishActions",
	props: {
		id: {},
		tags: {},
		name: {},
		meta: {},
		currentFolder: {},
		isArchived: { type: Boolean },
		isNewWorkflow: { type: Boolean },
		workflowPermissions: {}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const actionsMenuRef = useTemplateRef("actionsMenu");
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const collaborationStore = useCollaborationStore();
		const projectStore = useProjectsStore();
		const workflowHistoryStore = useWorkflowHistoryStore();
		const settingsStore = useSettingsStore();
		const i18n = useI18n();
		const router = useRouter();
		const toast = useToast();
		const saveStore = useWorkflowSaveStore();
		const { saveCurrentWorkflow, cancelAutoSave } = useWorkflowSaving({ router });
		const workflowActivate = useWorkflowActivate();
		const isNamedVersionsEnabled = computed(() => settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.NamedVersions]);
		const autoSaveForPublish = ref(false);
		const importFileRef = computed(() => actionsMenuRef.value?.importFileRef);
		const foundTriggers = computed(() => getActivatableTriggerNodes(workflowsStore.workflowTriggerNodes));
		const containsTrigger = computed(() => {
			return foundTriggers.value.length > 0;
		});
		const workflowPublishState = computed(() => {
			const hasBeenPublished = !!workflowsStore.workflow.activeVersion;
			const hasChanges = workflowsStore.workflow.versionId !== workflowsStore.workflow.activeVersion?.versionId || uiStore.hasUnsavedWorkflowChanges;
			if (!hasBeenPublished) return containsTrigger.value && !workflowsStore.nodesIssuesExist ? "not-published-eligible" : "not-published-not-eligible";
			if (!containsTrigger.value) return "published-invalid-trigger";
			if (workflowsStore.nodesIssuesExist) return "published-node-issues";
			return hasChanges ? "published-with-changes" : "published-no-changes";
		});
		const collaborationReadOnly = computed(() => collaborationStore.shouldBeReadOnly);
		const hasUpdatePermission = computed(() => props.workflowPermissions.update);
		const hasPublishPermission = computed(() => props.workflowPermissions.publish);
		const hasUnpublishPermission = computed(() => props.workflowPermissions.unpublish);
		const isPersonalSpace = computed(() => projectStore.currentProject?.type === ProjectTypes.Personal);
		const saveBeforePublish = async () => {
			let saved = false;
			if (saveStore.autoSaveState === AutoSaveState.InProgress && saveStore.pendingSave) {
				autoSaveForPublish.value = true;
				try {
					await saveStore.pendingSave;
					saved = true;
				} catch {} finally {
					autoSaveForPublish.value = false;
				}
			} else if (saveStore.autoSaveState === AutoSaveState.Scheduled) cancelAutoSave();
			if (!saved || uiStore.stateIsDirty || props.isNewWorkflow) {
				autoSaveForPublish.value = true;
				saved = await saveCurrentWorkflow({}, true);
				autoSaveForPublish.value = false;
			}
			return saved;
		};
		const onPublishButtonClick = async () => {
			if (uiStore.stateIsDirty || props.isNewWorkflow) {
				if (!await saveBeforePublish()) return;
			}
			uiStore.openModalWithData({
				name: WORKFLOW_PUBLISH_MODAL_KEY,
				data: {}
			});
		};
		const publishButtonConfig = computed(() => {
			if (!hasPublishPermission.value) {
				const defaultConfigForNoPermission = {
					text: i18n.baseText("workflows.publish"),
					enabled: false,
					showIndicator: false,
					indicatorClass: "",
					tooltip: isPersonalSpace.value ? i18n.baseText("workflows.publish.personalSpaceRestricted") : i18n.baseText("workflows.publish.permissionDenied"),
					showVersionInfo: false
				};
				if (!!workflowsStore.workflow.activeVersion) return {
					...defaultConfigForNoPermission,
					showIndicator: true,
					showVersionInfo: true,
					indicatorClass: "published"
				};
				else return defaultConfigForNoPermission;
			}
			if (props.isNewWorkflow) return {
				text: i18n.baseText("workflows.publish"),
				enabled: containsTrigger.value && !workflowsStore.nodesIssuesExist,
				showIndicator: false,
				indicatorClass: "",
				tooltip: !containsTrigger.value ? i18n.baseText("workflows.publishModal.noTriggerMessage") : workflowsStore.nodesIssuesExist ? i18n.baseText("workflowActivator.showMessage.activeChangedNodesIssuesExistTrue.title", {
					interpolate: { count: workflowsStore.nodesWithIssues.length },
					adjustToNumber: workflowsStore.nodesWithIssues.length
				}) : "",
				showVersionInfo: false
			};
			return {
				"not-published-not-eligible": {
					text: i18n.baseText("workflows.publish"),
					enabled: false,
					showIndicator: false,
					indicatorClass: "",
					tooltip: !containsTrigger.value ? i18n.baseText("workflows.publishModal.noTriggerMessage") : i18n.baseText("workflowActivator.showMessage.activeChangedNodesIssuesExistTrue.title", {
						interpolate: { count: workflowsStore.nodesWithIssues.length },
						adjustToNumber: workflowsStore.nodesWithIssues.length
					}),
					showVersionInfo: false
				},
				"not-published-eligible": {
					text: i18n.baseText("workflows.publish"),
					enabled: true,
					showIndicator: false,
					indicatorClass: "",
					tooltip: "",
					showVersionInfo: false
				},
				"published-no-changes": {
					text: i18n.baseText("generic.published"),
					enabled: false,
					showIndicator: true,
					indicatorClass: "published",
					tooltip: "",
					showVersionInfo: true
				},
				"published-with-changes": {
					text: i18n.baseText("workflows.publish"),
					enabled: true,
					showIndicator: true,
					indicatorClass: "changes",
					tooltip: i18n.baseText("workflows.publishModal.changes"),
					showVersionInfo: false
				},
				"published-node-issues": {
					text: i18n.baseText("workflows.publish"),
					enabled: false,
					showIndicator: true,
					indicatorClass: "error",
					tooltip: i18n.baseText("workflowActivator.showMessage.activeChangedNodesIssuesExistTrue.title", {
						interpolate: { count: workflowsStore.nodesWithIssues.length },
						adjustToNumber: workflowsStore.nodesWithIssues.length
					}),
					showVersionInfo: true
				},
				"published-invalid-trigger": {
					text: i18n.baseText("workflows.publish"),
					enabled: false,
					showIndicator: true,
					indicatorClass: "changes",
					tooltip: i18n.baseText("workflows.publishModal.noTriggerMessage"),
					showVersionInfo: true
				}
			}[workflowPublishState.value];
		});
		const shouldHidePublishButton = computed(() => {
			if (props.isNewWorkflow) return false;
			return props.isArchived || !hasUpdatePermission.value && !hasPublishPermission.value;
		});
		const shouldDisablePublishButton = computed(() => {
			return props.isNewWorkflow || collaborationReadOnly.value || !publishButtonConfig.value.enabled || !hasPublishPermission.value;
		});
		const activeVersion = computed(() => workflowsStore.workflow.activeVersion);
		const activeVersionName = computed(() => {
			if (!activeVersion.value) return "";
			return activeVersion.value.name ?? generateVersionName(activeVersion.value.versionId);
		});
		const latestPublishDate = computed(() => {
			return getLastPublishedVersion(activeVersion.value?.workflowPublishHistory ?? [])?.createdAt;
		});
		const versionMenuActions = computed(() => {
			const actions = [{
				id: VERSION_ACTIONS.PUBLISH,
				label: i18n.baseText("workflows.publish"),
				shortcut: {
					shiftKey: true,
					keys: ["P"]
				},
				disabled: shouldDisablePublishButton.value
			}];
			if (isNamedVersionsEnabled.value) actions.push({
				id: VERSION_ACTIONS.NAME_VERSION,
				label: i18n.baseText("generic.nameVersion"),
				shortcut: {
					metaKey: true,
					keys: ["S"]
				},
				disabled: !hasUpdatePermission.value || !workflowsStore.workflow.versionId
			});
			actions.push({
				id: VERSION_ACTIONS.UNPUBLISH,
				label: i18n.baseText("workflows.unpublish"),
				disabled: !activeVersion.value || collaborationReadOnly.value || !hasUnpublishPermission.value,
				divided: true,
				shortcut: {
					metaKey: true,
					keys: ["U"]
				}
			});
			return actions;
		});
		const onNameVersion = async () => {
			if (uiStore.stateIsDirty || props.isNewWorkflow) {
				if (!await saveBeforePublish()) return;
			}
			const versionId = workflowsStore.workflow.versionId;
			const versionData = workflowsStore.versionData;
			const nameVersionEventBus = createEventBus();
			const modalData = ref({
				versionId,
				versionName: versionData?.name ?? void 0,
				description: versionData?.description ?? void 0,
				modalTitle: i18n.baseText("workflowHistory.nameVersionModal.title"),
				submitButtonLabel: i18n.baseText("workflowHistory.nameVersionModal.confirmButton"),
				submitting: false,
				eventBus: nameVersionEventBus
			});
			nameVersionEventBus.once("submit", async (submitData) => {
				modalData.value.submitting = true;
				try {
					await workflowHistoryStore.updateWorkflowHistoryVersion(props.id, versionId, {
						name: submitData.name,
						description: submitData.description
					});
					workflowsStore.setWorkflowVersionData({
						versionId,
						name: submitData.name,
						description: submitData.description
					});
					toast.showMessage({
						title: i18n.baseText("workflowHistory.action.nameVersion.success.title"),
						type: "success"
					});
					uiStore.closeModal(WORKFLOW_HISTORY_NAME_VERSION_MODAL_KEY);
				} catch (error) {
					toast.showError(error, i18n.baseText("workflowHistory.action.nameVersion.error.title"));
				} finally {
					modalData.value.submitting = false;
				}
			});
			uiStore.openModalWithData({
				name: WORKFLOW_HISTORY_NAME_VERSION_MODAL_KEY,
				data: modalData.value
			});
		};
		const onUnpublish = () => {
			if (!activeVersion.value) {
				toast.showMessage({
					title: i18n.baseText("workflowHistory.action.unpublish.notAvailable"),
					type: "warning"
				});
				return;
			}
			const unpublishEventBus = createEventBus();
			unpublishEventBus.once("unpublish", async () => {
				const success = await workflowActivate.unpublishWorkflowFromHistory(props.id);
				uiStore.closeModal(WORKFLOW_HISTORY_VERSION_UNPUBLISH);
				if (success) toast.showMessage({
					title: i18n.baseText("workflowHistory.action.unpublish.success.title"),
					type: "success"
				});
			});
			uiStore.openModalWithData({
				name: WORKFLOW_HISTORY_VERSION_UNPUBLISH,
				data: {
					versionName: activeVersion.value.name,
					eventBus: unpublishEventBus
				}
			});
		};
		const onDropdownMenuSelect = async (action) => {
			switch (action) {
				case VERSION_ACTIONS.PUBLISH:
					await onPublishButtonClick();
					break;
				case VERSION_ACTIONS.NAME_VERSION:
					await onNameVersion();
					break;
				case VERSION_ACTIONS.UNPUBLISH:
					onUnpublish();
					break;
				default: break;
			}
		};
		useKeybindings({
			shift_p: {
				disabled: () => shouldDisablePublishButton.value,
				run: async () => {
					await onPublishButtonClick();
				}
			},
			"ctrl+s": {
				disabled: () => !isNamedVersionsEnabled.value || !hasUpdatePermission.value || !workflowsStore.workflow.versionId,
				run: async () => {
					await onNameVersion();
				}
			},
			"ctrl+u": {
				disabled: () => !activeVersion.value || !hasPublishPermission.value || collaborationReadOnly.value,
				run: onUnpublish
			}
		});
		onMounted(() => {
			nodeViewEventBus.on("publishWorkflow", onPublishButtonClick);
			nodeViewEventBus.on("unpublishWorkflow", onUnpublish);
		});
		onBeforeUnmount(() => {
			nodeViewEventBus.off("publishWorkflow", onPublishButtonClick);
			nodeViewEventBus.off("unpublishWorkflow", onUnpublish);
		});
		__expose({ importFileRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.container) }, [
				!__props.isNewWorkflow ? (openBlock(), createBlock(CollaborationPane_default, { key: 0 })) : createCommentVNode("", true),
				!shouldHidePublishButton.value ? (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.publishButtonWrapper)
				}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.buttonGroup) }, [createVNode(unref(N8nTooltip_default), {
					disabled: workflowPublishState.value === "not-published-eligible" && props.workflowPermissions.publish,
					"show-after": 300,
					offset: 15
				}, {
					content: withCtx(() => [createBaseVNode("div", null, [publishButtonConfig.value.tooltip ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(publishButtonConfig.value.tooltip) + " ", 1), _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1))], 64)) : createCommentVNode("", true), activeVersion.value && publishButtonConfig.value.showVersionInfo ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
						createBaseVNode("span", _hoisted_1$1, toDisplayString(activeVersionName.value), 1),
						_cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
						createTextVNode(toDisplayString(unref(i18n).baseText("workflowHistory.item.active")) + " ", 1),
						latestPublishDate.value ? (openBlock(), createBlock(TimeAgo_default, {
							key: 0,
							date: latestPublishDate.value
						}, null, 8, ["date"])) : createCommentVNode("", true)
					], 64)) : createCommentVNode("", true)])]),
					default: withCtx(() => [createVNode(unref(N8nButton_default), {
						class: normalizeClass(_ctx.$style.groupButtonLeft),
						loading: autoSaveForPublish.value,
						disabled: !publishButtonConfig.value.enabled || shouldDisablePublishButton.value,
						variant: "subtle",
						"data-test-id": "workflow-open-publish-modal-button",
						onClick: onPublishButtonClick
					}, {
						default: withCtx(() => [createBaseVNode("div", { class: normalizeClass([_ctx.$style.flex]) }, [publishButtonConfig.value.showIndicator ? (openBlock(), createElementBlock("span", {
							key: 0,
							"data-test-id": "workflow-active-version-indicator",
							class: normalizeClass({
								[_ctx.$style.indicatorDot]: true,
								[_ctx.$style.indicatorPublished]: publishButtonConfig.value.indicatorClass === "published",
								[_ctx.$style.indicatorChanges]: publishButtonConfig.value.indicatorClass === "changes",
								[_ctx.$style.indicatorIssues]: publishButtonConfig.value.indicatorClass === "error"
							})
						}, null, 2)) : createCommentVNode("", true), createBaseVNode("span", { class: normalizeClass([workflowPublishState.value === "published-no-changes" && _ctx.$style.indicatorPublishedText]) }, toDisplayString(publishButtonConfig.value.text), 3)], 2)]),
						_: 1
					}, 8, [
						"class",
						"loading",
						"disabled"
					])]),
					_: 1
				}, 8, ["disabled"]), createVNode(unref(N8nActionDropdown_default), {
					items: versionMenuActions.value,
					placement: "bottom-end",
					"data-test-id": "version-menu",
					onSelect: onDropdownMenuSelect
				}, {
					activator: withCtx(() => [createVNode(unref(N8nIconButton_default), {
						class: normalizeClass(_ctx.$style.groupButtonRight),
						variant: "subtle",
						icon: "chevron-down",
						"data-test-id": "version-menu-button"
					}, null, 8, ["class"])]),
					_: 1
				}, 8, ["items"])], 2)], 2)) : createCommentVNode("", true),
				createVNode(WorkflowHistoryButton_default, {
					"workflow-id": props.id,
					"is-new-workflow": __props.isNewWorkflow
				}, null, 8, ["workflow-id", "is-new-workflow"]),
				createVNode(ActionsDropdownMenu_default, {
					id: __props.id,
					ref: "actionsMenu",
					"workflow-permissions": __props.workflowPermissions,
					"is-new-workflow": __props.isNewWorkflow,
					"is-archived": __props.isArchived,
					name: __props.name,
					tags: __props.tags,
					"current-folder": __props.currentFolder,
					meta: __props.meta
				}, null, 8, [
					"id",
					"workflow-permissions",
					"is-new-workflow",
					"is-archived",
					"name",
					"tags",
					"current-folder",
					"meta"
				])
			], 2);
		};
	}
});
var WorkflowHeaderDraftPublishActions_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_joo8n_125",
	activeVersionIndicator: "_activeVersionIndicator_joo8n_129",
	icon: "_icon_joo8n_133",
	publishButtonWrapper: "_publishButtonWrapper_joo8n_137",
	buttonGroup: "_buttonGroup_joo8n_143",
	groupButtonLeft: "_groupButtonLeft_joo8n_147",
	groupButtonRight: "_groupButtonRight_joo8n_159",
	indicatorDot: "_indicatorDot_joo8n_168",
	indicatorPublished: "_indicatorPublished_joo8n_176",
	indicatorPublishedText: "_indicatorPublishedText_joo8n_180",
	indicatorChanges: "_indicatorChanges_joo8n_184",
	indicatorIssues: "_indicatorIssues_joo8n_188",
	flex: "_flex_joo8n_192"
};
var WorkflowHeaderDraftPublishActions_default = /* @__PURE__ */ __plugin_vue_export_helper_default(WorkflowHeaderDraftPublishActions_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": WorkflowHeaderDraftPublishActions_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1 = {
	class: "tags",
	"data-test-id": "workflow-tags-container"
};
var _hoisted_2 = { key: 1 };
var WorkflowDetails_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowDetails",
	props: {
		id: {},
		tags: {},
		name: {},
		meta: {},
		scopes: {},
		active: { type: Boolean },
		currentFolder: {},
		isArchived: { type: Boolean },
		description: {}
	},
	setup(__props) {
		const WORKFLOW_NAME_BP_TO_WIDTH = {
			XS: 150,
			SM: 200,
			MD: 250,
			LG: 500,
			XL: 1e3
		};
		const props = __props;
		const $style = useCssModule();
		const settingsStore = useSettingsStore();
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const workflowsListStore = useWorkflowsListStore();
		const projectsStore = useProjectsStore();
		const collaborationStore = useCollaborationStore();
		const sourceControlStore = useSourceControlStore();
		const foldersStore = useFoldersStore();
		const i18n = useI18n();
		const router = useRouter();
		const route = useRoute();
		const locale = useI18n();
		const telemetry$1 = useTelemetry();
		const message = useMessage();
		const toast = useToast();
		const documentTitle = useDocumentTitle();
		const workflowState = injectWorkflowState();
		const workflowDocumentStore = inject(WorkflowDocumentStoreKey, null);
		const isTagsEditEnabled = ref(false);
		const appliedTagIds = ref([]);
		const workflowHeaderActionsRef = useTemplateRef("workflowHeaderActions");
		const tagsEventBus = createEventBus();
		const hasChanged = (prev, curr) => {
			if (prev.length !== curr.length) return true;
			const set = new Set(prev);
			return curr.reduce((acc, val) => acc || !set.has(val), false);
		};
		const isNewWorkflow = computed(() => {
			return !workflowsStore.isWorkflowSaved[props.id];
		});
		const workflowPermissions = computed(() => getResourcePermissions(props.scopes).workflow);
		const readOnly = computed(() => sourceControlStore.preferences.branchReadOnly || collaborationStore.shouldBeReadOnly);
		const readOnlyActions = computed(() => {
			if (isNewWorkflow.value) return readOnly.value;
			return readOnly.value || props.isArchived || !workflowPermissions.value.update;
		});
		const workflowTagIds = computed(() => props.tags);
		const currentFolderForBreadcrumbs = computed(() => {
			if (!isNewWorkflow.value && props.currentFolder) return props.currentFolder;
			const folderId = route.query.parentFolderId;
			if (folderId) return foldersStore.getCachedFolder(folderId);
			return null;
		});
		watch(() => props.id, () => {
			isTagsEditEnabled.value = false;
			renameInput.value?.forceCancel();
		});
		function onTagsEditEnable() {
			if (readOnlyActions.value) return;
			appliedTagIds.value = [...props.tags];
			isTagsEditEnabled.value = true;
			setTimeout(() => {
				renameInput.value?.forceCancel();
				tagsEventBus.emit("focus");
			}, 0);
		}
		function onTagsBlur() {
			const current = props.tags;
			const tags = appliedTagIds.value;
			if (!hasChanged(current, tags)) {
				isTagsEditEnabled.value = false;
				return;
			}
			if (readOnlyActions.value) {
				isTagsEditEnabled.value = false;
				return;
			}
			collaborationStore.requestWriteAccess();
			if (workflowDocumentStore?.value) workflowDocumentStore.value.setTags(tags);
			uiStore.markStateDirty("metadata");
			telemetry$1.track("User edited workflow tags", {
				workflow_id: props.id,
				new_tag_count: tags.length
			});
			isTagsEditEnabled.value = false;
		}
		function onTagsEditEsc() {
			isTagsEditEnabled.value = false;
		}
		const renameInput = useTemplateRef("renameInput");
		function onNameToggle() {
			if (renameInput.value?.forceFocus) renameInput.value.forceFocus();
		}
		function onNameSubmit(name) {
			const newName = name.trim();
			if (!newName) {
				toast.showMessage({
					title: locale.baseText("renameAction.emptyName.title"),
					message: locale.baseText("renameAction.emptyName.message"),
					type: "error"
				});
				renameInput.value?.forceCancel();
				return;
			}
			if (newName === props.name) {
				renameInput.value?.forceCancel();
				return;
			}
			workflowState.setWorkflowName({
				newName,
				setStateDirty: true
			});
			documentTitle.setDocumentTitle(newName, "IDLE");
			renameInput.value?.forceCancel();
		}
		async function handleArchiveWorkflow() {
			if (props.active) {
				if (await message.confirm(locale.baseText("mainSidebar.confirmMessage.workflowArchive.message", { interpolate: { workflowName: props.name } }), locale.baseText("mainSidebar.confirmMessage.workflowArchive.headline"), {
					type: "warning",
					confirmButtonText: locale.baseText("mainSidebar.confirmMessage.workflowArchive.confirmButtonText"),
					cancelButtonText: locale.baseText("mainSidebar.confirmMessage.workflowArchive.cancelButtonText")
				}) !== "confirm") return;
			}
			try {
				const expectedChecksum = props.id === workflowsStore.workflowId ? workflowsStore.workflowChecksum : void 0;
				await workflowsStore.archiveWorkflow(props.id, expectedChecksum);
			} catch (error) {
				toast.showError(error, locale.baseText("generic.archiveWorkflowError"));
				return;
			}
			uiStore.markStateClean();
			toast.showMessage({
				title: locale.baseText("mainSidebar.showMessage.handleArchive.title", { interpolate: { workflowName: props.name } }),
				type: "success"
			});
			const workflow = workflowsListStore.getWorkflowById(props.id);
			if (workflow?.homeProject?.type === ProjectTypes.Team) await router.push({
				name: VIEWS.PROJECTS_WORKFLOWS,
				params: { projectId: workflow.homeProject.id }
			});
			else await router.push({ name: VIEWS.WORKFLOWS });
		}
		async function handleUnarchiveWorkflow() {
			await workflowsStore.unarchiveWorkflow(props.id);
			toast.showMessage({
				title: locale.baseText("mainSidebar.showMessage.handleUnarchive.title", { interpolate: { workflowName: props.name } }),
				type: "success"
			});
		}
		async function handleDeleteWorkflow() {
			if (await message.confirm(locale.baseText("mainSidebar.confirmMessage.workflowDelete.message", { interpolate: { workflowName: props.name } }), locale.baseText("mainSidebar.confirmMessage.workflowDelete.headline"), {
				type: "warning",
				confirmButtonText: locale.baseText("mainSidebar.confirmMessage.workflowDelete.confirmButtonText"),
				cancelButtonText: locale.baseText("mainSidebar.confirmMessage.workflowDelete.cancelButtonText")
			}) !== "confirm") return;
			const workflow = workflowsListStore.getWorkflowById(props.id);
			const isTeamProject = workflow?.homeProject?.type === ProjectTypes.Team;
			try {
				await workflowsListStore.deleteWorkflow(props.id);
			} catch (error) {
				toast.showError(error, locale.baseText("generic.deleteWorkflowError"));
				return;
			}
			uiStore.markStateClean();
			documentTitle.reset();
			toast.showMessage({
				title: locale.baseText("mainSidebar.showMessage.handleSelect1.title", { interpolate: { workflowName: props.name } }),
				type: "success"
			});
			if (isTeamProject && workflow?.homeProject) await router.push({
				name: VIEWS.PROJECTS_WORKFLOWS,
				params: { projectId: workflow.homeProject.id }
			});
			else await router.push({ name: VIEWS.WORKFLOWS });
		}
		const onBreadcrumbsItemSelected = (item) => {
			if (item.href) router.push(item.href).catch((error) => {
				toast.showError(error, i18n.baseText("folders.open.error.title"));
			});
		};
		const handleImportWorkflowFromFile = () => {
			if (workflowHeaderActionsRef.value?.importFileRef) workflowHeaderActionsRef.value.importFileRef.click();
		};
		onMounted(() => {
			nodeViewEventBus.on("importWorkflowFromFile", handleImportWorkflowFromFile);
			nodeViewEventBus.on("archiveWorkflow", handleArchiveWorkflow);
			nodeViewEventBus.on("unarchiveWorkflow", handleUnarchiveWorkflow);
			nodeViewEventBus.on("deleteWorkflow", handleDeleteWorkflow);
			nodeViewEventBus.on("renameWorkflow", onNameToggle);
			nodeViewEventBus.on("addTag", onTagsEditEnable);
		});
		onBeforeUnmount(() => {
			nodeViewEventBus.off("importWorkflowFromFile", handleImportWorkflowFromFile);
			nodeViewEventBus.off("archiveWorkflow", handleArchiveWorkflow);
			nodeViewEventBus.off("unarchiveWorkflow", handleUnarchiveWorkflow);
			nodeViewEventBus.off("deleteWorkflow", handleDeleteWorkflow);
			nodeViewEventBus.off("renameWorkflow", onNameToggle);
			nodeViewEventBus.off("addTag", onTagsEditEnable);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(unref($style).container) }, [
				createVNode(BreakpointsObserver_default, {
					"value-x-s": 15,
					"value-s-m": 25,
					"value-m-d": 50,
					class: "name-container",
					"data-test-id": "canvas-breadcrumbs"
				}, {
					default: withCtx(({ bp }) => [createVNode(FolderBreadcrumbs_default, {
						"current-folder": currentFolderForBreadcrumbs.value,
						"current-folder-as-link": true,
						onItemSelected: onBreadcrumbsItemSelected
					}, {
						append: withCtx(() => [unref(projectsStore).currentProject ?? unref(projectsStore).personalProject ? (openBlock(), createElementBlock("span", {
							key: 0,
							class: normalizeClass(unref($style)["path-separator"])
						}, "/", 2)) : createCommentVNode("", true), (openBlock(), createBlock(unref(N8nInlineTextEdit_default), {
							ref_key: "renameInput",
							ref: renameInput,
							key: __props.id,
							placeholder: "Workflow name",
							"data-test-id": "workflow-name-input",
							class: "name",
							"model-value": __props.name,
							"max-length": unref(128),
							"max-width": WORKFLOW_NAME_BP_TO_WIDTH[bp],
							"read-only": readOnlyActions.value,
							disabled: readOnlyActions.value,
							"onUpdate:modelValue": onNameSubmit
						}, null, 8, [
							"model-value",
							"max-length",
							"max-width",
							"read-only",
							"disabled"
						]))]),
						_: 2
					}, 1032, ["current-folder"])]),
					_: 1
				}),
				createBaseVNode("span", _hoisted_1, [unref(settingsStore).areTagsEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [isTagsEditEnabled.value && !readOnlyActions.value ? (openBlock(), createBlock(WorkflowTagsDropdown_default, {
					key: 0,
					ref: "dropdown",
					modelValue: appliedTagIds.value,
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => appliedTagIds.value = $event),
					"event-bus": unref(tagsEventBus),
					placeholder: unref(i18n).baseText("workflowDetails.chooseOrCreateATag"),
					class: "tags-edit",
					"data-test-id": "workflow-tags-dropdown",
					onBlur: onTagsBlur,
					onEsc: onTagsEditEsc
				}, null, 8, [
					"modelValue",
					"event-bus",
					"placeholder"
				])) : __props.tags.length === 0 && !readOnlyActions.value ? (openBlock(), createElementBlock("div", _hoisted_2, [createBaseVNode("span", {
					class: "add-tag clickable",
					"data-test-id": "new-tag-link",
					onClick: onTagsEditEnable
				}, " + " + toDisplayString(unref(i18n).baseText("workflowDetails.addTag")), 1)])) : (openBlock(), createBlock(WorkflowTagsContainer_default, {
					key: __props.id,
					"tag-ids": workflowTagIds.value,
					clickable: true,
					responsive: true,
					"data-test-id": "workflow-tags",
					onClick: onTagsEditEnable
				}, null, 8, ["tag-ids"]))], 64)) : createCommentVNode("", true), createBaseVNode("span", { class: normalizeClass(unref($style)["header-controls"]) }, [__props.isArchived ? (openBlock(), createBlock(unref(N8nBadge_default), {
					key: 0,
					class: "ml-3xs",
					theme: "tertiary",
					bold: "",
					"data-test-id": "workflow-archived-tag"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(locale).baseText("workflows.item.archived")), 1)]),
					_: 1
				})) : createCommentVNode("", true)], 2)]),
				createVNode(ConnectionTracker_default, { class: "actions" }, {
					default: withCtx(() => [!isNewWorkflow.value ? (openBlock(), createBlock(WorkflowProductionChecklist_default, {
						key: 0,
						workflow: unref(workflowsStore).workflow
					}, null, 8, ["workflow"])) : createCommentVNode("", true), createVNode(WorkflowHeaderDraftPublishActions_default, {
						id: __props.id,
						ref: "workflowHeaderActions",
						tags: __props.tags,
						name: __props.name,
						meta: __props.meta,
						"is-archived": __props.isArchived,
						"is-new-workflow": isNewWorkflow.value,
						"workflow-permissions": workflowPermissions.value
					}, null, 8, [
						"id",
						"tags",
						"name",
						"meta",
						"is-archived",
						"is-new-workflow",
						"workflow-permissions"
					])]),
					_: 1
				})
			], 2);
		};
	}
});
const container$1 = "_container_h2714_125";
const closeNodeViewDiscovery = "_closeNodeViewDiscovery_h2714_140";
var WorkflowDetails_vue_vue_type_style_index_1_lang_module_default = {
	container: container$1,
	"path-separator": "_path-separator_h2714_134",
	closeNodeViewDiscovery,
	"header-controls": "_header-controls_h2714_147"
};
var WorkflowDetails_default = /* @__PURE__ */ __plugin_vue_export_helper_default(WorkflowDetails_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": WorkflowDetails_vue_vue_type_style_index_1_lang_module_default }], ["__scopeId", "data-v-25155f8e"]]);
init_shared_esm_bundler();
var vue_github_button_default = defineComponent({
	name: "github-button",
	props: {
		href: String,
		ariaLabel: String,
		title: String,
		dataIcon: String,
		dataColorScheme: String,
		dataSize: String,
		dataShowCount: String,
		dataText: String
	},
	render: function() {
		const props = { ref: "_" };
		for (const key in this.$props) props[hyphenate(key)] = this.$props[key];
		return h("span", [hasOwn(this.$slots, "default") ? h("a", props, this.$slots.default()) : h("a", props)]);
	},
	mounted: function() {
		this.paint();
	},
	beforeUpdate: function() {
		this.reset();
	},
	updated: function() {
		this.paint();
	},
	beforeUnmount: function() {
		this.reset();
	},
	methods: {
		paint: function() {
			if (this.$el.lastChild !== this.$refs._) return;
			const _ = this.$el.appendChild(document.createElement("span"));
			const _this = this;
			__vitePreload(() => import(
				/* webpackMode: "eager" */
				"./buttons.esm-UZiUMlWF.js"
), []).then(function(module) {
				if (_this.$el.lastChild !== _) return;
				module.render(_.appendChild(_this.$refs._), function(el) {
					if (_this.$el.lastChild !== _) return;
					_.parentNode.replaceChild(el, _);
				});
			});
		},
		reset: function() {
			if (this.$refs._ == null) return;
			this.$el.replaceChild(this.$refs._, this.$el.lastChild);
		}
	}
});
var MainHeader_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MainHeader",
	setup(__props) {
		const router = useRouter();
		const route = useRoute();
		const locale = useI18n();
		const pushConnection = usePushConnection({ router });
		const toast = useToast();
		const ndvStore = useNDVStore();
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const workflowsListStore = useWorkflowsListStore();
		const executionsStore = useExecutionsStore();
		const settingsStore = useSettingsStore();
		const activeHeaderTab = ref(MAIN_HEADER_TABS.WORKFLOW);
		const workflowToReturnTo = ref("");
		const executionToReturnTo = ref("");
		const dirtyState = ref(false);
		const githubButtonHidden = useLocalStorage(LOCAL_STORAGE_HIDE_GITHUB_STAR_BUTTON, false);
		const evaluationRoutes = [VIEWS.EVALUATION_EDIT, VIEWS.EVALUATION_RUNS_DETAIL];
		const workflowRoutes = [
			VIEWS.WORKFLOW,
			VIEWS.NEW_WORKFLOW,
			VIEWS.EXECUTION_DEBUG
		];
		const executionRoutes = [
			VIEWS.EXECUTION_HOME,
			VIEWS.WORKFLOW_EXECUTIONS,
			VIEWS.EXECUTION_PREVIEW
		];
		const tabBarItems = computed(() => {
			return [
				{
					value: MAIN_HEADER_TABS.WORKFLOW,
					label: locale.baseText("generic.editor")
				},
				{
					value: MAIN_HEADER_TABS.EXECUTIONS,
					label: locale.baseText("generic.executions")
				},
				{
					value: MAIN_HEADER_TABS.EVALUATION,
					label: locale.baseText("generic.tests")
				}
			];
		});
		const activeNode = computed(() => ndvStore.activeNode);
		const hideMenuBar = computed(() => Boolean(activeNode.value && activeNode.value.type !== "n8n-nodes-base.stickyNote"));
		const workflow = computed(() => workflowsStore.workflow);
		const workflowId = injectStrict(WorkflowIdKey);
		const workflowDocumentStore = inject(WorkflowDocumentStoreKey, null);
		const workflowTags = computed(() => workflowDocumentStore?.value?.tags ?? []);
		const onWorkflowPage = computed(() => !!(route.meta.nodeView || route.meta.keepWorkflowAlive));
		const isEnterprise = computed(() => settingsStore.isQueueModeEnabled && settingsStore.isWorkerViewAvailable);
		const isTelemetryEnabled = computed(() => {
			return settingsStore.isTelemetryEnabled;
		});
		const showGitHubButton = computed(() => !isEnterprise.value && !settingsStore.settings.inE2ETests && !githubButtonHidden.value && isTelemetryEnabled.value);
		const parentFolderForBreadcrumbs = computed(() => {
			if (!workflow.value.parentFolder) return;
			return {
				id: workflow.value.parentFolder.id,
				name: workflow.value.parentFolder.name,
				parentFolder: workflow.value.parentFolder.parentFolderId ?? void 0
			};
		});
		watch(route, (to, from) => {
			syncTabsWithRoute(to, from);
		});
		onBeforeMount(() => {
			pushConnection.initialize();
		});
		onBeforeUnmount(() => {
			pushConnection.terminate();
		});
		onMounted(async () => {
			dirtyState.value = uiStore.stateIsDirty;
			syncTabsWithRoute(route);
		});
		function isViewRoute(name) {
			return typeof name === "string" && [
				evaluationRoutes,
				workflowRoutes,
				executionRoutes
			].flat().includes(name);
		}
		function syncTabsWithRoute(to, from) {
			const routeTabMapping = [
				{
					routes: evaluationRoutes,
					tab: MAIN_HEADER_TABS.EVALUATION
				},
				{
					routes: executionRoutes,
					tab: MAIN_HEADER_TABS.EXECUTIONS
				},
				{
					routes: workflowRoutes,
					tab: MAIN_HEADER_TABS.WORKFLOW
				}
			];
			if (to.name && isViewRoute(to.name)) {
				const matchingTab = routeTabMapping.find(({ routes }) => routes.includes(to.name));
				if (matchingTab) activeHeaderTab.value = matchingTab.tab;
			}
			if (typeof to.params.name === "string") workflowToReturnTo.value = to.params.name;
			if (from?.name === VIEWS.EXECUTION_PREVIEW && to.params.name === from.params.name && typeof from.params.executionId === "string") executionToReturnTo.value = from.params.executionId;
		}
		function onTabSelected(tab, event) {
			const openInNewTab = event.ctrlKey || event.metaKey;
			switch (tab) {
				case MAIN_HEADER_TABS.WORKFLOW:
					navigateToWorkflowView(openInNewTab);
					break;
				case MAIN_HEADER_TABS.EXECUTIONS:
					navigateToExecutionsView(openInNewTab);
					break;
				case MAIN_HEADER_TABS.EVALUATION:
					navigateToEvaluationsView(openInNewTab);
					break;
				default: break;
			}
		}
		async function navigateToWorkflowView(openInNewTab) {
			let routeToNavigateTo;
			if (workflowToReturnTo.value && workflowToReturnTo.value !== "") routeToNavigateTo = {
				name: VIEWS.WORKFLOW,
				params: { name: workflowToReturnTo.value },
				query: route.query
			};
			else routeToNavigateTo = {
				name: VIEWS.NEW_WORKFLOW,
				query: route.query
			};
			if (openInNewTab) {
				const { href } = router.resolve(routeToNavigateTo);
				window.open(href, "_blank");
			} else if (route.name !== routeToNavigateTo.name) {
				if (route.name === VIEWS.NEW_WORKFLOW) if (dirtyState.value) uiStore.markStateDirty();
				else uiStore.markStateClean();
				activeHeaderTab.value = MAIN_HEADER_TABS.WORKFLOW;
				await router.push(routeToNavigateTo);
			}
		}
		async function navigateToExecutionsView(openInNewTab) {
			const executionToReturnToValue = executionsStore.activeExecution?.id || executionToReturnTo.value;
			const routeToNavigateTo = executionToReturnToValue ? {
				name: VIEWS.EXECUTION_PREVIEW,
				params: {
					name: workflowId.value,
					executionId: executionToReturnToValue
				},
				query: route.query
			} : {
				name: VIEWS.EXECUTION_HOME,
				params: { name: workflowId.value },
				query: route.query
			};
			if (openInNewTab) {
				const { href } = router.resolve(routeToNavigateTo);
				window.open(href, "_blank");
			} else if (route.name !== routeToNavigateTo.name) {
				dirtyState.value = uiStore.stateIsDirty;
				workflowToReturnTo.value = workflowId.value;
				activeHeaderTab.value = MAIN_HEADER_TABS.EXECUTIONS;
				await router.push(routeToNavigateTo);
			}
		}
		async function navigateToEvaluationsView(openInNewTab) {
			const routeToNavigateTo = {
				name: VIEWS.EVALUATION_EDIT,
				params: { name: workflowId.value },
				query: route.query
			};
			if (openInNewTab) {
				const { href } = router.resolve(routeToNavigateTo);
				window.open(href, "_blank");
			} else if (route.name !== routeToNavigateTo.name) {
				dirtyState.value = uiStore.stateIsDirty;
				workflowToReturnTo.value = workflowId.value;
				activeHeaderTab.value = MAIN_HEADER_TABS.EXECUTIONS;
				await router.push(routeToNavigateTo);
			}
		}
		function hideGithubButton() {
			githubButtonHidden.value = true;
		}
		async function onWorkflowDeactivated() {
			if (settingsStore.isModuleActive("mcp") && workflow.value.settings?.availableInMCP) try {
				const updatedWorkflow = await workflowsListStore.fetchWorkflow(workflow.value.id);
				workflowsStore.setWorkflow(updatedWorkflow);
				toast.showToast({
					title: locale.baseText("mcp.workflowDeactivated.title"),
					message: locale.baseText("mcp.workflowDeactivated.message"),
					type: "info"
				});
			} catch (error) {
				toast.showError(error, locale.baseText("workflowSettings.showError.fetchSettings.title"));
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.container) }, [createBaseVNode("div", { class: normalizeClass({
				[_ctx.$style["main-header"]]: true,
				[_ctx.$style.expanded]: !unref(uiStore).sidebarMenuCollapsed
			}) }, [withDirectives(createBaseVNode("div", { class: normalizeClass(_ctx.$style["top-menu"]) }, [workflow.value?.name ? (openBlock(), createBlock(WorkflowDetails_default, {
				key: 0,
				id: workflow.value.id,
				tags: workflowTags.value,
				name: workflow.value.name,
				meta: workflow.value.meta,
				scopes: workflow.value.scopes,
				active: workflow.value.active,
				"current-folder": parentFolderForBreadcrumbs.value,
				"is-archived": workflow.value.isArchived,
				description: workflow.value.description,
				"onWorkflow:deactivated": onWorkflowDeactivated
			}, null, 8, [
				"id",
				"tags",
				"name",
				"meta",
				"scopes",
				"active",
				"current-folder",
				"is-archived",
				"description"
			])) : createCommentVNode("", true), showGitHubButton.value ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass([_ctx.$style["github-button"], "hidden-sm-and-down"])
			}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style["github-button-container"]) }, [createVNode(unref(vue_github_button_default), {
				href: unref(N8N_MAIN_GITHUB_REPO_URL),
				"data-color-scheme": unref(uiStore).appliedTheme,
				"data-size": "large",
				"data-show-count": "true",
				"aria-label": unref(locale).baseText("editor.mainHeader.githubButton.label")
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(locale).baseText("generic.star")), 1)]),
				_: 1
			}, 8, [
				"href",
				"data-color-scheme",
				"aria-label"
			]), createVNode(unref(N8nIcon_default), {
				class: normalizeClass(_ctx.$style["close-github-button"]),
				icon: "circle-x",
				size: "medium",
				onClick: hideGithubButton
			}, null, 8, ["class"])], 2)], 2)) : createCommentVNode("", true)], 2), [[vShow, !hideMenuBar.value]]), onWorkflowPage.value ? (openBlock(), createBlock(TabBar_default, {
				key: 0,
				items: tabBarItems.value,
				"model-value": activeHeaderTab.value,
				"onUpdate:modelValue": onTabSelected
			}, null, 8, ["items", "model-value"])) : createCommentVNode("", true)], 2)], 2);
		};
	}
});
var MainHeader_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_19rmf_125",
	"main-header": "_main-header_19rmf_132",
	"top-menu": "_top-menu_19rmf_140",
	"github-button": "_github-button_19rmf_151",
	"close-github-button": "_close-github-button_19rmf_160",
	"github-button-container": "_github-button-container_19rmf_175"
};
var MainHeader_default = /* @__PURE__ */ __plugin_vue_export_helper_default(MainHeader_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": MainHeader_vue_vue_type_style_index_0_lang_module_default }]]);
var AppHeader_default = /* @__PURE__ */ defineComponent({
	__name: "AppHeader",
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(MainHeader_default);
		};
	}
});
var WorkflowLayout_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowLayout",
	setup(__props) {
		const { layoutProps } = useLayoutProps();
		const assistantStore = useAssistantStore();
		const workflowState = useWorkflowState();
		provide(WorkflowStateKey, workflowState);
		const { isLoading, workflowId, currentWorkflowDocumentStore, isDebugRoute, initializeData, initializeWorkflow, handleDebugModeRoute, cleanup } = useWorkflowInitialization(workflowState);
		provide(WorkflowIdKey, workflowId);
		provide(WorkflowDocumentStoreKey, currentWorkflowDocumentStore);
		onMounted(async () => {
			await initializeData();
			await initializeWorkflow();
		});
		watch(workflowId, async (newId, oldId) => {
			if (newId !== oldId && newId) await initializeWorkflow(true);
		}, { flush: "post" });
		watch(isDebugRoute, async (isDebug, wasDebug) => {
			if (isDebug && !wasDebug && !isLoading.value) await handleDebugModeRoute();
		}, { flush: "post" });
		onBeforeUnmount(() => cleanup());
		return (_ctx, _cache) => {
			const _component_RouterView = resolveComponent("RouterView");
			return openBlock(), createBlock(BaseLayout_default, null, createSlots({
				header: withCtx(() => [createVNode(AppHeader_default)]),
				sidebar: withCtx(() => [createVNode(AppSidebar_default)]),
				overlays: withCtx(() => [unref(assistantStore).isFloatingButtonShown ? (openBlock(), createBlock(AskAssistantFloatingButton_default, { key: 0 })) : createCommentVNode("", true)]),
				default: withCtx(() => [unref(isLoading) ? (openBlock(), createBlock(LoadingView_default, { key: 0 })) : (openBlock(), createBlock(_component_RouterView, { key: 1 }, {
					default: withCtx(({ Component }) => [(openBlock(), createBlock(KeepAlive, {
						include: "NodeView",
						max: 1
					}, [(openBlock(), createBlock(resolveDynamicComponent(Component)))], 1024))]),
					_: 1
				}))]),
				_: 2
			}, [unref(layoutProps).logs ? {
				name: "footer",
				fn: withCtx(() => [createVNode(LogsPanel_default)]),
				key: "0"
			} : void 0]), 1024);
		};
	}
});
export { WorkflowLayout_default as default };
