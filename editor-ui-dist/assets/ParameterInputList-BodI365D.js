const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/FixedCollectionParameter-C1-2JFIV.js","assets/_plugin-vue_export-helper-BwBpWJRZ.js","assets/src-B9lyFNPE.js","assets/preload-helper-CR0ecmWK.js","assets/icon-B8U-CfQv.js","assets/vue.runtime.esm-bundler-DDuXT-9r.js","assets/chunk-6z4oVpB-.js","assets/truncate-D09te2fm.js","assets/_MapCache-CMopfp37.js","assets/sanitize-html-BuXr7o4T.js","assets/empty-BuGRxzl4.js","assets/path-browserify-DsmB_HMK.js","assets/en-BYTsM8fR.js","assets/src-B3UiHJ-Q.css","assets/nodeCreator.store-DkZQyY8W.js","assets/constants-7lEZpYki.js","assets/merge-9-BpYlRV.js","assets/useTelemetry-BnWkdL5v.js","assets/dateformat-D7TIhVd4.js","assets/useDebounce-BSVJx8HC.js","assets/useExternalHooks-BhwArgDu.js","assets/templates.store-B66LeSvw.js","assets/cloudPlan.store-6mcCsbPK.js","assets/nodeIcon-DDhmw_5Z.js","assets/isEmpty-DxMcMfyi.js","assets/useToast-CYEyObML.js","assets/FileSaver.min-D8bnhVIu.js","assets/uniqBy-CMy6VD1M.js","assets/NDVEmptyState-DXP-2qHk.js","assets/NDVEmptyState-Hm1vFJ4i.css","assets/vue-json-pretty-BlSK1oxV.js","assets/vue-GniKVX87.js","assets/schemaPreview.store-CLfCgUB5.js","assets/assistant.store-BVON_WC2.js","assets/RunDataHtml-BJNWCJaI.js","assets/RunDataHtml-Bu3RZcuV.css","assets/useClipboard-DM6_szGh.js","assets/usePinnedData-en44HETZ.js","assets/chatPanel.store-C-k9-deH.js","assets/useExecutionHelpers-C_T89TtO.js","assets/dateFormatter-BcAWObOP.js","assets/externalSecrets.ee.store-BA9u6Jjb.js","assets/isEmpty-Bi_tkWnE.css","assets/exports-9spWG404.js","assets/useRunWorkflow-Bd2-68As.js","assets/useCanvasOperations-txv-wr0L.js","assets/folders.store-CrkPMTTZ.js","assets/executions.store-D5Bo0447.js","assets/focusPanel.store-CBZJy8Ca.js","assets/useWorkflowSaving-ClsTd_Kb.js","assets/useMessage-CzSaXdHQ.js","assets/overlay-CPmcXGrH.js","assets/npsSurvey.store-Bu7abrXf.js","assets/date-picker-CuI_Lwu8.js","assets/dialog-C7-JMpyx.js","assets/VirtualSchema-xT96MPFz.js","assets/Draggable-Dx1WUTsP.js","assets/Draggable-DfBtatxg.css","assets/useTelemetryContext-UPqMtM_b.js","assets/useTelemetryContext-BpnKRIT7.css","assets/NodeIcon-CDBCK2ja.js","assets/NodeIcon-C-Ise6x6.css","assets/TextWithHighlights-4Fm26J2a.js","assets/TextWithHighlights-BgbTzzK2.css","assets/nodeTransforms-idgabZjR.js","assets/VirtualSchema-DSZB6gKx.css","assets/FixedCollectionParameter-DhxxT9l5.css","assets/CollectionParameter-Bb4k4hYX.js"])))=>i.map(i=>d[i]);
import { a as __toCommonJS, n as __esmMin, o as __toESM, r as __export, t as __commonJSMin } from "./chunk-6z4oVpB-.js";
import { $ as onUpdated, A as createStaticVNode, Bt as toRaw, C as computed, D as createElementBlock, E as createCommentVNode, F as getCurrentInstance, G as nextTick, Gt as unref, It as ref, J as onBeforeUnmount, M as createVNode, N as defineAsyncComponent, P as defineComponent, Pt as reactive, Q as onUnmounted, Sn as toDisplayString, T as createBlock, U as mergeModels, Ut as toValue, V as isVNode, Vt as toRef, X as onErrorCaptured, Z as onMounted, _ as Fragment, _n as normalizeClass, _t as watch, at as renderSlot, bt as withCtx, c as useCssModule, ct as resolveDynamicComponent, et as openBlock, ft as useModel, h as withModifiers, it as renderList, j as createTextVNode, k as createSlots, m as withKeys, mt as useTemplateRef, n as Transition, nt as provide, p as vShow, pn as isString, pt as useSlots, st as resolveDirective, tn as init_shared_esm_bundler, vt as watchEffect, w as createBaseVNode, xt as withDirectives, y as Suspense, yn as normalizeStyle, z as inject, zt as shallowRef } from "./vue.runtime.esm-bundler-DDuXT-9r.js";
import { D as useEventListener, E as useElementSize, F as useSessionStorage, T as useElementHover, V as computedWithControl, _t as I18nT, at as watchDebounced, c as require_isObject, g as onClickOutside, gt as useI18n, it as useThrottleFn, pt as i18n, v as onKeyStroke } from "./_MapCache-CMopfp37.js";
import { $ as N8nActionToggle_default, $t as useDeprecated, C as N8nPopover_default, Fn as N8nIcon_default, G as N8nOption_default, Mn as N8nText_default, N as N8nInputNumber_default, Nn as N8nButton_default, Nt as ElColorPicker, S as N8nPopoverReka_default, T as N8nNotice_default, W as N8nSelect_default, Y as N8nInputLabel_default, _t as N8nInput_default, an as UPDATE_MODEL_EVENT, b as N8nRadioButtons_default, bt as N8nIconButton_default, en as mutable, et as N8nLoading_default, ft as N8nTooltip_default, it as N8nBadge_default, jn as N8nCallout_default, lt as N8nLink_default, nn as flattedChildren, q as N8nCircleLoader_default, rt as useDeviceSupport, v as N8nResizeWrapper_default, w as N8nSelectableList_default, wt as ElSwitch, z as ResizeObserver_default } from "./src-B9lyFNPE.js";
import { t as __vitePreload } from "./preload-helper-CR0ecmWK.js";
import { t as __plugin_vue_export_helper_default } from "./_plugin-vue_export-helper-BwBpWJRZ.js";
import { At as useWindowFocus, Dt as useDocumentVisibility$1, F as definePropType, H as throwError, P as buildProps, W as capitalize, X as isUndefined, Y as isNumber, a as require__toKey, b as useRouter, i as require__baseGet, jt as computedEager, k as useNamespace, kt as useResizeObserver, o as require__castPath, r as require_get, t as truncate, x as createEventBus } from "./truncate-D09te2fm.js";
import { b as close_default$1, h as arrow_right_default, i as withInstall, k as plus_default, m as arrow_left_default, n as _export_sfc, r as EVENT_CODE, s as withNoopInstall, t as ElIcon } from "./icon-B8U-CfQv.js";
import { t as ElDatePicker } from "./date-picker-CuI_Lwu8.js";
import { t as useMessage } from "./useMessage-CzSaXdHQ.js";
import { t as ElDialog } from "./dialog-C7-JMpyx.js";
import { $t as escapeMappingString, An as useProjectsStore, Bt as require__createCompounder, Ci as isSelectableEl, Fi as codeNodeEditorEventBus, Gt as generateCodeForPrompt, Ht as useCredentialsStore, Js as useRootStore, Li as useUIStore, Mi as htmlEditorEventBus, Oi as omitKey, On as require__baseSet, Qr as getNodeAuthFields, Si as isPresent, Sn as injectWorkflowState, Ur as executionDataToJson, Wr as fieldCannotBeDeleted, Xr as getAuthTypeForNodeCredential, Yr as getAppNameFromNodeName, Zr as getMainAuthField, Zt as useDataSchema, _c as storeToRefs, a as useNDVStore, ai as isAuthRelatedParameter, an as getResolvableState, bi as isEmpty$1, bn as useEnvironmentsStore, ci as isResourceMapperFieldListStale, cn as removeExpressionPrefix, di as updateNodeAuthType, ei as getNodeCredentialForSelectedAuthType, fc as assert, fn as resolveParameter, fr as isResourceMapperValue, i as usePostHog, ii as hasOnlyListMode, in as getExpressionErrorMessage, li as isValueExpression, ln as shouldConvertToExpression, mn as useWorkflowHelpers, nn as propertyNameFromExpression, nt as waitingNodeTooltip, o as useWorkflowsStore, oi as isMatchingField, pn as resolveRequiredParameters, qr as getAllNodeCredentialForAuthType, ri as hasExpressionMapping, rn as completeExpressionSyntax, rt as useNodeTypesStore, si as isRequiredCredential, t as useTelemetry, tn as getMappedResult, ui as parseResourceMapperFieldName, un as stringifyExpressionResult, ur as isFullExecutionResponse, vi as hasFocusOnInput, vn as isCredentialOnlyNodeType, xi as isFocusableEl, xn as useNodeHelpers, yc as v4_default, yi as isBlurrableEl, yn as environments_store_default, zo as useSettingsStore, zt as require__baseSlice } from "./useTelemetry-BnWkdL5v.js";
import { c as sanitizeHtml, n as useStyles, o as isEventTargetContainedBy, t as useToast } from "./useToast-CYEyObML.js";
import { $o as getNodeParametersIssues, As as parseScript, Bi as SWITCH_NODE_TYPE, Cn as IMPORT_CURL_MODAL_KEY, D as AI_TRANSFORM_NODE_TYPE, Do as createResultError, En as INTERVAL_NODE_TYPE, Eo as Expression, Es as randomInt, F as ASK_AI_LOADING_DURATION_MS, Fo as isExpression, I as ASK_AI_MAX_PROMPT_LENGTH, Is as ADD_FORM_NOTICE, L as ASK_AI_MIN_PROMPT_LENGTH, Li as START_NODE_TYPE, Lr as NODES_USING_CODE_NODE_EDITOR, Ms as DateTime, Ns as NodeConnectionTypes, Oo as createResultOk, Ot as DATA_TYPE_ICON_MAP, P as APP_MODALS_ELEMENT_ID, Pr as NDV_UI_OVERHAUL_EXPERIMENT, Qo as getNodeParameters, Ri as STICKY_NODE_TYPE, St as CanvasKey, U as BINARY_DATA_ACCESS_TOOLTIP, Us as CREDENTIAL_EMPTY_VALUE, Xo as getNodeInputs, Xs as HTTP_REQUEST_NODE_TYPE, Zo as getNodeOutputs, _s as FilterError, as as isDefaultNodeName, at as CODEMIRROR_TOOLTIP_CONTAINER_ELEMENT_ID, bt as CUSTOM_API_CALL_KEY, dn as FORM_TRIGGER_NODE_TYPE, ft as CORE_NODES_CATEGORY, gs as isResourceLocatorValue, gt as CRON_NODE_TYPE, hs as isINodePropertyOptionsList, ht as CREDENTIAL_ONLY_NODE_PREFIX, ic as require_isEqual, is as getUpdatedToolDescription, jn as KEEP_AUTH_IN_NDV_FOR_NODES, ko as EXTENSION_OBJECTS, kr as MODAL_CONFIRM, ks as Syntax, lo as resolveRelativePath, ms as isINodePropertyCollectionList, nn as EXPRESSION_EDITOR_PARSER_TIMEOUT, ns as getParameterValueByPath, oa as VIEWS, oo as getResourcePermissions, or as MANUAL_TRIGGER_NODE_TYPE, ot as CODE_NODE_TYPE, ps as isINodePropertiesList, qo as displayParameter, sa as WAIT_NODE_TYPE, sn as ExpressionLocalResolveContextSymbol, ts as getParameterIssues, un as FORM_NODE_TYPE, us as makeNodeName, vn as HTML_NODE_TYPE, vs as executeFilterCondition, ws as jsonParse, xs as deepCopy, ys as validateFieldType } from "./constants-7lEZpYki.js";
import { n as ndvEventBus } from "./assistant.store-BVON_WC2.js";
import { n as require_debounce, t as useDebounce } from "./useDebounce-BSVJx8HC.js";
import { t as useExternalHooks } from "./useExternalHooks-BhwArgDu.js";
import { a as updateFromAIOverrideValues, i as makeOverrideValue, n as buildValueFromOverride, r as isFromAIOverrideValue, t as useFocusPanelStore } from "./focusPanel.store-CBZJy8Ca.js";
import { a as proxy, o as wrap, t as useRunWorkflow } from "./useRunWorkflow-Bd2-68As.js";
import { _ as useCalloutHelpers } from "./nodeCreator.store-DkZQyY8W.js";
import { i as useExperimentalNdvStore, t as useCanvasOperations } from "./useCanvasOperations-txv-wr0L.js";
import { t as NodeIcon_default } from "./NodeIcon-CDBCK2ja.js";
import { $ as pickedCompletion$1, A as autocompletableNodeNames, At as highlightActiveLine, B as tsxLanguage, Bt as EditorSelection, C as n8nCompletionSources, Ct as parseMixed, D as FIELDS_SECTION, Dt as WidgetType, E as luxonInstanceDocs, Et as ViewPlugin, F as javascript, Ft as lineNumbers, G as CompletionContext, Gt as RangeSetBuilder, H as ContextTracker, Ht as Facet, I as javascriptLanguage, It as showTooltip, J as closeBracketsKeymap, Jt as StateField, K as autocompletion, Kt as RangeValue, L as jsxLanguage, Lt as tooltips, M as isCompletionSection, Mt as highlightSpecialChars, N as longestCommonPrefix, Nt as hoverTooltip, O as TARGET_NODE_PARAMETER_FACET, Ot as drawSelection, P as prefixMatch$1, Pt as keymap, Q as insertCompletionText, R as localCompletionSource, Rt as Annotation, S as mappingDropCursor, St as tags, T as luxonStaticDocs, Tt as EditorView, U as ExternalTokenizer, Ut as MapMode, V as typescriptLanguage, Vt as EditorState, W as LRParser, Wt as Prec, X as completeFromList$1, Xt as Transaction, Y as closeCompletion, Yt as Text, Z as completionStatus, Zt as combineConfig, _ as highlightSelectionMatches, _t as indentOnInput, at as LRLanguage, b as dropInCodeEditor, bt as syntaxTree, c as json, ct as continuedIndent, d as n8nLang, dt as foldGutter, et as snippetCompletion, f as expressionParser, ft as foldInside, g as linter, gt as indentNodeProp, h as lintGutter, ht as getIndentUnit, it as HighlightStyle, j as isAllowedInDotNotation, jt as highlightActiveLineGutter, k as createInfoBoxRenderer, kt as dropCursor, l as codeEditorTheme, lt as delimitedIndent, m as languageFacet, mt as foldState, n as RunData_default, nt as history, o as JsonEditor_default, ot as LanguageSupport, p as editorKeymap, pt as foldNodeProp, q as closeBrackets, qt as StateEffect, rt as historyField, s as close_default, st as bracketMatching, t as require_isEmpty, tt as startCompletion, u as n8nAutocompletion, ut as ensureSyntaxTree, v as expressionCloseBrackets, vt as indentUnit, w as datatypeCompletions, wt as Decoration, x as dropInExpressionEditor, xt as styleTags, y as expressionCloseBracketsConfig, yt as syntaxHighlighting, z as snippets, zt as Compartment } from "./isEmpty-DxMcMfyi.js";
import { i as Ln, o as gu, r as estree_exports, t as NDVEmptyState_default } from "./NDVEmptyState-DXP-2qHk.js";
import { n as captureException, r as captureMessage } from "./exports-9spWG404.js";
import { t as useExternalSecretsStore } from "./externalSecrets.ee.store-BA9u6Jjb.js";
import { t as require_uniqBy } from "./uniqBy-CMy6VD1M.js";
import { a as getTextareaCursorPosition, i as getParentNodes, n as NodeExecuteButton_default, o as getUpdatedTextareaValue, r as generateCodeForAiTransform, t as VirtualSchema_default } from "./VirtualSchema-xT96MPFz.js";
import { i as getParameterDisplayableOptions } from "./nodeTransforms-idgabZjR.js";
import { t as require_vue } from "./vue-GniKVX87.js";
var getOrderedChildren = (vm, childComponentName, children) => {
	return flattedChildren(vm.subTree).filter((n) => {
		var _a$1;
		return isVNode(n) && ((_a$1 = n.type) == null ? void 0 : _a$1.name) === childComponentName && !!n.component;
	}).map((n) => n.component.uid).map((uid) => children[uid]).filter((p) => !!p);
};
var useOrderedChildren = (vm, childComponentName) => {
	const children = {};
	const orderedChildren = shallowRef([]);
	const addChild = (child) => {
		children[child.uid] = child;
		orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
	};
	const removeChild = (uid) => {
		delete children[uid];
		orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid);
	};
	return {
		children: orderedChildren,
		addChild,
		removeChild
	};
};
var tabsRootContextKey = Symbol("tabsRootContextKey");
var tabBarProps = buildProps({ tabs: {
	type: definePropType(Array),
	default: () => mutable([])
} });
var COMPONENT_NAME$2 = "ElTabBar";
var TabBar = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: COMPONENT_NAME$2 }),
	props: tabBarProps,
	setup(__props, { expose }) {
		const props = __props;
		const instance = getCurrentInstance();
		const rootTabs = inject(tabsRootContextKey);
		if (!rootTabs) throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
		const ns$1 = useNamespace("tabs");
		const barRef = ref();
		const barStyle = ref();
		const getBarStyle = () => {
			let offset = 0;
			let tabSize = 0;
			const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
			const sizeDir = sizeName === "width" ? "x" : "y";
			const position = sizeDir === "x" ? "left" : "top";
			props.tabs.every((tab$1) => {
				var _a$1, _b;
				const $el = (_b = (_a$1 = instance.parent) == null ? void 0 : _a$1.refs) == null ? void 0 : _b[`tab-${tab$1.uid}`];
				if (!$el) return false;
				if (!tab$1.active) return true;
				offset = $el[`offset${capitalize(position)}`];
				tabSize = $el[`client${capitalize(sizeName)}`];
				const tabStyles = window.getComputedStyle($el);
				if (sizeName === "width") {
					if (props.tabs.length > 1) tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
					offset += Number.parseFloat(tabStyles.paddingLeft);
				}
				return false;
			});
			return {
				[sizeName]: `${tabSize}px`,
				transform: `translate${capitalize(sizeDir)}(${offset}px)`
			};
		};
		const update = () => barStyle.value = getBarStyle();
		watch(() => props.tabs, async () => {
			await nextTick();
			update();
		}, { immediate: true });
		useResizeObserver(barRef, () => update());
		expose({
			ref: barRef,
			update
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "barRef",
				ref: barRef,
				class: normalizeClass([unref(ns$1).e("active-bar"), unref(ns$1).is(unref(rootTabs).props.tabPosition)]),
				style: normalizeStyle(barStyle.value)
			}, null, 6);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
var tabNavProps = buildProps({
	panes: {
		type: definePropType(Array),
		default: () => mutable([])
	},
	currentName: {
		type: [String, Number],
		default: ""
	},
	editable: Boolean,
	type: {
		type: String,
		values: [
			"card",
			"border-card",
			""
		],
		default: ""
	},
	stretch: Boolean
});
var tabNavEmits = {
	tabClick: (tab$1, tabName, ev) => ev instanceof Event,
	tabRemove: (tab$1, ev) => ev instanceof Event
};
var COMPONENT_NAME$1 = "ElTabNav";
var TabNav = defineComponent({
	name: COMPONENT_NAME$1,
	props: tabNavProps,
	emits: tabNavEmits,
	setup(props, { expose, emit }) {
		const vm = getCurrentInstance();
		const rootTabs = inject(tabsRootContextKey);
		if (!rootTabs) throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
		const ns$1 = useNamespace("tabs");
		const visibility = useDocumentVisibility$1();
		const focused$1 = useWindowFocus();
		const navScroll$ = ref();
		const nav$ = ref();
		const el$ = ref();
		const tabBarRef = ref();
		const scrollable = ref(false);
		const navOffset = ref(0);
		const isFocus = ref(false);
		const focusable = ref(true);
		const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
		const navStyle = computed(() => {
			return { transform: `translate${sizeName.value === "width" ? "X" : "Y"}(-${navOffset.value}px)` };
		});
		const scrollPrev = () => {
			if (!navScroll$.value) return;
			const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
			const currentOffset = navOffset.value;
			if (!currentOffset) return;
			navOffset.value = currentOffset > containerSize ? currentOffset - containerSize : 0;
		};
		const scrollNext = () => {
			if (!navScroll$.value || !nav$.value) return;
			const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
			const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
			const currentOffset = navOffset.value;
			if (navSize - currentOffset <= containerSize) return;
			navOffset.value = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
		};
		const scrollToActiveTab = async () => {
			const nav = nav$.value;
			if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;
			await nextTick();
			const activeTab = el$.value.querySelector(".is-active");
			if (!activeTab) return;
			const navScroll = navScroll$.value;
			const isHorizontal = ["top", "bottom"].includes(rootTabs.props.tabPosition);
			const activeTabBounding = activeTab.getBoundingClientRect();
			const navScrollBounding = navScroll.getBoundingClientRect();
			const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
			const currentOffset = navOffset.value;
			let newOffset = currentOffset;
			if (isHorizontal) {
				if (activeTabBounding.left < navScrollBounding.left) newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
				if (activeTabBounding.right > navScrollBounding.right) newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
			} else {
				if (activeTabBounding.top < navScrollBounding.top) newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
				if (activeTabBounding.bottom > navScrollBounding.bottom) newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
			}
			newOffset = Math.max(newOffset, 0);
			navOffset.value = Math.min(newOffset, maxOffset);
		};
		const update = () => {
			var _a$1;
			if (!nav$.value || !navScroll$.value) return;
			props.stretch && ((_a$1 = tabBarRef.value) == null || _a$1.update());
			const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
			const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
			const currentOffset = navOffset.value;
			if (containerSize < navSize) {
				scrollable.value = scrollable.value || {};
				scrollable.value.prev = currentOffset;
				scrollable.value.next = currentOffset + containerSize < navSize;
				if (navSize - currentOffset < containerSize) navOffset.value = navSize - containerSize;
			} else {
				scrollable.value = false;
				if (currentOffset > 0) navOffset.value = 0;
			}
		};
		const changeTab = (e) => {
			const code = e.code;
			const { up, down, left, right } = EVENT_CODE;
			if (![
				up,
				down,
				left,
				right
			].includes(code)) return;
			const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
			const currentIndex = tabList.indexOf(e.target);
			let nextIndex;
			if (code === left || code === up) if (currentIndex === 0) nextIndex = tabList.length - 1;
			else nextIndex = currentIndex - 1;
			else if (currentIndex < tabList.length - 1) nextIndex = currentIndex + 1;
			else nextIndex = 0;
			tabList[nextIndex].focus({ preventScroll: true });
			tabList[nextIndex].click();
			setFocus();
		};
		const setFocus = () => {
			if (focusable.value) isFocus.value = true;
		};
		const removeFocus = () => isFocus.value = false;
		watch(visibility, (visibility2) => {
			if (visibility2 === "hidden") focusable.value = false;
			else if (visibility2 === "visible") setTimeout(() => focusable.value = true, 50);
		});
		watch(focused$1, (focused2) => {
			if (focused2) setTimeout(() => focusable.value = true, 50);
			else focusable.value = false;
		});
		useResizeObserver(el$, update);
		onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
		onUpdated(() => update());
		expose({
			scrollToActiveTab,
			removeFocus
		});
		watch(() => props.panes, () => vm.update(), {
			flush: "post",
			deep: true
		});
		return () => {
			const scrollBtn = scrollable.value ? [createVNode("span", {
				"class": [ns$1.e("nav-prev"), ns$1.is("disabled", !scrollable.value.prev)],
				"onClick": scrollPrev
			}, [createVNode(ElIcon, null, { default: () => [createVNode(arrow_left_default, null, null)] })]), createVNode("span", {
				"class": [ns$1.e("nav-next"), ns$1.is("disabled", !scrollable.value.next)],
				"onClick": scrollNext
			}, [createVNode(ElIcon, null, { default: () => [createVNode(arrow_right_default, null, null)] })])] : null;
			const tabs$1 = props.panes.map((pane, index$1) => {
				var _a$1, _b, _c, _d;
				const uid = pane.uid;
				const disabled$2 = pane.props.disabled;
				const tabName = (_b = (_a$1 = pane.props.name) != null ? _a$1 : pane.index) != null ? _b : `${index$1}`;
				const closable = !disabled$2 && (pane.isClosable || props.editable);
				pane.index = `${index$1}`;
				const btnClose = closable ? createVNode(ElIcon, {
					"class": "is-icon-close",
					"onClick": (ev) => emit("tabRemove", pane, ev)
				}, { default: () => [createVNode(close_default$1, null, null)] }) : null;
				const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
				const tabindex = !disabled$2 && pane.active ? 0 : -1;
				return createVNode("div", {
					"ref": `tab-${uid}`,
					"class": [
						ns$1.e("item"),
						ns$1.is(rootTabs.props.tabPosition),
						ns$1.is("active", pane.active),
						ns$1.is("disabled", disabled$2),
						ns$1.is("closable", closable),
						ns$1.is("focus", isFocus.value)
					],
					"id": `tab-${tabName}`,
					"key": `tab-${uid}`,
					"aria-controls": `pane-${tabName}`,
					"role": "tab",
					"aria-selected": pane.active,
					"tabindex": tabindex,
					"onFocus": () => setFocus(),
					"onBlur": () => removeFocus(),
					"onClick": (ev) => {
						removeFocus();
						emit("tabClick", pane, tabName, ev);
					},
					"onKeydown": (ev) => {
						if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) emit("tabRemove", pane, ev);
					}
				}, [...[tabLabelContent, btnClose]]);
			});
			return createVNode("div", {
				"ref": el$,
				"class": [
					ns$1.e("nav-wrap"),
					ns$1.is("scrollable", !!scrollable.value),
					ns$1.is(rootTabs.props.tabPosition)
				]
			}, [scrollBtn, createVNode("div", {
				"class": ns$1.e("nav-scroll"),
				"ref": navScroll$
			}, [createVNode("div", {
				"class": [
					ns$1.e("nav"),
					ns$1.is(rootTabs.props.tabPosition),
					ns$1.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))
				],
				"ref": nav$,
				"style": navStyle.value,
				"role": "tablist",
				"onKeydown": changeTab
			}, [...[!props.type ? createVNode(TabBar, {
				"ref": tabBarRef,
				"tabs": [...props.panes]
			}, null) : null, tabs$1]])])]);
		};
	}
});
init_shared_esm_bundler();
var tabsProps = buildProps({
	type: {
		type: String,
		values: [
			"card",
			"border-card",
			""
		],
		default: ""
	},
	activeName: { type: [String, Number] },
	closable: Boolean,
	addable: Boolean,
	modelValue: { type: [String, Number] },
	editable: Boolean,
	tabPosition: {
		type: String,
		values: [
			"top",
			"right",
			"bottom",
			"left"
		],
		default: "top"
	},
	beforeLeave: {
		type: definePropType(Function),
		default: () => true
	},
	stretch: Boolean
});
var isPaneName = (value$1) => isString(value$1) || isNumber(value$1);
var Tabs = defineComponent({
	name: "ElTabs",
	props: tabsProps,
	emits: {
		[UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
		tabClick: (pane, ev) => ev instanceof Event,
		tabChange: (name) => isPaneName(name),
		edit: (paneName, action) => ["remove", "add"].includes(action),
		tabRemove: (name) => isPaneName(name),
		tabAdd: () => true
	},
	setup(props, { emit, slots, expose }) {
		var _a$1, _b;
		const ns$1 = useNamespace("tabs");
		const { children: panes, addChild: registerPane, removeChild: unregisterPane } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
		const nav$ = ref();
		const currentName = ref((_b = (_a$1 = props.modelValue) != null ? _a$1 : props.activeName) != null ? _b : "0");
		const setCurrentName = async (value$1, trigger = false) => {
			var _a2, _b2, _c;
			if (currentName.value === value$1 || isUndefined(value$1)) return;
			try {
				if (await ((_a2 = props.beforeLeave) == null ? void 0 : _a2.call(props, value$1, currentName.value)) !== false) {
					currentName.value = value$1;
					if (trigger) {
						emit(UPDATE_MODEL_EVENT, value$1);
						emit("tabChange", value$1);
					}
					(_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null || _c.call(_b2);
				}
			} catch (e) {}
		};
		const handleTabClick = (tab$1, tabName, event) => {
			if (tab$1.props.disabled) return;
			setCurrentName(tabName, true);
			emit("tabClick", tab$1, event);
		};
		const handleTabRemove = (pane, ev) => {
			if (pane.props.disabled || isUndefined(pane.props.name)) return;
			ev.stopPropagation();
			emit("edit", pane.props.name, "remove");
			emit("tabRemove", pane.props.name);
		};
		const handleTabAdd = () => {
			emit("edit", void 0, "add");
			emit("tabAdd");
		};
		useDeprecated({
			from: "\"activeName\"",
			replacement: "\"model-value\" or \"v-model\"",
			scope: "ElTabs",
			version: "2.3.0",
			ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
			type: "Attribute"
		}, computed(() => !!props.activeName));
		watch(() => props.activeName, (modelValue) => setCurrentName(modelValue));
		watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
		watch(currentName, async () => {
			var _a2;
			await nextTick();
			(_a2 = nav$.value) == null || _a2.scrollToActiveTab();
		});
		provide(tabsRootContextKey, {
			props,
			currentName,
			registerPane,
			unregisterPane
		});
		expose({ currentName });
		return () => {
			const addSlot = slots.addIcon;
			const newButton = props.editable || props.addable ? createVNode("span", {
				"class": ns$1.e("new-tab"),
				"tabindex": "0",
				"onClick": handleTabAdd,
				"onKeydown": (ev) => {
					if (ev.code === EVENT_CODE.enter) handleTabAdd();
				}
			}, [addSlot ? renderSlot(slots, "addIcon") : createVNode(ElIcon, { "class": ns$1.is("icon-plus") }, { default: () => [createVNode(plus_default, null, null)] })]) : null;
			const header$2 = createVNode("div", { "class": [ns$1.e("header"), ns$1.is(props.tabPosition)] }, [newButton, createVNode(TabNav, {
				"ref": nav$,
				"currentName": currentName.value,
				"editable": props.editable,
				"type": props.type,
				"panes": panes.value,
				"stretch": props.stretch,
				"onTabClick": handleTabClick,
				"onTabRemove": handleTabRemove
			}, null)]);
			const panels = createVNode("div", { "class": ns$1.e("content") }, [renderSlot(slots, "default")]);
			return createVNode("div", { "class": [
				ns$1.b(),
				ns$1.m(props.tabPosition),
				{
					[ns$1.m("card")]: props.type === "card",
					[ns$1.m("border-card")]: props.type === "border-card"
				}
			] }, [...props.tabPosition !== "bottom" ? [header$2, panels] : [panels, header$2]]);
		};
	}
});
var tabPaneProps = buildProps({
	label: {
		type: String,
		default: ""
	},
	name: { type: [String, Number] },
	closable: Boolean,
	disabled: Boolean,
	lazy: Boolean
});
var _hoisted_1$28 = [
	"id",
	"aria-hidden",
	"aria-labelledby"
];
var COMPONENT_NAME = "ElTabPane";
var TabPane = /* @__PURE__ */ _export_sfc(/* @__PURE__ */ defineComponent({
	...defineComponent({ name: COMPONENT_NAME }),
	props: tabPaneProps,
	setup(__props) {
		const props = __props;
		const instance = getCurrentInstance();
		const slots = useSlots();
		const tabsRoot = inject(tabsRootContextKey);
		if (!tabsRoot) throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
		const ns$1 = useNamespace("tab-pane");
		const index$1 = ref();
		const isClosable = computed(() => props.closable || tabsRoot.props.closable);
		const active$2 = computedEager(() => {
			var _a$1;
			return tabsRoot.currentName.value === ((_a$1 = props.name) != null ? _a$1 : index$1.value);
		});
		const loaded = ref(active$2.value);
		const paneName = computed(() => {
			var _a$1;
			return (_a$1 = props.name) != null ? _a$1 : index$1.value;
		});
		const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active$2.value);
		watch(active$2, (val) => {
			if (val) loaded.value = true;
		});
		const pane = reactive({
			uid: instance.uid,
			slots,
			props,
			paneName,
			active: active$2,
			index: index$1,
			isClosable
		});
		onMounted(() => {
			tabsRoot.registerPane(pane);
		});
		onUnmounted(() => {
			tabsRoot.unregisterPane(pane.uid);
		});
		return (_ctx, _cache) => {
			return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
				key: 0,
				id: `pane-${unref(paneName)}`,
				class: normalizeClass(unref(ns$1).b()),
				role: "tabpanel",
				"aria-hidden": !unref(active$2),
				"aria-labelledby": `tab-${unref(paneName)}`
			}, [renderSlot(_ctx.$slots, "default")], 10, _hoisted_1$28)), [[vShow, unref(active$2)]]) : createCommentVNode("v-if", true);
		};
	}
}), [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
var ElTabs = withInstall(Tabs, { TabPane });
var ElTabPane = withNoopInstall(TabPane);
var ni$1 = Object.defineProperty;
var Xr$1 = (t) => {
	throw TypeError(t);
};
var Jr$1 = (t, e) => {
	for (var r in e) ni$1(t, r, {
		get: e[r],
		enumerable: !0
	});
};
var Zr$1 = (t, e, r) => e.has(t) || Xr$1("Cannot " + r);
var Q$1 = (t, e, r) => (Zr$1(t, e, "read from private field"), r ? r.call(t) : e.get(t)), en$1 = (t, e, r) => e.has(t) ? Xr$1("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), tn$1 = (t, e, r, n) => (Zr$1(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
var Yr$1 = {};
Jr$1(Yr$1, {
	languages: () => Ds$1,
	options: () => ys,
	parsers: () => Gr$1,
	printers: () => $o
});
var si$1 = (t, e, r, n) => {
	if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, w = si$1;
var ke$1 = "string", Be$1 = "array", Le = "cursor", ce$1 = "indent", pe = "align", Fe$1 = "trim", te$1 = "group", he = "fill", me = "if-break", fe$1 = "indent-if-break", Ne = "line-suffix", Pe = "line-suffix-boundary", Y = "line", Ie = "label", de$1 = "break-parent", St$1 = new Set([
	Le,
	ce$1,
	pe,
	Fe$1,
	te$1,
	he,
	me,
	fe$1,
	Ne,
	Pe,
	Y,
	Ie,
	de$1
]);
function ii$1(t) {
	if (typeof t == "string") return ke$1;
	if (Array.isArray(t)) return Be$1;
	if (!t) return;
	let { type: e } = t;
	if (St$1.has(e)) return e;
}
var Re$1 = ii$1;
var ai$1 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function oi$1(t) {
	let e = t === null ? "null" : typeof t;
	if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
	if (Re$1(t)) throw new Error("doc is valid.");
	let r = Object.prototype.toString.call(t);
	if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
	let n = ai$1([...St$1].map((s) => `'${s}'`));
	return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var lr = class extends Error {
	name = "InvalidDocError";
	constructor(e) {
		super(oi$1(e)), this.doc = e;
	}
}, _t$1 = lr;
var rn$1 = () => {}, re$1 = rn$1, Et$1 = rn$1;
function k(t) {
	return re$1(t), {
		type: ce$1,
		contents: t
	};
}
function nn$1(t, e) {
	return re$1(e), {
		type: pe,
		contents: e,
		n: t
	};
}
function _$1(t, e = {}) {
	return re$1(t), Et$1(e.expandedStates, !0), {
		type: te$1,
		id: e.id,
		contents: t,
		break: !!e.shouldBreak,
		expandedStates: e.expandedStates
	};
}
function sn$1(t) {
	return nn$1(Number.NEGATIVE_INFINITY, t);
}
function an$1(t) {
	return nn$1({ type: "root" }, t);
}
function At$1(t) {
	return Et$1(t), {
		type: he,
		parts: t
	};
}
function ge$1(t, e = "", r = {}) {
	return re$1(t), e !== "" && re$1(e), {
		type: me,
		breakContents: t,
		flatContents: e,
		groupId: r.groupId
	};
}
function on$2(t, e) {
	return re$1(t), {
		type: fe$1,
		contents: t,
		groupId: e.groupId,
		negate: e.negate
	};
}
var ne = { type: de$1 };
var ui$1 = {
	type: Y,
	hard: !0
}, li$1 = {
	type: Y,
	hard: !0,
	literal: !0
}, E$1 = { type: Y }, v = {
	type: Y,
	soft: !0
}, S$1 = [ui$1, ne], un$1 = [li$1, ne];
function q$1(t, e) {
	re$1(t), Et$1(e);
	let r = [];
	for (let n = 0; n < e.length; n++) n !== 0 && r.push(t), r.push(e[n]);
	return r;
}
var ci$1 = (t, e, r) => {
	if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, X = ci$1;
function Dt$1(t, e) {
	if (typeof t == "string") return e(t);
	let r = /* @__PURE__ */ new Map();
	return n(t);
	function n(i) {
		if (r.has(i)) return r.get(i);
		let a = s(i);
		return r.set(i, a), a;
	}
	function s(i) {
		switch (Re$1(i)) {
			case Be$1: return e(i.map(n));
			case he: return e({
				...i,
				parts: i.parts.map(n)
			});
			case me: return e({
				...i,
				breakContents: n(i.breakContents),
				flatContents: n(i.flatContents)
			});
			case te$1: {
				let { expandedStates: a, contents: o } = i;
				return a ? (a = a.map(n), o = a[0]) : o = n(o), e({
					...i,
					contents: o,
					expandedStates: a
				});
			}
			case pe:
			case ce$1:
			case fe$1:
			case Ie:
			case Ne: return e({
				...i,
				contents: n(i.contents)
			});
			case ke$1:
			case Le:
			case Fe$1:
			case Pe:
			case Y:
			case de$1: return e(i);
			default: throw new _t$1(i);
		}
	}
}
function pi$1(t) {
	switch (Re$1(t)) {
		case he:
			if (t.parts.every((e) => e === "")) return "";
			break;
		case te$1:
			if (!t.contents && !t.id && !t.break && !t.expandedStates) return "";
			if (t.contents.type === te$1 && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates) return t.contents;
			break;
		case pe:
		case ce$1:
		case fe$1:
		case Ne:
			if (!t.contents) return "";
			break;
		case me:
			if (!t.flatContents && !t.breakContents) return "";
			break;
		case Be$1: {
			let e = [];
			for (let r of t) {
				if (!r) continue;
				let [n, ...s] = Array.isArray(r) ? r : [r];
				typeof n == "string" && typeof X(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...s);
			}
			return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
		}
		case ke$1:
		case Le:
		case Fe$1:
		case Pe:
		case Y:
		case Ie:
		case de$1: break;
		default: throw new _t$1(t);
	}
	return t;
}
function ln$1(t) {
	return Dt$1(t, (e) => pi$1(e));
}
function B(t, e = un$1) {
	return Dt$1(t, (r) => typeof r == "string" ? q$1(e, r.split(`
`)) : r);
}
var vt = "'", cn$1 = "\"";
function hi(t, e) {
	let r = e === !0 || e === vt ? vt : cn$1, n = r === vt ? cn$1 : vt, s = 0, i = 0;
	for (let a of t) a === r ? s++ : a === n && i++;
	return s > i ? n : r;
}
var pn$1 = hi;
function cr(t) {
	if (typeof t != "string") throw new TypeError("Expected a string");
	return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var H, pr = class {
	constructor(e) {
		en$1(this, H);
		tn$1(this, H, new Set(e));
	}
	getLeadingWhitespaceCount(e) {
		let r = Q$1(this, H), n = 0;
		for (let s = 0; s < e.length && r.has(e.charAt(s)); s++) n++;
		return n;
	}
	getTrailingWhitespaceCount(e) {
		let r = Q$1(this, H), n = 0;
		for (let s = e.length - 1; s >= 0 && r.has(e.charAt(s)); s--) n++;
		return n;
	}
	getLeadingWhitespace(e) {
		let r = this.getLeadingWhitespaceCount(e);
		return e.slice(0, r);
	}
	getTrailingWhitespace(e) {
		let r = this.getTrailingWhitespaceCount(e);
		return e.slice(e.length - r);
	}
	hasLeadingWhitespace(e) {
		return Q$1(this, H).has(e.charAt(0));
	}
	hasTrailingWhitespace(e) {
		return Q$1(this, H).has(X(!1, e, -1));
	}
	trimStart(e) {
		let r = this.getLeadingWhitespaceCount(e);
		return e.slice(r);
	}
	trimEnd(e) {
		let r = this.getTrailingWhitespaceCount(e);
		return e.slice(0, e.length - r);
	}
	trim(e) {
		return this.trimEnd(this.trimStart(e));
	}
	split(e, r = !1) {
		let n = `[${cr([...Q$1(this, H)].join(""))}]+`, s = new RegExp(r ? `(${n})` : n, "u");
		return e.split(s);
	}
	hasWhitespaceCharacter(e) {
		let r = Q$1(this, H);
		return Array.prototype.some.call(e, (n) => r.has(n));
	}
	hasNonWhitespaceCharacter(e) {
		let r = Q$1(this, H);
		return Array.prototype.some.call(e, (n) => !r.has(n));
	}
	isWhitespaceOnly(e) {
		let r = Q$1(this, H);
		return Array.prototype.every.call(e, (n) => r.has(n));
	}
};
H = /* @__PURE__ */ new WeakMap();
var N$1 = new pr([
	"	",
	`
`,
	"\f",
	"\r",
	" "
]);
var hr = class extends Error {
	name = "UnexpectedNodeError";
	constructor(e, r, n = "type") {
		super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`), this.node = e;
	}
}, mn$1 = hr;
function di$1(t) {
	return (t == null ? void 0 : t.type) === "front-matter";
}
var $e$1 = di$1;
var gi = new Set([
	"sourceSpan",
	"startSourceSpan",
	"endSourceSpan",
	"nameSpan",
	"valueSpan",
	"keySpan",
	"tagDefinition",
	"tokens",
	"valueTokens",
	"switchValueSourceSpan",
	"expSourceSpan",
	"valueSourceSpan"
]), Ci = new Set([
	"if",
	"else if",
	"for",
	"switch",
	"case"
]);
function fn$1(t, e) {
	var r;
	if (t.type === "text" || t.type === "comment" || $e$1(t) || t.type === "yaml" || t.type === "toml") return null;
	if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = t.parameters) != null && r.children) for (let n of e.parameters.children) Ci.has(t.name) ? delete n.expression : n.expression = n.expression.trim();
	t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim()), t.type === "angularLetDeclarationInitializer" && delete e.value;
}
fn$1.ignoredProperties = gi;
var dn = fn$1;
async function Si(t, e) {
	if (t.language === "yaml") {
		let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
		return an$1([
			t.startDelimiter,
			t.explicitLanguage,
			S$1,
			n,
			n ? S$1 : "",
			t.endDelimiter
		]);
	}
}
var gn$1 = Si;
function Ce(t, e = !0) {
	return [k([v, t]), e ? v : ""];
}
function j(t, e) {
	let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
	return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function T(t, e, r, n) {
	r = {
		__isInHtmlAttribute: !0,
		__embeddedInHtml: !0,
		...r
	};
	let s = !0;
	n && (r.__onHtmlBindingRoot = (a, o) => {
		s = n(a, o);
	});
	let i = await e(t, r, e);
	return s ? _$1(i) : Ce(i);
}
function _i(t, e, r, n) {
	let { node: s } = r, i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
	return /^\s*$/u.test(i) ? "" : T(i, t, {
		parser: "__ng_directive",
		__isInHtmlAttribute: !1
	}, j);
}
var Cn$1 = _i;
var Ei = (t) => String(t).split(/[/\\]/u).pop();
function Sn$1(t, e) {
	if (!e) return;
	let r = Ei(e).toLowerCase();
	return t.find(({ filenames: n }) => n == null ? void 0 : n.some((s) => s.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((s) => r.endsWith(s)));
}
function Ai(t, e) {
	if (e) return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function Di(t, e) {
	let r = t.plugins.flatMap((s) => s.languages ?? []), n = Ai(r, e.language) ?? Sn$1(r, e.physicalFile) ?? Sn$1(r, e.file) ?? (e.physicalFile, void 0);
	return n == null ? void 0 : n.parsers[0];
}
var Oe$1 = Di;
var _n$1 = "inline", En$1 = {
	area: "none",
	base: "none",
	basefont: "none",
	datalist: "none",
	head: "none",
	link: "none",
	meta: "none",
	noembed: "none",
	noframes: "none",
	param: "block",
	rp: "none",
	script: "block",
	style: "none",
	template: "inline",
	title: "none",
	html: "block",
	body: "block",
	address: "block",
	blockquote: "block",
	center: "block",
	dialog: "block",
	div: "block",
	figure: "block",
	figcaption: "block",
	footer: "block",
	form: "block",
	header: "block",
	hr: "block",
	legend: "block",
	listing: "block",
	main: "block",
	p: "block",
	plaintext: "block",
	pre: "block",
	search: "block",
	xmp: "block",
	slot: "contents",
	ruby: "ruby",
	rt: "ruby-text",
	article: "block",
	aside: "block",
	h1: "block",
	h2: "block",
	h3: "block",
	h4: "block",
	h5: "block",
	h6: "block",
	hgroup: "block",
	nav: "block",
	section: "block",
	dir: "block",
	dd: "block",
	dl: "block",
	dt: "block",
	menu: "block",
	ol: "block",
	ul: "block",
	li: "list-item",
	table: "table",
	caption: "table-caption",
	colgroup: "table-column-group",
	col: "table-column",
	thead: "table-header-group",
	tbody: "table-row-group",
	tfoot: "table-footer-group",
	tr: "table-row",
	td: "table-cell",
	th: "table-cell",
	input: "inline-block",
	button: "inline-block",
	fieldset: "block",
	marquee: "inline-block",
	source: "block",
	track: "block",
	details: "block",
	summary: "block",
	meter: "inline-block",
	progress: "inline-block",
	object: "inline-block",
	video: "inline-block",
	audio: "inline-block",
	select: "inline-block",
	option: "block",
	optgroup: "block"
}, An$1 = "normal", Dn$1 = {
	listing: "pre",
	plaintext: "pre",
	pre: "pre",
	xmp: "pre",
	nobr: "nowrap",
	table: "initial",
	textarea: "pre-wrap"
};
function vi(t) {
	return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var Se$1 = vi;
var yi$1 = (t) => w(!1, t, /^[\t\f\r ]*\n/gu, ""), mr = (t) => yi$1(N$1.trimEnd(t)), vn$1 = (t) => {
	let e = t, r = N$1.getLeadingWhitespace(e);
	r && (e = e.slice(r.length));
	let n = N$1.getTrailingWhitespace(e);
	return n && (e = e.slice(0, -n.length)), {
		leadingWhitespace: r,
		trailingWhitespace: n,
		text: e
	};
};
function yt(t, e) {
	return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || _e$1(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Tt$1(t, e) && !U$1(t) && t.type !== "interpolation");
}
function Ee$1(t) {
	return t.type === "attribute" || !t.parent || !t.prev ? !1 : wi(t.prev);
}
function wi(t) {
	return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function $(t) {
	return t.type === "text" || t.type === "comment";
}
function U$1(t) {
	return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || Se$1(t) && (t.name === "script" || t.name === "style"));
}
function yn$1(t) {
	return t.children && !U$1(t);
}
function wn$1(t) {
	return U$1(t) || t.type === "interpolation" || fr(t);
}
function fr(t) {
	return Rn$1(t).startsWith("pre");
}
function bn$1(t, e) {
	var s, i;
	let r = n();
	if (r && !t.prev && (i = (s = t.parent) == null ? void 0 : s.tagDefinition) != null && i.ignoreFirstLf) return t.type === "interpolation";
	return r;
	function n() {
		return $e$1(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : _e$1(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || _e$1(t) && t.parent || U$1(t.parent) || Je$1(t.parent, e) || !Li(t.parent.cssDisplay)) || t.prev && !Pi(t.prev.cssDisplay));
	}
}
function Tn$1(t, e) {
	return $e$1(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : _e$1(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || _e$1(t) && t.parent || U$1(t.parent) || Je$1(t.parent, e) || !Fi(t.parent.cssDisplay)) || t.next && !Ni(t.next.cssDisplay));
}
function xn$1(t) {
	return Ii(t.cssDisplay) && !U$1(t);
}
function Qe$1(t) {
	return $e$1(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function kn$1(t) {
	return dr(t) || t.type === "element" && t.children.length > 0 && ([
		"body",
		"script",
		"style"
	].includes(t.name) || t.children.some((e) => Ti(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && Ln$2(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || Fn$1(t.lastChild));
}
function dr(t) {
	return t.type === "element" && t.children.length > 0 && ([
		"html",
		"head",
		"ul",
		"ol",
		"select"
	].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function wt(t) {
	return Nn$1(t) || t.prev && bi(t.prev) || Bn$1(t);
}
function bi(t) {
	return Nn$1(t) || t.type === "element" && t.fullName === "br" || Bn$1(t);
}
function Bn$1(t) {
	return Ln$2(t) && Fn$1(t);
}
function Ln$2(t) {
	return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function Fn$1(t) {
	return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function Nn$1(t) {
	switch (t.type) {
		case "ieConditionalComment":
		case "comment":
		case "directive": return !0;
		case "element": return ["script", "select"].includes(t.name);
	}
	return !1;
}
function bt$1(t) {
	return t.lastChild ? bt$1(t.lastChild) : t;
}
function Ti(t) {
	var e;
	return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function Pn$1(t) {
	if (t) switch (t) {
		case "module":
		case "text/javascript":
		case "text/babel":
		case "application/javascript": return "babel";
		case "application/x-typescript": return "typescript";
		case "text/markdown": return "markdown";
		case "text/html": return "html";
		case "text/x-handlebars-template": return "glimmer";
		default: if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules") return "json";
	}
}
function xi(t, e) {
	let { name: r, attrMap: n } = t;
	if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src")) return;
	let { type: s, lang: i } = t.attrMap;
	return !i && !s ? "babel" : Oe$1(e, { language: i }) ?? Pn$1(s);
}
function ki(t, e) {
	if (!Tt$1(t, e)) return;
	let { attrMap: r } = t;
	if (Object.prototype.hasOwnProperty.call(r, "src")) return;
	let { type: n, lang: s } = r;
	return Oe$1(e, { language: s }) ?? Pn$1(n);
}
function Bi(t, e) {
	if (t.name !== "style") return;
	let { lang: r } = t.attrMap;
	return r ? Oe$1(e, { language: r }) : "css";
}
function gr(t, e) {
	return xi(t, e) ?? Bi(t, e) ?? ki(t, e);
}
function Xe$1(t) {
	return t === "block" || t === "list-item" || t.startsWith("table");
}
function Li(t) {
	return !Xe$1(t) && t !== "inline-block";
}
function Fi(t) {
	return !Xe$1(t) && t !== "inline-block";
}
function Ni(t) {
	return !Xe$1(t);
}
function Pi(t) {
	return !Xe$1(t);
}
function Ii(t) {
	return !Xe$1(t) && t !== "inline-block";
}
function _e$1(t) {
	return Rn$1(t).startsWith("pre");
}
function Ri(t, e) {
	let r = t;
	for (; r;) {
		if (e(r)) return !0;
		r = r.parent;
	}
	return !1;
}
function In$1(t, e) {
	var n;
	if (Ae$1(t, e)) return "block";
	if (((n = t.prev) == null ? void 0 : n.type) === "comment") {
		let s = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
		if (s) return s[1];
	}
	let r = !1;
	if (t.type === "element" && t.namespace === "svg") if (Ri(t, (s) => s.fullName === "svg:foreignObject")) r = !0;
	else return t.name === "svg" ? "inline-block" : "block";
	switch (e.htmlWhitespaceSensitivity) {
		case "strict": return "inline";
		case "ignore": return "block";
		default: return t.type === "element" && (!t.namespace || r || Se$1(t)) && En$1[t.name] || _n$1;
	}
}
function Rn$1(t) {
	return t.type === "element" && (!t.namespace || Se$1(t)) && Dn$1[t.name] || An$1;
}
function $i(t) {
	let e = Number.POSITIVE_INFINITY;
	for (let r of t.split(`
`)) {
		if (r.length === 0) continue;
		let n = N$1.getLeadingWhitespaceCount(r);
		if (n === 0) return 0;
		r.length !== n && n < e && (e = n);
	}
	return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function Cr(t, e = $i(t)) {
	return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function Sr(t) {
	return w(!1, w(!1, t, "&apos;", "'"), "&quot;", "\"");
}
function P$1(t) {
	return Sr(t.value);
}
var Oi = new Set([
	"template",
	"style",
	"script"
]);
function Je$1(t, e) {
	return Ae$1(t, e) && !Oi.has(t.fullName);
}
function Ae$1(t, e) {
	return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function Tt$1(t, e) {
	return Ae$1(t, e) && (Je$1(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function $n$1(t) {
	let e = t.fullName;
	return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function On$1(t, e) {
	let r = t.parent;
	if (!Ae$1(r, e)) return !1;
	let n = r.fullName, s = t.fullName;
	return n === "script" && s === "setup" || n === "style" && s === "vars";
}
function xt(t, e = t.value) {
	return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? B(e) : B(Cr(mr(e)), S$1) : q$1(E$1, N$1.split(e));
}
function kt$1(t, e) {
	return Ae$1(t, e) && t.name === "script";
}
var _r = /\{\{(.+?)\}\}/su;
async function Mn$1(t, e) {
	let r = [];
	for (let [n, s] of t.split(_r).entries()) if (n % 2 === 0) r.push(B(s));
	else try {
		r.push(_$1([
			"{{",
			k([E$1, await T(s, e, {
				parser: "__ng_interpolation",
				__isInHtmlInterpolation: !0
			})]),
			E$1,
			"}}"
		]));
	} catch {
		r.push("{{", B(s), "}}");
	}
	return r;
}
function Er({ parser: t }) {
	return (e, r, n) => T(P$1(n.node), e, { parser: t }, j);
}
var Mi = Er({ parser: "__ng_action" }), qi = Er({ parser: "__ng_binding" }), Hi = Er({ parser: "__ng_directive" });
function Vi(t, e) {
	if (e.parser !== "angular") return;
	let { node: r } = t, n = r.fullName;
	if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-")) return Mi;
	if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/u.test(n) || /^ng-(?:if|show|hide|class|style)$/u.test(n)) return qi;
	if (n.startsWith("*")) return Hi;
	let s = P$1(r);
	if (/^i18n(?:-.+)?$/u.test(n)) return () => Ce(At$1(xt(r, s.trim())), !s.includes("@@"));
	if (_r.test(s)) return (i) => Mn$1(s, i);
}
var qn$1 = Vi;
function Ui(t, e) {
	let { node: r } = t, n = P$1(r);
	if (r.fullName === "class" && !e.parentParser && !n.includes("{{")) return () => n.trim().split(/\s+/u).join(" ");
}
var Hn$1 = Ui;
function Vn$1(t) {
	return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var Wi = /^[ \t\n\r\u000c]+/, zi = /^[, \t\n\r\u000c]+/, Gi = /^[^ \t\n\r\u000c]+/, Yi = /[,]+$/, Un$1 = /^\d+$/, ji = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function Ki$1(t) {
	let e = t.length, r, n, s, i, a, o = 0, u;
	function p(C) {
		let A$1, D$1 = C.exec(t.substring(o));
		if (D$1) return [A$1] = D$1, o += A$1.length, A$1;
	}
	let l = [];
	for (;;) {
		if (p(zi), o >= e) {
			if (l.length === 0) throw new Error("Must contain one or more image candidate strings.");
			return l;
		}
		u = o, r = p(Gi), n = [], r.slice(-1) === "," ? (r = r.replace(Yi, ""), d()) : f();
	}
	function f() {
		for (p(Wi), s = "", i = "in descriptor";;) {
			if (a = t.charAt(o), i === "in descriptor") if (Vn$1(a)) s && (n.push(s), s = "", i = "after descriptor");
			else if (a === ",") {
				o += 1, s && n.push(s), d();
				return;
			} else if (a === "(") s += a, i = "in parens";
			else if (a === "") {
				s && n.push(s), d();
				return;
			} else s += a;
			else if (i === "in parens") if (a === ")") s += a, i = "in descriptor";
			else if (a === "") {
				n.push(s), d();
				return;
			} else s += a;
			else if (i === "after descriptor" && !Vn$1(a)) if (a === "") {
				d();
				return;
			} else i = "in descriptor", o -= 1;
			o += 1;
		}
	}
	function d() {
		let C = !1, A$1, D$1, R, F, c = {}, g, y$1, M$1, x, V$1;
		for (F = 0; F < n.length; F++) g = n[F], y$1 = g[g.length - 1], M$1 = g.substring(0, g.length - 1), x = parseInt(M$1, 10), V$1 = parseFloat(M$1), Un$1.test(M$1) && y$1 === "w" ? ((A$1 || D$1) && (C = !0), x === 0 ? C = !0 : A$1 = x) : ji.test(M$1) && y$1 === "x" ? ((A$1 || D$1 || R) && (C = !0), V$1 < 0 ? C = !0 : D$1 = V$1) : Un$1.test(M$1) && y$1 === "h" ? ((R || D$1) && (C = !0), x === 0 ? C = !0 : R = x) : C = !0;
		if (!C) c.source = {
			value: r,
			startOffset: u
		}, A$1 && (c.width = { value: A$1 }), D$1 && (c.density = { value: D$1 }), R && (c.height = { value: R }), l.push(c);
		else throw new Error(`Invalid srcset descriptor found in "${t}" at "${g}".`);
	}
}
var Wn$1 = Ki$1;
function Qi(t) {
	if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source")) return () => Ji$1(P$1(t.node));
}
var zn$1 = {
	width: "w",
	height: "h",
	density: "x"
}, Xi = Object.keys(zn$1);
function Ji$1(t) {
	let e = Wn$1(t), r = Xi.filter((l) => e.some((f) => Object.prototype.hasOwnProperty.call(f, l)));
	if (r.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
	let [n] = r, s = zn$1[n], i = e.map((l) => l.source.value), a = Math.max(...i.map((l) => l.length)), o = e.map((l) => l[n] ? String(l[n].value) : ""), u = o.map((l) => {
		let f = l.indexOf(".");
		return f === -1 ? l.length : f;
	}), p = Math.max(...u);
	return Ce(q$1([",", E$1], i.map((l, f) => {
		let d = [l], C = o[f];
		if (C) {
			let A$1 = a - l.length + 1, D$1 = p - u[f], R = " ".repeat(A$1 + D$1);
			d.push(ge$1(R, " "), C + s);
		}
		return d;
	})));
}
var Gn$1 = Qi;
function Yn$1(t, e) {
	let { node: r } = t, n = P$1(t.node).trim();
	if (r.fullName === "style" && !e.parentParser && !n.includes("{{")) return async (s) => Ce(await s(n, {
		parser: "css",
		__isHTMLStyleAttribute: !0
	}));
}
var Ar = /* @__PURE__ */ new WeakMap();
function Zi(t, e) {
	let { root: r } = t;
	return Ar.has(r) || Ar.set(r, r.children.some((n) => kt$1(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), Ar.get(r);
}
var Me$1 = Zi;
function jn$1(t, e, r) {
	let { node: n } = r;
	return T(`type T<${P$1(n)}> = any`, t, {
		parser: "babel-ts",
		__isEmbeddedTypescriptGenericParameters: !0
	}, j);
}
function Kn$1(t, e, { parseWithTs: r }) {
	return T(`function _(${t}) {}`, e, {
		parser: r ? "babel-ts" : "babel",
		__isVueBindings: !0
	});
}
function Qn$1(t) {
	let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/u, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*'\]|\["[^"]*"\]|\[\d+\]|\[[$_a-z][\w$]*\])*$/iu, n = t.trim();
	return e.test(n) || r.test(n);
}
async function Xn$1(t, e, r, n) {
	let { left: i, operator: a, right: o } = ea(P$1(r.node)), u = Me$1(r, n);
	return [
		_$1(await T(`function _(${i}) {}`, t, {
			parser: u ? "babel-ts" : "babel",
			__isVueForBindingLeft: !0
		})),
		" ",
		a,
		" ",
		await T(o, t, { parser: u ? "__ts_expression" : "__js_expression" })
	];
}
function ea(t) {
	let e = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n = /^\(|\)$/gu, s = t.match(e);
	if (!s) return;
	let i = {};
	if (i.for = s[3].trim(), !i.for) return;
	let a = w(!1, s[1].trim(), n, ""), o = a.match(r);
	o ? (i.alias = a.replace(r, ""), i.iterator1 = o[1].trim(), o[2] && (i.iterator2 = o[2].trim())) : i.alias = a;
	let u = [
		i.alias,
		i.iterator1,
		i.iterator2
	];
	if (!u.some((p, l) => !p && (l === 0 || u.slice(l + 1).some(Boolean)))) return {
		left: u.filter(Boolean).join(","),
		operator: s[2],
		right: i.for
	};
}
function ta$1(t, e) {
	if (e.parser !== "vue") return;
	let { node: r } = t, n = r.fullName;
	if (n === "v-for") return Xn$1;
	if (n === "generic" && kt$1(r.parent, e)) return jn$1;
	let s = P$1(r), i = Me$1(t, e);
	if ($n$1(r) || On$1(r, e)) return (a) => Kn$1(s, a, { parseWithTs: i });
	if (n.startsWith("@") || n.startsWith("v-on:")) return (a) => ra$1(s, a, { parseWithTs: i });
	if (n.startsWith(":") || n.startsWith("v-bind:")) return (a) => na(s, a, { parseWithTs: i });
	if (n.startsWith("v-")) return (a) => Jn$1(s, a, { parseWithTs: i });
}
function ra$1(t, e, { parseWithTs: r }) {
	return Qn$1(t) ? Jn$1(t, e, { parseWithTs: r }) : T(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, j);
}
function na(t, e, { parseWithTs: r }) {
	return T(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, j);
}
function Jn$1(t, e, { parseWithTs: r }) {
	return T(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, j);
}
var Zn$1 = ta$1;
function sa(t, e) {
	let { node: r } = t;
	if (r.value) {
		if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}")) return [
			r.rawName,
			"=",
			r.value
		];
		for (let n of [
			Gn$1,
			Yn$1,
			Hn$1,
			Zn$1,
			qn$1
		]) {
			let s = n(t, e);
			if (s) return ia(s);
		}
	}
}
function ia(t) {
	return async (e, r, n, s) => {
		let i = await t(e, r, n, s);
		if (i) return i = Dt$1(i, (a) => typeof a == "string" ? w(!1, a, "\"", "&quot;") : a), [
			n.node.rawName,
			"=\"",
			_$1(i),
			"\""
		];
	};
}
var es$1 = sa;
var ts = new Proxy(() => {}, { get: () => ts }), Dr = ts;
function aa$1(t) {
	return Array.isArray(t) && t.length > 0;
}
var qe$1 = aa$1;
function se(t) {
	return t.sourceSpan.start.offset;
}
function ie$1(t) {
	return t.sourceSpan.end.offset;
}
function Ze$1(t, e) {
	return [t.isSelfClosing ? "" : oa(t, e), De(t, e)];
}
function oa(t, e) {
	return t.lastChild && we$1(t.lastChild) ? "" : [ua$1(t, e), Bt$1(t, e)];
}
function De(t, e) {
	return (t.next ? K$1(t.next) : ye$1(t.parent)) ? "" : [ve$1(t, e), W$1(t, e)];
}
function ua$1(t, e) {
	return ye$1(t) ? ve$1(t.lastChild, e) : "";
}
function W$1(t, e) {
	return we$1(t) ? Bt$1(t.parent, e) : et$1(t) ? Lt$1(t.next) : "";
}
function Bt$1(t, e) {
	if (Dr(!t.isSelfClosing), rs(t, e)) return "";
	switch (t.type) {
		case "ieConditionalComment": return "<!";
		case "element": if (t.hasHtmComponentClosingTag) return "<//";
		default: return `</${t.rawName}`;
	}
}
function ve$1(t, e) {
	if (rs(t, e)) return "";
	switch (t.type) {
		case "ieConditionalComment":
		case "ieConditionalEndComment": return "[endif]-->";
		case "ieConditionalStartComment": return "]><!-->";
		case "interpolation": return "}}";
		case "angularIcuExpression": return "}";
		case "element": if (t.isSelfClosing) return "/>";
		default: return ">";
	}
}
function rs(t, e) {
	return !t.isSelfClosing && !t.endSourceSpan && (Ee$1(t) || yt(t.parent, e));
}
function K$1(t) {
	return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !$(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function ye$1(t) {
	var e;
	return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !$(bt$1(t.lastChild)) && !_e$1(t);
}
function we$1(t) {
	return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && $(bt$1(t));
}
function et$1(t) {
	return t.next && !$(t.next) && $(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function la$1(t) {
	let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
	return e ? e[1] ? e[1].split(/\s+/u) : !0 : !1;
}
function tt$1(t) {
	return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function ca$1(t, e, r) {
	var f;
	let { node: n } = t;
	if (!qe$1(n.attrs)) return n.isSelfClosing ? " " : "";
	let s = ((f = n.prev) == null ? void 0 : f.type) === "comment" && la$1(n.prev.value), i = typeof s == "boolean" ? () => s : Array.isArray(s) ? (d) => s.includes(d.rawName) : () => !1, a = t.map(({ node: d }) => i(d) ? B(e.originalText.slice(se(d), ie$1(d))) : r(), "attrs"), o = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, p = e.singleAttributePerLine && n.attrs.length > 1 && !Ae$1(n, e) ? S$1 : E$1, l = [k([o ? " " : E$1, q$1(p, a)])];
	return n.firstChild && tt$1(n.firstChild) || n.isSelfClosing && ye$1(n.parent) || o ? l.push(n.isSelfClosing ? " " : "") : l.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? E$1 : v), l;
}
function pa(t) {
	return t.firstChild && tt$1(t.firstChild) ? "" : Ft$1(t);
}
function rt$1(t, e, r) {
	let { node: n } = t;
	return [
		be$1(n, e),
		ca$1(t, e, r),
		n.isSelfClosing ? "" : pa(n)
	];
}
function be$1(t, e) {
	return t.prev && et$1(t.prev) ? "" : [z$1(t, e), Lt$1(t)];
}
function z$1(t, e) {
	return tt$1(t) ? Ft$1(t.parent) : K$1(t) ? ve$1(t.prev, e) : "";
}
function Lt$1(t) {
	switch (t.type) {
		case "ieConditionalComment":
		case "ieConditionalStartComment": return `<!--[if ${t.condition}`;
		case "ieConditionalEndComment": return "<!--<!";
		case "interpolation": return "{{";
		case "docType": return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
		case "angularIcuExpression": return "{";
		case "element": if (t.condition) return `<!--[if ${t.condition}]><!--><${t.rawName}`;
		default: return `<${t.rawName}`;
	}
}
function Ft$1(t) {
	switch (Dr(!t.isSelfClosing), t.type) {
		case "ieConditionalComment": return "]>";
		case "element": if (t.condition) return "><!--<![endif]-->";
		default: return ">";
	}
}
function ha(t, e) {
	if (!t.endSourceSpan) return "";
	let r = t.startSourceSpan.end.offset;
	t.firstChild && tt$1(t.firstChild) && (r -= Ft$1(t).length);
	let n = t.endSourceSpan.start.offset;
	return t.lastChild && we$1(t.lastChild) ? n += Bt$1(t, e).length : ye$1(t) && (n -= ve$1(t.lastChild, e).length), e.originalText.slice(r, n);
}
var Nt$1 = ha;
var ma = new Set([
	"if",
	"else if",
	"for",
	"switch",
	"case"
]);
function fa(t, e) {
	let { node: r } = t;
	switch (r.type) {
		case "element":
			if (U$1(r) || r.type === "interpolation") return;
			if (!r.isSelfClosing && Tt$1(r, e)) {
				let n = gr(r, e);
				return n ? async (s, i) => {
					let a = Nt$1(r, e), o = /^\s*$/u.test(a), u = "";
					return o || (u = await s(mr(a), {
						parser: n,
						__embeddedInHtml: !0
					}), o = u === ""), [
						z$1(r, e),
						_$1(rt$1(t, e, i)),
						o ? "" : S$1,
						u,
						o ? "" : S$1,
						Ze$1(r, e),
						W$1(r, e)
					];
				} : void 0;
			}
			break;
		case "text":
			if (U$1(r.parent)) {
				let n = gr(r.parent, e);
				if (n) return async (s) => {
					let i = n === "markdown" ? Cr(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = {
						parser: n,
						__embeddedInHtml: !0
					};
					if (e.parser === "html" && n === "babel") {
						let o = "script", { attrMap: u } = r.parent;
						u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
					}
					return [
						ne,
						z$1(r, e),
						await s(i, a),
						W$1(r, e)
					];
				};
			} else if (r.parent.type === "interpolation") return async (n) => {
				let s = {
					__isInHtmlInterpolation: !0,
					__embeddedInHtml: !0
				};
				return e.parser === "angular" ? s.parser = "__ng_interpolation" : e.parser === "vue" ? s.parser = Me$1(t, e) ? "__vue_ts_expression" : "__vue_expression" : s.parser = "__js_expression", [k([E$1, await n(r.value, s)]), r.parent.next && K$1(r.parent.next) ? " " : E$1];
			};
			break;
		case "attribute": return es$1(t, e);
		case "front-matter": return (n) => gn$1(r, n);
		case "angularControlFlowBlockParameters": return ma.has(t.parent.name) ? Cn$1 : void 0;
		case "angularLetDeclarationInitializer": return (n) => T(r.value, n, {
			parser: "__ng_binding",
			__isInHtmlAttribute: !1
		});
	}
}
var ns = fa;
var nt = null;
function st(t) {
	if (nt !== null && typeof nt.property) {
		let e = nt;
		return nt = st.prototype = null, e;
	}
	return nt = st.prototype = t ?? Object.create(null), new st();
}
var da = 10;
for (let t = 0; t <= da; t++) st();
function vr(t) {
	return st(t);
}
function ga$1(t, e = "type") {
	vr(t);
	function r(n) {
		let s = n[e], i = t[s];
		if (!Array.isArray(i)) throw Object.assign(/* @__PURE__ */ new Error(`Missing visitor keys for '${s}'.`), { node: n });
		return i;
	}
	return r;
}
var as = ga$1({
	"front-matter": [],
	root: ["children"],
	element: ["attrs", "children"],
	ieConditionalComment: ["children"],
	ieConditionalStartComment: [],
	ieConditionalEndComment: [],
	interpolation: ["children"],
	text: ["children"],
	docType: [],
	comment: [],
	attribute: [],
	cdata: [],
	angularControlFlowBlock: ["children", "parameters"],
	angularControlFlowBlockParameters: ["children"],
	angularControlFlowBlockParameter: [],
	angularLetDeclaration: ["init"],
	angularLetDeclarationInitializer: [],
	angularIcuExpression: ["cases"],
	angularIcuCase: ["expression"]
});
function os(t) {
	return /^\s*<!--\s*@(?:format|prettier)\s*-->/u.test(t);
}
function us$1(t) {
	return `<!-- @format -->

` + t;
}
var ls = new Map([
	["if", new Set(["else if", "else"])],
	["else if", new Set(["else if", "else"])],
	["for", new Set(["empty"])],
	["defer", new Set([
		"placeholder",
		"error",
		"loading"
	])],
	["placeholder", new Set([
		"placeholder",
		"error",
		"loading"
	])],
	["error", new Set([
		"placeholder",
		"error",
		"loading"
	])],
	["loading", new Set([
		"placeholder",
		"error",
		"loading"
	])]
]);
function cs$1(t) {
	let e = ie$1(t);
	return t.type === "element" && !t.endSourceSpan && qe$1(t.children) ? Math.max(e, cs$1(X(!1, t.children, -1))) : e;
}
function it$1(t, e, r) {
	let n = t.node;
	if (Ee$1(n)) {
		let s = cs$1(n);
		return [
			z$1(n, e),
			B(N$1.trimEnd(e.originalText.slice(se(n) + (n.prev && et$1(n.prev) ? Lt$1(n).length : 0), s - (n.next && K$1(n.next) ? ve$1(n, e).length : 0)))),
			W$1(n, e)
		];
	}
	return r();
}
function Pt$1(t, e) {
	return $(t) && $(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? wt(e) ? S$1 : E$1 : "" : wt(e) ? S$1 : v : et$1(t) && (Ee$1(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && K$1(e) ? "" : !e.isLeadingSpaceSensitive || wt(e) || K$1(e) && t.lastChild && we$1(t.lastChild) && t.lastChild.lastChild && we$1(t.lastChild.lastChild) ? S$1 : e.hasLeadingSpaces ? E$1 : v;
}
function He$1(t, e, r) {
	let { node: n } = t;
	if (dr(n)) return [ne, ...t.map((i) => {
		let a = i.node, o = a.prev ? Pt$1(a.prev, a) : "";
		return [o ? [o, Qe$1(a.prev) ? S$1 : ""] : "", it$1(i, e, r)];
	}, "children")];
	let s = n.children.map(() => Symbol(""));
	return t.map((i, a) => {
		let o = i.node;
		if ($(o)) {
			if (o.prev && $(o.prev)) {
				let A$1 = Pt$1(o.prev, o);
				if (A$1) return Qe$1(o.prev) ? [
					S$1,
					S$1,
					it$1(i, e, r)
				] : [A$1, it$1(i, e, r)];
			}
			return it$1(i, e, r);
		}
		let u = [], p = [], l = [], f = [], d = o.prev ? Pt$1(o.prev, o) : "", C = o.next ? Pt$1(o, o.next) : "";
		return d && (Qe$1(o.prev) ? u.push(S$1, S$1) : d === S$1 ? u.push(S$1) : $(o.prev) ? p.push(d) : p.push(ge$1("", v, { groupId: s[a - 1] }))), C && (Qe$1(o) ? $(o.next) && f.push(S$1, S$1) : C === S$1 ? $(o.next) && f.push(S$1) : l.push(C)), [
			...u,
			_$1([...p, _$1([it$1(i, e, r), ...l], { id: s[a] })]),
			...f
		];
	}, "children");
}
function ps(t, e, r) {
	let { node: n } = t, s = [];
	_a(t) && s.push("} "), s.push("@", n.name), n.parameters && s.push(" (", _$1(r("parameters")), ")"), s.push(" {");
	let i = hs(n);
	return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = !0, n.lastChild.hasTrailingSpaces = !0, s.push(k([S$1, He$1(t, e, r)])), i && s.push(S$1, "}")) : i && s.push("}"), _$1(s, { shouldBreak: !0 });
}
function hs(t) {
	var e, r;
	return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = ls.get(t.name)) != null && r.has(t.next.name));
}
function _a(t) {
	let { previous: e } = t;
	return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Ee$1(e) && !hs(e);
}
function ms(t, e, r) {
	return [k([v, q$1([";", E$1], t.map(r, "children"))]), v];
}
function fs(t, e, r) {
	let { node: n } = t;
	return [
		be$1(n, e),
		_$1([
			n.switchValue.trim(),
			", ",
			n.clause,
			n.cases.length > 0 ? [",", k([E$1, q$1(E$1, t.map(r, "cases"))])] : "",
			v
		]),
		De(n, e)
	];
}
function ds(t, e, r) {
	let { node: n } = t;
	return [
		n.value,
		" {",
		_$1([k([v, t.map(({ node: s }) => s.type === "text" && !N$1.trim(s.value) ? "" : r(), "expression")]), v]),
		"}"
	];
}
function gs$1(t, e, r) {
	let { node: n } = t;
	if (yt(n, e)) return [
		z$1(n, e),
		_$1(rt$1(t, e, r)),
		B(Nt$1(n, e)),
		...Ze$1(n, e),
		W$1(n, e)
	];
	let s = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l) => _$1([
		_$1(rt$1(t, e, r), { id: i }),
		l,
		Ze$1(n, e)
	]), o = (l) => s ? on$2(l, { groupId: i }) : (U$1(n) || Je$1(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? l : k(l), u = () => s ? ge$1(v, "", { groupId: i }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? E$1 : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? sn$1(v) : v, p = () => (n.next ? K$1(n.next) : ye$1(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : s ? ge$1(v, "", { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? E$1 : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`, "u").test(n.lastChild.value) ? "" : v;
	return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? E$1 : "") : a([
		kn$1(n) ? ne : "",
		o([u(), He$1(t, e, r)]),
		p()
	]);
}
function at$1(t) {
	return t >= 9 && t <= 32 || t == 160;
}
function It$1(t) {
	return 48 <= t && t <= 57;
}
function ot(t) {
	return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function Cs(t) {
	return t >= 97 && t <= 102 || t >= 65 && t <= 70 || It$1(t);
}
function Rt$1(t) {
	return t === 10 || t === 13;
}
function yr(t) {
	return 48 <= t && t <= 55;
}
function $t$1(t) {
	return t === 39 || t === 34 || t === 96;
}
var Ea = /-+([a-z0-9])/g;
function _s$1(t) {
	return t.replace(Ea, (...e) => e[1].toUpperCase());
}
var ae$1 = class t {
	constructor(e, r, n, s) {
		this.file = e, this.offset = r, this.line = n, this.col = s;
	}
	toString() {
		return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
	}
	moveBy(e) {
		let r = this.file.content, n = r.length, s = this.offset, i = this.line, a = this.col;
		for (; s > 0 && e < 0;) if (s--, e++, r.charCodeAt(s) == 10) {
			i--;
			let u = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
			a = u > 0 ? s - u : s;
		} else a--;
		for (; s < n && e > 0;) {
			let o = r.charCodeAt(s);
			s++, e--, o == 10 ? (i++, a = 0) : a++;
		}
		return new t(this.file, s, i, a);
	}
	getContext(e, r) {
		let n = this.file.content, s = this.offset;
		if (s != null) {
			s > n.length - 1 && (s = n.length - 1);
			let i = s, a = 0, o = 0;
			for (; a < e && s > 0 && (s--, a++, !(n[s] == `
` && ++o == r)););
			for (a = 0, o = 0; a < e && i < n.length - 1 && (i++, a++, !(n[i] == `
` && ++o == r)););
			return {
				before: n.substring(s, this.offset),
				after: n.substring(this.offset, i + 1)
			};
		}
		return null;
	}
}, Te$1 = class {
	constructor(e, r) {
		this.content = e, this.url = r;
	}
}, h = class {
	constructor(e, r, n = e, s = null) {
		this.start = e, this.end = r, this.fullStart = n, this.details = s;
	}
	toString() {
		return this.start.file.content.substring(this.start.offset, this.end.offset);
	}
}, Ot$1;
(function(t) {
	t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(Ot$1 || (Ot$1 = {}));
var Ue$1 = class {
	constructor(e, r, n = Ot$1.ERROR) {
		this.span = e, this.msg = r, this.level = n;
	}
	contextualMessage() {
		let e = this.span.start.getContext(100, 3);
		return e ? `${this.msg} ("${e.before}[${Ot$1[this.level]} ->]${e.after}")` : this.msg;
	}
	toString() {
		let e = this.span.details ? `, ${this.span.details}` : "";
		return `${this.contextualMessage()}: ${this.span.start}${e}`;
	}
};
var Aa$1 = [
	va,
	ya,
	ba,
	xa$1,
	ka$1,
	Fa,
	Ba,
	La$1,
	Na,
	Ta
];
function Da(t, e) {
	for (let r of Aa$1) r(t, e);
	return t;
}
function va(t) {
	t.walk((e) => {
		if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
			let r = e.children[0];
			r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
		}
	});
}
function ya(t) {
	let e = (r) => {
		var n, s;
		return r.type === "element" && ((n = r.prev) == null ? void 0 : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((s = r.firstChild) == null ? void 0 : s.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
	};
	t.walk((r) => {
		if (r.children) for (let n = 0; n < r.children.length; n++) {
			let s = r.children[n];
			if (!e(s)) continue;
			let i = s.prev, a = s.firstChild;
			r.removeChild(i), n--;
			let o = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o.start, s.sourceSpan.end);
			s.condition = i.condition, s.sourceSpan = u, s.startSourceSpan = o, s.removeChild(a);
		}
	});
}
function wa(t, e, r) {
	t.walk((n) => {
		if (n.children) for (let s = 0; s < n.children.length; s++) {
			let i = n.children[s];
			if (i.type !== "text" && !e(i)) continue;
			i.type !== "text" && (i.type = "text", i.value = r(i));
			let a = i.prev;
			!a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n.removeChild(i), s--);
		}
	});
}
function ba(t) {
	return wa(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function Ta(t) {
	let e = (r) => {
		var n, s;
		return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !N$1.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? void 0 : n.type) === "text" && ((s = r.next) == null ? void 0 : s.type) === "text";
	};
	t.walk((r) => {
		if (r.children) for (let n = 0; n < r.children.length; n++) {
			let s = r.children[n];
			if (!e(s)) continue;
			let i = s.prev, a = s.next;
			i.value += `<${s.rawName}>` + s.firstChild.value + `</${s.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(s), n--, r.removeChild(a);
		}
	});
}
function xa$1(t, e) {
	if (e.parser === "html") return;
	let r = /\{\{(.+?)\}\}/su;
	t.walk((n) => {
		if (yn$1(n)) for (let s of n.children) {
			if (s.type !== "text") continue;
			let i = s.sourceSpan.start, a = null, o = s.value.split(r);
			for (let u = 0; u < o.length; u++, i = a) {
				let p = o[u];
				if (u % 2 === 0) {
					a = i.moveBy(p.length), p.length > 0 && n.insertChildBefore(s, {
						type: "text",
						value: p,
						sourceSpan: new h(i, a)
					});
					continue;
				}
				a = i.moveBy(p.length + 4), n.insertChildBefore(s, {
					type: "interpolation",
					sourceSpan: new h(i, a),
					children: p.length === 0 ? [] : [{
						type: "text",
						value: p,
						sourceSpan: new h(i.moveBy(2), a.moveBy(-2))
					}]
				});
			}
			n.removeChild(s);
		}
	});
}
function ka$1(t) {
	t.walk((e) => {
		if (!e.children) return;
		if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && N$1.trim(e.children[0].value).length === 0) {
			e.hasDanglingSpaces = e.children.length > 0, e.children = [];
			return;
		}
		let r = wn$1(e), n = fr(e);
		if (!r) for (let s = 0; s < e.children.length; s++) {
			let i = e.children[s];
			if (i.type !== "text") continue;
			let { leadingWhitespace: a, text: o, trailingWhitespace: u } = vn$1(i.value), p = i.prev, l = i.next;
			o ? (i.value = o, i.sourceSpan = new h(i.sourceSpan.start.moveBy(a.length), i.sourceSpan.end.moveBy(-u.length)), a && (p && (p.hasTrailingSpaces = !0), i.hasLeadingSpaces = !0), u && (i.hasTrailingSpaces = !0, l && (l.hasLeadingSpaces = !0))) : (e.removeChild(i), s--, (a || u) && (p && (p.hasTrailingSpaces = !0), l && (l.hasLeadingSpaces = !0)));
		}
		e.isWhitespaceSensitive = r, e.isIndentationSensitive = n;
	});
}
function Ba(t) {
	t.walk((e) => {
		e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
	});
}
function La$1(t, e) {
	t.walk((r) => {
		r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
	});
}
function Fa(t, e) {
	t.walk((r) => {
		r.cssDisplay = In$1(r, e);
	});
}
function Na(t, e) {
	t.walk((r) => {
		let { children: n } = r;
		if (n) {
			if (n.length === 0) {
				r.isDanglingSpaceSensitive = xn$1(r);
				return;
			}
			for (let s of n) s.isLeadingSpaceSensitive = bn$1(s, e), s.isTrailingSpaceSensitive = Tn$1(s, e);
			for (let s = 0; s < n.length; s++) {
				let i = n[s];
				i.isLeadingSpaceSensitive = (s === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s === n.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
			}
		}
	});
}
var Es = Da;
function Pa$1(t, e, r) {
	let { node: n } = t;
	switch (n.type) {
		case "front-matter": return B(n.raw);
		case "root": return e.__onHtmlRoot && e.__onHtmlRoot(n), [_$1(He$1(t, e, r)), S$1];
		case "element":
		case "ieConditionalComment": return gs$1(t, e, r);
		case "angularControlFlowBlock": return ps(t, e, r);
		case "angularControlFlowBlockParameters": return ms(t, e, r);
		case "angularControlFlowBlockParameter": return N$1.trim(n.expression);
		case "angularLetDeclaration": return _$1([
			"@let ",
			_$1([
				n.id,
				" =",
				_$1(k([E$1, r("init")]))
			]),
			";"
		]);
		case "angularLetDeclarationInitializer": return n.value;
		case "angularIcuExpression": return fs(t, e, r);
		case "angularIcuCase": return ds(t, e, r);
		case "ieConditionalStartComment":
		case "ieConditionalEndComment": return [be$1(n), De(n)];
		case "interpolation": return [
			be$1(n, e),
			...t.map(r, "children"),
			De(n, e)
		];
		case "text": {
			if (n.parent.type === "interpolation") {
				let i = /\n[^\S\n]*$/u, a = i.test(n.value);
				return [B(a ? n.value.replace(i, "") : n.value), a ? S$1 : ""];
			}
			let s = ln$1([
				z$1(n, e),
				...xt(n),
				W$1(n, e)
			]);
			return Array.isArray(s) ? At$1(s) : s;
		}
		case "docType": return [_$1([
			be$1(n, e),
			" ",
			w(!1, n.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")
		]), De(n, e)];
		case "comment": return [
			z$1(n, e),
			B(e.originalText.slice(se(n), ie$1(n))),
			W$1(n, e)
		];
		case "attribute": {
			if (n.value === null) return n.rawName;
			let s = Sr(n.value), i = pn$1(s, "\"");
			return [
				n.rawName,
				"=",
				i,
				B(i === "\"" ? w(!1, s, "\"", "&quot;") : w(!1, s, "'", "&apos;")),
				i
			];
		}
		case "cdata":
		default: throw new mn$1(n, "HTML");
	}
}
var As$1 = {
	preprocess: Es,
	print: Pa$1,
	insertPragma: us$1,
	massageAstNode: dn,
	embed: ns,
	getVisitorKeys: as
};
var Ds$1 = [
	{
		linguistLanguageId: 146,
		name: "Angular",
		type: "markup",
		tmScope: "text.html.basic",
		aceMode: "html",
		codemirrorMode: "htmlmixed",
		codemirrorMimeType: "text/html",
		color: "#e34c26",
		aliases: ["xhtml"],
		extensions: [".component.html"],
		parsers: ["angular"],
		vscodeLanguageIds: ["html"],
		filenames: []
	},
	{
		linguistLanguageId: 146,
		name: "HTML",
		type: "markup",
		tmScope: "text.html.basic",
		aceMode: "html",
		codemirrorMode: "htmlmixed",
		codemirrorMimeType: "text/html",
		color: "#e34c26",
		aliases: ["xhtml"],
		extensions: [
			".html",
			".hta",
			".htm",
			".html.hl",
			".inc",
			".xht",
			".xhtml",
			".mjml"
		],
		parsers: ["html"],
		vscodeLanguageIds: ["html"]
	},
	{
		linguistLanguageId: 146,
		name: "Lightning Web Components",
		type: "markup",
		tmScope: "text.html.basic",
		aceMode: "html",
		codemirrorMode: "htmlmixed",
		codemirrorMimeType: "text/html",
		color: "#e34c26",
		aliases: ["xhtml"],
		extensions: [],
		parsers: ["lwc"],
		vscodeLanguageIds: ["html"],
		filenames: []
	},
	{
		linguistLanguageId: 391,
		name: "Vue",
		type: "markup",
		color: "#41b883",
		extensions: [".vue"],
		tmScope: "text.html.vue",
		aceMode: "html",
		parsers: ["vue"],
		vscodeLanguageIds: ["vue"]
	}
];
var wr = {
	bracketSpacing: {
		category: "Common",
		type: "boolean",
		default: !0,
		description: "Print spaces between brackets.",
		oppositeDescription: "Do not print spaces between brackets."
	},
	singleQuote: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Use single quotes instead of double quotes."
	},
	proseWrap: {
		category: "Common",
		type: "choice",
		default: "preserve",
		description: "How to wrap prose.",
		choices: [
			{
				value: "always",
				description: "Wrap prose if it exceeds the print width."
			},
			{
				value: "never",
				description: "Do not wrap prose."
			},
			{
				value: "preserve",
				description: "Wrap prose as-is."
			}
		]
	},
	bracketSameLine: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Put > of opening tags on the last line instead of on a new line."
	},
	singleAttributePerLine: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Enforce single attribute per line in HTML, Vue and JSX."
	}
};
var vs$1 = "HTML", ys = {
	bracketSameLine: wr.bracketSameLine,
	htmlWhitespaceSensitivity: {
		category: vs$1,
		type: "choice",
		default: "css",
		description: "How to handle whitespaces in HTML.",
		choices: [
			{
				value: "css",
				description: "Respect the default value of CSS display property."
			},
			{
				value: "strict",
				description: "Whitespaces are considered sensitive."
			},
			{
				value: "ignore",
				description: "Whitespaces are considered insensitive."
			}
		]
	},
	singleAttributePerLine: wr.singleAttributePerLine,
	vueIndentScriptAndStyle: {
		category: vs$1,
		type: "boolean",
		default: !1,
		description: "Indent script and style tags in Vue files."
	}
};
var Gr$1 = {};
Jr$1(Gr$1, {
	angular: () => Po,
	html: () => No,
	lwc: () => Ro,
	vue: () => Io
});
var ws$1;
(function(t) {
	t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(ws$1 || (ws$1 = {}));
var bs;
(function(t) {
	t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(bs || (bs = {}));
var Ts;
(function(t) {
	t[t.None = 0] = "None", t[t.SignalBased = 1] = "SignalBased", t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
})(Ts || (Ts = {}));
var br = { name: "custom-elements" }, Tr = { name: "no-errors-schema" };
var J$1;
(function(t) {
	t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(J$1 || (J$1 = {}));
var xs;
(function(t) {
	t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(xs || (xs = {}));
var I;
(function(t) {
	t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(I || (I = {}));
function ut(t, e = !0) {
	if (t[0] != ":") return [null, t];
	let r = t.indexOf(":", 1);
	if (r === -1) {
		if (e) throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
		return [null, t];
	}
	return [t.slice(1, r), t.slice(r + 1)];
}
function xr(t) {
	return ut(t)[1] === "ng-container";
}
function kr(t) {
	return ut(t)[1] === "ng-content";
}
function We$1(t) {
	return t === null ? null : ut(t)[0];
}
function ze$1(t, e) {
	return t ? `:${t}:${e}` : e;
}
var qt$1;
function Br$1() {
	return qt$1 || (qt$1 = {}, Mt$1(J$1.HTML, [
		"iframe|srcdoc",
		"*|innerHTML",
		"*|outerHTML"
	]), Mt$1(J$1.STYLE, ["*|style"]), Mt$1(J$1.URL, [
		"*|formAction",
		"area|href",
		"area|ping",
		"audio|src",
		"a|href",
		"a|ping",
		"blockquote|cite",
		"body|background",
		"del|cite",
		"form|action",
		"img|src",
		"input|src",
		"ins|cite",
		"q|cite",
		"source|src",
		"track|src",
		"video|poster",
		"video|src"
	]), Mt$1(J$1.RESOURCE_URL, [
		"applet|code",
		"applet|codebase",
		"base|href",
		"embed|src",
		"frame|src",
		"head|profile",
		"html|manifest",
		"iframe|src",
		"link|href",
		"media|src",
		"object|codebase",
		"object|data",
		"script|src"
	])), qt$1;
}
function Mt$1(t, e) {
	for (let r of e) qt$1[r.toLowerCase()] = t;
}
var Ht$1 = class {};
var $a$1 = "boolean", Oa$1 = "number", Ma$1 = "string", qa = "object", Ha = [
	"[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored",
	"[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy",
	"abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy",
	"media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume",
	":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex",
	":svg:graphics^:svg:|",
	":svg:animation^:svg:|*begin,*end,*repeat",
	":svg:geometry^:svg:|",
	":svg:componentTransferFunction^:svg:|",
	":svg:gradient^:svg:|",
	":svg:textContent^:svg:graphics|",
	":svg:textPositioning^:svg:textContent|",
	"a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username",
	"area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username",
	"audio^media|",
	"br^[HTMLElement]|clear",
	"base^[HTMLElement]|href,target",
	"body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink",
	"button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value",
	"canvas^[HTMLElement]|#height,#width",
	"content^[HTMLElement]|select",
	"dl^[HTMLElement]|!compact",
	"data^[HTMLElement]|value",
	"datalist^[HTMLElement]|",
	"details^[HTMLElement]|!open",
	"dialog^[HTMLElement]|!open,returnValue",
	"dir^[HTMLElement]|!compact",
	"div^[HTMLElement]|align",
	"embed^[HTMLElement]|align,height,name,src,type,width",
	"fieldset^[HTMLElement]|!disabled,name",
	"font^[HTMLElement]|color,face,size",
	"form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target",
	"frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src",
	"frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows",
	"hr^[HTMLElement]|align,color,!noShade,size,width",
	"head^[HTMLElement]|",
	"h1,h2,h3,h4,h5,h6^[HTMLElement]|align",
	"html^[HTMLElement]|version",
	"iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width",
	"img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width",
	"input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width",
	"li^[HTMLElement]|type,#value",
	"label^[HTMLElement]|htmlFor",
	"legend^[HTMLElement]|align",
	"link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type",
	"map^[HTMLElement]|name",
	"marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width",
	"menu^[HTMLElement]|!compact",
	"meta^[HTMLElement]|content,httpEquiv,media,name,scheme",
	"meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value",
	"ins,del^[HTMLElement]|cite,dateTime",
	"ol^[HTMLElement]|!compact,!reversed,#start,type",
	"object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width",
	"optgroup^[HTMLElement]|!disabled,label",
	"option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value",
	"output^[HTMLElement]|defaultValue,%htmlFor,name,value",
	"p^[HTMLElement]|align",
	"param^[HTMLElement]|name,type,value,valueType",
	"picture^[HTMLElement]|",
	"pre^[HTMLElement]|#width",
	"progress^[HTMLElement]|#max,#value",
	"q,blockquote,cite^[HTMLElement]|",
	"script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type",
	"select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value",
	"slot^[HTMLElement]|name",
	"source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width",
	"span^[HTMLElement]|",
	"style^[HTMLElement]|!disabled,media,type",
	"caption^[HTMLElement]|align",
	"th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width",
	"col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width",
	"table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width",
	"tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign",
	"tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign",
	"template^[HTMLElement]|",
	"textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap",
	"time^[HTMLElement]|dateTime",
	"title^[HTMLElement]|text",
	"track^[HTMLElement]|!default,kind,label,src,srclang",
	"ul^[HTMLElement]|!compact,type",
	"unknown^[HTMLElement]|",
	"video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width",
	":svg:a^:svg:graphics|",
	":svg:animate^:svg:animation|",
	":svg:animateMotion^:svg:animation|",
	":svg:animateTransform^:svg:animation|",
	":svg:circle^:svg:geometry|",
	":svg:clipPath^:svg:graphics|",
	":svg:defs^:svg:graphics|",
	":svg:desc^:svg:|",
	":svg:discard^:svg:|",
	":svg:ellipse^:svg:geometry|",
	":svg:feBlend^:svg:|",
	":svg:feColorMatrix^:svg:|",
	":svg:feComponentTransfer^:svg:|",
	":svg:feComposite^:svg:|",
	":svg:feConvolveMatrix^:svg:|",
	":svg:feDiffuseLighting^:svg:|",
	":svg:feDisplacementMap^:svg:|",
	":svg:feDistantLight^:svg:|",
	":svg:feDropShadow^:svg:|",
	":svg:feFlood^:svg:|",
	":svg:feFuncA^:svg:componentTransferFunction|",
	":svg:feFuncB^:svg:componentTransferFunction|",
	":svg:feFuncG^:svg:componentTransferFunction|",
	":svg:feFuncR^:svg:componentTransferFunction|",
	":svg:feGaussianBlur^:svg:|",
	":svg:feImage^:svg:|",
	":svg:feMerge^:svg:|",
	":svg:feMergeNode^:svg:|",
	":svg:feMorphology^:svg:|",
	":svg:feOffset^:svg:|",
	":svg:fePointLight^:svg:|",
	":svg:feSpecularLighting^:svg:|",
	":svg:feSpotLight^:svg:|",
	":svg:feTile^:svg:|",
	":svg:feTurbulence^:svg:|",
	":svg:filter^:svg:|",
	":svg:foreignObject^:svg:graphics|",
	":svg:g^:svg:graphics|",
	":svg:image^:svg:graphics|decoding",
	":svg:line^:svg:geometry|",
	":svg:linearGradient^:svg:gradient|",
	":svg:mpath^:svg:|",
	":svg:marker^:svg:|",
	":svg:mask^:svg:|",
	":svg:metadata^:svg:|",
	":svg:path^:svg:geometry|",
	":svg:pattern^:svg:|",
	":svg:polygon^:svg:geometry|",
	":svg:polyline^:svg:geometry|",
	":svg:radialGradient^:svg:gradient|",
	":svg:rect^:svg:geometry|",
	":svg:svg^:svg:graphics|#currentScale,#zoomAndPan",
	":svg:script^:svg:|type",
	":svg:set^:svg:animation|",
	":svg:stop^:svg:|",
	":svg:style^:svg:|!disabled,media,title,type",
	":svg:switch^:svg:graphics|",
	":svg:symbol^:svg:|",
	":svg:tspan^:svg:textPositioning|",
	":svg:text^:svg:textPositioning|",
	":svg:textPath^:svg:textContent|",
	":svg:title^:svg:|",
	":svg:use^:svg:graphics|",
	":svg:view^:svg:|#zoomAndPan",
	"data^[HTMLElement]|value",
	"keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name",
	"menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default",
	"summary^[HTMLElement]|",
	"time^[HTMLElement]|dateTime",
	":svg:cursor^:svg:|",
	":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex",
	":math:math^:math:|",
	":math:maction^:math:|",
	":math:menclose^:math:|",
	":math:merror^:math:|",
	":math:mfenced^:math:|",
	":math:mfrac^:math:|",
	":math:mi^:math:|",
	":math:mmultiscripts^:math:|",
	":math:mn^:math:|",
	":math:mo^:math:|",
	":math:mover^:math:|",
	":math:mpadded^:math:|",
	":math:mphantom^:math:|",
	":math:mroot^:math:|",
	":math:mrow^:math:|",
	":math:ms^:math:|",
	":math:mspace^:math:|",
	":math:msqrt^:math:|",
	":math:mstyle^:math:|",
	":math:msub^:math:|",
	":math:msubsup^:math:|",
	":math:msup^:math:|",
	":math:mtable^:math:|",
	":math:mtd^:math:|",
	":math:mtext^:math:|",
	":math:mtr^:math:|",
	":math:munder^:math:|",
	":math:munderover^:math:|",
	":math:semantics^:math:|"
], ks = new Map(Object.entries({
	class: "className",
	for: "htmlFor",
	formaction: "formAction",
	innerHtml: "innerHTML",
	readonly: "readOnly",
	tabindex: "tabIndex"
})), Va = Array.from(ks).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), Vt$1 = class extends Ht$1 {
	constructor() {
		super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), Ha.forEach((e) => {
			let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), [s, i] = e.split("|"), a = i.split(","), [o, u] = s.split("^");
			o.split(",").forEach((l) => {
				this._schema.set(l.toLowerCase(), r), this._eventSchema.set(l.toLowerCase(), n);
			});
			let p = u && this._schema.get(u.toLowerCase());
			if (p) {
				for (let [l, f] of p) r.set(l, f);
				for (let l of this._eventSchema.get(u.toLowerCase())) n.add(l);
			}
			a.forEach((l) => {
				if (l.length > 0) switch (l[0]) {
					case "*":
						n.add(l.substring(1));
						break;
					case "!":
						r.set(l.substring(1), $a$1);
						break;
					case "#":
						r.set(l.substring(1), Oa$1);
						break;
					case "%":
						r.set(l.substring(1), qa);
						break;
					default: r.set(l, Ma$1);
				}
			});
		});
	}
	hasProperty(e, r, n) {
		if (n.some((i) => i.name === Tr.name)) return !0;
		if (e.indexOf("-") > -1) {
			if (xr(e) || kr(e)) return !1;
			if (n.some((i) => i.name === br.name)) return !0;
		}
		return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
	}
	hasElement(e, r) {
		return r.some((n) => n.name === Tr.name) || e.indexOf("-") > -1 && (xr(e) || kr(e) || r.some((n) => n.name === br.name)) ? !0 : this._schema.has(e.toLowerCase());
	}
	securityContext(e, r, n) {
		n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
		let s = Br$1()[e + "|" + r];
		return s || (s = Br$1()["*|" + r], s || J$1.NONE);
	}
	getMappedPropName(e) {
		return ks.get(e) ?? e;
	}
	getDefaultComponentElementName() {
		return "ng-component";
	}
	validateProperty(e) {
		return e.toLowerCase().startsWith("on") ? {
			error: !0,
			msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.`
		} : { error: !1 };
	}
	validateAttribute(e) {
		return e.toLowerCase().startsWith("on") ? {
			error: !0,
			msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...`
		} : { error: !1 };
	}
	allKnownElementNames() {
		return Array.from(this._schema.keys());
	}
	allKnownAttributesOfElement(e) {
		let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
		return Array.from(r.keys()).map((n) => Va.get(n) ?? n);
	}
	allKnownEventsOfElement(e) {
		return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
	}
	normalizeAnimationStyleProperty(e) {
		return _s$1(e);
	}
	normalizeAnimationStyleValue(e, r, n) {
		let s = "", i = n.toString().trim(), a = null;
		if (Ua$1(e) && n !== 0 && n !== "0") if (typeof n == "number") s = "px";
		else {
			let o = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
			o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${n}`);
		}
		return {
			error: a,
			value: i + s
		};
	}
};
function Ua$1(t) {
	switch (t) {
		case "width":
		case "height":
		case "minWidth":
		case "minHeight":
		case "maxWidth":
		case "maxHeight":
		case "left":
		case "top":
		case "bottom":
		case "right":
		case "fontSize":
		case "outlineWidth":
		case "outlineOffset":
		case "paddingTop":
		case "paddingLeft":
		case "paddingBottom":
		case "paddingRight":
		case "marginTop":
		case "marginLeft":
		case "marginBottom":
		case "marginRight":
		case "borderRadius":
		case "borderWidth":
		case "borderTopWidth":
		case "borderLeftWidth":
		case "borderRightWidth":
		case "borderBottomWidth":
		case "textIndent": return !0;
		default: return !1;
	}
}
var m = class {
	constructor({ closedByChildren: e, implicitNamespacePrefix: r, contentType: n = I.PARSABLE_DATA, closedByParent: s = !1, isVoid: i = !1, ignoreFirstLf: a = !1, preventNamespaceInheritance: o = !1, canSelfClose: u = !1 } = {}) {
		this.closedByChildren = {}, this.closedByParent = !1, e && e.length > 0 && e.forEach((p) => this.closedByChildren[p] = !0), this.isVoid = i, this.closedByParent = s || i, this.implicitNamespacePrefix = r || null, this.contentType = n, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o, this.canSelfClose = u ?? i;
	}
	isClosedByChild(e) {
		return this.isVoid || e.toLowerCase() in this.closedByChildren;
	}
	getContentType(e) {
		return typeof this.contentType == "object" ? (e === void 0 ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType;
	}
}, Bs, lt$1;
function Ge$1(t) {
	return lt$1 || (Bs = new m({ canSelfClose: !0 }), lt$1 = Object.assign(Object.create(null), {
		base: new m({ isVoid: !0 }),
		meta: new m({ isVoid: !0 }),
		area: new m({ isVoid: !0 }),
		embed: new m({ isVoid: !0 }),
		link: new m({ isVoid: !0 }),
		img: new m({ isVoid: !0 }),
		input: new m({ isVoid: !0 }),
		param: new m({ isVoid: !0 }),
		hr: new m({ isVoid: !0 }),
		br: new m({ isVoid: !0 }),
		source: new m({ isVoid: !0 }),
		track: new m({ isVoid: !0 }),
		wbr: new m({ isVoid: !0 }),
		p: new m({
			closedByChildren: [
				"address",
				"article",
				"aside",
				"blockquote",
				"div",
				"dl",
				"fieldset",
				"footer",
				"form",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"header",
				"hgroup",
				"hr",
				"main",
				"nav",
				"ol",
				"p",
				"pre",
				"section",
				"table",
				"ul"
			],
			closedByParent: !0
		}),
		thead: new m({ closedByChildren: ["tbody", "tfoot"] }),
		tbody: new m({
			closedByChildren: ["tbody", "tfoot"],
			closedByParent: !0
		}),
		tfoot: new m({
			closedByChildren: ["tbody"],
			closedByParent: !0
		}),
		tr: new m({
			closedByChildren: ["tr"],
			closedByParent: !0
		}),
		td: new m({
			closedByChildren: ["td", "th"],
			closedByParent: !0
		}),
		th: new m({
			closedByChildren: ["td", "th"],
			closedByParent: !0
		}),
		col: new m({ isVoid: !0 }),
		svg: new m({ implicitNamespacePrefix: "svg" }),
		foreignObject: new m({
			implicitNamespacePrefix: "svg",
			preventNamespaceInheritance: !0
		}),
		math: new m({ implicitNamespacePrefix: "math" }),
		li: new m({
			closedByChildren: ["li"],
			closedByParent: !0
		}),
		dt: new m({ closedByChildren: ["dt", "dd"] }),
		dd: new m({
			closedByChildren: ["dt", "dd"],
			closedByParent: !0
		}),
		rb: new m({
			closedByChildren: [
				"rb",
				"rt",
				"rtc",
				"rp"
			],
			closedByParent: !0
		}),
		rt: new m({
			closedByChildren: [
				"rb",
				"rt",
				"rtc",
				"rp"
			],
			closedByParent: !0
		}),
		rtc: new m({
			closedByChildren: [
				"rb",
				"rtc",
				"rp"
			],
			closedByParent: !0
		}),
		rp: new m({
			closedByChildren: [
				"rb",
				"rt",
				"rtc",
				"rp"
			],
			closedByParent: !0
		}),
		optgroup: new m({
			closedByChildren: ["optgroup"],
			closedByParent: !0
		}),
		option: new m({
			closedByChildren: ["option", "optgroup"],
			closedByParent: !0
		}),
		pre: new m({ ignoreFirstLf: !0 }),
		listing: new m({ ignoreFirstLf: !0 }),
		style: new m({ contentType: I.RAW_TEXT }),
		script: new m({ contentType: I.RAW_TEXT }),
		title: new m({ contentType: {
			default: I.ESCAPABLE_RAW_TEXT,
			svg: I.PARSABLE_DATA
		} }),
		textarea: new m({
			contentType: I.ESCAPABLE_RAW_TEXT,
			ignoreFirstLf: !0
		})
	}), new Vt$1().allKnownElementNames().forEach((e) => {
		!lt$1[e] && We$1(e) === null && (lt$1[e] = new m({ canSelfClose: !1 }));
	})), lt$1[t] ?? Bs;
}
var oe$1 = class {
	constructor(e, r) {
		this.sourceSpan = e, this.i18n = r;
	}
}, Ut$1 = class extends oe$1 {
	constructor(e, r, n, s) {
		super(r, s), this.value = e, this.tokens = n, this.type = "text";
	}
	visit(e, r) {
		return e.visitText(this, r);
	}
}, Wt = class extends oe$1 {
	constructor(e, r, n, s) {
		super(r, s), this.value = e, this.tokens = n, this.type = "cdata";
	}
	visit(e, r) {
		return e.visitCdata(this, r);
	}
}, zt = class extends oe$1 {
	constructor(e, r, n, s, i, a) {
		super(s, a), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = i;
	}
	visit(e, r) {
		return e.visitExpansion(this, r);
	}
}, Gt$1 = class {
	constructor(e, r, n, s, i) {
		this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = s, this.expSourceSpan = i, this.type = "expansionCase";
	}
	visit(e, r) {
		return e.visitExpansionCase(this, r);
	}
}, Yt = class extends oe$1 {
	constructor(e, r, n, s, i, a, o) {
		super(n, o), this.name = e, this.value = r, this.keySpan = s, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
	}
	visit(e, r) {
		return e.visitAttribute(this, r);
	}
	get nameSpan() {
		return this.keySpan;
	}
}, G$1 = class extends oe$1 {
	constructor(e, r, n, s, i, a = null, o = null, u) {
		super(s, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
	}
	visit(e, r) {
		return e.visitElement(this, r);
	}
}, jt$1 = class {
	constructor(e, r) {
		this.value = e, this.sourceSpan = r, this.type = "comment";
	}
	visit(e, r) {
		return e.visitComment(this, r);
	}
}, Kt = class {
	constructor(e, r) {
		this.value = e, this.sourceSpan = r, this.type = "docType";
	}
	visit(e, r) {
		return e.visitDocType(this, r);
	}
}, Z$1 = class extends oe$1 {
	constructor(e, r, n, s, i, a, o = null, u) {
		super(s, u), this.name = e, this.parameters = r, this.children = n, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o, this.type = "block";
	}
	visit(e, r) {
		return e.visitBlock(this, r);
	}
}, ct = class {
	constructor(e, r) {
		this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
	}
	visit(e, r) {
		return e.visitBlockParameter(this, r);
	}
}, pt$1 = class {
	constructor(e, r, n, s, i) {
		this.name = e, this.value = r, this.sourceSpan = n, this.nameSpan = s, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
	}
	visit(e, r) {
		return e.visitLetDeclaration(this, r);
	}
};
function Qt(t, e, r = null) {
	let n = [], s = t.visit ? (i) => t.visit(i, r) || i.visit(t, r) : (i) => i.visit(t, r);
	return e.forEach((i) => {
		let a = s(i);
		a && n.push(a);
	}), n;
}
var ht = class {
	constructor() {}
	visitElement(e, r) {
		this.visitChildren(r, (n) => {
			n(e.attrs), n(e.children);
		});
	}
	visitAttribute(e, r) {}
	visitText(e, r) {}
	visitCdata(e, r) {}
	visitComment(e, r) {}
	visitDocType(e, r) {}
	visitExpansion(e, r) {
		return this.visitChildren(r, (n) => {
			n(e.cases);
		});
	}
	visitExpansionCase(e, r) {}
	visitBlock(e, r) {
		this.visitChildren(r, (n) => {
			n(e.parameters), n(e.children);
		});
	}
	visitBlockParameter(e, r) {}
	visitLetDeclaration(e, r) {}
	visitChildren(e, r) {
		let n = [], s = this;
		function i(a) {
			a && n.push(Qt(s, a, e));
		}
		return r(i), Array.prototype.concat.apply([], n);
	}
};
var Ye$1 = {
	AElig: "Æ",
	AMP: "&",
	amp: "&",
	Aacute: "Á",
	Abreve: "Ă",
	Acirc: "Â",
	Acy: "А",
	Afr: "𝔄",
	Agrave: "À",
	Alpha: "Α",
	Amacr: "Ā",
	And: "⩓",
	Aogon: "Ą",
	Aopf: "𝔸",
	ApplyFunction: "⁡",
	af: "⁡",
	Aring: "Å",
	angst: "Å",
	Ascr: "𝒜",
	Assign: "≔",
	colone: "≔",
	coloneq: "≔",
	Atilde: "Ã",
	Auml: "Ä",
	Backslash: "∖",
	setminus: "∖",
	setmn: "∖",
	smallsetminus: "∖",
	ssetmn: "∖",
	Barv: "⫧",
	Barwed: "⌆",
	doublebarwedge: "⌆",
	Bcy: "Б",
	Because: "∵",
	becaus: "∵",
	because: "∵",
	Bernoullis: "ℬ",
	Bscr: "ℬ",
	bernou: "ℬ",
	Beta: "Β",
	Bfr: "𝔅",
	Bopf: "𝔹",
	Breve: "˘",
	breve: "˘",
	Bumpeq: "≎",
	HumpDownHump: "≎",
	bump: "≎",
	CHcy: "Ч",
	COPY: "©",
	copy: "©",
	Cacute: "Ć",
	Cap: "⋒",
	CapitalDifferentialD: "ⅅ",
	DD: "ⅅ",
	Cayleys: "ℭ",
	Cfr: "ℭ",
	Ccaron: "Č",
	Ccedil: "Ç",
	Ccirc: "Ĉ",
	Cconint: "∰",
	Cdot: "Ċ",
	Cedilla: "¸",
	cedil: "¸",
	CenterDot: "·",
	centerdot: "·",
	middot: "·",
	Chi: "Χ",
	CircleDot: "⊙",
	odot: "⊙",
	CircleMinus: "⊖",
	ominus: "⊖",
	CirclePlus: "⊕",
	oplus: "⊕",
	CircleTimes: "⊗",
	otimes: "⊗",
	ClockwiseContourIntegral: "∲",
	cwconint: "∲",
	CloseCurlyDoubleQuote: "”",
	rdquo: "”",
	rdquor: "”",
	CloseCurlyQuote: "’",
	rsquo: "’",
	rsquor: "’",
	Colon: "∷",
	Proportion: "∷",
	Colone: "⩴",
	Congruent: "≡",
	equiv: "≡",
	Conint: "∯",
	DoubleContourIntegral: "∯",
	ContourIntegral: "∮",
	conint: "∮",
	oint: "∮",
	Copf: "ℂ",
	complexes: "ℂ",
	Coproduct: "∐",
	coprod: "∐",
	CounterClockwiseContourIntegral: "∳",
	awconint: "∳",
	Cross: "⨯",
	Cscr: "𝒞",
	Cup: "⋓",
	CupCap: "≍",
	asympeq: "≍",
	DDotrahd: "⤑",
	DJcy: "Ђ",
	DScy: "Ѕ",
	DZcy: "Џ",
	Dagger: "‡",
	ddagger: "‡",
	Darr: "↡",
	Dashv: "⫤",
	DoubleLeftTee: "⫤",
	Dcaron: "Ď",
	Dcy: "Д",
	Del: "∇",
	nabla: "∇",
	Delta: "Δ",
	Dfr: "𝔇",
	DiacriticalAcute: "´",
	acute: "´",
	DiacriticalDot: "˙",
	dot: "˙",
	DiacriticalDoubleAcute: "˝",
	dblac: "˝",
	DiacriticalGrave: "`",
	grave: "`",
	DiacriticalTilde: "˜",
	tilde: "˜",
	Diamond: "⋄",
	diam: "⋄",
	diamond: "⋄",
	DifferentialD: "ⅆ",
	dd: "ⅆ",
	Dopf: "𝔻",
	Dot: "¨",
	DoubleDot: "¨",
	die: "¨",
	uml: "¨",
	DotDot: "⃜",
	DotEqual: "≐",
	doteq: "≐",
	esdot: "≐",
	DoubleDownArrow: "⇓",
	Downarrow: "⇓",
	dArr: "⇓",
	DoubleLeftArrow: "⇐",
	Leftarrow: "⇐",
	lArr: "⇐",
	DoubleLeftRightArrow: "⇔",
	Leftrightarrow: "⇔",
	hArr: "⇔",
	iff: "⇔",
	DoubleLongLeftArrow: "⟸",
	Longleftarrow: "⟸",
	xlArr: "⟸",
	DoubleLongLeftRightArrow: "⟺",
	Longleftrightarrow: "⟺",
	xhArr: "⟺",
	DoubleLongRightArrow: "⟹",
	Longrightarrow: "⟹",
	xrArr: "⟹",
	DoubleRightArrow: "⇒",
	Implies: "⇒",
	Rightarrow: "⇒",
	rArr: "⇒",
	DoubleRightTee: "⊨",
	vDash: "⊨",
	DoubleUpArrow: "⇑",
	Uparrow: "⇑",
	uArr: "⇑",
	DoubleUpDownArrow: "⇕",
	Updownarrow: "⇕",
	vArr: "⇕",
	DoubleVerticalBar: "∥",
	par: "∥",
	parallel: "∥",
	shortparallel: "∥",
	spar: "∥",
	DownArrow: "↓",
	ShortDownArrow: "↓",
	darr: "↓",
	downarrow: "↓",
	DownArrowBar: "⤓",
	DownArrowUpArrow: "⇵",
	duarr: "⇵",
	DownBreve: "̑",
	DownLeftRightVector: "⥐",
	DownLeftTeeVector: "⥞",
	DownLeftVector: "↽",
	leftharpoondown: "↽",
	lhard: "↽",
	DownLeftVectorBar: "⥖",
	DownRightTeeVector: "⥟",
	DownRightVector: "⇁",
	rhard: "⇁",
	rightharpoondown: "⇁",
	DownRightVectorBar: "⥗",
	DownTee: "⊤",
	top: "⊤",
	DownTeeArrow: "↧",
	mapstodown: "↧",
	Dscr: "𝒟",
	Dstrok: "Đ",
	ENG: "Ŋ",
	ETH: "Ð",
	Eacute: "É",
	Ecaron: "Ě",
	Ecirc: "Ê",
	Ecy: "Э",
	Edot: "Ė",
	Efr: "𝔈",
	Egrave: "È",
	Element: "∈",
	in: "∈",
	isin: "∈",
	isinv: "∈",
	Emacr: "Ē",
	EmptySmallSquare: "◻",
	EmptyVerySmallSquare: "▫",
	Eogon: "Ę",
	Eopf: "𝔼",
	Epsilon: "Ε",
	Equal: "⩵",
	EqualTilde: "≂",
	eqsim: "≂",
	esim: "≂",
	Equilibrium: "⇌",
	rightleftharpoons: "⇌",
	rlhar: "⇌",
	Escr: "ℰ",
	expectation: "ℰ",
	Esim: "⩳",
	Eta: "Η",
	Euml: "Ë",
	Exists: "∃",
	exist: "∃",
	ExponentialE: "ⅇ",
	ee: "ⅇ",
	exponentiale: "ⅇ",
	Fcy: "Ф",
	Ffr: "𝔉",
	FilledSmallSquare: "◼",
	FilledVerySmallSquare: "▪",
	blacksquare: "▪",
	squarf: "▪",
	squf: "▪",
	Fopf: "𝔽",
	ForAll: "∀",
	forall: "∀",
	Fouriertrf: "ℱ",
	Fscr: "ℱ",
	GJcy: "Ѓ",
	GT: ">",
	gt: ">",
	Gamma: "Γ",
	Gammad: "Ϝ",
	Gbreve: "Ğ",
	Gcedil: "Ģ",
	Gcirc: "Ĝ",
	Gcy: "Г",
	Gdot: "Ġ",
	Gfr: "𝔊",
	Gg: "⋙",
	ggg: "⋙",
	Gopf: "𝔾",
	GreaterEqual: "≥",
	ge: "≥",
	geq: "≥",
	GreaterEqualLess: "⋛",
	gel: "⋛",
	gtreqless: "⋛",
	GreaterFullEqual: "≧",
	gE: "≧",
	geqq: "≧",
	GreaterGreater: "⪢",
	GreaterLess: "≷",
	gl: "≷",
	gtrless: "≷",
	GreaterSlantEqual: "⩾",
	geqslant: "⩾",
	ges: "⩾",
	GreaterTilde: "≳",
	gsim: "≳",
	gtrsim: "≳",
	Gscr: "𝒢",
	Gt: "≫",
	NestedGreaterGreater: "≫",
	gg: "≫",
	HARDcy: "Ъ",
	Hacek: "ˇ",
	caron: "ˇ",
	Hat: "^",
	Hcirc: "Ĥ",
	Hfr: "ℌ",
	Poincareplane: "ℌ",
	HilbertSpace: "ℋ",
	Hscr: "ℋ",
	hamilt: "ℋ",
	Hopf: "ℍ",
	quaternions: "ℍ",
	HorizontalLine: "─",
	boxh: "─",
	Hstrok: "Ħ",
	HumpEqual: "≏",
	bumpe: "≏",
	bumpeq: "≏",
	IEcy: "Е",
	IJlig: "Ĳ",
	IOcy: "Ё",
	Iacute: "Í",
	Icirc: "Î",
	Icy: "И",
	Idot: "İ",
	Ifr: "ℑ",
	Im: "ℑ",
	image: "ℑ",
	imagpart: "ℑ",
	Igrave: "Ì",
	Imacr: "Ī",
	ImaginaryI: "ⅈ",
	ii: "ⅈ",
	Int: "∬",
	Integral: "∫",
	int: "∫",
	Intersection: "⋂",
	bigcap: "⋂",
	xcap: "⋂",
	InvisibleComma: "⁣",
	ic: "⁣",
	InvisibleTimes: "⁢",
	it: "⁢",
	Iogon: "Į",
	Iopf: "𝕀",
	Iota: "Ι",
	Iscr: "ℐ",
	imagline: "ℐ",
	Itilde: "Ĩ",
	Iukcy: "І",
	Iuml: "Ï",
	Jcirc: "Ĵ",
	Jcy: "Й",
	Jfr: "𝔍",
	Jopf: "𝕁",
	Jscr: "𝒥",
	Jsercy: "Ј",
	Jukcy: "Є",
	KHcy: "Х",
	KJcy: "Ќ",
	Kappa: "Κ",
	Kcedil: "Ķ",
	Kcy: "К",
	Kfr: "𝔎",
	Kopf: "𝕂",
	Kscr: "𝒦",
	LJcy: "Љ",
	LT: "<",
	lt: "<",
	Lacute: "Ĺ",
	Lambda: "Λ",
	Lang: "⟪",
	Laplacetrf: "ℒ",
	Lscr: "ℒ",
	lagran: "ℒ",
	Larr: "↞",
	twoheadleftarrow: "↞",
	Lcaron: "Ľ",
	Lcedil: "Ļ",
	Lcy: "Л",
	LeftAngleBracket: "⟨",
	lang: "⟨",
	langle: "⟨",
	LeftArrow: "←",
	ShortLeftArrow: "←",
	larr: "←",
	leftarrow: "←",
	slarr: "←",
	LeftArrowBar: "⇤",
	larrb: "⇤",
	LeftArrowRightArrow: "⇆",
	leftrightarrows: "⇆",
	lrarr: "⇆",
	LeftCeiling: "⌈",
	lceil: "⌈",
	LeftDoubleBracket: "⟦",
	lobrk: "⟦",
	LeftDownTeeVector: "⥡",
	LeftDownVector: "⇃",
	dharl: "⇃",
	downharpoonleft: "⇃",
	LeftDownVectorBar: "⥙",
	LeftFloor: "⌊",
	lfloor: "⌊",
	LeftRightArrow: "↔",
	harr: "↔",
	leftrightarrow: "↔",
	LeftRightVector: "⥎",
	LeftTee: "⊣",
	dashv: "⊣",
	LeftTeeArrow: "↤",
	mapstoleft: "↤",
	LeftTeeVector: "⥚",
	LeftTriangle: "⊲",
	vartriangleleft: "⊲",
	vltri: "⊲",
	LeftTriangleBar: "⧏",
	LeftTriangleEqual: "⊴",
	ltrie: "⊴",
	trianglelefteq: "⊴",
	LeftUpDownVector: "⥑",
	LeftUpTeeVector: "⥠",
	LeftUpVector: "↿",
	uharl: "↿",
	upharpoonleft: "↿",
	LeftUpVectorBar: "⥘",
	LeftVector: "↼",
	leftharpoonup: "↼",
	lharu: "↼",
	LeftVectorBar: "⥒",
	LessEqualGreater: "⋚",
	leg: "⋚",
	lesseqgtr: "⋚",
	LessFullEqual: "≦",
	lE: "≦",
	leqq: "≦",
	LessGreater: "≶",
	lessgtr: "≶",
	lg: "≶",
	LessLess: "⪡",
	LessSlantEqual: "⩽",
	leqslant: "⩽",
	les: "⩽",
	LessTilde: "≲",
	lesssim: "≲",
	lsim: "≲",
	Lfr: "𝔏",
	Ll: "⋘",
	Lleftarrow: "⇚",
	lAarr: "⇚",
	Lmidot: "Ŀ",
	LongLeftArrow: "⟵",
	longleftarrow: "⟵",
	xlarr: "⟵",
	LongLeftRightArrow: "⟷",
	longleftrightarrow: "⟷",
	xharr: "⟷",
	LongRightArrow: "⟶",
	longrightarrow: "⟶",
	xrarr: "⟶",
	Lopf: "𝕃",
	LowerLeftArrow: "↙",
	swarr: "↙",
	swarrow: "↙",
	LowerRightArrow: "↘",
	searr: "↘",
	searrow: "↘",
	Lsh: "↰",
	lsh: "↰",
	Lstrok: "Ł",
	Lt: "≪",
	NestedLessLess: "≪",
	ll: "≪",
	Map: "⤅",
	Mcy: "М",
	MediumSpace: " ",
	Mellintrf: "ℳ",
	Mscr: "ℳ",
	phmmat: "ℳ",
	Mfr: "𝔐",
	MinusPlus: "∓",
	mnplus: "∓",
	mp: "∓",
	Mopf: "𝕄",
	Mu: "Μ",
	NJcy: "Њ",
	Nacute: "Ń",
	Ncaron: "Ň",
	Ncedil: "Ņ",
	Ncy: "Н",
	NegativeMediumSpace: "​",
	NegativeThickSpace: "​",
	NegativeThinSpace: "​",
	NegativeVeryThinSpace: "​",
	ZeroWidthSpace: "​",
	NewLine: `
`,
	Nfr: "𝔑",
	NoBreak: "⁠",
	NonBreakingSpace: "\xA0",
	nbsp: "\xA0",
	Nopf: "ℕ",
	naturals: "ℕ",
	Not: "⫬",
	NotCongruent: "≢",
	nequiv: "≢",
	NotCupCap: "≭",
	NotDoubleVerticalBar: "∦",
	npar: "∦",
	nparallel: "∦",
	nshortparallel: "∦",
	nspar: "∦",
	NotElement: "∉",
	notin: "∉",
	notinva: "∉",
	NotEqual: "≠",
	ne: "≠",
	NotEqualTilde: "≂̸",
	nesim: "≂̸",
	NotExists: "∄",
	nexist: "∄",
	nexists: "∄",
	NotGreater: "≯",
	ngt: "≯",
	ngtr: "≯",
	NotGreaterEqual: "≱",
	nge: "≱",
	ngeq: "≱",
	NotGreaterFullEqual: "≧̸",
	ngE: "≧̸",
	ngeqq: "≧̸",
	NotGreaterGreater: "≫̸",
	nGtv: "≫̸",
	NotGreaterLess: "≹",
	ntgl: "≹",
	NotGreaterSlantEqual: "⩾̸",
	ngeqslant: "⩾̸",
	nges: "⩾̸",
	NotGreaterTilde: "≵",
	ngsim: "≵",
	NotHumpDownHump: "≎̸",
	nbump: "≎̸",
	NotHumpEqual: "≏̸",
	nbumpe: "≏̸",
	NotLeftTriangle: "⋪",
	nltri: "⋪",
	ntriangleleft: "⋪",
	NotLeftTriangleBar: "⧏̸",
	NotLeftTriangleEqual: "⋬",
	nltrie: "⋬",
	ntrianglelefteq: "⋬",
	NotLess: "≮",
	nless: "≮",
	nlt: "≮",
	NotLessEqual: "≰",
	nle: "≰",
	nleq: "≰",
	NotLessGreater: "≸",
	ntlg: "≸",
	NotLessLess: "≪̸",
	nLtv: "≪̸",
	NotLessSlantEqual: "⩽̸",
	nleqslant: "⩽̸",
	nles: "⩽̸",
	NotLessTilde: "≴",
	nlsim: "≴",
	NotNestedGreaterGreater: "⪢̸",
	NotNestedLessLess: "⪡̸",
	NotPrecedes: "⊀",
	npr: "⊀",
	nprec: "⊀",
	NotPrecedesEqual: "⪯̸",
	npre: "⪯̸",
	npreceq: "⪯̸",
	NotPrecedesSlantEqual: "⋠",
	nprcue: "⋠",
	NotReverseElement: "∌",
	notni: "∌",
	notniva: "∌",
	NotRightTriangle: "⋫",
	nrtri: "⋫",
	ntriangleright: "⋫",
	NotRightTriangleBar: "⧐̸",
	NotRightTriangleEqual: "⋭",
	nrtrie: "⋭",
	ntrianglerighteq: "⋭",
	NotSquareSubset: "⊏̸",
	NotSquareSubsetEqual: "⋢",
	nsqsube: "⋢",
	NotSquareSuperset: "⊐̸",
	NotSquareSupersetEqual: "⋣",
	nsqsupe: "⋣",
	NotSubset: "⊂⃒",
	nsubset: "⊂⃒",
	vnsub: "⊂⃒",
	NotSubsetEqual: "⊈",
	nsube: "⊈",
	nsubseteq: "⊈",
	NotSucceeds: "⊁",
	nsc: "⊁",
	nsucc: "⊁",
	NotSucceedsEqual: "⪰̸",
	nsce: "⪰̸",
	nsucceq: "⪰̸",
	NotSucceedsSlantEqual: "⋡",
	nsccue: "⋡",
	NotSucceedsTilde: "≿̸",
	NotSuperset: "⊃⃒",
	nsupset: "⊃⃒",
	vnsup: "⊃⃒",
	NotSupersetEqual: "⊉",
	nsupe: "⊉",
	nsupseteq: "⊉",
	NotTilde: "≁",
	nsim: "≁",
	NotTildeEqual: "≄",
	nsime: "≄",
	nsimeq: "≄",
	NotTildeFullEqual: "≇",
	ncong: "≇",
	NotTildeTilde: "≉",
	nap: "≉",
	napprox: "≉",
	NotVerticalBar: "∤",
	nmid: "∤",
	nshortmid: "∤",
	nsmid: "∤",
	Nscr: "𝒩",
	Ntilde: "Ñ",
	Nu: "Ν",
	OElig: "Œ",
	Oacute: "Ó",
	Ocirc: "Ô",
	Ocy: "О",
	Odblac: "Ő",
	Ofr: "𝔒",
	Ograve: "Ò",
	Omacr: "Ō",
	Omega: "Ω",
	ohm: "Ω",
	Omicron: "Ο",
	Oopf: "𝕆",
	OpenCurlyDoubleQuote: "“",
	ldquo: "“",
	OpenCurlyQuote: "‘",
	lsquo: "‘",
	Or: "⩔",
	Oscr: "𝒪",
	Oslash: "Ø",
	Otilde: "Õ",
	Otimes: "⨷",
	Ouml: "Ö",
	OverBar: "‾",
	oline: "‾",
	OverBrace: "⏞",
	OverBracket: "⎴",
	tbrk: "⎴",
	OverParenthesis: "⏜",
	PartialD: "∂",
	part: "∂",
	Pcy: "П",
	Pfr: "𝔓",
	Phi: "Φ",
	Pi: "Π",
	PlusMinus: "±",
	plusmn: "±",
	pm: "±",
	Popf: "ℙ",
	primes: "ℙ",
	Pr: "⪻",
	Precedes: "≺",
	pr: "≺",
	prec: "≺",
	PrecedesEqual: "⪯",
	pre: "⪯",
	preceq: "⪯",
	PrecedesSlantEqual: "≼",
	prcue: "≼",
	preccurlyeq: "≼",
	PrecedesTilde: "≾",
	precsim: "≾",
	prsim: "≾",
	Prime: "″",
	Product: "∏",
	prod: "∏",
	Proportional: "∝",
	prop: "∝",
	propto: "∝",
	varpropto: "∝",
	vprop: "∝",
	Pscr: "𝒫",
	Psi: "Ψ",
	QUOT: "\"",
	quot: "\"",
	Qfr: "𝔔",
	Qopf: "ℚ",
	rationals: "ℚ",
	Qscr: "𝒬",
	RBarr: "⤐",
	drbkarow: "⤐",
	REG: "®",
	circledR: "®",
	reg: "®",
	Racute: "Ŕ",
	Rang: "⟫",
	Rarr: "↠",
	twoheadrightarrow: "↠",
	Rarrtl: "⤖",
	Rcaron: "Ř",
	Rcedil: "Ŗ",
	Rcy: "Р",
	Re: "ℜ",
	Rfr: "ℜ",
	real: "ℜ",
	realpart: "ℜ",
	ReverseElement: "∋",
	SuchThat: "∋",
	ni: "∋",
	niv: "∋",
	ReverseEquilibrium: "⇋",
	leftrightharpoons: "⇋",
	lrhar: "⇋",
	ReverseUpEquilibrium: "⥯",
	duhar: "⥯",
	Rho: "Ρ",
	RightAngleBracket: "⟩",
	rang: "⟩",
	rangle: "⟩",
	RightArrow: "→",
	ShortRightArrow: "→",
	rarr: "→",
	rightarrow: "→",
	srarr: "→",
	RightArrowBar: "⇥",
	rarrb: "⇥",
	RightArrowLeftArrow: "⇄",
	rightleftarrows: "⇄",
	rlarr: "⇄",
	RightCeiling: "⌉",
	rceil: "⌉",
	RightDoubleBracket: "⟧",
	robrk: "⟧",
	RightDownTeeVector: "⥝",
	RightDownVector: "⇂",
	dharr: "⇂",
	downharpoonright: "⇂",
	RightDownVectorBar: "⥕",
	RightFloor: "⌋",
	rfloor: "⌋",
	RightTee: "⊢",
	vdash: "⊢",
	RightTeeArrow: "↦",
	map: "↦",
	mapsto: "↦",
	RightTeeVector: "⥛",
	RightTriangle: "⊳",
	vartriangleright: "⊳",
	vrtri: "⊳",
	RightTriangleBar: "⧐",
	RightTriangleEqual: "⊵",
	rtrie: "⊵",
	trianglerighteq: "⊵",
	RightUpDownVector: "⥏",
	RightUpTeeVector: "⥜",
	RightUpVector: "↾",
	uharr: "↾",
	upharpoonright: "↾",
	RightUpVectorBar: "⥔",
	RightVector: "⇀",
	rharu: "⇀",
	rightharpoonup: "⇀",
	RightVectorBar: "⥓",
	Ropf: "ℝ",
	reals: "ℝ",
	RoundImplies: "⥰",
	Rrightarrow: "⇛",
	rAarr: "⇛",
	Rscr: "ℛ",
	realine: "ℛ",
	Rsh: "↱",
	rsh: "↱",
	RuleDelayed: "⧴",
	SHCHcy: "Щ",
	SHcy: "Ш",
	SOFTcy: "Ь",
	Sacute: "Ś",
	Sc: "⪼",
	Scaron: "Š",
	Scedil: "Ş",
	Scirc: "Ŝ",
	Scy: "С",
	Sfr: "𝔖",
	ShortUpArrow: "↑",
	UpArrow: "↑",
	uarr: "↑",
	uparrow: "↑",
	Sigma: "Σ",
	SmallCircle: "∘",
	compfn: "∘",
	Sopf: "𝕊",
	Sqrt: "√",
	radic: "√",
	Square: "□",
	squ: "□",
	square: "□",
	SquareIntersection: "⊓",
	sqcap: "⊓",
	SquareSubset: "⊏",
	sqsub: "⊏",
	sqsubset: "⊏",
	SquareSubsetEqual: "⊑",
	sqsube: "⊑",
	sqsubseteq: "⊑",
	SquareSuperset: "⊐",
	sqsup: "⊐",
	sqsupset: "⊐",
	SquareSupersetEqual: "⊒",
	sqsupe: "⊒",
	sqsupseteq: "⊒",
	SquareUnion: "⊔",
	sqcup: "⊔",
	Sscr: "𝒮",
	Star: "⋆",
	sstarf: "⋆",
	Sub: "⋐",
	Subset: "⋐",
	SubsetEqual: "⊆",
	sube: "⊆",
	subseteq: "⊆",
	Succeeds: "≻",
	sc: "≻",
	succ: "≻",
	SucceedsEqual: "⪰",
	sce: "⪰",
	succeq: "⪰",
	SucceedsSlantEqual: "≽",
	sccue: "≽",
	succcurlyeq: "≽",
	SucceedsTilde: "≿",
	scsim: "≿",
	succsim: "≿",
	Sum: "∑",
	sum: "∑",
	Sup: "⋑",
	Supset: "⋑",
	Superset: "⊃",
	sup: "⊃",
	supset: "⊃",
	SupersetEqual: "⊇",
	supe: "⊇",
	supseteq: "⊇",
	THORN: "Þ",
	TRADE: "™",
	trade: "™",
	TSHcy: "Ћ",
	TScy: "Ц",
	Tab: "	",
	Tau: "Τ",
	Tcaron: "Ť",
	Tcedil: "Ţ",
	Tcy: "Т",
	Tfr: "𝔗",
	Therefore: "∴",
	there4: "∴",
	therefore: "∴",
	Theta: "Θ",
	ThickSpace: "  ",
	ThinSpace: " ",
	thinsp: " ",
	Tilde: "∼",
	sim: "∼",
	thicksim: "∼",
	thksim: "∼",
	TildeEqual: "≃",
	sime: "≃",
	simeq: "≃",
	TildeFullEqual: "≅",
	cong: "≅",
	TildeTilde: "≈",
	ap: "≈",
	approx: "≈",
	asymp: "≈",
	thickapprox: "≈",
	thkap: "≈",
	Topf: "𝕋",
	TripleDot: "⃛",
	tdot: "⃛",
	Tscr: "𝒯",
	Tstrok: "Ŧ",
	Uacute: "Ú",
	Uarr: "↟",
	Uarrocir: "⥉",
	Ubrcy: "Ў",
	Ubreve: "Ŭ",
	Ucirc: "Û",
	Ucy: "У",
	Udblac: "Ű",
	Ufr: "𝔘",
	Ugrave: "Ù",
	Umacr: "Ū",
	UnderBar: "_",
	lowbar: "_",
	UnderBrace: "⏟",
	UnderBracket: "⎵",
	bbrk: "⎵",
	UnderParenthesis: "⏝",
	Union: "⋃",
	bigcup: "⋃",
	xcup: "⋃",
	UnionPlus: "⊎",
	uplus: "⊎",
	Uogon: "Ų",
	Uopf: "𝕌",
	UpArrowBar: "⤒",
	UpArrowDownArrow: "⇅",
	udarr: "⇅",
	UpDownArrow: "↕",
	updownarrow: "↕",
	varr: "↕",
	UpEquilibrium: "⥮",
	udhar: "⥮",
	UpTee: "⊥",
	bot: "⊥",
	bottom: "⊥",
	perp: "⊥",
	UpTeeArrow: "↥",
	mapstoup: "↥",
	UpperLeftArrow: "↖",
	nwarr: "↖",
	nwarrow: "↖",
	UpperRightArrow: "↗",
	nearr: "↗",
	nearrow: "↗",
	Upsi: "ϒ",
	upsih: "ϒ",
	Upsilon: "Υ",
	Uring: "Ů",
	Uscr: "𝒰",
	Utilde: "Ũ",
	Uuml: "Ü",
	VDash: "⊫",
	Vbar: "⫫",
	Vcy: "В",
	Vdash: "⊩",
	Vdashl: "⫦",
	Vee: "⋁",
	bigvee: "⋁",
	xvee: "⋁",
	Verbar: "‖",
	Vert: "‖",
	VerticalBar: "∣",
	mid: "∣",
	shortmid: "∣",
	smid: "∣",
	VerticalLine: "|",
	verbar: "|",
	vert: "|",
	VerticalSeparator: "❘",
	VerticalTilde: "≀",
	wr: "≀",
	wreath: "≀",
	VeryThinSpace: " ",
	hairsp: " ",
	Vfr: "𝔙",
	Vopf: "𝕍",
	Vscr: "𝒱",
	Vvdash: "⊪",
	Wcirc: "Ŵ",
	Wedge: "⋀",
	bigwedge: "⋀",
	xwedge: "⋀",
	Wfr: "𝔚",
	Wopf: "𝕎",
	Wscr: "𝒲",
	Xfr: "𝔛",
	Xi: "Ξ",
	Xopf: "𝕏",
	Xscr: "𝒳",
	YAcy: "Я",
	YIcy: "Ї",
	YUcy: "Ю",
	Yacute: "Ý",
	Ycirc: "Ŷ",
	Ycy: "Ы",
	Yfr: "𝔜",
	Yopf: "𝕐",
	Yscr: "𝒴",
	Yuml: "Ÿ",
	ZHcy: "Ж",
	Zacute: "Ź",
	Zcaron: "Ž",
	Zcy: "З",
	Zdot: "Ż",
	Zeta: "Ζ",
	Zfr: "ℨ",
	zeetrf: "ℨ",
	Zopf: "ℤ",
	integers: "ℤ",
	Zscr: "𝒵",
	aacute: "á",
	abreve: "ă",
	ac: "∾",
	mstpos: "∾",
	acE: "∾̳",
	acd: "∿",
	acirc: "â",
	acy: "а",
	aelig: "æ",
	afr: "𝔞",
	agrave: "à",
	alefsym: "ℵ",
	aleph: "ℵ",
	alpha: "α",
	amacr: "ā",
	amalg: "⨿",
	and: "∧",
	wedge: "∧",
	andand: "⩕",
	andd: "⩜",
	andslope: "⩘",
	andv: "⩚",
	ang: "∠",
	angle: "∠",
	ange: "⦤",
	angmsd: "∡",
	measuredangle: "∡",
	angmsdaa: "⦨",
	angmsdab: "⦩",
	angmsdac: "⦪",
	angmsdad: "⦫",
	angmsdae: "⦬",
	angmsdaf: "⦭",
	angmsdag: "⦮",
	angmsdah: "⦯",
	angrt: "∟",
	angrtvb: "⊾",
	angrtvbd: "⦝",
	angsph: "∢",
	angzarr: "⍼",
	aogon: "ą",
	aopf: "𝕒",
	apE: "⩰",
	apacir: "⩯",
	ape: "≊",
	approxeq: "≊",
	apid: "≋",
	apos: "'",
	aring: "å",
	ascr: "𝒶",
	ast: "*",
	midast: "*",
	atilde: "ã",
	auml: "ä",
	awint: "⨑",
	bNot: "⫭",
	backcong: "≌",
	bcong: "≌",
	backepsilon: "϶",
	bepsi: "϶",
	backprime: "‵",
	bprime: "‵",
	backsim: "∽",
	bsim: "∽",
	backsimeq: "⋍",
	bsime: "⋍",
	barvee: "⊽",
	barwed: "⌅",
	barwedge: "⌅",
	bbrktbrk: "⎶",
	bcy: "б",
	bdquo: "„",
	ldquor: "„",
	bemptyv: "⦰",
	beta: "β",
	beth: "ℶ",
	between: "≬",
	twixt: "≬",
	bfr: "𝔟",
	bigcirc: "◯",
	xcirc: "◯",
	bigodot: "⨀",
	xodot: "⨀",
	bigoplus: "⨁",
	xoplus: "⨁",
	bigotimes: "⨂",
	xotime: "⨂",
	bigsqcup: "⨆",
	xsqcup: "⨆",
	bigstar: "★",
	starf: "★",
	bigtriangledown: "▽",
	xdtri: "▽",
	bigtriangleup: "△",
	xutri: "△",
	biguplus: "⨄",
	xuplus: "⨄",
	bkarow: "⤍",
	rbarr: "⤍",
	blacklozenge: "⧫",
	lozf: "⧫",
	blacktriangle: "▴",
	utrif: "▴",
	blacktriangledown: "▾",
	dtrif: "▾",
	blacktriangleleft: "◂",
	ltrif: "◂",
	blacktriangleright: "▸",
	rtrif: "▸",
	blank: "␣",
	blk12: "▒",
	blk14: "░",
	blk34: "▓",
	block: "█",
	bne: "=⃥",
	bnequiv: "≡⃥",
	bnot: "⌐",
	bopf: "𝕓",
	bowtie: "⋈",
	boxDL: "╗",
	boxDR: "╔",
	boxDl: "╖",
	boxDr: "╓",
	boxH: "═",
	boxHD: "╦",
	boxHU: "╩",
	boxHd: "╤",
	boxHu: "╧",
	boxUL: "╝",
	boxUR: "╚",
	boxUl: "╜",
	boxUr: "╙",
	boxV: "║",
	boxVH: "╬",
	boxVL: "╣",
	boxVR: "╠",
	boxVh: "╫",
	boxVl: "╢",
	boxVr: "╟",
	boxbox: "⧉",
	boxdL: "╕",
	boxdR: "╒",
	boxdl: "┐",
	boxdr: "┌",
	boxhD: "╥",
	boxhU: "╨",
	boxhd: "┬",
	boxhu: "┴",
	boxminus: "⊟",
	minusb: "⊟",
	boxplus: "⊞",
	plusb: "⊞",
	boxtimes: "⊠",
	timesb: "⊠",
	boxuL: "╛",
	boxuR: "╘",
	boxul: "┘",
	boxur: "└",
	boxv: "│",
	boxvH: "╪",
	boxvL: "╡",
	boxvR: "╞",
	boxvh: "┼",
	boxvl: "┤",
	boxvr: "├",
	brvbar: "¦",
	bscr: "𝒷",
	bsemi: "⁏",
	bsol: "\\",
	bsolb: "⧅",
	bsolhsub: "⟈",
	bull: "•",
	bullet: "•",
	bumpE: "⪮",
	cacute: "ć",
	cap: "∩",
	capand: "⩄",
	capbrcup: "⩉",
	capcap: "⩋",
	capcup: "⩇",
	capdot: "⩀",
	caps: "∩︀",
	caret: "⁁",
	ccaps: "⩍",
	ccaron: "č",
	ccedil: "ç",
	ccirc: "ĉ",
	ccups: "⩌",
	ccupssm: "⩐",
	cdot: "ċ",
	cemptyv: "⦲",
	cent: "¢",
	cfr: "𝔠",
	chcy: "ч",
	check: "✓",
	checkmark: "✓",
	chi: "χ",
	cir: "○",
	cirE: "⧃",
	circ: "ˆ",
	circeq: "≗",
	cire: "≗",
	circlearrowleft: "↺",
	olarr: "↺",
	circlearrowright: "↻",
	orarr: "↻",
	circledS: "Ⓢ",
	oS: "Ⓢ",
	circledast: "⊛",
	oast: "⊛",
	circledcirc: "⊚",
	ocir: "⊚",
	circleddash: "⊝",
	odash: "⊝",
	cirfnint: "⨐",
	cirmid: "⫯",
	cirscir: "⧂",
	clubs: "♣",
	clubsuit: "♣",
	colon: ":",
	comma: ",",
	commat: "@",
	comp: "∁",
	complement: "∁",
	congdot: "⩭",
	copf: "𝕔",
	copysr: "℗",
	crarr: "↵",
	cross: "✗",
	cscr: "𝒸",
	csub: "⫏",
	csube: "⫑",
	csup: "⫐",
	csupe: "⫒",
	ctdot: "⋯",
	cudarrl: "⤸",
	cudarrr: "⤵",
	cuepr: "⋞",
	curlyeqprec: "⋞",
	cuesc: "⋟",
	curlyeqsucc: "⋟",
	cularr: "↶",
	curvearrowleft: "↶",
	cularrp: "⤽",
	cup: "∪",
	cupbrcap: "⩈",
	cupcap: "⩆",
	cupcup: "⩊",
	cupdot: "⊍",
	cupor: "⩅",
	cups: "∪︀",
	curarr: "↷",
	curvearrowright: "↷",
	curarrm: "⤼",
	curlyvee: "⋎",
	cuvee: "⋎",
	curlywedge: "⋏",
	cuwed: "⋏",
	curren: "¤",
	cwint: "∱",
	cylcty: "⌭",
	dHar: "⥥",
	dagger: "†",
	daleth: "ℸ",
	dash: "‐",
	hyphen: "‐",
	dbkarow: "⤏",
	rBarr: "⤏",
	dcaron: "ď",
	dcy: "д",
	ddarr: "⇊",
	downdownarrows: "⇊",
	ddotseq: "⩷",
	eDDot: "⩷",
	deg: "°",
	delta: "δ",
	demptyv: "⦱",
	dfisht: "⥿",
	dfr: "𝔡",
	diamondsuit: "♦",
	diams: "♦",
	digamma: "ϝ",
	gammad: "ϝ",
	disin: "⋲",
	div: "÷",
	divide: "÷",
	divideontimes: "⋇",
	divonx: "⋇",
	djcy: "ђ",
	dlcorn: "⌞",
	llcorner: "⌞",
	dlcrop: "⌍",
	dollar: "$",
	dopf: "𝕕",
	doteqdot: "≑",
	eDot: "≑",
	dotminus: "∸",
	minusd: "∸",
	dotplus: "∔",
	plusdo: "∔",
	dotsquare: "⊡",
	sdotb: "⊡",
	drcorn: "⌟",
	lrcorner: "⌟",
	drcrop: "⌌",
	dscr: "𝒹",
	dscy: "ѕ",
	dsol: "⧶",
	dstrok: "đ",
	dtdot: "⋱",
	dtri: "▿",
	triangledown: "▿",
	dwangle: "⦦",
	dzcy: "џ",
	dzigrarr: "⟿",
	eacute: "é",
	easter: "⩮",
	ecaron: "ě",
	ecir: "≖",
	eqcirc: "≖",
	ecirc: "ê",
	ecolon: "≕",
	eqcolon: "≕",
	ecy: "э",
	edot: "ė",
	efDot: "≒",
	fallingdotseq: "≒",
	efr: "𝔢",
	eg: "⪚",
	egrave: "è",
	egs: "⪖",
	eqslantgtr: "⪖",
	egsdot: "⪘",
	el: "⪙",
	elinters: "⏧",
	ell: "ℓ",
	els: "⪕",
	eqslantless: "⪕",
	elsdot: "⪗",
	emacr: "ē",
	empty: "∅",
	emptyset: "∅",
	emptyv: "∅",
	varnothing: "∅",
	emsp13: " ",
	emsp14: " ",
	emsp: " ",
	eng: "ŋ",
	ensp: " ",
	eogon: "ę",
	eopf: "𝕖",
	epar: "⋕",
	eparsl: "⧣",
	eplus: "⩱",
	epsi: "ε",
	epsilon: "ε",
	epsiv: "ϵ",
	straightepsilon: "ϵ",
	varepsilon: "ϵ",
	equals: "=",
	equest: "≟",
	questeq: "≟",
	equivDD: "⩸",
	eqvparsl: "⧥",
	erDot: "≓",
	risingdotseq: "≓",
	erarr: "⥱",
	escr: "ℯ",
	eta: "η",
	eth: "ð",
	euml: "ë",
	euro: "€",
	excl: "!",
	fcy: "ф",
	female: "♀",
	ffilig: "ﬃ",
	fflig: "ﬀ",
	ffllig: "ﬄ",
	ffr: "𝔣",
	filig: "ﬁ",
	fjlig: "fj",
	flat: "♭",
	fllig: "ﬂ",
	fltns: "▱",
	fnof: "ƒ",
	fopf: "𝕗",
	fork: "⋔",
	pitchfork: "⋔",
	forkv: "⫙",
	fpartint: "⨍",
	frac12: "½",
	half: "½",
	frac13: "⅓",
	frac14: "¼",
	frac15: "⅕",
	frac16: "⅙",
	frac18: "⅛",
	frac23: "⅔",
	frac25: "⅖",
	frac34: "¾",
	frac35: "⅗",
	frac38: "⅜",
	frac45: "⅘",
	frac56: "⅚",
	frac58: "⅝",
	frac78: "⅞",
	frasl: "⁄",
	frown: "⌢",
	sfrown: "⌢",
	fscr: "𝒻",
	gEl: "⪌",
	gtreqqless: "⪌",
	gacute: "ǵ",
	gamma: "γ",
	gap: "⪆",
	gtrapprox: "⪆",
	gbreve: "ğ",
	gcirc: "ĝ",
	gcy: "г",
	gdot: "ġ",
	gescc: "⪩",
	gesdot: "⪀",
	gesdoto: "⪂",
	gesdotol: "⪄",
	gesl: "⋛︀",
	gesles: "⪔",
	gfr: "𝔤",
	gimel: "ℷ",
	gjcy: "ѓ",
	glE: "⪒",
	gla: "⪥",
	glj: "⪤",
	gnE: "≩",
	gneqq: "≩",
	gnap: "⪊",
	gnapprox: "⪊",
	gne: "⪈",
	gneq: "⪈",
	gnsim: "⋧",
	gopf: "𝕘",
	gscr: "ℊ",
	gsime: "⪎",
	gsiml: "⪐",
	gtcc: "⪧",
	gtcir: "⩺",
	gtdot: "⋗",
	gtrdot: "⋗",
	gtlPar: "⦕",
	gtquest: "⩼",
	gtrarr: "⥸",
	gvertneqq: "≩︀",
	gvnE: "≩︀",
	hardcy: "ъ",
	harrcir: "⥈",
	harrw: "↭",
	leftrightsquigarrow: "↭",
	hbar: "ℏ",
	hslash: "ℏ",
	planck: "ℏ",
	plankv: "ℏ",
	hcirc: "ĥ",
	hearts: "♥",
	heartsuit: "♥",
	hellip: "…",
	mldr: "…",
	hercon: "⊹",
	hfr: "𝔥",
	hksearow: "⤥",
	searhk: "⤥",
	hkswarow: "⤦",
	swarhk: "⤦",
	hoarr: "⇿",
	homtht: "∻",
	hookleftarrow: "↩",
	larrhk: "↩",
	hookrightarrow: "↪",
	rarrhk: "↪",
	hopf: "𝕙",
	horbar: "―",
	hscr: "𝒽",
	hstrok: "ħ",
	hybull: "⁃",
	iacute: "í",
	icirc: "î",
	icy: "и",
	iecy: "е",
	iexcl: "¡",
	ifr: "𝔦",
	igrave: "ì",
	iiiint: "⨌",
	qint: "⨌",
	iiint: "∭",
	tint: "∭",
	iinfin: "⧜",
	iiota: "℩",
	ijlig: "ĳ",
	imacr: "ī",
	imath: "ı",
	inodot: "ı",
	imof: "⊷",
	imped: "Ƶ",
	incare: "℅",
	infin: "∞",
	infintie: "⧝",
	intcal: "⊺",
	intercal: "⊺",
	intlarhk: "⨗",
	intprod: "⨼",
	iprod: "⨼",
	iocy: "ё",
	iogon: "į",
	iopf: "𝕚",
	iota: "ι",
	iquest: "¿",
	iscr: "𝒾",
	isinE: "⋹",
	isindot: "⋵",
	isins: "⋴",
	isinsv: "⋳",
	itilde: "ĩ",
	iukcy: "і",
	iuml: "ï",
	jcirc: "ĵ",
	jcy: "й",
	jfr: "𝔧",
	jmath: "ȷ",
	jopf: "𝕛",
	jscr: "𝒿",
	jsercy: "ј",
	jukcy: "є",
	kappa: "κ",
	kappav: "ϰ",
	varkappa: "ϰ",
	kcedil: "ķ",
	kcy: "к",
	kfr: "𝔨",
	kgreen: "ĸ",
	khcy: "х",
	kjcy: "ќ",
	kopf: "𝕜",
	kscr: "𝓀",
	lAtail: "⤛",
	lBarr: "⤎",
	lEg: "⪋",
	lesseqqgtr: "⪋",
	lHar: "⥢",
	lacute: "ĺ",
	laemptyv: "⦴",
	lambda: "λ",
	langd: "⦑",
	lap: "⪅",
	lessapprox: "⪅",
	laquo: "«",
	larrbfs: "⤟",
	larrfs: "⤝",
	larrlp: "↫",
	looparrowleft: "↫",
	larrpl: "⤹",
	larrsim: "⥳",
	larrtl: "↢",
	leftarrowtail: "↢",
	lat: "⪫",
	latail: "⤙",
	late: "⪭",
	lates: "⪭︀",
	lbarr: "⤌",
	lbbrk: "❲",
	lbrace: "{",
	lcub: "{",
	lbrack: "[",
	lsqb: "[",
	lbrke: "⦋",
	lbrksld: "⦏",
	lbrkslu: "⦍",
	lcaron: "ľ",
	lcedil: "ļ",
	lcy: "л",
	ldca: "⤶",
	ldrdhar: "⥧",
	ldrushar: "⥋",
	ldsh: "↲",
	le: "≤",
	leq: "≤",
	leftleftarrows: "⇇",
	llarr: "⇇",
	leftthreetimes: "⋋",
	lthree: "⋋",
	lescc: "⪨",
	lesdot: "⩿",
	lesdoto: "⪁",
	lesdotor: "⪃",
	lesg: "⋚︀",
	lesges: "⪓",
	lessdot: "⋖",
	ltdot: "⋖",
	lfisht: "⥼",
	lfr: "𝔩",
	lgE: "⪑",
	lharul: "⥪",
	lhblk: "▄",
	ljcy: "љ",
	llhard: "⥫",
	lltri: "◺",
	lmidot: "ŀ",
	lmoust: "⎰",
	lmoustache: "⎰",
	lnE: "≨",
	lneqq: "≨",
	lnap: "⪉",
	lnapprox: "⪉",
	lne: "⪇",
	lneq: "⪇",
	lnsim: "⋦",
	loang: "⟬",
	loarr: "⇽",
	longmapsto: "⟼",
	xmap: "⟼",
	looparrowright: "↬",
	rarrlp: "↬",
	lopar: "⦅",
	lopf: "𝕝",
	loplus: "⨭",
	lotimes: "⨴",
	lowast: "∗",
	loz: "◊",
	lozenge: "◊",
	lpar: "(",
	lparlt: "⦓",
	lrhard: "⥭",
	lrm: "‎",
	lrtri: "⊿",
	lsaquo: "‹",
	lscr: "𝓁",
	lsime: "⪍",
	lsimg: "⪏",
	lsquor: "‚",
	sbquo: "‚",
	lstrok: "ł",
	ltcc: "⪦",
	ltcir: "⩹",
	ltimes: "⋉",
	ltlarr: "⥶",
	ltquest: "⩻",
	ltrPar: "⦖",
	ltri: "◃",
	triangleleft: "◃",
	lurdshar: "⥊",
	luruhar: "⥦",
	lvertneqq: "≨︀",
	lvnE: "≨︀",
	mDDot: "∺",
	macr: "¯",
	strns: "¯",
	male: "♂",
	malt: "✠",
	maltese: "✠",
	marker: "▮",
	mcomma: "⨩",
	mcy: "м",
	mdash: "—",
	mfr: "𝔪",
	mho: "℧",
	micro: "µ",
	midcir: "⫰",
	minus: "−",
	minusdu: "⨪",
	mlcp: "⫛",
	models: "⊧",
	mopf: "𝕞",
	mscr: "𝓂",
	mu: "μ",
	multimap: "⊸",
	mumap: "⊸",
	nGg: "⋙̸",
	nGt: "≫⃒",
	nLeftarrow: "⇍",
	nlArr: "⇍",
	nLeftrightarrow: "⇎",
	nhArr: "⇎",
	nLl: "⋘̸",
	nLt: "≪⃒",
	nRightarrow: "⇏",
	nrArr: "⇏",
	nVDash: "⊯",
	nVdash: "⊮",
	nacute: "ń",
	nang: "∠⃒",
	napE: "⩰̸",
	napid: "≋̸",
	napos: "ŉ",
	natur: "♮",
	natural: "♮",
	ncap: "⩃",
	ncaron: "ň",
	ncedil: "ņ",
	ncongdot: "⩭̸",
	ncup: "⩂",
	ncy: "н",
	ndash: "–",
	neArr: "⇗",
	nearhk: "⤤",
	nedot: "≐̸",
	nesear: "⤨",
	toea: "⤨",
	nfr: "𝔫",
	nharr: "↮",
	nleftrightarrow: "↮",
	nhpar: "⫲",
	nis: "⋼",
	nisd: "⋺",
	njcy: "њ",
	nlE: "≦̸",
	nleqq: "≦̸",
	nlarr: "↚",
	nleftarrow: "↚",
	nldr: "‥",
	nopf: "𝕟",
	not: "¬",
	notinE: "⋹̸",
	notindot: "⋵̸",
	notinvb: "⋷",
	notinvc: "⋶",
	notnivb: "⋾",
	notnivc: "⋽",
	nparsl: "⫽⃥",
	npart: "∂̸",
	npolint: "⨔",
	nrarr: "↛",
	nrightarrow: "↛",
	nrarrc: "⤳̸",
	nrarrw: "↝̸",
	nscr: "𝓃",
	nsub: "⊄",
	nsubE: "⫅̸",
	nsubseteqq: "⫅̸",
	nsup: "⊅",
	nsupE: "⫆̸",
	nsupseteqq: "⫆̸",
	ntilde: "ñ",
	nu: "ν",
	num: "#",
	numero: "№",
	numsp: " ",
	nvDash: "⊭",
	nvHarr: "⤄",
	nvap: "≍⃒",
	nvdash: "⊬",
	nvge: "≥⃒",
	nvgt: ">⃒",
	nvinfin: "⧞",
	nvlArr: "⤂",
	nvle: "≤⃒",
	nvlt: "<⃒",
	nvltrie: "⊴⃒",
	nvrArr: "⤃",
	nvrtrie: "⊵⃒",
	nvsim: "∼⃒",
	nwArr: "⇖",
	nwarhk: "⤣",
	nwnear: "⤧",
	oacute: "ó",
	ocirc: "ô",
	ocy: "о",
	odblac: "ő",
	odiv: "⨸",
	odsold: "⦼",
	oelig: "œ",
	ofcir: "⦿",
	ofr: "𝔬",
	ogon: "˛",
	ograve: "ò",
	ogt: "⧁",
	ohbar: "⦵",
	olcir: "⦾",
	olcross: "⦻",
	olt: "⧀",
	omacr: "ō",
	omega: "ω",
	omicron: "ο",
	omid: "⦶",
	oopf: "𝕠",
	opar: "⦷",
	operp: "⦹",
	or: "∨",
	vee: "∨",
	ord: "⩝",
	order: "ℴ",
	orderof: "ℴ",
	oscr: "ℴ",
	ordf: "ª",
	ordm: "º",
	origof: "⊶",
	oror: "⩖",
	orslope: "⩗",
	orv: "⩛",
	oslash: "ø",
	osol: "⊘",
	otilde: "õ",
	otimesas: "⨶",
	ouml: "ö",
	ovbar: "⌽",
	para: "¶",
	parsim: "⫳",
	parsl: "⫽",
	pcy: "п",
	percnt: "%",
	period: ".",
	permil: "‰",
	pertenk: "‱",
	pfr: "𝔭",
	phi: "φ",
	phiv: "ϕ",
	straightphi: "ϕ",
	varphi: "ϕ",
	phone: "☎",
	pi: "π",
	piv: "ϖ",
	varpi: "ϖ",
	planckh: "ℎ",
	plus: "+",
	plusacir: "⨣",
	pluscir: "⨢",
	plusdu: "⨥",
	pluse: "⩲",
	plussim: "⨦",
	plustwo: "⨧",
	pointint: "⨕",
	popf: "𝕡",
	pound: "£",
	prE: "⪳",
	prap: "⪷",
	precapprox: "⪷",
	precnapprox: "⪹",
	prnap: "⪹",
	precneqq: "⪵",
	prnE: "⪵",
	precnsim: "⋨",
	prnsim: "⋨",
	prime: "′",
	profalar: "⌮",
	profline: "⌒",
	profsurf: "⌓",
	prurel: "⊰",
	pscr: "𝓅",
	psi: "ψ",
	puncsp: " ",
	qfr: "𝔮",
	qopf: "𝕢",
	qprime: "⁗",
	qscr: "𝓆",
	quatint: "⨖",
	quest: "?",
	rAtail: "⤜",
	rHar: "⥤",
	race: "∽̱",
	racute: "ŕ",
	raemptyv: "⦳",
	rangd: "⦒",
	range: "⦥",
	raquo: "»",
	rarrap: "⥵",
	rarrbfs: "⤠",
	rarrc: "⤳",
	rarrfs: "⤞",
	rarrpl: "⥅",
	rarrsim: "⥴",
	rarrtl: "↣",
	rightarrowtail: "↣",
	rarrw: "↝",
	rightsquigarrow: "↝",
	ratail: "⤚",
	ratio: "∶",
	rbbrk: "❳",
	rbrace: "}",
	rcub: "}",
	rbrack: "]",
	rsqb: "]",
	rbrke: "⦌",
	rbrksld: "⦎",
	rbrkslu: "⦐",
	rcaron: "ř",
	rcedil: "ŗ",
	rcy: "р",
	rdca: "⤷",
	rdldhar: "⥩",
	rdsh: "↳",
	rect: "▭",
	rfisht: "⥽",
	rfr: "𝔯",
	rharul: "⥬",
	rho: "ρ",
	rhov: "ϱ",
	varrho: "ϱ",
	rightrightarrows: "⇉",
	rrarr: "⇉",
	rightthreetimes: "⋌",
	rthree: "⋌",
	ring: "˚",
	rlm: "‏",
	rmoust: "⎱",
	rmoustache: "⎱",
	rnmid: "⫮",
	roang: "⟭",
	roarr: "⇾",
	ropar: "⦆",
	ropf: "𝕣",
	roplus: "⨮",
	rotimes: "⨵",
	rpar: ")",
	rpargt: "⦔",
	rppolint: "⨒",
	rsaquo: "›",
	rscr: "𝓇",
	rtimes: "⋊",
	rtri: "▹",
	triangleright: "▹",
	rtriltri: "⧎",
	ruluhar: "⥨",
	rx: "℞",
	sacute: "ś",
	scE: "⪴",
	scap: "⪸",
	succapprox: "⪸",
	scaron: "š",
	scedil: "ş",
	scirc: "ŝ",
	scnE: "⪶",
	succneqq: "⪶",
	scnap: "⪺",
	succnapprox: "⪺",
	scnsim: "⋩",
	succnsim: "⋩",
	scpolint: "⨓",
	scy: "с",
	sdot: "⋅",
	sdote: "⩦",
	seArr: "⇘",
	sect: "§",
	semi: ";",
	seswar: "⤩",
	tosa: "⤩",
	sext: "✶",
	sfr: "𝔰",
	sharp: "♯",
	shchcy: "щ",
	shcy: "ш",
	shy: "­",
	sigma: "σ",
	sigmaf: "ς",
	sigmav: "ς",
	varsigma: "ς",
	simdot: "⩪",
	simg: "⪞",
	simgE: "⪠",
	siml: "⪝",
	simlE: "⪟",
	simne: "≆",
	simplus: "⨤",
	simrarr: "⥲",
	smashp: "⨳",
	smeparsl: "⧤",
	smile: "⌣",
	ssmile: "⌣",
	smt: "⪪",
	smte: "⪬",
	smtes: "⪬︀",
	softcy: "ь",
	sol: "/",
	solb: "⧄",
	solbar: "⌿",
	sopf: "𝕤",
	spades: "♠",
	spadesuit: "♠",
	sqcaps: "⊓︀",
	sqcups: "⊔︀",
	sscr: "𝓈",
	star: "☆",
	sub: "⊂",
	subset: "⊂",
	subE: "⫅",
	subseteqq: "⫅",
	subdot: "⪽",
	subedot: "⫃",
	submult: "⫁",
	subnE: "⫋",
	subsetneqq: "⫋",
	subne: "⊊",
	subsetneq: "⊊",
	subplus: "⪿",
	subrarr: "⥹",
	subsim: "⫇",
	subsub: "⫕",
	subsup: "⫓",
	sung: "♪",
	sup1: "¹",
	sup2: "²",
	sup3: "³",
	supE: "⫆",
	supseteqq: "⫆",
	supdot: "⪾",
	supdsub: "⫘",
	supedot: "⫄",
	suphsol: "⟉",
	suphsub: "⫗",
	suplarr: "⥻",
	supmult: "⫂",
	supnE: "⫌",
	supsetneqq: "⫌",
	supne: "⊋",
	supsetneq: "⊋",
	supplus: "⫀",
	supsim: "⫈",
	supsub: "⫔",
	supsup: "⫖",
	swArr: "⇙",
	swnwar: "⤪",
	szlig: "ß",
	target: "⌖",
	tau: "τ",
	tcaron: "ť",
	tcedil: "ţ",
	tcy: "т",
	telrec: "⌕",
	tfr: "𝔱",
	theta: "θ",
	thetasym: "ϑ",
	thetav: "ϑ",
	vartheta: "ϑ",
	thorn: "þ",
	times: "×",
	timesbar: "⨱",
	timesd: "⨰",
	topbot: "⌶",
	topcir: "⫱",
	topf: "𝕥",
	topfork: "⫚",
	tprime: "‴",
	triangle: "▵",
	utri: "▵",
	triangleq: "≜",
	trie: "≜",
	tridot: "◬",
	triminus: "⨺",
	triplus: "⨹",
	trisb: "⧍",
	tritime: "⨻",
	trpezium: "⏢",
	tscr: "𝓉",
	tscy: "ц",
	tshcy: "ћ",
	tstrok: "ŧ",
	uHar: "⥣",
	uacute: "ú",
	ubrcy: "ў",
	ubreve: "ŭ",
	ucirc: "û",
	ucy: "у",
	udblac: "ű",
	ufisht: "⥾",
	ufr: "𝔲",
	ugrave: "ù",
	uhblk: "▀",
	ulcorn: "⌜",
	ulcorner: "⌜",
	ulcrop: "⌏",
	ultri: "◸",
	umacr: "ū",
	uogon: "ų",
	uopf: "𝕦",
	upsi: "υ",
	upsilon: "υ",
	upuparrows: "⇈",
	uuarr: "⇈",
	urcorn: "⌝",
	urcorner: "⌝",
	urcrop: "⌎",
	uring: "ů",
	urtri: "◹",
	uscr: "𝓊",
	utdot: "⋰",
	utilde: "ũ",
	uuml: "ü",
	uwangle: "⦧",
	vBar: "⫨",
	vBarv: "⫩",
	vangrt: "⦜",
	varsubsetneq: "⊊︀",
	vsubne: "⊊︀",
	varsubsetneqq: "⫋︀",
	vsubnE: "⫋︀",
	varsupsetneq: "⊋︀",
	vsupne: "⊋︀",
	varsupsetneqq: "⫌︀",
	vsupnE: "⫌︀",
	vcy: "в",
	veebar: "⊻",
	veeeq: "≚",
	vellip: "⋮",
	vfr: "𝔳",
	vopf: "𝕧",
	vscr: "𝓋",
	vzigzag: "⦚",
	wcirc: "ŵ",
	wedbar: "⩟",
	wedgeq: "≙",
	weierp: "℘",
	wp: "℘",
	wfr: "𝔴",
	wopf: "𝕨",
	wscr: "𝓌",
	xfr: "𝔵",
	xi: "ξ",
	xnis: "⋻",
	xopf: "𝕩",
	xscr: "𝓍",
	yacute: "ý",
	yacy: "я",
	ycirc: "ŷ",
	ycy: "ы",
	yen: "¥",
	yfr: "𝔶",
	yicy: "ї",
	yopf: "𝕪",
	yscr: "𝓎",
	yucy: "ю",
	yuml: "ÿ",
	zacute: "ź",
	zcaron: "ž",
	zcy: "з",
	zdot: "ż",
	zeta: "ζ",
	zfr: "𝔷",
	zhcy: "ж",
	zigrarr: "⇝",
	zopf: "𝕫",
	zscr: "𝓏",
	zwj: "‍",
	zwnj: "‌"
};
Ye$1.ngsp = "";
var Ga = [
	/@/,
	/^\s*$/,
	/[<>]/,
	/^[{}]$/,
	/&(#|[a-z])/i,
	/^\/\//
];
function Ls$1(t, e) {
	if (e != null && !(Array.isArray(e) && e.length == 2)) throw new Error(`Expected '${t}' to be an array, [start, end].`);
	if (e != null) {
		let r = e[0], n = e[1];
		Ga.forEach((s) => {
			if (s.test(r) || s.test(n)) throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
		});
	}
}
var Fr$1 = new class t {
	static fromArray(e) {
		return e ? (Ls$1("interpolation", e), new t(e[0], e[1])) : Fr$1;
	}
	constructor(e, r) {
		this.start = e, this.end = r;
	}
}("{{", "}}");
var ft = class extends Ue$1 {
	constructor(e, r, n) {
		super(n, e), this.tokenType = r;
	}
}, $r$1 = class {
	constructor(e, r, n) {
		this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
	}
};
function Ws(t, e, r, n = {}) {
	let s = new Or(new Te$1(t, e), r, n);
	return s.tokenize(), new $r$1(_o(s.tokens), s.errors, s.nonNormalizedIcuExpressions);
}
var po = /\r\n?/g;
function je$1(t) {
	return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function Rs(t) {
	return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function ho(t, e) {
	return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var tr;
(function(t) {
	t.HEX = "hexadecimal", t.DEC = "decimal";
})(tr || (tr = {}));
var dt = class {
	constructor(e) {
		this.error = e;
	}
}, Or = class {
	constructor(e, r, n) {
		this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || !1, this._interpolationConfig = n.interpolationConfig || Fr$1, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || !1, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || !1;
		let s = n.range || {
			endPos: e.content.length,
			startPos: 0,
			startLine: 0,
			startCol: 0
		};
		this._cursor = n.escapedString ? new Mr$1(e, s) : new rr(e, s), this._preserveLineEndings = n.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = n.tokenizeBlocks ?? !0, this._tokenizeLet = n.tokenizeLet ?? !0;
		try {
			this._cursor.init();
		} catch (i) {
			this.handleError(i);
		}
	}
	_processCarriageReturns(e) {
		return this._preserveLineEndings ? e : e.replace(po, `
`);
	}
	tokenize() {
		for (; this._cursor.peek() !== 0;) {
			let e = this._cursor.clone();
			try {
				if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
				else if (this._attemptCharCode(47)) this._consumeTagClose(e);
				else {
					let r = this._cursor.clone();
					this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
				}
				else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
			} catch (r) {
				this.handleError(r);
			}
		}
		this._beginToken(34), this._endToken([]);
	}
	_getBlockName() {
		let e = !1, r = this._cursor.clone();
		return this._attemptCharCodeUntilFn((n) => at$1(n) ? !e : Ms(n) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
	}
	_consumeBlockStart(e) {
		this._beginToken(25, e);
		let r = this._endToken([this._getBlockName()]);
		if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(b);
		else {
			r.type = 29;
			return;
		}
		this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
	}
	_consumeBlockEnd(e) {
		this._beginToken(27, e), this._endToken([]);
	}
	_consumeBlockParameters() {
		for (this._attemptCharCodeUntilFn(qs$1); this._cursor.peek() !== 41 && this._cursor.peek() !== 0;) {
			this._beginToken(28);
			let e = this._cursor.clone(), r = null, n = 0;
			for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null;) {
				let s = this._cursor.peek();
				if (s === 92) this._cursor.advance();
				else if (s === r) r = null;
				else if (r === null && $t$1(s)) r = s;
				else if (s === 40 && r === null) n++;
				else if (s === 41 && r === null) {
					if (n === 0) break;
					n > 0 && n--;
				}
				this._cursor.advance();
			}
			this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(qs$1);
		}
	}
	_consumeLetDeclaration(e) {
		if (this._beginToken(30, e), at$1(this._cursor.peek())) this._attemptCharCodeUntilFn(b);
		else {
			let s = this._endToken([this._cursor.getChars(e)]);
			s.type = 33;
			return;
		}
		let r = this._endToken([this._getLetDeclarationName()]);
		if (this._attemptCharCodeUntilFn(b), !this._attemptCharCode(61)) {
			r.type = 33;
			return;
		}
		this._attemptCharCodeUntilFn((s) => b(s) && !Rt$1(s)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r.type = 33, r.sourceSpan = this._cursor.getSpan(e));
	}
	_getLetDeclarationName() {
		let e = this._cursor.clone(), r = !1;
		return this._attemptCharCodeUntilFn((n) => ot(n) || n == 36 || n === 95 || r && It$1(n) ? (r = !0, !1) : !0), this._cursor.getChars(e).trim();
	}
	_consumeLetDeclarationValue() {
		let e = this._cursor.clone();
		for (this._beginToken(31, e); this._cursor.peek() !== 0;) {
			let r = this._cursor.peek();
			if (r === 59) break;
			$t$1(r) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n) => n === 92 ? (this._cursor.advance(), !1) : n === r)), this._cursor.advance();
		}
		this._endToken([this._cursor.getChars(e)]);
	}
	_tokenizeExpansionForm() {
		if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
		if (Co(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), !0;
		if (this._cursor.peek() === 125) {
			if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
			if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
		}
		return !1;
	}
	_beginToken(e, r = this._cursor.clone()) {
		this._currentTokenStart = r, this._currentTokenType = e;
	}
	_endToken(e, r) {
		if (this._currentTokenStart === null) throw new ft("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
		if (this._currentTokenType === null) throw new ft("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
		let n = {
			type: this._currentTokenType,
			parts: e,
			sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)
		};
		return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
	}
	_createError(e, r) {
		this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
		let n = new ft(e, this._currentTokenType, r);
		return this._currentTokenStart = null, this._currentTokenType = null, new dt(n);
	}
	handleError(e) {
		if (e instanceof gt && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof dt) this.errors.push(e.error);
		else throw e;
	}
	_attemptCharCode(e) {
		return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
	}
	_attemptCharCodeCaseInsensitive(e) {
		return So(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
	}
	_requireCharCode(e) {
		let r = this._cursor.clone();
		if (!this._attemptCharCode(e)) throw this._createError(je$1(this._cursor.peek()), this._cursor.getSpan(r));
	}
	_attemptStr(e) {
		let r = e.length;
		if (this._cursor.charsLeft() < r) return !1;
		let n = this._cursor.clone();
		for (let s = 0; s < r; s++) if (!this._attemptCharCode(e.charCodeAt(s))) return this._cursor = n, !1;
		return !0;
	}
	_attemptStrCaseInsensitive(e) {
		for (let r = 0; r < e.length; r++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r))) return !1;
		return !0;
	}
	_requireStr(e) {
		let r = this._cursor.clone();
		if (!this._attemptStr(e)) throw this._createError(je$1(this._cursor.peek()), this._cursor.getSpan(r));
	}
	_requireStrCaseInsensitive(e) {
		let r = this._cursor.clone();
		if (!this._attemptStrCaseInsensitive(e)) throw this._createError(je$1(this._cursor.peek()), this._cursor.getSpan(r));
	}
	_attemptCharCodeUntilFn(e) {
		for (; !e(this._cursor.peek());) this._cursor.advance();
	}
	_requireCharCodeUntilFn(e, r) {
		let n = this._cursor.clone();
		if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r) throw this._createError(je$1(this._cursor.peek()), this._cursor.getSpan(n));
	}
	_attemptUntilChar(e) {
		for (; this._cursor.peek() !== e;) this._cursor.advance();
	}
	_readChar() {
		let e = String.fromCodePoint(this._cursor.peek());
		return this._cursor.advance(), e;
	}
	_consumeEntity(e) {
		this._beginToken(9);
		let r = this._cursor.clone();
		if (this._cursor.advance(), this._attemptCharCode(35)) {
			let n = this._attemptCharCode(120) || this._attemptCharCode(88), s = this._cursor.clone();
			if (this._attemptCharCodeUntilFn(fo), this._cursor.peek() != 59) {
				this._cursor.advance();
				let a = n ? tr.HEX : tr.DEC;
				throw this._createError(ho(a, this._cursor.getChars(r)), this._cursor.getSpan());
			}
			let i = this._cursor.getChars(s);
			this._cursor.advance();
			try {
				let a = parseInt(i, n ? 16 : 10);
				this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
			} catch {
				throw this._createError(Rs(this._cursor.getChars(r)), this._cursor.getSpan());
			}
		} else {
			let n = this._cursor.clone();
			if (this._attemptCharCodeUntilFn(go$1), this._cursor.peek() != 59) this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
			else {
				let s = this._cursor.getChars(n);
				this._cursor.advance();
				let i = Ye$1[s];
				if (!i) throw this._createError(Rs(s), this._cursor.getSpan(r));
				this._endToken([i, `&${s};`]);
			}
		}
	}
	_consumeRawText(e, r) {
		this._beginToken(e ? 6 : 7);
		let n = [];
		for (;;) {
			let s = this._cursor.clone(), i = r();
			if (this._cursor = s, i) break;
			e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
		}
		this._endToken([this._processCarriageReturns(n.join(""))]);
	}
	_consumeComment(e) {
		this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
	}
	_consumeBogusComment(e) {
		this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
	}
	_consumeCdata(e) {
		this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
	}
	_consumeDocType(e) {
		this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
	}
	_consumePrefixAndName() {
		let e = this._cursor.clone(), r = "";
		for (; this._cursor.peek() !== 58 && !mo$1(this._cursor.peek());) this._cursor.advance();
		let n;
		this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn($s, r === "" ? 0 : 1);
		let s = this._cursor.getChars(n);
		return [r, s];
	}
	_consumeTagOpen(e) {
		let r, n, s, i = [];
		try {
			if (!ot(this._cursor.peek())) throw this._createError(je$1(this._cursor.peek()), this._cursor.getSpan(e));
			for (s = this._consumeTagOpenStart(e), n = s.parts[0], r = s.parts[1], this._attemptCharCodeUntilFn(b); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0;) {
				let [o, u] = this._consumeAttributeName();
				if (this._attemptCharCodeUntilFn(b), this._attemptCharCode(61)) {
					this._attemptCharCodeUntilFn(b);
					let p = this._consumeAttributeValue();
					i.push({
						prefix: o,
						name: u,
						value: p
					});
				} else i.push({
					prefix: o,
					name: u
				});
				this._attemptCharCodeUntilFn(b);
			}
			this._consumeTagOpenEnd();
		} catch (o) {
			if (o instanceof dt) {
				s ? s.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
				return;
			}
			throw o;
		}
		if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2) return;
		let a = this._getTagContentType(r, n, this._fullNameStack.length > 0, i);
		this._handleFullNameStackForTagOpen(n, r), a === I.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, !1) : a === I.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, !0);
	}
	_consumeRawTextWithTagClose(e, r, n) {
		this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(b), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s) => s === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
	}
	_consumeTagOpenStart(e) {
		this._beginToken(0, e);
		let r = this._consumePrefixAndName();
		return this._endToken(r);
	}
	_consumeAttributeName() {
		let e = this._cursor.peek();
		if (e === 39 || e === 34) throw this._createError(je$1(e), this._cursor.getSpan());
		this._beginToken(14);
		let r = this._consumePrefixAndName();
		return this._endToken(r), r;
	}
	_consumeAttributeValue() {
		let e;
		if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
			let r = this._cursor.peek();
			this._consumeQuote(r);
			let n = () => this._cursor.peek() === r;
			e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
		} else {
			let r = () => $s(this._cursor.peek());
			e = this._consumeWithInterpolation(16, 17, r, r);
		}
		return e;
	}
	_consumeQuote(e) {
		this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
	}
	_consumeTagOpenEnd() {
		let e = this._attemptCharCode(47) ? 2 : 1;
		this._beginToken(e), this._requireCharCode(62), this._endToken([]);
	}
	_consumeTagClose(e) {
		if (this._beginToken(3, e), this._attemptCharCodeUntilFn(b), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([]);
		else {
			let [r, n] = this._consumePrefixAndName();
			this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
		}
	}
	_consumeExpansionFormStart() {
		this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
		let e = this._readUntil(44), r = this._processCarriageReturns(e);
		if (this._i18nNormalizeLineEndingsInICUs) this._endToken([r]);
		else {
			let s = this._endToken([e]);
			r !== e && this.nonNormalizedIcuExpressions.push(s);
		}
		this._requireCharCode(44), this._attemptCharCodeUntilFn(b), this._beginToken(7);
		let n = this._readUntil(44);
		this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b);
	}
	_consumeExpansionCaseStart() {
		this._beginToken(21);
		let e = this._readUntil(123).trim();
		this._endToken([e]), this._attemptCharCodeUntilFn(b), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.push(22);
	}
	_consumeExpansionCaseEnd() {
		this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.pop();
	}
	_consumeExpansionFormEnd() {
		this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
	}
	_consumeWithInterpolation(e, r, n, s) {
		this._beginToken(e);
		let i = [];
		for (; !n();) {
			let o = this._cursor.clone();
			this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o), i.length = 0, this._consumeInterpolation(r, o, s), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e), this._beginToken(e)) : i.push(this._readChar());
		}
		this._inInterpolation = !1;
		let a = this._processCarriageReturns(i.join(""));
		return this._endToken([a]), a;
	}
	_consumeInterpolation(e, r, n) {
		let s = [];
		this._beginToken(e, r), s.push(this._interpolationConfig.start);
		let i = this._cursor.clone(), a = null, o = !1;
		for (; this._cursor.peek() !== 0 && (n === null || !n());) {
			let u = this._cursor.clone();
			if (this._isTagStart()) {
				this._cursor = u, s.push(this._getProcessedChars(i, u)), this._endToken(s);
				return;
			}
			if (a === null) if (this._attemptStr(this._interpolationConfig.end)) {
				s.push(this._getProcessedChars(i, u)), s.push(this._interpolationConfig.end), this._endToken(s);
				return;
			} else this._attemptStr("//") && (o = !0);
			let p = this._cursor.peek();
			this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o && a === null && $t$1(p) && (a = p);
		}
		s.push(this._getProcessedChars(i, this._cursor)), this._endToken(s);
	}
	_getProcessedChars(e, r) {
		return this._processCarriageReturns(r.getChars(e));
	}
	_isTextEnd() {
		return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
	}
	_isTagStart() {
		if (this._cursor.peek() === 60) {
			let e = this._cursor.clone();
			e.advance();
			let r = e.peek();
			if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33) return !0;
		}
		return !1;
	}
	_isBlockStart() {
		if (this._tokenizeBlocks && this._cursor.peek() === 64) {
			let e = this._cursor.clone();
			if (e.advance(), Ms(e.peek())) return !0;
		}
		return !1;
	}
	_readUntil(e) {
		let r = this._cursor.clone();
		return this._attemptUntilChar(e), this._cursor.getChars(r);
	}
	_isInExpansion() {
		return this._isInExpansionCase() || this._isInExpansionForm();
	}
	_isInExpansionCase() {
		return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
	}
	_isInExpansionForm() {
		return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
	}
	isExpansionFormStart() {
		if (this._cursor.peek() !== 123) return !1;
		if (this._interpolationConfig) {
			let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
			return this._cursor = e, !r;
		}
		return !0;
	}
	_handleFullNameStackForTagOpen(e, r) {
		let n = ze$1(e, r);
		(this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
	}
	_handleFullNameStackForTagClose(e, r) {
		let n = ze$1(e, r);
		this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
	}
};
function b(t) {
	return !at$1(t) || t === 0;
}
function $s(t) {
	return at$1(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function mo$1(t) {
	return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function fo(t) {
	return t === 59 || t === 0 || !Cs(t);
}
function go$1(t) {
	return t === 59 || t === 0 || !ot(t);
}
function Co(t) {
	return t !== 125;
}
function So(t, e) {
	return Os$1(t) === Os$1(e);
}
function Os$1(t) {
	return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function Ms(t) {
	return ot(t) || It$1(t) || t === 95;
}
function qs$1(t) {
	return t !== 59 && b(t);
}
function _o(t) {
	let e = [], r;
	for (let n = 0; n < t.length; n++) {
		let s = t[n];
		r && r.type === 5 && s.type === 5 || r && r.type === 16 && s.type === 16 ? (r.parts[0] += s.parts[0], r.sourceSpan.end = s.sourceSpan.end) : (r = s, e.push(r));
	}
	return e;
}
var rr = class t {
	constructor(e, r) {
		if (e instanceof t) {
			this.file = e.file, this.input = e.input, this.end = e.end;
			let n = e.state;
			this.state = {
				peek: n.peek,
				offset: n.offset,
				line: n.line,
				column: n.column
			};
		} else {
			if (!r) throw new Error("Programming error: the range argument must be provided with a file argument.");
			this.file = e, this.input = e.content, this.end = r.endPos, this.state = {
				peek: -1,
				offset: r.startPos,
				line: r.startLine,
				column: r.startCol
			};
		}
	}
	clone() {
		return new t(this);
	}
	peek() {
		return this.state.peek;
	}
	charsLeft() {
		return this.end - this.state.offset;
	}
	diff(e) {
		return this.state.offset - e.state.offset;
	}
	advance() {
		this.advanceState(this.state);
	}
	init() {
		this.updatePeek(this.state);
	}
	getSpan(e, r) {
		e = e || this;
		let n = e;
		if (r) for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1;) n === e && (e = e.clone()), e.advance();
		let s = this.locationFromCursor(e);
		return new h(s, this.locationFromCursor(this), n !== e ? this.locationFromCursor(n) : s);
	}
	getChars(e) {
		return this.input.substring(e.state.offset, this.state.offset);
	}
	charAt(e) {
		return this.input.charCodeAt(e);
	}
	advanceState(e) {
		if (e.offset >= this.end) throw this.state = e, new gt("Unexpected character \"EOF\"", this);
		let r = this.charAt(e.offset);
		r === 10 ? (e.line++, e.column = 0) : Rt$1(r) || e.column++, e.offset++, this.updatePeek(e);
	}
	updatePeek(e) {
		e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
	}
	locationFromCursor(e) {
		return new ae$1(e.file, e.state.offset, e.state.line, e.state.column);
	}
}, Mr$1 = class t extends rr {
	constructor(e, r) {
		e instanceof t ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
	}
	advance() {
		this.state = this.internalState, super.advance(), this.processEscapeSequence();
	}
	init() {
		super.init(), this.processEscapeSequence();
	}
	clone() {
		return new t(this);
	}
	getChars(e) {
		let r = e.clone(), n = "";
		for (; r.internalState.offset < this.internalState.offset;) n += String.fromCodePoint(r.peek()), r.advance();
		return n;
	}
	processEscapeSequence() {
		let e = () => this.internalState.peek;
		if (e() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110) this.state.peek = 10;
		else if (e() === 114) this.state.peek = 13;
		else if (e() === 118) this.state.peek = 11;
		else if (e() === 116) this.state.peek = 9;
		else if (e() === 98) this.state.peek = 8;
		else if (e() === 102) this.state.peek = 12;
		else if (e() === 117) if (this.advanceState(this.internalState), e() === 123) {
			this.advanceState(this.internalState);
			let r = this.clone(), n = 0;
			for (; e() !== 125;) this.advanceState(this.internalState), n++;
			this.state.peek = this.decodeHexDigits(r, n);
		} else {
			let r = this.clone();
			this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
		}
		else if (e() === 120) {
			this.advanceState(this.internalState);
			let r = this.clone();
			this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
		} else if (yr(e())) {
			let r = "", n = 0, s = this.clone();
			for (; yr(e()) && n < 3;) s = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
			this.state.peek = parseInt(r, 8), this.internalState = s.internalState;
		} else Rt$1(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
	}
	decodeHexDigits(e, r) {
		let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), s = parseInt(n, 16);
		if (isNaN(s)) throw e.state = e.internalState, new gt("Invalid hexadecimal escape sequence", e);
		return s;
	}
}, gt = class {
	constructor(e, r) {
		this.msg = e, this.cursor = r;
	}
};
var L$1 = class t extends Ue$1 {
	static create(e, r, n) {
		return new t(e, r, n);
	}
	constructor(e, r, n) {
		super(r, n), this.elementName = e;
	}
}, Vr$1 = class {
	constructor(e, r) {
		this.rootNodes = e, this.errors = r;
	}
}, nr = class {
	constructor(e) {
		this.getTagDefinition = e;
	}
	parse(e, r, n, s = !1, i) {
		let a = (D$1) => (R, ...F) => D$1(R.toLowerCase(), ...F), o = s ? this.getTagDefinition : a(this.getTagDefinition), u = (D$1) => o(D$1).getContentType(), p = s ? i : a(i), f = Ws(e, r, i ? (D$1, R, F, c) => {
			let g = p(D$1, R, F, c);
			return g !== void 0 ? g : u(D$1);
		} : u, n), d = n && n.canSelfClose || !1, C = n && n.allowHtmComponentClosingTags || !1, A$1 = new Ur$1(f.tokens, o, d, C, s);
		return A$1.build(), new Vr$1(A$1.rootNodes, f.errors.concat(A$1.errors));
	}
}, Ur$1 = class t {
	constructor(e, r, n, s, i) {
		this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = s, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
	}
	build() {
		for (; this._peek.type !== 34;) this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
		for (let e of this._containerStack) e instanceof Z$1 && this.errors.push(L$1.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
	}
	_advance() {
		let e = this._peek;
		return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
	}
	_advanceIf(e) {
		return this._peek.type === e ? this._advance() : null;
	}
	_consumeCdata(e) {
		let r = this._advance(), n = this._getText(r), s = this._advanceIf(13);
		this._addToParent(new Wt(n, new h(e.sourceSpan.start, (s || r).sourceSpan.end), [r]));
	}
	_consumeComment(e) {
		let r = this._advanceIf(7), n = this._advanceIf(11), s = r != null ? r.parts[0].trim() : null, i = n == null ? e.sourceSpan : new h(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart);
		this._addToParent(new jt$1(s, i));
	}
	_consumeDocType(e) {
		let r = this._advanceIf(7), n = this._advanceIf(19), s = r != null ? r.parts[0].trim() : null, i = new h(e.sourceSpan.start, (n || r || e).sourceSpan.end);
		this._addToParent(new Kt(s, i));
	}
	_consumeExpansion(e) {
		let r = this._advance(), n = this._advance(), s = [];
		for (; this._peek.type === 21;) {
			let a = this._parseExpansionCase();
			if (!a) return;
			s.push(a);
		}
		if (this._peek.type !== 24) {
			this.errors.push(L$1.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
			return;
		}
		let i = new h(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
		this._addToParent(new zt(r.parts[0], n.parts[0], s, i, r.sourceSpan)), this._advance();
	}
	_parseExpansionCase() {
		let e = this._advance();
		if (this._peek.type !== 22) return this.errors.push(L$1.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
		let r = this._advance(), n = this._collectExpansionExpTokens(r);
		if (!n) return null;
		let s = this._advance();
		n.push({
			type: 34,
			parts: [],
			sourceSpan: s.sourceSpan
		});
		let i = new t(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
		if (i.build(), i.errors.length > 0) return this.errors = this.errors.concat(i.errors), null;
		let a = new h(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart), o = new h(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
		return new Gt$1(e.parts[0], i.rootNodes, a, e.sourceSpan, o);
	}
	_collectExpansionExpTokens(e) {
		let r = [], n = [22];
		for (;;) {
			if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23) if (zs(n, 22)) {
				if (n.pop(), n.length === 0) return r;
			} else return this.errors.push(L$1.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
			if (this._peek.type === 24) if (zs(n, 20)) n.pop();
			else return this.errors.push(L$1.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
			if (this._peek.type === 34) return this.errors.push(L$1.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
			r.push(this._advance());
		}
	}
	_getText(e) {
		let r = e.parts[0];
		if (r.length > 0 && r[0] == `
`) {
			let n = this._getClosestParentElement();
			n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
		}
		return r;
	}
	_consumeText(e) {
		let r = [e], n = e.sourceSpan, s = e.parts[0];
		if (s.length > 0 && s[0] === `
`) {
			let i = this._getContainer();
			i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s = s.substring(1), r[0] = {
				type: e.type,
				sourceSpan: e.sourceSpan,
				parts: [s]
			});
		}
		for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9;) e = this._advance(), r.push(e), e.type === 8 ? s += e.parts.join("").replace(/&([^;]+);/g, Gs) : e.type === 9 ? s += e.parts[0] : s += e.parts.join("");
		if (s.length > 0) {
			let i = e.sourceSpan;
			this._addToParent(new Ut$1(s, new h(n.start, i.end, n.fullStart, n.details), r));
		}
	}
	_closeVoidElement() {
		let e = this._getContainer();
		e instanceof G$1 && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
	}
	_consumeStartTag(e) {
		let [r, n] = e.parts, s = [];
		for (; this._peek.type === 14;) s.push(this._consumeAttr(this._advance()));
		let i = this._getElementFullName(r, n, this._getClosestParentElement()), a = !1;
		if (this._peek.type === 2) {
			this._advance(), a = !0;
			let C = this.getTagDefinition(i);
			this.canSelfClose || C.canSelfClose || We$1(i) !== null || C.isVoid || this.errors.push(L$1.create(i, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
		} else this._peek.type === 1 && (this._advance(), a = !1);
		let o = this._peek.sourceSpan.fullStart, u = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), f = new G$1(i, s, [], u, new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), void 0, new h(e.sourceSpan.start.moveBy(1), e.sourceSpan.end)), d = this._getContainer();
		this._pushContainer(f, d instanceof G$1 && this.getTagDefinition(d.name).isClosedByChild(f.name)), a ? this._popContainer(i, G$1, u) : e.type === 4 && (this._popContainer(i, G$1, null), this.errors.push(L$1.create(i, u, `Opening tag "${i}" not terminated.`)));
	}
	_pushContainer(e, r) {
		r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
	}
	_consumeEndTag(e) {
		let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
		if (r && this.getTagDefinition(r).isVoid) this.errors.push(L$1.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
		else if (!this._popContainer(r, G$1, e.sourceSpan)) {
			let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
			this.errors.push(L$1.create(r, e.sourceSpan, n));
		}
	}
	_popContainer(e, r, n) {
		let s = !1;
		for (let i = this._containerStack.length - 1; i >= 0; i--) {
			let a = this._containerStack[i];
			if (We$1(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r) return a.endSourceSpan = n, a.sourceSpan.end = n !== null ? n.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s;
			(a instanceof Z$1 || a instanceof G$1 && !this.getTagDefinition(a.name).closedByParent) && (s = !0);
		}
		return !1;
	}
	_consumeAttr(e) {
		let r = ze$1(e.parts[0], e.parts[1]), n = e.sourceSpan.end, s;
		this._peek.type === 15 && (s = this._advance());
		let i = "", a = [], o, u;
		if (this._peek.type === 16) for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9;) {
			let f = this._advance();
			a.push(f), f.type === 17 ? i += f.parts.join("").replace(/&([^;]+);/g, Gs) : f.type === 9 ? i += f.parts[0] : i += f.parts.join(""), u = n = f.sourceSpan.end;
		}
		this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
		let l = o && u && new h((s == null ? void 0 : s.sourceSpan.start) ?? o.start, u, (s == null ? void 0 : s.sourceSpan.fullStart) ?? o.fullStart);
		return new Yt(r, i, new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, l, a.length > 0 ? a : void 0, void 0);
	}
	_consumeBlockOpen(e) {
		let r = [];
		for (; this._peek.type === 28;) {
			let o = this._advance();
			r.push(new ct(o.parts[0], o.sourceSpan));
		}
		this._peek.type === 26 && this._advance();
		let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Z$1(e.parts[0], r, [], s, e.sourceSpan, i);
		this._pushContainer(a, !1);
	}
	_consumeBlockClose(e) {
		this._popContainer(null, Z$1, e.sourceSpan) || this.errors.push(L$1.create(null, e.sourceSpan, "Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the \"&#125;\" HTML entity instead."));
	}
	_consumeIncompleteBlock(e) {
		let r = [];
		for (; this._peek.type === 28;) {
			let o = this._advance();
			r.push(new ct(o.parts[0], o.sourceSpan));
		}
		let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Z$1(e.parts[0], r, [], s, e.sourceSpan, i);
		this._pushContainer(a, !1), this._popContainer(null, Z$1, null), this.errors.push(L$1.create(e.parts[0], s, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
	}
	_consumeLet(e) {
		let r = e.parts[0], n, s;
		if (this._peek.type !== 31) {
			this.errors.push(L$1.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
			return;
		} else n = this._advance();
		if (this._peek.type !== 32) {
			this.errors.push(L$1.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
			return;
		} else s = this._advance();
		let i = s.sourceSpan.fullStart, a = new h(e.sourceSpan.start, i, e.sourceSpan.fullStart), o = e.sourceSpan.toString().lastIndexOf(r), p = new h(e.sourceSpan.start.moveBy(o), e.sourceSpan.end), l = new pt$1(r, n.parts[0], a, p, n.sourceSpan);
		this._addToParent(l);
	}
	_consumeIncompleteLet(e) {
		let r = e.parts[0] ?? "", n = r ? ` "${r}"` : "";
		if (r.length > 0) {
			let s = e.sourceSpan.toString().lastIndexOf(r), a = new h(e.sourceSpan.start.moveBy(s), e.sourceSpan.end), o = new h(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), u = new pt$1(r, "", e.sourceSpan, a, o);
			this._addToParent(u);
		}
		this.errors.push(L$1.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``));
	}
	_getContainer() {
		return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
	}
	_getClosestParentElement() {
		for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof G$1) return this._containerStack[e];
		return null;
	}
	_addToParent(e) {
		let r = this._getContainer();
		r === null ? this.rootNodes.push(e) : r.children.push(e);
	}
	_getElementFullName(e, r, n) {
		if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
			let s = ut(n.name)[1];
			this.getTagDefinition(s).preventNamespaceInheritance || (e = We$1(n.name));
		}
		return ze$1(e, r);
	}
};
function zs(t, e) {
	return t.length > 0 && t[t.length - 1] === e;
}
function Gs(t, e) {
	return Ye$1[e] !== void 0 ? Ye$1[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var sr = class extends nr {
	constructor() {
		super(Ge$1);
	}
	parse(e, r, n, s = !1, i) {
		return super.parse(e, r, n, s, i);
	}
};
var Wr$1 = null, Eo = () => (Wr$1 || (Wr$1 = new sr()), Wr$1);
function zr$1(t, e = {}) {
	let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: s = !1, getTagContentType: i, tokenizeAngularBlocks: a = !1, tokenizeAngularLetDeclaration: o = !1 } = e;
	return Eo().parse(t, "angular-html-parser", {
		tokenizeExpansionForms: a,
		interpolationConfig: void 0,
		canSelfClose: r,
		allowHtmComponentClosingTags: n,
		tokenizeBlocks: a,
		tokenizeLet: o
	}, s, i);
}
function Ao(t, e) {
	let r = /* @__PURE__ */ new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
	return Object.assign(r, e);
}
var Ys = Ao;
var Ct$1 = 3;
function Do(t) {
	let e = t.slice(0, Ct$1);
	if (e !== "---" && e !== "+++") return;
	let r = t.indexOf(`
`, Ct$1);
	if (r === -1) return;
	let n = t.slice(Ct$1, r).trim(), s = t.indexOf(`
${e}`, r), i = n;
	if (i || (i = e === "+++" ? "toml" : "yaml"), s === -1 && e === "---" && i === "yaml" && (s = t.indexOf(`
...`, r)), s === -1) return;
	let a = s + 1 + Ct$1, o = t.charAt(a + 1);
	if (!/\s?/u.test(o)) return;
	let u = t.slice(0, a);
	return {
		type: "front-matter",
		language: i,
		explicitLanguage: n,
		value: t.slice(r + 1, s),
		startDelimiter: e,
		endDelimiter: u.slice(-Ct$1),
		raw: u
	};
}
function vo(t) {
	let e = Do(t);
	if (!e) return { content: t };
	let { raw: r } = e;
	return {
		frontMatter: e,
		content: w(!1, r, /[^\n]/gu, " ") + t.slice(r.length)
	};
}
var js$1 = vo;
var ir$1 = {
	attrs: !0,
	children: !0,
	cases: !0,
	expression: !0
}, Ks$1 = new Set(["parent"]), ar = class t {
	constructor(e = {}) {
		for (let r of new Set([...Ks$1, ...Object.keys(e)])) this.setProperty(r, e[r]);
	}
	setProperty(e, r) {
		if (this[e] !== r) {
			if (e in ir$1 && (r = r.map((n) => this.createChild(n))), !Ks$1.has(e)) {
				this[e] = r;
				return;
			}
			Object.defineProperty(this, e, {
				value: r,
				enumerable: !1,
				configurable: !0
			});
		}
	}
	map(e) {
		let r;
		for (let n in ir$1) {
			let s = this[n];
			if (s) {
				let i = yo(s, (a) => a.map(e));
				r !== s && (r || (r = new t({ parent: this.parent })), r.setProperty(n, i));
			}
		}
		if (r) for (let n in this) n in ir$1 || (r[n] = this[n]);
		return e(r || this);
	}
	walk(e) {
		for (let r in ir$1) {
			let n = this[r];
			if (n) for (let s = 0; s < n.length; s++) n[s].walk(e);
		}
		e(this);
	}
	createChild(e) {
		let r = e instanceof t ? e.clone() : new t(e);
		return r.setProperty("parent", this), r;
	}
	insertChildBefore(e, r) {
		this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
	}
	removeChild(e) {
		this.children.splice(this.children.indexOf(e), 1);
	}
	replaceChild(e, r) {
		this.children[this.children.indexOf(e)] = this.createChild(r);
	}
	clone() {
		return new t(this);
	}
	get firstChild() {
		var e;
		return (e = this.children) == null ? void 0 : e[0];
	}
	get lastChild() {
		var e;
		return (e = this.children) == null ? void 0 : e[this.children.length - 1];
	}
	get prev() {
		var e, r;
		return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
	}
	get next() {
		var e, r;
		return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
	}
	get rawName() {
		return this.hasExplicitNamespace ? this.fullName : this.name;
	}
	get fullName() {
		return this.namespace ? this.namespace + ":" + this.name : this.name;
	}
	get attrMap() {
		return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
	}
};
function yo(t, e) {
	let r = t.map(e);
	return r.some((n, s) => n !== t[s]) ? r : t;
}
var wo = [
	{
		regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su,
		parse: bo$1
	},
	{
		regex: /^\[if([^\]]*)\]><!$/u,
		parse: To
	},
	{
		regex: /^<!\s*\[endif\]$/u,
		parse: xo$1
	}
];
function Qs$1(t, e) {
	if (t.value) for (let { regex: r, parse: n } of wo) {
		let s = t.value.match(r);
		if (s) return n(t, e, s);
	}
	return null;
}
function bo$1(t, e, r) {
	let [, n, s, i] = r, a = 4 + n.length, o = t.sourceSpan.start.moveBy(a), u = o.moveBy(i.length), [p, l] = (() => {
		try {
			return [!0, e(i, o).children];
		} catch {
			return [!1, [{
				type: "text",
				value: i,
				sourceSpan: new h(o, u)
			}]];
		}
	})();
	return {
		type: "ieConditionalComment",
		complete: p,
		children: l,
		condition: w(!1, s.trim(), /\s+/gu, " "),
		sourceSpan: t.sourceSpan,
		startSourceSpan: new h(t.sourceSpan.start, o),
		endSourceSpan: new h(u, t.sourceSpan.end)
	};
}
function To(t, e, r) {
	let [, n] = r;
	return {
		type: "ieConditionalStartComment",
		condition: w(!1, n.trim(), /\s+/gu, " "),
		sourceSpan: t.sourceSpan
	};
}
function xo$1(t) {
	return {
		type: "ieConditionalEndComment",
		sourceSpan: t.sourceSpan
	};
}
var or$1 = new Map([
	["*", new Set([
		"accesskey",
		"autocapitalize",
		"autofocus",
		"class",
		"contenteditable",
		"dir",
		"draggable",
		"enterkeyhint",
		"hidden",
		"id",
		"inert",
		"inputmode",
		"is",
		"itemid",
		"itemprop",
		"itemref",
		"itemscope",
		"itemtype",
		"lang",
		"nonce",
		"popover",
		"slot",
		"spellcheck",
		"style",
		"tabindex",
		"title",
		"translate",
		"writingsuggestions"
	])],
	["a", new Set([
		"charset",
		"coords",
		"download",
		"href",
		"hreflang",
		"name",
		"ping",
		"referrerpolicy",
		"rel",
		"rev",
		"shape",
		"target",
		"type"
	])],
	["applet", new Set([
		"align",
		"alt",
		"archive",
		"code",
		"codebase",
		"height",
		"hspace",
		"name",
		"object",
		"vspace",
		"width"
	])],
	["area", new Set([
		"alt",
		"coords",
		"download",
		"href",
		"hreflang",
		"nohref",
		"ping",
		"referrerpolicy",
		"rel",
		"shape",
		"target",
		"type"
	])],
	["audio", new Set([
		"autoplay",
		"controls",
		"crossorigin",
		"loop",
		"muted",
		"preload",
		"src"
	])],
	["base", new Set(["href", "target"])],
	["basefont", new Set([
		"color",
		"face",
		"size"
	])],
	["blockquote", new Set(["cite"])],
	["body", new Set([
		"alink",
		"background",
		"bgcolor",
		"link",
		"text",
		"vlink"
	])],
	["br", new Set(["clear"])],
	["button", new Set([
		"disabled",
		"form",
		"formaction",
		"formenctype",
		"formmethod",
		"formnovalidate",
		"formtarget",
		"name",
		"popovertarget",
		"popovertargetaction",
		"type",
		"value"
	])],
	["canvas", new Set(["height", "width"])],
	["caption", new Set(["align"])],
	["col", new Set([
		"align",
		"char",
		"charoff",
		"span",
		"valign",
		"width"
	])],
	["colgroup", new Set([
		"align",
		"char",
		"charoff",
		"span",
		"valign",
		"width"
	])],
	["data", new Set(["value"])],
	["del", new Set(["cite", "datetime"])],
	["details", new Set(["name", "open"])],
	["dialog", new Set(["open"])],
	["dir", new Set(["compact"])],
	["div", new Set(["align"])],
	["dl", new Set(["compact"])],
	["embed", new Set([
		"height",
		"src",
		"type",
		"width"
	])],
	["fieldset", new Set([
		"disabled",
		"form",
		"name"
	])],
	["font", new Set([
		"color",
		"face",
		"size"
	])],
	["form", new Set([
		"accept",
		"accept-charset",
		"action",
		"autocomplete",
		"enctype",
		"method",
		"name",
		"novalidate",
		"target"
	])],
	["frame", new Set([
		"frameborder",
		"longdesc",
		"marginheight",
		"marginwidth",
		"name",
		"noresize",
		"scrolling",
		"src"
	])],
	["frameset", new Set(["cols", "rows"])],
	["h1", new Set(["align"])],
	["h2", new Set(["align"])],
	["h3", new Set(["align"])],
	["h4", new Set(["align"])],
	["h5", new Set(["align"])],
	["h6", new Set(["align"])],
	["head", new Set(["profile"])],
	["hr", new Set([
		"align",
		"noshade",
		"size",
		"width"
	])],
	["html", new Set(["manifest", "version"])],
	["iframe", new Set([
		"align",
		"allow",
		"allowfullscreen",
		"allowpaymentrequest",
		"allowusermedia",
		"frameborder",
		"height",
		"loading",
		"longdesc",
		"marginheight",
		"marginwidth",
		"name",
		"referrerpolicy",
		"sandbox",
		"scrolling",
		"src",
		"srcdoc",
		"width"
	])],
	["img", new Set([
		"align",
		"alt",
		"border",
		"crossorigin",
		"decoding",
		"fetchpriority",
		"height",
		"hspace",
		"ismap",
		"loading",
		"longdesc",
		"name",
		"referrerpolicy",
		"sizes",
		"src",
		"srcset",
		"usemap",
		"vspace",
		"width"
	])],
	["input", new Set([
		"accept",
		"align",
		"alt",
		"autocomplete",
		"checked",
		"dirname",
		"disabled",
		"form",
		"formaction",
		"formenctype",
		"formmethod",
		"formnovalidate",
		"formtarget",
		"height",
		"ismap",
		"list",
		"max",
		"maxlength",
		"min",
		"minlength",
		"multiple",
		"name",
		"pattern",
		"placeholder",
		"popovertarget",
		"popovertargetaction",
		"readonly",
		"required",
		"size",
		"src",
		"step",
		"type",
		"usemap",
		"value",
		"width"
	])],
	["ins", new Set(["cite", "datetime"])],
	["isindex", new Set(["prompt"])],
	["label", new Set(["for", "form"])],
	["legend", new Set(["align"])],
	["li", new Set(["type", "value"])],
	["link", new Set([
		"as",
		"blocking",
		"charset",
		"color",
		"crossorigin",
		"disabled",
		"fetchpriority",
		"href",
		"hreflang",
		"imagesizes",
		"imagesrcset",
		"integrity",
		"media",
		"referrerpolicy",
		"rel",
		"rev",
		"sizes",
		"target",
		"type"
	])],
	["map", new Set(["name"])],
	["menu", new Set(["compact"])],
	["meta", new Set([
		"charset",
		"content",
		"http-equiv",
		"media",
		"name",
		"scheme"
	])],
	["meter", new Set([
		"high",
		"low",
		"max",
		"min",
		"optimum",
		"value"
	])],
	["object", new Set([
		"align",
		"archive",
		"border",
		"classid",
		"codebase",
		"codetype",
		"data",
		"declare",
		"form",
		"height",
		"hspace",
		"name",
		"standby",
		"type",
		"typemustmatch",
		"usemap",
		"vspace",
		"width"
	])],
	["ol", new Set([
		"compact",
		"reversed",
		"start",
		"type"
	])],
	["optgroup", new Set(["disabled", "label"])],
	["option", new Set([
		"disabled",
		"label",
		"selected",
		"value"
	])],
	["output", new Set([
		"for",
		"form",
		"name"
	])],
	["p", new Set(["align"])],
	["param", new Set([
		"name",
		"type",
		"value",
		"valuetype"
	])],
	["pre", new Set(["width"])],
	["progress", new Set(["max", "value"])],
	["q", new Set(["cite"])],
	["script", new Set([
		"async",
		"blocking",
		"charset",
		"crossorigin",
		"defer",
		"fetchpriority",
		"integrity",
		"language",
		"nomodule",
		"referrerpolicy",
		"src",
		"type"
	])],
	["select", new Set([
		"autocomplete",
		"disabled",
		"form",
		"multiple",
		"name",
		"required",
		"size"
	])],
	["slot", new Set(["name"])],
	["source", new Set([
		"height",
		"media",
		"sizes",
		"src",
		"srcset",
		"type",
		"width"
	])],
	["style", new Set([
		"blocking",
		"media",
		"type"
	])],
	["table", new Set([
		"align",
		"bgcolor",
		"border",
		"cellpadding",
		"cellspacing",
		"frame",
		"rules",
		"summary",
		"width"
	])],
	["tbody", new Set([
		"align",
		"char",
		"charoff",
		"valign"
	])],
	["td", new Set([
		"abbr",
		"align",
		"axis",
		"bgcolor",
		"char",
		"charoff",
		"colspan",
		"headers",
		"height",
		"nowrap",
		"rowspan",
		"scope",
		"valign",
		"width"
	])],
	["template", new Set([
		"shadowrootclonable",
		"shadowrootdelegatesfocus",
		"shadowrootmode"
	])],
	["textarea", new Set([
		"autocomplete",
		"cols",
		"dirname",
		"disabled",
		"form",
		"maxlength",
		"minlength",
		"name",
		"placeholder",
		"readonly",
		"required",
		"rows",
		"wrap"
	])],
	["tfoot", new Set([
		"align",
		"char",
		"charoff",
		"valign"
	])],
	["th", new Set([
		"abbr",
		"align",
		"axis",
		"bgcolor",
		"char",
		"charoff",
		"colspan",
		"headers",
		"height",
		"nowrap",
		"rowspan",
		"scope",
		"valign",
		"width"
	])],
	["thead", new Set([
		"align",
		"char",
		"charoff",
		"valign"
	])],
	["time", new Set(["datetime"])],
	["tr", new Set([
		"align",
		"bgcolor",
		"char",
		"charoff",
		"valign"
	])],
	["track", new Set([
		"default",
		"kind",
		"label",
		"src",
		"srclang"
	])],
	["ul", new Set(["compact", "type"])],
	["video", new Set([
		"autoplay",
		"controls",
		"crossorigin",
		"height",
		"loop",
		"muted",
		"playsinline",
		"poster",
		"preload",
		"src",
		"width"
	])]
]);
var Xs$1 = new Set([
	"a",
	"abbr",
	"acronym",
	"address",
	"applet",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"basefont",
	"bdi",
	"bdo",
	"bgsound",
	"big",
	"blink",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"center",
	"cite",
	"code",
	"col",
	"colgroup",
	"command",
	"content",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"dir",
	"div",
	"dl",
	"dt",
	"element",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"font",
	"footer",
	"form",
	"frame",
	"frameset",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"image",
	"img",
	"input",
	"ins",
	"isindex",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"listing",
	"main",
	"map",
	"mark",
	"marquee",
	"math",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"multicol",
	"nav",
	"nextid",
	"nobr",
	"noembed",
	"noframes",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"plaintext",
	"pre",
	"progress",
	"q",
	"rb",
	"rbc",
	"rp",
	"rt",
	"rtc",
	"ruby",
	"s",
	"samp",
	"script",
	"search",
	"section",
	"select",
	"shadow",
	"slot",
	"small",
	"source",
	"spacer",
	"span",
	"strike",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"tt",
	"u",
	"ul",
	"var",
	"video",
	"wbr",
	"xmp"
]);
function ko(t) {
	if (t.type === "block") {
		if (t.name = w(!1, t.name.toLowerCase(), /\s+/gu, " ").trim(), t.type = "angularControlFlowBlock", !qe$1(t.parameters)) {
			delete t.parameters;
			return;
		}
		for (let e of t.parameters) e.type = "angularControlFlowBlockParameter";
		t.parameters = {
			type: "angularControlFlowBlockParameters",
			children: t.parameters,
			sourceSpan: new h(t.parameters[0].sourceSpan.start, X(!1, t.parameters, -1).sourceSpan.end)
		};
	}
}
function Bo(t) {
	t.type === "letDeclaration" && (t.type = "angularLetDeclaration", t.id = t.name, t.init = {
		type: "angularLetDeclarationInitializer",
		sourceSpan: new h(t.valueSpan.start, t.valueSpan.end),
		value: t.value
	}, delete t.name, delete t.value);
}
function Lo$1(t) {
	(t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function Zs$1(t, e, r) {
	let { name: n, canSelfClose: s = !0, normalizeTagName: i = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: p } = e, { rootNodes: l, errors: f } = zr$1(t, {
		canSelfClose: s,
		allowHtmComponentClosingTags: o,
		isTagNameCaseSensitive: u,
		getTagContentType: p ? (...c) => p(...c) ? I.RAW_TEXT : void 0 : void 0,
		tokenizeAngularBlocks: n === "angular" ? !0 : void 0,
		tokenizeAngularLetDeclaration: n === "angular" ? !0 : void 0
	});
	if (n === "vue") {
		if (l.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html")) return Zs$1(t, ti$1, r);
		let g, y$1 = () => g ?? (g = zr$1(t, {
			canSelfClose: s,
			allowHtmComponentClosingTags: o,
			isTagNameCaseSensitive: u
		})), M$1 = (x) => y$1().rootNodes.find(({ startSourceSpan: V$1 }) => V$1 && V$1.start.offset === x.startSourceSpan.start.offset) ?? x;
		for (let [x, V$1] of l.entries()) {
			let { endSourceSpan: jr$1, startSourceSpan: ri$1 } = V$1;
			if (jr$1 === null) f = y$1().errors, l[x] = M$1(V$1);
			else if (Fo(V$1, r)) {
				let Kr$1 = y$1().errors.find((Qr$1) => Qr$1.span.start.offset > ri$1.start.offset && Qr$1.span.start.offset < jr$1.end.offset);
				Kr$1 && Js(Kr$1), l[x] = M$1(V$1);
			}
		}
	}
	f.length > 0 && Js(f[0]);
	let d = (c) => {
		let g = c.name.startsWith(":") ? c.name.slice(1).split(":")[0] : null, y$1 = c.nameSpan.toString(), M$1 = g !== null && y$1.startsWith(`${g}:`);
		c.name = M$1 ? y$1.slice(g.length + 1) : y$1, c.namespace = g, c.hasExplicitNamespace = M$1;
	}, C = (c) => {
		switch (c.type) {
			case "element":
				d(c);
				for (let g of c.attrs) d(g), g.valueSpan ? (g.value = g.valueSpan.toString(), /["']/u.test(g.value[0]) && (g.value = g.value.slice(1, -1))) : g.value = null;
				break;
			case "comment":
				c.value = c.sourceSpan.toString().slice(4, -3);
				break;
			case "text":
				c.value = c.sourceSpan.toString();
				break;
		}
	}, A$1 = (c, g) => {
		let y$1 = c.toLowerCase();
		return g(y$1) ? y$1 : c;
	}, D$1 = (c) => {
		if (c.type === "element" && (i && (!c.namespace || c.namespace === c.tagDefinition.implicitNamespacePrefix || Se$1(c)) && (c.name = A$1(c.name, (g) => Xs$1.has(g))), a)) for (let g of c.attrs) g.namespace || (g.name = A$1(g.name, (y$1) => or$1.has(c.name) && (or$1.get("*").has(y$1) || or$1.get(c.name).has(y$1))));
	}, R = (c) => {
		c.sourceSpan && c.endSourceSpan && (c.sourceSpan = new h(c.sourceSpan.start, c.endSourceSpan.end));
	}, F = (c) => {
		if (c.type === "element") {
			let g = Ge$1(u ? c.name : c.name.toLowerCase());
			!c.namespace || c.namespace === g.implicitNamespacePrefix || Se$1(c) ? c.tagDefinition = g : c.tagDefinition = Ge$1("");
		}
	};
	return Qt(new class extends ht {
		visitExpansionCase(c, g) {
			n === "angular" && this.visitChildren(g, (y$1) => {
				y$1(c.expression);
			});
		}
		visit(c) {
			C(c), F(c), D$1(c), R(c);
		}
	}(), l), l;
}
function Fo(t, e) {
	var n;
	if (t.type !== "element" || t.name !== "template") return !1;
	let r = (n = t.attrs.find((s) => s.name === "lang")) == null ? void 0 : n.value;
	return !r || Oe$1(e, { language: r }) === "html";
}
function Js(t) {
	let { msg: e, span: { start: r, end: n } } = t;
	throw Ys(e, {
		loc: {
			start: {
				line: r.line + 1,
				column: r.col + 1
			},
			end: {
				line: n.line + 1,
				column: n.col + 1
			}
		},
		cause: t
	});
}
function ei$1(t, e, r = {}, n = !0) {
	let { frontMatter: s, content: i } = n ? js$1(t) : {
		frontMatter: null,
		content: t
	}, a = new Te$1(t, r.filepath), o = new ae$1(a, 0, 0, 0), p = {
		type: "root",
		sourceSpan: new h(o, o.moveBy(t.length)),
		children: Zs$1(i, e, r)
	};
	if (s) {
		let d = new ae$1(a, 0, 0, 0);
		s.sourceSpan = new h(d, d.moveBy(s.raw.length)), p.children.unshift(s);
	}
	let l = new ar(p), f = (d, C) => {
		let { offset: A$1 } = C, F = ei$1(w(!1, t.slice(0, A$1), /[^\n\r]/gu, " ") + d, e, r, !1);
		F.sourceSpan = new h(C, X(!1, F.children, -1).sourceSpan.end);
		let c = F.children[0];
		return c.length === A$1 ? F.children.shift() : (c.sourceSpan = new h(c.sourceSpan.start.moveBy(A$1), c.sourceSpan.end), c.value = c.value.slice(A$1)), F;
	};
	return l.walk((d) => {
		if (d.type === "comment") {
			let C = Qs$1(d, f);
			C && d.parent.replaceChild(d, C);
		}
		ko(d), Bo(d), Lo$1(d);
	}), l;
}
function ur(t) {
	return {
		parse: (e, r) => ei$1(e, t, r),
		hasPragma: os,
		astFormat: "html",
		locStart: se,
		locEnd: ie$1
	};
}
var ti$1 = {
	name: "html",
	normalizeTagName: !0,
	normalizeAttributeName: !0,
	allowHtmComponentClosingTags: !0
}, No = ur(ti$1), Po = ur({ name: "angular" }), Io = ur({
	name: "vue",
	isTagNameCaseSensitive: !0,
	shouldParseAsRawText(t, e, r, n) {
		return t.toLowerCase() !== "html" && !r && (t !== "template" || n.some(({ name: s, value: i }) => s === "lang" && i !== "html" && i !== "" && i !== void 0));
	}
}), Ro = ur({
	name: "lwc",
	canSelfClose: !1
});
var $o = { html: As$1 };
var Ih = Yr$1;
var al = Object.create;
var Ur = Object.defineProperty;
var ul = Object.getOwnPropertyDescriptor;
var ll = Object.getOwnPropertyNames;
var cl = Object.getPrototypeOf, fl = Object.prototype.hasOwnProperty;
var y = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Xs = (t, e) => {
	for (var s in e) Ur(t, s, {
		get: e[s],
		enumerable: !0
	});
}, pl = (t, e, s, r) => {
	if (e && typeof e == "object" || typeof e == "function") for (let n of ll(e)) !fl.call(t, n) && n !== s && Ur(t, n, {
		get: () => e[n],
		enumerable: !(r = ul(e, n)) || r.enumerable
	});
	return t;
};
var ye = (t, e, s) => (s = t != null ? al(cl(t)) : {}, pl(e || !t || !t.__esModule ? Ur(s, "default", {
	value: t,
	enumerable: !0
}) : s, t));
var Ut = y((tv, ts$1) => {
	ts$1.exports.isClean = Symbol("isClean");
	ts$1.exports.my = Symbol("my");
});
var yi = y((rv, rs$1) => {
	var S$2 = String, mi = function() {
		return {
			isColorSupported: !1,
			reset: S$2,
			bold: S$2,
			dim: S$2,
			italic: S$2,
			underline: S$2,
			inverse: S$2,
			hidden: S$2,
			strikethrough: S$2,
			black: S$2,
			red: S$2,
			green: S$2,
			yellow: S$2,
			blue: S$2,
			magenta: S$2,
			cyan: S$2,
			white: S$2,
			gray: S$2,
			bgBlack: S$2,
			bgRed: S$2,
			bgGreen: S$2,
			bgYellow: S$2,
			bgBlue: S$2,
			bgMagenta: S$2,
			bgCyan: S$2,
			bgWhite: S$2
		};
	};
	rs$1.exports = mi();
	rs$1.exports.createColors = mi;
});
var ss = y(() => {});
var Ft = y((iv, vi$1) => {
	var wi$1 = yi(), gi$1 = ss(), st$1 = class t extends Error {
		constructor(e, s, r, n, i, o) {
			super(e), this.name = "CssSyntaxError", this.reason = e, i && (this.file = i), n && (this.source = n), o && (this.plugin = o), typeof s < "u" && typeof r < "u" && (typeof s == "number" ? (this.line = s, this.column = r) : (this.line = s.line, this.column = s.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
		}
		setMessage() {
			this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
		}
		showSourceCode(e) {
			if (!this.source) return "";
			let s = this.source;
			e ??= wi$1.isColorSupported, gi$1 && e && (s = gi$1(s));
			let r = s.split(/\r?\n/), n = Math.max(this.line - 3, 0), i = Math.min(this.line + 2, r.length), o = String(i).length, a, u;
			if (e) {
				let { bold: c, gray: f, red: p } = wi$1.createColors(!0);
				a = (l) => c(p(l)), u = (l) => f(l);
			} else a = u = (c) => c;
			return r.slice(n, i).map((c, f) => {
				let p = n + 1 + f, l = " " + (" " + p).slice(-o) + " | ";
				if (p === this.line) {
					let w$1 = u(l.replace(/\d/g, " ")) + c.slice(0, this.column - 1).replace(/[^\t]/g, " ");
					return a(">") + u(l) + c + `
 ` + w$1 + a("^");
				}
				return " " + u(l) + c;
			}).join(`
`);
		}
		toString() {
			let e = this.showSourceCode();
			return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
		}
	};
	vi$1.exports = st$1;
	st$1.default = st$1;
});
var $t = y((ov, bi$1) => {
	var xi$1 = {
		after: `
`,
		beforeClose: `
`,
		beforeComment: `
`,
		beforeDecl: `
`,
		beforeOpen: " ",
		beforeRule: `
`,
		colon: ": ",
		commentLeft: " ",
		commentRight: " ",
		emptyBody: "",
		indent: "    ",
		semicolon: !1
	};
	function lc(t) {
		return t[0].toUpperCase() + t.slice(1);
	}
	var nt$1 = class {
		constructor(e) {
			this.builder = e;
		}
		atrule(e, s) {
			let r = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
			if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : n && (r += " "), e.nodes) this.block(e, r + n);
			else {
				let i = (e.raws.between || "") + (s ? ";" : "");
				this.builder(r + n + i, e);
			}
		}
		beforeAfter(e, s) {
			let r;
			e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : s === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
			let n = e.parent, i = 0;
			for (; n && n.type !== "root";) i += 1, n = n.parent;
			if (r.includes(`
`)) {
				let o = this.raw(e, null, "indent");
				if (o.length) for (let a = 0; a < i; a++) r += o;
			}
			return r;
		}
		block(e, s) {
			let r = this.raw(e, "between", "beforeOpen");
			this.builder(s + r + "{", e, "start");
			let n;
			e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
		}
		body(e) {
			let s = e.nodes.length - 1;
			for (; s > 0 && e.nodes[s].type === "comment";) s -= 1;
			let r = this.raw(e, "semicolon");
			for (let n = 0; n < e.nodes.length; n++) {
				let i = e.nodes[n], o = this.raw(i, "before");
				o && this.builder(o), this.stringify(i, s !== n || r);
			}
		}
		comment(e) {
			let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
			this.builder("/*" + s + e.text + r + "*/", e);
		}
		decl(e, s) {
			let r = this.raw(e, "between", "colon"), n = e.prop + r + this.rawValue(e, "value");
			e.important && (n += e.raws.important || " !important"), s && (n += ";"), this.builder(n, e);
		}
		document(e) {
			this.body(e);
		}
		raw(e, s, r) {
			let n;
			if (r || (r = s), s && (n = e.raws[s], typeof n < "u")) return n;
			let i = e.parent;
			if (r === "before" && (!i || i.type === "root" && i.first === e || i && i.type === "document")) return "";
			if (!i) return xi$1[r];
			let o = e.root();
			if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[r] < "u") return o.rawCache[r];
			if (r === "before" || r === "after") return this.beforeAfter(e, r);
			{
				let a = "raw" + lc(r);
				this[a] ? n = this[a](o, e) : o.walk((u) => {
					if (n = u.raws[s], typeof n < "u") return !1;
				});
			}
			return typeof n > "u" && (n = xi$1[r]), o.rawCache[r] = n, n;
		}
		rawBeforeClose(e) {
			let s;
			return e.walk((r) => {
				if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u") return s = r.raws.after, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
			}), s && (s = s.replace(/\S/g, "")), s;
		}
		rawBeforeComment(e, s) {
			let r;
			return e.walkComments((n) => {
				if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
			}), typeof r > "u" ? r = this.raw(s, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
		}
		rawBeforeDecl(e, s) {
			let r;
			return e.walkDecls((n) => {
				if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
			}), typeof r > "u" ? r = this.raw(s, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
		}
		rawBeforeOpen(e) {
			let s;
			return e.walk((r) => {
				if (r.type !== "decl" && (s = r.raws.between, typeof s < "u")) return !1;
			}), s;
		}
		rawBeforeRule(e) {
			let s;
			return e.walk((r) => {
				if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u") return s = r.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
			}), s && (s = s.replace(/\S/g, "")), s;
		}
		rawColon(e) {
			let s;
			return e.walkDecls((r) => {
				if (typeof r.raws.between < "u") return s = r.raws.between.replace(/[^\s:]/g, ""), !1;
			}), s;
		}
		rawEmptyBody(e) {
			let s;
			return e.walk((r) => {
				if (r.nodes && r.nodes.length === 0 && (s = r.raws.after, typeof s < "u")) return !1;
			}), s;
		}
		rawIndent(e) {
			if (e.raws.indent) return e.raws.indent;
			let s;
			return e.walk((r) => {
				let n = r.parent;
				if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < "u") {
					let i = r.raws.before.split(`
`);
					return s = i[i.length - 1], s = s.replace(/\S/g, ""), !1;
				}
			}), s;
		}
		rawSemicolon(e) {
			let s;
			return e.walk((r) => {
				if (r.nodes && r.nodes.length && r.last.type === "decl" && (s = r.raws.semicolon, typeof s < "u")) return !1;
			}), s;
		}
		rawValue(e, s) {
			let r = e[s], n = e.raws[s];
			return n && n.value === r ? n.raw : r;
		}
		root(e) {
			this.body(e), e.raws.after && this.builder(e.raws.after);
		}
		rule(e) {
			this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
		}
		stringify(e, s) {
			if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
			this[e.type](e, s);
		}
	};
	bi$1.exports = nt$1;
	nt$1.default = nt$1;
});
var it = y((av, _i$1) => {
	var cc = $t();
	function ns$1(t, e) {
		new cc(e).stringify(t);
	}
	_i$1.exports = ns$1;
	ns$1.default = ns$1;
});
var at = y((uv, ki$1) => {
	var { isClean: Wt$1, my: fc } = Ut(), pc = Ft(), hc = $t(), dc = it();
	function is(t, e) {
		let s = new t.constructor();
		for (let r in t) {
			if (!Object.prototype.hasOwnProperty.call(t, r) || r === "proxyCache") continue;
			let n = t[r], i = typeof n;
			r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : Array.isArray(n) ? s[r] = n.map((o) => is(o, s)) : (i === "object" && n !== null && (n = is(n)), s[r] = n);
		}
		return s;
	}
	var ot$1 = class {
		constructor(e = {}) {
			this.raws = {}, this[Wt$1] = !1, this[fc] = !0;
			for (let s in e) if (s === "nodes") {
				this.nodes = [];
				for (let r of e[s]) typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
			} else this[s] = e[s];
		}
		addToError(e) {
			if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
				let s = this.source;
				e.stack = e.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
			}
			return e;
		}
		after(e) {
			return this.parent.insertAfter(this, e), this;
		}
		assign(e = {}) {
			for (let s in e) this[s] = e[s];
			return this;
		}
		before(e) {
			return this.parent.insertBefore(this, e), this;
		}
		cleanRaws(e) {
			delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
		}
		clone(e = {}) {
			let s = is(this);
			for (let r in e) s[r] = e[r];
			return s;
		}
		cloneAfter(e = {}) {
			let s = this.clone(e);
			return this.parent.insertAfter(this, s), s;
		}
		cloneBefore(e = {}) {
			let s = this.clone(e);
			return this.parent.insertBefore(this, s), s;
		}
		error(e, s = {}) {
			if (this.source) {
				let { end: r, start: n } = this.rangeBy(s);
				return this.source.input.error(e, {
					column: n.column,
					line: n.line
				}, {
					column: r.column,
					line: r.line
				}, s);
			}
			return new pc(e);
		}
		getProxyProcessor() {
			return {
				get(e, s) {
					return s === "proxyOf" ? e : s === "root" ? () => e.root().toProxy() : e[s];
				},
				set(e, s, r) {
					return e[s] === r || (e[s] = r, (s === "prop" || s === "value" || s === "name" || s === "params" || s === "important" || s === "text") && e.markDirty()), !0;
				}
			};
		}
		markDirty() {
			if (this[Wt$1]) {
				this[Wt$1] = !1;
				let e = this;
				for (; e = e.parent;) e[Wt$1] = !1;
			}
		}
		next() {
			if (!this.parent) return;
			let e = this.parent.index(this);
			return this.parent.nodes[e + 1];
		}
		positionBy(e, s) {
			let r = this.source.start;
			if (e.index) r = this.positionInside(e.index, s);
			else if (e.word) {
				s = this.toString();
				let n = s.indexOf(e.word);
				n !== -1 && (r = this.positionInside(n, s));
			}
			return r;
		}
		positionInside(e, s) {
			let r = s || this.toString(), n = this.source.start.column, i = this.source.start.line;
			for (let o = 0; o < e; o++) r[o] === `
` ? (n = 1, i += 1) : n += 1;
			return {
				column: n,
				line: i
			};
		}
		prev() {
			if (!this.parent) return;
			let e = this.parent.index(this);
			return this.parent.nodes[e - 1];
		}
		rangeBy(e) {
			let s = {
				column: this.source.start.column,
				line: this.source.start.line
			}, r = this.source.end ? {
				column: this.source.end.column + 1,
				line: this.source.end.line
			} : {
				column: s.column + 1,
				line: s.line
			};
			if (e.word) {
				let n = this.toString(), i = n.indexOf(e.word);
				i !== -1 && (s = this.positionInside(i, n), r = this.positionInside(i + e.word.length, n));
			} else e.start ? s = {
				column: e.start.column,
				line: e.start.line
			} : e.index && (s = this.positionInside(e.index)), e.end ? r = {
				column: e.end.column,
				line: e.end.line
			} : typeof e.endIndex == "number" ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
			return (r.line < s.line || r.line === s.line && r.column <= s.column) && (r = {
				column: s.column + 1,
				line: s.line
			}), {
				end: r,
				start: s
			};
		}
		raw(e, s) {
			return new hc().raw(this, e, s);
		}
		remove() {
			return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
		}
		replaceWith(...e) {
			if (this.parent) {
				let s = this, r = !1;
				for (let n of e) n === this ? r = !0 : r ? (this.parent.insertAfter(s, n), s = n) : this.parent.insertBefore(s, n);
				r || this.remove();
			}
			return this;
		}
		root() {
			let e = this;
			for (; e.parent && e.parent.type !== "document";) e = e.parent;
			return e;
		}
		toJSON(e, s) {
			let r = {}, n = s == null;
			s = s || /* @__PURE__ */ new Map();
			let i = 0;
			for (let o in this) {
				if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
				let a = this[o];
				if (Array.isArray(a)) r[o] = a.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, s) : u);
				else if (typeof a == "object" && a.toJSON) r[o] = a.toJSON(null, s);
				else if (o === "source") {
					let u = s.get(a.input);
					u ?? (u = i, s.set(a.input, i), i++), r[o] = {
						end: a.end,
						inputId: u,
						start: a.start
					};
				} else r[o] = a;
			}
			return n && (r.inputs = [...s.keys()].map((o) => o.toJSON())), r;
		}
		toProxy() {
			return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
		}
		toString(e = dc) {
			e.stringify && (e = e.stringify);
			let s = "";
			return e(this, (r) => {
				s += r;
			}), s;
		}
		warn(e, s, r) {
			let n = { node: this };
			for (let i in r) n[i] = r[i];
			return e.warn(s, n);
		}
		get proxyOf() {
			return this;
		}
	};
	ki$1.exports = ot$1;
	ot$1.default = ot$1;
});
var lt = y((lv, Ei$1) => {
	var mc = at(), ut$1 = class extends mc {
		constructor(e) {
			e && typeof e.value < "u" && typeof e.value != "string" && (e = {
				...e,
				value: String(e.value)
			}), super(e), this.type = "decl";
		}
		get variable() {
			return this.prop.startsWith("--") || this.prop[0] === "$";
		}
	};
	Ei$1.exports = ut$1;
	ut$1.default = ut$1;
});
var Oe = y((cv, Si$1) => {
	var yc = at(), ct$1 = class extends yc {
		constructor(e) {
			super(e), this.type = "comment";
		}
	};
	Si$1.exports = ct$1;
	ct$1.default = ct$1;
});
var re = y((fv, qi$1) => {
	var { isClean: Ti$1, my: Oi$1 } = Ut(), Ci$1 = lt(), Ai$1 = Oe(), wc = at(), Ni$1, os$1, as$1, Pi$1;
	function Ri$1(t) {
		return t.map((e) => (e.nodes && (e.nodes = Ri$1(e.nodes)), delete e.source, e));
	}
	function Ii$1(t) {
		if (t[Ti$1] = !1, t.proxyOf.nodes) for (let e of t.proxyOf.nodes) Ii$1(e);
	}
	var Y$1 = class t extends wc {
		append(...e) {
			for (let s of e) {
				let r = this.normalize(s, this.last);
				for (let n of r) this.proxyOf.nodes.push(n);
			}
			return this.markDirty(), this;
		}
		cleanRaws(e) {
			if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
		}
		each(e) {
			if (!this.proxyOf.nodes) return;
			let s = this.getIterator(), r, n;
			for (; this.indexes[s] < this.proxyOf.nodes.length && (r = this.indexes[s], n = e(this.proxyOf.nodes[r], r), n !== !1);) this.indexes[s] += 1;
			return delete this.indexes[s], n;
		}
		every(e) {
			return this.nodes.every(e);
		}
		getIterator() {
			this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
			let e = this.lastEach;
			return this.indexes[e] = 0, e;
		}
		getProxyProcessor() {
			return {
				get(e, s) {
					return s === "proxyOf" ? e : e[s] ? s === "each" || typeof s == "string" && s.startsWith("walk") ? (...r) => e[s](...r.map((n) => typeof n == "function" ? (i, o) => n(i.toProxy(), o) : n)) : s === "every" || s === "some" ? (r) => e[s]((n, ...i) => r(n.toProxy(), ...i)) : s === "root" ? () => e.root().toProxy() : s === "nodes" ? e.nodes.map((r) => r.toProxy()) : s === "first" || s === "last" ? e[s].toProxy() : e[s] : e[s];
				},
				set(e, s, r) {
					return e[s] === r || (e[s] = r, (s === "name" || s === "params" || s === "selector") && e.markDirty()), !0;
				}
			};
		}
		index(e) {
			return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
		}
		insertAfter(e, s) {
			let r = this.index(e), n = this.normalize(s, this.proxyOf.nodes[r]).reverse();
			r = this.index(e);
			for (let o of n) this.proxyOf.nodes.splice(r + 1, 0, o);
			let i;
			for (let o in this.indexes) i = this.indexes[o], r < i && (this.indexes[o] = i + n.length);
			return this.markDirty(), this;
		}
		insertBefore(e, s) {
			let r = this.index(e), n = r === 0 ? "prepend" : !1, i = this.normalize(s, this.proxyOf.nodes[r], n).reverse();
			r = this.index(e);
			for (let a of i) this.proxyOf.nodes.splice(r, 0, a);
			let o;
			for (let a in this.indexes) o = this.indexes[a], r <= o && (this.indexes[a] = o + i.length);
			return this.markDirty(), this;
		}
		normalize(e, s) {
			if (typeof e == "string") e = Ri$1(Ni$1(e).nodes);
			else if (typeof e > "u") e = [];
			else if (Array.isArray(e)) {
				e = e.slice(0);
				for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
			} else if (e.type === "root" && this.type !== "document") {
				e = e.nodes.slice(0);
				for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
			} else if (e.type) e = [e];
			else if (e.prop) {
				if (typeof e.value > "u") throw new Error("Value field is missed in node creation");
				typeof e.value != "string" && (e.value = String(e.value)), e = [new Ci$1(e)];
			} else if (e.selector) e = [new os$1(e)];
			else if (e.name) e = [new as$1(e)];
			else if (e.text) e = [new Ai$1(e)];
			else throw new Error("Unknown node type in node creation");
			return e.map((n) => (n[Oi$1] || t.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[Ti$1] && Ii$1(n), typeof n.raws.before > "u" && s && typeof s.raws.before < "u" && (n.raws.before = s.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
		}
		prepend(...e) {
			e = e.reverse();
			for (let s of e) {
				let r = this.normalize(s, this.first, "prepend").reverse();
				for (let n of r) this.proxyOf.nodes.unshift(n);
				for (let n in this.indexes) this.indexes[n] = this.indexes[n] + r.length;
			}
			return this.markDirty(), this;
		}
		push(e) {
			return e.parent = this, this.proxyOf.nodes.push(e), this;
		}
		removeAll() {
			for (let e of this.proxyOf.nodes) e.parent = void 0;
			return this.proxyOf.nodes = [], this.markDirty(), this;
		}
		removeChild(e) {
			e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
			let s;
			for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
			return this.markDirty(), this;
		}
		replaceValues(e, s, r) {
			return r || (r = s, s = {}), this.walkDecls((n) => {
				s.props && !s.props.includes(n.prop) || s.fast && !n.value.includes(s.fast) || (n.value = n.value.replace(e, r));
			}), this.markDirty(), this;
		}
		some(e) {
			return this.nodes.some(e);
		}
		walk(e) {
			return this.each((s, r) => {
				let n;
				try {
					n = e(s, r);
				} catch (i) {
					throw s.addToError(i);
				}
				return n !== !1 && s.walk && (n = s.walk(e)), n;
			});
		}
		walkAtRules(e, s) {
			return s ? e instanceof RegExp ? this.walk((r, n) => {
				if (r.type === "atrule" && e.test(r.name)) return s(r, n);
			}) : this.walk((r, n) => {
				if (r.type === "atrule" && r.name === e) return s(r, n);
			}) : (s = e, this.walk((r, n) => {
				if (r.type === "atrule") return s(r, n);
			}));
		}
		walkComments(e) {
			return this.walk((s, r) => {
				if (s.type === "comment") return e(s, r);
			});
		}
		walkDecls(e, s) {
			return s ? e instanceof RegExp ? this.walk((r, n) => {
				if (r.type === "decl" && e.test(r.prop)) return s(r, n);
			}) : this.walk((r, n) => {
				if (r.type === "decl" && r.prop === e) return s(r, n);
			}) : (s = e, this.walk((r, n) => {
				if (r.type === "decl") return s(r, n);
			}));
		}
		walkRules(e, s) {
			return s ? e instanceof RegExp ? this.walk((r, n) => {
				if (r.type === "rule" && e.test(r.selector)) return s(r, n);
			}) : this.walk((r, n) => {
				if (r.type === "rule" && r.selector === e) return s(r, n);
			}) : (s = e, this.walk((r, n) => {
				if (r.type === "rule") return s(r, n);
			}));
		}
		get first() {
			if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
		}
		get last() {
			if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
		}
	};
	Y$1.registerParse = (t) => {
		Ni$1 = t;
	};
	Y$1.registerRule = (t) => {
		os$1 = t;
	};
	Y$1.registerAtRule = (t) => {
		as$1 = t;
	};
	Y$1.registerRoot = (t) => {
		Pi$1 = t;
	};
	qi$1.exports = Y$1;
	Y$1.default = Y$1;
	Y$1.rebuild = (t) => {
		t.type === "atrule" ? Object.setPrototypeOf(t, as$1.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, os$1.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, Ci$1.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, Ai$1.prototype) : t.type === "root" && Object.setPrototypeOf(t, Pi$1.prototype), t[Oi$1] = !0, t.nodes && t.nodes.forEach((e) => {
			Y$1.rebuild(e);
		});
	};
});
var Vt = y((pv, Di$1) => {
	var Yt$1 = /[\t\n\f\r "#'()/;[\\\]{}]/g, zt$1 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, gc = /.[\r\n"'(/\\]/, Li$1 = /[\da-f]/i;
	Di$1.exports = function(e, s = {}) {
		let r = e.css.valueOf(), n = s.ignoreErrors, i, o, a, u, c, f, p, l, w$1, x, h$1 = r.length, d = 0, m$1 = [], b$1 = [];
		function g() {
			return d;
		}
		function v$1($$1) {
			throw e.error("Unclosed " + $$1, d);
		}
		function R() {
			return b$1.length === 0 && d >= h$1;
		}
		function F($$1) {
			if (b$1.length) return b$1.pop();
			if (d >= h$1) return;
			let T$1 = $$1 ? $$1.ignoreUnclosed : !1;
			switch (i = r.charCodeAt(d), i) {
				case 10:
				case 32:
				case 9:
				case 13:
				case 12:
					o = d;
					do
						o += 1, i = r.charCodeAt(o);
					while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
					x = ["space", r.slice(d, o)], d = o - 1;
					break;
				case 91:
				case 93:
				case 123:
				case 125:
				case 58:
				case 59:
				case 41: {
					let O = String.fromCharCode(i);
					x = [
						O,
						O,
						d
					];
					break;
				}
				case 40:
					if (l = m$1.length ? m$1.pop()[1] : "", w$1 = r.charCodeAt(d + 1), l === "url" && w$1 !== 39 && w$1 !== 34 && w$1 !== 32 && w$1 !== 10 && w$1 !== 9 && w$1 !== 12 && w$1 !== 13) {
						o = d;
						do {
							if (f = !1, o = r.indexOf(")", o + 1), o === -1) if (n || T$1) {
								o = d;
								break;
							} else v$1("bracket");
							for (p = o; r.charCodeAt(p - 1) === 92;) p -= 1, f = !f;
						} while (f);
						x = [
							"brackets",
							r.slice(d, o + 1),
							d,
							o
						], d = o;
					} else o = r.indexOf(")", d + 1), u = r.slice(d, o + 1), o === -1 || gc.test(u) ? x = [
						"(",
						"(",
						d
					] : (x = [
						"brackets",
						u,
						d,
						o
					], d = o);
					break;
				case 39:
				case 34:
					a = i === 39 ? "'" : "\"", o = d;
					do {
						if (f = !1, o = r.indexOf(a, o + 1), o === -1) if (n || T$1) {
							o = d + 1;
							break;
						} else v$1("string");
						for (p = o; r.charCodeAt(p - 1) === 92;) p -= 1, f = !f;
					} while (f);
					x = [
						"string",
						r.slice(d, o + 1),
						d,
						o
					], d = o;
					break;
				case 64:
					Yt$1.lastIndex = d + 1, Yt$1.test(r), Yt$1.lastIndex === 0 ? o = r.length - 1 : o = Yt$1.lastIndex - 2, x = [
						"at-word",
						r.slice(d, o + 1),
						d,
						o
					], d = o;
					break;
				case 92:
					for (o = d, c = !0; r.charCodeAt(o + 1) === 92;) o += 1, c = !c;
					if (i = r.charCodeAt(o + 1), c && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (o += 1, Li$1.test(r.charAt(o)))) {
						for (; Li$1.test(r.charAt(o + 1));) o += 1;
						r.charCodeAt(o + 1) === 32 && (o += 1);
					}
					x = [
						"word",
						r.slice(d, o + 1),
						d,
						o
					], d = o;
					break;
				default:
					i === 47 && r.charCodeAt(d + 1) === 42 ? (o = r.indexOf("*/", d + 2) + 1, o === 0 && (n || T$1 ? o = r.length : v$1("comment")), x = [
						"comment",
						r.slice(d, o + 1),
						d,
						o
					], d = o) : (zt$1.lastIndex = d + 1, zt$1.test(r), zt$1.lastIndex === 0 ? o = r.length - 1 : o = zt$1.lastIndex - 2, x = [
						"word",
						r.slice(d, o + 1),
						d,
						o
					], m$1.push(x), d = o);
					break;
			}
			return d++, x;
		}
		function H$1($$1) {
			b$1.push($$1);
		}
		return {
			back: H$1,
			endOfFile: R,
			nextToken: F,
			position: g
		};
	};
});
var Gt = y((hv, Bi$1) => {
	var Mi$1 = re(), Ce$1 = class extends Mi$1 {
		constructor(e) {
			super(e), this.type = "atrule";
		}
		append(...e) {
			return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
		}
		prepend(...e) {
			return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
		}
	};
	Bi$1.exports = Ce$1;
	Ce$1.default = Ce$1;
	Mi$1.registerAtRule(Ce$1);
});
var Ae = y((dv, Wi$1) => {
	var Ui$1 = re(), Fi$1, $i$1, se$1 = class extends Ui$1 {
		constructor(e) {
			super(e), this.type = "root", this.nodes || (this.nodes = []);
		}
		normalize(e, s, r) {
			let n = super.normalize(e);
			if (s) {
				if (r === "prepend") this.nodes.length > 1 ? s.raws.before = this.nodes[1].raws.before : delete s.raws.before;
				else if (this.first !== s) for (let i of n) i.raws.before = s.raws.before;
			}
			return n;
		}
		removeChild(e, s) {
			let r = this.index(e);
			return !s && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
		}
		toResult(e = {}) {
			return new Fi$1(new $i$1(), this, e).stringify();
		}
	};
	se$1.registerLazyResult = (t) => {
		Fi$1 = t;
	};
	se$1.registerProcessor = (t) => {
		$i$1 = t;
	};
	Wi$1.exports = se$1;
	se$1.default = se$1;
	Ui$1.registerRoot(se$1);
});
var us = y((mv, Yi$1) => {
	var ft$1 = {
		comma(t) {
			return ft$1.split(t, [","], !0);
		},
		space(t) {
			return ft$1.split(t, [
				" ",
				`
`,
				"	"
			]);
		},
		split(t, e, s) {
			let r = [], n = "", i = !1, o = 0, a = !1, u = "", c = !1;
			for (let f of t) c ? c = !1 : f === "\\" ? c = !0 : a ? f === u && (a = !1) : f === "\"" || f === "'" ? (a = !0, u = f) : f === "(" ? o += 1 : f === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(f) && (i = !0), i ? (n !== "" && r.push(n.trim()), n = "", i = !1) : n += f;
			return (s || n !== "") && r.push(n.trim()), r;
		}
	};
	Yi$1.exports = ft$1;
	ft$1.default = ft$1;
});
var jt = y((yv, Vi$1) => {
	var zi$1 = re(), vc = us(), Ne$1 = class extends zi$1 {
		constructor(e) {
			super(e), this.type = "rule", this.nodes || (this.nodes = []);
		}
		get selectors() {
			return vc.comma(this.selector);
		}
		set selectors(e) {
			let s = this.selector ? this.selector.match(/,\s*/) : null, r = s ? s[0] : "," + this.raw("between", "beforeOpen");
			this.selector = e.join(r);
		}
	};
	Vi$1.exports = Ne$1;
	Ne$1.default = Ne$1;
	zi$1.registerRule(Ne$1);
});
var Ht = y((wv, Hi$1) => {
	var xc = lt(), bc = Vt(), _c = Oe(), kc = Gt(), Ec = Ae(), Gi$1 = jt(), ji$1 = {
		empty: !0,
		space: !0
	};
	function Sc(t) {
		for (let e = t.length - 1; e >= 0; e--) {
			let s = t[e], r = s[3] || s[2];
			if (r) return r;
		}
	}
	var ls$1 = class {
		constructor(e) {
			this.input = e, this.root = new Ec(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = {
				input: e,
				start: {
					column: 1,
					line: 1,
					offset: 0
				}
			};
		}
		atrule(e) {
			let s = new kc();
			s.name = e[1].slice(1), s.name === "" && this.unnamedAtrule(s, e), this.init(s, e[2]);
			let r, n, i, o = !1, a = !1, u = [], c = [];
			for (; !this.tokenizer.endOfFile();) {
				if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? c.push(r === "(" ? ")" : "]") : r === "{" && c.length > 0 ? c.push("}") : r === c[c.length - 1] && c.pop(), c.length === 0) if (r === ";") {
					s.source.end = this.getPosition(e[2]), s.source.end.offset++, this.semicolon = !0;
					break;
				} else if (r === "{") {
					a = !0;
					break;
				} else if (r === "}") {
					if (u.length > 0) {
						for (i = u.length - 1, n = u[i]; n && n[0] === "space";) n = u[--i];
						n && (s.source.end = this.getPosition(n[3] || n[2]), s.source.end.offset++);
					}
					this.end(e);
					break;
				} else u.push(e);
				else u.push(e);
				if (this.tokenizer.endOfFile()) {
					o = !0;
					break;
				}
			}
			s.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (s.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(s, "params", u), o && (e = u[u.length - 1], s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++, this.spaces = s.raws.between, s.raws.between = "")) : (s.raws.afterName = "", s.params = ""), a && (s.nodes = [], this.current = s);
		}
		checkMissedSemicolon(e) {
			let s = this.colon(e);
			if (s === !1) return;
			let r = 0, n;
			for (let i = s - 1; i >= 0 && (n = e[i], !(n[0] !== "space" && (r += 1, r === 2))); i--);
			throw this.input.error("Missed semicolon", n[0] === "word" ? n[3] + 1 : n[2]);
		}
		colon(e) {
			let s = 0, r, n, i;
			for (let [o, a] of e.entries()) {
				if (r = a, n = r[0], n === "(" && (s += 1), n === ")" && (s -= 1), s === 0 && n === ":") if (!i) this.doubleColon(r);
				else {
					if (i[0] === "word" && i[1] === "progid") continue;
					return o;
				}
				i = r;
			}
			return !1;
		}
		comment(e) {
			let s = new _c();
			this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++;
			let r = e[1].slice(2, -2);
			if (/^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
			else {
				let n = r.match(/^(\s*)([^]*\S)(\s*)$/);
				s.text = n[2], s.raws.left = n[1], s.raws.right = n[3];
			}
		}
		createTokenizer() {
			this.tokenizer = bc(this.input);
		}
		decl(e, s) {
			let r = new xc();
			this.init(r, e[0][2]);
			let n = e[e.length - 1];
			for (n[0] === ";" && (this.semicolon = !0, e.pop()), r.source.end = this.getPosition(n[3] || n[2] || Sc(e)), r.source.end.offset++; e[0][0] !== "word";) e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
			for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length;) {
				let c = e[0][0];
				if (c === ":" || c === "space" || c === "comment") break;
				r.prop += e.shift()[1];
			}
			r.raws.between = "";
			let i;
			for (; e.length;) if (i = e.shift(), i[0] === ":") {
				r.raws.between += i[1];
				break;
			} else i[0] === "word" && /\w/.test(i[1]) && this.unknownWord([i]), r.raws.between += i[1];
			(r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
			let o = [], a;
			for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment"));) o.push(e.shift());
			this.precheckMissedSemicolon(e);
			for (let c = e.length - 1; c >= 0; c--) {
				if (i = e[c], i[1].toLowerCase() === "!important") {
					r.important = !0;
					let f = this.stringFrom(e, c);
					f = this.spacesFromEnd(e) + f, f !== " !important" && (r.raws.important = f);
					break;
				} else if (i[1].toLowerCase() === "important") {
					let f = e.slice(0), p = "";
					for (let l = c; l > 0; l--) {
						let w$1 = f[l][0];
						if (p.trim().indexOf("!") === 0 && w$1 !== "space") break;
						p = f.pop()[1] + p;
					}
					p.trim().indexOf("!") === 0 && (r.important = !0, r.raws.important = p, e = f);
				}
				if (i[0] !== "space" && i[0] !== "comment") break;
			}
			e.some((c) => c[0] !== "space" && c[0] !== "comment") && (r.raws.between += o.map((c) => c[1]).join(""), o = []), this.raw(r, "value", o.concat(e), s), r.value.includes(":") && !s && this.checkMissedSemicolon(e);
		}
		doubleColon(e) {
			throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
		}
		emptyRule(e) {
			let s = new Gi$1();
			this.init(s, e[2]), s.selector = "", s.raws.between = "", this.current = s;
		}
		end(e) {
			this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
		}
		endFile() {
			this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
		}
		freeSemicolon(e) {
			if (this.spaces += e[1], this.current.nodes) {
				let s = this.current.nodes[this.current.nodes.length - 1];
				s && s.type === "rule" && !s.raws.ownSemicolon && (s.raws.ownSemicolon = this.spaces, this.spaces = "");
			}
		}
		getPosition(e) {
			let s = this.input.fromOffset(e);
			return {
				column: s.col,
				line: s.line,
				offset: e
			};
		}
		init(e, s) {
			this.current.push(e), e.source = {
				input: this.input,
				start: this.getPosition(s)
			}, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
		}
		other(e) {
			let s = !1, r = null, n = !1, i = null, o = [], a = e[1].startsWith("--"), u = [], c = e;
			for (; c;) {
				if (r = c[0], u.push(c), r === "(" || r === "[") i || (i = c), o.push(r === "(" ? ")" : "]");
				else if (a && n && r === "{") i || (i = c), o.push("}");
				else if (o.length === 0) if (r === ";") if (n) {
					this.decl(u, a);
					return;
				} else break;
				else if (r === "{") {
					this.rule(u);
					return;
				} else if (r === "}") {
					this.tokenizer.back(u.pop()), s = !0;
					break;
				} else r === ":" && (n = !0);
				else r === o[o.length - 1] && (o.pop(), o.length === 0 && (i = null));
				c = this.tokenizer.nextToken();
			}
			if (this.tokenizer.endOfFile() && (s = !0), o.length > 0 && this.unclosedBracket(i), s && n) {
				if (!a) for (; u.length && (c = u[u.length - 1][0], !(c !== "space" && c !== "comment"));) this.tokenizer.back(u.pop());
				this.decl(u, a);
			} else this.unknownWord(u);
		}
		parse() {
			let e;
			for (; !this.tokenizer.endOfFile();) switch (e = this.tokenizer.nextToken(), e[0]) {
				case "space":
					this.spaces += e[1];
					break;
				case ";":
					this.freeSemicolon(e);
					break;
				case "}":
					this.end(e);
					break;
				case "comment":
					this.comment(e);
					break;
				case "at-word":
					this.atrule(e);
					break;
				case "{":
					this.emptyRule(e);
					break;
				default:
					this.other(e);
					break;
			}
			this.endFile();
		}
		precheckMissedSemicolon() {}
		raw(e, s, r, n) {
			let i, o, a = r.length, u = "", c = !0, f, p;
			for (let l = 0; l < a; l += 1) i = r[l], o = i[0], o === "space" && l === a - 1 && !n ? c = !1 : o === "comment" ? (p = r[l - 1] ? r[l - 1][0] : "empty", f = r[l + 1] ? r[l + 1][0] : "empty", !ji$1[p] && !ji$1[f] ? u.slice(-1) === "," ? c = !1 : u += i[1] : c = !1) : u += i[1];
			if (!c) {
				let l = r.reduce((w$1, x) => w$1 + x[1], "");
				e.raws[s] = {
					raw: l,
					value: u
				};
			}
			e[s] = u;
		}
		rule(e) {
			e.pop();
			let s = new Gi$1();
			this.init(s, e[0][2]), s.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(s, "selector", e), this.current = s;
		}
		spacesAndCommentsFromEnd(e) {
			let s, r = "";
			for (; e.length && (s = e[e.length - 1][0], !(s !== "space" && s !== "comment"));) r = e.pop()[1] + r;
			return r;
		}
		spacesAndCommentsFromStart(e) {
			let s, r = "";
			for (; e.length && (s = e[0][0], !(s !== "space" && s !== "comment"));) r += e.shift()[1];
			return r;
		}
		spacesFromEnd(e) {
			let s, r = "";
			for (; e.length && (s = e[e.length - 1][0], s === "space");) r = e.pop()[1] + r;
			return r;
		}
		stringFrom(e, s) {
			let r = "";
			for (let n = s; n < e.length; n++) r += e[n][1];
			return e.splice(s, e.length - s), r;
		}
		unclosedBlock() {
			let e = this.current.source.start;
			throw this.input.error("Unclosed block", e.line, e.column);
		}
		unclosedBracket(e) {
			throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
		}
		unexpectedClose(e) {
			throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
		}
		unknownWord(e) {
			throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
		}
		unnamedAtrule(e, s) {
			throw this.input.error("At-rule without name", { offset: s[2] }, { offset: s[2] + s[1].length });
		}
	};
	Hi$1.exports = ls$1;
});
var Ki = y(() => {});
var Ji = y((xv, Qi$1) => {
	var Tc = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Oc = (t, e = 21) => (s = e) => {
		let r = "", n = s;
		for (; n--;) r += t[Math.random() * t.length | 0];
		return r;
	}, Cc = (t = 21) => {
		let e = "", s = t;
		for (; s--;) e += Tc[Math.random() * 64 | 0];
		return e;
	};
	Qi$1.exports = {
		nanoid: Cc,
		customAlphabet: Oc
	};
});
var cs = y((bv, Xi$1) => {
	Xi$1.exports = class {};
});
var Re = y((kv, ro) => {
	var { SourceMapConsumer: Ac, SourceMapGenerator: Nc } = Ki(), { fileURLToPath: Zi$1, pathToFileURL: Kt$1 } = {}, { isAbsolute: hs$1, resolve: ds$1 } = {}, { nanoid: Pc } = Ji(), fs$1 = ss(), eo = Ft(), Rc = cs(), ps$1 = Symbol("fromOffsetCache"), Ic = !!(Ac && Nc), to = !!(ds$1 && hs$1), Pe$1 = class {
		constructor(e, s = {}) {
			if (e === null || typeof e > "u" || typeof e == "object" && !e.toString) throw new Error(`PostCSS received ${e} instead of CSS string`);
			if (this.css = e.toString(), this.css[0] === "﻿" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, s.from && (!to || /^\w+:\/\//.test(s.from) || hs$1(s.from) ? this.file = s.from : this.file = ds$1(s.from)), to && Ic) {
				let r = new Rc(this.css, s);
				if (r.text) {
					this.map = r;
					let n = r.consumer().file;
					!this.file && n && (this.file = this.mapResolve(n));
				}
			}
			this.file || (this.id = "<input css " + Pc(6) + ">"), this.map && (this.map.file = this.from);
		}
		error(e, s, r, n = {}) {
			let i, o, a;
			if (s && typeof s == "object") {
				let c = s, f = r;
				if (typeof c.offset == "number") {
					let p = this.fromOffset(c.offset);
					s = p.line, r = p.col;
				} else s = c.line, r = c.column;
				if (typeof f.offset == "number") {
					let p = this.fromOffset(f.offset);
					o = p.line, a = p.col;
				} else o = f.line, a = f.column;
			} else if (!r) {
				let c = this.fromOffset(s);
				s = c.line, r = c.col;
			}
			let u = this.origin(s, r, o, a);
			return u ? i = new eo(e, u.endLine === void 0 ? u.line : {
				column: u.column,
				line: u.line
			}, u.endLine === void 0 ? u.column : {
				column: u.endColumn,
				line: u.endLine
			}, u.source, u.file, n.plugin) : i = new eo(e, o === void 0 ? s : {
				column: r,
				line: s
			}, o === void 0 ? r : {
				column: a,
				line: o
			}, this.css, this.file, n.plugin), i.input = {
				column: r,
				endColumn: a,
				endLine: o,
				line: s,
				source: this.css
			}, this.file && (Kt$1 && (i.input.url = Kt$1(this.file).toString()), i.input.file = this.file), i;
		}
		fromOffset(e) {
			let s, r;
			if (this[ps$1]) r = this[ps$1];
			else {
				let i = this.css.split(`
`);
				r = new Array(i.length);
				let o = 0;
				for (let a = 0, u = i.length; a < u; a++) r[a] = o, o += i[a].length + 1;
				this[ps$1] = r;
			}
			s = r[r.length - 1];
			let n = 0;
			if (e >= s) n = r.length - 1;
			else {
				let i = r.length - 2, o;
				for (; n < i;) if (o = n + (i - n >> 1), e < r[o]) i = o - 1;
				else if (e >= r[o + 1]) n = o + 1;
				else {
					n = o;
					break;
				}
			}
			return {
				col: e - r[n] + 1,
				line: n + 1
			};
		}
		mapResolve(e) {
			return /^\w+:\/\//.test(e) ? e : ds$1(this.map.consumer().sourceRoot || this.map.root || ".", e);
		}
		origin(e, s, r, n) {
			if (!this.map) return !1;
			let i = this.map.consumer(), o = i.originalPositionFor({
				column: s,
				line: e
			});
			if (!o.source) return !1;
			let a;
			typeof r == "number" && (a = i.originalPositionFor({
				column: n,
				line: r
			}));
			let u;
			hs$1(o.source) ? u = Kt$1(o.source) : u = new URL(o.source, this.map.consumer().sourceRoot || Kt$1(this.map.mapFile));
			let c = {
				column: o.column,
				endColumn: a && a.column,
				endLine: a && a.line,
				line: o.line,
				url: u.toString()
			};
			if (u.protocol === "file:") if (Zi$1) c.file = Zi$1(u);
			else throw new Error("file: protocol is not available in this PostCSS build");
			let f = i.sourceContentFor(o.source);
			return f && (c.source = f), c;
		}
		toJSON() {
			let e = {};
			for (let s of [
				"hasBOM",
				"css",
				"file",
				"id"
			]) this[s] != null && (e[s] = this[s]);
			return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
		}
		get from() {
			return this.file || this.id;
		}
	};
	ro.exports = Pe$1;
	Pe$1.default = Pe$1;
	fs$1 && fs$1.registerInput && fs$1.registerInput(Pe$1);
});
var pt = y((Ev, so) => {
	var qc = re(), Lc = Ht(), Dc = Re();
	function Qt$1(t, e) {
		let r = new Lc(new Dc(t, e));
		try {
			r.parse();
		} catch (n) {
			throw n;
		}
		return r.root;
	}
	so.exports = Qt$1;
	Qt$1.default = Qt$1;
	qc.registerParse(Qt$1);
});
var no = y((Sv, ms$1) => {
	var Mc = Vt(), Bc = Re();
	ms$1.exports = { isInlineComment(t) {
		if (t[0] === "word" && t[1].slice(0, 2) === "//") {
			let e = t, s = [], r, n;
			for (; t;) {
				if (/\r?\n/.test(t[1])) {
					if (/['"].*\r?\n/.test(t[1])) {
						s.push(t[1].substring(0, t[1].indexOf(`
`))), n = t[1].substring(t[1].indexOf(`
`));
						let o = this.input.css.valueOf().substring(this.tokenizer.position());
						n += o, r = t[3] + o.length - n.length;
					} else this.tokenizer.back(t);
					break;
				}
				s.push(t[1]), r = t[2], t = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
			}
			let i = [
				"comment",
				s.join(""),
				e[2],
				r
			];
			return this.inlineComment(i), n && (this.input = new Bc(n), this.tokenizer = Mc(this.input)), !0;
		} else if (t[1] === "/") {
			let e = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
			if (e[0] === "comment" && /^\/\*/.test(e[1])) return e[0] = "word", e[1] = e[1].slice(1), t[1] = "//", this.tokenizer.back(e), ms$1.exports.isInlineComment.bind(this)(t);
		}
		return !1;
	} };
});
var oo = y((Tv, io$1) => {
	io$1.exports = { interpolation(t) {
		let e = [t, this.tokenizer.nextToken()], s = ["word", "}"];
		if (e[0][1].length > 1 || e[1][0] !== "{") return this.tokenizer.back(e[1]), !1;
		for (t = this.tokenizer.nextToken(); t && s.includes(t[0]);) e.push(t), t = this.tokenizer.nextToken();
		let r = e.map((a) => a[1]), [n] = e, i = e.pop(), o = [
			"word",
			r.join(""),
			n[2],
			i[2]
		];
		return this.tokenizer.back(t), this.tokenizer.back(o), !0;
	} };
});
var uo = y((Ov, ao) => {
	var Uc = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, Fc = /\.[0-9]/, $c = (t) => {
		let [, e] = t, [s] = e;
		return (s === "." || s === "#") && Uc.test(e) === !1 && Fc.test(e) === !1;
	};
	ao.exports = { isMixinToken: $c };
});
var co = y((Cv, lo) => {
	var Wc = Vt(), Yc = /^url\((.+)\)/;
	lo.exports = (t) => {
		let { name: e, params: s = "" } = t;
		if (e === "import" && s.length) {
			t.import = !0;
			let r = Wc({ css: s });
			for (t.filename = s.replace(Yc, "$1"); !r.endOfFile();) {
				let [n, i] = r.nextToken();
				if (n === "word" && i === "url") return;
				if (n === "brackets") {
					t.options = i, t.filename = s.replace(i, "").trim();
					break;
				}
			}
		}
	};
});
var mo = y((Av, ho$1) => {
	var fo$1 = /:$/, po$1 = /^:(\s+)?/;
	ho$1.exports = (t) => {
		let { name: e, params: s = "" } = t;
		if (t.name.slice(-1) === ":") {
			if (fo$1.test(e)) {
				let [r] = e.match(fo$1);
				t.name = e.replace(r, ""), t.raws.afterName = r + (t.raws.afterName || ""), t.variable = !0, t.value = t.params;
			}
			if (po$1.test(s)) {
				let [r] = s.match(po$1);
				t.value = s.replace(r, ""), t.raws.afterName = (t.raws.afterName || "") + r, t.variable = !0;
			}
		}
	};
});
var go = y((Pv, wo$1) => {
	var zc = Oe(), Vc = Ht(), { isInlineComment: Gc } = no(), { interpolation: yo$1 } = oo(), { isMixinToken: jc } = uo(), Hc = co(), Kc = mo(), Qc = /(!\s*important)$/i;
	wo$1.exports = class extends Vc {
		constructor(...e) {
			super(...e), this.lastNode = null;
		}
		atrule(e) {
			yo$1.bind(this)(e) || (super.atrule(e), Hc(this.lastNode), Kc(this.lastNode));
		}
		decl(...e) {
			super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
		}
		each(e) {
			e[0][1] = ` ${e[0][1]}`;
			let s = e.findIndex((a) => a[0] === "("), r = e.reverse().find((a) => a[0] === ")"), n = e.reverse().indexOf(r), o = e.splice(s, n).map((a) => a[1]).join("");
			for (let a of e.reverse()) this.tokenizer.back(a);
			this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = o;
		}
		init(e, s, r) {
			super.init(e, s, r), this.lastNode = e;
		}
		inlineComment(e) {
			let s = new zc(), r = e[1].slice(2);
			if (this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.inline = !0, s.raws.begin = "//", /^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
			else {
				let n = r.match(/^(\s*)([^]*[^\s])(\s*)$/);
				[, s.raws.left, s.text, s.raws.right] = n;
			}
		}
		mixin(e) {
			let [s] = e, r = s[1].slice(0, 1), n = e.findIndex((c) => c[0] === "brackets"), i = e.findIndex((c) => c[0] === "("), o = "";
			if ((n < 0 || n > 3) && i > 0) {
				let c = e.reduce((g, v$1, R) => v$1[0] === ")" ? R : g), p = e.slice(i, c + i).map((g) => g[1]).join(""), [l] = e.slice(i), w$1 = [l[2], l[3]], [x] = e.slice(c, c + 1), h$1 = [x[2], x[3]], d = ["brackets", p].concat(w$1, h$1), m$1 = e.slice(0, i), b$1 = e.slice(c + 1);
				e = m$1, e.push(d), e = e.concat(b$1);
			}
			let a = [];
			for (let c of e) if ((c[1] === "!" || a.length) && a.push(c), c[1] === "important") break;
			if (a.length) {
				let [c] = a, f = e.indexOf(c), p = a[a.length - 1], l = [c[2], c[3]], w$1 = [p[4], p[5]], h$1 = ["word", a.map((d) => d[1]).join("")].concat(l, w$1);
				e.splice(f, a.length, h$1);
			}
			let u = e.findIndex((c) => Qc.test(c[1]));
			u > 0 && ([, o] = e[u], e.splice(u, 1));
			for (let c of e.reverse()) this.tokenizer.back(c);
			this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = r, o && (this.lastNode.important = !0, this.lastNode.raws.important = o);
		}
		other(e) {
			Gc.bind(this)(e) || super.other(e);
		}
		rule(e) {
			let s = e[e.length - 1], r = e[e.length - 2];
			if (r[0] === "at-word" && s[0] === "{" && (this.tokenizer.back(s), yo$1.bind(this)(r))) {
				let i = this.tokenizer.nextToken();
				e = e.slice(0, e.length - 2).concat([i]);
				for (let o of e.reverse()) this.tokenizer.back(o);
				return;
			}
			super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
		}
		unknownWord(e) {
			let [s] = e;
			if (e[0][1] === "each" && e[1][0] === "(") {
				this.each(e);
				return;
			}
			if (jc(s)) {
				this.mixin(e);
				return;
			}
			super.unknownWord(e);
		}
	};
});
var xo = y((Iv, vo$1) => {
	var Jc = $t();
	vo$1.exports = class extends Jc {
		atrule(e, s) {
			if (!e.mixin && !e.variable && !e.function) {
				super.atrule(e, s);
				return;
			}
			let n = `${e.function ? "" : e.raws.identifier || "@"}${e.name}`, i = e.params ? this.rawValue(e, "params") : "", o = e.raws.important || "";
			if (e.variable && (i = e.value), typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes) this.block(e, n + i + o);
			else {
				let a = (e.raws.between || "") + o + (s ? ";" : "");
				this.builder(n + i + a, e);
			}
		}
		comment(e) {
			if (e.inline) {
				let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
				this.builder(`//${s}${e.text}${r}`, e);
			} else super.comment(e);
		}
	};
});
var bo = y((qv, ys$1) => {
	var Xc = Re(), Zc = go(), ef = xo();
	ys$1.exports = {
		parse(t, e) {
			let s = new Xc(t, e), r = new Zc(s);
			return r.parse(), r.root.walk((n) => {
				let i = s.css.lastIndexOf(n.source.input.css);
				if (i === 0) return;
				if (i + n.source.input.css.length !== s.css.length) throw new Error("Invalid state detected in postcss-less");
				let o = i + n.source.start.offset, a = s.fromOffset(i + n.source.start.offset);
				if (n.source.start = {
					offset: o,
					line: a.line,
					column: a.col
				}, n.source.end) {
					let u = i + n.source.end.offset, c = s.fromOffset(i + n.source.end.offset);
					n.source.end = {
						offset: u,
						line: c.line,
						column: c.col
					};
				}
			}), r.root;
		},
		stringify(t, e) {
			new ef(e).stringify(t);
		},
		nodeToString(t) {
			let e = "";
			return ys$1.exports.stringify(t, (s) => {
				e += s;
			}), e;
		}
	};
});
var ws = y((Lv, _o$1) => {
	_o$1.exports = class {
		generate() {}
	};
});
var Jt = y((Mv, So$1) => {
	var tf = re(), ko$1, Eo$1, pe$1 = class extends tf {
		constructor(e) {
			super({
				type: "document",
				...e
			}), this.nodes || (this.nodes = []);
		}
		toResult(e = {}) {
			return new ko$1(new Eo$1(), this, e).stringify();
		}
	};
	pe$1.registerLazyResult = (t) => {
		ko$1 = t;
	};
	pe$1.registerProcessor = (t) => {
		Eo$1 = t;
	};
	So$1.exports = pe$1;
	pe$1.default = pe$1;
});
var gs = y((Bv, Oo) => {
	var To$1 = {};
	Oo.exports = function(e) {
		To$1[e] || (To$1[e] = !0, typeof console < "u" && console.warn && console.warn(e));
	};
});
var vs = y((Uv, Co$1) => {
	var ht$1 = class {
		constructor(e, s = {}) {
			if (this.type = "warning", this.text = e, s.node && s.node.source) {
				let r = s.node.rangeBy(s);
				this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
			}
			for (let r in s) this[r] = s[r];
		}
		toString() {
			return this.node ? this.node.error(this.text, {
				index: this.index,
				plugin: this.plugin,
				word: this.word
			}).message : this.plugin ? this.plugin + ": " + this.text : this.text;
		}
	};
	Co$1.exports = ht$1;
	ht$1.default = ht$1;
});
var Xt = y((Fv, Ao$1) => {
	var rf = vs(), dt$1 = class {
		constructor(e, s, r) {
			this.processor = e, this.messages = [], this.root = s, this.opts = r, this.css = void 0, this.map = void 0;
		}
		toString() {
			return this.css;
		}
		warn(e, s = {}) {
			s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
			let r = new rf(e, s);
			return this.messages.push(r), r;
		}
		warnings() {
			return this.messages.filter((e) => e.type === "warning");
		}
		get content() {
			return this.css;
		}
	};
	Ao$1.exports = dt$1;
	dt$1.default = dt$1;
});
var _s = y((Wv, Io$1) => {
	var { isClean: j$1, my: sf } = Ut(), nf = ws(), of = it(), af = re(), uf = Jt();
	gs();
	var No$1 = Xt(), lf = pt(), cf = Ae(), ff = {
		atrule: "AtRule",
		comment: "Comment",
		decl: "Declaration",
		document: "Document",
		root: "Root",
		rule: "Rule"
	}, pf = {
		AtRule: !0,
		AtRuleExit: !0,
		Comment: !0,
		CommentExit: !0,
		Declaration: !0,
		DeclarationExit: !0,
		Document: !0,
		DocumentExit: !0,
		Once: !0,
		OnceExit: !0,
		postcssPlugin: !0,
		prepare: !0,
		Root: !0,
		RootExit: !0,
		Rule: !0,
		RuleExit: !0
	}, hf = {
		Once: !0,
		postcssPlugin: !0,
		prepare: !0
	}, Ie$1 = 0;
	function mt(t) {
		return typeof t == "object" && typeof t.then == "function";
	}
	function Ro$1(t) {
		let e = !1, s = ff[t.type];
		return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
			s,
			s + "-" + e,
			Ie$1,
			s + "Exit",
			s + "Exit-" + e
		] : e ? [
			s,
			s + "-" + e,
			s + "Exit",
			s + "Exit-" + e
		] : t.append ? [
			s,
			Ie$1,
			s + "Exit"
		] : [s, s + "Exit"];
	}
	function Po$1(t) {
		let e;
		return t.type === "document" ? e = [
			"Document",
			Ie$1,
			"DocumentExit"
		] : t.type === "root" ? e = [
			"Root",
			Ie$1,
			"RootExit"
		] : e = Ro$1(t), {
			eventIndex: 0,
			events: e,
			iterator: 0,
			node: t,
			visitorIndex: 0,
			visitors: []
		};
	}
	function xs$1(t) {
		return t[j$1] = !1, t.nodes && t.nodes.forEach((e) => xs$1(e)), t;
	}
	var bs$1 = {}, ne$1 = class t {
		constructor(e, s, r) {
			this.stringified = !1, this.processed = !1;
			let n;
			if (typeof s == "object" && s !== null && (s.type === "root" || s.type === "document")) n = xs$1(s);
			else if (s instanceof t || s instanceof No$1) n = xs$1(s.root), s.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = !1), r.map.prev = s.map);
			else {
				let i = lf;
				r.syntax && (i = r.syntax.parse), r.parser && (i = r.parser), i.parse && (i = i.parse);
				try {
					n = i(s, r);
				} catch (o) {
					this.processed = !0, this.error = o;
				}
				n && !n[sf] && af.rebuild(n);
			}
			this.result = new No$1(e, n, r), this.helpers = {
				...bs$1,
				postcss: bs$1,
				result: this.result
			}, this.plugins = this.processor.plugins.map((i) => typeof i == "object" && i.prepare ? {
				...i,
				...i.prepare(this.result)
			} : i);
		}
		async() {
			return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
		}
		catch(e) {
			return this.async().catch(e);
		}
		finally(e) {
			return this.async().then(e, e);
		}
		getAsyncError() {
			throw new Error("Use process(css).then(cb) to work with async plugins");
		}
		handleError(e, s) {
			let r = this.result.lastPlugin;
			try {
				s && s.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
			} catch (n) {
				console && console.error && console.error(n);
			}
			return e;
		}
		prepareVisitors() {
			this.listeners = {};
			let e = (s, r, n) => {
				this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([s, n]);
			};
			for (let s of this.plugins) if (typeof s == "object") for (let r in s) {
				if (!pf[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${s.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
				if (!hf[r]) if (typeof s[r] == "object") for (let n in s[r]) n === "*" ? e(s, r, s[r][n]) : e(s, r + "-" + n.toLowerCase(), s[r][n]);
				else typeof s[r] == "function" && e(s, r, s[r]);
			}
			this.hasListener = Object.keys(this.listeners).length > 0;
		}
		async runAsync() {
			this.plugin = 0;
			for (let e = 0; e < this.plugins.length; e++) {
				let s = this.plugins[e], r = this.runOnRoot(s);
				if (mt(r)) try {
					await r;
				} catch (n) {
					throw this.handleError(n);
				}
			}
			if (this.prepareVisitors(), this.hasListener) {
				let e = this.result.root;
				for (; !e[j$1];) {
					e[j$1] = !0;
					let s = [Po$1(e)];
					for (; s.length > 0;) {
						let r = this.visitTick(s);
						if (mt(r)) try {
							await r;
						} catch (n) {
							let i = s[s.length - 1].node;
							throw this.handleError(n, i);
						}
					}
				}
				if (this.listeners.OnceExit) for (let [s, r] of this.listeners.OnceExit) {
					this.result.lastPlugin = s;
					try {
						if (e.type === "document") {
							let n = e.nodes.map((i) => r(i, this.helpers));
							await Promise.all(n);
						} else await r(e, this.helpers);
					} catch (n) {
						throw this.handleError(n);
					}
				}
			}
			return this.processed = !0, this.stringify();
		}
		runOnRoot(e) {
			this.result.lastPlugin = e;
			try {
				if (typeof e == "object" && e.Once) {
					if (this.result.root.type === "document") {
						let s = this.result.root.nodes.map((r) => e.Once(r, this.helpers));
						return mt(s[0]) ? Promise.all(s) : s;
					}
					return e.Once(this.result.root, this.helpers);
				} else if (typeof e == "function") return e(this.result.root, this.result);
			} catch (s) {
				throw this.handleError(s);
			}
		}
		stringify() {
			if (this.error) throw this.error;
			if (this.stringified) return this.result;
			this.stringified = !0, this.sync();
			let e = this.result.opts, s = of;
			e.syntax && (s = e.syntax.stringify), e.stringifier && (s = e.stringifier), s.stringify && (s = s.stringify);
			let n = new nf(s, this.result.root, this.result.opts).generate();
			return this.result.css = n[0], this.result.map = n[1], this.result;
		}
		sync() {
			if (this.error) throw this.error;
			if (this.processed) return this.result;
			if (this.processed = !0, this.processing) throw this.getAsyncError();
			for (let e of this.plugins) if (mt(this.runOnRoot(e))) throw this.getAsyncError();
			if (this.prepareVisitors(), this.hasListener) {
				let e = this.result.root;
				for (; !e[j$1];) e[j$1] = !0, this.walkSync(e);
				if (this.listeners.OnceExit) if (e.type === "document") for (let s of e.nodes) this.visitSync(this.listeners.OnceExit, s);
				else this.visitSync(this.listeners.OnceExit, e);
			}
			return this.result;
		}
		then(e, s) {
			return this.async().then(e, s);
		}
		toString() {
			return this.css;
		}
		visitSync(e, s) {
			for (let [r, n] of e) {
				this.result.lastPlugin = r;
				let i;
				try {
					i = n(s, this.helpers);
				} catch (o) {
					throw this.handleError(o, s.proxyOf);
				}
				if (s.type !== "root" && s.type !== "document" && !s.parent) return !0;
				if (mt(i)) throw this.getAsyncError();
			}
		}
		visitTick(e) {
			let s = e[e.length - 1], { node: r, visitors: n } = s;
			if (r.type !== "root" && r.type !== "document" && !r.parent) {
				e.pop();
				return;
			}
			if (n.length > 0 && s.visitorIndex < n.length) {
				let [o, a] = n[s.visitorIndex];
				s.visitorIndex += 1, s.visitorIndex === n.length && (s.visitors = [], s.visitorIndex = 0), this.result.lastPlugin = o;
				try {
					return a(r.toProxy(), this.helpers);
				} catch (u) {
					throw this.handleError(u, r);
				}
			}
			if (s.iterator !== 0) {
				let o = s.iterator, a;
				for (; a = r.nodes[r.indexes[o]];) if (r.indexes[o] += 1, !a[j$1]) {
					a[j$1] = !0, e.push(Po$1(a));
					return;
				}
				s.iterator = 0, delete r.indexes[o];
			}
			let i = s.events;
			for (; s.eventIndex < i.length;) {
				let o = i[s.eventIndex];
				if (s.eventIndex += 1, o === Ie$1) {
					r.nodes && r.nodes.length && (r[j$1] = !0, s.iterator = r.getIterator());
					return;
				} else if (this.listeners[o]) {
					s.visitors = this.listeners[o];
					return;
				}
			}
			e.pop();
		}
		walkSync(e) {
			e[j$1] = !0;
			let s = Ro$1(e);
			for (let r of s) if (r === Ie$1) e.nodes && e.each((n) => {
				n[j$1] || this.walkSync(n);
			});
			else {
				let n = this.listeners[r];
				if (n && this.visitSync(n, e.toProxy())) return;
			}
		}
		warnings() {
			return this.sync().warnings();
		}
		get content() {
			return this.stringify().content;
		}
		get css() {
			return this.stringify().css;
		}
		get map() {
			return this.stringify().map;
		}
		get messages() {
			return this.sync().messages;
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			return this.sync().root;
		}
		get [Symbol.toStringTag]() {
			return "LazyResult";
		}
	};
	ne$1.registerPostcss = (t) => {
		bs$1 = t;
	};
	Io$1.exports = ne$1;
	ne$1.default = ne$1;
	cf.registerLazyResult(ne$1);
	uf.registerLazyResult(ne$1);
});
var Lo = y((zv, qo) => {
	var df = ws(), mf = it();
	gs();
	var yf = pt(), wf = Xt(), yt$1 = class {
		constructor(e, s, r) {
			s = s.toString(), this.stringified = !1, this._processor = e, this._css = s, this._opts = r, this._map = void 0;
			let n, i = mf;
			this.result = new wf(this._processor, n, this._opts), this.result.css = s;
			let o = this;
			Object.defineProperty(this.result, "root", { get() {
				return o.root;
			} });
			let a = new df(i, n, this._opts, s);
			if (a.isMap()) {
				let [u, c] = a.generate();
				u && (this.result.css = u), c && (this.result.map = c);
			} else a.clearAnnotation(), this.result.css = a.css;
		}
		async() {
			return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
		}
		catch(e) {
			return this.async().catch(e);
		}
		finally(e) {
			return this.async().then(e, e);
		}
		sync() {
			if (this.error) throw this.error;
			return this.result;
		}
		then(e, s) {
			return this.async().then(e, s);
		}
		toString() {
			return this._css;
		}
		warnings() {
			return [];
		}
		get content() {
			return this.result.css;
		}
		get css() {
			return this.result.css;
		}
		get map() {
			return this.result.map;
		}
		get messages() {
			return [];
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			if (this._root) return this._root;
			let e, s = yf;
			try {
				e = s(this._css, this._opts);
			} catch (r) {
				this.error = r;
			}
			if (this.error) throw this.error;
			return this._root = e, e;
		}
		get [Symbol.toStringTag]() {
			return "NoWorkResult";
		}
	};
	qo.exports = yt$1;
	yt$1.default = yt$1;
});
var Mo = y((Vv, Do$1) => {
	var gf = Lo(), vf = _s(), xf = Jt(), bf = Ae(), he$1 = class {
		constructor(e = []) {
			this.version = "8.4.39", this.plugins = this.normalize(e);
		}
		normalize(e) {
			let s = [];
			for (let r of e) if (r.postcss === !0 ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins)) s = s.concat(r.plugins);
			else if (typeof r == "object" && r.postcssPlugin) s.push(r);
			else if (typeof r == "function") s.push(r);
			else if (!(typeof r == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
			return s;
		}
		process(e, s = {}) {
			return !this.plugins.length && !s.parser && !s.stringifier && !s.syntax ? new gf(this, e, s) : new vf(this, e, s);
		}
		use(e) {
			return this.plugins = this.plugins.concat(this.normalize([e])), this;
		}
	};
	Do$1.exports = he$1;
	he$1.default = he$1;
	bf.registerProcessor(he$1);
	xf.registerProcessor(he$1);
});
var Uo = y((Gv, Bo$1) => {
	var _f = lt(), kf = cs(), Ef = Oe(), Sf = Gt(), Tf = Re(), Of = Ae(), Cf = jt();
	function wt$1(t, e) {
		if (Array.isArray(t)) return t.map((n) => wt$1(n));
		let { inputs: s,...r } = t;
		if (s) {
			e = [];
			for (let n of s) {
				let i = {
					...n,
					__proto__: Tf.prototype
				};
				i.map && (i.map = {
					...i.map,
					__proto__: kf.prototype
				}), e.push(i);
			}
		}
		if (r.nodes && (r.nodes = t.nodes.map((n) => wt$1(n, e))), r.source) {
			let { inputId: n,...i } = r.source;
			r.source = i, n != null && (r.source.input = e[n]);
		}
		if (r.type === "root") return new Of(r);
		if (r.type === "decl") return new _f(r);
		if (r.type === "rule") return new Cf(r);
		if (r.type === "comment") return new Ef(r);
		if (r.type === "atrule") return new Sf(r);
		throw new Error("Unknown node type: " + t.type);
	}
	Bo$1.exports = wt$1;
	wt$1.default = wt$1;
});
var Zt = y((jv, Go) => {
	var Af = Ft(), Fo$1 = lt(), Nf = _s(), Pf = re(), ks$1 = Mo(), Rf = it(), If = Uo(), $o$1 = Jt(), qf = vs(), Wo = Oe(), Yo = Gt(), Lf = Xt(), Df = Re(), Mf = pt(), Bf = us(), zo = jt(), Vo = Ae(), Uf = at();
	function k$1(...t) {
		return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new ks$1(t);
	}
	k$1.plugin = function(e, s) {
		let r = !1;
		function n(...o) {
			console && console.warn && !r && (r = !0, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
			let a = s(...o);
			return a.postcssPlugin = e, a.postcssVersion = new ks$1().version, a;
		}
		let i;
		return Object.defineProperty(n, "postcss", { get() {
			return i || (i = n()), i;
		} }), n.process = function(o, a, u) {
			return k$1([n(u)]).process(o, a);
		}, n;
	};
	k$1.stringify = Rf;
	k$1.parse = Mf;
	k$1.fromJSON = If;
	k$1.list = Bf;
	k$1.comment = (t) => new Wo(t);
	k$1.atRule = (t) => new Yo(t);
	k$1.decl = (t) => new Fo$1(t);
	k$1.rule = (t) => new zo(t);
	k$1.root = (t) => new Vo(t);
	k$1.document = (t) => new $o$1(t);
	k$1.CssSyntaxError = Af;
	k$1.Declaration = Fo$1;
	k$1.Container = Pf;
	k$1.Processor = ks$1;
	k$1.Document = $o$1;
	k$1.Comment = Wo;
	k$1.Warning = qf;
	k$1.AtRule = Yo;
	k$1.Result = Lf;
	k$1.Input = Df;
	k$1.Rule = zo;
	k$1.Root = Vo;
	k$1.Node = Uf;
	Nf.registerPostcss(k$1);
	Go.exports = k$1;
	k$1.default = k$1;
});
var Ho = y((Hv, jo) => {
	var { Container: Ff } = Zt(), Es$1 = class extends Ff {
		constructor(e) {
			super(e), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
		}
	};
	jo.exports = Es$1;
});
var Jo = y((Kv, Qo) => {
	var er = /[\t\n\f\r "#'()/;[\\\]{}]/g, tr$1 = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, $f = /.[\r\n"'(/\\]/, Ko = /[\da-f]/i, rr$1 = /[\n\f\r]/g;
	Qo.exports = function(e, s = {}) {
		let r = e.css.valueOf(), n = s.ignoreErrors, i, o, a, u, c, f, p, l, w$1, x = r.length, h$1 = 0, d = [], m$1 = [], b$1;
		function g() {
			return h$1;
		}
		function v$1(T$1) {
			throw e.error("Unclosed " + T$1, h$1);
		}
		function R() {
			return m$1.length === 0 && h$1 >= x;
		}
		function F() {
			let T$1 = 1, O = !1, C = !1;
			for (; T$1 > 0;) o += 1, r.length <= o && v$1("interpolation"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), O ? !C && i === O ? (O = !1, C = !1) : i === 92 ? C = !C : C && (C = !1) : i === 39 || i === 34 ? O = i : i === 125 ? T$1 -= 1 : i === 35 && l === 123 && (T$1 += 1);
		}
		function H$1(T$1) {
			if (m$1.length) return m$1.pop();
			if (h$1 >= x) return;
			let O = T$1 ? T$1.ignoreUnclosed : !1;
			switch (i = r.charCodeAt(h$1), i) {
				case 10:
				case 32:
				case 9:
				case 13:
				case 12:
					o = h$1;
					do
						o += 1, i = r.charCodeAt(o);
					while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
					w$1 = ["space", r.slice(h$1, o)], h$1 = o - 1;
					break;
				case 91:
				case 93:
				case 123:
				case 125:
				case 58:
				case 59:
				case 41: {
					let C = String.fromCharCode(i);
					w$1 = [
						C,
						C,
						h$1
					];
					break;
				}
				case 44:
					w$1 = [
						"word",
						",",
						h$1,
						h$1 + 1
					];
					break;
				case 40:
					if (p = d.length ? d.pop()[1] : "", l = r.charCodeAt(h$1 + 1), p === "url" && l !== 39 && l !== 34) {
						for (b$1 = 1, f = !1, o = h$1 + 1; o <= r.length - 1;) {
							if (l = r.charCodeAt(o), l === 92) f = !f;
							else if (l === 40) b$1 += 1;
							else if (l === 41 && (b$1 -= 1, b$1 === 0)) break;
							o += 1;
						}
						u = r.slice(h$1, o + 1), w$1 = [
							"brackets",
							u,
							h$1,
							o
						], h$1 = o;
					} else o = r.indexOf(")", h$1 + 1), u = r.slice(h$1, o + 1), o === -1 || $f.test(u) ? w$1 = [
						"(",
						"(",
						h$1
					] : (w$1 = [
						"brackets",
						u,
						h$1,
						o
					], h$1 = o);
					break;
				case 39:
				case 34:
					for (a = i, o = h$1, f = !1; o < x && (o++, o === x && v$1("string"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), !(!f && i === a));) i === 92 ? f = !f : f ? f = !1 : i === 35 && l === 123 && F();
					w$1 = [
						"string",
						r.slice(h$1, o + 1),
						h$1,
						o
					], h$1 = o;
					break;
				case 64:
					er.lastIndex = h$1 + 1, er.test(r), er.lastIndex === 0 ? o = r.length - 1 : o = er.lastIndex - 2, w$1 = [
						"at-word",
						r.slice(h$1, o + 1),
						h$1,
						o
					], h$1 = o;
					break;
				case 92:
					for (o = h$1, c = !0; r.charCodeAt(o + 1) === 92;) o += 1, c = !c;
					if (i = r.charCodeAt(o + 1), c && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (o += 1, Ko.test(r.charAt(o)))) {
						for (; Ko.test(r.charAt(o + 1));) o += 1;
						r.charCodeAt(o + 1) === 32 && (o += 1);
					}
					w$1 = [
						"word",
						r.slice(h$1, o + 1),
						h$1,
						o
					], h$1 = o;
					break;
				default:
					l = r.charCodeAt(h$1 + 1), i === 35 && l === 123 ? (o = h$1, F(), u = r.slice(h$1, o + 1), w$1 = [
						"word",
						u,
						h$1,
						o
					], h$1 = o) : i === 47 && l === 42 ? (o = r.indexOf("*/", h$1 + 2) + 1, o === 0 && (n || O ? o = r.length : v$1("comment")), w$1 = [
						"comment",
						r.slice(h$1, o + 1),
						h$1,
						o
					], h$1 = o) : i === 47 && l === 47 ? (rr$1.lastIndex = h$1 + 1, rr$1.test(r), rr$1.lastIndex === 0 ? o = r.length - 1 : o = rr$1.lastIndex - 2, u = r.slice(h$1, o + 1), w$1 = [
						"comment",
						u,
						h$1,
						o,
						"inline"
					], h$1 = o) : (tr$1.lastIndex = h$1 + 1, tr$1.test(r), tr$1.lastIndex === 0 ? o = r.length - 1 : o = tr$1.lastIndex - 2, w$1 = [
						"word",
						r.slice(h$1, o + 1),
						h$1,
						o
					], d.push(w$1), h$1 = o);
					break;
			}
			return h$1++, w$1;
		}
		function $$1(T$1) {
			m$1.push(T$1);
		}
		return {
			back: $$1,
			endOfFile: R,
			nextToken: H$1,
			position: g
		};
	};
});
var Zo = y((Qv, Xo) => {
	var { Comment: Wf } = Zt(), Yf = Ht(), zf = Ho(), Vf = Jo(), Ss = class extends Yf {
		atrule(e) {
			let s = e[1], r = e;
			for (; !this.tokenizer.endOfFile();) {
				let n = this.tokenizer.nextToken();
				if (n[0] === "word" && n[2] === r[3] + 1) s += n[1], r = n;
				else {
					this.tokenizer.back(n);
					break;
				}
			}
			super.atrule([
				"at-word",
				s,
				e[2],
				r[3]
			]);
		}
		comment(e) {
			if (e[4] === "inline") {
				let s = new Wf();
				this.init(s, e[2]), s.raws.inline = !0;
				let r = this.input.fromOffset(e[3]);
				s.source.end = {
					column: r.col,
					line: r.line,
					offset: e[3] + 1
				};
				let n = e[1].slice(2);
				if (/^\s*$/.test(n)) s.text = "", s.raws.left = n, s.raws.right = "";
				else {
					let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
					s.text = i[2].replace(/(\*\/|\/\*)/g, "*//*"), s.raws.left = i[1], s.raws.right = i[3], s.raws.text = i[2];
				}
			} else super.comment(e);
		}
		createTokenizer() {
			this.tokenizer = Vf(this.input);
		}
		raw(e, s, r, n) {
			if (super.raw(e, s, r, n), e.raws[s]) {
				let i = e.raws[s].raw;
				e.raws[s].raw = r.reduce((o, a) => {
					if (a[0] === "comment" && a[4] === "inline") {
						let u = a[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
						return o + "/*" + u + "*/";
					} else return o + a[1];
				}, ""), i !== e.raws[s].raw && (e.raws[s].scss = i);
			}
		}
		rule(e) {
			let s = !1, r = 0, n = "";
			for (let i of e) if (s) i[0] !== "comment" && i[0] !== "{" && (n += i[1]);
			else {
				if (i[0] === "space" && i[1].includes(`
`)) break;
				i[0] === "(" ? r += 1 : i[0] === ")" ? r -= 1 : r === 0 && i[0] === ":" && (s = !0);
			}
			if (!s || n.trim() === "" || /^[#:A-Za-z-]/.test(n)) super.rule(e);
			else {
				e.pop();
				let i = new zf();
				this.init(i, e[0][2]);
				let o;
				for (let u = e.length - 1; u >= 0; u--) if (e[u][0] !== "space") {
					o = e[u];
					break;
				}
				if (o[3]) {
					let u = this.input.fromOffset(o[3]);
					i.source.end = {
						column: u.col,
						line: u.line,
						offset: o[3] + 1
					};
				} else {
					let u = this.input.fromOffset(o[2]);
					i.source.end = {
						column: u.col,
						line: u.line,
						offset: o[2] + 1
					};
				}
				for (; e[0][0] !== "word";) i.raws.before += e.shift()[1];
				if (e[0][2]) {
					let u = this.input.fromOffset(e[0][2]);
					i.source.start = {
						column: u.col,
						line: u.line,
						offset: e[0][2]
					};
				}
				for (i.prop = ""; e.length;) {
					let u = e[0][0];
					if (u === ":" || u === "space" || u === "comment") break;
					i.prop += e.shift()[1];
				}
				i.raws.between = "";
				let a;
				for (; e.length;) if (a = e.shift(), a[0] === ":") {
					i.raws.between += a[1];
					break;
				} else i.raws.between += a[1];
				(i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1)), i.raws.between += this.spacesAndCommentsFromStart(e), this.precheckMissedSemicolon(e);
				for (let u = e.length - 1; u > 0; u--) {
					if (a = e[u], a[1] === "!important") {
						i.important = !0;
						let c = this.stringFrom(e, u);
						c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c);
						break;
					} else if (a[1] === "important") {
						let c = e.slice(0), f = "";
						for (let p = u; p > 0; p--) {
							let l = c[p][0];
							if (f.trim().indexOf("!") === 0 && l !== "space") break;
							f = c.pop()[1] + f;
						}
						f.trim().indexOf("!") === 0 && (i.important = !0, i.raws.important = f, e = c);
					}
					if (a[0] !== "space" && a[0] !== "comment") break;
				}
				this.raw(i, "value", e), i.value.includes(":") && this.checkMissedSemicolon(e), this.current = i;
			}
		}
	};
	Xo.exports = Ss;
});
var ta = y((Jv, ea$1) => {
	var { Input: Gf } = Zt(), jf = Zo();
	ea$1.exports = function(e, s) {
		let n = new jf(new Gf(e, s));
		return n.parse(), n.root;
	};
});
var Os = y((Ts$1) => {
	Object.defineProperty(Ts$1, "__esModule", { value: !0 });
	function Kf(t) {
		this.after = t.after, this.before = t.before, this.type = t.type, this.value = t.value, this.sourceIndex = t.sourceIndex;
	}
	Ts$1.default = Kf;
});
var As = y((Cs$1) => {
	Object.defineProperty(Cs$1, "__esModule", { value: !0 });
	var sa$1 = Jf(Os());
	function Jf(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function gt$1(t) {
		var e = this;
		this.constructor(t), this.nodes = t.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(s) {
			s.parent = e;
		});
	}
	gt$1.prototype = Object.create(sa$1.default.prototype);
	gt$1.constructor = sa$1.default;
	gt$1.prototype.walk = function(e, s) {
		for (var r = typeof e == "string" || e instanceof RegExp, n = r ? s : e, i = typeof e == "string" ? new RegExp(e) : e, o = 0; o < this.nodes.length; o++) {
			var a = this.nodes[o];
			if ((r ? i.test(a.type) : !0) && n && n(a, o, this.nodes) === !1 || a.nodes && a.walk(e, s) === !1) return !1;
		}
		return !0;
	};
	gt$1.prototype.each = function() {
		for (var e = arguments.length <= 0 || arguments[0] === void 0 ? function() {} : arguments[0], s = 0; s < this.nodes.length; s++) {
			var r = this.nodes[s];
			if (e(r, s, this.nodes) === !1) return !1;
		}
		return !0;
	};
	Cs$1.default = gt$1;
});
var aa = y((vt$1) => {
	Object.defineProperty(vt$1, "__esModule", { value: !0 });
	vt$1.parseMediaFeature = oa$1;
	vt$1.parseMediaQuery = Ps;
	vt$1.parseMediaList = ep;
	var na$1 = ia$1(Os()), Ns = ia$1(As());
	function ia$1(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function oa$1(t) {
		var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [{
			mode: "normal",
			character: null
		}], r = [], n = 0, i = "", o = null, a = null, u = e, c = t;
		t[0] === "(" && t[t.length - 1] === ")" && (c = t.substring(1, t.length - 1), u++);
		for (var f = 0; f < c.length; f++) {
			var p = c[f];
			if ((p === "'" || p === "\"") && (s[n].isCalculationEnabled === !0 ? (s.push({
				mode: "string",
				isCalculationEnabled: !1,
				character: p
			}), n++) : s[n].mode === "string" && s[n].character === p && c[f - 1] !== "\\" && (s.pop(), n--)), p === "{" ? (s.push({
				mode: "interpolation",
				isCalculationEnabled: !0
			}), n++) : p === "}" && (s.pop(), n--), s[n].mode === "normal" && p === ":") {
				var l = c.substring(f + 1);
				a = {
					type: "value",
					before: /^(\s*)/.exec(l)[1],
					after: /(\s*)$/.exec(l)[1],
					value: l.trim()
				}, a.sourceIndex = a.before.length + f + 1 + u, o = {
					type: "colon",
					sourceIndex: f + u,
					after: a.before,
					value: ":"
				};
				break;
			}
			i += p;
		}
		return i = {
			type: "media-feature",
			before: /^(\s*)/.exec(i)[1],
			after: /(\s*)$/.exec(i)[1],
			value: i.trim()
		}, i.sourceIndex = i.before.length + u, r.push(i), o !== null && (o.before = i.after, r.push(o)), a !== null && r.push(a), r;
	}
	function Ps(t) {
		var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [], r = 0, n = !1, i = void 0;
		function o() {
			return {
				before: "",
				after: "",
				value: ""
			};
		}
		i = o();
		for (var a = 0; a < t.length; a++) {
			var u = t[a];
			n ? (i.value += u, (u === "{" || u === "(") && r++, (u === ")" || u === "}") && r--) : u.search(/\s/) !== -1 ? i.before += u : (u === "(" && (i.type = "media-feature-expression", r++), i.value = u, i.sourceIndex = e + a, n = !0), n && r === 0 && (u === ")" || a === t.length - 1 || t[a + 1].search(/\s/) !== -1) && ([
				"not",
				"only",
				"and"
			].indexOf(i.value) !== -1 && (i.type = "keyword"), i.type === "media-feature-expression" && (i.nodes = oa$1(i.value, i.sourceIndex)), s.push(Array.isArray(i.nodes) ? new Ns.default(i) : new na$1.default(i)), i = o(), n = !1);
		}
		for (var c = 0; c < s.length; c++) if (i = s[c], c > 0 && (s[c - 1].after = i.before), i.type === void 0) {
			if (c > 0) {
				if (s[c - 1].type === "media-feature-expression") {
					i.type = "keyword";
					continue;
				}
				if (s[c - 1].value === "not" || s[c - 1].value === "only") {
					i.type = "media-type";
					continue;
				}
				if (s[c - 1].value === "and") {
					i.type = "media-feature-expression";
					continue;
				}
				s[c - 1].type === "media-type" && (s[c + 1] ? i.type = s[c + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : i.type = "media-feature-expression");
			}
			if (c === 0) {
				if (!s[c + 1]) {
					i.type = "media-type";
					continue;
				}
				if (s[c + 1] && (s[c + 1].type === "media-feature-expression" || s[c + 1].type === "keyword")) {
					i.type = "media-type";
					continue;
				}
				if (s[c + 2]) {
					if (s[c + 2].type === "media-feature-expression") {
						i.type = "media-type", s[c + 1].type = "keyword";
						continue;
					}
					if (s[c + 2].type === "keyword") {
						i.type = "keyword", s[c + 1].type = "media-type";
						continue;
					}
				}
				if (s[c + 3] && s[c + 3].type === "media-feature-expression") {
					i.type = "keyword", s[c + 1].type = "media-type", s[c + 2].type = "keyword";
					continue;
				}
			}
		}
		return s;
	}
	function ep(t) {
		var e = [], s = 0, r = 0, n = /^(\s*)url\s*\(/.exec(t);
		if (n !== null) {
			for (var i = n[0].length, o = 1; o > 0;) {
				var a = t[i];
				a === "(" && o++, a === ")" && o--, i++;
			}
			e.unshift(new na$1.default({
				type: "url",
				value: t.substring(0, i).trim(),
				sourceIndex: n[1].length,
				before: n[1],
				after: /^(\s*)/.exec(t.substring(i))[1]
			})), s = i;
		}
		for (var u = s; u < t.length; u++) {
			var c = t[u];
			if (c === "(" && r++, c === ")" && r--, r === 0 && c === ",") {
				var f = t.substring(s, u), p = /^(\s*)/.exec(f)[1];
				e.push(new Ns.default({
					type: "media-query",
					value: f.trim(),
					sourceIndex: s + p.length,
					nodes: Ps(f, s),
					before: p,
					after: /(\s*)$/.exec(f)[1]
				})), s = u + 1;
			}
		}
		var l = t.substring(s), w$1 = /^(\s*)/.exec(l)[1];
		return e.push(new Ns.default({
			type: "media-query",
			value: l.trim(),
			sourceIndex: s + w$1.length,
			nodes: Ps(l, s),
			before: w$1,
			after: /(\s*)$/.exec(l)[1]
		})), e;
	}
});
var ua = y((Rs$1) => {
	Object.defineProperty(Rs$1, "__esModule", { value: !0 });
	Rs$1.default = ip;
	var rp = np(As()), sp = aa();
	function np(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function ip(t) {
		return new rp.default({
			nodes: (0, sp.parseMediaList)(t),
			type: "media-query-list",
			value: t.trim()
		});
	}
});
var qs = y((ox, fa$1) => {
	fa$1.exports = function(e, s) {
		if (s = typeof s == "number" ? s : Infinity, !s) return Array.isArray(e) ? e.map(function(n) {
			return n;
		}) : e;
		return r(e, 1);
		function r(n, i) {
			return n.reduce(function(o, a) {
				return Array.isArray(a) && i < s ? o.concat(r(a, i + 1)) : o.concat(a);
			}, []);
		}
	};
});
var Ls = y((ax, pa$1) => {
	pa$1.exports = function(t, e) {
		for (var s = -1, r = []; (s = t.indexOf(e, s + 1)) !== -1;) r.push(s);
		return r;
	};
});
var Ds = y((ux, ha$1) => {
	function up(t, e) {
		for (var s = 1, r = t.length, n = t[0], i = t[0], o = 1; o < r; ++o) if (i = n, n = t[o], e(n, i)) {
			if (o === s) {
				s++;
				continue;
			}
			t[s++] = n;
		}
		return t.length = s, t;
	}
	function lp(t) {
		for (var e = 1, s = t.length, r = t[0], n = t[0], i = 1; i < s; ++i, n = r) if (n = r, r = t[i], r !== n) {
			if (i === e) {
				e++;
				continue;
			}
			t[e++] = r;
		}
		return t.length = e, t;
	}
	function cp(t, e, s) {
		return t.length === 0 ? t : e ? (s || t.sort(e), up(t, e)) : (s || t.sort(), lp(t));
	}
	ha$1.exports = cp;
});
var de = y((sr$1, ma$1) => {
	sr$1.__esModule = !0;
	var da$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
		return typeof t;
	} : function(t) {
		return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
	};
	function fp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	var pp = function t(e, s) {
		if ((typeof e > "u" ? "undefined" : da$1(e)) !== "object") return e;
		var r = new e.constructor();
		for (var n in e) if (e.hasOwnProperty(n)) {
			var i = e[n], o = typeof i > "u" ? "undefined" : da$1(i);
			n === "parent" && o === "object" ? s && (r[n] = s) : i instanceof Array ? r[n] = i.map(function(a) {
				return t(a, r);
			}) : r[n] = t(i, r);
		}
		return r;
	};
	sr$1.default = function() {
		function t() {
			var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
			fp(this, t);
			for (var s in e) this[s] = e[s];
			var r = e.spaces;
			r = r === void 0 ? {} : r;
			var n = r.before, i = n === void 0 ? "" : n, o = r.after;
			this.spaces = {
				before: i,
				after: o === void 0 ? "" : o
			};
		}
		return t.prototype.remove = function() {
			return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
		}, t.prototype.replaceWith = function() {
			if (this.parent) {
				for (var s in arguments) this.parent.insertBefore(this, arguments[s]);
				this.remove();
			}
			return this;
		}, t.prototype.next = function() {
			return this.parent.at(this.parent.index(this) + 1);
		}, t.prototype.prev = function() {
			return this.parent.at(this.parent.index(this) - 1);
		}, t.prototype.clone = function() {
			var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = pp(this);
			for (var n in s) r[n] = s[n];
			return r;
		}, t.prototype.toString = function() {
			return [
				this.spaces.before,
				String(this.value),
				this.spaces.after
			].join("");
		}, t;
	}();
	ma$1.exports = sr$1.default;
});
var D = y((B$1) => {
	B$1.__esModule = !0;
	B$1.TAG = "tag";
	B$1.STRING = "string";
	B$1.SELECTOR = "selector";
	B$1.ROOT = "root";
	B$1.PSEUDO = "pseudo";
	B$1.NESTING = "nesting";
	B$1.ID = "id";
	B$1.COMMENT = "comment";
	B$1.COMBINATOR = "combinator";
	B$1.CLASS = "class";
	B$1.ATTRIBUTE = "attribute";
	B$1.UNIVERSAL = "universal";
});
var ir = y((nr$1, ya$1) => {
	nr$1.__esModule = !0;
	var dp = function() {
		function t(e, s) {
			for (var r = 0; r < s.length; r++) {
				var n = s[r];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
			}
		}
		return function(e, s, r) {
			return s && t(e.prototype, s), r && t(e, r), e;
		};
	}(), yp = vp(de()), X$1 = gp(D());
	function gp(t) {
		if (t && t.__esModule) return t;
		var e = {};
		if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
		return e.default = t, e;
	}
	function vp(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function xp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function bp(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function _p(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	nr$1.default = function(t) {
		_p(e, t);
		function e(s) {
			xp(this, e);
			var r = bp(this, t.call(this, s));
			return r.nodes || (r.nodes = []), r;
		}
		return e.prototype.append = function(r) {
			return r.parent = this, this.nodes.push(r), this;
		}, e.prototype.prepend = function(r) {
			return r.parent = this, this.nodes.unshift(r), this;
		}, e.prototype.at = function(r) {
			return this.nodes[r];
		}, e.prototype.index = function(r) {
			return typeof r == "number" ? r : this.nodes.indexOf(r);
		}, e.prototype.removeChild = function(r) {
			r = this.index(r), this.at(r).parent = void 0, this.nodes.splice(r, 1);
			var n = void 0;
			for (var i in this.indexes) n = this.indexes[i], n >= r && (this.indexes[i] = n - 1);
			return this;
		}, e.prototype.removeAll = function() {
			for (var i = this.nodes, r = Array.isArray(i), n = 0, i = r ? i : i[Symbol.iterator]();;) {
				var o;
				if (r) {
					if (n >= i.length) break;
					o = i[n++];
				} else {
					if (n = i.next(), n.done) break;
					o = n.value;
				}
				var a = o;
				a.parent = void 0;
			}
			return this.nodes = [], this;
		}, e.prototype.empty = function() {
			return this.removeAll();
		}, e.prototype.insertAfter = function(r, n) {
			var i = this.index(r);
			this.nodes.splice(i + 1, 0, n);
			var o = void 0;
			for (var a in this.indexes) o = this.indexes[a], i <= o && (this.indexes[a] = o + this.nodes.length);
			return this;
		}, e.prototype.insertBefore = function(r, n) {
			var i = this.index(r);
			this.nodes.splice(i, 0, n);
			var o = void 0;
			for (var a in this.indexes) o = this.indexes[a], i <= o && (this.indexes[a] = o + this.nodes.length);
			return this;
		}, e.prototype.each = function(r) {
			this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
			var n = this.lastEach;
			if (this.indexes[n] = 0, !!this.length) {
				for (var i = void 0, o = void 0; this.indexes[n] < this.length && (i = this.indexes[n], o = r(this.at(i), i), o !== !1);) this.indexes[n] += 1;
				if (delete this.indexes[n], o === !1) return !1;
			}
		}, e.prototype.walk = function(r) {
			return this.each(function(n, i) {
				var o = r(n, i);
				if (o !== !1 && n.length && (o = n.walk(r)), o === !1) return !1;
			});
		}, e.prototype.walkAttributes = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.ATTRIBUTE) return r.call(n, i);
			});
		}, e.prototype.walkClasses = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.CLASS) return r.call(n, i);
			});
		}, e.prototype.walkCombinators = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.COMBINATOR) return r.call(n, i);
			});
		}, e.prototype.walkComments = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.COMMENT) return r.call(n, i);
			});
		}, e.prototype.walkIds = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.ID) return r.call(n, i);
			});
		}, e.prototype.walkNesting = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.NESTING) return r.call(n, i);
			});
		}, e.prototype.walkPseudos = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.PSEUDO) return r.call(n, i);
			});
		}, e.prototype.walkTags = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.TAG) return r.call(n, i);
			});
		}, e.prototype.walkUniversals = function(r) {
			var n = this;
			return this.walk(function(i) {
				if (i.type === X$1.UNIVERSAL) return r.call(n, i);
			});
		}, e.prototype.split = function(r) {
			var n = this, i = [];
			return this.reduce(function(o, a, u) {
				var c = r.call(n, a);
				return i.push(a), c ? (o.push(i), i = []) : u === n.length - 1 && o.push(i), o;
			}, []);
		}, e.prototype.map = function(r) {
			return this.nodes.map(r);
		}, e.prototype.reduce = function(r, n) {
			return this.nodes.reduce(r, n);
		}, e.prototype.every = function(r) {
			return this.nodes.every(r);
		}, e.prototype.some = function(r) {
			return this.nodes.some(r);
		}, e.prototype.filter = function(r) {
			return this.nodes.filter(r);
		}, e.prototype.sort = function(r) {
			return this.nodes.sort(r);
		}, e.prototype.toString = function() {
			return this.map(String).join("");
		}, dp(e, [
			{
				key: "first",
				get: function() {
					return this.at(0);
				}
			},
			{
				key: "last",
				get: function() {
					return this.at(this.length - 1);
				}
			},
			{
				key: "length",
				get: function() {
					return this.nodes.length;
				}
			}
		]), e;
	}(yp.default);
	ya$1.exports = nr$1.default;
});
var ga = y((or$2, wa$1) => {
	or$2.__esModule = !0;
	var Sp = Op(ir()), Tp = D();
	function Op(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Cp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Ap(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Np(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	or$2.default = function(t) {
		Np(e, t);
		function e(s) {
			Cp(this, e);
			var r = Ap(this, t.call(this, s));
			return r.type = Tp.ROOT, r;
		}
		return e.prototype.toString = function() {
			var r = this.reduce(function(n, i) {
				var o = String(i);
				return o ? n + o + "," : "";
			}, "").slice(0, -1);
			return this.trailingComma ? r + "," : r;
		}, e;
	}(Sp.default);
	wa$1.exports = or$2.default;
});
var xa = y((ar$1, va$1) => {
	ar$1.__esModule = !0;
	var Ip = Lp(ir()), qp = D();
	function Lp(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Dp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Mp(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Bp(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	ar$1.default = function(t) {
		Bp(e, t);
		function e(s) {
			Dp(this, e);
			var r = Mp(this, t.call(this, s));
			return r.type = qp.SELECTOR, r;
		}
		return e;
	}(Ip.default);
	va$1.exports = ar$1.default;
});
var qe = y((ur$1, ba$1) => {
	ur$1.__esModule = !0;
	var Fp = function() {
		function t(e, s) {
			for (var r = 0; r < s.length; r++) {
				var n = s[r];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
			}
		}
		return function(e, s, r) {
			return s && t(e.prototype, s), r && t(e, r), e;
		};
	}(), Wp = Yp(de());
	function Yp(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function zp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Vp(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Gp(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	ur$1.default = function(t) {
		Gp(e, t);
		function e() {
			return zp(this, e), Vp(this, t.apply(this, arguments));
		}
		return e.prototype.toString = function() {
			return [
				this.spaces.before,
				this.ns,
				String(this.value),
				this.spaces.after
			].join("");
		}, Fp(e, [{
			key: "ns",
			get: function() {
				var r = this.namespace;
				return r ? (typeof r == "string" ? r : "") + "|" : "";
			}
		}]), e;
	}(Wp.default);
	ba$1.exports = ur$1.default;
});
var ka = y((lr$1, _a$1) => {
	lr$1.__esModule = !0;
	var Kp = Jp(qe()), Qp = D();
	function Jp(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Xp(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Zp(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function eh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	lr$1.default = function(t) {
		eh(e, t);
		function e(s) {
			Xp(this, e);
			var r = Zp(this, t.call(this, s));
			return r.type = Qp.CLASS, r;
		}
		return e.prototype.toString = function() {
			return [
				this.spaces.before,
				this.ns,
				"." + this.value,
				this.spaces.after
			].join("");
		}, e;
	}(Kp.default);
	_a$1.exports = lr$1.default;
});
var Sa = y((cr$1, Ea$1) => {
	cr$1.__esModule = !0;
	var sh = ih(de()), nh = D();
	function ih(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function oh(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function ah(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function uh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	cr$1.default = function(t) {
		uh(e, t);
		function e(s) {
			oh(this, e);
			var r = ah(this, t.call(this, s));
			return r.type = nh.COMMENT, r;
		}
		return e;
	}(sh.default);
	Ea$1.exports = cr$1.default;
});
var Oa = y((fr$1, Ta$1) => {
	fr$1.__esModule = !0;
	var fh = hh(qe()), ph = D();
	function hh(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function dh(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function mh(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function yh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	fr$1.default = function(t) {
		yh(e, t);
		function e(s) {
			dh(this, e);
			var r = mh(this, t.call(this, s));
			return r.type = ph.ID, r;
		}
		return e.prototype.toString = function() {
			return [
				this.spaces.before,
				this.ns,
				"#" + this.value,
				this.spaces.after
			].join("");
		}, e;
	}(fh.default);
	Ta$1.exports = fr$1.default;
});
var Aa = y((pr$1, Ca) => {
	pr$1.__esModule = !0;
	var vh = bh(qe()), xh = D();
	function bh(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function _h(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function kh(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Eh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	pr$1.default = function(t) {
		Eh(e, t);
		function e(s) {
			_h(this, e);
			var r = kh(this, t.call(this, s));
			return r.type = xh.TAG, r;
		}
		return e;
	}(vh.default);
	Ca.exports = pr$1.default;
});
var Pa = y((hr$1, Na$1) => {
	hr$1.__esModule = !0;
	var Oh = Ah(de()), Ch$1 = D();
	function Ah(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Nh(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Ph(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Rh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	hr$1.default = function(t) {
		Rh(e, t);
		function e(s) {
			Nh(this, e);
			var r = Ph(this, t.call(this, s));
			return r.type = Ch$1.STRING, r;
		}
		return e;
	}(Oh.default);
	Na$1.exports = hr$1.default;
});
var Ia = y((dr$1, Ra) => {
	dr$1.__esModule = !0;
	var Lh = Mh(ir()), Dh = D();
	function Mh(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Bh(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function Uh(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Fh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	dr$1.default = function(t) {
		Fh(e, t);
		function e(s) {
			Bh(this, e);
			var r = Uh(this, t.call(this, s));
			return r.type = Dh.PSEUDO, r;
		}
		return e.prototype.toString = function() {
			var r = this.length ? "(" + this.map(String).join(",") + ")" : "";
			return [
				this.spaces.before,
				String(this.value),
				r,
				this.spaces.after
			].join("");
		}, e;
	}(Lh.default);
	Ra.exports = dr$1.default;
});
var La = y((mr$1, qa$1) => {
	mr$1.__esModule = !0;
	var Yh = Vh(qe()), zh = D();
	function Vh(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function Gh(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function jh(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function Hh(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	mr$1.default = function(t) {
		Hh(e, t);
		function e(s) {
			Gh(this, e);
			var r = jh(this, t.call(this, s));
			return r.type = zh.ATTRIBUTE, r.raws = {}, r;
		}
		return e.prototype.toString = function() {
			var r = [
				this.spaces.before,
				"[",
				this.ns,
				this.attribute
			];
			return this.operator && r.push(this.operator), this.value && r.push(this.value), this.raws.insensitive ? r.push(this.raws.insensitive) : this.insensitive && r.push(" i"), r.push("]"), r.concat(this.spaces.after).join("");
		}, e;
	}(Yh.default);
	qa$1.exports = mr$1.default;
});
var Ma = y((yr$1, Da$1) => {
	yr$1.__esModule = !0;
	var Jh = Zh(qe()), Xh = D();
	function Zh(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function ed(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function td(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function rd(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	yr$1.default = function(t) {
		rd(e, t);
		function e(s) {
			ed(this, e);
			var r = td(this, t.call(this, s));
			return r.type = Xh.UNIVERSAL, r.value = "*", r;
		}
		return e;
	}(Jh.default);
	Da$1.exports = yr$1.default;
});
var Ua = y((wr$1, Ba$1) => {
	wr$1.__esModule = !0;
	var id = ad(de()), od = D();
	function ad(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function ud(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function ld(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function cd(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	wr$1.default = function(t) {
		cd(e, t);
		function e(s) {
			ud(this, e);
			var r = ld(this, t.call(this, s));
			return r.type = od.COMBINATOR, r;
		}
		return e;
	}(id.default);
	Ba$1.exports = wr$1.default;
});
var $a = y((gr$1, Fa$1) => {
	gr$1.__esModule = !0;
	var hd = md(de()), dd = D();
	function md(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function yd(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	function wd(t, e) {
		if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e && (typeof e == "object" || typeof e == "function") ? e : t;
	}
	function gd(t, e) {
		if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, { constructor: {
			value: t,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
	}
	gr$1.default = function(t) {
		gd(e, t);
		function e(s) {
			yd(this, e);
			var r = wd(this, t.call(this, s));
			return r.type = dd.NESTING, r.value = "&", r;
		}
		return e;
	}(hd.default);
	Fa$1.exports = gr$1.default;
});
var Ya = y((vr$1, Wa) => {
	vr$1.__esModule = !0;
	vr$1.default = xd;
	function xd(t) {
		return t.sort(function(e, s) {
			return e - s;
		});
	}
	Wa.exports = vr$1.default;
});
var Xa = y((_r$1, Ja) => {
	_r$1.__esModule = !0;
	_r$1.default = Pd;
	var za = 39, bd = 34, Ms$1 = 92, Va$1 = 47, xt$1 = 10, Bs$1 = 32, Us = 12, Fs = 9, $s$1 = 13, Ga$1 = 43, ja = 62, Ha$1 = 126, Ka = 124, _d = 44, kd = 40, Ed = 41, Sd = 91, Td = 93, Od = 59, Qa = 42, Cd = 58, Ad = 38, Nd = 64, xr$1 = /[ \n\t\r\{\(\)'"\\;/]/g, br$1 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
	function Pd(t) {
		for (var e = [], s = t.css.valueOf(), r = void 0, n = void 0, i = void 0, o = void 0, a = void 0, u = void 0, c = void 0, f = void 0, p = void 0, l = void 0, w$1 = void 0, x = s.length, h$1 = -1, d = 1, m$1 = 0, b$1 = function(v$1, R) {
			if (t.safe) s += R, n = s.length - 1;
			else throw t.error("Unclosed " + v$1, d, m$1 - h$1, m$1);
		}; m$1 < x;) {
			switch (r = s.charCodeAt(m$1), r === xt$1 && (h$1 = m$1, d += 1), r) {
				case xt$1:
				case Bs$1:
				case Fs:
				case $s$1:
				case Us:
					n = m$1;
					do
						n += 1, r = s.charCodeAt(n), r === xt$1 && (h$1 = n, d += 1);
					while (r === Bs$1 || r === xt$1 || r === Fs || r === $s$1 || r === Us);
					e.push([
						"space",
						s.slice(m$1, n),
						d,
						m$1 - h$1,
						m$1
					]), m$1 = n - 1;
					break;
				case Ga$1:
				case ja:
				case Ha$1:
				case Ka:
					n = m$1;
					do
						n += 1, r = s.charCodeAt(n);
					while (r === Ga$1 || r === ja || r === Ha$1 || r === Ka);
					e.push([
						"combinator",
						s.slice(m$1, n),
						d,
						m$1 - h$1,
						m$1
					]), m$1 = n - 1;
					break;
				case Qa:
					e.push([
						"*",
						"*",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Ad:
					e.push([
						"&",
						"&",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case _d:
					e.push([
						",",
						",",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Sd:
					e.push([
						"[",
						"[",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Td:
					e.push([
						"]",
						"]",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Cd:
					e.push([
						":",
						":",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Od:
					e.push([
						";",
						";",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case kd:
					e.push([
						"(",
						"(",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case Ed:
					e.push([
						")",
						")",
						d,
						m$1 - h$1,
						m$1
					]);
					break;
				case za:
				case bd:
					i = r === za ? "'" : "\"", n = m$1;
					do
						for (l = !1, n = s.indexOf(i, n + 1), n === -1 && b$1("quote", i), w$1 = n; s.charCodeAt(w$1 - 1) === Ms$1;) w$1 -= 1, l = !l;
					while (l);
					e.push([
						"string",
						s.slice(m$1, n + 1),
						d,
						m$1 - h$1,
						d,
						n - h$1,
						m$1
					]), m$1 = n;
					break;
				case Nd:
					xr$1.lastIndex = m$1 + 1, xr$1.test(s), xr$1.lastIndex === 0 ? n = s.length - 1 : n = xr$1.lastIndex - 2, e.push([
						"at-word",
						s.slice(m$1, n + 1),
						d,
						m$1 - h$1,
						d,
						n - h$1,
						m$1
					]), m$1 = n;
					break;
				case Ms$1:
					for (n = m$1, c = !0; s.charCodeAt(n + 1) === Ms$1;) n += 1, c = !c;
					r = s.charCodeAt(n + 1), c && r !== Va$1 && r !== Bs$1 && r !== xt$1 && r !== Fs && r !== $s$1 && r !== Us && (n += 1), e.push([
						"word",
						s.slice(m$1, n + 1),
						d,
						m$1 - h$1,
						d,
						n - h$1,
						m$1
					]), m$1 = n;
					break;
				default:
					r === Va$1 && s.charCodeAt(m$1 + 1) === Qa ? (n = s.indexOf("*/", m$1 + 2) + 1, n === 0 && b$1("comment", "*/"), u = s.slice(m$1, n + 1), o = u.split(`
`), a = o.length - 1, a > 0 ? (f = d + a, p = n - o[a].length) : (f = d, p = h$1), e.push([
						"comment",
						u,
						d,
						m$1 - h$1,
						f,
						n - p,
						m$1
					]), h$1 = p, d = f, m$1 = n) : (br$1.lastIndex = m$1 + 1, br$1.test(s), br$1.lastIndex === 0 ? n = s.length - 1 : n = br$1.lastIndex - 2, e.push([
						"word",
						s.slice(m$1, n + 1),
						d,
						m$1 - h$1,
						d,
						n - h$1,
						m$1
					]), m$1 = n);
					break;
			}
			m$1++;
		}
		return e;
	}
	Ja.exports = _r$1.default;
});
var tu = y((kr$1, eu) => {
	kr$1.__esModule = !0;
	var Rd = function() {
		function t(e, s) {
			for (var r = 0; r < s.length; r++) {
				var n = s[r];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
			}
		}
		return function(e, s, r) {
			return s && t(e.prototype, s), r && t(e, r), e;
		};
	}(), qd = I$1(qs()), Ws$1 = I$1(Ls()), Md = I$1(Ds()), Ud = I$1(ga()), Ys$1 = I$1(xa()), Wd = I$1(ka()), zd = I$1(Sa()), Gd = I$1(Oa()), Hd = I$1(Aa()), Qd = I$1(Pa()), Xd = I$1(Ia()), em = I$1(La()), rm = I$1(Ma()), nm = I$1(Ua()), om = I$1($a()), um = I$1(Ya()), Za = I$1(Xa()), fm = pm(D());
	function pm(t) {
		if (t && t.__esModule) return t;
		var e = {};
		if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
		return e.default = t, e;
	}
	function I$1(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function hm(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	kr$1.default = function() {
		function t(e) {
			hm(this, t), this.input = e, this.lossy = e.options.lossless === !1, this.position = 0, this.root = new Ud.default();
			var s = new Ys$1.default();
			return this.root.append(s), this.current = s, this.lossy ? this.tokens = (0, Za.default)({
				safe: e.safe,
				css: e.css.trim()
			}) : this.tokens = (0, Za.default)(e), this.loop();
		}
		return t.prototype.attribute = function() {
			var s = "", r = void 0, n = this.currToken;
			for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]";) s += this.tokens[this.position][1], this.position++;
			this.position === this.tokens.length && !~s.indexOf("]") && this.error("Expected a closing square bracket.");
			var i = s.split(/((?:[*~^$|]?=))([^]*)/), o = i[0].split(/(\|)/g), a = {
				operator: i[1],
				value: i[2],
				source: {
					start: {
						line: n[2],
						column: n[3]
					},
					end: {
						line: this.currToken[2],
						column: this.currToken[3]
					}
				},
				sourceIndex: n[4]
			};
			if (o.length > 1 ? (o[0] === "" && (o[0] = !0), a.attribute = this.parseValue(o[2]), a.namespace = this.parseNamespace(o[0])) : a.attribute = this.parseValue(i[0]), r = new em.default(a), i[2]) {
				var u = i[2].split(/(\s+i\s*?)$/), c = u[0].trim();
				r.value = this.lossy ? c : u[0], u[1] && (r.insensitive = !0, this.lossy || (r.raws.insensitive = u[1])), r.quoted = c[0] === "'" || c[0] === "\"", r.raws.unquoted = r.quoted ? c.slice(1, -1) : c;
			}
			this.newNode(r), this.position++;
		}, t.prototype.combinator = function() {
			if (this.currToken[1] === "|") return this.namespace();
			for (var s = new nm.default({
				value: "",
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[2],
						column: this.currToken[3]
					}
				},
				sourceIndex: this.currToken[4]
			}); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator");) this.nextToken && this.nextToken[0] === "combinator" ? (s.spaces.before = this.parseSpace(this.currToken[1]), s.source.start.line = this.nextToken[2], s.source.start.column = this.nextToken[3], s.source.end.column = this.nextToken[3], s.source.end.line = this.nextToken[2], s.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? s.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? s.value = this.currToken[1] : this.currToken[0] === "space" && (s.value = this.parseSpace(this.currToken[1], " ")), this.position++;
			return this.newNode(s);
		}, t.prototype.comma = function() {
			if (this.position === this.tokens.length - 1) {
				this.root.trailingComma = !0, this.position++;
				return;
			}
			var s = new Ys$1.default();
			this.current.parent.append(s), this.current = s, this.position++;
		}, t.prototype.comment = function() {
			var s = new zd.default({
				value: this.currToken[1],
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[4],
						column: this.currToken[5]
					}
				},
				sourceIndex: this.currToken[6]
			});
			this.newNode(s), this.position++;
		}, t.prototype.error = function(s) {
			throw new this.input.error(s);
		}, t.prototype.missingBackslash = function() {
			return this.error("Expected a backslash preceding the semicolon.");
		}, t.prototype.missingParenthesis = function() {
			return this.error("Expected opening parenthesis.");
		}, t.prototype.missingSquareBracket = function() {
			return this.error("Expected opening square bracket.");
		}, t.prototype.namespace = function() {
			var s = this.prevToken && this.prevToken[1] || !0;
			if (this.nextToken[0] === "word") return this.position++, this.word(s);
			if (this.nextToken[0] === "*") return this.position++, this.universal(s);
		}, t.prototype.nesting = function() {
			this.newNode(new om.default({
				value: this.currToken[1],
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[2],
						column: this.currToken[3]
					}
				},
				sourceIndex: this.currToken[4]
			})), this.position++;
		}, t.prototype.parentheses = function() {
			var s = this.current.last;
			if (s && s.type === fm.PSEUDO) {
				var r = new Ys$1.default(), n = this.current;
				s.append(r), this.current = r;
				var i = 1;
				for (this.position++; this.position < this.tokens.length && i;) this.currToken[0] === "(" && i++, this.currToken[0] === ")" && i--, i ? this.parse() : (r.parent.source.end.line = this.currToken[2], r.parent.source.end.column = this.currToken[3], this.position++);
				i && this.error("Expected closing parenthesis."), this.current = n;
			} else {
				var o = 1;
				for (this.position++, s.value += "("; this.position < this.tokens.length && o;) this.currToken[0] === "(" && o++, this.currToken[0] === ")" && o--, s.value += this.parseParenthesisToken(this.currToken), this.position++;
				o && this.error("Expected closing parenthesis.");
			}
		}, t.prototype.pseudo = function() {
			for (var s = this, r = "", n = this.currToken; this.currToken && this.currToken[0] === ":";) r += this.currToken[1], this.position++;
			if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
			if (this.currToken[0] === "word") {
				var i = void 0;
				this.splitWord(!1, function(o, a) {
					r += o, i = new Xd.default({
						value: r,
						source: {
							start: {
								line: n[2],
								column: n[3]
							},
							end: {
								line: s.currToken[4],
								column: s.currToken[5]
							}
						},
						sourceIndex: n[4]
					}), s.newNode(i), a > 1 && s.nextToken && s.nextToken[0] === "(" && s.error("Misplaced parenthesis.");
				});
			} else this.error("Unexpected \"" + this.currToken[0] + "\" found.");
		}, t.prototype.space = function() {
			var s = this.currToken;
			this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(s[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(s[1]), this.position++) : this.combinator();
		}, t.prototype.string = function() {
			var s = this.currToken;
			this.newNode(new Qd.default({
				value: this.currToken[1],
				source: {
					start: {
						line: s[2],
						column: s[3]
					},
					end: {
						line: s[4],
						column: s[5]
					}
				},
				sourceIndex: s[6]
			})), this.position++;
		}, t.prototype.universal = function(s) {
			var r = this.nextToken;
			if (r && r[1] === "|") return this.position++, this.namespace();
			this.newNode(new rm.default({
				value: this.currToken[1],
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[2],
						column: this.currToken[3]
					}
				},
				sourceIndex: this.currToken[4]
			}), s), this.position++;
		}, t.prototype.splitWord = function(s, r) {
			for (var n = this, i = this.nextToken, o = this.currToken[1]; i && i[0] === "word";) {
				this.position++;
				var a = this.currToken[1];
				if (o += a, a.lastIndexOf("\\") === a.length - 1) {
					var u = this.nextToken;
					u && u[0] === "space" && (o += this.parseSpace(u[1], " "), this.position++);
				}
				i = this.nextToken;
			}
			var c = (0, Ws$1.default)(o, "."), f = (0, Ws$1.default)(o, "#"), p = (0, Ws$1.default)(o, "#{");
			p.length && (f = f.filter(function(w$1) {
				return !~p.indexOf(w$1);
			}));
			var l = (0, um.default)((0, Md.default)((0, qd.default)([
				[0],
				c,
				f
			])));
			l.forEach(function(w$1, x) {
				var h$1 = l[x + 1] || o.length, d = o.slice(w$1, h$1);
				if (x === 0 && r) return r.call(n, d, l.length);
				var m$1 = void 0;
				~c.indexOf(w$1) ? m$1 = new Wd.default({
					value: d.slice(1),
					source: {
						start: {
							line: n.currToken[2],
							column: n.currToken[3] + w$1
						},
						end: {
							line: n.currToken[4],
							column: n.currToken[3] + (h$1 - 1)
						}
					},
					sourceIndex: n.currToken[6] + l[x]
				}) : ~f.indexOf(w$1) ? m$1 = new Gd.default({
					value: d.slice(1),
					source: {
						start: {
							line: n.currToken[2],
							column: n.currToken[3] + w$1
						},
						end: {
							line: n.currToken[4],
							column: n.currToken[3] + (h$1 - 1)
						}
					},
					sourceIndex: n.currToken[6] + l[x]
				}) : m$1 = new Hd.default({
					value: d,
					source: {
						start: {
							line: n.currToken[2],
							column: n.currToken[3] + w$1
						},
						end: {
							line: n.currToken[4],
							column: n.currToken[3] + (h$1 - 1)
						}
					},
					sourceIndex: n.currToken[6] + l[x]
				}), n.newNode(m$1, s);
			}), this.position++;
		}, t.prototype.word = function(s) {
			var r = this.nextToken;
			return r && r[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(s);
		}, t.prototype.loop = function() {
			for (; this.position < this.tokens.length;) this.parse(!0);
			return this.root;
		}, t.prototype.parse = function(s) {
			switch (this.currToken[0]) {
				case "space":
					this.space();
					break;
				case "comment":
					this.comment();
					break;
				case "(":
					this.parentheses();
					break;
				case ")":
					s && this.missingParenthesis();
					break;
				case "[":
					this.attribute();
					break;
				case "]":
					this.missingSquareBracket();
					break;
				case "at-word":
				case "word":
					this.word();
					break;
				case ":":
					this.pseudo();
					break;
				case ";":
					this.missingBackslash();
					break;
				case ",":
					this.comma();
					break;
				case "*":
					this.universal();
					break;
				case "&":
					this.nesting();
					break;
				case "combinator":
					this.combinator();
					break;
				case "string":
					this.string();
					break;
			}
		}, t.prototype.parseNamespace = function(s) {
			if (this.lossy && typeof s == "string") {
				var r = s.trim();
				return r.length ? r : !0;
			}
			return s;
		}, t.prototype.parseSpace = function(s, r) {
			return this.lossy ? r || "" : s;
		}, t.prototype.parseValue = function(s) {
			return this.lossy && s && typeof s == "string" ? s.trim() : s;
		}, t.prototype.parseParenthesisToken = function(s) {
			return this.lossy ? s[0] === "space" ? this.parseSpace(s[1], " ") : this.parseValue(s[1]) : s[1];
		}, t.prototype.newNode = function(s, r) {
			return r && (s.namespace = this.parseNamespace(r)), this.spaces && (s.spaces.before = this.spaces, this.spaces = ""), this.current.append(s);
		}, Rd(t, [
			{
				key: "currToken",
				get: function() {
					return this.tokens[this.position];
				}
			},
			{
				key: "nextToken",
				get: function() {
					return this.tokens[this.position + 1];
				}
			},
			{
				key: "prevToken",
				get: function() {
					return this.tokens[this.position - 1];
				}
			}
		]), t;
	}();
	eu.exports = kr$1.default;
});
var su = y((Er$1, ru) => {
	Er$1.__esModule = !0;
	var mm = function() {
		function t(e, s) {
			for (var r = 0; r < s.length; r++) {
				var n = s[r];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
			}
		}
		return function(e, s, r) {
			return s && t(e.prototype, s), r && t(e, r), e;
		};
	}(), wm = gm(tu());
	function gm(t) {
		return t && t.__esModule ? t : { default: t };
	}
	function vm(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	}
	Er$1.default = function() {
		function t(e) {
			return vm(this, t), this.func = e || function() {}, this;
		}
		return t.prototype.process = function(s) {
			var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = new wm.default({
				css: s,
				error: function(o) {
					throw new Error(o);
				},
				options: r
			});
			return this.res = n, this.func(n), this;
		}, mm(t, [{
			key: "result",
			get: function() {
				return String(this.res);
			}
		}]), t;
	}();
	ru.exports = Er$1.default;
});
var z = y((Sx, iu) => {
	var zs$1 = function(t, e) {
		let s = new t.constructor();
		for (let r in t) {
			if (!t.hasOwnProperty(r)) continue;
			let n = t[r], i = typeof n;
			r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : n instanceof Array ? s[r] = n.map((o) => zs$1(o, s)) : r !== "before" && r !== "after" && r !== "between" && r !== "semicolon" && (i === "object" && n !== null && (n = zs$1(n)), s[r] = n);
		}
		return s;
	};
	iu.exports = class {
		constructor(e) {
			e = e || {}, this.raws = {
				before: "",
				after: ""
			};
			for (let s in e) this[s] = e[s];
		}
		remove() {
			return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
		}
		toString() {
			return [
				this.raws.before,
				String(this.value),
				this.raws.after
			].join("");
		}
		clone(e) {
			e = e || {};
			let s = zs$1(this);
			for (let r in e) s[r] = e[r];
			return s;
		}
		cloneBefore(e) {
			e = e || {};
			let s = this.clone(e);
			return this.parent.insertBefore(this, s), s;
		}
		cloneAfter(e) {
			e = e || {};
			let s = this.clone(e);
			return this.parent.insertAfter(this, s), s;
		}
		replaceWith() {
			let e = Array.prototype.slice.call(arguments);
			if (this.parent) {
				for (let s of e) this.parent.insertBefore(this, s);
				this.remove();
			}
			return this;
		}
		moveTo(e) {
			return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
		}
		moveBefore(e) {
			return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
		}
		moveAfter(e) {
			return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
		}
		next() {
			let e = this.parent.index(this);
			return this.parent.nodes[e + 1];
		}
		prev() {
			let e = this.parent.index(this);
			return this.parent.nodes[e - 1];
		}
		toJSON() {
			let e = {};
			for (let s in this) {
				if (!this.hasOwnProperty(s) || s === "parent") continue;
				let r = this[s];
				r instanceof Array ? e[s] = r.map((n) => typeof n == "object" && n.toJSON ? n.toJSON() : n) : typeof r == "object" && r.toJSON ? e[s] = r.toJSON() : e[s] = r;
			}
			return e;
		}
		root() {
			let e = this;
			for (; e.parent;) e = e.parent;
			return e;
		}
		cleanRaws(e) {
			delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
		}
		positionInside(e) {
			let s = this.toString(), r = this.source.start.column, n = this.source.start.line;
			for (let i = 0; i < e; i++) s[i] === `
` ? (r = 1, n += 1) : r += 1;
			return {
				line: n,
				column: r
			};
		}
		positionBy(e) {
			let s = this.source.start;
			if (Object(e).index) s = this.positionInside(e.index);
			else if (Object(e).word) {
				let r = this.toString().indexOf(e.word);
				r !== -1 && (s = this.positionInside(r));
			}
			return s;
		}
	};
});
var U = y((Tx, ou) => {
	var _m = z(), Le$1 = class extends _m {
		constructor(e) {
			super(e), this.nodes || (this.nodes = []);
		}
		push(e) {
			return e.parent = this, this.nodes.push(e), this;
		}
		each(e) {
			this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
			let s = this.lastEach, r, n;
			if (this.indexes[s] = 0, !!this.nodes) {
				for (; this.indexes[s] < this.nodes.length && (r = this.indexes[s], n = e(this.nodes[r], r), n !== !1);) this.indexes[s] += 1;
				return delete this.indexes[s], n;
			}
		}
		walk(e) {
			return this.each((s, r) => {
				let n = e(s, r);
				return n !== !1 && s.walk && (n = s.walk(e)), n;
			});
		}
		walkType(e, s) {
			if (!e || !s) throw new Error("Parameters {type} and {callback} are required.");
			let r = typeof e == "function";
			return this.walk((n, i) => {
				if (r && n instanceof e || !r && n.type === e) return s.call(this, n, i);
			});
		}
		append(e) {
			return e.parent = this, this.nodes.push(e), this;
		}
		prepend(e) {
			return e.parent = this, this.nodes.unshift(e), this;
		}
		cleanRaws(e) {
			if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
		}
		insertAfter(e, s) {
			let r = this.index(e), n;
			this.nodes.splice(r + 1, 0, s);
			for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
			return this;
		}
		insertBefore(e, s) {
			let r = this.index(e), n;
			this.nodes.splice(r, 0, s);
			for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
			return this;
		}
		removeChild(e) {
			e = this.index(e), this.nodes[e].parent = void 0, this.nodes.splice(e, 1);
			let s;
			for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
			return this;
		}
		removeAll() {
			for (let e of this.nodes) e.parent = void 0;
			return this.nodes = [], this;
		}
		every(e) {
			return this.nodes.every(e);
		}
		some(e) {
			return this.nodes.some(e);
		}
		index(e) {
			return typeof e == "number" ? e : this.nodes.indexOf(e);
		}
		get first() {
			if (this.nodes) return this.nodes[0];
		}
		get last() {
			if (this.nodes) return this.nodes[this.nodes.length - 1];
		}
		toString() {
			let e = this.nodes.map(String).join("");
			return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
		}
	};
	Le$1.registerWalker = (t) => {
		let e = "walk" + t.name;
		e.lastIndexOf("s") !== e.length - 1 && (e += "s"), !Le$1.prototype[e] && (Le$1.prototype[e] = function(s) {
			return this.walkType(t, s);
		});
	};
	ou.exports = Le$1;
});
var uu = y((Cx, au) => {
	var km = U();
	au.exports = class extends km {
		constructor(e) {
			super(e), this.type = "root";
		}
	};
});
var cu = y((Nx, lu) => {
	var Em = U();
	lu.exports = class extends Em {
		constructor(e) {
			super(e), this.type = "value", this.unbalanced = 0;
		}
	};
});
var hu = y((Px, pu) => {
	var fu = U(), Sr$1 = class extends fu {
		constructor(e) {
			super(e), this.type = "atword";
		}
		toString() {
			this.quoted && this.raws.quote;
			return [
				this.raws.before,
				"@",
				String.prototype.toString.call(this.value),
				this.raws.after
			].join("");
		}
	};
	fu.registerWalker(Sr$1);
	pu.exports = Sr$1;
});
var mu = y((Rx, du) => {
	var Sm = U(), Tm = z(), Tr$1 = class extends Tm {
		constructor(e) {
			super(e), this.type = "colon";
		}
	};
	Sm.registerWalker(Tr$1);
	du.exports = Tr$1;
});
var wu = y((Ix, yu) => {
	var Om = U(), Cm = z(), Or$1 = class extends Cm {
		constructor(e) {
			super(e), this.type = "comma";
		}
	};
	Om.registerWalker(Or$1);
	yu.exports = Or$1;
});
var vu = y((qx, gu$1) => {
	var Am = U(), Nm = z(), Cr$1 = class extends Nm {
		constructor(e) {
			super(e), this.type = "comment", this.inline = Object(e).inline || !1;
		}
		toString() {
			return [
				this.raws.before,
				this.inline ? "//" : "/*",
				String(this.value),
				this.inline ? "" : "*/",
				this.raws.after
			].join("");
		}
	};
	Am.registerWalker(Cr$1);
	gu$1.exports = Cr$1;
});
var _u = y((Lx, bu) => {
	var xu = U(), Ar$1 = class extends xu {
		constructor(e) {
			super(e), this.type = "func", this.unbalanced = -1;
		}
	};
	xu.registerWalker(Ar$1);
	bu.exports = Ar$1;
});
var Eu = y((Dx, ku) => {
	var Pm = U(), Rm = z(), Nr = class extends Rm {
		constructor(e) {
			super(e), this.type = "number", this.unit = Object(e).unit || "";
		}
		toString() {
			return [
				this.raws.before,
				String(this.value),
				this.unit,
				this.raws.after
			].join("");
		}
	};
	Pm.registerWalker(Nr);
	ku.exports = Nr;
});
var Tu = y((Mx, Su) => {
	var Im = U(), qm = z(), Pr = class extends qm {
		constructor(e) {
			super(e), this.type = "operator";
		}
	};
	Im.registerWalker(Pr);
	Su.exports = Pr;
});
var Cu = y((Bx, Ou) => {
	var Lm = U(), Dm = z(), Rr = class extends Dm {
		constructor(e) {
			super(e), this.type = "paren", this.parenType = "";
		}
	};
	Lm.registerWalker(Rr);
	Ou.exports = Rr;
});
var Nu = y((Ux, Au) => {
	var Mm = U(), Bm = z(), Ir = class extends Bm {
		constructor(e) {
			super(e), this.type = "string";
		}
		toString() {
			let e = this.quoted ? this.raws.quote : "";
			return [
				this.raws.before,
				e,
				this.value + "",
				e,
				this.raws.after
			].join("");
		}
	};
	Mm.registerWalker(Ir);
	Au.exports = Ir;
});
var Ru = y((Fx, Pu) => {
	var Um = U(), Fm = z(), qr = class extends Fm {
		constructor(e) {
			super(e), this.type = "word";
		}
	};
	Um.registerWalker(qr);
	Pu.exports = qr;
});
var qu = y(($x, Iu) => {
	var $m = U(), Wm = z(), Lr = class extends Wm {
		constructor(e) {
			super(e), this.type = "unicode-range";
		}
	};
	$m.registerWalker(Lr);
	Iu.exports = Lr;
});
var Du = y((Wx, Lu) => {
	var Vs = class extends Error {
		constructor(e) {
			super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
		}
	};
	Lu.exports = Vs;
});
var Uu = y((Yx, Bu) => {
	var Dr$1 = /[ \n\t\r\{\(\)'"\\;,/]/g, Ym = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, De$1 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, zm = /^[a-z0-9]/i, Vm = /^[a-f0-9?\-]/i, Mu = Du();
	Bu.exports = function(e, s) {
		s = s || {};
		let r = [], n = e.valueOf(), i = n.length, o = -1, a = 1, u = 0, c = 0, f = null, p, l, w$1, x, h$1, d, b$1, g, v$1, R, F;
		function H$1(T$1) {
			throw new Mu(`Unclosed ${T$1} at line: ${a}, column: ${u - o}, token: ${u}`);
		}
		for (; u < i;) {
			switch (p = n.charCodeAt(u), p === 10 && (o = u, a += 1), p) {
				case 10:
				case 32:
				case 9:
				case 13:
				case 12:
					l = u;
					do
						l += 1, p = n.charCodeAt(l), p === 10 && (o = l, a += 1);
					while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
					r.push([
						"space",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					break;
				case 58:
					l = u + 1, r.push([
						"colon",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					break;
				case 44:
					l = u + 1, r.push([
						"comma",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					break;
				case 123:
					r.push([
						"{",
						"{",
						a,
						u - o,
						a,
						l - o,
						u
					]);
					break;
				case 125:
					r.push([
						"}",
						"}",
						a,
						u - o,
						a,
						l - o,
						u
					]);
					break;
				case 40:
					c++, f = !f && c === 1 && r.length > 0 && r[r.length - 1][0] === "word" && r[r.length - 1][1] === "url", r.push([
						"(",
						"(",
						a,
						u - o,
						a,
						l - o,
						u
					]);
					break;
				case 41:
					c--, f = f && c > 0, r.push([
						")",
						")",
						a,
						u - o,
						a,
						l - o,
						u
					]);
					break;
				case 39:
				case 34:
					w$1 = p === 39 ? "'" : "\"", l = u;
					do
						for (v$1 = !1, l = n.indexOf(w$1, l + 1), l === -1 && H$1("quote", w$1), R = l; n.charCodeAt(R - 1) === 92;) R -= 1, v$1 = !v$1;
					while (v$1);
					r.push([
						"string",
						n.slice(u, l + 1),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l;
					break;
				case 64:
					Dr$1.lastIndex = u + 1, Dr$1.test(n), Dr$1.lastIndex === 0 ? l = n.length - 1 : l = Dr$1.lastIndex - 2, r.push([
						"atword",
						n.slice(u, l + 1),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l;
					break;
				case 92:
					l = u, p = n.charCodeAt(l + 1), r.push([
						"word",
						n.slice(u, l + 1),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l;
					break;
				case 43:
				case 45:
				case 42:
					l = u + 1, F = n.slice(u + 1, l + 1);
					n.slice(u - 1, u);
					if (p === 45 && F.charCodeAt(0) === 45) {
						l++, r.push([
							"word",
							n.slice(u, l),
							a,
							u - o,
							a,
							l - o,
							u
						]), u = l - 1;
						break;
					}
					r.push([
						"operator",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					break;
				default:
					if (p === 47 && (n.charCodeAt(u + 1) === 42 || s.loose && !f && n.charCodeAt(u + 1) === 47)) {
						if (n.charCodeAt(u + 1) === 42) l = n.indexOf("*/", u + 2) + 1, l === 0 && H$1("comment", "*/");
						else {
							let C = n.indexOf(`
`, u + 2);
							l = C !== -1 ? C - 1 : i;
						}
						d = n.slice(u, l + 1), x = d.split(`
`), h$1 = x.length - 1, h$1 > 0 ? (b$1 = a + h$1, g = l - x[h$1].length) : (b$1 = a, g = o), r.push([
							"comment",
							d,
							a,
							u - o,
							b$1,
							l - g,
							u
						]), o = g, a = b$1, u = l;
					} else if (p === 35 && !zm.test(n.slice(u + 1, u + 2))) l = u + 1, r.push([
						"#",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					else if ((p === 117 || p === 85) && n.charCodeAt(u + 1) === 43) {
						l = u + 2;
						do
							l += 1, p = n.charCodeAt(l);
						while (l < i && Vm.test(n.slice(l, l + 1)));
						r.push([
							"unicoderange",
							n.slice(u, l),
							a,
							u - o,
							a,
							l - o,
							u
						]), u = l - 1;
					} else if (p === 47) l = u + 1, r.push([
						"operator",
						n.slice(u, l),
						a,
						u - o,
						a,
						l - o,
						u
					]), u = l - 1;
					else {
						let O = Ym;
						if (p >= 48 && p <= 57 && (O = De$1), O.lastIndex = u + 1, O.test(n), O.lastIndex === 0 ? l = n.length - 1 : l = O.lastIndex - 2, O === De$1 || p === 46) {
							let C = n.charCodeAt(l), me$1 = n.charCodeAt(l + 1), Js$1 = n.charCodeAt(l + 2);
							(C === 101 || C === 69) && (me$1 === 45 || me$1 === 43) && Js$1 >= 48 && Js$1 <= 57 && (De$1.lastIndex = l + 2, De$1.test(n), De$1.lastIndex === 0 ? l = n.length - 1 : l = De$1.lastIndex - 2);
						}
						r.push([
							"word",
							n.slice(u, l + 1),
							a,
							u - o,
							a,
							l - o,
							u
						]), u = l;
					}
					break;
			}
			u++;
		}
		return r;
	};
});
var $u = y((zx, Fu) => {
	var Gs$1 = class extends Error {
		constructor(e) {
			super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
		}
	};
	Fu.exports = Gs$1;
});
var Vu = y((Gx, zu) => {
	var Gm = uu(), jm = cu(), Hm = hu(), Km = mu(), Qm = wu(), Jm = vu(), Xm = _u(), Zm = Eu(), ey = Tu(), Wu = Cu(), ty = Nu(), Yu = Ru(), ry = qu(), sy = Uu(), ny = qs(), iy = Ls(), oy = Ds(), ay = $u();
	function uy(t) {
		return t.sort((e, s) => e - s);
	}
	zu.exports = class {
		constructor(e, s) {
			this.cache = [], this.input = e, this.options = Object.assign({}, { loose: !1 }, s), this.position = 0, this.unbalanced = 0, this.root = new Gm();
			let n = new jm();
			this.root.append(n), this.current = n, this.tokens = sy(e, this.options);
		}
		parse() {
			return this.loop();
		}
		colon() {
			let e = this.currToken;
			this.newNode(new Km({
				value: e[1],
				source: {
					start: {
						line: e[2],
						column: e[3]
					},
					end: {
						line: e[4],
						column: e[5]
					}
				},
				sourceIndex: e[6]
			})), this.position++;
		}
		comma() {
			let e = this.currToken;
			this.newNode(new Qm({
				value: e[1],
				source: {
					start: {
						line: e[2],
						column: e[3]
					},
					end: {
						line: e[4],
						column: e[5]
					}
				},
				sourceIndex: e[6]
			})), this.position++;
		}
		comment() {
			let e = !1, s = this.currToken[1].replace(/\/\*|\*\//g, ""), r;
			this.options.loose && s.startsWith("//") && (s = s.substring(2), e = !0), r = new Jm({
				value: s,
				inline: e,
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[4],
						column: this.currToken[5]
					}
				},
				sourceIndex: this.currToken[6]
			}), this.newNode(r), this.position++;
		}
		error(e, s) {
			throw new ay(e + ` at line: ${s[2]}, column ${s[3]}`);
		}
		loop() {
			for (; this.position < this.tokens.length;) this.parseTokens();
			return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
		}
		operator() {
			let e = this.currToken[1], s;
			if (e === "+" || e === "-") {
				if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
					if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word") return this.word();
				} else if (this.nextToken[0] === "word") return this.word();
			}
			return s = new ey({
				value: this.currToken[1],
				source: {
					start: {
						line: this.currToken[2],
						column: this.currToken[3]
					},
					end: {
						line: this.currToken[2],
						column: this.currToken[3]
					}
				},
				sourceIndex: this.currToken[4]
			}), this.position++, this.newNode(s);
		}
		parseTokens() {
			switch (this.currToken[0]) {
				case "space":
					this.space();
					break;
				case "colon":
					this.colon();
					break;
				case "comma":
					this.comma();
					break;
				case "comment":
					this.comment();
					break;
				case "(":
					this.parenOpen();
					break;
				case ")":
					this.parenClose();
					break;
				case "atword":
				case "word":
					this.word();
					break;
				case "operator":
					this.operator();
					break;
				case "string":
					this.string();
					break;
				case "unicoderange":
					this.unicodeRange();
					break;
				default:
					this.word();
					break;
			}
		}
		parenOpen() {
			let e = 1, s = this.position + 1, r = this.currToken, n;
			for (; s < this.tokens.length && e;) {
				let i = this.tokens[s];
				i[0] === "(" && e++, i[0] === ")" && e--, s++;
			}
			if (e && this.error("Expected closing parenthesis", r), n = this.current.last, n && n.type === "func" && n.unbalanced < 0 && (n.unbalanced = 0, this.current = n), this.current.unbalanced++, this.newNode(new Wu({
				value: r[1],
				source: {
					start: {
						line: r[2],
						column: r[3]
					},
					end: {
						line: r[4],
						column: r[5]
					}
				},
				sourceIndex: r[6]
			})), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
				let i = this.nextToken, o = this.currToken[1], a = {
					line: this.currToken[2],
					column: this.currToken[3]
				};
				for (; i && i[0] !== ")" && this.current.unbalanced;) this.position++, o += this.currToken[1], i = this.nextToken;
				this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new Yu({
					value: o,
					source: {
						start: a,
						end: {
							line: this.currToken[4],
							column: this.currToken[5]
						}
					},
					sourceIndex: this.currToken[6]
				})));
			}
		}
		parenClose() {
			let e = this.currToken;
			this.newNode(new Wu({
				value: e[1],
				source: {
					start: {
						line: e[2],
						column: e[3]
					},
					end: {
						line: e[4],
						column: e[5]
					}
				},
				sourceIndex: e[6]
			})), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
		}
		space() {
			let e = this.currToken;
			this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e[1], this.position++) : (this.spaces = e[1], this.position++);
		}
		unicodeRange() {
			let e = this.currToken;
			this.newNode(new ry({
				value: e[1],
				source: {
					start: {
						line: e[2],
						column: e[3]
					},
					end: {
						line: e[4],
						column: e[5]
					}
				},
				sourceIndex: e[6]
			})), this.position++;
		}
		splitWord() {
			let e = this.nextToken, s = this.currToken[1], r = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, n = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, i, o;
			if (!n.test(s)) for (; e && e[0] === "word";) {
				this.position++;
				let a = this.currToken[1];
				s += a, e = this.nextToken;
			}
			i = iy(s, "@"), o = uy(oy(ny([[0], i]))), o.forEach((a, u) => {
				let c = o[u + 1] || s.length, f = s.slice(a, c), p;
				if (~i.indexOf(a)) p = new Hm({
					value: f.slice(1),
					source: {
						start: {
							line: this.currToken[2],
							column: this.currToken[3] + a
						},
						end: {
							line: this.currToken[4],
							column: this.currToken[3] + (c - 1)
						}
					},
					sourceIndex: this.currToken[6] + o[u]
				});
				else if (r.test(this.currToken[1])) {
					let l = f.replace(r, "");
					p = new Zm({
						value: f.replace(l, ""),
						source: {
							start: {
								line: this.currToken[2],
								column: this.currToken[3] + a
							},
							end: {
								line: this.currToken[4],
								column: this.currToken[3] + (c - 1)
							}
						},
						sourceIndex: this.currToken[6] + o[u],
						unit: l
					});
				} else p = new (e && e[0] === "(" ? Xm : Yu)({
					value: f,
					source: {
						start: {
							line: this.currToken[2],
							column: this.currToken[3] + a
						},
						end: {
							line: this.currToken[4],
							column: this.currToken[3] + (c - 1)
						}
					},
					sourceIndex: this.currToken[6] + o[u]
				}), p.type === "word" ? (p.isHex = /^#(.+)/.test(f), p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(f)) : this.cache.push(this.current);
				this.newNode(p);
			}), this.position++;
		}
		string() {
			let e = this.currToken, s = this.currToken[1], r = /^(\"|\')/, n = r.test(s), i = "", o;
			n && (i = s.match(r)[0], s = s.slice(1, s.length - 1)), o = new ty({
				value: s,
				source: {
					start: {
						line: e[2],
						column: e[3]
					},
					end: {
						line: e[4],
						column: e[5]
					}
				},
				sourceIndex: e[6],
				quoted: n
			}), o.raws.quote = i, this.newNode(o), this.position++;
		}
		word() {
			return this.splitWord();
		}
		newNode(e) {
			return this.spaces && (e.raws.before += this.spaces, this.spaces = ""), this.current.append(e);
		}
		get currToken() {
			return this.tokens[this.position];
		}
		get nextToken() {
			return this.tokens[this.position + 1];
		}
		get prevToken() {
			return this.tokens[this.position - 1];
		}
	};
});
var Qs = {};
Xs(Qs, {
	languages: () => pi,
	options: () => di,
	parsers: () => Ks,
	printers: () => Ey
});
var hl = (t, e, s, r) => {
	if (!(t && e == null)) return e.replaceAll ? e.replaceAll(s, r) : s.global ? e.replace(s, r) : e.split(s).join(r);
}, _ = hl;
var Me = "string", Be = "array", Ue = "cursor", we = "indent", ge = "align", Fe = "trim", ve = "group", xe = "fill", oe = "if-break", $e = "indent-if-break", We = "line-suffix", Ye = "line-suffix-boundary", K = "line", ze = "label", be = "break-parent", bt = new Set([
	Ue,
	we,
	ge,
	Fe,
	ve,
	xe,
	oe,
	$e,
	We,
	Ye,
	K,
	ze,
	be
]);
function dl(t) {
	if (typeof t == "string") return Me;
	if (Array.isArray(t)) return Be;
	if (!t) return;
	let { type: e } = t;
	if (bt.has(e)) return e;
}
var Ve = dl;
var ml = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function yl(t) {
	let e = t === null ? "null" : typeof t;
	if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
	if (Ve(t)) throw new Error("doc is valid.");
	let s = Object.prototype.toString.call(t);
	if (s !== "[object Object]") return `Unexpected doc '${s}'.`;
	let r = ml([...bt].map((n) => `'${n}'`));
	return `Unexpected doc.type '${t.type}'.
Expected it to be ${r}.`;
}
var Fr = class extends Error {
	name = "InvalidDocError";
	constructor(e) {
		super(yl(e)), this.doc = e;
	}
}, $r = Fr;
var Zs = () => {}, ae = Zs, _t = Zs;
function q(t) {
	return ae(t), {
		type: we,
		contents: t
	};
}
function en(t, e) {
	return ae(e), {
		type: ge,
		contents: e,
		n: t
	};
}
function L(t, e = {}) {
	return ae(t), _t(e.expandedStates, !0), {
		type: ve,
		id: e.id,
		contents: t,
		break: !!e.shouldBreak,
		expandedStates: e.expandedStates
	};
}
function tn(t) {
	return en({ type: "root" }, t);
}
function ue(t) {
	return en(-1, t);
}
function Ge(t) {
	return _t(t), {
		type: xe,
		parts: t
	};
}
function kt(t, e = "", s = {}) {
	return ae(t), e !== "" && ae(e), {
		type: oe,
		breakContents: t,
		flatContents: e,
		groupId: s.groupId
	};
}
var je = { type: be };
var wl = {
	type: K,
	hard: !0
};
var A = { type: K }, M = {
	type: K,
	soft: !0
}, E = [wl, je];
function V(t, e) {
	ae(t), _t(e);
	let s = [];
	for (let r = 0; r < e.length; r++) r !== 0 && s.push(t), s.push(e[r]);
	return s;
}
var gl = (t, e, s) => {
	if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[s < 0 ? e.length + s : s] : e.at(s);
}, G = gl;
function vl(t, e) {
	if (typeof t == "string") return e(t);
	let s = /* @__PURE__ */ new Map();
	return r(t);
	function r(i) {
		if (s.has(i)) return s.get(i);
		let o = n(i);
		return s.set(i, o), o;
	}
	function n(i) {
		switch (Ve(i)) {
			case Be: return e(i.map(r));
			case xe: return e({
				...i,
				parts: i.parts.map(r)
			});
			case oe: return e({
				...i,
				breakContents: r(i.breakContents),
				flatContents: r(i.flatContents)
			});
			case ve: {
				let { expandedStates: o, contents: a } = i;
				return o ? (o = o.map(r), a = o[0]) : a = r(a), e({
					...i,
					contents: a,
					expandedStates: o
				});
			}
			case ge:
			case we:
			case $e:
			case ze:
			case We: return e({
				...i,
				contents: r(i.contents)
			});
			case Me:
			case Ue:
			case Fe:
			case Ye:
			case K:
			case be: return e(i);
			default: throw new $r(i);
		}
	}
}
function xl(t) {
	return t.type === K && !t.hard ? t.soft ? "" : " " : t.type === oe ? t.flatContents : t;
}
function rn(t) {
	return vl(t, xl);
}
function bl(t) {
	return Array.isArray(t) && t.length > 0;
}
var ee = bl;
var Et = "'", sn = "\"";
function _l(t, e) {
	let s = e === !0 || e === Et ? Et : sn, r = s === Et ? sn : Et, n = 0, i = 0;
	for (let o of t) o === s ? n++ : o === r && i++;
	return n > i ? r : s;
}
var nn = _l;
function kl(t, e, s) {
	let r = e === "\"" ? "'" : "\"";
	return e + _(!1, t, /\\(.)|(["'])/gsu, (o, a, u) => a === r ? a : u === e ? "\\" + u : u || (s && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a) ? a : "\\" + a)) + e;
}
var on$1 = kl;
function El(t, e) {
	let s = t.slice(1, -1);
	return on$1(s, e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? "\"" : e.__isInHtmlAttribute ? "'" : nn(s, e.singleQuote), !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var St = El;
var Wr = class extends Error {
	name = "UnexpectedNodeError";
	constructor(e, s, r = "type") {
		super(`Unexpected ${s} node ${r}: ${JSON.stringify(e[r])}.`), this.node = e;
	}
}, an = Wr;
function Sl(t) {
	return (t == null ? void 0 : t.type) === "front-matter";
}
var _e = Sl;
var Tl = new Set([
	"raw",
	"raws",
	"sourceIndex",
	"source",
	"before",
	"after",
	"trailingComma",
	"spaces"
]);
function un(t, e, s) {
	if (_e(t) && t.language === "yaml" && delete e.value, t.type === "css-comment" && s.type === "css-root" && s.nodes.length > 0 && ((s.nodes[0] === t || _e(s.nodes[0]) && s.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/u.test(t.text)) || s.type === "css-root" && G(!1, s.nodes, -1) === t)) return null;
	if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && t.value && (e.value = Ol(t.value)), t.type === "selector-combinator" && (e.value = _(!1, e.value, /\s+/gu, " ")), t.type === "media-feature" && (e.value = _(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || [
		"initial",
		"inherit",
		"unset",
		"revert"
	].includes(t.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = t.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = t.name.toLowerCase()), t.type === "value-number" && (e.unit = t.unit.toLowerCase()), t.type === "value-unknown" && (e.value = _(!1, e.value, /;$/gu, "")), t.type === "selector-attribute" && (e.attribute = t.attribute.trim(), t.namespace && typeof t.namespace == "string" && (e.namespace = t.namespace.trim() || !0), t.value && (e.value = _(!1, e.value.trim(), /^["']|["']$/gu, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && t.value && (e.value = _(!1, e.value, /([\d+.e-]+)([a-z]*)/giu, (r, n, i) => {
		let o = Number(n);
		return Number.isNaN(o) ? r : o + i.toLowerCase();
	})), t.type === "selector-tag") {
		let r = e.value.toLowerCase();
		["from", "to"].includes(r) && (e.value = r);
	}
	if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
		let r = t.groups.findIndex((n) => n.type === "value-number" && n.unit === "...");
		r !== -1 && (e.groups[r].unit = "", e.groups.splice(r + 1, 0, {
			type: "value-word",
			value: "...",
			isColor: !1,
			isHex: !1
		}));
	}
	if (t.type === "value-comma_group" && t.groups.some((r) => r.type === "value-atword" && r.value.endsWith("[") || r.type === "value-word" && r.value.startsWith("]"))) return {
		type: "value-atword",
		value: t.groups.map((r) => r.value).join(""),
		group: {
			open: null,
			close: null,
			groups: [],
			type: "value-paren_group"
		}
	};
}
un.ignoredProperties = Tl;
function Ol(t) {
	return _(!1, _(!1, t, "'", "\""), /\\([^\da-f])/giu, "$1");
}
var ln = un;
async function Cl(t, e) {
	if (t.language === "yaml") {
		let s = t.value.trim(), r = s ? await e(s, { parser: "yaml" }) : "";
		return tn([
			t.startDelimiter,
			t.explicitLanguage,
			E,
			r,
			r ? E : "",
			t.endDelimiter
		]);
	}
}
var cn = Cl;
function fn(t) {
	let { node: e } = t;
	if (e.type === "front-matter") return async (s) => {
		let r = await cn(e, s);
		return r ? [r, E] : void 0;
	};
}
fn.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var pn = fn;
var He = null;
function Ke(t) {
	if (He !== null && typeof He.property) {
		let e = He;
		return He = Ke.prototype = null, e;
	}
	return He = Ke.prototype = t ?? Object.create(null), new Ke();
}
var Al = 10;
for (let t = 0; t <= Al; t++) Ke();
function Yr(t) {
	return Ke(t);
}
function Nl(t, e = "type") {
	Yr(t);
	function s(r) {
		let n = r[e], i = t[n];
		if (!Array.isArray(i)) throw Object.assign(/* @__PURE__ */ new Error(`Missing visitor keys for '${n}'.`), { node: r });
		return i;
	}
	return s;
}
var mn = Nl({
	"front-matter": [],
	"css-root": ["frontMatter", "nodes"],
	"css-comment": [],
	"css-rule": ["selector", "nodes"],
	"css-decl": [
		"value",
		"selector",
		"nodes"
	],
	"css-atrule": [
		"selector",
		"params",
		"value",
		"nodes"
	],
	"media-query-list": ["nodes"],
	"media-query": ["nodes"],
	"media-type": [],
	"media-feature-expression": ["nodes"],
	"media-feature": [],
	"media-colon": [],
	"media-value": [],
	"media-keyword": [],
	"media-url": [],
	"media-unknown": [],
	"selector-root": ["nodes"],
	"selector-selector": ["nodes"],
	"selector-comment": [],
	"selector-string": [],
	"selector-tag": [],
	"selector-id": [],
	"selector-class": [],
	"selector-attribute": [],
	"selector-combinator": ["nodes"],
	"selector-universal": [],
	"selector-pseudo": ["nodes"],
	"selector-nesting": [],
	"selector-unknown": [],
	"value-value": ["group"],
	"value-root": ["group"],
	"value-comment": [],
	"value-comma_group": ["groups"],
	"value-paren_group": [
		"open",
		"groups",
		"close"
	],
	"value-func": ["group"],
	"value-paren": [],
	"value-number": [],
	"value-operator": [],
	"value-word": [],
	"value-colon": [],
	"value-comma": [],
	"value-string": [],
	"value-atword": [],
	"value-unicode-range": [],
	"value-unknown": []
});
function Il(t, e) {
	let s = 0;
	for (let r = 0; r < t.line - 1; ++r) s = e.indexOf(`
`, s) + 1;
	return s + t.column;
}
var zr = Il;
function Tt(t) {
	return (e, s, r) => {
		let n = !!(r != null && r.backwards);
		if (s === !1) return !1;
		let { length: i } = e, o = s;
		for (; o >= 0 && o < i;) {
			let a = e.charAt(o);
			if (t instanceof RegExp) {
				if (!t.test(a)) return o;
			} else if (!t.includes(a)) return o;
			n ? o-- : o++;
		}
		return o === -1 || o === i ? o : !1;
	};
}
Tt(/\s/u);
var Ot = Tt(" 	"), yn = Tt(",; 	"), Ct = Tt(/[^\n\r]/u);
function wn(t, e) {
	var s, r, n;
	if (typeof ((r = (s = t.source) == null ? void 0 : s.start) == null ? void 0 : r.offset) == "number") return t.source.start.offset;
	if (typeof t.sourceIndex == "number") return t.sourceIndex;
	if ((n = t.source) != null && n.start) return zr(t.source.start, e);
	throw Object.assign(/* @__PURE__ */ new Error("Can not locate node."), { node: t });
}
function Vr(t, e) {
	var s, r;
	if (t.type === "css-comment" && t.inline) return Ct(e, t.source.startOffset);
	if (typeof ((r = (s = t.source) == null ? void 0 : s.end) == null ? void 0 : r.offset) == "number") return t.source.end.offset;
	if (t.source) {
		if (t.source.end) return zr(t.source.end, e);
		if (ee(t.nodes)) return Vr(G(!1, t.nodes, -1), e);
	}
	return null;
}
function Gr(t, e) {
	t.source && (t.source.startOffset = wn(t, e), t.source.endOffset = Vr(t, e));
	for (let s in t) {
		let r = t[s];
		s === "source" || !r || typeof r != "object" || (r.type === "value-root" || r.type === "value-unknown" ? gn(r, ql(t), r.text || r.value) : Gr(r, e));
	}
}
function gn(t, e, s) {
	t.source && (t.source.startOffset = wn(t, s) + e, t.source.endOffset = Vr(t, s) + e);
	for (let r in t) {
		let n = t[r];
		r === "source" || !n || typeof n != "object" || gn(n, e, s);
	}
}
function ql(t) {
	var s;
	let e = t.source.startOffset;
	return typeof t.prop == "string" && (e += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (e += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/u)[0].length), t.type !== "css-atrule" && typeof ((s = t.raws) == null ? void 0 : s.between) == "string" && (e += t.raws.between.length), e;
}
function vn(t) {
	let e = "initial", s = "initial", r, n = !1, i = [];
	for (let o = 0; o < t.length; o++) {
		let a = t[o];
		switch (e) {
			case "initial":
				if (a === "'") {
					e = "single-quotes";
					continue;
				}
				if (a === "\"") {
					e = "double-quotes";
					continue;
				}
				if ((a === "u" || a === "U") && t.slice(o, o + 4).toLowerCase() === "url(") {
					e = "url", o += 3;
					continue;
				}
				if (a === "*" && t[o - 1] === "/") {
					e = "comment-block";
					continue;
				}
				if (a === "/" && t[o - 1] === "/") {
					e = "comment-inline", r = o - 1;
					continue;
				}
				continue;
			case "single-quotes":
				if (a === "'" && t[o - 1] !== "\\" && (e = s, s = "initial"), a === `
` || a === "\r") return t;
				continue;
			case "double-quotes":
				if (a === "\"" && t[o - 1] !== "\\" && (e = s, s = "initial"), a === `
` || a === "\r") return t;
				continue;
			case "url":
				if (a === ")" && (e = "initial"), a === `
` || a === "\r") return t;
				if (a === "'") {
					e = "single-quotes", s = "url";
					continue;
				}
				if (a === "\"") {
					e = "double-quotes", s = "url";
					continue;
				}
				continue;
			case "comment-block":
				a === "/" && t[o - 1] === "*" && (e = "initial");
				continue;
			case "comment-inline":
				(a === "\"" || a === "'" || a === "*") && (n = !0), (a === `
` || a === "\r") && (n && i.push([r, o]), e = "initial", n = !1);
				continue;
		}
	}
	for (let [o, a] of i) t = t.slice(0, o) + _(!1, t.slice(o, a), /["'*]/gu, " ") + t.slice(a);
	return t;
}
function N(t) {
	var e;
	return (e = t.source) == null ? void 0 : e.startOffset;
}
function P(t) {
	var e;
	return (e = t.source) == null ? void 0 : e.endOffset;
}
var Ll = /\*\/$/, Dl = /^\/\*\*?/, kn = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Ml = /(^|\s+)\/\/([^\n\r]*)/g, xn = /^(\r?\n)+/, Bl = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, bn = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ul = /(\r?\n|^) *\* ?/g, En = [];
function Sn(t) {
	let e = t.match(kn);
	return e ? e[0].trimStart() : "";
}
function Tn(t) {
	let e = t.match(kn), s = e == null ? void 0 : e[0];
	return s == null ? t : t.slice(s.length);
}
function On(t) {
	let e = `
`;
	t = _(!1, t.replace(Dl, "").replace(Ll, ""), Ul, "$1");
	let s = "";
	for (; s !== t;) s = t, t = _(!1, t, Bl, `${e}$1 $2${e}`);
	t = t.replace(xn, "").trimEnd();
	let r = Object.create(null), n = _(!1, t, bn, "").replace(xn, "").trimEnd(), i;
	for (; i = bn.exec(t);) {
		let o = _(!1, i[2], Ml, "");
		if (typeof r[i[1]] == "string" || Array.isArray(r[i[1]])) {
			let a = r[i[1]];
			r[i[1]] = [
				...En,
				...Array.isArray(a) ? a : [a],
				o
			];
		} else r[i[1]] = o;
	}
	return {
		comments: n,
		pragmas: r
	};
}
function Cn({ comments: t = "", pragmas: e = {} }) {
	let s = `
`, r = "/**", n = " *", i = " */", o = Object.keys(e), a = o.flatMap((c) => _n(c, e[c])).map((c) => `${n} ${c}${s}`).join("");
	if (!t) {
		if (o.length === 0) return "";
		if (o.length === 1 && !Array.isArray(e[o[0]])) {
			let c = e[o[0]];
			return `${r} ${_n(o[0], c)[0]}${i}`;
		}
	}
	let u = t.split(s).map((c) => `${n} ${c}`).join(s) + s;
	return r + s + (t ? u : "") + (t && o.length > 0 ? n + s : "") + a + i;
}
function _n(t, e) {
	return [...En, ...Array.isArray(e) ? e : [e]].map((s) => `@${t} ${s}`.trim());
}
function Fl(t) {
	if (!t.startsWith("#!")) return "";
	let e = t.indexOf(`
`);
	return e === -1 ? t : t.slice(0, e);
}
var An = Fl;
function Nn(t) {
	let e = An(t);
	e && (t = t.slice(e.length + 1));
	let { pragmas: r, comments: n } = On(Sn(t));
	return {
		shebang: e,
		text: t,
		pragmas: r,
		comments: n
	};
}
function Pn(t) {
	let { pragmas: e } = Nn(t);
	return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function Rn(t) {
	let { shebang: e, text: s, pragmas: r, comments: n } = Nn(t), i = Tn(s), o = Cn({
		pragmas: {
			format: "",
			...r
		},
		comments: n.trimStart()
	});
	return (e ? `${e}
` : "") + o + (i.startsWith(`
`) ? `
` : `

`) + i;
}
var Qe = 3;
function $l(t) {
	let e = t.slice(0, Qe);
	if (e !== "---" && e !== "+++") return;
	let s = t.indexOf(`
`, Qe);
	if (s === -1) return;
	let r = t.slice(Qe, s).trim(), n = t.indexOf(`
${e}`, s), i = r;
	if (i || (i = e === "+++" ? "toml" : "yaml"), n === -1 && e === "---" && i === "yaml" && (n = t.indexOf(`
...`, s)), n === -1) return;
	let o = n + 1 + Qe, a = t.charAt(o + 1);
	if (!/\s?/u.test(a)) return;
	let u = t.slice(0, o);
	return {
		type: "front-matter",
		language: i,
		explicitLanguage: r,
		value: t.slice(s + 1, n),
		startDelimiter: e,
		endDelimiter: u.slice(-Qe),
		raw: u
	};
}
function Wl(t) {
	let e = $l(t);
	if (!e) return { content: t };
	let { raw: s } = e;
	return {
		frontMatter: e,
		content: _(!1, s, /[^\n]/gu, " ") + t.slice(s.length)
	};
}
var Je = Wl;
function In(t) {
	return Pn(Je(t).content);
}
function qn(t) {
	let { frontMatter: e, content: s } = Je(t);
	return (e ? e.raw + `

` : "") + Rn(s);
}
var Yl = new Set([
	"red",
	"green",
	"blue",
	"alpha",
	"a",
	"rgb",
	"hue",
	"h",
	"saturation",
	"s",
	"lightness",
	"l",
	"whiteness",
	"w",
	"blackness",
	"b",
	"tint",
	"shade",
	"blend",
	"blenda",
	"contrast",
	"hsl",
	"hsla",
	"hwb",
	"hwba"
]);
function Ln$1(t) {
	var e, s;
	return (s = (e = t.findAncestor((r) => r.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : s.toLowerCase();
}
var zl = new Set([
	"initial",
	"inherit",
	"unset",
	"revert"
]);
function Dn(t) {
	return zl.has(t.toLowerCase());
}
function Mn(t, e) {
	var r;
	let s = t.findAncestor((n) => n.type === "css-atrule");
	return ((r = s == null ? void 0 : s.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function te(t) {
	return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function ke(t, e) {
	var r;
	let s = t.findAncestor((n) => n.type === "value-func");
	return ((r = s == null ? void 0 : s.value) == null ? void 0 : r.toLowerCase()) === e;
}
function Bn(t) {
	var r;
	let e = t.findAncestor((n) => n.type === "css-rule"), s = (r = e == null ? void 0 : e.raws) == null ? void 0 : r.selector;
	return s && (s.startsWith(":import") || s.startsWith(":export"));
}
function Ee(t, e) {
	let s = Array.isArray(e) ? e : [e], r = t.findAncestor((n) => n.type === "css-atrule");
	return r && s.includes(r.name.toLowerCase());
}
function Un(t) {
	var s;
	let { node: e } = t;
	return e.groups[0].value === "url" && e.groups.length === 2 && ((s = t.findAncestor((r) => r.type === "css-atrule")) == null ? void 0 : s.name) === "import";
}
function Fn(t) {
	return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function $n(t) {
	return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function Wn(t) {
	let { selector: e } = t;
	return e ? typeof e == "string" && /^@.+:.*$/u.test(e) || e.value && /^@.+:.*$/u.test(e.value) : !1;
}
function Yn(t) {
	return t.type === "value-word" && [
		"from",
		"through",
		"end"
	].includes(t.value);
}
function zn(t) {
	return t.type === "value-word" && [
		"and",
		"or",
		"not"
	].includes(t.value);
}
function Vn(t) {
	return t.type === "value-word" && t.value === "in";
}
function At(t) {
	return t.type === "value-operator" && t.value === "*";
}
function Xe(t) {
	return t.type === "value-operator" && t.value === "/";
}
function Q(t) {
	return t.type === "value-operator" && t.value === "+";
}
function le(t) {
	return t.type === "value-operator" && t.value === "-";
}
function Vl(t) {
	return t.type === "value-operator" && t.value === "%";
}
function Nt(t) {
	return At(t) || Xe(t) || Q(t) || le(t) || Vl(t);
}
function Gn(t) {
	return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function jn(t) {
	return t.type === "value-word" && [
		"<",
		">",
		"<=",
		">="
	].includes(t.value);
}
function Ze(t, e) {
	return e.parser === "scss" && t.type === "css-atrule" && [
		"if",
		"else",
		"for",
		"each",
		"while"
	].includes(t.name);
}
function Hr(t) {
	var e;
	return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/u.test(t.raws.params);
}
function Pt(t) {
	return t.name.startsWith("prettier-placeholder");
}
function Hn(t) {
	return t.prop.startsWith("@prettier-placeholder");
}
function Kn(t, e) {
	return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function Qn(t) {
	var e, s;
	return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((s = t.value.group) == null ? void 0 : s.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function Jn(t) {
	var e, s, r;
	return ((r = (s = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : s.group) == null ? void 0 : r.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function ce(t) {
	var e;
	return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function Rt(t) {
	var e, s;
	return t.type === "value-comma_group" && ((s = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : s.type) === "value-colon";
}
function jr(t) {
	var e;
	return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && Rt(t.groups[0]);
}
function Kr(t, e) {
	var i;
	if (e.parser !== "scss") return !1;
	let { node: s } = t;
	if (s.groups.length === 0) return !1;
	let r = t.grandparent;
	if (!jr(s) && !(r && jr(r))) return !1;
	let n = t.findAncestor((o) => o.type === "css-decl");
	return !!((i = n == null ? void 0 : n.prop) != null && i.startsWith("$") || jr(r) || r.type === "value-func");
}
function Qr(t) {
	return t.type === "value-comment" && t.inline;
}
function It(t) {
	return t.type === "value-word" && t.value === "#";
}
function Jr(t) {
	return t.type === "value-word" && t.value === "{";
}
function qt(t) {
	return t.type === "value-word" && t.value === "}";
}
function et(t) {
	return ["value-word", "value-atword"].includes(t.type);
}
function Lt(t) {
	return (t == null ? void 0 : t.type) === "value-colon";
}
function Xn(t, e) {
	if (!Rt(e)) return !1;
	let { groups: s } = e, r = s.indexOf(t);
	return r === -1 ? !1 : Lt(s[r + 1]);
}
function Zn(t) {
	return t.value && [
		"not",
		"and",
		"or"
	].includes(t.value.toLowerCase());
}
function ei(t) {
	return t.type !== "value-func" ? !1 : Yl.has(t.value.toLowerCase());
}
function Se(t) {
	return /\/\//u.test(t.split(/[\n\r]/u).pop());
}
function tt(t) {
	return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function ti(t, e) {
	var s, r;
	if (((s = t.open) == null ? void 0 : s.value) !== "(" || ((r = t.close) == null ? void 0 : r.value) !== ")" || t.groups.some((n) => n.type !== "value-comma_group")) return !1;
	if (e.type === "value-comma_group") {
		let n = e.groups.indexOf(t) - 1, i = e.groups[n];
		if ((i == null ? void 0 : i.type) === "value-word" && i.value === "with") return !0;
	}
	return !1;
}
function rt(t) {
	var e, s;
	return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((s = t.close) == null ? void 0 : s.value) === ")";
}
function Gl(t, e, s) {
	var d;
	let { node: r } = t, n = t.parent, i = t.grandparent, o = Ln$1(t), a = o && n.type === "value-value" && (o === "grid" || o.startsWith("grid-template")), u = t.findAncestor((m$1) => m$1.type === "css-atrule"), c = u && Ze(u, e), f = r.groups.some((m$1) => Qr(m$1)), p = t.map(s, "groups"), l = [], w$1 = ke(t, "url"), x = !1, h$1 = !1;
	for (let m$1 = 0; m$1 < r.groups.length; ++m$1) {
		l.push(p[m$1]);
		let b$1 = r.groups[m$1 - 1], g = r.groups[m$1], v$1 = r.groups[m$1 + 1], R = r.groups[m$1 + 2];
		if (w$1) {
			(v$1 && Q(v$1) || Q(g)) && l.push(" ");
			continue;
		}
		if (Ee(t, "forward") && g.type === "value-word" && g.value && b$1 !== void 0 && b$1.type === "value-word" && b$1.value === "as" && v$1.type === "value-operator" && v$1.value === "*" || !v$1 || g.type === "value-word" && g.value.endsWith("-") && tt(v$1)) continue;
		if (g.type === "value-string" && g.quoted) {
			let C = g.value.lastIndexOf("#{"), me$1 = g.value.lastIndexOf("}");
			C !== -1 && me$1 !== -1 ? x = C > me$1 : C !== -1 ? x = !0 : me$1 !== -1 && (x = !1);
		}
		if (x || Lt(g) || Lt(v$1) || g.type === "value-atword" && (g.value === "" || g.value.endsWith("[")) || v$1.type === "value-word" && v$1.value.startsWith("]") || g.value === "~" || g.type !== "value-string" && g.value && g.value.includes("\\") && v$1 && v$1.type !== "value-comment" || b$1 != null && b$1.value && b$1.value.indexOf("\\") === b$1.value.length - 1 && g.type === "value-operator" && g.value === "/" || g.value === "\\" || Kn(g, v$1) || It(g) || Jr(g) || qt(v$1) || Jr(v$1) && ce(v$1) || qt(g) && ce(v$1) || g.value === "--" && It(v$1)) continue;
		let F = Nt(g), H$1 = Nt(v$1);
		if ((F && It(v$1) || H$1 && qt(g)) && ce(v$1) || !b$1 && Xe(g) || ke(t, "calc") && (Q(g) || Q(v$1) || le(g) || le(v$1)) && ce(v$1)) continue;
		let $$1 = (Q(g) || le(g)) && m$1 === 0 && (v$1.type === "value-number" || v$1.isHex) && i && ei(i) && !ce(v$1), T$1 = (R == null ? void 0 : R.type) === "value-func" || R && et(R) || g.type === "value-func" || et(g), O = v$1.type === "value-func" || et(v$1) || (b$1 == null ? void 0 : b$1.type) === "value-func" || b$1 && et(b$1);
		if (e.parser === "scss" && F && g.value === "-" && v$1.type === "value-func" && P(g) !== N(v$1)) {
			l.push(" ");
			continue;
		}
		if (!(!(At(v$1) || At(g)) && !ke(t, "calc") && !$$1 && (Xe(v$1) && !T$1 || Xe(g) && !O || Q(v$1) && !T$1 || Q(g) && !O || le(v$1) || le(g)) && (ce(v$1) || F && (!b$1 || b$1 && Nt(b$1)))) && !((e.parser === "scss" || e.parser === "less") && F && g.value === "-" && rt(v$1) && P(g) === N(v$1.open) && v$1.open.value === "(")) {
			if (Qr(g)) {
				if (n.type === "value-paren_group") {
					l.push(ue(E));
					continue;
				}
				l.push(E);
				continue;
			}
			if (c && (Gn(v$1) || jn(v$1) || zn(v$1) || Vn(g) || Yn(g))) {
				l.push(" ");
				continue;
			}
			if (u && u.name.toLowerCase() === "namespace") {
				l.push(" ");
				continue;
			}
			if (a) {
				g.source && v$1.source && g.source.start.line !== v$1.source.start.line ? (l.push(E), h$1 = !0) : l.push(" ");
				continue;
			}
			if (H$1) {
				l.push(" ");
				continue;
			}
			if ((v$1 == null ? void 0 : v$1.value) !== "..." && !(tt(g) && tt(v$1) && P(g) === N(v$1))) {
				if (tt(g) && rt(v$1) && P(g) === N(v$1.open)) {
					l.push(M);
					continue;
				}
				if (g.value === "with" && rt(v$1)) {
					l.push(" ");
					continue;
				}
				(d = g.value) != null && d.endsWith("#") && v$1.value === "{" && rt(v$1.group) || l.push(A);
			}
		}
	}
	return f && l.push(je), h$1 && l.unshift(E), c ? L(q(l)) : Un(t) ? L(Ge(l)) : L(q(Ge(l)));
}
var ri = Gl;
function jl(t) {
	return t.length === 1 ? t : t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
}
var si = jl;
var Xr = new Map([
	["em", "em"],
	["rem", "rem"],
	["ex", "ex"],
	["rex", "rex"],
	["cap", "cap"],
	["rcap", "rcap"],
	["ch", "ch"],
	["rch", "rch"],
	["ic", "ic"],
	["ric", "ric"],
	["lh", "lh"],
	["rlh", "rlh"],
	["vw", "vw"],
	["svw", "svw"],
	["lvw", "lvw"],
	["dvw", "dvw"],
	["vh", "vh"],
	["svh", "svh"],
	["lvh", "lvh"],
	["dvh", "dvh"],
	["vi", "vi"],
	["svi", "svi"],
	["lvi", "lvi"],
	["dvi", "dvi"],
	["vb", "vb"],
	["svb", "svb"],
	["lvb", "lvb"],
	["dvb", "dvb"],
	["vmin", "vmin"],
	["svmin", "svmin"],
	["lvmin", "lvmin"],
	["dvmin", "dvmin"],
	["vmax", "vmax"],
	["svmax", "svmax"],
	["lvmax", "lvmax"],
	["dvmax", "dvmax"],
	["cm", "cm"],
	["mm", "mm"],
	["q", "Q"],
	["in", "in"],
	["pt", "pt"],
	["pc", "pc"],
	["px", "px"],
	["deg", "deg"],
	["grad", "grad"],
	["rad", "rad"],
	["turn", "turn"],
	["s", "s"],
	["ms", "ms"],
	["hz", "Hz"],
	["khz", "kHz"],
	["dpi", "dpi"],
	["dpcm", "dpcm"],
	["dppx", "dppx"],
	["x", "x"],
	["cqw", "cqw"],
	["cqh", "cqh"],
	["cqi", "cqi"],
	["cqb", "cqb"],
	["cqmin", "cqmin"],
	["cqmax", "cqmax"]
]);
function ni(t) {
	let e = t.toLowerCase();
	return Xr.has(e) ? Xr.get(e) : t;
}
var ii = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu, Jl = new RegExp(ii.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu.source})(${/[a-z]+/giu.source})?`, "giu");
function W(t, e) {
	return _(!1, t, ii, (s) => St(s, e));
}
function oi(t, e) {
	let s = e.singleQuote ? "'" : "\"";
	return t.includes("\"") || t.includes("'") ? t : s + t + s;
}
function fe(t) {
	return _(!1, t, Jl, (e, s, r, n, i) => !r && n ? Zr(n) + te(i || "") : e);
}
function Zr(t) {
	return si(t).replace(/\.0(?=$|e)/u, "");
}
function ai(t) {
	return t.trailingComma === "es5" || t.trailingComma === "all";
}
function Xl(t, e, s) {
	let r = !!(s != null && s.backwards);
	if (e === !1) return !1;
	let n = t.charAt(e);
	if (r) {
		if (t.charAt(e - 1) === "\r" && n === `
`) return e - 2;
		if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e - 1;
	} else {
		if (n === "\r" && t.charAt(e + 1) === `
`) return e + 2;
		if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e + 1;
	}
	return e;
}
var Dt = Xl;
function Zl(t, e, s = {}) {
	let r = Ot(t, s.backwards ? e - 1 : e, s);
	return r !== Dt(t, r, s);
}
var Mt = Zl;
function ec(t, e) {
	if (e === !1) return !1;
	if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
		for (let s = e + 2; s < t.length; ++s) if (t.charAt(s) === "*" && t.charAt(s + 1) === "/") return s + 2;
	}
	return e;
}
var ui = ec;
function tc(t, e) {
	return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Ct(t, e) : e;
}
var li = tc;
function rc(t, e) {
	let s = null, r = e;
	for (; r !== s;) s = r, r = yn(t, r), r = ui(t, r), r = Ot(t, r);
	return r = li(t, r), r = Dt(t, r), r !== !1 && Mt(t, r);
}
var Bt = rc;
function sc({ node: t, parent: e }, s) {
	return !!(t.source && s.originalText.slice(N(t), N(e.close)).trimEnd().endsWith(","));
}
function nc(t, e) {
	return $n(t.grandparent) && sc(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((s) => s.type === "value-comment")) && ai(e) && t.callParent(() => Kr(t, e)) ? kt(",") : "";
}
function ci(t, e, s) {
	let { node: r, parent: n } = t, i = t.map(({ node: w$1 }) => typeof w$1 == "string" ? w$1 : s(), "groups");
	if (n && Fn(n) && (r.groups.length === 1 || r.groups.length > 0 && r.groups[0].type === "value-comma_group" && r.groups[0].groups.length > 0 && r.groups[0].groups[0].type === "value-word" && r.groups[0].groups[0].value.startsWith("data:"))) return [
		r.open ? s("open") : "",
		V(",", i),
		r.close ? s("close") : ""
	];
	if (!r.open) {
		let w$1 = es(t), x = V([",", w$1 ? E : A], i);
		return q(w$1 ? [E, x] : L(Ge(x)));
	}
	let o = t.map(({ node: w$1, isLast: x, index: h$1 }) => {
		var b$1;
		let d = i[h$1];
		if (Rt(w$1) && w$1.type === "value-comma_group" && w$1.groups && w$1.groups[0].type !== "value-paren_group" && ((b$1 = w$1.groups[2]) == null ? void 0 : b$1.type) === "value-paren_group") {
			let { parts: g } = d.contents.contents;
			g[1] = L(g[1]), d = L(ue(d));
		}
		let m$1 = [d, x ? nc(t, e) : ","];
		if (!x && w$1.type === "value-comma_group" && ee(w$1.groups)) {
			let g = G(!1, w$1.groups, -1);
			!g.source && g.close && (g = g.close), g.source && Bt(e.originalText, P(g)) && m$1.push(E);
		}
		return m$1;
	}, "groups"), a = Xn(r, n), u = ti(r, n), c = Kr(t, e), f = u || c && !a, p = u || a, l = L([
		r.open ? s("open") : "",
		q([M, V(A, o)]),
		M,
		r.close ? s("close") : ""
	], { shouldBreak: f });
	return p ? ue(l) : l;
}
function es(t) {
	return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((s) => s.type === "value-comma_group"), (e, s) => s === "group" && e.type === "value-value", (e, s) => s === "group" && e.type === "value-root", (e, s) => s === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function ic(t, e, s) {
	let r = [];
	return t.each(() => {
		let { node: n, previous: i } = t;
		if ((i == null ? void 0 : i.type) === "css-comment" && i.text.trim() === "prettier-ignore" ? r.push(e.originalText.slice(N(n), P(n))) : r.push(s()), t.isLast) return;
		let { next: o } = t;
		o.type === "css-comment" && !Mt(e.originalText, N(o), { backwards: !0 }) && !_e(n) || o.type === "css-atrule" && o.name === "else" && n.type !== "css-comment" ? r.push(" ") : (r.push(e.__isHTMLStyleAttribute ? A : E), Bt(e.originalText, P(n)) && !_e(n) && r.push(E));
	}, "nodes"), r;
}
var Te = ic;
function oc(t, e, s) {
	var n, i, o, a, u, c;
	let { node: r } = t;
	switch (r.type) {
		case "front-matter": return [r.raw, E];
		case "css-root": {
			let f = Te(t, e, s), p = r.raws.after.trim();
			return p.startsWith(";") && (p = p.slice(1).trim()), [
				r.frontMatter ? [s("frontMatter"), E] : "",
				f,
				p ? ` ${p}` : "",
				r.nodes.length > 0 ? E : ""
			];
		}
		case "css-comment": {
			let f = r.inline || r.raws.inline, p = e.originalText.slice(N(r), P(r));
			return f ? p.trimEnd() : p;
		}
		case "css-rule": return [
			s("selector"),
			r.important ? " !important" : "",
			r.nodes ? [
				((n = r.selector) == null ? void 0 : n.type) === "selector-unknown" && Se(r.selector.value) ? A : r.selector ? " " : "",
				"{",
				r.nodes.length > 0 ? q([E, Te(t, e, s)]) : "",
				E,
				"}",
				Wn(r) ? ";" : ""
			] : ";"
		];
		case "css-decl": {
			let f = t.parent, { between: p } = r.raws, l = p.trim(), w$1 = l === ":", x = typeof r.value == "string" && /^ *$/u.test(r.value), h$1 = typeof r.value == "string" ? r.value : s("value");
			return h$1 = Qn(r) ? rn(h$1) : h$1, !w$1 && Se(l) && !((o = (i = r.value) == null ? void 0 : i.group) != null && o.group && t.call(() => es(t), "value", "group", "group")) && (h$1 = q([E, ue(h$1)])), [
				_(!1, r.raws.before, /[\s;]/gu, ""),
				f.type === "css-atrule" && f.variable || Bn(t) ? r.prop : te(r.prop),
				l.startsWith("//") ? " " : "",
				l,
				r.extend || x ? "" : " ",
				e.parser === "less" && r.extend && r.selector ? [
					"extend(",
					s("selector"),
					")"
				] : "",
				h$1,
				r.raws.important ? r.raws.important.replace(/\s*!\s*important/iu, " !important") : r.important ? " !important" : "",
				r.raws.scssDefault ? r.raws.scssDefault.replace(/\s*!default/iu, " !default") : r.scssDefault ? " !default" : "",
				r.raws.scssGlobal ? r.raws.scssGlobal.replace(/\s*!global/iu, " !global") : r.scssGlobal ? " !global" : "",
				r.nodes ? [
					" {",
					q([M, Te(t, e, s)]),
					M,
					"}"
				] : Hn(r) && !f.raws.semicolon && e.originalText[P(r) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && t.isLast ? kt(";") : ";"
			];
		}
		case "css-atrule": {
			let f = t.parent, p = Pt(r) && !f.raws.semicolon && e.originalText[P(r) - 1] !== ";";
			if (e.parser === "less") {
				if (r.mixin) return [
					s("selector"),
					r.important ? " !important" : "",
					p ? "" : ";"
				];
				if (r.function) return [
					r.name,
					typeof r.params == "string" ? r.params : s("params"),
					p ? "" : ";"
				];
				if (r.variable) return [
					"@",
					r.name,
					": ",
					r.value ? s("value") : "",
					r.raws.between.trim() ? r.raws.between.trim() + " " : "",
					r.nodes ? [
						"{",
						q([r.nodes.length > 0 ? M : "", Te(t, e, s)]),
						M,
						"}"
					] : "",
					p ? "" : ";"
				];
			}
			let l = r.name === "import" && ((a = r.params) == null ? void 0 : a.type) === "value-unknown" && r.params.value.endsWith(";");
			return [
				"@",
				Hr(r) || r.name.endsWith(":") || Pt(r) ? r.name : te(r.name),
				r.params ? [Hr(r) ? "" : Pt(r) ? r.raws.afterName === "" ? "" : r.name.endsWith(":") ? " " : /^\s*\n\s*\n/u.test(r.raws.afterName) ? [E, E] : /^\s*\n/u.test(r.raws.afterName) ? E : " " : " ", typeof r.params == "string" ? r.params : s("params")] : "",
				r.selector ? q([" ", s("selector")]) : "",
				r.value ? L([
					" ",
					s("value"),
					Ze(r, e) ? Jn(r) ? " " : A : ""
				]) : r.name === "else" ? " " : "",
				r.nodes ? [
					Ze(r, e) ? "" : r.selector && !r.selector.nodes && typeof r.selector.value == "string" && Se(r.selector.value) || !r.selector && typeof r.params == "string" && Se(r.params) ? A : " ",
					"{",
					q([r.nodes.length > 0 ? M : "", Te(t, e, s)]),
					M,
					"}"
				] : p || l ? "" : ";"
			];
		}
		case "media-query-list": {
			let f = [];
			return t.each(({ node: p }) => {
				p.type === "media-query" && p.value === "" || f.push(s());
			}, "nodes"), L(q(V(A, f)));
		}
		case "media-query": return [V(" ", t.map(s, "nodes")), t.isLast ? "" : ","];
		case "media-type": return fe(W(r.value, e));
		case "media-feature-expression": return r.nodes ? [
			"(",
			...t.map(s, "nodes"),
			")"
		] : r.value;
		case "media-feature": return te(W(_(!1, r.value, / +/gu, " "), e));
		case "media-colon": return [r.value, " "];
		case "media-value": return fe(W(r.value, e));
		case "media-keyword": return W(r.value, e);
		case "media-url": return W(_(!1, _(!1, r.value, /^url\(\s+/giu, "url("), /\s+\)$/gu, ")"), e);
		case "media-unknown": return r.value;
		case "selector-root": return L([Ee(t, "custom-selector") ? [t.findAncestor((f) => f.type === "css-atrule").customSelector, A] : "", V([",", Ee(t, [
			"extend",
			"custom-selector",
			"nest"
		]) ? A : E], t.map(s, "nodes"))]);
		case "selector-selector": return L(q(t.map(s, "nodes")));
		case "selector-comment": return r.value;
		case "selector-string": return W(r.value, e);
		case "selector-tag": return [r.namespace ? [r.namespace === !0 ? "" : r.namespace.trim(), "|"] : "", ((u = t.previous) == null ? void 0 : u.type) === "selector-nesting" ? r.value : fe(Mn(t, r.value) ? r.value.toLowerCase() : r.value)];
		case "selector-id": return ["#", r.value];
		case "selector-class": return [".", fe(W(r.value, e))];
		case "selector-attribute": return [
			"[",
			r.namespace ? [r.namespace === !0 ? "" : r.namespace.trim(), "|"] : "",
			r.attribute.trim(),
			r.operator ?? "",
			r.value ? oi(W(r.value.trim(), e), e) : "",
			r.insensitive ? " i" : "",
			"]"
		];
		case "selector-combinator":
			if (r.value === "+" || r.value === ">" || r.value === "~" || r.value === ">>>") {
				let l = t.parent;
				return [
					l.type === "selector-selector" && l.nodes[0] === r ? "" : A,
					r.value,
					t.isLast ? "" : " "
				];
			}
			return [r.value.trim().startsWith("(") ? A : "", fe(W(r.value.trim(), e)) || A];
		case "selector-universal": return [r.namespace ? [r.namespace === !0 ? "" : r.namespace.trim(), "|"] : "", r.value];
		case "selector-pseudo": return [te(r.value), ee(r.nodes) ? L([
			"(",
			q([M, V([",", A], t.map(s, "nodes"))]),
			M,
			")"
		]) : ""];
		case "selector-nesting": return r.value;
		case "selector-unknown": {
			let f = t.findAncestor((w$1) => w$1.type === "css-rule");
			if (f != null && f.isSCSSNesterProperty) return fe(W(te(r.value), e));
			let p = t.parent;
			if ((c = p.raws) != null && c.selector) {
				let w$1 = N(p), x = w$1 + p.raws.selector.length;
				return e.originalText.slice(w$1, x).trim();
			}
			let l = t.grandparent;
			if (p.type === "value-paren_group" && (l == null ? void 0 : l.type) === "value-func" && l.value === "selector") {
				let w$1 = P(p.open) + 1, x = N(p.close), h$1 = e.originalText.slice(w$1, x).trim();
				return Se(h$1) ? [je, h$1] : h$1;
			}
			return r.value;
		}
		case "value-value":
		case "value-root": return s("group");
		case "value-comment": return e.originalText.slice(N(r), P(r));
		case "value-comma_group": return ri(t, e, s);
		case "value-paren_group": return ci(t, e, s);
		case "value-func": return [
			r.value,
			Ee(t, "supports") && Zn(r) ? " " : "",
			s("group")
		];
		case "value-paren": return r.value;
		case "value-number": return [Zr(r.value), ni(r.unit)];
		case "value-operator": return r.value;
		case "value-word": return r.isColor && r.isHex || Dn(r.value) ? r.value.toLowerCase() : r.value;
		case "value-colon": {
			let { previous: f } = t;
			return [r.value, typeof (f == null ? void 0 : f.value) == "string" && f.value.endsWith("\\") || ke(t, "url") ? "" : A];
		}
		case "value-string": return St(r.raws.quote + r.value + r.raws.quote, e);
		case "value-atword": return ["@", r.value];
		case "value-unicode-range": return r.value;
		case "value-unknown": return r.value;
		case "value-comma":
		default: throw new an(r, "PostCSS");
	}
}
var fi = {
	print: oc,
	embed: pn,
	insertPragma: qn,
	massageAstNode: ln,
	getVisitorKeys: mn
};
var pi = [
	{
		linguistLanguageId: 50,
		name: "CSS",
		type: "markup",
		tmScope: "source.css",
		aceMode: "css",
		codemirrorMode: "css",
		codemirrorMimeType: "text/css",
		color: "#563d7c",
		extensions: [".css", ".wxss"],
		parsers: ["css"],
		vscodeLanguageIds: ["css"]
	},
	{
		linguistLanguageId: 262764437,
		name: "PostCSS",
		type: "markup",
		color: "#dc3a0c",
		tmScope: "source.postcss",
		group: "CSS",
		extensions: [".pcss", ".postcss"],
		aceMode: "text",
		parsers: ["css"],
		vscodeLanguageIds: ["postcss"]
	},
	{
		linguistLanguageId: 198,
		name: "Less",
		type: "markup",
		color: "#1d365d",
		aliases: ["less-css"],
		extensions: [".less"],
		tmScope: "source.css.less",
		aceMode: "less",
		codemirrorMode: "css",
		codemirrorMimeType: "text/css",
		parsers: ["less"],
		vscodeLanguageIds: ["less"]
	},
	{
		linguistLanguageId: 329,
		name: "SCSS",
		type: "markup",
		color: "#c6538c",
		tmScope: "source.css.scss",
		aceMode: "scss",
		codemirrorMode: "css",
		codemirrorMimeType: "text/x-scss",
		extensions: [".scss"],
		parsers: ["scss"],
		vscodeLanguageIds: ["scss"]
	}
];
var di = { singleQuote: {
	bracketSpacing: {
		category: "Common",
		type: "boolean",
		default: !0,
		description: "Print spaces between brackets.",
		oppositeDescription: "Do not print spaces between brackets."
	},
	singleQuote: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Use single quotes instead of double quotes."
	},
	proseWrap: {
		category: "Common",
		type: "choice",
		default: "preserve",
		description: "How to wrap prose.",
		choices: [
			{
				value: "always",
				description: "Wrap prose if it exceeds the print width."
			},
			{
				value: "never",
				description: "Do not wrap prose."
			},
			{
				value: "preserve",
				description: "Wrap prose as-is."
			}
		]
	},
	bracketSameLine: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Put > of opening tags on the last line instead of on a new line."
	},
	singleAttributePerLine: {
		category: "Common",
		type: "boolean",
		default: !1,
		description: "Enforce single attribute per line in HTML, Vue and JSX."
	}
}.singleQuote };
var Ks = {};
Xs(Ks, {
	css: () => by,
	less: () => _y,
	scss: () => ky
});
var el = ye(pt(), 1), tl = ye(bo(), 1), rl = ye(ta(), 1);
function Hf(t, e) {
	let s = /* @__PURE__ */ new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
	return Object.assign(s, e);
}
var ra = Hf;
var la = ye(ua(), 1);
function J(t, e, s) {
	if (t && typeof t == "object") {
		delete t.parent;
		for (let r in t) J(t[r], e, s), r === "type" && typeof t[r] == "string" && !t[r].startsWith(e) && (!s || !s.test(t[r])) && (t[r] = e + t[r]);
	}
	return t;
}
function Is(t) {
	if (t && typeof t == "object") {
		delete t.parent;
		for (let e in t) Is(t[e]);
		!Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
	}
	return t;
}
var op = la.default.default;
function ap(t) {
	let e;
	try {
		e = op(t);
	} catch {
		return {
			type: "selector-unknown",
			value: t
		};
	}
	return J(Is(e), "media-");
}
var ca = ap;
var nu = ye(su(), 1);
function bm(t) {
	if (/\/\/|\/\*/u.test(t)) return {
		type: "selector-unknown",
		value: t.trim()
	};
	let e;
	try {
		new nu.default((s) => {
			e = s;
		}).process(t);
	} catch {
		return {
			type: "selector-unknown",
			value: t
		};
	}
	return J(e, "selector-");
}
var Z = bm;
var Qu = ye(Vu(), 1);
var ly = (t) => {
	for (; t.parent;) t = t.parent;
	return t;
}, Mr = ly;
function cy(t) {
	return Mr(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var Gu = cy;
function fy(t) {
	if (ee(t)) {
		for (let e = t.length - 1; e > 0; e--) if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#")) return !0;
	}
	return !1;
}
var ju = fy;
function py(t) {
	return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var Hu = py;
function hy(t, e) {
	return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var Ku = hy;
function dy(t, e) {
	var u;
	let { nodes: s } = t, r = {
		open: null,
		close: null,
		groups: [],
		type: "paren_group"
	}, n = [r], i = r, o = {
		groups: [],
		type: "comma_group"
	}, a = [o];
	for (let c = 0; c < s.length; ++c) {
		let f = s[c];
		if (e.parser === "scss" && f.type === "number" && f.unit === ".." && f.value.endsWith(".") && (f.value = f.value.slice(0, -1), f.unit = "..."), f.type === "func" && f.value === "selector" && (f.group.groups = [Z(Mr(t).text.slice(f.group.open.sourceIndex + 1, f.group.close.sourceIndex))]), f.type === "func" && f.value === "url") {
			let p = ((u = f.group) == null ? void 0 : u.groups) ?? [], l = [];
			for (let w$1 = 0; w$1 < p.length; w$1++) {
				let x = p[w$1];
				x.type === "comma_group" ? l = [...l, ...x.groups] : l.push(x);
			}
			(ju(l) || !Hu(l) && !Ku(l[0], e)) && (f.group.groups = [Gu(f)]);
		}
		if (f.type === "paren" && f.value === "(") r = {
			open: f,
			close: null,
			groups: [],
			type: "paren_group"
		}, n.push(r), o = {
			groups: [],
			type: "comma_group"
		}, a.push(o);
		else if (f.type === "paren" && f.value === ")") {
			if (o.groups.length > 0 && r.groups.push(o), r.close = f, a.length === 1) throw new Error("Unbalanced parenthesis");
			a.pop(), o = G(!1, a, -1), o.groups.push(r), n.pop(), r = G(!1, n, -1);
		} else f.type === "comma" ? (r.groups.push(o), o = {
			groups: [],
			type: "comma_group"
		}, a[a.length - 1] = o) : o.groups.push(f);
	}
	return o.groups.length > 0 && r.groups.push(o), i;
}
function Br(t) {
	return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? Br(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? {
		...t,
		groups: t.groups.map(Br)
	} : t;
}
function Ju(t, e) {
	if (t && typeof t == "object") for (let s in t) s !== "parent" && (Ju(t[s], e), s === "nodes" && (t.group = Br(dy(t, e)), delete t[s]));
	return t;
}
function my(t, e) {
	if (e.parser === "less" && t.startsWith("~`")) return {
		type: "value-unknown",
		value: t
	};
	let s = null;
	try {
		s = new Qu.default(t, { loose: !0 }).parse();
	} catch {
		return {
			type: "value-unknown",
			value: t
		};
	}
	s.text = t;
	return J(Ju(s, e), "value-", /^selector-/u);
}
var ie = my;
var yy = new Set([
	"import",
	"use",
	"forward"
]);
function wy(t) {
	return yy.has(t);
}
var Xu = wy;
function gy(t, e) {
	return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//u, "").replace(/\/\/.*\n/u, "").trim().endsWith(":");
}
var Zu = gy;
var vy = /(\s*)(!default).*$/u, xy = /(\s*)(!global).*$/u;
function sl(t, e) {
	var s, r;
	if (t && typeof t == "object") {
		delete t.parent;
		for (let a in t) sl(t[a], e);
		if (!t.type) return t;
		if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
			let a;
			if (t.value.trimEnd().endsWith("}")) {
				let u = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), f = _(!1, u, /[^\n]/gu, " ") + c, p;
				e.parser === "scss" ? p = ol : e.parser === "less" ? p = il : p = nl;
				let l;
				try {
					l = p(f, { ...e });
				} catch {}
				((s = l == null ? void 0 : l.nodes) == null ? void 0 : s.length) === 1 && l.nodes[0].type === "css-rule" && (a = l.nodes[0].nodes);
			}
			return a ? t.value = {
				type: "css-rule",
				nodes: a
			} : t.value = {
				type: "value-unknown",
				value: t.raws.value.raw
			}, t;
		}
		let n = "";
		typeof t.selector == "string" && (n = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (n += t.raws.between), t.raws.selector = n);
		let i = "";
		typeof t.value == "string" && (i = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, i = i.trim(), t.raws.value = i);
		let o = "";
		if (typeof t.params == "string" && (o = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (o = t.raws.afterName + o), t.raws.between && t.raws.between.trim().length > 0 && (o = o + t.raws.between), o = o.trim(), t.raws.params = o), n.trim().length > 0) return n.startsWith("@") && n.endsWith(":") ? t : t.mixin ? (t.selector = ie(n, e), t) : (Zu(t, e) && (t.isSCSSNesterProperty = !0), t.selector = Z(n), t);
		if (i.length > 0) {
			let a = i.match(vy);
			a && (i = i.slice(0, a.index), t.scssDefault = !0, a[0].trim() !== "!default" && (t.raws.scssDefault = a[0]));
			let u = i.match(xy);
			if (u && (i = i.slice(0, u.index), t.scssGlobal = !0, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), i.startsWith("progid:")) return {
				type: "value-unknown",
				value: i
			};
			t.value = ie(i, e);
		}
		if (e.parser === "less" && t.type === "css-decl" && i.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = Z(i.slice(7, -1)))), t.type === "css-atrule") {
			if (e.parser === "less") {
				if (t.mixin) return t.selector = Z(t.raws.identifier + t.name + t.raws.afterName + t.raws.params), delete t.params, t;
				if (t.function) return t;
			}
			if (e.parser === "css" && t.name === "custom-selector") {
				let a = t.params.match(/:--\S+\s+/u)[0].trim();
				return t.customSelector = a, t.selector = Z(t.params.slice(a.length).trim()), delete t.params, t;
			}
			if (e.parser === "less") {
				if (t.name.includes(":") && !t.params) {
					t.variable = !0;
					let a = t.name.split(":");
					t.name = a[0], t.value = ie(a.slice(1).join(":"), e);
				}
				if (![
					"page",
					"nest",
					"keyframes"
				].includes(t.name) && ((r = t.params) == null ? void 0 : r[0]) === ":") {
					t.variable = !0;
					let a = t.params.slice(1);
					a && (t.value = ie(a, e)), t.raws.afterName += ":";
				}
				if (t.variable) return delete t.params, t.value || delete t.value, t;
			}
		}
		if (t.type === "css-atrule" && o.length > 0) {
			let { name: a } = t, u = t.name.toLowerCase();
			return a === "warn" || a === "error" ? (t.params = {
				type: "media-unknown",
				value: o
			}, t) : a === "extend" || a === "nest" ? (t.selector = Z(o), delete t.params, t) : a === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(o) ? t.params = ie(o, e) : (t.selector = Z(o), delete t.params), t) : Xu(u) ? (t.import = !0, delete t.filename, t.params = ie(o, e), t) : [
				"namespace",
				"supports",
				"if",
				"else",
				"for",
				"each",
				"while",
				"debug",
				"mixin",
				"include",
				"function",
				"return",
				"define-mixin",
				"add-mixin"
			].includes(a) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/u, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/u, "$1($2"), t.value = ie(o, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? o.includes("#{") ? {
				type: "media-unknown",
				value: o
			} : (t.params = ca(o), t) : (t.params = o, t);
		}
	}
	return t;
}
function js(t, e, s) {
	let r = Je(e), { frontMatter: n } = r;
	e = r.content;
	let i;
	try {
		i = t(e, { map: !1 });
	} catch (o) {
		let { name: a, reason: u, line: c, column: f } = o;
		throw typeof c != "number" ? o : ra(`${a}: ${u}`, {
			loc: { start: {
				line: c,
				column: f
			} },
			cause: o
		});
	}
	return s.originalText = e, i = sl(J(i, "css-"), s), Gr(i, e), n && (n.source = {
		startOffset: 0,
		endOffset: n.raw.length
	}, i.frontMatter = n), i;
}
function nl(t, e = {}) {
	return js(el.default.default, t, e);
}
function il(t, e = {}) {
	return js((s) => tl.default.parse(vn(s)), t, e);
}
function ol(t, e = {}) {
	return js(rl.default, t, e);
}
var Hs = {
	astFormat: "postcss",
	hasPragma: In,
	locStart: N,
	locEnd: P
}, by = {
	...Hs,
	parse: nl
}, _y = {
	...Hs,
	parse: il
}, ky = {
	...Hs,
	parse: ol
};
var Ey = { postcss: fi };
var Ob = Qs;
var cssClasses = {
	validResolvable: "cm-valid-resolvable",
	invalidResolvable: "cm-invalid-resolvable",
	pendingResolvable: "cm-pending-resolvable",
	plaintext: "cm-plaintext"
};
var resolvablesTheme = EditorView.theme({
	["." + cssClasses.validResolvable]: {
		color: "var(--expression-editor--resolvable--color--foreground--valid)",
		backgroundColor: "var(--expression-editor--resolvable--color--background--valid)"
	},
	["." + cssClasses.invalidResolvable]: {
		color: "var(--expression-editor--resolvable--color--foreground--invalid)",
		backgroundColor: "var(--expression-editor--resolvable--color--background--invalid)"
	},
	["." + cssClasses.pendingResolvable]: {
		color: "var(--expression-editor--resolvable--color--foreground--pending)",
		backgroundColor: "var(--expression-editor--resolvable--color--background--pending)"
	}
});
var resolvableStateToDecoration = {
	valid: Decoration.mark({ class: cssClasses.validResolvable }),
	invalid: Decoration.mark({ class: cssClasses.invalidResolvable }),
	pending: Decoration.mark({ class: cssClasses.pendingResolvable })
};
var coloringStateEffects = {
	addColorEffect: StateEffect.define({ map: ({ from, to, kind, state }, change) => ({
		from: change.mapPos(from),
		to: change.mapPos(to),
		kind,
		state
	}) }),
	removeColorEffect: StateEffect.define({ map: ({ from, to }, change) => ({
		from: change.mapPos(from),
		to: change.mapPos(to)
	}) })
};
var coloringStateField = StateField.define({
	provide: (stateField) => EditorView.decorations.from(stateField),
	create() {
		return Decoration.none;
	},
	update(colorings, transaction) {
		try {
			colorings = colorings.map(transaction.changes);
			for (const txEffect of transaction.effects) {
				if (txEffect.is(coloringStateEffects.removeColorEffect)) colorings = colorings.update({ filter: (from, to) => txEffect.value.from !== from && txEffect.value.to !== to });
				if (txEffect.is(coloringStateEffects.addColorEffect)) {
					colorings = colorings.update({ filter: (from, to) => txEffect.value.from !== from && txEffect.value.to !== to });
					const decoration = resolvableStateToDecoration[txEffect.value.state ?? "pending"];
					if (txEffect.value.from === 0 && txEffect.value.to === 0) continue;
					colorings = colorings.update({ add: [decoration.range(txEffect.value.from, txEffect.value.to)] });
				}
			}
		} catch (error) {
			captureException(error);
		}
		return colorings;
	}
});
function addColor(view, segments) {
	const effects = segments.map(({ from, to, kind, state }) => coloringStateEffects.addColorEffect.of({
		from,
		to,
		kind,
		state
	}));
	if (effects.length === 0) return;
	if (!view.state.field(coloringStateField, false)) effects.push(StateEffect.appendConfig.of([coloringStateField, resolvablesTheme]));
	view.dispatch({ effects });
}
function removeColor(view, segments) {
	const effects = segments.map(({ from, to }) => coloringStateEffects.removeColorEffect.of({
		from,
		to
	}));
	if (effects.length === 0) return;
	if (!view.state.field(coloringStateField, false)) effects.push(StateEffect.appendConfig.of([coloringStateField, resolvablesTheme]));
	view.dispatch({ effects });
}
const highlighter = {
	addColor,
	removeColor,
	resolvableStyle: syntaxHighlighting(HighlightStyle.define([{
		tag: tags.content,
		class: cssClasses.plaintext
	}]))
};
var findNearestParentOfType = (type) => (node$1) => {
	if (node$1.name === type) return node$1;
	if (node$1.parent) return findNearestParentOfType(type)(node$1.parent);
	return null;
};
var findNearestArgList = findNearestParentOfType("ArgList");
var findNearestCallExpression = findNearestParentOfType("CallExpression");
function completionToTooltip(completion, pos, options$1 = {}) {
	if (!completion) return null;
	return {
		pos,
		end: options$1.end,
		above: true,
		create: () => {
			const element = document.createElement("div");
			element.classList.add("cm-cursorInfo");
			const info = completion.info;
			if (typeof info === "string") element.textContent = info;
			else if (isInfoBoxRenderer(info)) {
				const infoResult = info(completion, options$1.argIndex ?? -1);
				if (infoResult) element.appendChild(infoResult);
			}
			return { dom: element };
		}
	};
}
function findActiveArgIndex(node$1, index$1) {
	let currentIndex = 1;
	let argIndex = 0;
	let child = null;
	do {
		child = node$1.childAfter(currentIndex);
		if (child) {
			currentIndex = child.to;
			if (index$1 >= child.from && index$1 <= child.to) return argIndex;
			if (child.name !== "," && child.name !== "(") argIndex++;
		}
	} while (child);
	return -1;
}
var createStateReader = (state) => (node$1) => {
	return node$1 ? state.sliceDoc(node$1.from, node$1.to) : "";
};
var createStringReader = (str) => (node$1) => {
	return node$1 ? str.slice(node$1.from, node$1.to) : "";
};
function getJsNodeAtPosition(state, pos, anchor) {
	const rootNode = syntaxTree(state).resolveInner(pos, -1);
	if (rootNode.name !== "Resolvable") return null;
	const resolvable = createStateReader(state)(rootNode);
	const jsCode = resolvable.replace(/^{{\s*(.*)\s*}}$/, "$1");
	const prefixLength = resolvable.indexOf(jsCode);
	const jsOffset = rootNode.from + prefixLength;
	const jsPos = pos - jsOffset;
	const jsAnchor = anchor ? anchor - jsOffset : jsPos;
	const getGlobalPosition = (jsPosition) => jsPosition + jsOffset;
	const isSelectionWithinNode = (n) => {
		return jsPos >= n.from && jsPos <= n.to && jsAnchor >= n.from && jsAnchor <= n.to;
	};
	if (jsPos >= jsCode.length || jsAnchor >= jsCode.length) return null;
	return {
		node: javascriptLanguage.parser.parse(jsCode).resolveInner(jsPos, typeof anchor === "number" ? 0 : -1),
		pos: jsPos,
		readNode: createStringReader(jsCode),
		isSelectionWithinNode,
		getGlobalPosition
	};
}
function getCompletion(state, pos, filter$1) {
	const context = new CompletionContext(state, pos, true);
	const sources = state.languageDataAt("autocomplete", pos);
	for (const source of sources) {
		const options$1 = source(context)?.options.filter(filter$1);
		if (options$1 && options$1.length > 0) return options$1[0];
	}
	return null;
}
var isInfoBoxRenderer = (info) => {
	return typeof info === "function";
};
function getInfoBoxTooltip(state) {
	const { head, anchor } = state.selection.ranges[0];
	const jsNodeResult = getJsNodeAtPosition(state, head, anchor);
	if (!jsNodeResult) return null;
	const { node: node$1, pos, isSelectionWithinNode, getGlobalPosition, readNode } = jsNodeResult;
	const argList = findNearestArgList(node$1);
	if (!argList || !isSelectionWithinNode(argList)) return null;
	const callExpression = findNearestCallExpression(argList);
	if (!callExpression) return null;
	const argIndex = findActiveArgIndex(argList, pos);
	const subject = callExpression?.firstChild;
	switch (subject?.name) {
		case "MemberExpression": {
			const methodName = readNode(subject.lastChild);
			return completionToTooltip(getCompletion(state, getGlobalPosition(subject.to - 1), (c) => c.label === methodName + "()"), head, { argIndex });
		}
		case "VariableName": {
			const methodName = readNode(subject);
			return completionToTooltip(getCompletion(state, getGlobalPosition(subject.to - 1), (c) => c.label === methodName + "()"), head, { argIndex });
		}
		default: return null;
	}
}
var cursorInfoBoxTooltip = StateField.define({
	create(state) {
		return { tooltip: getInfoBoxTooltip(state) };
	},
	update(value$1, tr$1) {
		if (tr$1.state.selection.ranges.length !== 1 || tr$1.state.selection.ranges[0].head === 0 || completionStatus(tr$1.state) === "active") return { tooltip: null };
		if (tr$1.effects.find((effect) => effect.is(closeInfoBoxEffect))) return { tooltip: null };
		if (!tr$1.docChanged && !tr$1.selection) return { tooltip: value$1.tooltip };
		return {
			...value$1,
			tooltip: getInfoBoxTooltip(tr$1.state)
		};
	},
	provide: (f) => showTooltip.compute([f], (state) => state.field(f).tooltip)
});
const hoverTooltipSource = (view, pos) => {
	const cursorTooltipOpen = !!view.state.field(cursorInfoBoxTooltip, false)?.tooltip;
	if (completionStatus(view.state) === "active") return null;
	const jsNodeResult = getJsNodeAtPosition(view.state, pos);
	if (!jsNodeResult) return null;
	const { node: node$1, getGlobalPosition, readNode } = jsNodeResult;
	const tooltipForNode = (subject) => {
		const newHoverTooltip = completionToTooltip(getCompletion(view.state, getGlobalPosition(subject.to - 1), (c) => c.label === readNode(subject) || c.label === readNode(subject) + "()"), getGlobalPosition(subject.from), { end: getGlobalPosition(subject.to) });
		if (newHoverTooltip && cursorTooltipOpen) closeCursorInfoBox(view);
		return newHoverTooltip;
	};
	switch (node$1.name) {
		case "VariableName":
		case "PropertyName": return tooltipForNode(node$1);
		case "String":
		case "Number":
		case "Boolean":
		case "CallExpression": {
			const callExpression = findNearestCallExpression(node$1);
			if (!callExpression) return null;
			return tooltipForNode(callExpression);
		}
		default: return null;
	}
};
var hoverInfoBoxTooltip = hoverTooltip(hoverTooltipSource, {
	hideOnChange: true,
	hoverTime: 500
});
var closeInfoBoxEffect = StateEffect.define();
const closeCursorInfoBox = (view) => {
	if (!view.state.field(cursorInfoBoxTooltip, false)?.tooltip) return false;
	view.dispatch({ effects: closeInfoBoxEffect.of(null) });
	return true;
};
const infoBoxTooltips = () => {
	return [
		tooltips({ parent: document.getElementById("cm-tooltip-container") ?? void 0 }),
		cursorInfoBoxTooltip,
		hoverInfoBoxTooltip,
		keymap.of([{
			key: "Escape",
			run: closeCursorInfoBox
		}])
	];
};
var import_debounce$3 = /* @__PURE__ */ __toESM(require_debounce());
const useAutocompleteTelemetry = ({ editor: editorRef, parameterPath, compartment }) => {
	const ndvStore = useNDVStore();
	const rootStore = useRootStore();
	const telemetry = useTelemetry();
	const expressionExtensionsCategories = computed(() => {
		return EXTENSION_OBJECTS.reduce((acc, cur) => {
			for (const fnName of Object.keys(cur.functions)) acc[fnName] = cur.typeName;
			return acc;
		}, {});
	});
	function findCompletionBaseStartIndex(fromIndex) {
		const editor$5 = toValue(editorRef);
		if (!editor$5) return -1;
		const INDICATORS = [" $", "{ "];
		const doc = editor$5.state.doc.toString();
		for (let index$1 = fromIndex; index$1 > 0; index$1--) if (INDICATORS.some((indicator) => indicator === doc[index$1] + doc[index$1 + 1])) return index$1 + 1;
		return -1;
	}
	function trackCompletion(viewUpdate, path) {
		const editor$5 = toValue(editorRef);
		if (!editor$5) return;
		if (!viewUpdate.transactions.find((tx) => tx.isUserEvent("input.complete"))) return;
		ndvStore.setAutocompleteOnboarded();
		let completion = "";
		let completionBase = "";
		viewUpdate.changes.iterChanges((_$2, __, fromB, toB) => {
			completion = toValue(editor$5).state.doc.slice(fromB, toB).toString();
			const index$1 = findCompletionBaseStartIndex(fromB);
			completionBase = toValue(editor$5).state.doc.slice(index$1, fromB - 1).toString().trim();
		});
		const category = expressionExtensionsCategories.value[completion];
		const payload = {
			instance_id: rootStore.instanceId,
			node_type: ndvStore.activeNode?.type,
			field_name: path,
			field_type: "expression",
			context: completionBase,
			inserted_text: completion,
			category: category ?? "n/a"
		};
		telemetry.track("User autocompleted code", payload);
	}
	const safeTrackCompletion = (viewUpdate, path) => {
		try {
			trackCompletion(viewUpdate, path);
		} catch {}
	};
	const debouncedTrackCompletion = (0, import_debounce$3.default)(safeTrackCompletion, 100);
	watchEffect(() => {
		const editor$5 = toValue(editorRef);
		if (!editor$5) return;
		editor$5.dispatch({ effects: toValue(compartment).reconfigure([EditorView.updateListener.of((viewUpdate) => {
			if (!viewUpdate.docChanged || !editor$5) return;
			debouncedTrackCompletion(viewUpdate, toValue(parameterPath));
		})]) });
	});
};
const ignoreUpdateAnnotation = Annotation.define();
function forceParse(view) {
	view.dispatch({
		changes: {
			from: view.viewport.to,
			insert: "_"
		},
		annotations: [ignoreUpdateAnnotation.of(true)]
	});
	view.dispatch({
		changes: {
			from: view.viewport.to - 1,
			to: view.viewport.to,
			insert: ""
		},
		annotations: [ignoreUpdateAnnotation.of(true)]
	});
}
var import_debounce$2 = /* @__PURE__ */ __toESM(require_debounce());
var import_isEqual$3 = /* @__PURE__ */ __toESM(require_isEqual());
const useExpressionEditor = ({ editorRef, editorValue, targetNodeParameterContext, extensions = [], additionalData = {}, skipSegments = [], autocompleteTelemetry, isReadOnly = false, disableSearchDialog = false, onChange = () => {} }) => {
	const ndvStore = useNDVStore();
	const workflowsStore = useWorkflowsStore();
	const workflowHelpers = useWorkflowHelpers();
	const { isMacOs } = useDeviceSupport();
	const i18n$1 = useI18n();
	const editor$5 = ref();
	const hasFocus = ref(false);
	const segments = ref([]);
	const selection = ref(EditorSelection.cursor(0));
	const customExtensions = ref(new Compartment());
	const readOnlyExtensions = ref(new Compartment());
	const telemetryExtensions = ref(new Compartment());
	const autocompleteStatus = ref(null);
	const dragging$2 = ref(false);
	const hasChanges = ref(false);
	const expressionLocalResolveContext = inject(ExpressionLocalResolveContextSymbol, computed(() => void 0));
	const emitChanges = (0, import_debounce$2.default)(onChange, 300);
	const updateSegments = () => {
		const state = editor$5.value?.state;
		if (!state) return;
		const rawSegments = [];
		const fullTree = ensureSyntaxTree(state, state.doc.length, EXPRESSION_EDITOR_PARSER_TIMEOUT);
		if (fullTree === null) return;
		const skip = [
			"Program",
			"Script",
			"Document",
			...toValue(skipSegments)
		];
		fullTree.cursor().iterate((node$1) => {
			const text$1 = state.sliceDoc(node$1.from, node$1.to);
			if (skip.includes(node$1.type.name)) return;
			const newSegment = {
				from: node$1.from,
				to: node$1.to,
				text: text$1,
				token: node$1.type.name === "Resolvable" ? "Resolvable" : "Plaintext"
			};
			if ((0, import_isEqual$3.default)(newSegment, rawSegments.at(-1))) return;
			rawSegments.push(newSegment);
		});
		segments.value = rawSegments.reduce((acc, segment) => {
			const { from, to, text: text$1, token } = segment;
			if (token === "Resolvable") {
				const { resolved, error, fullError } = resolve(text$1, targetItem.value);
				acc.push({
					kind: "resolvable",
					from,
					to,
					resolvable: text$1,
					resolved: String(resolved),
					state: getResolvableState(fullError ?? error, autocompleteStatus.value !== null),
					error: fullError
				});
				return acc;
			}
			acc.push({
				kind: "plaintext",
				from,
				to,
				plaintext: text$1
			});
			return acc;
		}, []);
		if (segments.value.length === 1 && segments.value[0]?.kind === "resolvable" && segments.value[0]?.resolved === "") segments.value[0].resolved = i18n$1.baseText("expressionModalInput.empty");
	};
	function readEditorValue() {
		return editor$5.value?.state.doc.toString() ?? "";
	}
	function updateHighlighting() {
		if (!editor$5.value) return;
		highlighter.removeColor(editor$5.value, plaintextSegments.value);
		highlighter.addColor(editor$5.value, resolvableSegments.value);
	}
	function updateSelection(viewUpdate) {
		const currentSelection = selection.value;
		const newSelection = viewUpdate.state.selection.ranges[0];
		if (!currentSelection?.eq(newSelection)) selection.value = newSelection;
	}
	const debouncedUpdateSegments = (0, import_debounce$2.default)(updateSegments, 200);
	function onEditorUpdate(viewUpdate) {
		autocompleteStatus.value = completionStatus(viewUpdate.view.state);
		updateSelection(viewUpdate);
		const shouldIgnoreUpdate = viewUpdate.transactions.some((tr$1) => tr$1.annotation(ignoreUpdateAnnotation));
		if (viewUpdate.docChanged && !shouldIgnoreUpdate) {
			hasChanges.value = true;
			emitChanges(viewUpdate);
			debouncedUpdateSegments();
		}
	}
	function blur() {
		if (editor$5.value) {
			editor$5.value.contentDOM.blur();
			closeCompletion(editor$5.value);
			closeCursorInfoBox(editor$5.value);
		}
	}
	function blurOnClickOutside(event) {
		if (!dragging$2.value && !isEventTargetContainedBy(event.target, editor$5.value?.dom)) blur();
		dragging$2.value = false;
	}
	function onKeyDown(e) {
		if (unref(disableSearchDialog) && (isMacOs && e.metaKey || !isMacOs && e.ctrlKey) && e.key === "f") e.preventDefault();
	}
	watch(toRef(editorRef), () => {
		const parent$2 = toValue(editorRef);
		if (!parent$2) return;
		const state = EditorState.create({
			doc: toValue(editorValue),
			extensions: [
				TARGET_NODE_PARAMETER_FACET.of(expressionLocalResolveContext.value ? {
					nodeName: expressionLocalResolveContext.value.nodeName,
					parameterPath: ""
				} : toValue(targetNodeParameterContext)),
				customExtensions.value.of(toValue(extensions)),
				readOnlyExtensions.value.of([EditorState.readOnly.of(toValue(isReadOnly))]),
				telemetryExtensions.value.of([]),
				EditorView.updateListener.of(onEditorUpdate),
				EditorView.focusChangeEffect.of((_$2, newHasFocus) => {
					hasFocus.value = newHasFocus;
					selection.value = state.selection.ranges[0];
					if (!newHasFocus) {
						autocompleteStatus.value = null;
						debouncedUpdateSegments();
					}
					return null;
				}),
				EditorView.contentAttributes.of({ "data-gramm": "false" }),
				EditorView.domEventHandlers({ mousedown: () => {
					dragging$2.value = true;
				} })
			]
		});
		if (editor$5.value) editor$5.value.destroy();
		editor$5.value = new EditorView({
			parent: parent$2,
			state
		});
		editor$5.value.dom.addEventListener("keydown", onKeyDown, { capture: true });
		debouncedUpdateSegments();
	});
	watchEffect(() => {
		if (editor$5.value) editor$5.value.dispatch({ effects: customExtensions.value.reconfigure(toValue(extensions)) });
	});
	watchEffect(() => {
		if (editor$5.value) editor$5.value.dispatch({ effects: readOnlyExtensions.value.reconfigure([EditorState.readOnly.of(toValue(isReadOnly))]) });
	});
	watchEffect(() => {
		if (!editor$5.value) return;
		const newValue = toValue(editorValue);
		const currentValue = readEditorValue();
		if (newValue === void 0 || newValue === currentValue) return;
		editor$5.value.dispatch({ changes: {
			from: 0,
			to: currentValue.length,
			insert: newValue
		} });
	});
	watchEffect(() => {
		const telemetry = toValue(autocompleteTelemetry);
		if (!telemetry?.enabled) return;
		useAutocompleteTelemetry({
			editor: editor$5,
			parameterPath: telemetry.parameterPath,
			compartment: telemetryExtensions
		});
	});
	onMounted(() => {
		document.addEventListener("click", blurOnClickOutside);
	});
	onBeforeUnmount(() => {
		document.removeEventListener("click", blurOnClickOutside);
		debouncedUpdateSegments.flush();
		emitChanges.flush();
		editor$5.value?.destroy();
	});
	const expressionExtensionNames = computed(() => {
		return new Set(EXTENSION_OBJECTS.reduce((acc, cur) => {
			return [...acc, ...Object.keys(cur.functions)];
		}, []));
	});
	function isUncalledExpressionExtension(resolvable) {
		const end = resolvable.replace(/^{{|}}$/g, "").trim().split(".").pop();
		return end !== void 0 && expressionExtensionNames.value.has(end);
	}
	function resolve(resolvable, target) {
		const result = {
			resolved: void 0,
			error: false,
			fullError: null
		};
		try {
			if (expressionLocalResolveContext.value) result.resolved = workflowHelpers.resolveExpression("=" + resolvable, void 0, {
				...expressionLocalResolveContext.value,
				additionalKeys: toValue(additionalData)
			});
			else if (!ndvStore.activeNode && toValue(targetNodeParameterContext) === void 0) result.resolved = Expression.resolveWithoutWorkflow(resolvable, toValue(additionalData));
			else {
				let opts = {
					additionalKeys: toValue(additionalData),
					contextNodeName: toValue(targetNodeParameterContext)?.nodeName
				};
				if (toValue(targetNodeParameterContext) === void 0 && ndvStore.isInputParentOfActiveNode) opts = {
					targetItem: target ?? void 0,
					inputNodeName: ndvStore.ndvInputNodeName,
					inputRunIndex: ndvStore.ndvInputRunIndex,
					inputBranchIndex: ndvStore.ndvInputBranchIndex
				};
				result.resolved = workflowHelpers.resolveExpression("=" + resolvable, void 0, opts);
			}
		} catch (error) {
			result.resolved = `[${getExpressionErrorMessage(error, !!workflowsStore.workflowExecutionData?.data?.resultData?.runData[ndvStore.activeNode?.name ?? ""])}]`;
			result.error = true;
			result.fullError = error;
		}
		if (result.resolved === void 0) {
			result.resolved = isUncalledExpressionExtension(resolvable) ? i18n$1.baseText("expressionEditor.uncalledFunction") : i18n$1.baseText("expressionModalInput.undefined");
			result.error = true;
		}
		return result;
	}
	const targetItem = computed(() => ndvStore.expressionTargetItem);
	const resolvableSegments = computed(() => {
		return segments.value.filter((s) => s.kind === "resolvable");
	});
	const plaintextSegments = computed(() => {
		return segments.value.filter((s) => s.kind === "plaintext");
	});
	const htmlSegments = computed(() => {
		return segments.value.filter((s) => s.kind !== "resolvable");
	});
	const displayableSegments = computed(() => {
		const cachedSegments = segments.value;
		return cachedSegments.map((s) => {
			if (cachedSegments.length <= 1 || s.kind !== "resolvable") return s;
			if (typeof s.resolved === "string") {
				let resolved = s.resolved;
				if (/\[Object: "\d{4}-\d{2}-\d{2}T/.test(resolved)) {
					const utcDateString = resolved.replace(/(\[Object: "|\"\])/g, "");
					resolved = new Date(utcDateString).toString();
				}
				if (/\[Object:\s(\{.+\}|\{\})\]/.test(resolved)) {
					resolved = resolved.replace(/(\[Object: |\]$)/g, "");
					try {
						resolved = String(JSON.parse(resolved));
					} catch (error) {}
				}
				if (/\[Array:\s\[.+\]\]/.test(resolved)) {
					resolved = resolved.replace(/(\[Array: |\]$)/g, "");
					try {
						resolved = String(JSON.parse(resolved));
					} catch (error) {}
				}
				s.resolved = resolved;
			}
			return s;
		}).filter((s) => {
			if (cachedSegments.length > 1 && s.kind === "resolvable" && typeof s.resolved === "string" && (s.resolved === "[Array: []]" || s.resolved === i18n$1.baseText("expressionModalInput.empty"))) return false;
			return true;
		});
	});
	watch([() => workflowsStore.getWorkflowExecution, () => workflowsStore.getWorkflowRunData], debouncedUpdateSegments);
	watch(targetItem, updateSegments);
	watch(resolvableSegments, updateHighlighting);
	function setCursorPosition(pos) {
		if (pos === "lastExpression") {
			const endOfLastExpression = readEditorValue().lastIndexOf(" }}");
			pos = endOfLastExpression !== -1 ? endOfLastExpression : editor$5.value?.state.doc.length ?? 0;
		} else if (pos === "end") pos = editor$5.value?.state.doc.length ?? 0;
		editor$5.value?.dispatch({ selection: {
			head: pos,
			anchor: pos
		} });
	}
	function select$1(anchor, head = "end") {
		editor$5.value?.dispatch({ selection: {
			anchor,
			head: head === "end" ? editor$5.value?.state.doc.length ?? 0 : head
		} });
	}
	const selectAll = () => select$1(0, "end");
	function focus() {
		if (hasFocus.value) return;
		editor$5.value?.focus();
	}
	return {
		editor: editor$5,
		hasFocus,
		selection,
		segments: {
			all: segments,
			html: htmlSegments,
			display: displayableSegments,
			plaintext: plaintextSegments,
			resolvable: resolvableSegments
		},
		readEditorValue,
		setCursorPosition,
		select: select$1,
		selectAll,
		focus,
		hasChanges
	};
};
var descendantOp = 94, Unit = 1, callee = 95, identifier$2 = 96, VariableName = 2;
var space$1 = [
	9,
	10,
	11,
	12,
	13,
	32,
	133,
	160,
	5760,
	8192,
	8193,
	8194,
	8195,
	8196,
	8197,
	8198,
	8199,
	8200,
	8201,
	8202,
	8232,
	8233,
	8239,
	8287,
	12288
];
var colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash$1 = 45, period = 46, hash$1 = 35, percent = 37;
function isAlpha$1(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
	return ch >= 48 && ch <= 57;
}
var identifiers = new ExternalTokenizer((input$5, stack) => {
	for (let inside = false, dashes = 0, i = 0;; i++) {
		let { next } = input$5;
		if (isAlpha$1(next) || next == dash$1 || next == underscore || inside && isDigit(next)) {
			if (!inside && (next != dash$1 || i > 0)) inside = true;
			if (dashes === i && next == dash$1) dashes++;
			input$5.advance();
		} else {
			if (inside) input$5.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier$2);
			break;
		}
	}
});
var descendant = new ExternalTokenizer((input$5) => {
	if (space$1.includes(input$5.peek(-1))) {
		let { next } = input$5;
		if (isAlpha$1(next) || next == underscore || next == hash$1 || next == period || next == bracketL || next == colon || next == dash$1) input$5.acceptToken(descendantOp);
	}
});
var unitToken = new ExternalTokenizer((input$5) => {
	if (!space$1.includes(input$5.peek(-1))) {
		let { next } = input$5;
		if (next == percent) {
			input$5.advance();
			input$5.acceptToken(Unit);
		}
		if (isAlpha$1(next)) {
			do
				input$5.advance();
			while (isAlpha$1(input$5.next));
			input$5.acceptToken(Unit);
		}
	}
});
var cssHighlighting = styleTags({
	"AtKeyword import charset namespace keyframes media supports": tags.definitionKeyword,
	"from to selector": tags.keyword,
	NamespaceName: tags.namespace,
	KeyframeName: tags.labelName,
	TagName: tags.tagName,
	ClassName: tags.className,
	PseudoClassName: tags.constant(tags.className),
	IdName: tags.labelName,
	"FeatureName PropertyName": tags.propertyName,
	AttributeName: tags.attributeName,
	NumberLiteral: tags.number,
	KeywordQuery: tags.keyword,
	UnaryQueryOp: tags.operatorKeyword,
	"CallTag ValueName": tags.atom,
	VariableName: tags.variableName,
	Callee: tags.operatorKeyword,
	Unit: tags.unit,
	"UniversalSelector NestingSelector": tags.definitionOperator,
	MatchOp: tags.compareOperator,
	"ChildOp SiblingOp, LogicOp": tags.logicOperator,
	BinOp: tags.arithmeticOperator,
	Important: tags.modifier,
	Comment: tags.blockComment,
	ParenthesizedContent: tags.special(tags.name),
	ColorLiteral: tags.color,
	StringLiteral: tags.string,
	":": tags.punctuation,
	"PseudoOp #": tags.derefOperator,
	"; ,": tags.separator,
	"( )": tags.paren,
	"[ ]": tags.squareBracket,
	"{ }": tags.brace
});
var spec_callee = {
	__proto__: null,
	lang: 32,
	"nth-child": 32,
	"nth-last-child": 32,
	"nth-of-type": 32,
	"nth-last-of-type": 32,
	dir: 32,
	"host-context": 32,
	url: 60,
	"url-prefix": 60,
	domain: 60,
	regexp: 60,
	selector: 134
};
var spec_AtKeyword = {
	__proto__: null,
	"@import": 114,
	"@media": 138,
	"@charset": 142,
	"@namespace": 146,
	"@keyframes": 152,
	"@supports": 164
};
var spec_identifier$1 = {
	__proto__: null,
	not: 128,
	only: 128,
	from: 158,
	to: 160
};
var parser$3 = LRParser.deserialize({
	version: 14,
	states: "7WQYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ed'#EdO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&TQ[O'#EPO&cQ[O'#EROOQS'#Ec'#EcOOQS'#ET'#ETQYQ[OOO&jQXO'#CdO'_QWO'#DaO'dQWO'#EjO'oQ[O'#EjQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'yQ[O'#EWO(eQWO,58{O(mQ[O,59SO$lQ[O,59kO$qQ[O,59oO'yQ[O,59sO'yQ[O,59uO'yQ[O,59vO(xQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)PQWO,59SO)UQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)ZQ`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)cQvO'#CsO*pQtO,5:POOQO'#Cx'#CxO)UQWO'#CwO+UQWO'#CyOOQS'#Eg'#EgOOQO'#Dh'#DhO+ZQ[O'#DoO+iQWO'#EkO&TQ[O'#DmO+wQWO'#DpOOQO'#El'#ElO(hQWO,5:^O+|QpO,5:`OOQS'#Dx'#DxO,UQWO,5:bO,ZQ[O,5:bOOQO'#D{'#D{O,cQWO,5:eO,hQWO,5:kO,pQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,xQ[O'#EYO-VQWO,5;UO-VQWO,5;UOOQP1G.l1G.lO-|QXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)PQWO1G.nO)UQWO1G.nOOQP1G/V1G/VO.ZQ`O1G/ZO.tQXO1G/_O/[QXO1G/aO/rQXO1G/bO0YQWO,59zO0_Q[O'#DOO0fQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0mQpO,59]OOQS,59_,59_O$vQdO,59aO0uQWO1G/kOOQS,59c,59cO0zQ!bO,59eO1SQWO'#DhO1_QWO,5:TO1dQWO,5:ZO&TQ[O,5:VO&TQ[O'#EZO1lQWO,5;VO1wQWO,5:XO'yQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2YQWO1G/|O2_QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0pOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EiO3tQWO,59jO3yQtO'#EUO4nQdO'#EfO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsO(hQWO'#E[O5yQdO,5:hOOQS,5:h,5:hO6XQtO'#EXO$vQdO'#EXO7VQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7jQpO<<HaO7rQWO,5;TOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO7zQWO,5;QOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8SQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8ZQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9XQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
	stateData: "9i~O#UOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SQO#XSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SdO#XSO~O#P#^P~P!ZO#SiO~O]nO^nOplOtoOxpO|qO!PsO#QrO#XkO~O!RtO~P#kO`zO#RwO#SvO~O#S{O~O#S}O~OQ!WOb!QOf!WOh!WOn!VO#R!TO#S!PO#[!RO~Ob!YO!b![O!e!]O#S!XO!R#_P~Oh!bOn!VO#S!aO~O#S!dO~Ob!YO!b![O!e!]O#S!XO~O!W#_P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#QWX#XWX~O]!iO~O!W!jO#P#^X!Q#^X~O#P#^X!Q#^X~P!ZOUXOXXO]UO^UOtVOxWO#SQO#XSO~OplO!RtO~O`!sO#RwO#SvO~O!Q#^P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#SgXagXQgXfgXhgXngXpgX!VgX#PgX#RgX#[gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#S!XO!W#_P~Ob#TO~Ob!YO!b![O!e!]O#S#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#P!|X!Q!|X~P!ZO!W!jO#P#^a!Q#^a~O]nO^nOtoOxpO|qO!PsO#QrO#XkO~Op!za!R!zaa!za~P-bOv#lOz#mO~O]nO^nOtoOxpO#XkO~Op{i|{i!P{i!R{i#Q{ia{i~P.cOp}i|}i!P}i!R}i#Q}ia}i~P.cOp!Oi|!Oi!P!Oi!R!Oi#Q!Oia!Oi~P.cO!Q#nO~Oa#]P~P'yOa#YP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$TO!q$RO!r$RO#[$QO~Oj#QOp$VO!V$XO!W!Ti#P!Ti!Q!Ti~P$vO!W!|a#P!|a!Q!|a~P!ZO!W!jO#P#^i!Q#^i~Oa#]X~P#kOa$]O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#R!xX#S!xX#[!xX~Op$_Oa#YX~P$vOa$aO~Oj#QOv$bO~Oa$cO~O!`#XOp!}a!R!}a!W!}a~Oa$eO~P-bOP#PO!RgX~O!Q$hO!q$RO!r$RO#[$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#P!{X#R!{X#S!{X#[!{X!Q!{X~Op$VO!V$kO!W!Tq#P!Tq!Q!Tq~P$vOj#QOv$lO~OplOa#]a~Op$_Oa#Ya~Oa$oO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#P!{a#R!{a#S!{a#[!{a!Q!{a~Oa!yap!ya~P$vOo#[j!Pj~",
	goto: ",`#aPPPPP#bP#k#zP#k$Z#kPP$aPPP$g$p$pP%SP$pP$p%j%|PPP&f&l#kP&rP#kP&xP#kP#k#kPPP'O'b'oPP#bPP'v'v(Q'vP'vP'v'vP#bP#bP#bP(T#bP(W(ZPP#bP#bP(^(m({)R)])c)m)sPPPPPP)y*SP*o*rP+h+k+q+z_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mT$R#b$Sq!UY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gR$f$RSfPtQ!lgQ#g!jR$Y#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eQcOSgPtU!hcg#hR#h!jQ#r!{U$^#r$d$mQ$d#yR$m$_Q$`#rR$n$`QmTS!om$[R$[#oQ$W#fR$j$WQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$S#bR$g$S_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$_$d$mQ#t!}Q#v#QS$U#f$WQ$Z#mR$i$VR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
	nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
	maxTerm: 108,
	nodeProps: [[
		"openedBy",
		17,
		"(",
		48,
		"{"
	], [
		"closedBy",
		18,
		")",
		49,
		"}"
	]],
	propSources: [cssHighlighting],
	skippedNodes: [0, 3],
	repeatNodeCount: 8,
	tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#U~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#U~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#[UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#[UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#XPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^XKeS!RPOy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
	tokenizers: [
		descendant,
		unitToken,
		identifiers,
		0,
		1,
		2,
		3
	],
	topRules: {
		"StyleSheet": [0, 4],
		"Styles": [1, 84]
	},
	specialized: [
		{
			term: 95,
			get: (value$1) => spec_callee[value$1] || -1
		},
		{
			term: 56,
			get: (value$1) => spec_AtKeyword[value$1] || -1
		},
		{
			term: 96,
			get: (value$1) => spec_identifier$1[value$1] || -1
		}
	],
	tokenPrec: 1123
});
var _properties = null;
function properties() {
	if (!_properties && typeof document == "object" && document.body) {
		let names = [];
		for (let prop in document.body.style) if (!/[A-Z]|^-|^(item|length)$/.test(prop)) names.push(prop);
		_properties = names.sort().map((name) => ({
			type: "property",
			label: name
		}));
	}
	return _properties || [];
}
var pseudoClasses = /* @__PURE__ */ [
	"active",
	"after",
	"any-link",
	"autofill",
	"backdrop",
	"before",
	"checked",
	"cue",
	"default",
	"defined",
	"disabled",
	"empty",
	"enabled",
	"file-selector-button",
	"first",
	"first-child",
	"first-letter",
	"first-line",
	"first-of-type",
	"focus",
	"focus-visible",
	"focus-within",
	"fullscreen",
	"has",
	"host",
	"host-context",
	"hover",
	"in-range",
	"indeterminate",
	"invalid",
	"is",
	"lang",
	"last-child",
	"last-of-type",
	"left",
	"link",
	"marker",
	"modal",
	"not",
	"nth-child",
	"nth-last-child",
	"nth-last-of-type",
	"nth-of-type",
	"only-child",
	"only-of-type",
	"optional",
	"out-of-range",
	"part",
	"placeholder",
	"placeholder-shown",
	"read-only",
	"read-write",
	"required",
	"right",
	"root",
	"scope",
	"selection",
	"slotted",
	"target",
	"target-text",
	"valid",
	"visited",
	"where"
].map((name) => ({
	type: "class",
	label: name
}));
var values = /* @__PURE__ */ [
	"above",
	"absolute",
	"activeborder",
	"additive",
	"activecaption",
	"after-white-space",
	"ahead",
	"alias",
	"all",
	"all-scroll",
	"alphabetic",
	"alternate",
	"always",
	"antialiased",
	"appworkspace",
	"asterisks",
	"attr",
	"auto",
	"auto-flow",
	"avoid",
	"avoid-column",
	"avoid-page",
	"avoid-region",
	"axis-pan",
	"background",
	"backwards",
	"baseline",
	"below",
	"bidi-override",
	"blink",
	"block",
	"block-axis",
	"bold",
	"bolder",
	"border",
	"border-box",
	"both",
	"bottom",
	"break",
	"break-all",
	"break-word",
	"bullets",
	"button",
	"button-bevel",
	"buttonface",
	"buttonhighlight",
	"buttonshadow",
	"buttontext",
	"calc",
	"capitalize",
	"caps-lock-indicator",
	"caption",
	"captiontext",
	"caret",
	"cell",
	"center",
	"checkbox",
	"circle",
	"cjk-decimal",
	"clear",
	"clip",
	"close-quote",
	"col-resize",
	"collapse",
	"color",
	"color-burn",
	"color-dodge",
	"column",
	"column-reverse",
	"compact",
	"condensed",
	"contain",
	"content",
	"contents",
	"content-box",
	"context-menu",
	"continuous",
	"copy",
	"counter",
	"counters",
	"cover",
	"crop",
	"cross",
	"crosshair",
	"currentcolor",
	"cursive",
	"cyclic",
	"darken",
	"dashed",
	"decimal",
	"decimal-leading-zero",
	"default",
	"default-button",
	"dense",
	"destination-atop",
	"destination-in",
	"destination-out",
	"destination-over",
	"difference",
	"disc",
	"discard",
	"disclosure-closed",
	"disclosure-open",
	"document",
	"dot-dash",
	"dot-dot-dash",
	"dotted",
	"double",
	"down",
	"e-resize",
	"ease",
	"ease-in",
	"ease-in-out",
	"ease-out",
	"element",
	"ellipse",
	"ellipsis",
	"embed",
	"end",
	"ethiopic-abegede-gez",
	"ethiopic-halehame-aa-er",
	"ethiopic-halehame-gez",
	"ew-resize",
	"exclusion",
	"expanded",
	"extends",
	"extra-condensed",
	"extra-expanded",
	"fantasy",
	"fast",
	"fill",
	"fill-box",
	"fixed",
	"flat",
	"flex",
	"flex-end",
	"flex-start",
	"footnotes",
	"forwards",
	"from",
	"geometricPrecision",
	"graytext",
	"grid",
	"groove",
	"hand",
	"hard-light",
	"help",
	"hidden",
	"hide",
	"higher",
	"highlight",
	"highlighttext",
	"horizontal",
	"hsl",
	"hsla",
	"hue",
	"icon",
	"ignore",
	"inactiveborder",
	"inactivecaption",
	"inactivecaptiontext",
	"infinite",
	"infobackground",
	"infotext",
	"inherit",
	"initial",
	"inline",
	"inline-axis",
	"inline-block",
	"inline-flex",
	"inline-grid",
	"inline-table",
	"inset",
	"inside",
	"intrinsic",
	"invert",
	"italic",
	"justify",
	"keep-all",
	"landscape",
	"large",
	"larger",
	"left",
	"level",
	"lighter",
	"lighten",
	"line-through",
	"linear",
	"linear-gradient",
	"lines",
	"list-item",
	"listbox",
	"listitem",
	"local",
	"logical",
	"loud",
	"lower",
	"lower-hexadecimal",
	"lower-latin",
	"lower-norwegian",
	"lowercase",
	"ltr",
	"luminosity",
	"manipulation",
	"match",
	"matrix",
	"matrix3d",
	"medium",
	"menu",
	"menutext",
	"message-box",
	"middle",
	"min-intrinsic",
	"mix",
	"monospace",
	"move",
	"multiple",
	"multiple_mask_images",
	"multiply",
	"n-resize",
	"narrower",
	"ne-resize",
	"nesw-resize",
	"no-close-quote",
	"no-drop",
	"no-open-quote",
	"no-repeat",
	"none",
	"normal",
	"not-allowed",
	"nowrap",
	"ns-resize",
	"numbers",
	"numeric",
	"nw-resize",
	"nwse-resize",
	"oblique",
	"opacity",
	"open-quote",
	"optimizeLegibility",
	"optimizeSpeed",
	"outset",
	"outside",
	"outside-shape",
	"overlay",
	"overline",
	"padding",
	"padding-box",
	"painted",
	"page",
	"paused",
	"perspective",
	"pinch-zoom",
	"plus-darker",
	"plus-lighter",
	"pointer",
	"polygon",
	"portrait",
	"pre",
	"pre-line",
	"pre-wrap",
	"preserve-3d",
	"progress",
	"push-button",
	"radial-gradient",
	"radio",
	"read-only",
	"read-write",
	"read-write-plaintext-only",
	"rectangle",
	"region",
	"relative",
	"repeat",
	"repeating-linear-gradient",
	"repeating-radial-gradient",
	"repeat-x",
	"repeat-y",
	"reset",
	"reverse",
	"rgb",
	"rgba",
	"ridge",
	"right",
	"rotate",
	"rotate3d",
	"rotateX",
	"rotateY",
	"rotateZ",
	"round",
	"row",
	"row-resize",
	"row-reverse",
	"rtl",
	"run-in",
	"running",
	"s-resize",
	"sans-serif",
	"saturation",
	"scale",
	"scale3d",
	"scaleX",
	"scaleY",
	"scaleZ",
	"screen",
	"scroll",
	"scrollbar",
	"scroll-position",
	"se-resize",
	"self-start",
	"self-end",
	"semi-condensed",
	"semi-expanded",
	"separate",
	"serif",
	"show",
	"single",
	"skew",
	"skewX",
	"skewY",
	"skip-white-space",
	"slide",
	"slider-horizontal",
	"slider-vertical",
	"sliderthumb-horizontal",
	"sliderthumb-vertical",
	"slow",
	"small",
	"small-caps",
	"small-caption",
	"smaller",
	"soft-light",
	"solid",
	"source-atop",
	"source-in",
	"source-out",
	"source-over",
	"space",
	"space-around",
	"space-between",
	"space-evenly",
	"spell-out",
	"square",
	"start",
	"static",
	"status-bar",
	"stretch",
	"stroke",
	"stroke-box",
	"sub",
	"subpixel-antialiased",
	"svg_masks",
	"super",
	"sw-resize",
	"symbolic",
	"symbols",
	"system-ui",
	"table",
	"table-caption",
	"table-cell",
	"table-column",
	"table-column-group",
	"table-footer-group",
	"table-header-group",
	"table-row",
	"table-row-group",
	"text",
	"text-bottom",
	"text-top",
	"textarea",
	"textfield",
	"thick",
	"thin",
	"threeddarkshadow",
	"threedface",
	"threedhighlight",
	"threedlightshadow",
	"threedshadow",
	"to",
	"top",
	"transform",
	"translate",
	"translate3d",
	"translateX",
	"translateY",
	"translateZ",
	"transparent",
	"ultra-condensed",
	"ultra-expanded",
	"underline",
	"unidirectional-pan",
	"unset",
	"up",
	"upper-latin",
	"uppercase",
	"url",
	"var",
	"vertical",
	"vertical-text",
	"view-box",
	"visible",
	"visibleFill",
	"visiblePainted",
	"visibleStroke",
	"visual",
	"w-resize",
	"wait",
	"wave",
	"wider",
	"window",
	"windowframe",
	"windowtext",
	"words",
	"wrap",
	"wrap-reverse",
	"x-large",
	"x-small",
	"xor",
	"xx-large",
	"xx-small"
].map((name) => ({
	type: "keyword",
	label: name
})).concat(/* @__PURE__ */ [
	"aliceblue",
	"antiquewhite",
	"aqua",
	"aquamarine",
	"azure",
	"beige",
	"bisque",
	"black",
	"blanchedalmond",
	"blue",
	"blueviolet",
	"brown",
	"burlywood",
	"cadetblue",
	"chartreuse",
	"chocolate",
	"coral",
	"cornflowerblue",
	"cornsilk",
	"crimson",
	"cyan",
	"darkblue",
	"darkcyan",
	"darkgoldenrod",
	"darkgray",
	"darkgreen",
	"darkkhaki",
	"darkmagenta",
	"darkolivegreen",
	"darkorange",
	"darkorchid",
	"darkred",
	"darksalmon",
	"darkseagreen",
	"darkslateblue",
	"darkslategray",
	"darkturquoise",
	"darkviolet",
	"deeppink",
	"deepskyblue",
	"dimgray",
	"dodgerblue",
	"firebrick",
	"floralwhite",
	"forestgreen",
	"fuchsia",
	"gainsboro",
	"ghostwhite",
	"gold",
	"goldenrod",
	"gray",
	"grey",
	"green",
	"greenyellow",
	"honeydew",
	"hotpink",
	"indianred",
	"indigo",
	"ivory",
	"khaki",
	"lavender",
	"lavenderblush",
	"lawngreen",
	"lemonchiffon",
	"lightblue",
	"lightcoral",
	"lightcyan",
	"lightgoldenrodyellow",
	"lightgray",
	"lightgreen",
	"lightpink",
	"lightsalmon",
	"lightseagreen",
	"lightskyblue",
	"lightslategray",
	"lightsteelblue",
	"lightyellow",
	"lime",
	"limegreen",
	"linen",
	"magenta",
	"maroon",
	"mediumaquamarine",
	"mediumblue",
	"mediumorchid",
	"mediumpurple",
	"mediumseagreen",
	"mediumslateblue",
	"mediumspringgreen",
	"mediumturquoise",
	"mediumvioletred",
	"midnightblue",
	"mintcream",
	"mistyrose",
	"moccasin",
	"navajowhite",
	"navy",
	"oldlace",
	"olive",
	"olivedrab",
	"orange",
	"orangered",
	"orchid",
	"palegoldenrod",
	"palegreen",
	"paleturquoise",
	"palevioletred",
	"papayawhip",
	"peachpuff",
	"peru",
	"pink",
	"plum",
	"powderblue",
	"purple",
	"rebeccapurple",
	"red",
	"rosybrown",
	"royalblue",
	"saddlebrown",
	"salmon",
	"sandybrown",
	"seagreen",
	"seashell",
	"sienna",
	"silver",
	"skyblue",
	"slateblue",
	"slategray",
	"snow",
	"springgreen",
	"steelblue",
	"tan",
	"teal",
	"thistle",
	"tomato",
	"turquoise",
	"violet",
	"wheat",
	"white",
	"whitesmoke",
	"yellow",
	"yellowgreen"
].map((name) => ({
	type: "constant",
	label: name
})));
var tags$1 = /* @__PURE__ */ [
	"a",
	"abbr",
	"address",
	"article",
	"aside",
	"b",
	"bdi",
	"bdo",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"figcaption",
	"figure",
	"footer",
	"form",
	"header",
	"hgroup",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"label",
	"legend",
	"li",
	"main",
	"meter",
	"nav",
	"ol",
	"output",
	"p",
	"pre",
	"ruby",
	"section",
	"select",
	"small",
	"source",
	"span",
	"strong",
	"sub",
	"summary",
	"sup",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"tr",
	"u",
	"ul"
].map((name) => ({
	type: "type",
	label: name
}));
var identifier$1 = /^[\w-]*/;
var cssCompletionSource = (context) => {
	let { state, pos } = context, node$1 = syntaxTree(state).resolveInner(pos, -1);
	if (node$1.name == "PropertyName") return {
		from: node$1.from,
		options: properties(),
		validFor: identifier$1
	};
	if (node$1.name == "ValueName") return {
		from: node$1.from,
		options: values,
		validFor: identifier$1
	};
	if (node$1.name == "PseudoClassName") return {
		from: node$1.from,
		options: pseudoClasses,
		validFor: identifier$1
	};
	if (node$1.name == "TagName") {
		for (let { parent: parent$2 } = node$1; parent$2; parent$2 = parent$2.parent) if (parent$2.name == "Block") return {
			from: node$1.from,
			options: properties(),
			validFor: identifier$1
		};
		return {
			from: node$1.from,
			options: tags$1,
			validFor: identifier$1
		};
	}
	if (!context.explicit) return null;
	let above = node$1.resolve(pos), before = above.childBefore(pos);
	if (before && before.name == ":" && above.name == "PseudoClassSelector") return {
		from: pos,
		options: pseudoClasses,
		validFor: identifier$1
	};
	if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList") return {
		from: pos,
		options: values,
		validFor: identifier$1
	};
	if (above.name == "Block") return {
		from: pos,
		options: properties(),
		validFor: identifier$1
	};
	return null;
};
var cssLanguage = /* @__PURE__ */ LRLanguage.define({
	name: "css",
	parser: /* @__PURE__ */ parser$3.configure({ props: [/* @__PURE__ */ indentNodeProp.add({ Declaration: /* @__PURE__ */ continuedIndent() }), /* @__PURE__ */ foldNodeProp.add({ Block: foldInside })] }),
	languageData: {
		commentTokens: { block: {
			open: "/*",
			close: "*/"
		} },
		indentOnInput: /^\s*\}$/,
		wordChars: "-"
	}
});
function css$1() {
	return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}
var scriptText = 55, StartCloseScriptTag = 1, styleText = 56, StartCloseStyleTag = 2, textareaText = 57, StartCloseTextareaTag = 3, StartTag = 4, StartScriptTag = 5, StartStyleTag = 6, StartTextareaTag = 7, StartSelfClosingTag = 8, StartCloseTag = 9, NoMatchStartCloseTag = 10, MismatchedStartCloseTag = 11, missingCloseTag = 58, IncompleteCloseTag = 12, commentContent$1 = 59, Element$1 = 19, TagName = 21, Attribute = 22, AttributeName = 23, AttributeValue = 25, UnquotedAttributeValue = 26, ScriptText = 28, StyleText = 31, TextareaText = 34, OpenTag = 36, CloseTag = 37, Dialect_noMatch = 0;
var selfClosers = {
	area: true,
	base: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
	menuitem: true
};
var implicitlyClosed = {
	dd: true,
	li: true,
	optgroup: true,
	option: true,
	p: true,
	rp: true,
	rt: true,
	tbody: true,
	td: true,
	tfoot: true,
	th: true,
	tr: true
};
var closeOnOpen = {
	dd: {
		dd: true,
		dt: true
	},
	dt: {
		dd: true,
		dt: true
	},
	li: { li: true },
	option: {
		option: true,
		optgroup: true
	},
	optgroup: { optgroup: true },
	p: {
		address: true,
		article: true,
		aside: true,
		blockquote: true,
		dir: true,
		div: true,
		dl: true,
		fieldset: true,
		footer: true,
		form: true,
		h1: true,
		h2: true,
		h3: true,
		h4: true,
		h5: true,
		h6: true,
		header: true,
		hgroup: true,
		hr: true,
		menu: true,
		nav: true,
		ol: true,
		p: true,
		pre: true,
		section: true,
		table: true,
		ul: true
	},
	rp: {
		rp: true,
		rt: true
	},
	rt: {
		rp: true,
		rt: true
	},
	tbody: {
		tbody: true,
		tfoot: true
	},
	td: {
		td: true,
		th: true
	},
	tfoot: { tbody: true },
	th: {
		td: true,
		th: true
	},
	thead: {
		tbody: true,
		tfoot: true
	},
	tr: { tr: true }
};
function nameChar(ch) {
	return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
	return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
var cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input$5, offset) {
	let pos = input$5.pos + offset;
	if (cachedPos == pos && cachedInput == input$5) return cachedName;
	let next = input$5.peek(offset);
	while (isSpace(next)) next = input$5.peek(++offset);
	let name = "";
	for (;;) {
		if (!nameChar(next)) break;
		name += String.fromCharCode(next);
		next = input$5.peek(++offset);
	}
	cachedInput = input$5;
	cachedPos = pos;
	return cachedName = name ? name.toLowerCase() : next == question || next == bang ? void 0 : null;
}
var lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;
function ElementContext(name, parent$2) {
	this.name = name;
	this.parent = parent$2;
	this.hash = parent$2 ? parent$2.hash : 0;
	for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}
var startTagTerms = [
	StartTag,
	StartSelfClosingTag,
	StartScriptTag,
	StartStyleTag,
	StartTextareaTag
];
var elementContext = /* @__PURE__ */ new ContextTracker({
	start: null,
	shift(context, term, stack, input$5) {
		return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input$5, 1) || "", context) : context;
	},
	reduce(context, term) {
		return term == Element$1 && context ? context.parent : context;
	},
	reuse(context, node$1, stack, input$5) {
		let type = node$1.type.id;
		return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input$5, 1) || "", context) : context;
	},
	hash(context) {
		return context ? context.hash : 0;
	},
	strict: false
});
var tagStart = /* @__PURE__ */ new ExternalTokenizer((input$5, stack) => {
	if (input$5.next != lessThan) {
		if (input$5.next < 0 && stack.context) input$5.acceptToken(missingCloseTag);
		return;
	}
	input$5.advance();
	let close$1 = input$5.next == slash;
	if (close$1) input$5.advance();
	let name = tagNameAfter(input$5, 0);
	if (name === void 0) return;
	if (!name) return input$5.acceptToken(close$1 ? IncompleteCloseTag : StartTag);
	let parent$2 = stack.context ? stack.context.name : null;
	if (close$1) {
		if (name == parent$2) return input$5.acceptToken(StartCloseTag);
		if (parent$2 && implicitlyClosed[parent$2]) return input$5.acceptToken(missingCloseTag, -2);
		if (stack.dialectEnabled(Dialect_noMatch)) return input$5.acceptToken(NoMatchStartCloseTag);
		for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return;
		input$5.acceptToken(MismatchedStartCloseTag);
	} else {
		if (name == "script") return input$5.acceptToken(StartScriptTag);
		if (name == "style") return input$5.acceptToken(StartStyleTag);
		if (name == "textarea") return input$5.acceptToken(StartTextareaTag);
		if (selfClosers.hasOwnProperty(name)) return input$5.acceptToken(StartSelfClosingTag);
		if (parent$2 && closeOnOpen[parent$2] && closeOnOpen[parent$2][name]) input$5.acceptToken(missingCloseTag, -1);
		else input$5.acceptToken(StartTag);
	}
}, { contextual: true });
var commentContent = /* @__PURE__ */ new ExternalTokenizer((input$5) => {
	for (let dashes = 0, i = 0;; i++) {
		if (input$5.next < 0) {
			if (i) input$5.acceptToken(commentContent$1);
			break;
		}
		if (input$5.next == dash) dashes++;
		else if (input$5.next == greaterThan && dashes >= 2) {
			if (i > 3) input$5.acceptToken(commentContent$1, -2);
			break;
		} else dashes = 0;
		input$5.advance();
	}
});
function contentTokenizer(tag, textToken, endToken) {
	let lastState = 2 + tag.length;
	return new ExternalTokenizer((input$5) => {
		for (let state = 0, matchedLen = 0, i = 0;; i++) {
			if (input$5.next < 0) {
				if (i) input$5.acceptToken(textToken);
				break;
			}
			if (state == 0 && input$5.next == lessThan || state == 1 && input$5.next == slash || state >= 2 && state < lastState && input$5.next == tag.charCodeAt(state - 2)) {
				state++;
				matchedLen++;
			} else if ((state == 2 || state == lastState) && isSpace(input$5.next)) matchedLen++;
			else if (state == lastState && input$5.next == greaterThan) {
				if (i > matchedLen) input$5.acceptToken(textToken, -matchedLen);
				else input$5.acceptToken(endToken, -(matchedLen - 2));
				break;
			} else if ((input$5.next == 10 || input$5.next == 13) && i) {
				input$5.acceptToken(textToken, 1);
				break;
			} else state = matchedLen = 0;
			input$5.advance();
		}
	});
}
var scriptTokens = /* @__PURE__ */ contentTokenizer("script", scriptText, StartCloseScriptTag);
var styleTokens = /* @__PURE__ */ contentTokenizer("style", styleText, StartCloseStyleTag);
var textareaTokens = /* @__PURE__ */ contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
var htmlHighlighting = /* @__PURE__ */ styleTags({
	"Text RawText": tags.content,
	"StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
	TagName: tags.tagName,
	"MismatchedCloseTag/TagName": [tags.tagName, tags.invalid],
	AttributeName: tags.attributeName,
	"AttributeValue UnquotedAttributeValue": tags.attributeValue,
	Is: tags.definitionOperator,
	"EntityReference CharacterReference": tags.character,
	Comment: tags.blockComment,
	ProcessingInst: tags.processingInstruction,
	DoctypeDecl: tags.documentMeta
});
var parser$2 = /* @__PURE__ */ LRParser.deserialize({
	version: 14,
	states: ",xOVOxOOO!ZQ!bO'#CpO!`Q!bO'#CzO!eQ!bO'#C}O!jQ!bO'#DQO!oQ!bO'#DSO!tOXO'#CoO#POYO'#CoO#[O[O'#CoO$kOxO'#CoOOOW'#Co'#CoO$rO!rO'#DUO$zQ!bO'#DWO%PQ!bO'#DXOOOW'#Dl'#DlOOOW'#DZ'#DZQVOxOOO%UQ#tO,59[O%^Q#tO,59fO%fQ#tO,59iO%nQ#tO,59lO%yQ#tO,59nOOOX'#D_'#D_O&ROXO'#CxO&^OXO,59ZOOOY'#D`'#D`O&fOYO'#C{O&qOYO,59ZOOO['#Da'#DaO&yO[O'#DOO'UO[O,59ZOOOW'#Db'#DbO'^OxO,59ZO'eQ!bO'#DROOOW,59Z,59ZOOO`'#Dc'#DcO'jO!rO,59pOOOW,59p,59pO'rQ!bO,59rO'wQ!bO,59sOOOW-E7X-E7XO'|Q#tO'#CrOOQO'#D['#D[O([Q#tO1G.vOOOX1G.v1G.vO(dQ#tO1G/QOOOY1G/Q1G/QO(lQ#tO1G/TOOO[1G/T1G/TO(tQ#tO1G/WOOOW1G/W1G/WOOOW1G/Y1G/YO)PQ#tO1G/YOOOX-E7]-E7]O)XQ!bO'#CyOOOW1G.u1G.uOOOY-E7^-E7^O)^Q!bO'#C|OOO[-E7_-E7_O)cQ!bO'#DPOOOW-E7`-E7`O)hQ!bO,59mOOO`-E7a-E7aOOOW1G/[1G/[OOOW1G/^1G/^OOOW1G/_1G/_O)mQ&jO,59^OOQO-E7Y-E7YOOOX7+$b7+$bOOOY7+$l7+$lOOO[7+$o7+$oOOOW7+$r7+$rOOOW7+$t7+$tO)xQ!bO,59eO)}Q!bO,59hO*SQ!bO,59kOOOW1G/X1G/XO*XO,UO'#CuO*jO7[O'#CuOOQO1G.x1G.xOOOW1G/P1G/POOOW1G/S1G/SOOOW1G/V1G/VOOOO'#D]'#D]O*{O,UO,59aOOQO,59a,59aOOOO'#D^'#D^O+^O7[O,59aOOOO-E7Z-E7ZOOQO1G.{1G.{OOOO-E7[-E7[",
	stateData: "+}~O!_OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ob^Oy^O|_O!eZO~OeaO~OebO~OecO~OedO~OeeO~O!XfOPlP![lP~O!YiOQoP![oP~O!ZlORrP![rP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ob^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OevO~OewO~OgyOk|O~OgyOk!OO~OgyOk!QO~OgyOk!SOw!TO~OgyOk!TO~O!XfOPlX![lX~OP!WO![!XO~O!YiOQoX![oX~OQ!ZO![!XO~O!ZlORrX![rX~OR!]O![!XO~O![!XO~P#gOe!_O~O!]sO!f!aO~Ok!bO~Ok!cO~Oh!dOgfXkfXwfX~OgyOk!fO~OgyOk!gO~OgyOk!hO~OgyOk!iOw!jO~OgyOk!jO~Oe!kO~Oe!lO~Oe!mO~Ok!nO~Oj!qO!a!oO!c!pO~Ok!rO~Ok!sO~Ok!tO~O`!uOa!uOb!uO!a!wO!b!uO~O`!xOa!xOb!xO!c!wO!d!xO~O`!uOa!uOb!uO!a!{O!b!uO~O`!xOa!xOb!xO!c!{O!d!xO~Ow~_^w!ey|ak`b`~",
	goto: "%q!aPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zPP!}#Q#T#Z#^#a#g#j#m#s#yP!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
	nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text Resolvable EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
	maxTerm: 68,
	context: elementContext,
	nodeProps: [
		[
			"closedBy",
			-10,
			1,
			2,
			3,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			"EndTag",
			4,
			"EndTag SelfClosingEndTag",
			-4,
			20,
			30,
			33,
			36,
			"CloseTag"
		],
		[
			"group",
			-10,
			12,
			15,
			16,
			17,
			18,
			19,
			40,
			41,
			42,
			43,
			"Entity",
			14,
			"Entity TextContent",
			-3,
			28,
			31,
			34,
			"TextContent Entity"
		],
		[
			"openedBy",
			27,
			"StartTag StartCloseTag",
			-4,
			29,
			32,
			35,
			37,
			"OpenTag",
			39,
			"StartTag"
		]
	],
	propSources: [htmlHighlighting],
	skippedNodes: [0],
	repeatNodeCount: 9,
	tokenData: "&(b!aR!ZOX$tXY3aYZ3aZ[$t[]&b]^3a^p$tpq3aqr4trsBjsv4tvwC`wx!*Tx}4t}!O!*|!O!P4t!P!Q!0_!Q![4t![!]!3O!]!^4t!^!_!7Z!_!`#5r!`!a#6p!a!c4t!c!}!3O!}#R4t#R#S!3O#S#T:r#T#o!3O#o#p#7n#p#s4t#s$f$t$f%W4t%W%o!3O%o%p4t%p&a!3O&a&b4t&b1p!3O1p4U4t4U4d!3O4d4e4t4e$IS!3O$IS$I`4t$I`$Ib!3O$Ib$Kh4t$Kh%#t!3O%#t&/x4t&/x&Et!3O&Et&FV4t&FV;'S!3O;'S;:j!7T;:j;=`Bd<%l?&r4t?&r?Ah!3O?Ah?BY$t?BY?Mn!3O?MnO$t!Z%PejW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!a&b!a#S$t#S#T&b#T#o$t#o#p0Q#p;'S$t;'S;=`3Z<%lO$t!R&kZ!b`!dp^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&bq'eX!dp^POv'^wx(Qx!^'^!^!_)d!_#o'^#o#p){#p;'S'^;'S;=`*s<%lO'^P(VV^POv(Qw!^(Q!_#o(Q#o#p(l#p;'S(Q;'S;=`)X<%lO(QP(oWOv(Qw!^(Q!_#o(Q#p;'S(Q;'S;=`)X<%l~(Q~O(Q~~)_P)[P;=`<%l(QP)dO^Pp)iS!dpOv)dx;'S)d;'S;=`)u<%lO)dp)xP;=`<%l)dq*QZ!dpOv'^wx(Qx!^'^!^!_)d!_#o'^#o#p)d#p;'S'^;'S;=`*s<%l~'^~O'^~~)_q*vP;=`<%l'^a+QY!b`^POr*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p,[#p;'S*y;'S;=`-V<%lO*y`+uT!b`Or+psv+pw;'S+p;'S;=`,U<%lO+p`,XP;=`<%l+pa,a[!b`Or*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p+p#p;'S*y;'S;=`-V<%l~*y~O*y~~)_a-YP;=`<%l*y!Q-dV!b`!dpOr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!Q-|P;=`<%l-]!R.W]!b`!dpOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p-]#p;'S&b;'S;=`/P<%l~&b~O&b~~)_!R/SP;=`<%l&bW/[YjWOX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/VW/}P;=`<%l/V!Z0ZgjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!a&b!a#S$t#S#T&b#T#o$t#o#p1r#p;'S$t;'S;=`3Z<%l~$t~O$t~~)_!Y1{bjW!b`!dpOX1rXZ-]Z[1r[^-]^p1rpq-]qr1rrs)dsv1rvw/Vwx+px!^1r!^!a-]!a#S1r#S#T-]#T;'S1r;'S;=`3T<%lO1r!Y3WP;=`<%l1r!Z3^P;=`<%l$t!a3lb!b`!dp!_^^POX&bXY3aYZ3aZ]&b]^3a^p&bpq3aqr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!_5RlgSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t[7QcgSjWOX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/VS8bXgSqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]S9QP;=`<%l8][9WP;=`<%l6y!U9dbgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!U:oP;=`<%l9Z!V:}egS!b`!dp^POq&bqr:rrs'^sv:rvw8]wx*yx!P:r!P!Q&b!Q!^:r!^!_9Z!_!a&b!a#o:r#o#p<`#p#s:r#s$f&b$f;'S:r;'S;=`>Q<%l?Ah:r?Ah?BY&b?BY?Mn:r?MnO&b!V<iggS!b`!dpOq&bqr:rrs'^sv:rvw8]wx*yx!P:r!P!Q&b!Q!^:r!^!_9Z!_!a&b!a#o:r#o#p9Z#p#s:r#s$f&b$f;'S:r;'S;=`>Q<%l?Ah:r?Ah?BY&b?BY?Mn:r?Mn~&b~O&b~~)_!V>TP;=`<%l:r!_>cngSjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p@a#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?Mn~$t~O$t~~)_!^@ljgSjW!b`!dpOX1rXZ-]Z[1r[^-]^p1rpq-]qr@ars)dsv@avw6ywx+px!P@a!P!Q1r!Q!^@a!^!_9Z!_!a-]!a#S@a#S#T9Z#T#s@a#s$f1r$f;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!^BaP;=`<%l@a!_BgP;=`<%l4t!ZBsX!ah!dp^POv'^wx(Qx!^'^!^!_)d!_#o'^#o#p){#p;'S'^;'S;=`*s<%lO'^!_CijgSjWb!ROXEZXZFhZ[EZ[^Fh^pEZqrHYrsFhstMztwHYwxFhx!PHY!P!QEZ!Q!]HY!]!^6y!^!_Kg!_!aFh!a#SHY#S#TKg#T#sHY#s$fEZ$f;'SHY;'S;=`Mt<%l?AhHY?Ah?BYEZ?BY?MnHY?MnOEZ!ZE`bjWOXEZXZFhZ[EZ[^Fh^pEZqrEZrsFhst/VtwEZwxFhx!]EZ!]!^G]!^!aFh!a#SEZ#S#TFh#T;'SEZ;'S;=`HS<%lOEZ!RFkVOpFhqsFht!]Fh!]!^GQ!^;'SFh;'S;=`GV<%lOFh!RGVO`!R!RGYP;=`<%lFh!ZGdYjW`!ROX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/V!ZHVP;=`<%lEZ!_HajgSjWOXEZXZFhZ[EZ[^Fh^pEZqrHYrsFhst6ytwHYwxFhx!PHY!P!QEZ!Q!]HY!]!^JR!^!_Kg!_!aFh!a#SHY#S#TKg#T#sHY#s$fEZ$f;'SHY;'S;=`Mt<%l?AhHY?Ah?BYEZ?BY?MnHY?MnOEZ!_J[cgSjW`!ROX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V!VKldgSOpFhqrKgrsFhst8]twKgwxFhx!PKg!P!QFh!Q!]Kg!]!^Lz!^!_Kg!_!aFh!a#sKg#s$fFh$f;'SKg;'S;=`Mn<%l?AhKg?Ah?BYFh?BY?MnKg?MnOFh!VMRXgS`!Rqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]!VMqP;=`<%lKg!_MwP;=`<%lHY!_NRigSjWOX! pXZ!!zZ[! p[^!!z^p! pqr!$irs!!zsw!$iwx!!zx!P!$i!P!Q! p!Q!]!$i!]!^6y!^!_!'s!_!a!!z!a#S!$i#S#T!'s#T#s!$i#s$f! p$f;'S!$i;'S;=`!)}<%l?Ah!$i?Ah?BY! p?BY?Mn!$i?MnO! p!Z! uajWOX! pXZ!!zZ[! p[^!!z^p! pqr! prs!!zsw! pwx!!zx!]! p!]!^!#l!^!a!!z!a#S! p#S#T!!z#T;'S! p;'S;=`!$c<%lO! p!R!!}UOp!!zq!]!!z!]!^!#a!^;'S!!z;'S;=`!#f<%lO!!z!R!#fOa!R!R!#iP;=`<%l!!z!Z!#sYjWa!ROX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/V!Z!$fP;=`<%l! p!_!$pigSjWOX! pXZ!!zZ[! p[^!!z^p! pqr!$irs!!zsw!$iwx!!zx!P!$i!P!Q! p!Q!]!$i!]!^!&_!^!_!'s!_!a!!z!a#S!$i#S#T!'s#T#s!$i#s$f! p$f;'S!$i;'S;=`!)}<%l?Ah!$i?Ah?BY! p?BY?Mn!$i?MnO! p!_!&hcgSjWa!ROX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V!V!'xcgSOp!!zqr!'srs!!zsw!'swx!!zx!P!'s!P!Q!!z!Q!]!'s!]!^!)T!^!_!'s!_!a!!z!a#s!'s#s$f!!z$f;'S!'s;'S;=`!)w<%l?Ah!'s?Ah?BY!!z?BY?Mn!'s?MnO!!z!V!)[XgSa!Rqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]!V!)zP;=`<%l!'s!_!*QP;=`<%l!$i!Z!*^Y!cx!b`^POr*yrs(Qsv*yw!^*y!^!_+p!_#o*y#o#p,[#p;'S*y;'S;=`-V<%lO*y!a!+ZngSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx}4t}!O!-X!O!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t!a!-fmgSjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!`&b!`!a!/a!a#S4t#S#T:r#T#o4t#o#p>W#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?MnO$t!T!/lZ!b`!dp!fQ^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!a!0jfjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr$trs'^sv$tvw/Vwx*yx!^$t!^!_-]!_!`&b!`!a!2O!a#S$t#S#T&b#T#o$t#o#p0Q#p;'S$t;'S;=`3Z<%lO$t!X!2]Z!b`!dp^PwSkUOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!a!3_![gSeQjW!b`!dp^POX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx}4t}!O!3O!O!P!3O!P!Q$t!Q![!3O![!]!3O!]!^4t!^!_9Z!_!a&b!a!c4t!c!}!3O!}#R4t#R#S!3O#S#T:r#T#o!3O#o#p>W#p#s4t#s$f$t$f$}4t$}%O!3O%O%W4t%W%o!3O%o%p4t%p&a!3O&a&b4t&b1p!3O1p4U!3O4U4d!3O4d4e4t4e$IS!3O$IS$I`4t$I`$Ib!3O$Ib$Je4t$Je$Jg!3O$Jg$Kh4t$Kh%#t!3O%#t&/x4t&/x&Et!3O&Et&FV4t&FV;'S!3O;'S;:j!7T;:j;=`Bd<%l?&r4t?&r?Ah!3O?Ah?BY$t?BY?Mn!3O?MnO$t!a!7WP;=`<%l!3O!V!7dcgS!b`!dpOq-]qr!8ors)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!b#(|!b#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!8xhgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px}9Z}!O!:d!O!P9Z!P!Q-]!Q!_9Z!_!a-]!a!f9Z!f!g!=`!g#W9Z#W#X!M|#X#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!:mdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px}9Z}!O!;{!O!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!<WbgS!b`!dp!ePOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!=idgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!q9Z!q!r!>w!r#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!?QdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!e9Z!e!f!@`!f#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!@idgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!v9Z!v!w!Aw!w#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!BQdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!{9Z!{!|!C`!|#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!CidgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!r9Z!r!s!Dw!s#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!EQdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a!g9Z!g!h!F`!h#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V!FicgS!b`!dpOq!Gtqr!F`rs!Hksv!F`vw!Lcwx!J_x!P!F`!P!Q!Gt!Q!_!F`!_!`!Gt!`!a!Km!a#s!F`#s$f!Gt$f;'S!F`;'S;=`!Mv<%l?Ah!F`?Ah?BY!Gt?BY?Mn!F`?MnO!Gt!R!G{Y!b`!dpOr!Gtrs!Hksv!Gtvw!IVwx!J_x!`!Gt!`!a!Km!a;'S!Gt;'S;=`!L]<%lO!Gtq!HpV!dpOv!Hkvx!IVx!`!Hk!`!a!It!a;'S!Hk;'S;=`!JX<%lO!HkP!IYTO!`!IV!`!a!Ii!a;'S!IV;'S;=`!In<%lO!IVP!InO|PP!IqP;=`<%l!IVq!I{S!dp|POv)dx;'S)d;'S;=`)u<%lO)dq!J[P;=`<%l!Hka!JdX!b`Or!J_rs!IVsv!J_vw!IVw!`!J_!`!a!KP!a;'S!J_;'S;=`!Kg<%lO!J_a!KWT!b`|POr+psv+pw;'S+p;'S;=`,U<%lO+pa!KjP;=`<%l!J_!R!KvV!b`!dp|POr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R!L`P;=`<%l!GtT!LhbgSOq!IVqr!Lcrs!IVsw!Lcwx!IVx!P!Lc!P!Q!IV!Q!_!Lc!_!`!IV!`!a!Ii!a#s!Lc#s$f!IV$f;'S!Lc;'S;=`!Mp<%l?Ah!Lc?Ah?BY!IV?BY?Mn!Lc?MnO!IVT!MsP;=`<%l!Lc!V!MyP;=`<%l!F`!V!NVdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#c9Z#c#d# e#d#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V# ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#V9Z#V#W#!|#W#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V##VdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#h9Z#h#i#$e#i#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#$ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#m9Z#m#n#%|#n#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#&VdgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#d9Z#d#e#'e#e#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#'ndgS!b`!dpOq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#X9Z#X#Y!F`#Y#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V#)VcgS!b`!dpOq#*bqr#(|rs#+Xsv#(|vw#1fwx#-yx!P#(|!P!Q#*b!Q!_#(|!_!a#*b!a!b#4W!b#s#(|#s$f#*b$f;'S#(|;'S;=`#5l<%l?Ah#(|?Ah?BY#*b?BY?Mn#(|?MnO#*b!R#*iY!b`!dpOr#*brs#+Xsv#*bvw#+swx#-yx!a#*b!a!b#/y!b;'S#*b;'S;=`#1`<%lO#*bq#+^V!dpOv#+Xvx#+sx!a#+X!a!b#,t!b;'S#+X;'S;=`#-s<%lO#+XP#+vTO!a#+s!a!b#,V!b;'S#+s;'S;=`#,n<%lO#+sP#,YTO!`#+s!`!a#,i!a;'S#+s;'S;=`#,n<%lO#+sP#,nOyPP#,qP;=`<%l#+sq#,yV!dpOv#+Xvx#+sx!`#+X!`!a#-`!a;'S#+X;'S;=`#-s<%lO#+Xq#-gS!dpyPOv)dx;'S)d;'S;=`)u<%lO)dq#-vP;=`<%l#+Xa#.OX!b`Or#-yrs#+ssv#-yvw#+sw!a#-y!a!b#.k!b;'S#-y;'S;=`#/s<%lO#-ya#.pX!b`Or#-yrs#+ssv#-yvw#+sw!`#-y!`!a#/]!a;'S#-y;'S;=`#/s<%lO#-ya#/dT!b`yPOr+psv+pw;'S+p;'S;=`,U<%lO+pa#/vP;=`<%l#-y!R#0QY!b`!dpOr#*brs#+Xsv#*bvw#+swx#-yx!`#*b!`!a#0p!a;'S#*b;'S;=`#1`<%lO#*b!R#0yV!b`!dpyPOr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R#1cP;=`<%l#*bT#1kbgSOq#+sqr#1frs#+ssw#1fwx#+sx!P#1f!P!Q#+s!Q!_#1f!_!a#+s!a!b#2s!b#s#1f#s$f#+s$f;'S#1f;'S;=`#4Q<%l?Ah#1f?Ah?BY#+s?BY?Mn#1f?MnO#+sT#2xbgSOq#+sqr#1frs#+ssw#1fwx#+sx!P#1f!P!Q#+s!Q!_#1f!_!`#+s!`!a#,i!a#s#1f#s$f#+s$f;'S#1f;'S;=`#4Q<%l?Ah#1f?Ah?BY#+s?BY?Mn#1f?MnO#+sT#4TP;=`<%l#1f!V#4acgS!b`!dpOq#*bqr#(|rs#+Xsv#(|vw#1fwx#-yx!P#(|!P!Q#*b!Q!_#(|!_!`#*b!`!a#0p!a#s#(|#s$f#*b$f;'S#(|;'S;=`#5l<%l?Ah#(|?Ah?BY#*b?BY?Mn#(|?MnO#*b!V#5oP;=`<%l#(|!V#5}ZhS!b`!dp^POr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!X#6{Z!b`!dp^PkUOr&brs'^sv&bwx*yx!^&b!^!_-]!_#o&b#o#p.P#p;'S&b;'S;=`/P<%lO&b!_#7yngSjW!b`!dpOX$tXZ&bZ[$t[^&b^p$tpq&bqr4trs'^sv4tvw6ywx*yx!P4t!P!Q$t!Q!^4t!^!_9Z!_!a&b!a#S4t#S#T:r#T#o4t#o#p#9w#p#s4t#s$f$t$f;'S4t;'S;=`Bd<%l?Ah4t?Ah?BY$t?BY?Mn4t?Mn~$t~O$t~~)_!_#:S!SgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r&$Y#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!Z#=i|jW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$JR#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!R#@jw!b`!dpOX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$4b#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]q#CYt!dpOX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r$#Z#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dP#EmiOX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#KS#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#G_iOX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#H|#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#IPTO#q#Ej#q#r#I`#r;'S#Ej;'S;=`#Kk<%lO#EjP#Iei_POX#EjX^#Ej^p#Ejpq#Ejq!Q#Ej!Q![#Ej![!c#Ej!c!}#Ej!}#O#Ej#O#P#G[#P#T#Ej#T#o#Ej#o#q#Ej#q#r#KS#r#y#Ej#y#z#Ej#z$f#Ej$f$g#Ej$gG|#Ej#BY#BZ#Ej$IS$I_#Ej$I|$JO#Ej$JT$JU#Ej$KV$KW#Ej&FU&FV#EjP#KVTO#q#Ej#q#r#Kf#r;'S#Ej;'S;=`#Kk<%lO#EjP#KkO_PP#KnP;=`<%l#Ejq#Kvt!dpOX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r#NW#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dq#N]V!dpOv#CTvx#Ejx#q#CT#q#r#Nr#r;'S#CT;'S;=`$$Y<%lO#CTq#Nyt!dp_POX#CTX^#CT^p#CTpq#CTqv#CTvx#Ejx!Q#CT!Q![#CT![!c#CT!c!}#CT!}#O#CT#O#P#Kq#P#T#CT#T#o#CT#o#q#CT#q#r$#Z#r#y#CT#y#z#CT#z$f#CT$f$g#CT$gG|#CTG|#BY)d#BY#BZ#CT#BZ$IS)d$IS$I_#CT$I_$I|)d$I|$JO#CT$JO$JT)d$JT$JU#CT$JU$KV)d$KV$KW#CT$KW&FU)d&FU&FV#CT&FV;'S)d;'S;=`)u<%lO)dq$#`V!dpOv#CTvx#Ejx#q#CT#q#r$#u#r;'S#CT;'S;=`$$Y<%lO#CTq$#|S!dp_POv)dx;'S)d;'S;=`)u<%lO)dq$$]P;=`<%l#CTa$$ev!b`OX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$,w#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$'Qv!b`OX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$)h#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$)mX!b`Or$$`rs#Ejsv$$`vw#Ejw#q$$`#q#r$*Y#r;'S$$`;'S;=`$.P<%lO$$`a$*av!b`_POX$$`X^$$`^p$$`pq$$`qr$$`rs#Ejsv$$`vw#Ejw!Q$$`!Q![$$`![!c$$`!c!}$$`!}#O$$`#O#P$&{#P#T$$`#T#o$$`#o#q$$`#q#r$,w#r#y$$`#y#z$$`#z$f$$`$f$g$$`$gG|$$`G|#BY+p#BY#BZ$$`#BZ$IS+p$IS$I_$$`$I_$I|+p$I|$JO$$`$JO$JT+p$JT$JU$$`$JU$KV+p$KV$KW$$`$KW&FU+p&FU&FV$$`&FV;'S+p;'S;=`,U<%lO+pa$,|X!b`Or$$`rs#Ejsv$$`vw#Ejw#q$$`#q#r$-i#r;'S$$`;'S;=`$.P<%lO$$`a$-pT!b`_POr+psv+pw;'S+p;'S;=`,U<%lO+pa$.SP;=`<%l$$`!R$.^w!b`!dpOX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$0w#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]!R$1OY!b`!dpOr#@crs#CTsv#@cvw#Ejwx$$`x#q#@c#q#r$1n#r;'S#@c;'S;=`$5w<%lO#@c!R$1ww!b`!dp_POX#@cX^#@c^p#@cpq#@cqr#@crs#CTsv#@cvw#Ejwx$$`x!Q#@c!Q![#@c![!c#@c!c!}#@c!}#O#@c#O#P$.V#P#T#@c#T#o#@c#o#q#@c#q#r$4b#r#y#@c#y#z#@c#z$f#@c$f$g#@c$gG|#@cG|#BY-]#BY#BZ#@c#BZ$IS-]$IS$I_#@c$I_$I|-]$I|$JO#@c$JO$JT-]$JT$JU#@c$JU$KV-]$KV$KW#@c$KW&FU-]&FU&FV#@c&FV;'S-];'S;=`-y<%lO-]!R$4iY!b`!dpOr#@crs#CTsv#@cvw#Ejwx$$`x#q#@c#q#r$5X#r;'S#@c;'S;=`$5w<%lO#@c!R$5bV!b`!dp_POr-]rs)dsv-]wx+px;'S-];'S;=`-y<%lO-]!R$5zP;=`<%l#@cX$6S{jWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$@T#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$9O{jWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$;u#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$;zcjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!^$5}!^!a#Ej!a#S$5}#S#T#Ej#T#q$5}#q#r$=V#r;'S$5};'S;=`$B[<%lO$5}X$=^{jW_POX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!Q$5}!Q![$5}![!^$5}!^!a#Ej!a!c$5}!c!}$5}!}#O$5}#O#P$8y#P#S$5}#S#T#Ej#T#o$5}#o#q$5}#q#r$@T#r#y$5}#y#z$5}#z$f$5}$f$g$5}$gG|$5}G|#BY/V#BY#BZ$5}#BZ$IS/V$IS$I_$5}$I_$I|/V$I|$JO$5}$JO$JT/V$JT$JU$5}$JU$KV/V$KV$KW$5}$KW&FU/V&FU&FV$5}&FV;'S/V;'S;=`/z<%lO/VX$@YcjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$5}rs#Ejsw$5}wx#Ejx!^$5}!^!a#Ej!a#S$5}#S#T#Ej#T#q$5}#q#r$Ae#r;'S$5};'S;=`$B[<%lO$5}X$AlYjW_POX/VZ[/V^p/Vqr/Vsw/Vx!^/V!a#S/V#T;'S/V;'S;=`/z<%lO/VX$B_P;=`<%l$5}!Z$Bk|jW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$Ee#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!Z$EndjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!^#=`!^!a#@c!a#S#=`#S#T#@c#T#q#=`#q#r$F|#r;'S#=`;'S;=`$L}<%lO#=`!Z$GX|jW!b`!dp_POX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!Q#=`!Q![#=`![!^#=`!^!a#@c!a!c#=`!c!}#=`!}#O#=`#O#P$Bb#P#S#=`#S#T#@c#T#o#=`#o#q#=`#q#r$JR#r#y#=`#y#z#=`#z$f#=`$f$g#=`$gG|#=`G|#BY1r#BY#BZ#=`#BZ$IS1r$IS$I_#=`$I_$I|1r$I|$JO#=`$JO$JT1r$JT$JU#=`$JU$KV1r$KV$KW#=`$KW&FU1r&FU&FV#=`&FV;'S1r;'S;=`3T<%lO1r!Z$J[djW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#=`rs#CTsv#=`vw$5}wx$$`x!^#=`!^!a#@c!a#S#=`#S#T#@c#T#q#=`#q#r$Kj#r;'S#=`;'S;=`$L}<%lO#=`!Z$KubjW!b`!dp_POX1rXZ-]Z[1r[^-]^p1rpq-]qr1rrs)dsv1rvw/Vwx+px!^1r!^!a-]!a#S1r#S#T-]#T;'S1r;'S;=`3T<%lO1r!Z$MQP;=`<%l#=`]$M[!RgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%7e#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/VT%!j{gSOX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%,k#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%%f{gSOX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%(]#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%(bcgSOq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q!_%!e!_!a#Ej!a#q%!e#q#r%)m#r#s%!e#s$f#Ej$f;'S%!e;'S;=`%.o<%l?Ah%!e?Ah?BY#Ej?BY?Mn%!e?MnO#EjT%)t{gS_POX#EjX^#Ej^p#Ejpq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q![%!e![!_%!e!_!a#Ej!a!c%!e!c!}%!e!}#O%!e#O#P%%a#P#T%!e#T#o%!e#o#q%!e#q#r%,k#r#s%!e#s#y#Ej#y#z#Ej#z$f#Ej$f$g%!e$gG|%!eG|#BY8]#BY#BZ%!e#BZ$IS8]$IS$I_%!e$I_$I|8]$I|$JO%!e$JO$JT8]$JT$JU%!e$JU$KV8]$KV$KW%!e$KW&FU8]&FU&FV%!e&FV;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%,pcgSOq#Ejqr%!ers#Ejsw%!ewx#Ejx!P%!e!P!Q#Ej!Q!_%!e!_!a#Ej!a#q%!e#q#r%-{#r#s%!e#s$f#Ej$f;'S%!e;'S;=`%.o<%l?Ah%!e?Ah?BY#Ej?BY?Mn%!e?MnO#EjT%.SXgS_Pqr8]sw8]x!P8]!Q!_8]!a#s8]$f;'S8];'S;=`8}<%l?Ah8]?BY?Mn8]T%.rP;=`<%l%!e]%.|!RgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%2V#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%2^kgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q!^$MT!^!_%!e!_!a#Ej!a#S$MT#S#T%!e#T#q$MT#q#r%4R#r#s$MT#s$f$5}$f;'S$MT;'S;=`%:u<%l?Ah$MT?Ah?BY$5}?BY?Mn$MT?MnO$5}]%4[!RgSjW_POX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q![$MT![!^$MT!^!_%!e!_!a#Ej!a!c$MT!c!}$MT!}#O$MT#O#P%.u#P#S$MT#S#T%!e#T#o$MT#o#q$MT#q#r%7e#r#s$MT#s#y$5}#y#z$5}#z$f$5}$f$g$MT$gG|$MTG|#BY6y#BY#BZ$MT#BZ$IS6y$IS$I_$MT$I_$I|6y$I|$JO$MT$JO$JT6y$JT$JU$MT$JU$KV6y$KV$KW$MT$KW&FU6y&FU&FV$MT&FV;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%7lkgSjWOX$5}XZ#EjZ[$5}[^#Ej^p$5}pq#Ejqr$MTrs#Ejsw$MTwx#Ejx!P$MT!P!Q$5}!Q!^$MT!^!_%!e!_!a#Ej!a#S$MT#S#T%!e#T#q$MT#q#r%9a#r#s$MT#s$f$5}$f;'S$MT;'S;=`%:u<%l?Ah$MT?Ah?BY$5}?BY?Mn$MT?MnO$5}]%9jcgSjW_POX/VZ[/V^p/Vqr6ysw6yx!P6y!P!Q/V!Q!^6y!^!_8]!a#S6y#S#T8]#T#s6y#s$f/V$f;'S6y;'S;=`9T<%l?Ah6y?Ah?BY/V?BY?Mn6y?MnO/V]%:xP;=`<%l$MT!V%;U!OgS!b`!dpOX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%FR#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%>_!OgS!b`!dpOX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%A_#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%AhdgS!b`!dpOq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q!_%:{!_!a#@c!a#q%:{#q#r%Bv#r#s%:{#s$f#@c$f;'S%:{;'S;=`%H}<%l?Ah%:{?Ah?BY#@c?BY?Mn%:{?MnO#@c!V%CR!OgS!b`!dp_POX#@cX^#@c^p#@cpq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q![%:{![!_%:{!_!a#@c!a!c%:{!c!}%:{!}#O%:{#O#P%>U#P#T%:{#T#o%:{#o#q%:{#q#r%FR#r#s%:{#s#y#@c#y#z#@c#z$f#@c$f$g%:{$gG|%:{G|#BY9Z#BY#BZ%:{#BZ$IS9Z$IS$I_%:{$I_$I|9Z$I|$JO%:{$JO$JT9Z$JT$JU%:{$JU$KV9Z$KV$KW%:{$KW&FU9Z&FU&FV%:{&FV;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%F[dgS!b`!dpOq#@cqr%:{rs#CTsv%:{vw%!ewx$$`x!P%:{!P!Q#@c!Q!_%:{!_!a#@c!a#q%:{#q#r%Gj#r#s%:{#s$f#@c$f;'S%:{;'S;=`%H}<%l?Ah%:{?Ah?BY#@c?BY?Mn%:{?MnO#@c!V%GubgS!b`!dp_POq-]qr9Zrs)dsv9Zvw8]wx+px!P9Z!P!Q-]!Q!_9Z!_!a-]!a#s9Z#s$f-]$f;'S9Z;'S;=`:l<%l?Ah9Z?Ah?BY-]?BY?Mn9Z?MnO-]!V%IQP;=`<%l%:{!_%I`!SgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r%Ll#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_%LwlgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q!^#9w!^!_%:{!_!a#@c!a#S#9w#S#T%:{#T#q#9w#q#r%No#r#s#9w#s$f#=`$f;'S#9w;'S;=`&([<%l?Ah#9w?Ah?BY#=`?BY?Mn#9w?MnO#=`!_%N|!SgSjW!b`!dp_POX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q![#9w![!^#9w!^!_%:{!_!a#@c!a!c#9w!c!}#9w!}#O#9w#O#P%IT#P#S#9w#S#T%:{#T#o#9w#o#q#9w#q#r&$Y#r#s#9w#s#y#=`#y#z#=`#z$f#=`$f$g#9w$gG|#9wG|#BY@a#BY#BZ#9w#BZ$IS@a$IS$I_#9w$I_$I|@a$I|$JO#9w$JO$JT@a$JT$JU#9w$JU$KV@a$KV$KW#9w$KW&FU@a&FU&FV#9w&FV;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_&$elgSjW!b`!dpOX#=`XZ#@cZ[#=`[^#@c^p#=`pq#@cqr#9wrs#CTsv#9wvw$MTwx$$`x!P#9w!P!Q#=`!Q!^#9w!^!_%:{!_!a#@c!a#S#9w#S#T%:{#T#q#9w#q#r&&]#r#s#9w#s$f#=`$f;'S#9w;'S;=`&([<%l?Ah#9w?Ah?BY#=`?BY?Mn#9w?MnO#=`!_&&jjgSjW!b`!dp_POX1rXZ-]Z[1r[^-]^p1rpq-]qr@ars)dsv@avw6ywx+px!P@a!P!Q1r!Q!^@a!^!_9Z!_!a-]!a#S@a#S#T9Z#T#s@a#s$f1r$f;'S@a;'S;=`B^<%l?Ah@a?Ah?BY1r?BY?Mn@a?MnO1r!_&(_P;=`<%l#9w",
	tokenizers: [
		scriptTokens,
		styleTokens,
		textareaTokens,
		tagStart,
		commentContent,
		0,
		1,
		2,
		3,
		4,
		5
	],
	topRules: { "Document": [0, 13] },
	dialects: {
		noMatch: 0,
		selfClosing: 491
	},
	tokenPrec: 493
});
function getAttrs(openTag, input$5) {
	let attrs = Object.create(null);
	for (let att of openTag.getChildren(Attribute)) {
		let name = att.getChild(AttributeName), value$1 = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
		if (name) attrs[input$5.read(name.from, name.to)] = !value$1 ? "" : value$1.type.id == AttributeValue ? input$5.read(value$1.from + 1, value$1.to - 1) : input$5.read(value$1.from, value$1.to);
	}
	return attrs;
}
function findTagName(openTag, input$5) {
	let tagNameNode = openTag.getChild(TagName);
	return tagNameNode ? input$5.read(tagNameNode.from, tagNameNode.to) : " ";
}
function maybeNest(node$1, input$5, tags$2) {
	let attrs;
	for (let tag of tags$2) if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node$1.node.parent.firstChild, input$5)))) return { parser: tag.parser };
	return null;
}
function configureNesting(tags$2 = [], attributes = []) {
	let script = [], style = [], textarea = [], other = [];
	for (let tag of tags$2) (tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other).push(tag);
	let attrs = attributes.length ? Object.create(null) : null;
	for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);
	return parseMixed((node$1, input$5) => {
		let id = node$1.type.id;
		if (id == ScriptText) return maybeNest(node$1, input$5, script);
		if (id == StyleText) return maybeNest(node$1, input$5, style);
		if (id == TextareaText) return maybeNest(node$1, input$5, textarea);
		if (id == OpenTag && other.length) {
			let n = node$1.node, tagName = findTagName(n, input$5), attrs$1;
			for (let tag of other) if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs$1 || (attrs$1 = getAttrs(n, input$5))))) {
				let close$1 = n.parent.lastChild;
				return {
					parser: tag.parser,
					overlay: [{
						from: node$1.to,
						to: close$1.type.id == CloseTag ? close$1.from : n.parent.to
					}]
				};
			}
		}
		if (attrs && id == Attribute) {
			let n = node$1.node, nameNode;
			if (nameNode = n.firstChild) {
				let matches$1 = attrs[input$5.read(nameNode.from, nameNode.to)];
				if (matches$1) for (let attr of matches$1) {
					if (attr.tagName && attr.tagName != findTagName(n.parent, input$5)) continue;
					let value$1 = n.lastChild;
					if (value$1.type.id == AttributeValue) return {
						parser: attr.parser,
						overlay: [{
							from: value$1.from + 1,
							to: value$1.to - 1
						}]
					};
					else if (value$1.type.id == UnquotedAttributeValue) return {
						parser: attr.parser,
						overlay: [{
							from: value$1.from,
							to: value$1.to
						}]
					};
				}
			}
		}
		return null;
	});
}
var Targets = [
	"_blank",
	"_self",
	"_top",
	"_parent"
];
var Charsets = [
	"ascii",
	"utf-8",
	"utf-16",
	"latin1",
	"latin1"
];
var Methods = [
	"get",
	"post",
	"put",
	"delete"
];
var Encs = [
	"application/x-www-form-urlencoded",
	"multipart/form-data",
	"text/plain"
];
var Bool$1 = ["true", "false"];
var S = {};
var Tags = {
	a: { attrs: {
		href: null,
		ping: null,
		type: null,
		media: null,
		target: Targets,
		hreflang: null
	} },
	abbr: S,
	address: S,
	area: { attrs: {
		alt: null,
		coords: null,
		href: null,
		target: null,
		ping: null,
		media: null,
		hreflang: null,
		type: null,
		shape: [
			"default",
			"rect",
			"circle",
			"poly"
		]
	} },
	article: S,
	aside: S,
	audio: { attrs: {
		src: null,
		mediagroup: null,
		crossorigin: ["anonymous", "use-credentials"],
		preload: [
			"none",
			"metadata",
			"auto"
		],
		autoplay: ["autoplay"],
		loop: ["loop"],
		controls: ["controls"]
	} },
	b: S,
	base: { attrs: {
		href: null,
		target: Targets
	} },
	bdi: S,
	bdo: S,
	blockquote: { attrs: { cite: null } },
	body: S,
	br: S,
	button: { attrs: {
		form: null,
		formaction: null,
		name: null,
		value: null,
		autofocus: ["autofocus"],
		disabled: ["autofocus"],
		formenctype: Encs,
		formmethod: Methods,
		formnovalidate: ["novalidate"],
		formtarget: Targets,
		type: [
			"submit",
			"reset",
			"button"
		]
	} },
	canvas: { attrs: {
		width: null,
		height: null
	} },
	caption: S,
	center: S,
	cite: S,
	code: S,
	col: { attrs: { span: null } },
	colgroup: { attrs: { span: null } },
	command: { attrs: {
		type: [
			"command",
			"checkbox",
			"radio"
		],
		label: null,
		icon: null,
		radiogroup: null,
		command: null,
		title: null,
		disabled: ["disabled"],
		checked: ["checked"]
	} },
	data: { attrs: { value: null } },
	datagrid: { attrs: {
		disabled: ["disabled"],
		multiple: ["multiple"]
	} },
	datalist: { attrs: { data: null } },
	dd: S,
	del: { attrs: {
		cite: null,
		datetime: null
	} },
	details: { attrs: { open: ["open"] } },
	dfn: S,
	div: S,
	dl: S,
	dt: S,
	em: S,
	embed: { attrs: {
		src: null,
		type: null,
		width: null,
		height: null
	} },
	eventsource: { attrs: { src: null } },
	fieldset: { attrs: {
		disabled: ["disabled"],
		form: null,
		name: null
	} },
	figcaption: S,
	figure: S,
	footer: S,
	form: { attrs: {
		action: null,
		name: null,
		"accept-charset": Charsets,
		autocomplete: ["on", "off"],
		enctype: Encs,
		method: Methods,
		novalidate: ["novalidate"],
		target: Targets
	} },
	h1: S,
	h2: S,
	h3: S,
	h4: S,
	h5: S,
	h6: S,
	head: { children: [
		"title",
		"base",
		"link",
		"style",
		"meta",
		"script",
		"noscript",
		"command"
	] },
	header: S,
	hgroup: S,
	hr: S,
	html: { attrs: { manifest: null } },
	i: S,
	iframe: { attrs: {
		src: null,
		srcdoc: null,
		name: null,
		width: null,
		height: null,
		sandbox: [
			"allow-top-navigation",
			"allow-same-origin",
			"allow-forms",
			"allow-scripts"
		],
		seamless: ["seamless"]
	} },
	img: { attrs: {
		alt: null,
		src: null,
		ismap: null,
		usemap: null,
		width: null,
		height: null,
		crossorigin: ["anonymous", "use-credentials"]
	} },
	input: { attrs: {
		alt: null,
		dirname: null,
		form: null,
		formaction: null,
		height: null,
		list: null,
		max: null,
		maxlength: null,
		min: null,
		name: null,
		pattern: null,
		placeholder: null,
		size: null,
		src: null,
		step: null,
		value: null,
		width: null,
		accept: [
			"audio/*",
			"video/*",
			"image/*"
		],
		autocomplete: ["on", "off"],
		autofocus: ["autofocus"],
		checked: ["checked"],
		disabled: ["disabled"],
		formenctype: Encs,
		formmethod: Methods,
		formnovalidate: ["novalidate"],
		formtarget: Targets,
		multiple: ["multiple"],
		readonly: ["readonly"],
		required: ["required"],
		type: [
			"hidden",
			"text",
			"search",
			"tel",
			"url",
			"email",
			"password",
			"datetime",
			"date",
			"month",
			"week",
			"time",
			"datetime-local",
			"number",
			"range",
			"color",
			"checkbox",
			"radio",
			"file",
			"submit",
			"image",
			"reset",
			"button"
		]
	} },
	ins: { attrs: {
		cite: null,
		datetime: null
	} },
	kbd: S,
	keygen: { attrs: {
		challenge: null,
		form: null,
		name: null,
		autofocus: ["autofocus"],
		disabled: ["disabled"],
		keytype: ["RSA"]
	} },
	label: { attrs: {
		for: null,
		form: null
	} },
	legend: S,
	li: { attrs: { value: null } },
	link: { attrs: {
		href: null,
		type: null,
		hreflang: null,
		media: null,
		sizes: [
			"all",
			"16x16",
			"16x16 32x32",
			"16x16 32x32 64x64"
		]
	} },
	map: { attrs: { name: null } },
	mark: S,
	menu: { attrs: {
		label: null,
		type: [
			"list",
			"context",
			"toolbar"
		]
	} },
	meta: { attrs: {
		content: null,
		charset: Charsets,
		name: [
			"viewport",
			"application-name",
			"author",
			"description",
			"generator",
			"keywords"
		],
		"http-equiv": [
			"content-language",
			"content-type",
			"default-style",
			"refresh"
		]
	} },
	meter: { attrs: {
		value: null,
		min: null,
		low: null,
		high: null,
		max: null,
		optimum: null
	} },
	nav: S,
	noscript: S,
	object: { attrs: {
		data: null,
		type: null,
		name: null,
		usemap: null,
		form: null,
		width: null,
		height: null,
		typemustmatch: ["typemustmatch"]
	} },
	ol: {
		attrs: {
			reversed: ["reversed"],
			start: null,
			type: [
				"1",
				"a",
				"A",
				"i",
				"I"
			]
		},
		children: [
			"li",
			"script",
			"template",
			"ul",
			"ol"
		]
	},
	optgroup: { attrs: {
		disabled: ["disabled"],
		label: null
	} },
	option: { attrs: {
		disabled: ["disabled"],
		label: null,
		selected: ["selected"],
		value: null
	} },
	output: { attrs: {
		for: null,
		form: null,
		name: null
	} },
	p: S,
	param: { attrs: {
		name: null,
		value: null
	} },
	pre: S,
	progress: { attrs: {
		value: null,
		max: null
	} },
	q: { attrs: { cite: null } },
	rp: S,
	rt: S,
	ruby: S,
	samp: S,
	script: { attrs: {
		type: ["text/javascript"],
		src: null,
		async: ["async"],
		defer: ["defer"],
		charset: Charsets
	} },
	section: S,
	select: { attrs: {
		form: null,
		name: null,
		size: null,
		autofocus: ["autofocus"],
		disabled: ["disabled"],
		multiple: ["multiple"]
	} },
	slot: { attrs: { name: null } },
	small: S,
	source: { attrs: {
		src: null,
		type: null,
		media: null
	} },
	span: S,
	strong: S,
	style: { attrs: {
		type: ["text/css"],
		media: null,
		scoped: null
	} },
	sub: S,
	summary: S,
	sup: S,
	table: S,
	tbody: S,
	td: { attrs: {
		colspan: null,
		rowspan: null,
		headers: null
	} },
	template: S,
	textarea: { attrs: {
		dirname: null,
		form: null,
		maxlength: null,
		name: null,
		placeholder: null,
		rows: null,
		cols: null,
		autofocus: ["autofocus"],
		disabled: ["disabled"],
		readonly: ["readonly"],
		required: ["required"],
		wrap: ["soft", "hard"]
	} },
	tfoot: S,
	th: { attrs: {
		colspan: null,
		rowspan: null,
		headers: null,
		scope: [
			"row",
			"col",
			"rowgroup",
			"colgroup"
		]
	} },
	thead: S,
	time: { attrs: { datetime: null } },
	title: S,
	tr: S,
	track: { attrs: {
		src: null,
		label: null,
		default: null,
		kind: [
			"subtitles",
			"captions",
			"descriptions",
			"chapters",
			"metadata"
		],
		srclang: null
	} },
	ul: { children: [
		"li",
		"script",
		"template",
		"ul",
		"ol"
	] },
	var: S,
	video: { attrs: {
		src: null,
		poster: null,
		width: null,
		height: null,
		crossorigin: ["anonymous", "use-credentials"],
		preload: [
			"auto",
			"metadata",
			"none"
		],
		autoplay: ["autoplay"],
		mediagroup: ["movie"],
		muted: ["muted"],
		controls: ["controls"]
	} },
	wbr: S
};
var GlobalAttrs = {
	accesskey: null,
	class: null,
	contenteditable: Bool$1,
	contextmenu: null,
	dir: [
		"ltr",
		"rtl",
		"auto"
	],
	draggable: [
		"true",
		"false",
		"auto"
	],
	dropzone: [
		"copy",
		"move",
		"link",
		"string:",
		"file:"
	],
	hidden: ["hidden"],
	id: null,
	inert: ["inert"],
	itemid: null,
	itemprop: null,
	itemref: null,
	itemscope: ["itemscope"],
	itemtype: null,
	lang: [
		"ar",
		"bn",
		"de",
		"en-GB",
		"en-US",
		"es",
		"fr",
		"hi",
		"id",
		"ja",
		"pa",
		"pt",
		"ru",
		"tr",
		"zh"
	],
	spellcheck: Bool$1,
	autocorrect: Bool$1,
	autocapitalize: Bool$1,
	style: null,
	tabindex: null,
	title: null,
	translate: ["yes", "no"],
	rel: [
		"stylesheet",
		"alternate",
		"author",
		"bookmark",
		"help",
		"license",
		"next",
		"nofollow",
		"noreferrer",
		"prefetch",
		"prev",
		"search",
		"tag"
	],
	role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
	"aria-activedescendant": null,
	"aria-atomic": Bool$1,
	"aria-autocomplete": [
		"inline",
		"list",
		"both",
		"none"
	],
	"aria-busy": Bool$1,
	"aria-checked": [
		"true",
		"false",
		"mixed",
		"undefined"
	],
	"aria-controls": null,
	"aria-describedby": null,
	"aria-disabled": Bool$1,
	"aria-dropeffect": null,
	"aria-expanded": [
		"true",
		"false",
		"undefined"
	],
	"aria-flowto": null,
	"aria-grabbed": [
		"true",
		"false",
		"undefined"
	],
	"aria-haspopup": Bool$1,
	"aria-hidden": Bool$1,
	"aria-invalid": [
		"true",
		"false",
		"grammar",
		"spelling"
	],
	"aria-label": null,
	"aria-labelledby": null,
	"aria-level": null,
	"aria-live": [
		"off",
		"polite",
		"assertive"
	],
	"aria-multiline": Bool$1,
	"aria-multiselectable": Bool$1,
	"aria-owns": null,
	"aria-posinset": null,
	"aria-pressed": [
		"true",
		"false",
		"mixed",
		"undefined"
	],
	"aria-readonly": Bool$1,
	"aria-relevant": null,
	"aria-required": Bool$1,
	"aria-selected": [
		"true",
		"false",
		"undefined"
	],
	"aria-setsize": null,
	"aria-sort": [
		"ascending",
		"descending",
		"none",
		"other"
	],
	"aria-valuemax": null,
	"aria-valuemin": null,
	"aria-valuenow": null,
	"aria-valuetext": null
};
var eventAttributes = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let a of eventAttributes) GlobalAttrs[a] = null;
var Schema = class {
	constructor(extraTags, extraAttrs) {
		this.tags = Object.assign(Object.assign({}, Tags), extraTags);
		this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
		this.allTags = Object.keys(this.tags);
		this.globalAttrNames = Object.keys(this.globalAttrs);
	}
};
Schema.default = /* @__PURE__ */ new Schema();
function elementName(doc, tree, max = doc.length) {
	if (!tree) return "";
	let tag = tree.firstChild;
	let name = tag && tag.getChild("TagName");
	return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
	for (let cur = tree.parent; cur; cur = cur.parent) if (cur.name == "Element") if (skip) skip = false;
	else return cur;
	return null;
}
function allowedChildren(doc, tree, schema$1) {
	let parentInfo = schema$1.tags[elementName(doc, findParentElement(tree, true))];
	return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema$1.allTags;
}
function openTags(doc, tree) {
	let open = [];
	for (let parent$2 = tree; parent$2 = findParentElement(parent$2);) {
		let tagName = elementName(doc, parent$2);
		if (tagName && parent$2.lastChild.name == "CloseTag") break;
		if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent$2.firstChild.to)) open.push(tagName);
	}
	return open;
}
var identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema$1, tree, from, to) {
	let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
	return {
		from,
		to,
		options: allowedChildren(state.doc, tree, schema$1).map((tagName) => ({
			label: tagName,
			type: "type"
		})).concat(openTags(state.doc, tree).map((tag, i) => ({
			label: "/" + tag,
			apply: "/" + tag + end,
			type: "type",
			boost: 99 - i
		}))),
		validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
	};
}
function completeCloseTag(state, tree, from, to) {
	let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
	return {
		from,
		to,
		options: openTags(state.doc, tree).map((tag, i) => ({
			label: tag,
			apply: tag + end,
			type: "type",
			boost: 99 - i
		})),
		validFor: identifier
	};
}
function completeStartTag(state, schema$1, tree, pos) {
	let options$1 = [], level = 0;
	for (let tagName of allowedChildren(state.doc, tree, schema$1)) options$1.push({
		label: "<" + tagName,
		type: "type"
	});
	for (let open of openTags(state.doc, tree)) options$1.push({
		label: "</" + open + ">",
		type: "type",
		boost: 99 - level++
	});
	return {
		from: pos,
		to: pos,
		options: options$1,
		validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
	};
}
function completeAttrName(state, schema$1, tree, from, to) {
	let elt = findParentElement(tree), info = elt ? schema$1.tags[elementName(state.doc, elt)] : null;
	let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
	return {
		from,
		to,
		options: (info && info.globalAttrs === false ? localAttrs : localAttrs.length ? localAttrs.concat(schema$1.globalAttrNames) : schema$1.globalAttrNames).map((attrName) => ({
			label: attrName,
			type: "property"
		})),
		validFor: identifier
	};
}
function completeAttrValue(state, schema$1, tree, from, to) {
	var _a$1;
	let nameNode = (_a$1 = tree.parent) === null || _a$1 === void 0 ? void 0 : _a$1.getChild("AttributeName");
	let options$1 = [], token = void 0;
	if (nameNode) {
		let attrName = state.sliceDoc(nameNode.from, nameNode.to);
		let attrs = schema$1.globalAttrs[attrName];
		if (!attrs) {
			let elt = findParentElement(tree), info = elt ? schema$1.tags[elementName(state.doc, elt)] : null;
			attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
		}
		if (attrs) {
			let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = "\"", quoteEnd = "\"";
			if (/^['"]/.test(base)) {
				token = base[0] == "\"" ? /^[^"]*$/ : /^[^']*$/;
				quoteStart = "";
				quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
				base = base.slice(1);
				from++;
			} else token = /^[^\s<>='"]*$/;
			for (let value$1 of attrs) options$1.push({
				label: value$1,
				apply: quoteStart + value$1 + quoteEnd,
				type: "constant"
			});
		}
	}
	return {
		from,
		to,
		options: options$1,
		validFor: token
	};
}
function htmlCompletionFor(schema$1, context) {
	let { state, pos } = context, around = syntaxTree(state).resolveInner(pos), tree = around.resolve(pos, -1);
	for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
		let last$2 = before.lastChild;
		if (!last$2 || !last$2.type.isError || last$2.from < last$2.to) break;
		around = tree = before;
		scan = last$2.from;
	}
	if (tree.name == "TagName") return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, schema$1, tree, tree.from, pos);
	else if (tree.name == "StartTag") return completeTag(state, schema$1, tree, pos, pos);
	else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") return completeCloseTag(state, tree, pos, pos);
	else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") return completeAttrName(state, schema$1, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
	else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") return completeAttrValue(state, schema$1, tree, tree.name == "Is" ? pos : tree.from, pos);
	else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) return completeStartTag(state, schema$1, tree, pos);
	else return null;
}
function htmlCompletionSourceWith(config) {
	let { extraTags, extraGlobalAttributes: extraAttrs } = config;
	let schema$1 = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
	return (context) => htmlCompletionFor(schema$1, context);
}
var defaultNesting = [
	{
		tag: "script",
		attrs: (attrs) => attrs.type == "text/typescript" || attrs.lang == "ts",
		parser: typescriptLanguage.parser
	},
	{
		tag: "script",
		attrs: (attrs) => attrs.type == "text/babel" || attrs.type == "text/jsx",
		parser: jsxLanguage.parser
	},
	{
		tag: "script",
		attrs: (attrs) => attrs.type == "text/typescript-jsx",
		parser: tsxLanguage.parser
	},
	{
		tag: "script",
		attrs(attrs) {
			return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
		},
		parser: javascriptLanguage.parser
	},
	{
		tag: "style",
		attrs(attrs) {
			return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
		},
		parser: cssLanguage.parser
	}
];
var defaultAttrs = /* @__PURE__ */ [{
	name: "style",
	parser: /* @__PURE__ */ cssLanguage.parser.configure({ top: "Styles" })
}].concat(/* @__PURE__ */ eventAttributes.map((name) => ({
	name,
	parser: javascriptLanguage.parser
})));
var htmlLanguage = /* @__PURE__ */ LRLanguage.define({
	name: "html",
	parser: /* @__PURE__ */ parser$2.configure({
		props: [/* @__PURE__ */ indentNodeProp.add({
			Element(context) {
				let after = /^(\s*)(<\/)?/.exec(context.textAfter);
				if (context.node.to <= context.pos + after[0].length) return context.continue();
				return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
			},
			"OpenTag CloseTag SelfClosingTag"(context) {
				return context.column(context.node.from) + context.unit;
			},
			Document(context) {
				if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to) return context.continue();
				let endElt = null, close$1;
				for (let cur = context.node;;) {
					let last$2 = cur.lastChild;
					if (!last$2 || last$2.name != "Element" || last$2.to != cur.to) break;
					endElt = cur = last$2;
				}
				if (endElt && !((close$1 = endElt.lastChild) && (close$1.name == "CloseTag" || close$1.name == "SelfClosingTag"))) return context.lineIndent(endElt.from) + context.unit;
				return null;
			}
		}), /* @__PURE__ */ foldNodeProp.add({ Element(node$1) {
			let first = node$1.firstChild, last$2 = node$1.lastChild;
			if (!first || first.name != "OpenTag") return null;
			return {
				from: first.to,
				to: last$2.name == "CloseTag" ? last$2.from : node$1.to
			};
		} })],
		wrap: /* @__PURE__ */ configureNesting(defaultNesting, defaultAttrs)
	}),
	languageData: {
		commentTokens: { block: {
			open: "<!--",
			close: "-->"
		} },
		indentOnInput: /^\s*<\/\w+\W$/,
		wordChars: "-._"
	}
});
function html(config = {}) {
	let dialect$1 = "", wrap$1;
	if (config.matchClosingTags === false) dialect$1 = "noMatch";
	if (config.selfClosingTags === true) dialect$1 = (dialect$1 ? dialect$1 + " " : "") + "selfClosing";
	if (config.nestedLanguages && config.nestedLanguages.length || config.nestedAttributes && config.nestedAttributes.length) wrap$1 = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));
	return new LanguageSupport(wrap$1 || dialect$1 ? htmlLanguage.configure({
		dialect: dialect$1,
		wrap: wrap$1
	}) : htmlLanguage, [
		htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
		config.autoCloseTags !== false ? autoCloseTags : [],
		javascript().support,
		css$1().support
	]);
}
var autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, text$1) => {
	if (view.composing || view.state.readOnly || from != to || text$1 != ">" && text$1 != "/" || !htmlLanguage.isActiveAt(view.state, from, -1)) return false;
	let { state } = view;
	let changes = state.changeByRange((range) => {
		var _a$1, _b, _c;
		let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name;
		if (around.name == "TagName" || around.name == "StartTag") around = around.parent;
		if (text$1 == ">" && around.name == "OpenTag") {
			if (((_b = (_a$1 = around.parent) === null || _a$1 === void 0 ? void 0 : _a$1.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, around.parent, head))) {
				let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
				let insert = `${hasRightBracket ? "" : ">"}</${name}>`;
				return {
					range: EditorSelection.cursor(head + 1),
					changes: {
						from: head + (hasRightBracket ? 1 : 0),
						insert
					}
				};
			}
		} else if (text$1 == "/" && around.name == "OpenTag") {
			let empty$1 = around.parent, base = empty$1 === null || empty$1 === void 0 ? void 0 : empty$1.parent;
			if (empty$1.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
				let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
				let insert = `/${name}${hasRightBracket ? "" : ">"}`;
				let pos = head + insert.length + (hasRightBracket ? 1 : 0);
				return {
					range: EditorSelection.cursor(pos),
					changes: {
						from: head,
						insert
					}
				};
			}
		}
		return { range };
	});
	if (changes.changes.empty) return false;
	view.dispatch(changes, {
		userEvent: "input.type",
		scrollIntoView: true
	});
	return true;
});
function nonTakenRanges(fullRange, takenRanges) {
	const found = [];
	const [fullStart, fullEnd] = fullRange;
	let i = fullStart;
	let curStart = fullStart;
	takenRanges = [...takenRanges];
	while (i < fullEnd) {
		if (takenRanges.length === 0) {
			found.push([curStart, fullEnd]);
			break;
		}
		const [takenStart, takenEnd] = takenRanges[0];
		if (i < takenStart) {
			i++;
			continue;
		}
		if (takenStart !== fullStart) found.push([curStart, i - 1]);
		i = takenEnd + 1;
		curStart = takenEnd + 1;
		takenRanges.shift();
	}
	return found;
}
function pasteHandler(event, view) {
	const htmlData = event.clipboardData?.getData("text/html") ?? "";
	const textData = event.clipboardData?.getData("text/plain") ?? "";
	const content$3 = htmlData || textData;
	if (!content$3) return false;
	if (/onclick=""/.test(content$3)) {
		event.preventDefault();
		const sanitized = content$3.replace(/onclick=""/g, "onclick=\" \"");
		const { from, to } = view.state.selection.main;
		view.dispatch({
			changes: {
				from,
				to,
				insert: sanitized
			},
			scrollIntoView: true
		});
		return true;
	}
	return false;
}
var DraggableTarget_default = /* @__PURE__ */ defineComponent({
	__name: "DraggableTarget",
	props: {
		type: {},
		disabled: {
			type: Boolean,
			default: false
		},
		sticky: {
			type: Boolean,
			default: false
		},
		stickyOffset: { default: () => [0, 0] },
		stickyOrigin: { default: "top-left" }
	},
	emits: ["drop"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const hovering$3 = ref(false);
		const targetRef = ref();
		const id = ref(v4_default());
		const ndvStore = useNDVStore();
		const isDragging = computed(() => ndvStore.isDraggableDragging);
		const draggableType = computed(() => ndvStore.draggableType);
		const draggableDimensions = computed(() => ndvStore.draggable.dimensions);
		const droppable$10 = computed(() => !props.disabled && isDragging.value && draggableType.value === props.type);
		const activeDrop$8 = computed(() => droppable$10.value && hovering$3.value);
		watch(activeDrop$8, (active$2) => {
			if (active$2) {
				const stickyPosition = getStickyPosition();
				ndvStore.setDraggableTarget({
					id: id.value,
					stickyPosition
				});
			} else if (ndvStore.draggable.activeTarget?.id === id.value) ndvStore.setDraggableTarget(null);
		});
		function onMouseEnter() {
			hovering$3.value = true;
		}
		function onMouseLeave() {
			hovering$3.value = false;
		}
		function onMouseUp(event) {
			if (activeDrop$8.value) {
				const data = ndvStore.draggableData;
				emit("drop", data, event);
			}
		}
		function getStickyPosition() {
			if (props.disabled || !props.sticky || !hovering$3.value || !targetRef.value) return null;
			const { left, top, width, height } = targetRef.value.getBoundingClientRect();
			if (props.stickyOrigin === "center") return [left + props.stickyOffset[0] + width / 2 - (draggableDimensions.value?.width ?? 0) / 2, top + props.stickyOffset[1] + height / 2 - (draggableDimensions.value?.height ?? 0) / 2];
			return [left + props.stickyOffset[0], top + props.stickyOffset[1]];
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "targetRef",
				ref: targetRef,
				onMouseenter: onMouseEnter,
				onMouseleave: onMouseLeave,
				onMouseup: onMouseUp
			}, [renderSlot(_ctx.$slots, "default", {
				droppable: droppable$10.value,
				activeDrop: activeDrop$8.value
			})], 544);
		};
	}
});
var HtmlEditor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "HtmlEditor",
	props: {
		modelValue: {},
		rows: { default: 4 },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		fullscreen: {
			type: Boolean,
			default: false
		},
		targetNodeParameterContext: { default: void 0 }
	},
	emits: ["update:model-value"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const htmlEditor = ref();
		const { editor: editorRef, readEditorValue, focus } = useExpressionEditor({
			editorRef: htmlEditor,
			editorValue: () => props.modelValue,
			extensions: computed(() => [
				bracketMatching(),
				n8nAutocompletion(),
				new LanguageSupport(htmlLanguage, [htmlLanguage.data.of({ closeBrackets: expressionCloseBracketsConfig }), n8nCompletionSources().map((source) => htmlLanguage.data.of(source))]),
				autoCloseTags,
				expressionCloseBrackets(),
				pasteSanitizer(),
				Prec.highest(keymap.of(editorKeymap)),
				indentOnInput(),
				codeEditorTheme({
					isReadOnly: props.isReadOnly,
					maxHeight: props.fullscreen ? "100%" : "40vh",
					minHeight: "20vh",
					rows: props.rows
				}),
				lineNumbers(),
				highlightActiveLineGutter(),
				history(),
				foldGutter(),
				dropCursor(),
				indentOnInput(),
				highlightActiveLine(),
				mappingDropCursor(),
				...props.isReadOnly ? [EditorState.readOnly.of(true)] : []
			]),
			targetNodeParameterContext: props.targetNodeParameterContext,
			onChange: () => {
				emit("update:model-value", readEditorValue());
			}
		});
		const sections = computed(() => {
			const editor$5 = toValue(editorRef);
			if (!editor$5) return [];
			const { state } = editor$5;
			const fullTree = ensureSyntaxTree(state, state.doc.length);
			if (fullTree === null) throw new Error("Failed to parse syntax tree");
			let documentRange = [-1, -1];
			const styleRanges = [];
			const scriptRanges = [];
			fullTree.cursor().iterate((node$1) => {
				if (node$1.type.name === "Document") documentRange = [node$1.from, node$1.to];
				if (node$1.type.name === "StyleSheet") styleRanges.push([node$1.from - 7, node$1.to + 8]);
				if (node$1.type.name === "Script") scriptRanges.push([node$1.from - 8, node$1.to + 9]);
			});
			const htmlRanges = nonTakenRanges(documentRange, [...styleRanges, ...scriptRanges]);
			const styleSections = styleRanges.map(([start, end]) => ({
				kind: "style",
				range: [start, end],
				content: state.sliceDoc(start, end).replace(/<\/?style>/g, "")
			}));
			const scriptSections = scriptRanges.map(([start, end]) => ({
				kind: "script",
				range: [start, end],
				content: state.sliceDoc(start, end).replace(/<\/?script>/g, "")
			}));
			const htmlSections = htmlRanges.map(([start, end]) => ({
				kind: "html",
				range: [start, end],
				content: state.sliceDoc(start, end).replace(/<\/html>/g, "")
			}));
			return [
				...styleSections,
				...scriptSections,
				...htmlSections
			].sort((a, b$1) => a.range[0] - b$1.range[0]);
		});
		function isMissingHtmlTags() {
			const zerothSection = sections.value.at(0);
			return !zerothSection?.content.trim().startsWith("<html") && !zerothSection?.content.trim().endsWith("</html>");
		}
		async function formatHtml() {
			const editor$5 = toValue(editorRef);
			if (!editor$5) return;
			const sectionToFormat = sections.value;
			if (sectionToFormat.length === 1 && isMissingHtmlTags()) {
				const formatted$1 = (await gu(sectionToFormat.at(0).content, {
					parser: "html",
					plugins: [Ih]
				})).trim();
				return editor$5.dispatch({ changes: {
					from: 0,
					to: editor$5.state.doc.length,
					insert: formatted$1
				} });
			}
			const formatted = [];
			for (const { kind, content: content$3 } of sections.value) {
				if (kind === "style") {
					const formattedStyle = await gu(content$3, {
						parser: "css",
						plugins: [Ob]
					});
					formatted.push(`<style>\n${formattedStyle}</style>`);
				}
				if (kind === "script") {
					const formattedScript = await gu(content$3, {
						parser: "babel",
						plugins: [Ln, estree_exports]
					});
					formatted.push(`<script>\n${formattedScript}<\/script>`);
				}
				if (kind === "html") {
					const match = content$3.match(/(?<pre>[\s\S]*<html[\s\S]*?>)(?<rest>[\s\S]*)/);
					if (!match?.groups?.pre || !match.groups?.rest) continue;
					const { pre, rest } = match.groups;
					const formattedRest = await gu(rest, {
						parser: "html",
						plugins: [Ih]
					});
					formatted.push(`${pre}\n${formattedRest}</html>`);
				}
			}
			if (formatted.length === 0) return;
			editor$5.dispatch({ changes: {
				from: 0,
				to: editor$5.state.doc.length,
				insert: formatted.join("\n\n")
			} });
		}
		function pasteSanitizer() {
			return EditorView.domEventHandlers({ paste: pasteHandler });
		}
		onMounted(() => {
			htmlEditorEventBus.on("format-html", formatHtml);
		});
		onBeforeUnmount(() => {
			htmlEditorEventBus.off("format-html", formatHtml);
		});
		async function onDrop(value$1, event) {
			if (!editorRef.value) return;
			await dropInExpressionEditor(toRaw(editorRef.value), event, value$1);
		}
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.editor) }, [createVNode(DraggableTarget_default, {
				type: "mapping",
				disabled: _ctx.isReadOnly,
				onDrop
			}, {
				default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createBaseVNode("div", {
					ref_key: "htmlEditor",
					ref: htmlEditor,
					class: normalizeClass([_ctx.$style.fillHeight, {
						[_ctx.$style.activeDrop]: activeDrop$8,
						[_ctx.$style.droppable]: droppable$10
					}]),
					"data-test-id": "html-editor-container"
				}, null, 2)]),
				_: 1
			}, 8, ["disabled"]), renderSlot(_ctx.$slots, "suffix")], 2);
		};
	}
});
var HtmlEditor_vue_vue_type_style_index_0_lang_module_default = {
	editor: "_editor_1x7m4_123",
	fillHeight: "_fillHeight_1x7m4_130",
	droppable: "_droppable_1x7m4_134",
	activeDrop: "_activeDrop_1x7m4_140"
};
var HtmlEditor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(HtmlEditor_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": HtmlEditor_vue_vue_type_style_index_0_lang_module_default }]]);
var JsEditor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "JsEditor",
	props: {
		modelValue: {},
		isReadOnly: {
			type: Boolean,
			default: false
		},
		fillParent: {
			type: Boolean,
			default: false
		},
		rows: { default: 4 },
		posthogCapture: { type: Boolean }
	},
	emits: ["update:modelValue"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		onMounted(() => {
			createEditor();
		});
		watch(() => props.modelValue, (newValue) => {
			const editorValue = editor$5.value?.state?.doc.toString();
			if (editorValue !== void 0 && editorValue.length !== newValue.length && editorValue !== newValue) {
				destroyEditor();
				createEditor();
			}
		});
		function createEditor() {
			const state = EditorState.create({
				doc: props.modelValue,
				extensions: extensions.value
			});
			const parent$2 = jsEditorRef.value;
			editor$5.value = new EditorView({
				parent: parent$2,
				state
			});
			editorState.value = editor$5.value.state;
		}
		function destroyEditor() {
			editor$5.value?.destroy();
		}
		const jsEditorRef = ref();
		const editor$5 = ref(null);
		const editorState = ref(null);
		const generatedCodeCapture = computed(() => {
			return props.posthogCapture ? "" : "ph-no-capture ";
		});
		const extensions = computed(() => {
			const extensionsToApply = [
				javascript(),
				lineNumbers(),
				EditorView.lineWrapping,
				EditorState.readOnly.of(props.isReadOnly),
				codeEditorTheme({
					isReadOnly: props.isReadOnly,
					maxHeight: props.fillParent ? "100%" : "40vh",
					minHeight: "20vh",
					rows: props.rows
				})
			];
			if (!props.isReadOnly) extensionsToApply.push(history(), Prec.highest(keymap.of(editorKeymap)), lintGutter(), n8nAutocompletion(), indentOnInput(), highlightActiveLine(), highlightActiveLineGutter(), foldGutter(), dropCursor(), EditorView.updateListener.of((viewUpdate) => {
				if (!viewUpdate.docChanged || !editor$5.value) return;
				emit("update:modelValue", editor$5.value?.state.doc.toString());
			}));
			return extensionsToApply;
		});
		const focus = () => {
			const view = editor$5.value;
			if (view && typeof view.focus === "function") view.focus();
		};
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.editor),
				style: normalizeStyle(_ctx.isReadOnly ? "opacity: 0.7" : "")
			}, [createBaseVNode("div", {
				ref_key: "jsEditorRef",
				ref: jsEditorRef,
				class: normalizeClass(generatedCodeCapture.value + "js-editor")
			}, null, 2), renderSlot(_ctx.$slots, "suffix")], 6);
		};
	}
});
var JsEditor_vue_vue_type_style_index_0_lang_module_default = { editor: "_editor_ilraf_123" };
var JsEditor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(JsEditor_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": JsEditor_vue_vue_type_style_index_0_lang_module_default }]]);
const typescriptWorkerFacet = Facet.define({ combine(configs) {
	return combineConfig(configs, {});
} });
const blockCommentSnippet = snippetCompletion("/**\n * #{}\n */", {
	label: "/**",
	detail: "Block Comment"
});
const snippets$2 = [
	snippetCompletion("console.log(#{})", {
		label: "log",
		detail: "Log to console"
	}),
	snippetCompletion("for (const #{1:element} of #{2:array}) {\n	#{}\n}", {
		label: "forof",
		detail: "For-of Loop"
	}),
	snippetCompletion("for (const #{1:key} in #{2:object}) {\n	if (Object.prototype.hasOwnProperty.call(#{2:object}, #{1:key})) {\n		const #{3:element} = #{2:object}[#{1:key}];\n		#{}\n	}\n}", {
		label: "forin",
		detail: "For-in Loop"
	}),
	snippetCompletion("for (let #{1:index} = 0; #{1:index} < #{2:array}.length; #{1:index}++) {\n	const #{3:element} = #{2:array}[#{1:index}];\n	#{}\n}", {
		label: "for",
		detail: "For Loop"
	}),
	snippetCompletion("if (#{1:condition}) {\n	#{}\n}", {
		label: "if",
		detail: "If Statement"
	}),
	snippetCompletion("if (#{1:condition}) {\n	#{}\n} else {\n	\n}", {
		label: "ifelse",
		detail: "If-Else Statement"
	}),
	snippetCompletion("function #{1:name}(#{2:params}) {\n	#{}\n}", {
		label: "function",
		detail: "Function Statement"
	}),
	snippetCompletion("function #{1:name}(#{2:params}) {\n	#{}\n}", {
		label: "fn",
		detail: "Function Statement"
	}),
	snippetCompletion("switch (#{1:key}) {\n	case #{2:value}:\n		#{}\n		break;\n	default:\n		break;\n}", {
		label: "switch",
		detail: "Switch Statement"
	}),
	snippetCompletion("try {\n	#{}\n} catch (#{1:error}) {\n	\n}", {
		label: "trycatch",
		detail: "Try-Catch Statement"
	}),
	snippetCompletion("while (#{1:condition}) {\n	#{}\n}", {
		label: "while",
		detail: "While Statement"
	}),
	blockCommentSnippet
];
var START_CHARACTERS = [
	"\"",
	"'",
	"(",
	".",
	"@"
];
var START_CHARACTERS_REGEX = /[\.\(\'\"\@]/;
const matchText = (context) => {
	let word = context.matchBefore(START_CHARACTERS_REGEX);
	if (!word?.text) word = context.matchBefore(/[\$\w]+/);
	if (!word?.text) word = context.matchBefore(/[\"\'].*/);
	return word;
};
const typescriptCompletionSource = async (context) => {
	const { worker } = context.state.facet(typescriptWorkerFacet);
	const targetNodeParameter = context.state.facet(TARGET_NODE_PARAMETER_FACET);
	const word = matchText(context);
	const blockComment = context.matchBefore(/\/\*?\*?/);
	if (blockComment) return {
		from: blockComment?.from,
		options: [blockCommentSnippet]
	};
	if (!word) return null;
	const completionResult = await worker.getCompletionsAtPos(context.pos);
	if (!completionResult || context.aborted) return null;
	const { result, isGlobal } = completionResult;
	let options$1 = [...result.options];
	if (isGlobal) options$1 = options$1.flatMap((opt) => {
		if (opt.label === "$()") return [opt, ...autocompletableNodeNames(targetNodeParameter).map((name) => ({
			...opt,
			label: `$('${escapeMappingString(name)}')`
		}))];
		return opt;
	}).concat(snippets$2);
	return {
		from: word ? START_CHARACTERS.includes(word.text) ? word.to : word.from : context.pos,
		filter: false,
		getMatch(completion) {
			return [0, longestCommonPrefix(completion.label, word.text).length];
		},
		options: options$1.filter((option$1) => word.text === "" || START_CHARACTERS.includes(word.text) || prefixMatch$1(option$1.label.replace(START_CHARACTERS_REGEX, ""), word.text.replace(START_CHARACTERS_REGEX, ""))).map((completion) => {
			if (completion.label.endsWith("()")) completion.apply = (view, _$2, from, to) => {
				const cursorPosition = from + completion.label.length - 1;
				view.dispatch({
					...insertCompletionText(view.state, completion.label, from, to),
					annotations: pickedCompletion$1.of(completion),
					selection: {
						anchor: cursorPosition,
						head: cursorPosition
					}
				});
			};
			return completion;
		})
	};
};
const typescriptHoverTooltips = async (view, pos) => {
	const { worker } = view.state.facet(typescriptWorkerFacet);
	const info = await worker.getHoverTooltip(pos);
	if (!info) return null;
	return {
		pos: info.start,
		end: info.end,
		above: true,
		create: () => {
			const div = document.createElement("div");
			div.classList.add("cm-tooltip-lint");
			const wrapper$3 = document.createElement("div");
			wrapper$3.classList.add("cm-diagnostic");
			div.appendChild(wrapper$3);
			const text$1 = document.createElement("div");
			text$1.classList.add("cm-diagnosticText");
			wrapper$3.appendChild(text$1);
			if (info.quickInfo?.displayParts) for (const part of info.quickInfo.displayParts) {
				const span = text$1.appendChild(document.createElement("span"));
				if (part.kind === "keyword" && [
					"string",
					"number",
					"boolean",
					"object"
				].includes(part.text)) span.className = "ts-primitive";
				else if (part.kind === "punctuation" && ["(", ")"].includes(part.text)) span.className = "ts-text";
				else span.className = `ts-${part.kind}`;
				span.innerText = part.text;
			}
			const documentation = info.quickInfo?.documentation?.find((doc) => doc.kind === "text")?.text;
			if (documentation) {
				const docElement = document.createElement("div");
				docElement.classList.add("cm-diagnosticDocs");
				docElement.textContent = documentation;
				wrapper$3.appendChild(docElement);
			}
			return { dom: div };
		}
	};
};
const typescriptLintSource = async (view) => {
	const { worker } = view.state.facet(typescriptWorkerFacet);
	const docLength = view.state.doc.length;
	return (await worker.getDiagnostics()).filter((diag) => {
		return diag.from < docLength && diag.to <= docLength && diag.from >= 0;
	});
};
function useTypescript(view, mode, id, targetNodeParameterContext) {
	const { getInputDataWithPinned, getSchemaForExecutionData } = useDataSchema();
	const ndvStore = useNDVStore();
	const workflowsStore = useWorkflowsStore();
	const { debounce: debounce$4 } = useDebounce();
	const activeNodeName = toValue(targetNodeParameterContext)?.nodeName ?? ndvStore.activeNodeName;
	const worker = ref();
	const webWorker = ref();
	async function createWorker() {
		webWorker.value = new Worker(new URL(
			/* @vite-ignore */
			"/%7B%7BBASE_PATH%7D%7D/assets/typescript.worker-CkR7RUha.js",
			"" + import.meta.url
		), { type: "module" });
		const { init } = wrap(webWorker.value);
		worker.value = await init({
			id: toValue(id),
			content: proxy((toValue(view)?.state.doc ?? Text.empty).toJSON()),
			allNodeNames: autocompletableNodeNames(toValue(targetNodeParameterContext)),
			variables: environments_store_default().scopedVariables.map((v$1) => v$1.key),
			inputNodeNames: activeNodeName ? workflowsStore.workflowObject.getParentNodes(activeNodeName, NodeConnectionTypes.Main, 1) : [],
			mode: toValue(mode)
		}, proxy(async (nodeName) => {
			const node$1 = workflowsStore.getNodeByName(nodeName);
			if (node$1) {
				const schema$1 = getSchemaForExecutionData(executionDataToJson(getInputDataWithPinned(node$1)), true);
				const execution = workflowsStore.getWorkflowExecution;
				const binaryData = useNodeHelpers().getBinaryData(execution?.data?.resultData?.runData ?? null, node$1.name, toValue(targetNodeParameterContext) === void 0 ? ndvStore.ndvInputRunIndex ?? 0 : 0, 0).filter((data) => Boolean(data && Object.keys(data).length));
				return {
					json: schema$1,
					binary: Object.keys(binaryData.reduce((acc, obj) => ({
						...acc,
						...obj
					}), {})),
					params: getSchemaForExecutionData([node$1.parameters])
				};
			}
		}));
		const editor$5 = toValue(view);
		if (editor$5) forceParse(editor$5);
		return [
			typescriptWorkerFacet.of({ worker: worker.value }),
			TARGET_NODE_PARAMETER_FACET.of(toValue(targetNodeParameterContext)),
			new LanguageSupport(javascriptLanguage, [javascriptLanguage.data.of({ autocomplete: typescriptCompletionSource })]),
			autocompletion({
				icons: false,
				aboveCursor: true
			}),
			linter(typescriptLintSource),
			hoverTooltip(typescriptHoverTooltips, {
				hideOnChange: true,
				hoverTime: 500
			}),
			EditorView.updateListener.of(async (update) => {
				if (update.docChanged) worker.value?.updateFile(update.changes.toJSON());
			})
		];
	}
	async function onWorkflowDataChange() {
		const editor$5 = toValue(view);
		if (!editor$5 || !worker.value) return;
		await worker.value.updateNodeTypes();
		forceParse(editor$5);
	}
	watch([() => workflowsStore.getWorkflowExecution, () => workflowsStore.getWorkflowRunData], debounce$4(onWorkflowDataChange, {
		debounceTime: 200,
		trailing: true
	}));
	watch(toRef(mode), async (newMode) => {
		const editor$5 = toValue(view);
		if (!editor$5 || !worker.value) return;
		await worker.value.updateMode(newMode);
		forceParse(editor$5);
	});
	onBeforeUnmount(() => {
		if (webWorker.value) webWorker.value.terminate();
	});
	return { createWorker };
}
var printKeyword = 1, indent = 196, dedent = 197, newline$1 = 198, blankLineStart = 199, newlineBracketed = 200, eof = 201, formatString1Content = 202, formatString1Brace = 2, formatString1End = 203, formatString2Content = 204, formatString2Brace = 3, formatString2End = 205, formatString1lContent = 206, formatString1lBrace = 4, formatString1lEnd = 207, formatString2lContent = 208, formatString2lBrace = 5, formatString2lEnd = 209, ParenL$1 = 26, ParenthesizedExpression = 27, TupleExpression = 51, ComprehensionExpression = 52, BracketL$1 = 57, ArrayExpression = 58, ArrayComprehensionExpression = 59, BraceL$1 = 61, DictionaryExpression = 62, DictionaryComprehensionExpression = 63, SetExpression = 64, SetComprehensionExpression = 65, ArgList = 67, subscript = 246, FormatString = 74, importList = 265, ParamList = 129, SequencePattern = 150, MappingPattern = 151, PatternArgList = 154;
var newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46, braceOpen = 123, singleQuote = 39, doubleQuote = 34;
var bracketed = new Set([
	ParenthesizedExpression,
	TupleExpression,
	ComprehensionExpression,
	importList,
	ArgList,
	ParamList,
	ArrayExpression,
	ArrayComprehensionExpression,
	subscript,
	SetExpression,
	SetComprehensionExpression,
	FormatString,
	DictionaryExpression,
	DictionaryComprehensionExpression,
	SequencePattern,
	MappingPattern,
	PatternArgList
]);
function isLineBreak(ch) {
	return ch == newline || ch == carriageReturn;
}
var newlines = new ExternalTokenizer((input$5, stack) => {
	if (input$5.next < 0) input$5.acceptToken(eof);
	else if (stack.context.depth < 0) {
		if (isLineBreak(input$5.next)) input$5.acceptToken(newlineBracketed, 1);
	} else if (isLineBreak(input$5.peek(-1)) && stack.canShift(blankLineStart)) {
		let spaces = 0;
		while (input$5.next == space || input$5.next == tab) {
			input$5.advance();
			spaces++;
		}
		if (input$5.next == newline || input$5.next == carriageReturn || input$5.next == hash) input$5.acceptToken(blankLineStart, -spaces);
	} else if (isLineBreak(input$5.next)) input$5.acceptToken(newline$1, 1);
}, { contextual: true });
var indentation = new ExternalTokenizer((input$5, stack) => {
	let cDepth = stack.context.depth;
	if (cDepth < 0) return;
	let prev = input$5.peek(-1);
	if (prev == newline || prev == carriageReturn) {
		let depth = 0, chars = 0;
		for (;;) {
			if (input$5.next == space) depth++;
			else if (input$5.next == tab) depth += 8 - depth % 8;
			else break;
			input$5.advance();
			chars++;
		}
		if (depth != cDepth && input$5.next != newline && input$5.next != carriageReturn && input$5.next != hash) if (depth < cDepth) input$5.acceptToken(dedent, -chars);
		else input$5.acceptToken(indent);
	}
});
function IndentLevel(parent$2, depth) {
	this.parent = parent$2;
	this.depth = depth;
	this.hash = (parent$2 ? parent$2.hash + parent$2.hash << 8 : 0) + depth + (depth << 4);
}
var topIndent = new IndentLevel(null, 0);
function countIndent(space$2) {
	let depth = 0;
	for (let i = 0; i < space$2.length; i++) depth += space$2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
	return depth;
}
var trackIndent = new ContextTracker({
	start: topIndent,
	reduce(context, term) {
		return context.depth < 0 && bracketed.has(term) ? context.parent : context;
	},
	shift(context, term, stack, input$5) {
		if (term == indent) return new IndentLevel(context, countIndent(input$5.read(input$5.pos, stack.pos)));
		if (term == dedent) return context.parent;
		if (term == ParenL$1 || term == BracketL$1 || term == BraceL$1) return new IndentLevel(context, -1);
		return context;
	},
	hash(context) {
		return context.hash;
	}
});
var legacyPrint = new ExternalTokenizer((input$5) => {
	for (let i = 0; i < 5; i++) {
		if (input$5.next != "print".charCodeAt(i)) return;
		input$5.advance();
	}
	if (/\w/.test(String.fromCharCode(input$5.next))) return;
	for (let off$1 = 0;; off$1++) {
		let next = input$5.peek(off$1);
		if (next == space || next == tab) continue;
		if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash) input$5.acceptToken(printKeyword);
		return;
	}
});
function formatString(quote, len, content$3, brace, end) {
	return new ExternalTokenizer((input$5) => {
		let start = input$5.pos;
		for (;;) if (input$5.next < 0) break;
		else if (input$5.next == braceOpen) if (input$5.peek(1) == braceOpen) input$5.advance(2);
		else {
			if (input$5.pos == start) {
				input$5.acceptToken(brace, 1);
				return;
			}
			break;
		}
		else if (input$5.next == "\\") {
			input$5.advance();
			if (input$5.next >= 0) input$5.advance();
		} else if (input$5.next == quote && (len == 1 || input$5.peek(1) == quote && input$5.peek(2) == quote)) {
			if (input$5.pos == start) {
				input$5.acceptToken(end, len);
				return;
			}
			break;
		} else input$5.advance();
		if (input$5.pos > start) input$5.acceptToken(content$3);
	});
}
var formatString1 = formatString(singleQuote, 1, formatString1Content, formatString1Brace, formatString1End);
var formatString2 = formatString(doubleQuote, 1, formatString2Content, formatString2Brace, formatString2End);
var formatString1l = formatString(singleQuote, 3, formatString1lContent, formatString1lBrace, formatString1lEnd);
var formatString2l = formatString(doubleQuote, 3, formatString2lContent, formatString2lBrace, formatString2lEnd);
var pythonHighlighting = styleTags({
	"async \"*\" \"**\" FormatConversion FormatSpec": tags.modifier,
	"for while if elif else try except finally return raise break continue with pass assert await yield match case": tags.controlKeyword,
	"in not and or is del": tags.operatorKeyword,
	"from def class global nonlocal lambda": tags.definitionKeyword,
	import: tags.moduleKeyword,
	"with as print": tags.keyword,
	Boolean: tags.bool,
	None: tags.null,
	VariableName: tags.variableName,
	"CallExpression/VariableName": tags.function(tags.variableName),
	"FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
	"ClassDefinition/VariableName": tags.definition(tags.className),
	PropertyName: tags.propertyName,
	"CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
	Comment: tags.lineComment,
	Number: tags.number,
	String: tags.string,
	FormatString: tags.special(tags.string),
	UpdateOp: tags.updateOperator,
	"ArithOp!": tags.arithmeticOperator,
	BitOp: tags.bitwiseOperator,
	CompareOp: tags.compareOperator,
	AssignOp: tags.definitionOperator,
	Ellipsis: tags.punctuation,
	At: tags.meta,
	"( )": tags.paren,
	"[ ]": tags.squareBracket,
	"{ }": tags.brace,
	".": tags.derefOperator,
	", ;": tags.separator
});
var spec_identifier = {
	__proto__: null,
	await: 48,
	or: 58,
	and: 60,
	in: 64,
	not: 66,
	is: 68,
	if: 74,
	else: 76,
	lambda: 80,
	yield: 98,
	from: 100,
	async: 106,
	for: 108,
	None: 168,
	True: 170,
	False: 170,
	del: 184,
	pass: 188,
	break: 192,
	continue: 196,
	return: 200,
	raise: 208,
	import: 212,
	as: 214,
	global: 218,
	nonlocal: 220,
	assert: 224,
	elif: 234,
	while: 238,
	try: 244,
	except: 246,
	finally: 248,
	with: 252,
	def: 256,
	class: 266,
	match: 277,
	case: 283
};
var parser$1 = LRParser.deserialize({
	version: 14,
	states: "#!OO`Q#yOOP$_OSOOO%hQ&nO'#H^OOQS'#Cq'#CqOOQS'#Cr'#CrO'WQ#xO'#CpO(yQ&nO'#H]OOQS'#H^'#H^OOQS'#DW'#DWOOQS'#H]'#H]O)gQ#xO'#DaO)zQ#xO'#DhO*[Q#xO'#DlOOQS'#Dw'#DwO*oO,UO'#DwO*wO7[O'#DwO+POWO'#DxO+[O`O'#DxO+gOpO'#DxO+rO!bO'#DxO-tQ&nO'#G}OOQS'#G}'#G}O'WQ#xO'#G|O/WQ&nO'#G|OOQS'#Ee'#EeO/oQ#xO'#EfOOQS'#G{'#G{O/yQ#xO'#GzOOQV'#Gz'#GzO0UQ#xO'#FXOOQS'#G`'#G`O0ZQ#xO'#FWOOQV'#IS'#ISOOQV'#Gy'#GyOOQV'#Fp'#FpQ`Q#yOOO'WQ#xO'#CsO0iQ#xO'#DPO0pQ#xO'#DTO1OQ#xO'#HbO1`Q&nO'#EYO'WQ#xO'#EZOOQS'#E]'#E]OOQS'#E_'#E_OOQS'#Ea'#EaO1tQ#xO'#EcO2[Q#xO'#EgO0UQ#xO'#EiO2oQ&nO'#EiO0UQ#xO'#ElO/oQ#xO'#EoO/oQ#xO'#EsO/oQ#xO'#EvO2zQ#xO'#ExO3RQ#xO'#E}O3^Q#xO'#EyO/oQ#xO'#E}O0UQ#xO'#FPO0UQ#xO'#FUO3cQ#xO'#FZP3jO#xO'#GxPOOO)CBl)CBlOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO3uQ#xO'#DqOOQS,5:[,5:[O4YQ#xO'#HlOOQS,5:_,5:_O4gQMlO,5:_O4lQ&nO,59[O0iQ#xO,59dO0iQ#xO,59dO0iQ#xO,59dO7[Q#xO,59dO7aQ#xO,59dO7hQ#xO,59lO7oQ#xO'#H]O8uQ#xO'#H[OOQS'#H['#H[OOQS'#D^'#D^O9^Q#xO,59cO'WQ#xO,59cO9lQ#xO,59cOOQS,59{,59{O9qQ#xO,5:TO'WQ#xO,5:TOOQS,5:S,5:SO:PQ#xO,5:SO:UQ#xO,5:ZO'WQ#xO,5:ZO'WQ#xO,5:XOOQS,5:W,5:WO:gQ#xO,5:WO:lQ#xO,5:YOOOO'#Fx'#FxO:qO,UO,5:cOOQS,5:c,5:cOOOO'#Fy'#FyO:yO7[O,5:cO;RQ#xO'#DyOOOW'#Fz'#FzO;cOWO,5:dOOQS,5:d,5:dO;RQ#xO'#D}OOO`'#F}'#F}O;nO`O,5:dO;RQ#xO'#EOOOOp'#GO'#GOO;yOpO,5:dO;RQ#xO'#EPOOO!b'#GP'#GPO<UO!bO,5:dOOQS'#GQ'#GQO<aQ&nO,5:lO?RQ&nO,5=hO?lQ!LUO,5=hO@]Q&nO,5=hOOQS,5;Q,5;QO@tQ#yO'#GYOBTQ#xO,5;]OOQV,5=f,5=fOB`Q&nO'#IOOBwQ#xO,5;sOOQS-E:^-E:^OOQV,5;r,5;rO3XQ#xO'#FPOOQV-E9n-E9nOCPQ&nO,59_OEWQ&nO,59kOEqQ#xO'#H_OE|Q#xO'#H_O0UQ#xO'#H_OFXQ#xO'#DVOFaQ#xO,59oOFfQ#xO'#HcO'WQ#xO'#HcO/oQ#xO,5=|OOQS,5=|,5=|O/oQ#xO'#EUOOQS'#EV'#EVOGTQ#xO'#GSOGeQ#xO,59OOGeQ#xO,59OO)mQ#xO,5:rOGsQ&nO'#HeOOQS,5:u,5:uOOQS,5:},5:}OHWQ#xO,5;ROHiQ#xO,5;TOOQS'#GV'#GVOHwQ&nO,5;TOIVQ#xO,5;TOI[Q#xO'#IROOQS,5;W,5;WOIjQ#xO'#H}OOQS,5;Z,5;ZO3^Q#xO,5;_O3^Q#xO,5;bOI{Q&nO'#ITO'WQ#xO'#ITOJVQ#xO,5;dO2zQ#xO,5;dO/oQ#xO,5;iO0UQ#xO,5;kOJ[Q#yO'#EtOKeQ#{O,5;eONvQ#xO'#IUO3^Q#xO,5;iO! RQ#xO,5;kO! WQ#xO,5;pO! `Q&nO,5;uO'WQ#xO,5;uPOOO,5=d,5=dP! gOSO,5=dP! lO#xO,5=dO!$aQ&nO1G.lO!$hQ&nO1G.lO!'XQ&nO1G.lO!'cQ&nO1G.lO!)|Q&nO1G.lO!*aQ&nO1G.lO!*tQ#xO'#HkO!+SQ&nO'#G}O/oQ#xO'#HkO!+^Q#xO'#HjOOQS,5:],5:]O!+fQ#xO,5:]O!+kQ#xO'#HmO!+vQ#xO'#HmO!,ZQ#xO,5>WOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-ZQ&nO1G/OO!-bQ&nO1G/OO0iQ#xO1G/OO!-}Q#xO1G/WOOQS'#D]'#D]O/oQ#xO,59vOOQS1G.}1G.}O!.UQ#xO1G/gO!.fQ#xO1G/gO!.nQ#xO1G/hO'WQ#xO'#HdO!.sQ#xO'#HdO!.xQ&nO1G.}O!/YQ#xO,59kO!0`Q#xO,5>SO!0pQ#xO,5>SO!0xQ#xO1G/oO!0}Q&nO1G/oOOQS1G/n1G/nO!1_Q#xO,5=}O!2UQ#xO,5=}O/oQ#xO1G/sO!2sQ#xO1G/uO!2xQ&nO1G/uO!3YQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E9v-E9vOOQS1G/}1G/}OOOO-E9w-E9wO!3jQ#xO'#HwO/oQ#xO'#HwO!3xQ#xO,5:eOOOW-E9x-E9xOOQS1G0O1G0OO!4TQ#xO,5:iOOO`-E9{-E9{O!4`Q#xO,5:jOOOp-E9|-E9|O!4kQ#xO,5:kOOO!b-E9}-E9}OOQS-E:O-E:OO!4vQ!LUO1G3SO!5gQ&nO1G3SO'WQ#xO,5<mOOQS,5<m,5<mOOQS-E:P-E:POOQS,5<t,5<tOOQS-E:W-E:WOOQV1G0w1G0wO0UQ#xO'#GUO!6OQ&nO,5>jOOQS1G1_1G1_O!6gQ#xO1G1_OOQS'#DX'#DXO/oQ#xO,5=yOOQS,5=y,5=yO!6lQ#xO'#FqO!6wQ#xO,59qO!7PQ#xO1G/ZO!7ZQ&nO,5=}OOQS1G3h1G3hOOQS,5:p,5:pO!7zQ#xO'#G|OOQS,5<n,5<nOOQS-E:Q-E:QO!8]Q#xO1G.jOOQS1G0^1G0^O!8kQ#xO,5>PO!8{Q#xO,5>PO/oQ#xO1G0mO/oQ#xO1G0mO0UQ#xO1G0oOOQS-E:T-E:TO!9^Q#xO1G0oO!9iQ#xO1G0oO!9nQ#xO,5>mO!9|Q#xO,5>mO!:[Q#xO,5>iO!:rQ#xO,5>iO!;TQ#{O1G0yO!>cQ#{O1G0|O!AnQ#xO,5>oO!AxQ#xO,5>oO!BQQ&nO,5>oO/oQ#xO1G1OO!B[Q#xO1G1OO3^Q#xO1G1TO! RQ#xO1G1VOOQV,5;`,5;`O!BaQ#zO,5;`O!BfQ#{O1G1PO!EwQ#xO'#G]O3^Q#xO1G1PO3^Q#xO1G1PO!FUQ#xO,5>pO!FcQ#xO,5>pO0UQ#xO,5>pOOQV1G1T1G1TO!FkQ#xO'#FRO!F|QMlO1G1VOOQV1G1[1G1[O3^Q#xO1G1[O!GUQ#xO'#F]OOQV1G1a1G1aO! `Q&nO1G1aPOOO1G3O1G3OP!GZOSO1G3OOOQS,5>V,5>VOOQS'#Dr'#DrO/oQ#xO,5>VO!G`Q#xO,5>UO!GsQ#xO,5>UOOQS1G/w1G/wO!G{Q#xO,5>XO!H]Q#xO,5>XO!HeQ#xO,5>XO!HxQ#xO,5>XO!IYQ#xO,5>XOOQS1G3r1G3rOOQS7+$j7+$jO!7PQ#xO7+$rO!J{Q#xO1G/OO!KSQ#xO1G/OOOQS1G/b1G/bOOQS,5<_,5<_O'WQ#xO,5<_OOQS7+%R7+%RO!KZQ#xO7+%ROOQS-E9q-E9qOOQS7+%S7+%SO!KkQ#xO,5>OO'WQ#xO,5>OOOQS7+$i7+$iO!KpQ#xO7+%RO!KxQ#xO7+%SO!K}Q#xO1G3nOOQS7+%Z7+%ZO!L_Q#xO1G3nO!LgQ#xO7+%ZOOQS,5<^,5<^O'WQ#xO,5<^O!LlQ#xO1G3iOOQS-E9p-E9pO!McQ#xO7+%_OOQS7+%a7+%aO!MqQ#xO1G3iO!N`Q#xO7+%aO!NeQ#xO1G3oO!NuQ#xO1G3oO!N}Q#xO7+%_O# SQ#xO,5>cO# jQ#xO,5>cO# jQ#xO,5>cO# xO$ISO'#D{O#!TO#tO'#HxOOOW1G0P1G0PO#!YQ#xO1G0POOO`1G0T1G0TO#!bQ#xO1G0TOOOp1G0U1G0UO#!jQ#xO1G0UOOO!b1G0V1G0VO#!rQ#xO1G0VO#!zQ!LUO7+(nO##kQ&nO1G2XP#$UQ#xO'#GROOQS,5<p,5<pOOQS-E:S-E:SOOQS7+&y7+&yOOQS1G3e1G3eOOQS,5<],5<]OOQS-E9o-E9oOOQS7+$u7+$uO#$cQ#xO,5=hO#$|Q#xO,5=hO#%_Q&nO,5<`O#%rQ#xO1G3kOOQS-E9r-E9rOOQS7+&X7+&XO#&SQ#xO7+&XOOQS7+&Z7+&ZO#&bQ#xO'#IQO0UQ#xO'#IPO#&vQ#xO7+&ZOOQS,5<s,5<sO#'RQ#xO1G4XOOQS-E:V-E:VOOQS,5<o,5<oO#'aQ#xO1G4TOOQS-E:R-E:RO#'wQ#{O7+&eO!EwQ#xO'#GZO3^Q#xO7+&eO3^Q#xO7+&hO#+VQ&nO,5<vO'WQ#xO,5<vO#+aQ#xO1G4ZOOQS-E:Y-E:YO#+kQ#xO1G4ZO3^Q#xO7+&jO/oQ#xO7+&jOOQV7+&o7+&oO!F|QMlO7+&qO`Q#yO1G0zOOQV-E:Z-E:ZO3^Q#xO7+&kO3^Q#xO7+&kOOQV,5<w,5<wO#+sQ#xO,5<wOOQV7+&k7+&kO#,OQ#{O7+&kO#/ZQ#xO,5<xO#/fQ#xO1G4[OOQS-E:[-E:[O#/sQ#xO1G4[O#/{Q#xO'#IWO#0ZQ#xO'#IWO0UQ#xO'#IWOOQS'#IW'#IWO#0fQ#xO'#IVOOQS,5;m,5;mO#0nQ#xO,5;mO/oQ#xO'#FTOOQV7+&q7+&qO3^Q#xO7+&qOOQV7+&v7+&vO#0sQ#zO,5;wOOQV7+&{7+&{POOO7+(j7+(jOOQS1G3q1G3qOOQS,5<b,5<bO#0xQ#xO1G3pOOQS-E9t-E9tO#1]Q#xO,5<cO#1hQ#xO,5<cO#1{Q#xO1G3sOOQS-E9u-E9uO#2]Q#xO1G3sO#2eQ#xO1G3sO#2uQ#xO1G3sO#2]Q#xO1G3sOOQS<<H^<<H^O#3QQ&nO1G1yOOQS<<Hm<<HmP#3_Q#xO'#FsO7hQ#xO1G3jO#3lQ#xO1G3jO#3qQ#xO<<HmOOQS<<Hn<<HnO#4RQ#xO7+)YOOQS<<Hu<<HuO#4cQ&nO1G1xP#5SQ#xO'#FrO#5aQ#xO7+)ZO#5qQ#xO7+)ZO#5yQ#xO<<HyO#6OQ#xO7+)TOOQS<<H{<<H{O#6uQ#xO,5<aO'WQ#xO,5<aOOQS-E9s-E9sOOQS<<Hy<<HyOOQS,5<g,5<gO/oQ#xO,5<gO#6zQ#xO1G3}OOQS-E9y-E9yO#7bQ#xO1G3}O;RQ#xO'#D|OOOO'#F|'#F|O#7pO$ISO,5:gOOO#l,5>d,5>dOOOW7+%k7+%kOOO`7+%o7+%oOOOp7+%p7+%pOOO!b7+%q7+%qO#7{Q#xO1G3SO#8fQ#xO1G3SP'WQ#xO'#FtO/oQ#xO<<IsO#8wQ#xO,5>lO#9YQ#xO,5>lO0UQ#xO,5>lO#9kQ#xO,5>kOOQS<<Iu<<IuP0UQ#xO'#GXP/oQ#xO'#GTOOQV-E:X-E:XO3^Q#xO<<JPOOQV,5<u,5<uO3^Q#xO,5<uOOQV<<JP<<JPOOQV<<JS<<JSO#9pQ&nO1G2bP#9zQ#xO'#G[O#:RQ#xO7+)uO#:]Q#{O<<JUO3^Q#xO<<JUOOQV<<J]<<J]O3^Q#xO<<J]O#=hQ#{O7+&fOOQV<<JV<<JVO#=rQ#{O<<JVOOQV1G2c1G2cO0UQ#xO1G2cO3^Q#xO<<JVO0UQ#xO1G2dP/oQ#xO'#G^O#@}Q#xO7+)vO#A[Q#xO7+)vOOQS'#FS'#FSO/oQ#xO,5>rO#AdQ#xO,5>rOOQS,5>r,5>rO#AoQ#xO,5>qO#BQQ#xO,5>qOOQS1G1X1G1XOOQS,5;o,5;oO#BYQ#xO1G1cP#B_Q#xO'#FvO#BoQ#xO1G1}O#CSQ#xO1G1}O#CdQ#xO1G1}P#CoQ#xO'#FwO#C|Q#xO7+)_O#D^Q#xO7+)_O#D^Q#xO7+)_O#DfQ#xO7+)_O#DvQ#xO7+)UO7hQ#xO7+)UOOQSAN>XAN>XO#EaQ#xO<<LuOOQSAN>eAN>eO/oQ#xO1G1{O#EqQ&nO1G1{P#E{Q#xO'#FuOOQS1G2R1G2RP#FYQ#xO'#F{O#FgQ#xO7+)iO#F}Q#xO,5:hOOOO-E9z-E9zO#GYQ#xO7+(nOOQSAN?_AN?_O#GsQ#xO,5<rO#HXQ#xO1G4WOOQS-E:U-E:UO#HjQ#xO1G4WOOQS1G4V1G4VOOQVAN?kAN?kOOQV1G2a1G2aO3^Q#xOAN?pO#H{Q#{OAN?pOOQVAN?wAN?wOOQV<<JQ<<JQO3^Q#xOAN?qO3^Q#xO7+'}OOQVAN?qAN?qOOQS7+(O7+(OO#LWQ#xO<<MbOOQS1G4^1G4^O/oQ#xO1G4^OOQS,5<y,5<yO#LeQ#xO1G4]OOQS-E:]-E:]OOQU'#Ga'#GaO#LvQ#zO7+&}O#MRQ#xO'#F^O#MyQ#xO7+'iO#NZQ#xO7+'iOOQS7+'i7+'iO#NfQ#xO<<LyO#NvQ#xO<<LyO#NvQ#xO<<LyO$ OQ#xO'#HfOOQS<<Lp<<LpO$ YQ#xO<<LpOOQS7+'g7+'gOOOO1G0S1G0SO$ sQ#xO1G0SO0UQ#xO1G2^P0UQ#xO'#GWO$ {Q#xO7+)rO$!^Q#xO7+)rOOQVG25[G25[O3^Q#xOG25[OOQVG25]G25]OOQV<<Ki<<KiOOQS7+)x7+)xP$!oQ#xO'#G_OOQU-E:_-E:_OOQV<<Ji<<JiO$#cQ&nO'#F`OOQS'#Fb'#FbO$#sQ#xO'#FaO$$eQ#xO'#FaOOQS'#Fa'#FaO$$jQ#xO'#IYO#MRQ#xO'#FhO#MRQ#xO'#FhO$%RQ#xO'#FiO#MRQ#xO'#FjO$%YQ#xO'#IZOOQS'#IZ'#IZO$%wQ#xO,5;xOOQS<<KT<<KTO$&PQ#xO<<KTO$&aQ#xOANBeO$&qQ#xOANBeO$&yQ#xO'#HgOOQS'#Hg'#HgO0pQ#xO'#DeO$'dQ#xO,5>QOOQSANB[ANB[OOOO7+%n7+%nOOQS7+'x7+'xO$'{Q#xO<<M^OOQVLD*vLD*vO4gQMlO'#GcO$(^Q&nO,5<RO#MRQ#xO'#FlOOQS,5<V,5<VOOQS'#Fc'#FcO$)OQ#xO,5;{O$)TQ#xO,5;{OOQS'#Ff'#FfO#MRQ#xO'#GbO$)uQ#xO,5<PO$*aQ#xO,5>tO$*qQ#xO,5>tO0UQ#xO,5<OO$+SQ#xO,5<SO$+XQ#xO,5<SO#MRQ#xO'#I[O$+^Q#xO'#I[O$+cQ#xO,5<TOOQS,5<U,5<UO'WQ#xO'#FoOOQU1G1d1G1dO3^Q#xO1G1dOOQSAN@oAN@oO$+hQ#xOG28PO$+xQ#xO,5:POOQS1G3l1G3lOOQS,5<},5<}OOQS-E:a-E:aO$+}Q&nO'#F`O$,UQ#xO'#I]O$,dQ#xO'#I]O$,lQ#xO,5<WOOQS1G1g1G1gO$,qQ#xO1G1gO$,vQ#xO,5<|OOQS-E:`-E:`O$-bQ#xO,5=QO$-yQ#xO1G4`OOQS-E:d-E:dOOQS1G1j1G1jOOQS1G1n1G1nO$.ZQ#xO,5>vO#MRQ#xO,5>vOOQS1G1o1G1oO$.iQ&nO,5<ZOOQU7+'O7+'OO$ OQ#xO1G/kO#MRQ#xO,5<XO$.pQ#xO,5>wO$.wQ#xO,5>wOOQS1G1r1G1rOOQS7+'R7+'RP#MRQ#xO'#GfO$/PQ#xO1G4bO$/ZQ#xO1G4bO$/cQ#xO1G4bOOQS7+%V7+%VO$/qQ#xO1G1sO$0PQ&nO'#F`O$0WQ#xO,5=POOQS,5=P,5=PO$0fQ#xO1G4cOOQS-E:c-E:cO#MRQ#xO,5=OO$0mQ#xO,5=OO$0rQ#xO7+)|OOQS-E:b-E:bO$0|Q#xO7+)|O#MRQ#xO,5<YP#MRQ#xO'#GeO$1UQ#xO1G2jO#MRQ#xO1G2jP$1dQ#xO'#GdO$1kQ#xO<<MhO$1uQ#xO1G1tO$2TQ#xO7+(UO7hQ#xO'#DPO7hQ#xO,59dO7hQ#xO,59dO7hQ#xO,59dO$2cQ&nO,5=hO7hQ#xO1G/OO/oQ#xO1G/ZO/oQ#xO7+$rP$2vQ#xO'#GRO'WQ#xO'#G|O$3TQ#xO,59dO$3YQ#xO,59dO$3aQ#xO,59oO$3fQ#xO1G/WO0pQ#xO'#DTO7hQ#xO,59l",
	stateData: "$3w~O%kOS%`OSUOS%_PQ~OPiOXfOhtOjYOquOu!TOxvO!RwO!S!QO!V!WO!W!VO!ZZO!_[O!jeO!ueO!veO!weO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#k!UO#n!XO#r!YO#t!ZO#y![O#|mO$O!]O%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O%_!^O~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%r!`O%s!aO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eO~Om&QXn&QXo&QXp&QXq&QXr&QXu&QX|&QX}&QX!{&QX#f&QX%^&QX%a&QX&S&QXi&QX!V&QX!W&QX&T&QX!Y&QX!^&QX!S&QX#_&QXv&QX!n&QX~P$dOhtOjYO!ZZO!_[O!jeO!ueO!veO!weO%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O|&PX}&PX#f&PX%^&PX%a&PX&S&PX~Om!tOn!uOo!sOp!sOq!vOr!wOu!xO!{&PX~P(eOX#OOi#QOq0VOx0eO!RwO~P'WOX#SOq0VOx0eO!Y#TO~P'WOX#WOc#XOq0VOx0eO!^#YO~P'WO&e#]O&f#_O~O&h#`O&i#_O~OQ#bO%b#cO%c#eO~OR#fO%d#gO%e#eO~OS#iO%f#jO%g#eO~OT#lO%h#mO%i#eO~OX%qXa%qXc%qXj%qXm%qXn%qXo%qXp%qXq%qXr%qXu%qX|%qX!Z%qX!h%qX%r%qX%s%qX%t%qX%u%qX%v%qX%w%qX%x%qX%y%qX%z%qX%{%qXi%qX!V%qX!W%qX~O&c]O&d^O&g_O&j`O&naO&obO&pcO}%qX!{%qX#f%qX%^%qX%a%qX&S%qX&T%qX!Y%qX!^%qX!S%qX#_%qXv%qX!n%qX~P+}O|#rO}%pX!{%pX#f%pX%^%pX%a%pX&S%pX~Oq0VOx0eO~P'WO#f#uO%^#wO%a#wO~O%}WO~O!V#|O#t!ZO#y![O#|mO~OquO~P'WOX$ROc$SO%}WO}yP~OX$WOq0VOx0eO!S$XO~P'WO}$ZO!{$`O&S$[O#f!|X%^!|X%a!|X~OX$WOq0VOx0eO#f#VX%^#VX%a#VX~P'WOq0VOx0eO#f#ZX%^#ZX%a#ZX~P'WO!h$fO!u$fO%}WO~OX$pO~P'WO!W$rO#r$sO#t$tO~O}$uO~OX$|O~P'WOU%OO%^$}O%k%PO~OX%YOc%YOi%[Oq0VOx0eO~P'WOq0VOx0eO}%_O~P'WO&b%aO~Oc!fOj!mO!Z!oO!h!qOXdaadamdandaodapdaqdardauda|da}da!{da#fda%^da%ada%rda%sda%tda%uda%vda%wda%xda%yda%zda%{da&Sdaida!Vda!Wda&Tda!Yda!^da!Sda#_davda!nda~Op%fO~Oq%fO~P'WOq0VO~P'WOm0XOn0YOo0WOp0WOq0aOr0bOu0fOi&PX!V&PX!W&PX&T&PX!Y&PX!^&PX!S&PX#_&PX!n&PX~P(eO&T%hOi&OX|&OX!V&OX!W&OX!Y&OX}&OX~Oi%jO|%kO!V%oO!W%nO~Oi%jO~O|%rO!V%oO!W%nO!Y&[X~O!Y%vO~O|%wO}%yO!V%oO!W%nO!^&VX~O!^%}O~O!^&OO~O&e#]O&f&QO~O&h#`O&i&QO~OX&TOq0VOx0eO!RwO~P'WOQ#bO%b#cO%c&WO~OR#fO%d#gO%e&WO~OS#iO%f#jO%g&WO~OT#lO%h#mO%i&WO~OX!taa!tac!taj!tam!tan!tao!tap!taq!tar!tau!ta|!ta}!ta!Z!ta!h!ta!{!ta#f!ta%^!ta%a!ta%r!ta%s!ta%t!ta%u!ta%v!ta%w!ta%x!ta%y!ta%z!ta%{!ta&S!tai!ta!V!ta!W!ta&T!ta!Y!ta!^!ta!S!ta#_!tav!ta!n!ta~P#vO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P$dOX&bOquOxvO}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P'WO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f$|X%^$|X%a$|X~P'WO#f#uO%^&gO%a&gO~O!h&hOj&rX%^&rX#_&rX#f&rX%a&rX#^&rX~Oj!mO%^&jO~Omgangaogapgaqgargauga|ga}ga!{ga#fga%^ga%aga&Sgaiga!Vga!Wga&Tga!Yga!^ga!Sga#_gavga!nga~P$dOusa|sa}sa#fsa%^sa%asa&Ssa~Om!tOn!uOo!sOp!sOq!vOr!wO!{sa~PDoO&S&lO|&RX}&RX~O%}WO|&RX}&RX~O|&oO}yX~O}&qO~O|%wO#f&VX%^&VX%a&VXi&VX}&VX!^&VX!n&VX&S&VX~OX0`Oq0VOx0eO!RwO~P'WO&S$[O#fWa%^Wa%aWa~O|&zO#f&XX%^&XX%a&XXp&XX~P$dO|&}O!S&|O#f#Za%^#Za%a#Za~O#_'OO#f#]a%^#]a%a#]a~O!h$fO!u$fO#^'QO%}WO~O#^'QO~O|'SO#f&uX%^&uX%a&uX~O|'UO#f&qX%^&qX%a&qX}&qX~O|'YOp&wX~P$dOp']O~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO%^'bO~P'WOv'fO#o'dO#p'eOP#maX#mah#maj#maq#mau#max#ma!R#ma!S#ma!V#ma!W#ma!Z#ma!_#ma!j#ma!u#ma!v#ma!w#ma#O#ma#Q#ma#S#ma#U#ma#W#ma#[#ma#^#ma#a#ma#b#ma#d#ma#k#ma#n#ma#r#ma#t#ma#y#ma#|#ma$O#ma%Z#ma%w#ma%x#ma%|#ma%}#ma&c#ma&d#ma&g#ma&j#ma&n#ma&o#ma&p#ma%]#ma%a#ma~O|'gO#_'iO}&xX~Oj'kO~Oj!mO}$uO~O}'oO~P$dO%^'rO~OU'sO%^'rO~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%s!aO~P! tO%sYi~P! tOX!eOa!eOc!fOj!mO!Z!oO!h!qO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%u!cO%v!cO~P!$oO%uYi%vYi~P!$oOc!fOj!mO!Z!oO!h!qOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi%uYi%vYi%wYi%xYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~OX!eOa!eO%y!eO%z!eO%{!eO~P!'mOXYiaYi%yYi%zYi%{Yi~P!'mO!V%oO!W%nOi&_X|&_X~O&S'uO&T'uO~P+}O|'wOi&^X~Oi'yO~O|'zO}'|O!Y&aX~Oq0VOx0eO|'zO}'}O!Y&aX~P'WO!Y(PO~Oo!sOp!sOq!vOr!wOmliuli|li}li!{li#fli%^li%ali&Sli~On!uO~P!,`Onli~P!,`Om0XOn0YOo0WOp0WOq0aOr0bO~Ov(RO~P!-iOX(WOi(XOq0VOx0eO~P'WOi(XO|(YO~Oi([O~O!W(^O~Oi(_O|(YO!V%oO!W%nO~P$dOm0XOn0YOo0WOp0WOq0aOr0bOisa!Vsa!Wsa&Tsa!Ysa!^sa!Ssa#_savsa!nsa~PDoOX(WOq0VOx0eO!Y&[a~P'WO|(bO!Y&[a~O!Y(cO~O|(bO!V%oO!W%nO!Y&[a~P$dOX(gOq0VOx0eO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~P'WO|(hO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~O!^(kO~O|(hO!V%oO!W%nO!^&Va~P$dO|(nO!V%oO!W%nO!^&]a~P$dO|(qO}&kX!^&kX!n&kX~O}(tO!^(vO!n(wO~O}(tO!^(xO!n(yO~O}(tO!^(zO!n({O~O}(tO!^(|O!n(}O~OX&bOquOxvO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~P'WO|)OO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~O!h&hOj&ra%^&ra#_&ra#f&ra%a&ra#^&ra~O%^)TO~OX$ROc$SO%}WO~O|&oO}ya~OquOxvO~P'WO|(hO#f&Va%^&Va%a&Vai&Va}&Va!^&Va!n&Va&S&Va~P$dO|)YO#f%pX%^%pX%a%pX&S%pX~O&S$[O#fWi%^Wi%aWi~O#f&Xa%^&Xa%a&Xap&Xa~P'WO|)]O#f&Xa%^&Xa%a&Xap&Xa~OX)aOj)cO%}WO~O#^)dO~O%}WO#f&ua%^&ua%a&ua~O|)fO#f&ua%^&ua%a&ua~Oq0VOx0eO#f&qa%^&qa%a&qa}&qa~P'WO|)iO#f&qa%^&qa%a&qa}&qa~Ov)mO#i)lOP#giX#gih#gij#giq#giu#gix#gi!R#gi!S#gi!V#gi!W#gi!Z#gi!_#gi!j#gi!u#gi!v#gi!w#gi#O#gi#Q#gi#S#gi#U#gi#W#gi#[#gi#^#gi#a#gi#b#gi#d#gi#k#gi#n#gi#r#gi#t#gi#y#gi#|#gi$O#gi%Z#gi%w#gi%x#gi%|#gi%}#gi&c#gi&d#gi&g#gi&j#gi&n#gi&o#gi&p#gi%]#gi%a#gi~Ov)nOP#jiX#jih#jij#jiq#jiu#jix#ji!R#ji!S#ji!V#ji!W#ji!Z#ji!_#ji!j#ji!u#ji!v#ji!w#ji#O#ji#Q#ji#S#ji#U#ji#W#ji#[#ji#^#ji#a#ji#b#ji#d#ji#k#ji#n#ji#r#ji#t#ji#y#ji#|#ji$O#ji%Z#ji%w#ji%x#ji%|#ji%}#ji&c#ji&d#ji&g#ji&j#ji&n#ji&o#ji&p#ji%]#ji%a#ji~OX)pOp&wa~P'WO|)qOp&wa~O|)qOp&wa~P$dOp)uO~O%[)xO~Ov){O#o'dO#p)zOP#miX#mih#mij#miq#miu#mix#mi!R#mi!S#mi!V#mi!W#mi!Z#mi!_#mi!j#mi!u#mi!v#mi!w#mi#O#mi#Q#mi#S#mi#U#mi#W#mi#[#mi#^#mi#a#mi#b#mi#d#mi#k#mi#n#mi#r#mi#t#mi#y#mi#|#mi$O#mi%Z#mi%w#mi%x#mi%|#mi%}#mi&c#mi&d#mi&g#mi&j#mi&n#mi&o#mi&p#mi%]#mi%a#mi~Oq0VOx0eO}$uO~P'WOq0VOx0eO}&xa~P'WO|*RO}&xa~OX*VOc*WOi*ZO%y*XO%}WO~O}$uO&{*]O~O%^*aO~O%^*cO~OX%YOc%YOq0VOx0eOi&^a~P'WO|*fOi&^a~Oq0VOx0eO}*iO!Y&aa~P'WO|*jO!Y&aa~Oq0VOx0eO|*jO}*mO!Y&aa~P'WOq0VOx0eO|*jO!Y&aa~P'WO|*jO}*mO!Y&aa~Oo0WOp0WOq0aOr0bOilimliuli|li!Vli!Wli&Tli!Yli}li!^li#fli%^li%ali!Sli#_livli!nli&Sli~On0YO~P!IeOnli~P!IeOX(WOi*rOq0VOx0eO~P'WOp*tO~Oi*rO|*vO~Oi*wO~OX(WOq0VOx0eO!Y&[i~P'WO|*xO!Y&[i~O!Y*yO~OX(gOq0VOx0eO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~P'WO|*|O!V%oO!W%nO!^&]i~O|+PO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~O!^+QO~Oc+SOq0VOx0eO!^&]i~P'WO|*|O!^&]i~O!^+UO~OX+WOq0VOx0eO}&ka!^&ka!n&ka~P'WO|+XO}&ka!^&ka!n&ka~O!_+[O&m+]O!^!oX~O!^+_O~O}(tO!^+`O~O}(tO!^+aO~O}(tO!^+bO~O}(tO!^+cO~OX&bOquOxvO}%pq!{%pq#f%pq%^%pq%a%pq&S%pq~P'WO|$ui}$ui!{$ui#f$ui%^$ui%a$ui&S$ui~P$dOX&bOquOxvO~P'WOX&bOq0VOx0eO#f%pa%^%pa%a%pa&S%pa~P'WO|+dO#f%pa%^%pa%a%pa&S%pa~O|$ha#f$ha%^$ha%a$hap$ha~P$dO#f&Xi%^&Xi%a&Xip&Xi~P'WO|+gO#f#Zq%^#Zq%a#Zq~O|+hO#_+jO#f&tX%^&tX%a&tXi&tX~OX+lOj)cO%}WO~O%}WO#f&ui%^&ui%a&ui~Oq0VOx0eO#f&qi%^&qi%a&qi}&qi~P'WOv+pO#i)lOP#gqX#gqh#gqj#gqq#gqu#gqx#gq!R#gq!S#gq!V#gq!W#gq!Z#gq!_#gq!j#gq!u#gq!v#gq!w#gq#O#gq#Q#gq#S#gq#U#gq#W#gq#[#gq#^#gq#a#gq#b#gq#d#gq#k#gq#n#gq#r#gq#t#gq#y#gq#|#gq$O#gq%Z#gq%w#gq%x#gq%|#gq%}#gq&c#gq&d#gq&g#gq&j#gq&n#gq&o#gq&p#gq%]#gq%a#gq~Op%Oa|%Oa~P$dOX)pOp&wi~P'WO|+wOp&wi~O|,QO}$uO#_,QO~O#p,ROP#mqX#mqh#mqj#mqq#mqu#mqx#mq!R#mq!S#mq!V#mq!W#mq!Z#mq!_#mq!j#mq!u#mq!v#mq!w#mq#O#mq#Q#mq#S#mq#U#mq#W#mq#[#mq#^#mq#a#mq#b#mq#d#mq#k#mq#n#mq#r#mq#t#mq#y#mq#|#mq$O#mq%Z#mq%w#mq%x#mq%|#mq%}#mq&c#mq&d#mq&g#mq&j#mq&n#mq&o#mq&p#mq%]#mq%a#mq~O#_,SO|%Qa}%Qa~Oq0VOx0eO}&xi~P'WO|,UO}&xi~O}$ZO&S,WOi&zX|&zX~O%}WOi&zX|&zX~O|,[Oi&yX~Oi,^O~O%[,`O~OX%YOc%YOq0VOx0eOi&^i~P'WO},bO|$ka!Y$ka~Oq0VOx0eO},cO|$ka!Y$ka~P'WOq0VOx0eO}*iO!Y&ai~P'WO|,fO!Y&ai~Oq0VOx0eO|,fO!Y&ai~P'WO|,fO},iO!Y&ai~Oi$gi|$gi!Y$gi~P$dOX(WOq0VOx0eO~P'WOp,kO~OX(WOi,lOq0VOx0eO~P'WOX(WOq0VOx0eO!Y&[q~P'WO|$fi!^$fi#f$fi%^$fi%a$fii$fi}$fi!n$fi&S$fi~P$dOX(gOq0VOx0eO~P'WOc+SOq0VOx0eO!^&]q~P'WO|,mO!^&]q~O!^,nO~OX(gOq0VOx0eO!^&Vq#f&Vq%^&Vq%a&Vqi&Vq}&Vq!n&Vq&S&Vq~P'WO},oO~OX+WOq0VOx0eO}&ki!^&ki!n&ki~P'WO|,tO}&ki!^&ki!n&ki~O!_+[O&m+]O!^!oa~OX&bOq0VOx0eO#f%pi%^%pi%a%pi&S%pi~P'WO|,wO#f%pi%^%pi%a%pi&S%pi~O%}WO#f&ta%^&ta%a&tai&ta~O|,zO#f&ta%^&ta%a&tai&ta~Oi,}O~Op%Oi|%Oi~P$dOX)pO~P'WOX)pOp&wq~P'WOv-QOP#lyX#lyh#lyj#lyq#lyu#lyx#ly!R#ly!S#ly!V#ly!W#ly!Z#ly!_#ly!j#ly!u#ly!v#ly!w#ly#O#ly#Q#ly#S#ly#U#ly#W#ly#[#ly#^#ly#a#ly#b#ly#d#ly#k#ly#n#ly#r#ly#t#ly#y#ly#|#ly$O#ly%Z#ly%w#ly%x#ly%|#ly%}#ly&c#ly&d#ly&g#ly&j#ly&n#ly&o#ly&p#ly%]#ly%a#ly~O%]-TO%a-TO~P`O#p-UOP#myX#myh#myj#myq#myu#myx#my!R#my!S#my!V#my!W#my!Z#my!_#my!j#my!u#my!v#my!w#my#O#my#Q#my#S#my#U#my#W#my#[#my#^#my#a#my#b#my#d#my#k#my#n#my#r#my#t#my#y#my#|#my$O#my%Z#my%w#my%x#my%|#my%}#my&c#my&d#my&g#my&j#my&n#my&o#my&p#my%]#my%a#my~Oq0VOx0eO}&xq~P'WO|-YO}&xq~O&S,WOi&za|&za~OX*VOc*WO%y*XO%}WOi&ya~O|-^Oi&ya~O$R-bO~OX%YOc%YOq0VOx0eO~P'WOq0VOx0eO}-cO|$ki!Y$ki~P'WOq0VOx0eO|$ki!Y$ki~P'WO}-cO|$ki!Y$ki~Oq0VOx0eO}*iO~P'WOq0VOx0eO}*iO!Y&aq~P'WO|-fO!Y&aq~Oq0VOx0eO|-fO!Y&aq~P'WOu-iO!V%oO!W%nOi&Wq!Y&Wq!^&Wq|&Wq~P!-iOc+SOq0VOx0eO!^&]y~P'WO|$ii!^$ii~P$dOc+SOq0VOx0eO~P'WOX+WOq0VOx0eO~P'WOX+WOq0VOx0eO}&kq!^&kq!n&kq~P'WO}(tO!^-mO!n-nO~OX&bOq0VOx0eO#f%pq%^%pq%a%pq&S%pq~P'WO#_-oO|$za#f$za%^$za%a$zai$za~O%}WO#f&ti%^&ti%a&tii&ti~O|-qO#f&ti%^&ti%a&tii&ti~Ov-tOP#l!RX#l!Rh#l!Rj#l!Rq#l!Ru#l!Rx#l!R!R#l!R!S#l!R!V#l!R!W#l!R!Z#l!R!_#l!R!j#l!R!u#l!R!v#l!R!w#l!R#O#l!R#Q#l!R#S#l!R#U#l!R#W#l!R#[#l!R#^#l!R#a#l!R#b#l!R#d#l!R#k#l!R#n#l!R#r#l!R#t#l!R#y#l!R#|#l!R$O#l!R%Z#l!R%w#l!R%x#l!R%|#l!R%}#l!R&c#l!R&d#l!R&g#l!R&j#l!R&n#l!R&o#l!R&p#l!R%]#l!R%a#l!R~Oq0VOx0eO}&xy~P'WOX*VOc*WO%y*XO%}WOi&yi~O$R-bO%]-zO%a-zO~OX.UOj.SO!Z.RO!_.TO!j-}O!v.PO!w.PO%x-|O%}WO&c]O&d^O&g_O~Oq0VOx0eO|$kq!Y$kq~P'WO}.ZO|$kq!Y$kq~Oq0VOx0eO}*iO!Y&ay~P'WO|.[O!Y&ay~Oq0VOx.`O~P'WOu-iO!V%oO!W%nOi&Wy!Y&Wy!^&Wy|&Wy~P!-iO}(tO!^.cO~O%}WO#f&tq%^&tq%a&tqi&tq~O|.eO#f&tq%^&tq%a&tqi&tq~OX*VOc*WO%y*XO%}WO~Oj.iO!h.gO|$SX#_$SX%r$SXi$SX~Ou$SX}$SX!Y$SX!^$SX~P$!}O%w.kO%x.kOu$TX|$TX}$TX#_$TX%r$TX!Y$TXi$TX!^$TX~O!j.mO~O|.qO#_.sO%r.nOu&|X}&|X!Y&|Xi&|X~Oc.vO~P#M_Oj.iOu&}X|&}X}&}X#_&}X%r&}X!Y&}Xi&}X!^&}X~Ou.zO}$uO~Oq0VOx0eO|$ky!Y$ky~P'WOq0VOx0eO}*iO!Y&a!R~P'WO|/OO!Y&a!R~Oi&ZXu&ZX!V&ZX!W&ZX!Y&ZX!^&ZX|&ZX~P!-iOu-iO!V%oO!W%nOi&Ya!Y&Ya!^&Ya|&Ya~O%}WO#f&ty%^&ty%a&tyi&ty~O!h.gOj$Zau$Za|$Za}$Za#_$Za%r$Za!Y$Zai$Za!^$Za~O!j/XO~O%w.kO%x.kOu$Ta|$Ta}$Ta#_$Ta%r$Ta!Y$Tai$Ta!^$Ta~O%r.nOu$Xa|$Xa}$Xa#_$Xa!Y$Xai$Xa!^$Xa~Ou&|a}&|a!Y&|ai&|a~P#MRO|/^Ou&|a}&|a!Y&|ai&|a~O!Y/aO~Oi/aO~O}/cO~O!^/dO~Oq0VOx0eO}*iO!Y&a!Z~P'WO}/gO~O&S/hO~P$!}O|/iO#_.sO%r.nOi'PX~O|/iOi'PX~Oi/kO~O!j/lO~O#_.sOu%Ua|%Ua}%Ua%r%Ua!Y%Uai%Ua!^%Ua~O#_.sO%r.nOu%Ya|%Ya}%Ya!Y%Yai%Ya~Ou&|i}&|i!Y&|ii&|i~P#MRO|/nO#_.sO%r.nO!^'Oa~O}$ca~P$dOi'Pa~P#MRO|/vOi'Pa~Oc/xO!^'Oi~P#M_O|/zO!^'Oi~O|/zO#_.sO%r.nO!^'Oi~O#_.sO%r.nOi$ai|$ai~O&S/}O~P$!}O#_.sO%r.nOi%Xa|%Xa~Oi'Pi~P#MRO}0QO~Oc/xO!^'Oq~P#M_O|0SO!^'Oq~O#_.sO%r.nO|%Wi!^%Wi~Oc/xO~P#M_Oc/xO!^'Oy~P#M_O#_.sO%r.nOi$bi|$bi~O#_.sO%r.nO|%Wq!^%Wq~O|+dO#f%pa%^%pa%a%pa&S%pa~P$dOX&bOq0VOx0eO~P'WOp0[O~Oq0[O~P'WO}0]O~Ov0^O~P!-iO&d&g&o&p&c&j&n%}&c~",
	goto: "!<w'QPPPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=pPP=s>e>hPP'Z'ZPP?QPP'Z'ZPP'Z'Z'Z'Z'Z?U?{'ZP@OP@UD]GyPG}HZH_HcHg'ZPPPHkHq'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RPHwPIOIUPIOPIOIOPPPIOPKTPK^KdKjKTPIOKpPIOPKwK}PLRLgMUMoLRLRMuNSLRLRLRLRNhNnNqNvNy! T! Z! g! y!!P!!Z!!a!!}!#T!#Z!#a!#k!#q!#w!#}!$T!$Z!$m!$w!$}!%T!%Z!%e!%k!%q!%w!&R!&X!&c!&i!&r!&x!'X!'a!'k!'rPPPPPPPPPPPPPPPPP!'x!'{!(R!([!(f!(qPPPPPPPPPPPP!-e!.y!2s!6TPP!6]!6o!6x!7n!7e!7w!7}!8Q!8T!8W!8`!9PPPPPPPPPP!9S!9cPPPP!:R!:_!:k!:q!:z!:}!;T!;Z!;a!;dP!;l!;u!<q!<t]jOs#u$u)x+|'}eOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f}!gQ#q$O$a$o${%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!P!hQ#q$O$a$o${%Q%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!R!iQ#q$O$a$o${%Q%R%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!T!jQ#q$O$a$o${%Q%R%S%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!V!kQ#q$O$a$o${%Q%R%S%T%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!X!lQ#q$O$a$o${%Q%R%S%T%U%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!]!lQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z'}TOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f&cVOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0f%mXOYZ[isw}!O!S!T!U!Y!m!o#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$UvQ/P.`R0c0e'teOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fW#xm!P!Q$gW$Qv&o.`0eQ$i!RQ$y!ZQ$z![W%X!m'w*f,aS&n$R$SQ'`$tQ)R&hQ)a'OU)b'Q)c)dU)e'S)f+mQ*T'iW*U'k,[-^-xS,Z*V*WY,y+h,z-p-q.eQ,|+jQ-V,QQ-X,Sl-{-b.R.S.U.o.q.v/^/c/h/m/x/}0QQ.d-oQ.w.TQ/T.iQ/`.sU/s/i/v0OX/y/n/z0R0SR&m$Q!_!{YZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OR%i!zQ#PYQ&U#bQ&X#fQ&Z#iQ&]#lQ&v$]Q&y$`R,u+[T._-i/g![!nQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZQ&k#yR'n$zR'v%XQ%b!qR/R.g'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fS#od#p!P.P-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0S'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fT#od#pT#c`#de(u&U&X&Z&](w(y({(},u-nT+](t+^T#ga#hT#jb#kT#mc#nQ$_xR,Y*UX$]x$^$_&xZlOs$u)x+|XpOs)x+|Q$v!XQ'W$mQ'X$nQ'j$xQ'm$zQ)v'_Q)|'dQ*O'eQ*P'fQ*^'lQ*`'nQ+q)lQ+s)mQ+t)nQ+x)tS+z)w*_Q+})zQ,O){Q,P)}Q-O+pQ-P+rQ-R+yQ-S+{Q-W,RQ-s-QQ-u-UQ-v-VQ.f-tQ.{.XR/f.|WpOs)x+|R#{oQ'l$yR)w'`Q,X*UR-[,YQ*_'lR+{)wZnOos)x+|Q'p${R*b'qT-`,`-au.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0Qt.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QQ.w.TX/y/n/z0R0S!P.O-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0SQ.l-}R/Y.mg.o.Q.p/U/]/b/p/r/t0P0T0Uu.V-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QX.j-{.V/T/sR/V.iV/u/i/v0OR.|.XQsOS#}s+|R+|)xQ&p$TR)W&pS%x#V$VS(i%x(lT(l%{&rQ%l!}Q%s#RW(Z%l%s(`(dQ(`%pR(d%uQ&{$aR)^&{Q(o%|Q*}(jT+T(o*}Q'x%ZR*g'xS'{%^%_Y*k'{*l,g-g.]U*l'|'}(OU,g*m*n*oS-g,h,iR.]-hQ#^^R&P#^Q#a_R&R#aQ#d`R&V#dQ(r&SS+Y(r+ZR+Z(sQ+^(tR,v+^Q#haR&Y#hQ#kbR&[#kQ#ncR&^#nQ#pdR&_#pQ#sgQ&a#qW&d#s&a)Z+eQ)Z&uR+e0ZQ$^xS&w$^&xR&x$_Q'V$kR)j'VQ&i#xR)S&iQ$g!QR'P$gQ+i)bS,{+i-rR-r,|Q'T$iR)g'TQ#vkR&f#vQ)k'WR+o)kQ'Z$oS)r'Z)sR)s'[Q'c$vR)y'cQ'h$wS*S'h,VR,V*TQ,]*YR-_,]WoOs)x+|R#zoQ-a,`R-y-ad.p.Q/U/]/b/p/r/t0P0T0UR/[.pU.h-{/T/sR/S.hQ/o/bS/{/o/|R/|/pS/j/U/VR/w/jQ.r.QR/_.rR!_PXrOs)x+|WqOs)x+|R'a$uYkOs$u)x+|R&e#u[xOs#u$u)x+|R&v$]&bQOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0fQ!rTQ#qfQ$OtU$ay%n(^S$o!V$rQ${!]Q%Q!gQ%R!hQ%S!iQ%T!jQ%U!kQ%V!lQ%p#OQ%u#SQ%{#WQ%|#XQ&r$WQ'[$pQ'q$|Q)P&bU)[&z)]+fW)o'Y)q+v+wQ*q(WQ*z(gQ+u)pQ,p+SQ/e.zR0Z0`Q!}YQ#RZQ$m!TQ$n!UQ%^!oQ(O%_^(V%k%r(Y(b*s*v*x^*h'z*j,e,f-f.[/OQ*n'|Q*o'}Q+r)lQ,d*iQ,h*mQ-d,bQ-e,cQ-h,iQ.Y-cR.}.Z[gOs#u$u)x+|!^!zYZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OQ#V[Q#tiS$Vw}Q$d!OW$k!S$`'])uS$w!Y$sW%W!m'w*f,aY&S#b#f#i#l+[`&c#r&`)O)Q)Y+d,w0_Q&s$XQ&t$ZQ&u$]Q't%YQ(U%iW(f%w(h*{+PQ(j%yQ(s&TQ)U&mS)X&q0]Q)_&|Q)`&}U)h'U)i+nQ)}'dY*Q'g*R,T,U-YQ*d'vS*p(R0^W+R(n*|,m,qW+V(q+X,s,tQ,_*]Q,r+WQ,x+gQ-Z,XQ-l,oR-w-[hUOs#r#u$u&`&q(R)O)Q)x+|%S!yYZ[iw}!O!S!T!U!Y!m!o#b#f#i#l$X$Z$]$`$s%Y%_%i%k%r%w%y&T&m&|&}'U']'d'g'v'w'z'|'}(Y(b(h(n(q)Y)i)l)u*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$PuW%c!s!w0W0bQ%d!tQ%e!uQ%g!xQ%q0VS(Q%f0[Q(S0XQ(T0YQ,j*tQ-k,kS.^-i/gR0d0fU$Tv.`0eR)V&o[hOs#u$u)x+|a!|Y#b#f#i#l$]$`+[Q#[[Q$YwR$c}Q%m!}Q%t#RQ%z#VQ't%WQ(a%pQ(e%uQ(m%{Q(p%|Q+O(jQ-j,jQ.b-kR/Q.aQ$byQ(]%nR*u(^Q.a-iR/q/gR#UZR#Z[R%]!mQ%Z!mV*e'w*f,a!]!pQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZR%`!oQ&U#bQ&X#fQ&Z#iQ&]#lR,u+[Q(v&UQ(x&XQ(z&ZQ(|&]Q+`(wQ+a(yQ+b({Q+c(}Q-m,uR.c-nQ$l!SQ&y$`Q)t']R+y)uQ#ymQ$e!PQ$h!QR'R$gQ)a'QR+l)dQ)a'QQ+k)cR+l)dR$j!RXqOs)x+|Q$q!VR'^$rQ$x!YR'_$sR*['kQ*Y'kV-],[-^-xQ.X-bQ.t.RR.u.SU.Q-b.R.SQ.y.UQ/U.iQ/Z.oU/].q/^/mQ/b.vQ/p/cQ/r/hU/t/i/v0OQ0P/xQ0T/}R0U0QR.x.TR/W.i",
	nodeNames: "⚠ print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec FormatReplacement FormatReplacement FormatReplacement FormatReplacement ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
	maxTerm: 277,
	context: trackIndent,
	nodeProps: [
		[
			"group",
			-14,
			8,
			88,
			90,
			91,
			93,
			95,
			97,
			99,
			101,
			102,
			103,
			105,
			108,
			111,
			"Statement Statement",
			-22,
			10,
			20,
			23,
			27,
			42,
			51,
			52,
			58,
			59,
			62,
			63,
			64,
			65,
			66,
			69,
			72,
			73,
			74,
			82,
			83,
			84,
			85,
			"Expression",
			-10,
			113,
			115,
			118,
			120,
			121,
			125,
			127,
			132,
			134,
			137,
			"Statement",
			-9,
			142,
			143,
			146,
			147,
			149,
			150,
			151,
			152,
			153,
			"Pattern"
		],
		[
			"openedBy",
			25,
			"(",
			56,
			"[",
			60,
			"{"
		],
		[
			"closedBy",
			26,
			")",
			57,
			"]",
			61,
			"}"
		]
	],
	propSources: [pythonHighlighting],
	skippedNodes: [0, 6],
	repeatNodeCount: 37,
	tokenData: "%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&m!b&eSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&m!b&eSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&m!b&eSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&m!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&m!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&m!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&m!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&m!b&hWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&m!b&hWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&m!b&hWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&m!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&m!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&m!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&m!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&eSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&eSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&hWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&hWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&m!b&eS&hW%k!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&m!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!nR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&m!b&eS&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&m!b&eS&csOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&m!b&hW&csOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&m!b&csOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&m!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&csOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&m!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&eS&csOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&m!b&eS&csOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&iW&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&m!b&eS&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&m!b&eSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&m!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&m!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&eSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&m!b&hWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&m!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&hWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&m!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&eS&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_%zQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]!{r&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_%tQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&m!b&eS&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&m!b&eS&csOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&m!b&csOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&m!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&csOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&m!b&hW&csOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&m!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&hW&csOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&m!b&hW&csOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&fS&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&m!b&eS&hWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_%ws&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`%xs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]&{`&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!us&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&m!b&eS&hWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja%yR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_%{Q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&TR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#fs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_%uQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&Ss&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_%vQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ#|P&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&m!b&eS&hW&b`%}sOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&m!b&eS&csOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&m!b&hW&csOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&m!b&eS&nsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&m!b&eSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&m!b&eS&psOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&m!b&hW&jsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&m!b&hWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&m!b&hW&osOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%sQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%rR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]%|q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T",
	tokenizers: [
		legacyPrint,
		indentation,
		newlines,
		formatString1,
		formatString2,
		formatString1l,
		formatString2l,
		0,
		1,
		2,
		3,
		4,
		5,
		6
	],
	topRules: { "Script": [0, 7] },
	specialized: [{
		term: 229,
		get: (value$1) => spec_identifier[value$1] || -1
	}],
	tokenPrec: 7205
});
var DefaultBufferLength = 1024;
var nextPropID = 0;
var NodeProp = class {
	constructor(config = {}) {
		this.id = nextPropID++;
		this.perNode = !!config.perNode;
		this.deserialize = config.deserialize || (() => {
			throw new Error("This node type doesn't define a deserialize function");
		});
	}
	add(match) {
		if (this.perNode) throw new RangeError("Can't add per-node props to node types");
		if (typeof match != "function") match = NodeType.match(match);
		return (type) => {
			let result = match(type);
			return result === void 0 ? null : [this, result];
		};
	}
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value$1) => {
	if (value$1 && value$1 != "rtl" && value$1 != "ltr" && value$1 != "auto") throw new RangeError("Invalid value for isolate: " + value$1);
	return value$1 || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
	constructor(tree, overlay, parser$4) {
		this.tree = tree;
		this.overlay = overlay;
		this.parser = parser$4;
	}
	static get(tree) {
		return tree && tree.props && tree.props[NodeProp.mounted.id];
	}
};
var noProps = Object.create(null);
var NodeType = class NodeType {
	constructor(name, props, id, flags = 0) {
		this.name = name;
		this.props = props;
		this.id = id;
		this.flags = flags;
	}
	static define(spec) {
		let props = spec.props && spec.props.length ? Object.create(null) : noProps;
		let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
		let type = new NodeType(spec.name || "", props, spec.id, flags);
		if (spec.props) for (let src of spec.props) {
			if (!Array.isArray(src)) src = src(type);
			if (src) {
				if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
				props[src[0].id] = src[1];
			}
		}
		return type;
	}
	prop(prop) {
		return this.props[prop.id];
	}
	get isTop() {
		return (this.flags & 1) > 0;
	}
	get isSkipped() {
		return (this.flags & 2) > 0;
	}
	get isError() {
		return (this.flags & 4) > 0;
	}
	get isAnonymous() {
		return (this.flags & 8) > 0;
	}
	is(name) {
		if (typeof name == "string") {
			if (this.name == name) return true;
			let group$1 = this.prop(NodeProp.group);
			return group$1 ? group$1.indexOf(name) > -1 : false;
		}
		return this.id == name;
	}
	static match(map) {
		let direct = Object.create(null);
		for (let prop in map) for (let name of prop.split(" ")) direct[name] = map[prop];
		return (node$1) => {
			for (let groups$1 = node$1.prop(NodeProp.group), i = -1; i < (groups$1 ? groups$1.length : 0); i++) {
				let found = direct[i < 0 ? node$1.name : groups$1[i]];
				if (found) return found;
			}
		};
	}
};
NodeType.none = new NodeType("", Object.create(null), 0, 8);
var CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode$1) {
	IterMode$1[IterMode$1["ExcludeBuffers"] = 1] = "ExcludeBuffers";
	IterMode$1[IterMode$1["IncludeAnonymous"] = 2] = "IncludeAnonymous";
	IterMode$1[IterMode$1["IgnoreMounts"] = 4] = "IgnoreMounts";
	IterMode$1[IterMode$1["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class Tree {
	constructor(type, children, positions, length, props) {
		this.type = type;
		this.children = children;
		this.positions = positions;
		this.length = length;
		this.props = null;
		if (props && props.length) {
			this.props = Object.create(null);
			for (let [prop, value$1] of props) this.props[typeof prop == "number" ? prop : prop.id] = value$1;
		}
	}
	toString() {
		let mounted = MountedTree.get(this);
		if (mounted && !mounted.overlay) return mounted.tree.toString();
		let children = "";
		for (let ch of this.children) {
			let str = ch.toString();
			if (str) {
				if (children) children += ",";
				children += str;
			}
		}
		return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
	}
	cursor(mode = 0) {
		return new TreeCursor(this.topNode, mode);
	}
	cursorAt(pos, side = 0, mode = 0) {
		let cursor = new TreeCursor(CachedNode.get(this) || this.topNode);
		cursor.moveTo(pos, side);
		CachedNode.set(this, cursor._tree);
		return cursor;
	}
	get topNode() {
		return new TreeNode(this, 0, 0, null);
	}
	resolve(pos, side = 0) {
		let node$1 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
		CachedNode.set(this, node$1);
		return node$1;
	}
	resolveInner(pos, side = 0) {
		let node$1 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
		CachedInnerNode.set(this, node$1);
		return node$1;
	}
	resolveStack(pos, side = 0) {
		return stackIterator(this, pos, side);
	}
	iterate(spec) {
		let { enter, leave, from = 0, to = this.length } = spec;
		let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
		for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
			let entered = false;
			if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
				if (c.firstChild()) continue;
				entered = true;
			}
			for (;;) {
				if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);
				if (c.nextSibling()) break;
				if (!c.parent()) return;
				entered = true;
			}
		}
	}
	prop(prop) {
		return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
	}
	get propValues() {
		let result = [];
		if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);
		return result;
	}
	balance(config = {}) {
		return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
	}
	static build(data) {
		return buildTree(data);
	}
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class FlatBufferCursor {
	constructor(buffer, index$1) {
		this.buffer = buffer;
		this.index = index$1;
	}
	get id() {
		return this.buffer[this.index - 4];
	}
	get start() {
		return this.buffer[this.index - 3];
	}
	get end() {
		return this.buffer[this.index - 2];
	}
	get size() {
		return this.buffer[this.index - 1];
	}
	get pos() {
		return this.index;
	}
	next() {
		this.index -= 4;
	}
	fork() {
		return new FlatBufferCursor(this.buffer, this.index);
	}
};
var TreeBuffer = class TreeBuffer {
	constructor(buffer, length, set$3) {
		this.buffer = buffer;
		this.length = length;
		this.set = set$3;
	}
	get type() {
		return NodeType.none;
	}
	toString() {
		let result = [];
		for (let index$1 = 0; index$1 < this.buffer.length;) {
			result.push(this.childString(index$1));
			index$1 = this.buffer[index$1 + 3];
		}
		return result.join(",");
	}
	childString(index$1) {
		let id = this.buffer[index$1], endIndex = this.buffer[index$1 + 3];
		let type = this.set.types[id], result = type.name;
		if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
		index$1 += 4;
		if (endIndex == index$1) return result;
		let children = [];
		while (index$1 < endIndex) {
			children.push(this.childString(index$1));
			index$1 = this.buffer[index$1 + 3];
		}
		return result + "(" + children.join(",") + ")";
	}
	findChild(startIndex, endIndex, dir, pos, side) {
		let { buffer } = this, pick = -1;
		for (let i = startIndex; i != endIndex; i = buffer[i + 3]) if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
			pick = i;
			if (dir > 0) break;
		}
		return pick;
	}
	slice(startI, endI, from) {
		let b$1 = this.buffer;
		let copy = new Uint16Array(endI - startI), len = 0;
		for (let i = startI, j$1 = 0; i < endI;) {
			copy[j$1++] = b$1[i++];
			copy[j$1++] = b$1[i++] - from;
			let to = copy[j$1++] = b$1[i++] - from;
			copy[j$1++] = b$1[i++] - startI;
			len = Math.max(len, to);
		}
		return new TreeBuffer(copy, len, this.set);
	}
};
function checkSide(side, pos, from, to) {
	switch (side) {
		case -2: return from < pos;
		case -1: return to >= pos && from < pos;
		case 0: return from < pos && to > pos;
		case 1: return from <= pos && to > pos;
		case 2: return to > pos;
		case 4: return true;
	}
}
function resolveNode(node$1, pos, side, overlays) {
	var _a$1;
	while (node$1.from == node$1.to || (side < 1 ? node$1.from >= pos : node$1.from > pos) || (side > -1 ? node$1.to <= pos : node$1.to < pos)) {
		let parent$2 = !overlays && node$1 instanceof TreeNode && node$1.index < 0 ? null : node$1.parent;
		if (!parent$2) return node$1;
		node$1 = parent$2;
	}
	let mode = overlays ? 0 : IterMode.IgnoreOverlays;
	if (overlays) {
		for (let scan = node$1, parent$2 = scan.parent; parent$2; scan = parent$2, parent$2 = scan.parent) if (scan instanceof TreeNode && scan.index < 0 && ((_a$1 = parent$2.enter(pos, side, mode)) === null || _a$1 === void 0 ? void 0 : _a$1.from) != scan.from) node$1 = parent$2;
	}
	for (;;) {
		let inner = node$1.enter(pos, side, mode);
		if (!inner) return node$1;
		node$1 = inner;
	}
}
var BaseNode = class {
	cursor(mode = 0) {
		return new TreeCursor(this, mode);
	}
	getChild(type, before = null, after = null) {
		let r = getChildren(this, type, before, after);
		return r.length ? r[0] : null;
	}
	getChildren(type, before = null, after = null) {
		return getChildren(this, type, before, after);
	}
	resolve(pos, side = 0) {
		return resolveNode(this, pos, side, false);
	}
	resolveInner(pos, side = 0) {
		return resolveNode(this, pos, side, true);
	}
	matchContext(context) {
		return matchNodeContext(this, context);
	}
	enterUnfinishedNodesBefore(pos) {
		let scan = this.childBefore(pos), node$1 = this;
		while (scan) {
			let last$2 = scan.lastChild;
			if (!last$2 || last$2.to != scan.to) break;
			if (last$2.type.isError && last$2.from == last$2.to) {
				node$1 = scan;
				scan = last$2.prevSibling;
			} else scan = last$2;
		}
		return node$1;
	}
	get node() {
		return this;
	}
	get next() {
		return this.parent;
	}
};
var TreeNode = class TreeNode extends BaseNode {
	constructor(_tree, from, index$1, _parent) {
		super();
		this._tree = _tree;
		this.from = from;
		this.index = index$1;
		this._parent = _parent;
	}
	get type() {
		return this._tree.type;
	}
	get name() {
		return this._tree.type.name;
	}
	get to() {
		return this.from + this._tree.length;
	}
	nextChild(i, dir, pos, side, mode = 0) {
		for (let parent$2 = this;;) {
			for (let { children, positions } = parent$2._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
				let next = children[i], start = positions[i] + parent$2.from;
				if (!checkSide(side, pos, start, start + next.length)) continue;
				if (next instanceof TreeBuffer) {
					if (mode & IterMode.ExcludeBuffers) continue;
					let index$1 = next.findChild(0, next.buffer.length, dir, pos - start, side);
					if (index$1 > -1) return new BufferNode(new BufferContext(parent$2, next, i, start), null, index$1);
				} else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
					let mounted;
					if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent$2);
					let inner = new TreeNode(next, start, i, parent$2);
					return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
				}
			}
			if (mode & IterMode.IncludeAnonymous || !parent$2.type.isAnonymous) return null;
			if (parent$2.index >= 0) i = parent$2.index + dir;
			else i = dir < 0 ? -1 : parent$2._parent._tree.children.length;
			parent$2 = parent$2._parent;
			if (!parent$2) return null;
		}
	}
	get firstChild() {
		return this.nextChild(0, 1, 0, 4);
	}
	get lastChild() {
		return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
	}
	childAfter(pos) {
		return this.nextChild(0, 1, pos, 2);
	}
	childBefore(pos) {
		return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
	}
	enter(pos, side, mode = 0) {
		let mounted;
		if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
			let rPos = pos - this.from;
			for (let { from, to } of mounted.overlay) if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
		}
		return this.nextChild(0, 1, pos, side, mode);
	}
	nextSignificantParent() {
		let val = this;
		while (val.type.isAnonymous && val._parent) val = val._parent;
		return val;
	}
	get parent() {
		return this._parent ? this._parent.nextSignificantParent() : null;
	}
	get nextSibling() {
		return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
	}
	get prevSibling() {
		return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
	}
	get tree() {
		return this._tree;
	}
	toTree() {
		return this._tree;
	}
	toString() {
		return this._tree.toString();
	}
};
function getChildren(node$1, type, before, after) {
	let cur = node$1.cursor(), result = [];
	if (!cur.firstChild()) return result;
	if (before != null) for (let found = false; !found;) {
		found = cur.type.is(before);
		if (!cur.nextSibling()) return result;
	}
	for (;;) {
		if (after != null && cur.type.is(after)) return result;
		if (cur.type.is(type)) result.push(cur.node);
		if (!cur.nextSibling()) return after == null ? result : [];
	}
}
function matchNodeContext(node$1, context, i = context.length - 1) {
	for (let p = node$1.parent; i >= 0; p = p.parent) {
		if (!p) return false;
		if (!p.type.isAnonymous) {
			if (context[i] && context[i] != p.name) return false;
			i--;
		}
	}
	return true;
}
var BufferContext = class {
	constructor(parent$2, buffer, index$1, start) {
		this.parent = parent$2;
		this.buffer = buffer;
		this.index = index$1;
		this.start = start;
	}
};
var BufferNode = class BufferNode extends BaseNode {
	get name() {
		return this.type.name;
	}
	get from() {
		return this.context.start + this.context.buffer.buffer[this.index + 1];
	}
	get to() {
		return this.context.start + this.context.buffer.buffer[this.index + 2];
	}
	constructor(context, _parent, index$1) {
		super();
		this.context = context;
		this._parent = _parent;
		this.index = index$1;
		this.type = context.buffer.set.types[context.buffer.buffer[index$1]];
	}
	child(dir, pos, side) {
		let { buffer } = this.context;
		let index$1 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
		return index$1 < 0 ? null : new BufferNode(this.context, this, index$1);
	}
	get firstChild() {
		return this.child(1, 0, 4);
	}
	get lastChild() {
		return this.child(-1, 0, 4);
	}
	childAfter(pos) {
		return this.child(1, pos, 2);
	}
	childBefore(pos) {
		return this.child(-1, pos, -2);
	}
	enter(pos, side, mode = 0) {
		if (mode & IterMode.ExcludeBuffers) return null;
		let { buffer } = this.context;
		let index$1 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
		return index$1 < 0 ? null : new BufferNode(this.context, this, index$1);
	}
	get parent() {
		return this._parent || this.context.parent.nextSignificantParent();
	}
	externalSibling(dir) {
		return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
	}
	get nextSibling() {
		let { buffer } = this.context;
		let after = buffer.buffer[this.index + 3];
		if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
		return this.externalSibling(1);
	}
	get prevSibling() {
		let { buffer } = this.context;
		let parentStart = this._parent ? this._parent.index + 4 : 0;
		if (this.index == parentStart) return this.externalSibling(-1);
		return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
	}
	get tree() {
		return null;
	}
	toTree() {
		let children = [], positions = [];
		let { buffer } = this.context;
		let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
		if (endI > startI) {
			let from = buffer.buffer[this.index + 1];
			children.push(buffer.slice(startI, endI, from));
			positions.push(0);
		}
		return new Tree(this.type, children, positions, this.to - this.from);
	}
	toString() {
		return this.context.buffer.childString(this.index);
	}
};
function iterStack(heads) {
	if (!heads.length) return null;
	let pick = 0, picked = heads[0];
	for (let i = 1; i < heads.length; i++) {
		let node$1 = heads[i];
		if (node$1.from > picked.from || node$1.to < picked.to) {
			picked = node$1;
			pick = i;
		}
	}
	let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
	let newHeads = heads.slice();
	if (next) newHeads[pick] = next;
	else newHeads.splice(pick, 1);
	return new StackIterator(newHeads, picked);
}
var StackIterator = class {
	constructor(heads, node$1) {
		this.heads = heads;
		this.node = node$1;
	}
	get next() {
		return iterStack(this.heads);
	}
};
function stackIterator(tree, pos, side) {
	let inner = tree.resolveInner(pos, side), layers = null;
	for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) if (scan.index < 0) {
		let parent$2 = scan.parent;
		(layers || (layers = [inner])).push(parent$2.resolve(pos, side));
		scan = parent$2;
	} else {
		let mount = MountedTree.get(scan.tree);
		if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
			let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
			(layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
		}
	}
	return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
	get name() {
		return this.type.name;
	}
	constructor(node$1, mode = 0) {
		this.mode = mode;
		this.buffer = null;
		this.stack = [];
		this.index = 0;
		this.bufferNode = null;
		if (node$1 instanceof TreeNode) this.yieldNode(node$1);
		else {
			this._tree = node$1.context.parent;
			this.buffer = node$1.context;
			for (let n = node$1._parent; n; n = n._parent) this.stack.unshift(n.index);
			this.bufferNode = node$1;
			this.yieldBuf(node$1.index);
		}
	}
	yieldNode(node$1) {
		if (!node$1) return false;
		this._tree = node$1;
		this.type = node$1.type;
		this.from = node$1.from;
		this.to = node$1.to;
		return true;
	}
	yieldBuf(index$1, type) {
		this.index = index$1;
		let { start, buffer } = this.buffer;
		this.type = type || buffer.set.types[buffer.buffer[index$1]];
		this.from = start + buffer.buffer[index$1 + 1];
		this.to = start + buffer.buffer[index$1 + 2];
		return true;
	}
	yield(node$1) {
		if (!node$1) return false;
		if (node$1 instanceof TreeNode) {
			this.buffer = null;
			return this.yieldNode(node$1);
		}
		this.buffer = node$1.context;
		return this.yieldBuf(node$1.index, node$1.type);
	}
	toString() {
		return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
	}
	enterChild(dir, pos, side) {
		if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
		let { buffer } = this.buffer;
		let index$1 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
		if (index$1 < 0) return false;
		this.stack.push(this.index);
		return this.yieldBuf(index$1);
	}
	firstChild() {
		return this.enterChild(1, 0, 4);
	}
	lastChild() {
		return this.enterChild(-1, 0, 4);
	}
	childAfter(pos) {
		return this.enterChild(1, pos, 2);
	}
	childBefore(pos) {
		return this.enterChild(-1, pos, -2);
	}
	enter(pos, side, mode = this.mode) {
		if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));
		return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
	}
	parent() {
		if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
		if (this.stack.length) return this.yieldBuf(this.stack.pop());
		let parent$2 = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
		this.buffer = null;
		return this.yieldNode(parent$2);
	}
	sibling(dir) {
		if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
		let { buffer } = this.buffer, d = this.stack.length - 1;
		if (dir < 0) {
			let parentStart = d < 0 ? 0 : this.stack[d] + 4;
			if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
		} else {
			let after = buffer.buffer[this.index + 3];
			if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
		}
		return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
	}
	nextSibling() {
		return this.sibling(1);
	}
	prevSibling() {
		return this.sibling(-1);
	}
	atLastNode(dir) {
		let index$1, parent$2, { buffer } = this;
		if (buffer) {
			if (dir > 0) {
				if (this.index < buffer.buffer.buffer.length) return false;
			} else for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;
			({index: index$1, parent: parent$2} = buffer);
		} else ({index: index$1, _parent: parent$2} = this._tree);
		for (; parent$2; {index: index$1, _parent: parent$2} = parent$2) if (index$1 > -1) for (let i = index$1 + dir, e = dir < 0 ? -1 : parent$2._tree.children.length; i != e; i += dir) {
			let child = parent$2._tree.children[i];
			if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
		}
		return true;
	}
	move(dir, enter) {
		if (enter && this.enterChild(dir, 0, 4)) return true;
		for (;;) {
			if (this.sibling(dir)) return true;
			if (this.atLastNode(dir) || !this.parent()) return false;
		}
	}
	next(enter = true) {
		return this.move(1, enter);
	}
	prev(enter = true) {
		return this.move(-1, enter);
	}
	moveTo(pos, side = 0) {
		while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
		while (this.enterChild(1, pos, side));
		return this;
	}
	get node() {
		if (!this.buffer) return this._tree;
		let cache$1 = this.bufferNode, result = null, depth = 0;
		if (cache$1 && cache$1.context == this.buffer) scan: for (let index$1 = this.index, d = this.stack.length; d >= 0;) {
			for (let c = cache$1; c; c = c._parent) if (c.index == index$1) {
				if (index$1 == this.index) return c;
				result = c;
				depth = d + 1;
				break scan;
			}
			index$1 = this.stack[--d];
		}
		for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);
		return this.bufferNode = new BufferNode(this.buffer, result, this.index);
	}
	get tree() {
		return this.buffer ? null : this._tree._tree;
	}
	iterate(enter, leave) {
		for (let depth = 0;;) {
			let mustLeave = false;
			if (this.type.isAnonymous || enter(this) !== false) {
				if (this.firstChild()) {
					depth++;
					continue;
				}
				if (!this.type.isAnonymous) mustLeave = true;
			}
			for (;;) {
				if (mustLeave && leave) leave(this);
				mustLeave = this.type.isAnonymous;
				if (this.nextSibling()) break;
				if (!depth) return;
				this.parent();
				depth--;
				mustLeave = true;
			}
		}
	}
	matchContext(context) {
		if (!this.buffer) return matchNodeContext(this.node, context);
		let { buffer } = this.buffer, { types } = buffer.set;
		for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
			if (d < 0) return matchNodeContext(this.node, context, i);
			let type = types[buffer.buffer[this.stack[d]]];
			if (!type.isAnonymous) {
				if (context[i] && context[i] != type.name) return false;
				i--;
			}
		}
		return true;
	}
};
function hasChild(tree) {
	return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
	var _a$1;
	let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
	let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
	let types = nodeSet.types;
	let contextHash = 0, lookAhead = 0;
	function takeNode(parentStart, minPos, children$1, positions$1, inRepeat, depth) {
		let { id, start, end, size } = cursor;
		let lookAheadAtStart = lookAhead;
		while (size < 0) {
			cursor.next();
			if (size == -1) {
				let node$2 = reused[id];
				children$1.push(node$2);
				positions$1.push(start - parentStart);
				return;
			} else if (size == -3) {
				contextHash = id;
				return;
			} else if (size == -4) {
				lookAhead = id;
				return;
			} else throw new RangeError(`Unrecognized record size: ${size}`);
		}
		let type = types[id], node$1, buffer$1;
		let startPos = start - parentStart;
		if (end - start <= maxBufferLength && (buffer$1 = findBufferSize(cursor.pos - minPos, inRepeat))) {
			let data$1 = new Uint16Array(buffer$1.size - buffer$1.skip);
			let endPos = cursor.pos - buffer$1.size, index$1 = data$1.length;
			while (cursor.pos > endPos) index$1 = copyToBuffer(buffer$1.start, data$1, index$1);
			node$1 = new TreeBuffer(data$1, end - buffer$1.start, nodeSet);
			startPos = buffer$1.start - parentStart;
		} else {
			let endPos = cursor.pos - size;
			cursor.next();
			let localChildren = [], localPositions = [];
			let localInRepeat = id >= minRepeatType ? id : -1;
			let lastGroup = 0, lastEnd = end;
			while (cursor.pos > endPos) if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
				if (cursor.end <= lastEnd - maxBufferLength) {
					makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
					lastGroup = localChildren.length;
					lastEnd = cursor.end;
				}
				cursor.next();
			} else if (depth > 2500) takeFlatNode(start, endPos, localChildren, localPositions);
			else takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
			if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
			localChildren.reverse();
			localPositions.reverse();
			if (localInRepeat > -1 && lastGroup > 0) {
				let make = makeBalanced(type);
				node$1 = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
			} else node$1 = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
		}
		children$1.push(node$1);
		positions$1.push(startPos);
	}
	function takeFlatNode(parentStart, minPos, children$1, positions$1) {
		let nodes = [];
		let nodeCount = 0, stopAt = -1;
		while (cursor.pos > minPos) {
			let { id, start, end, size } = cursor;
			if (size > 4) cursor.next();
			else if (stopAt > -1 && start < stopAt) break;
			else {
				if (stopAt < 0) stopAt = end - maxBufferLength;
				nodes.push(id, start, end);
				nodeCount++;
				cursor.next();
			}
		}
		if (nodeCount) {
			let buffer$1 = new Uint16Array(nodeCount * 4);
			let start = nodes[nodes.length - 2];
			for (let i = nodes.length - 3, j$1 = 0; i >= 0; i -= 3) {
				buffer$1[j$1++] = nodes[i];
				buffer$1[j$1++] = nodes[i + 1] - start;
				buffer$1[j$1++] = nodes[i + 2] - start;
				buffer$1[j$1++] = j$1;
			}
			children$1.push(new TreeBuffer(buffer$1, nodes[2] - start, nodeSet));
			positions$1.push(start - parentStart);
		}
	}
	function makeBalanced(type) {
		return (children$1, positions$1, length$1) => {
			let lookAhead$1 = 0, lastI = children$1.length - 1, last$2, lookAheadProp;
			if (lastI >= 0 && (last$2 = children$1[lastI]) instanceof Tree) {
				if (!lastI && last$2.type == type && last$2.length == length$1) return last$2;
				if (lookAheadProp = last$2.prop(NodeProp.lookAhead)) lookAhead$1 = positions$1[lastI] + last$2.length + lookAheadProp;
			}
			return makeTree(type, children$1, positions$1, length$1, lookAhead$1);
		};
	}
	function makeRepeatLeaf(children$1, positions$1, base, i, from, to, type, lookAhead$1) {
		let localChildren = [], localPositions = [];
		while (children$1.length > i) {
			localChildren.push(children$1.pop());
			localPositions.push(positions$1.pop() + base - from);
		}
		children$1.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead$1 - to));
		positions$1.push(from - base);
	}
	function makeTree(type, children$1, positions$1, length$1, lookAhead$1 = 0, props) {
		if (contextHash) {
			let pair = [NodeProp.contextHash, contextHash];
			props = props ? [pair].concat(props) : [pair];
		}
		if (lookAhead$1 > 25) {
			let pair = [NodeProp.lookAhead, lookAhead$1];
			props = props ? [pair].concat(props) : [pair];
		}
		return new Tree(type, children$1, positions$1, length$1, props);
	}
	function findBufferSize(maxSize, inRepeat) {
		let fork = cursor.fork();
		let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
		let result = {
			size: 0,
			start: 0,
			skip: 0
		};
		scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
			let nodeSize$1 = fork.size;
			if (fork.id == inRepeat && nodeSize$1 >= 0) {
				result.size = size;
				result.start = start;
				result.skip = skip;
				skip += 4;
				size += 4;
				fork.next();
				continue;
			}
			let startPos = fork.pos - nodeSize$1;
			if (nodeSize$1 < 0 || startPos < minPos || fork.start < minStart) break;
			let localSkipped = fork.id >= minRepeatType ? 4 : 0;
			let nodeStart = fork.start;
			fork.next();
			while (fork.pos > startPos) {
				if (fork.size < 0) if (fork.size == -3) localSkipped += 4;
				else break scan;
				else if (fork.id >= minRepeatType) localSkipped += 4;
				fork.next();
			}
			start = nodeStart;
			size += nodeSize$1;
			skip += localSkipped;
		}
		if (inRepeat < 0 || size == maxSize) {
			result.size = size;
			result.start = start;
			result.skip = skip;
		}
		return result.size > 4 ? result : void 0;
	}
	function copyToBuffer(bufferStart, buffer$1, index$1) {
		let { id, start, end, size } = cursor;
		cursor.next();
		if (size >= 0 && id < minRepeatType) {
			let startIndex = index$1;
			if (size > 4) {
				let endPos = cursor.pos - (size - 4);
				while (cursor.pos > endPos) index$1 = copyToBuffer(bufferStart, buffer$1, index$1);
			}
			buffer$1[--index$1] = startIndex;
			buffer$1[--index$1] = end - bufferStart;
			buffer$1[--index$1] = start - bufferStart;
			buffer$1[--index$1] = id;
		} else if (size == -3) contextHash = id;
		else if (size == -4) lookAhead = id;
		return index$1;
	}
	let children = [], positions = [];
	while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
	let length = (_a$1 = data.length) !== null && _a$1 !== void 0 ? _a$1 : children.length ? positions[0] + children[0].length : 0;
	return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node$1) {
	if (!balanceType.isAnonymous || node$1 instanceof TreeBuffer || node$1.type != balanceType) return 1;
	let size = nodeSizeCache.get(node$1);
	if (size == null) {
		size = 1;
		for (let child of node$1.children) {
			if (child.type != balanceType || !(child instanceof Tree)) {
				size = 1;
				break;
			}
			size += nodeSize(balanceType, child);
		}
		nodeSizeCache.set(node$1, size);
	}
	return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
	let total = 0;
	for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);
	let maxChild = Math.ceil(total * 1.5 / 8);
	let localChildren = [], localPositions = [];
	function divide(children$1, positions$1, from$1, to$1, offset) {
		for (let i = from$1; i < to$1;) {
			let groupFrom = i, groupStart = positions$1[i], groupSize = nodeSize(balanceType, children$1[i]);
			i++;
			for (; i < to$1; i++) {
				let nextSize = nodeSize(balanceType, children$1[i]);
				if (groupSize + nextSize >= maxChild) break;
				groupSize += nextSize;
			}
			if (i == groupFrom + 1) {
				if (groupSize > maxChild) {
					let only = children$1[groupFrom];
					divide(only.children, only.positions, 0, only.children.length, positions$1[groupFrom] + offset);
					continue;
				}
				localChildren.push(children$1[groupFrom]);
			} else {
				let length$1 = positions$1[i - 1] + children$1[i - 1].length - groupStart;
				localChildren.push(balanceRange(balanceType, children$1, positions$1, groupFrom, i, groupStart, length$1, null, mkTree));
			}
			localPositions.push(groupStart + offset - start);
		}
	}
	divide(children, positions, from, to, 0);
	return (mkTop || mkTree)(localChildren, localPositions, length);
}
var NodeWeakMap = class {
	constructor() {
		this.map = /* @__PURE__ */ new WeakMap();
	}
	setBuffer(buffer, index$1, value$1) {
		let inner = this.map.get(buffer);
		if (!inner) this.map.set(buffer, inner = /* @__PURE__ */ new Map());
		inner.set(index$1, value$1);
	}
	getBuffer(buffer, index$1) {
		let inner = this.map.get(buffer);
		return inner && inner.get(index$1);
	}
	set(node$1, value$1) {
		if (node$1 instanceof BufferNode) this.setBuffer(node$1.context.buffer, node$1.index, value$1);
		else if (node$1 instanceof TreeNode) this.map.set(node$1.tree, value$1);
	}
	get(node$1) {
		return node$1 instanceof BufferNode ? this.getBuffer(node$1.context.buffer, node$1.index) : node$1 instanceof TreeNode ? this.map.get(node$1.tree) : void 0;
	}
	cursorSet(cursor, value$1) {
		if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value$1);
		else this.map.set(cursor.tree, value$1);
	}
	cursorGet(cursor) {
		return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
	}
};
new NodeProp({ perNode: true });
function toSet(chars) {
	let flat = Object.keys(chars).join("");
	let words = /\w/.test(flat);
	if (words) flat = flat.replace(/\w/g, "");
	return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options$1) {
	let first = Object.create(null), rest = Object.create(null);
	for (let { label } of options$1) {
		first[label[0]] = true;
		for (let i = 1; i < label.length; i++) rest[label[i]] = true;
	}
	let source = toSet(first) + toSet(rest) + "*$";
	return [/* @__PURE__ */ new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
	let options$1 = list.map((o) => typeof o == "string" ? { label: o } : o);
	let [validFor, match] = options$1.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options$1);
	return (context) => {
		let token = context.matchBefore(match);
		return token || context.explicit ? {
			from: token ? token.from : context.pos,
			options: options$1,
			validFor
		} : null;
	};
}
function ifNotIn(nodes, source) {
	return (context) => {
		for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
			if (nodes.indexOf(pos.name) > -1) return null;
			if (pos.type.isTop) break;
		}
		return source(context);
	};
}
var pickedCompletion = /* @__PURE__ */ Annotation.define();
typeof navigator == "object" && navigator.platform;
var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
	".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": {
		fontFamily: "monospace",
		whiteSpace: "nowrap",
		overflow: "hidden auto",
		maxWidth_fallback: "700px",
		maxWidth: "min(700px, 95vw)",
		minWidth: "250px",
		maxHeight: "10em",
		height: "100%",
		listStyle: "none",
		margin: 0,
		padding: 0,
		"& > li, & > completion-section": {
			padding: "1px 3px",
			lineHeight: 1.2
		},
		"& > li": {
			overflowX: "hidden",
			textOverflow: "ellipsis",
			cursor: "pointer"
		},
		"& > completion-section": {
			display: "list-item",
			borderBottom: "1px solid silver",
			paddingLeft: "0.5em",
			opacity: .7
		}
	} },
	"&light .cm-tooltip-autocomplete ul li[aria-selected]": {
		background: "#17c",
		color: "white"
	},
	"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" },
	"&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
		background: "#347",
		color: "white"
	},
	"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" },
	".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
		content: "\"···\"",
		opacity: .5,
		display: "block",
		textAlign: "center"
	},
	".cm-tooltip.cm-completionInfo": {
		position: "absolute",
		padding: "3px 9px",
		width: "max-content",
		maxWidth: `400px`,
		boxSizing: "border-box"
	},
	".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
	".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
	".cm-completionInfo.cm-completionInfo-left-narrow": { right: `30px` },
	".cm-completionInfo.cm-completionInfo-right-narrow": { left: `30px` },
	"&light .cm-snippetField": { backgroundColor: "#00000022" },
	"&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
	".cm-snippetFieldPosition": {
		verticalAlign: "text-top",
		width: 0,
		height: "1.15em",
		display: "inline-block",
		margin: "0 -0.7px -.7em",
		borderLeft: "1.4px dotted #888"
	},
	".cm-completionMatchedText": { textDecoration: "underline" },
	".cm-completionDetail": {
		marginLeft: "0.5em",
		fontStyle: "italic"
	},
	".cm-completionIcon": {
		fontSize: "90%",
		width: ".8em",
		display: "inline-block",
		textAlign: "center",
		paddingRight: ".6em",
		opacity: "0.6",
		boxSizing: "content-box"
	},
	".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'ƒ'" } },
	".cm-completionIcon-class": { "&:after": { content: "'○'" } },
	".cm-completionIcon-interface": { "&:after": { content: "'◌'" } },
	".cm-completionIcon-variable": { "&:after": { content: "'𝑥'" } },
	".cm-completionIcon-constant": { "&:after": { content: "'𝐶'" } },
	".cm-completionIcon-type": { "&:after": { content: "'𝑡'" } },
	".cm-completionIcon-enum": { "&:after": { content: "'∪'" } },
	".cm-completionIcon-property": { "&:after": { content: "'□'" } },
	".cm-completionIcon-keyword": { "&:after": { content: "'🔑︎'" } },
	".cm-completionIcon-namespace": { "&:after": { content: "'▢'" } },
	".cm-completionIcon-text": { "&:after": {
		content: "'abc'",
		fontSize: "50%",
		verticalAlign: "middle"
	} }
});
var FieldPos = class {
	constructor(field, line, from, to) {
		this.field = field;
		this.line = line;
		this.from = from;
		this.to = to;
	}
};
var FieldRange = class FieldRange {
	constructor(field, from, to) {
		this.field = field;
		this.from = from;
		this.to = to;
	}
	map(changes) {
		let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
		let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
		return from == null || to == null ? null : new FieldRange(this.field, from, to);
	}
};
var Snippet = class Snippet {
	constructor(lines, fieldPositions) {
		this.lines = lines;
		this.fieldPositions = fieldPositions;
	}
	instantiate(state, pos) {
		let text$1 = [], lineStart = [pos];
		let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
		for (let line of this.lines) {
			if (text$1.length) {
				let indent$1 = baseIndent, tabs$1 = /^\t*/.exec(line)[0].length;
				for (let i = 0; i < tabs$1; i++) indent$1 += state.facet(indentUnit);
				lineStart.push(pos + indent$1.length - tabs$1);
				line = indent$1 + line.slice(tabs$1);
			}
			text$1.push(line);
			pos += line.length + 1;
		}
		return {
			text: text$1,
			ranges: this.fieldPositions.map((pos$1) => new FieldRange(pos$1.field, lineStart[pos$1.line] + pos$1.from, lineStart[pos$1.line] + pos$1.to))
		};
	}
	static parse(template) {
		let fields = [];
		let lines = [], positions = [], m$1;
		for (let line of template.split(/\r\n?|\n/)) {
			while (m$1 = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
				let seq = m$1[1] ? +m$1[1] : null, name = m$1[2] || m$1[3] || "", found = -1;
				for (let i = 0; i < fields.length; i++) if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;
				if (found < 0) {
					let i = 0;
					while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq)) i++;
					fields.splice(i, 0, {
						seq,
						name
					});
					found = i;
					for (let pos of positions) if (pos.field >= found) pos.field++;
				}
				positions.push(new FieldPos(found, lines.length, m$1.index, m$1.index + name.length));
				line = line.slice(0, m$1.index) + name + line.slice(m$1.index + m$1[0].length);
			}
			for (let esc; esc = /\\([{}])/.exec(line);) {
				line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);
				for (let pos of positions) if (pos.line == lines.length && pos.from > esc.index) {
					pos.from--;
					pos.to--;
				}
			}
			lines.push(line);
		}
		return new Snippet(lines, positions);
	}
};
var fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
	toDOM() {
		let span = document.createElement("span");
		span.className = "cm-snippetFieldPosition";
		return span;
	}
	ignoreEvent() {
		return false;
	}
}() });
var fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class ActiveSnippet {
	constructor(ranges, active$2) {
		this.ranges = ranges;
		this.active = active$2;
		this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
	}
	map(changes) {
		let ranges = [];
		for (let r of this.ranges) {
			let mapped = r.map(changes);
			if (!mapped) return null;
			ranges.push(mapped);
		}
		return new ActiveSnippet(ranges, this.active);
	}
	selectionInsideField(sel) {
		return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
	}
};
var setActive = /* @__PURE__ */ StateEffect.define({ map(value$1, changes) {
	return value$1 && value$1.map(changes);
} });
var moveToField = /* @__PURE__ */ StateEffect.define();
var snippetState = /* @__PURE__ */ StateField.define({
	create() {
		return null;
	},
	update(value$1, tr$1) {
		for (let effect of tr$1.effects) {
			if (effect.is(setActive)) return effect.value;
			if (effect.is(moveToField) && value$1) return new ActiveSnippet(value$1.ranges, effect.value);
		}
		if (value$1 && tr$1.docChanged) value$1 = value$1.map(tr$1.changes);
		if (value$1 && tr$1.selection && !value$1.selectionInsideField(tr$1.selection)) value$1 = null;
		return value$1;
	},
	provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
	return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template) {
	let snippet$1 = Snippet.parse(template);
	return (editor$5, completion, from, to) => {
		let { text: text$1, ranges } = snippet$1.instantiate(editor$5.state, from);
		let spec = {
			changes: {
				from,
				to,
				insert: Text.of(text$1)
			},
			scrollIntoView: true,
			annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
		};
		if (ranges.length) spec.selection = fieldSelection(ranges, 0);
		if (ranges.some((r) => r.field > 0)) {
			let active$2 = new ActiveSnippet(ranges, 0);
			let effects = spec.effects = [setActive.of(active$2)];
			if (editor$5.state.field(snippetState, false) === void 0) effects.push(StateEffect.appendConfig.of([
				snippetState,
				addSnippetKeymap,
				snippetPointerHandler,
				baseTheme
			]));
		}
		editor$5.dispatch(editor$5.state.update(spec));
	};
}
function moveField(dir) {
	return ({ state, dispatch }) => {
		let active$2 = state.field(snippetState, false);
		if (!active$2 || dir < 0 && active$2.active == 0) return false;
		let next = active$2.active + dir, last$2 = dir > 0 && !active$2.ranges.some((r) => r.field == next + dir);
		dispatch(state.update({
			selection: fieldSelection(active$2.ranges, next),
			effects: setActive.of(last$2 ? null : new ActiveSnippet(active$2.ranges, next)),
			scrollIntoView: true
		}));
		return true;
	};
}
var clearSnippet = ({ state, dispatch }) => {
	if (!state.field(snippetState, false)) return false;
	dispatch(state.update({ effects: setActive.of(null) }));
	return true;
};
var defaultSnippetKeymap = [{
	key: "Tab",
	run: /* @__PURE__ */ moveField(1),
	shift: /* @__PURE__ */ moveField(-1)
}, {
	key: "Escape",
	run: clearSnippet
}];
var snippetKeymap = /* @__PURE__ */ Facet.define({ combine(maps) {
	return maps.length ? maps[0] : defaultSnippetKeymap;
} });
var addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion$1(template, completion) {
	return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({ mousedown(event, view) {
	let active$2 = view.state.field(snippetState, false), pos;
	if (!active$2 || (pos = view.posAtCoords({
		x: event.clientX,
		y: event.clientY
	})) == null) return false;
	let match = active$2.ranges.find((r) => r.from <= pos && r.to >= pos);
	if (!match || match.field == active$2.active) return false;
	view.dispatch({
		selection: fieldSelection(active$2.ranges, match.field),
		effects: setActive.of(active$2.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active$2.ranges, match.field) : null),
		scrollIntoView: true
	});
	return true;
} });
var closedBracket = /* @__PURE__ */ new class extends RangeValue {}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
typeof navigator == "object" && navigator.userAgent;
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
	"Script",
	"Body",
	"FunctionDefinition",
	"ClassDefinition",
	"LambdaExpression",
	"ForStatement",
	"MatchClause"
]);
function defID(type) {
	return (node$1, def, outer) => {
		if (outer) return false;
		let id = node$1.node.getChild("VariableName");
		if (id) def(id, type);
		return true;
	};
}
var gatherCompletions = {
	FunctionDefinition: /* @__PURE__ */ defID("function"),
	ClassDefinition: /* @__PURE__ */ defID("class"),
	ForStatement(node$1, def, outer) {
		if (outer) {
			for (let child = node$1.node.firstChild; child; child = child.nextSibling) if (child.name == "VariableName") def(child, "variable");
			else if (child.name == "in") break;
		}
	},
	ImportStatement(_node, def) {
		var _a$1, _b;
		let { node: node$1 } = _node;
		let isFrom = ((_a$1 = node$1.firstChild) === null || _a$1 === void 0 ? void 0 : _a$1.name) == "from";
		for (let ch = node$1.getChild("import"); ch; ch = ch.nextSibling) if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as") def(ch, isFrom ? "variable" : "namespace");
	},
	AssignStatement(node$1, def) {
		for (let child = node$1.node.firstChild; child; child = child.nextSibling) if (child.name == "VariableName") def(child, "variable");
		else if (child.name == ":" || child.name == "AssignOp") break;
	},
	ParamList(node$1, def) {
		for (let prev = null, child = node$1.node.firstChild; child; child = child.nextSibling) {
			if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name))) def(child, "variable");
			prev = child;
		}
	},
	CapturePattern: /* @__PURE__ */ defID("variable"),
	AsPattern: /* @__PURE__ */ defID("variable"),
	__proto__: null
};
function getScope(doc, node$1) {
	let cached = cache.get(node$1);
	if (cached) return cached;
	let completions = [], top = true;
	function def(node$2, type) {
		let name = doc.sliceString(node$2.from, node$2.to);
		completions.push({
			label: name,
			type
		});
	}
	node$1.cursor(IterMode.IncludeAnonymous).iterate((node$2) => {
		if (node$2.name) {
			let gather = gatherCompletions[node$2.name];
			if (gather && gather(node$2, def, top) || !top && ScopeNodes.has(node$2.name)) return false;
			top = false;
		} else if (node$2.to - node$2.from > 8192) {
			for (let c of getScope(doc, node$2.node)) completions.push(c);
			return false;
		}
	});
	cache.set(node$1, completions);
	return completions;
}
var Identifier$1 = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var dontComplete = [
	"String",
	"FormatString",
	"Comment",
	"PropertyName"
];
function localCompletionSource$1(context) {
	let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
	if (dontComplete.indexOf(inner.name) > -1) return null;
	let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier$1.test(context.state.sliceDoc(inner.from, inner.to));
	if (!isWord && !context.explicit) return null;
	let options$1 = [];
	for (let pos = inner; pos; pos = pos.parent) if (ScopeNodes.has(pos.name)) options$1 = options$1.concat(getScope(context.state.doc, pos));
	return {
		options: options$1,
		from: isWord ? inner.from : context.pos,
		validFor: Identifier$1
	};
}
var globals = /* @__PURE__ */ [
	"__annotations__",
	"__builtins__",
	"__debug__",
	"__doc__",
	"__import__",
	"__name__",
	"__loader__",
	"__package__",
	"__spec__",
	"False",
	"None",
	"True"
].map((n) => ({
	label: n,
	type: "constant"
})).concat(/* @__PURE__ */ [
	"ArithmeticError",
	"AssertionError",
	"AttributeError",
	"BaseException",
	"BlockingIOError",
	"BrokenPipeError",
	"BufferError",
	"BytesWarning",
	"ChildProcessError",
	"ConnectionAbortedError",
	"ConnectionError",
	"ConnectionRefusedError",
	"ConnectionResetError",
	"DeprecationWarning",
	"EOFError",
	"Ellipsis",
	"EncodingWarning",
	"EnvironmentError",
	"Exception",
	"FileExistsError",
	"FileNotFoundError",
	"FloatingPointError",
	"FutureWarning",
	"GeneratorExit",
	"IOError",
	"ImportError",
	"ImportWarning",
	"IndentationError",
	"IndexError",
	"InterruptedError",
	"IsADirectoryError",
	"KeyError",
	"KeyboardInterrupt",
	"LookupError",
	"MemoryError",
	"ModuleNotFoundError",
	"NameError",
	"NotADirectoryError",
	"NotImplemented",
	"NotImplementedError",
	"OSError",
	"OverflowError",
	"PendingDeprecationWarning",
	"PermissionError",
	"ProcessLookupError",
	"RecursionError",
	"ReferenceError",
	"ResourceWarning",
	"RuntimeError",
	"RuntimeWarning",
	"StopAsyncIteration",
	"StopIteration",
	"SyntaxError",
	"SyntaxWarning",
	"SystemError",
	"SystemExit",
	"TabError",
	"TimeoutError",
	"TypeError",
	"UnboundLocalError",
	"UnicodeDecodeError",
	"UnicodeEncodeError",
	"UnicodeError",
	"UnicodeTranslateError",
	"UnicodeWarning",
	"UserWarning",
	"ValueError",
	"Warning",
	"ZeroDivisionError"
].map((n) => ({
	label: n,
	type: "type"
}))).concat(/* @__PURE__ */ [
	"bool",
	"bytearray",
	"bytes",
	"classmethod",
	"complex",
	"float",
	"frozenset",
	"int",
	"list",
	"map",
	"memoryview",
	"object",
	"range",
	"set",
	"staticmethod",
	"str",
	"super",
	"tuple",
	"type"
].map((n) => ({
	label: n,
	type: "class"
}))).concat(/* @__PURE__ */ [
	"abs",
	"aiter",
	"all",
	"anext",
	"any",
	"ascii",
	"bin",
	"breakpoint",
	"callable",
	"chr",
	"compile",
	"delattr",
	"dict",
	"dir",
	"divmod",
	"enumerate",
	"eval",
	"exec",
	"exit",
	"filter",
	"format",
	"getattr",
	"globals",
	"hasattr",
	"hash",
	"help",
	"hex",
	"id",
	"input",
	"isinstance",
	"issubclass",
	"iter",
	"len",
	"license",
	"locals",
	"max",
	"min",
	"next",
	"oct",
	"open",
	"ord",
	"pow",
	"print",
	"property",
	"quit",
	"repr",
	"reversed",
	"round",
	"setattr",
	"slice",
	"sorted",
	"sum",
	"vars",
	"zip"
].map((n) => ({
	label: n,
	type: "function"
})));
var snippets$1 = [
	/* @__PURE__ */ snippetCompletion$1("def ${name}(${params}):\n	${}", {
		label: "def",
		detail: "function",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("for ${name} in ${collection}:\n	${}", {
		label: "for",
		detail: "loop",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("while ${}:\n	${}", {
		label: "while",
		detail: "loop",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("try:\n	${}\nexcept ${error}:\n	${}", {
		label: "try",
		detail: "/ except block",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("if ${}:\n	\n", {
		label: "if",
		detail: "block",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("if ${}:\n	${}\nelse:\n	${}", {
		label: "if",
		detail: "/ else block",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
		label: "class",
		detail: "definition",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("import ${module}", {
		label: "import",
		detail: "statement",
		type: "keyword"
	}),
	/* @__PURE__ */ snippetCompletion$1("from ${module} import ${names}", {
		label: "from",
		detail: "import",
		type: "keyword"
	})
];
var globalCompletion = /* @__PURE__ */ ifNotIn(dontComplete, /* @__PURE__ */ completeFromList(/* @__PURE__ */ globals.concat(snippets$1)));
function innerBody(context) {
	let { node: node$1, pos } = context;
	let lineIndent = context.lineIndent(pos, -1);
	let found = null;
	for (;;) {
		let before = node$1.childBefore(pos);
		if (!before) break;
		else if (before.name == "Comment") pos = before.from;
		else if (before.name == "Body") {
			if (context.baseIndentFor(before) + context.unit <= lineIndent) found = before;
			node$1 = before;
		} else if (before.type.is("Statement")) node$1 = before;
		else break;
	}
	return found;
}
function indentBody(context, node$1) {
	let base = context.baseIndentFor(node$1);
	let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
	if (/^\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;
	if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;
	return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ LRLanguage.define({
	name: "python",
	parser: /* @__PURE__ */ parser$1.configure({ props: [/* @__PURE__ */ indentNodeProp.add({
		Body: (context) => {
			var _a$1;
			return (_a$1 = indentBody(context, innerBody(context) || context.node)) !== null && _a$1 !== void 0 ? _a$1 : context.continue();
		},
		IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
		"ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
		TryStatement: (cx) => /^\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
		"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ delimitedIndent({ closing: ")" }),
		"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ delimitedIndent({ closing: "}" }),
		"ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ delimitedIndent({ closing: "]" }),
		"String FormatString": () => null,
		Script: (context) => {
			var _a$1;
			let inner = innerBody(context);
			return (_a$1 = inner && indentBody(context, inner)) !== null && _a$1 !== void 0 ? _a$1 : context.continue();
		}
	}), /* @__PURE__ */ foldNodeProp.add({
		"ArrayExpression DictionaryExpression SetExpression TupleExpression": foldInside,
		Body: (node$1, state) => ({
			from: node$1.from + 1,
			to: node$1.to - (node$1.to == state.doc.length ? 0 : 1)
		})
	})] }),
	languageData: {
		closeBrackets: {
			brackets: [
				"(",
				"[",
				"{",
				"'",
				"\"",
				"'''",
				"\"\"\""
			],
			stringPrefixes: [
				"f",
				"fr",
				"rf",
				"r",
				"u",
				"b",
				"br",
				"rb",
				"F",
				"FR",
				"RF",
				"R",
				"U",
				"B",
				"BR",
				"RB"
			]
		},
		commentTokens: { line: "#" },
		indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
	}
});
function python() {
	return new LanguageSupport(pythonLanguage, [pythonLanguage.data.of({ autocomplete: localCompletionSource$1 }), pythonLanguage.data.of({ autocomplete: globalCompletion })]);
}
function getVisibleLines(view, state = view.state) {
	const lines = /* @__PURE__ */ new Set();
	for (const { from, to } of view.visibleRanges) {
		let pos = from;
		while (pos <= to) {
			const line = state.doc.lineAt(pos);
			if (!lines.has(line)) lines.add(line);
			pos = line.to + 1;
		}
	}
	return lines;
}
function getCurrentLine(state) {
	const currentPos = state.selection.main.head;
	return state.doc.lineAt(currentPos);
}
function numColumns(str, tabSize) {
	let col = 0;
	loop: for (let i = 0; i < str.length; i++) switch (str[i]) {
		case " ":
		case "\xA0":
			col += 1;
			continue loop;
		case "	":
			col += tabSize - col % tabSize;
			continue loop;
		case "\r": continue loop;
		default: break loop;
	}
	return col;
}
var indentationMarkerConfig = /* @__PURE__ */ Facet.define({ combine(configs) {
	return combineConfig(configs, {
		highlightActiveBlock: true,
		hideFirstIndent: false,
		markerType: "fullScope",
		thickness: 1
	});
} });
var IndentationMap = class {
	constructor(lines, state, unitWidth, markerType) {
		this.lines = lines;
		this.state = state;
		this.map = /* @__PURE__ */ new Map();
		this.unitWidth = unitWidth;
		this.markerType = markerType;
		for (const line of this.lines) this.add(line);
		if (this.state.facet(indentationMarkerConfig).highlightActiveBlock) this.findAndSetActiveLines();
	}
	has(line) {
		return this.map.has(typeof line === "number" ? line : line.number);
	}
	get(line) {
		const entry = this.map.get(typeof line === "number" ? line : line.number);
		if (!entry) throw new Error("Line not found in indentation map");
		return entry;
	}
	set(line, col, level) {
		const entry = {
			line,
			col,
			level,
			empty: !line.text.trim().length
		};
		this.map.set(entry.line.number, entry);
		return entry;
	}
	add(line) {
		if (this.has(line)) return this.get(line);
		if (!line.length || !line.text.trim().length) {
			if (line.number === 1) return this.set(line, 0, 0);
			if (line.number === this.state.doc.lines) {
				const prev$1 = this.closestNonEmpty(line, -1);
				return this.set(line, 0, prev$1.level);
			}
			const prev = this.closestNonEmpty(line, -1);
			const next = this.closestNonEmpty(line, 1);
			if (prev.level >= next.level && this.markerType !== "codeOnly") return this.set(line, 0, prev.level);
			if (prev.empty && prev.level === 0 && next.level !== 0) return this.set(line, 0, 0);
			if (next.level > prev.level) return this.set(line, 0, prev.level + 1);
			return this.set(line, 0, next.level);
		}
		const col = numColumns(line.text, this.state.tabSize);
		const level = Math.floor(col / this.unitWidth);
		return this.set(line, col, level);
	}
	closestNonEmpty(from, dir) {
		let lineNo = from.number + dir;
		while (dir === -1 ? lineNo >= 1 : lineNo <= this.state.doc.lines) {
			if (this.has(lineNo)) {
				const entry = this.get(lineNo);
				if (!entry.empty) return entry;
			}
			const line$1 = this.state.doc.line(lineNo);
			if (line$1.text.trim().length) {
				const col = numColumns(line$1.text, this.state.tabSize);
				const level = Math.floor(col / this.unitWidth);
				return this.set(line$1, col, level);
			}
			lineNo += dir;
		}
		const line = this.state.doc.line(dir === -1 ? 1 : this.state.doc.lines);
		return this.set(line, 0, 0);
	}
	findAndSetActiveLines() {
		const currentLine = getCurrentLine(this.state);
		if (!this.has(currentLine)) return;
		let current = this.get(currentLine);
		if (this.has(current.line.number + 1)) {
			const next = this.get(current.line.number + 1);
			if (next.level > current.level) current = next;
		}
		if (this.has(current.line.number - 1)) {
			const prev = this.get(current.line.number - 1);
			if (prev.level > current.level) current = prev;
		}
		if (current.level === 0) return;
		current.active = current.level;
		let start;
		let end;
		for (start = current.line.number; start > 1; start--) {
			if (!this.has(start - 1)) continue;
			const prev = this.get(start - 1);
			if (prev.level < current.level) break;
			prev.active = current.level;
		}
		for (end = current.line.number; end < this.state.doc.lines; end++) {
			if (!this.has(end + 1)) continue;
			const next = this.get(end + 1);
			if (next.level < current.level) break;
			next.active = current.level;
		}
	}
};
function indentTheme(colorOptions) {
	const defaultColors = {
		light: "#F0F1F2",
		dark: "#2B3245",
		activeLight: "#E4E5E6",
		activeDark: "#3C445C"
	};
	let colors = defaultColors;
	if (colorOptions) colors = Object.assign(Object.assign({}, defaultColors), colorOptions);
	return EditorView.baseTheme({
		"&light": {
			"--indent-marker-bg-color": colors.light,
			"--indent-marker-active-bg-color": colors.activeLight
		},
		"&dark": {
			"--indent-marker-bg-color": colors.dark,
			"--indent-marker-active-bg-color": colors.activeDark
		},
		".cm-line": { position: "relative" },
		".cm-indent-markers::before": {
			content: "\"\"",
			position: "absolute",
			top: 0,
			left: `2px`,
			right: 0,
			bottom: 0,
			background: "var(--indent-markers)",
			pointerEvents: "none",
			zIndex: "-1"
		}
	});
}
function createGradient(markerCssProperty, thickness, indentWidth, startOffset, columns) {
	return `${`repeating-linear-gradient(to right, var(${markerCssProperty}) 0 ${thickness}px, transparent ${thickness}px ${indentWidth}ch)`} ${startOffset * indentWidth}.5ch/calc(${indentWidth * columns}ch - 1px) no-repeat`;
}
function makeBackgroundCSS(entry, indentWidth, hideFirstIndent, thickness, activeThickness) {
	const { level, active: active$2 } = entry;
	activeThickness = activeThickness !== null && activeThickness !== void 0 ? activeThickness : thickness;
	if (hideFirstIndent && level === 0) return [];
	const startAt = hideFirstIndent ? 1 : 0;
	const backgrounds = [];
	if (active$2 !== void 0) {
		const markersBeforeActive = active$2 - startAt - 1;
		if (markersBeforeActive > 0) backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, markersBeforeActive));
		backgrounds.push(createGradient("--indent-marker-active-bg-color", activeThickness, indentWidth, active$2 - 1, 1));
		if (active$2 !== level) backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, active$2, level - active$2));
	} else backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, level - startAt));
	return backgrounds.join(",");
}
var IndentMarkersClass = class {
	constructor(view) {
		this.view = view;
		this.unitWidth = getIndentUnit(view.state);
		this.currentLineNumber = getCurrentLine(view.state).number;
		this.generate(view.state);
	}
	update(update) {
		const unitWidth = getIndentUnit(update.state);
		const unitWidthChanged = unitWidth !== this.unitWidth;
		if (unitWidthChanged) this.unitWidth = unitWidth;
		const lineNumber = getCurrentLine(update.state).number;
		const lineNumberChanged = lineNumber !== this.currentLineNumber;
		this.currentLineNumber = lineNumber;
		const activeBlockUpdateRequired = update.state.facet(indentationMarkerConfig).highlightActiveBlock && lineNumberChanged;
		if (update.docChanged || update.viewportChanged || unitWidthChanged || activeBlockUpdateRequired) this.generate(update.state);
	}
	generate(state) {
		const builder = new RangeSetBuilder();
		const lines = getVisibleLines(this.view, state);
		const { hideFirstIndent, markerType, thickness, activeThickness } = state.facet(indentationMarkerConfig);
		const map = new IndentationMap(lines, state, this.unitWidth, markerType);
		for (const line of lines) {
			const entry = map.get(line.number);
			if (!(entry === null || entry === void 0 ? void 0 : entry.level)) continue;
			const backgrounds = makeBackgroundCSS(entry, this.unitWidth, hideFirstIndent, thickness, activeThickness);
			builder.add(line.from, line.from, Decoration.line({
				class: "cm-indent-markers",
				attributes: { style: `--indent-markers: ${backgrounds}` }
			}));
		}
		this.decorations = builder.finish();
	}
};
function indentationMarkers(config = {}) {
	return [
		indentationMarkerConfig.of(config),
		indentTheme(config.colors),
		ViewPlugin.fromClass(IndentMarkersClass, { decorations: (v$1) => v$1.decorations })
	];
}
const NODE_TYPES_EXCLUDED_FROM_AUTOCOMPLETION = [STICKY_NODE_TYPE];
const AUTOCOMPLETABLE_BUILT_IN_MODULES_JS = [
	"console",
	"constants",
	"crypto",
	"dns",
	"dns/promises",
	"fs",
	"fs/promises",
	"http",
	"http2",
	"https",
	"inspector",
	"module",
	"os",
	"path",
	"process",
	"readline",
	"url",
	"util",
	"zlib"
];
const DEFAULT_LINTER_SEVERITY = "error";
const CODE_PLACEHOLDERS = {
	javaScript: {
		runOnceForAllItems: `
// Loop over input items and add a new field called 'myNewField' to the JSON of each one
for (const item of $input.all()) {
  item.json.myNewField = 1;
}

return $input.all();`.trim(),
		runOnceForEachItem: `
// Add a new field called 'myNewField' to the JSON of the item
$input.item.json.myNewField = 1;

return $input.item;`.trim()
	},
	python: {
		runOnceForAllItems: `
# Loop over input items and add a new field called 'myNewField' to the JSON of each one
for item in _input.all():
  item.json.myNewField = 1
return _input.all()`.trim(),
		runOnceForEachItem: `
# Add a new field called 'myNewField' to the JSON of the item
_input.item.json.myNewField = 1
return _input.item`.trim()
	},
	pythonNative: {
		runOnceForAllItems: `
# Loop over input items and add a new field called 'my_new_field' to the JSON of each one
for item in _items:
  item["json"]["my_new_field"] = 1
return _items`.trim(),
		runOnceForEachItem: `
# Add a new field called 'my_new_field' to the JSON of the item
_item["json"]["my_new_field"] = 1
return _item`.trim()
	}
};
function walk(node$1, test, found = []) {
	const isProgram = node$1.type === Syntax.Program;
	if (!isProgram && test(node$1)) found.push(node$1);
	if (isProgram) node$1.body.forEach((n) => walk(n, test, found));
	else for (const key in node$1) {
		if (!(key in node$1)) continue;
		const child = node$1[key];
		if (child === null || typeof child !== "object") continue;
		if (Array.isArray(child)) child.filter(Boolean).forEach((n) => walk(n, test, found));
		else walk(child, test, found);
	}
	return found;
}
const escape$2 = (str) => str.replace("$", "\\$").replace("(", "\\(").replace(")", "\\)").replace("[", "\\[").replace("]", "\\]");
const addInfoRenderer = (option$1) => {
	const { info } = option$1;
	if (typeof info === "string") option$1.info = () => {
		const wrapper$3 = document.createElement("span");
		wrapper$3.innerHTML = sanitizeHtml(info);
		return wrapper$3;
	};
	return option$1;
};
var DOT_CHAINS = /((?:\.[A-Za-z_$][A-Za-z0-9_$]*)+)/g;
var DOT_KEY = /\.(?<key>[A-Za-z_$][A-Za-z0-9_$]*)/g;
var toBracketNotation = (input$5) => {
	return input$5.replace(DOT_CHAINS, (chain) => chain.replace(DOT_KEY, "[\"$<key>\"]"));
};
var pythonInsert = (value$1, mode) => {
	if (value$1.includes("$(")) return "";
	return toBracketNotation(mode === "runOnceForAllItems" ? value$1.replace("$json", "_items[0][\"json\"]") : value$1.replace("$json", "_item[\"json\"]"));
};
var pyodideInsert = (value$1, mode) => {
	return value$1.replace("$json", mode === "runOnceForAllItems" ? "_input.first().json" : "_input.item.json").replace(/\$\((.*)\)\.item/, mode === "runOnceForAllItems" ? "_($1).first()" : "_($1).item");
};
var jsInsertForAllItems = (value$1) => {
	return value$1.replace("$json", "$input.first().json").replace(/\$\((.*)\)\.item/, "$($1).first()");
};
var isPyodide = (language) => language === "python";
var isPython = (language) => language === "pythonNative";
const valueToInsert = (value$1, language, mode) => {
	if (isPython(language)) return pythonInsert(value$1, mode);
	if (isPyodide(language)) return pyodideInsert(value$1, mode);
	if (mode === "runOnceForAllItems") return jsInsertForAllItems(value$1);
	return value$1;
};
var escape$3 = (str) => str.replace("$", "\\$");
const addVarType = (option$1) => ({
	...option$1,
	type: "variable"
});
function useVariablesCompletions() {
	const environmentsStore = useEnvironmentsStore();
	const variablesCompletions = (context, matcher = "$vars") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$3(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = environmentsStore.scopedVariables.map((variable) => ({
			label: `${matcher}.${variable.key}`,
			info: variable.value
		}));
		return {
			from: preCursor.from,
			options: options$1.map(addVarType)
		};
	};
	return { variablesCompletions };
}
function getAutoCompletableNodeNames(nodes) {
	return nodes.filter((node$1) => !NODE_TYPES_EXCLUDED_FROM_AUTOCOMPLETION.includes(node$1.type)).map((node$1) => node$1.name);
}
function useBaseCompletions(mode, language) {
	const i18n$1 = useI18n();
	const workflowsStore = useWorkflowsStore();
	const itemCompletions = (context) => {
		const preCursor = context.matchBefore(/i\w*/);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [];
		if (mode === "runOnceForEachItem") options$1.push({
			label: "item",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.item")
		});
		else if (mode === "runOnceForAllItems") options$1.push({
			label: "items",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.all")
		});
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	const baseCompletions = (context) => {
		const prefix = language === "python" ? "_" : "$";
		const preCursor = context.matchBefore(/* @__PURE__ */ new RegExp(`\\${prefix}\\w*`));
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [
			{
				label: `${prefix}execution`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution")
			},
			{
				label: `${prefix}ifEmpty()`,
				info: i18n$1.baseText("codeNodeEditor.completer.$ifEmpty")
			},
			{
				label: `${prefix}input`,
				info: i18n$1.baseText("codeNodeEditor.completer.$input")
			},
			{
				label: `${prefix}prevNode`,
				info: i18n$1.baseText("codeNodeEditor.completer.$prevNode")
			},
			{
				label: `${prefix}workflow`,
				info: i18n$1.baseText("codeNodeEditor.completer.$workflow")
			},
			{
				label: `${prefix}vars`,
				info: i18n$1.baseText("codeNodeEditor.completer.$vars")
			},
			{
				label: `${prefix}now`,
				info: i18n$1.baseText("codeNodeEditor.completer.$now")
			},
			{
				label: `${prefix}today`,
				info: i18n$1.baseText("codeNodeEditor.completer.$today")
			},
			{
				label: `${prefix}jmespath()`,
				info: i18n$1.baseText("codeNodeEditor.completer.$jmespath")
			},
			{
				label: `${prefix}runIndex`,
				info: i18n$1.baseText("codeNodeEditor.completer.$runIndex")
			},
			{
				label: `${prefix}nodeVersion`,
				info: i18n$1.baseText("codeNodeEditor.completer.$nodeVersion")
			}
		].map(addVarType);
		options$1.push(...getAutoCompletableNodeNames(workflowsStore.allNodes).map((nodeName) => {
			return {
				label: `${prefix}('${escapeMappingString(nodeName)}')`,
				type: "variable",
				info: i18n$1.baseText("codeNodeEditor.completer.$()", { interpolate: { nodeName } })
			};
		}));
		if (mode === "runOnceForEachItem") {
			const TOP_LEVEL_COMPLETIONS_IN_SINGLE_ITEM_MODE = [
				{ label: `${prefix}json` },
				{ label: `${prefix}binary` },
				{
					label: `${prefix}itemIndex`,
					info: i18n$1.baseText("codeNodeEditor.completer.$itemIndex")
				}
			];
			options$1.push(...TOP_LEVEL_COMPLETIONS_IN_SINGLE_ITEM_MODE.map(addVarType));
		}
		return {
			from: preCursor.from,
			options: options$1.map(addInfoRenderer)
		};
	};
	const nodeSelectorCompletions = (context) => {
		const prefix = language === "python" ? "_" : "$";
		const preCursor = context.matchBefore(/* @__PURE__ */ new RegExp(`\\${prefix}\\(.*`));
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = getAutoCompletableNodeNames(workflowsStore.allNodes).map((nodeName) => {
			return {
				label: `${prefix}('${escapeMappingString(nodeName)}')`,
				type: "variable",
				info: i18n$1.baseText("codeNodeEditor.completer.$()", { interpolate: { nodeName } })
			};
		});
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	return {
		itemCompletions,
		baseCompletions,
		nodeSelectorCompletions
	};
}
const jsSnippets = completeFromList$1([
	...snippets.filter((snippet$1) => snippet$1.label !== "class"),
	snippetCompletion("console.log(${arg})", { label: "console.log()" }),
	snippetCompletion("DateTime", { label: "DateTime" }),
	snippetCompletion("Interval", { label: "Interval" }),
	snippetCompletion("Duration", { label: "Duration" })
]);
function useExecutionCompletions() {
	const i18n$1 = useI18n();
	const executionCompletions = (context, matcher = "$execution") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [
			{
				label: `${matcher}.id`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.id")
			},
			{
				label: `${matcher}.mode`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.mode")
			},
			{
				label: `${matcher}.resumeUrl`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.resumeUrl")
			},
			{
				label: `${matcher}.resumeFormUrl`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.resumeFormUrl")
			},
			{
				label: `${matcher}.customData.set("key", "value")`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.customData.set")
			},
			{
				label: `${matcher}.customData.get("key")`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.customData.get")
			},
			{
				label: `${matcher}.customData.setAll({})`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.customData.setAll")
			},
			{
				label: `${matcher}.customData.getAll()`,
				info: i18n$1.baseText("codeNodeEditor.completer.$execution.customData.getAll")
			}
		];
		return {
			from: preCursor.from,
			options: options$1.map(addVarType).map(addInfoRenderer)
		};
	};
	return { executionCompletions };
}
function useItemFieldCompletions(language) {
	const i18n$1 = useI18n();
	const matcherItemFieldCompletions = (context, matcher, variablesToValues) => {
		const preCursor = context.matchBefore(/* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`));
		if (!preCursor) return null;
		const [varName] = preCursor.text.split(".");
		if (!variablesToValues[varName]) return null;
		const options$1 = [{
			label: `${matcher}.json`,
			info: i18n$1.baseText("codeNodeEditor.completer.json")
		}, {
			label: `${matcher}.binary`,
			info: i18n$1.baseText("codeNodeEditor.completer.binary")
		}];
		return {
			from: preCursor.from,
			options: options$1.map(addVarType)
		};
	};
	const inputMethodCompletions = (context) => {
		const prefix = language === "python" ? "_" : "$";
		const patterns = {
			first: /* @__PURE__ */ new RegExp(`\\${prefix}input\\.first\\(\\)\\..*`),
			last: /* @__PURE__ */ new RegExp(`\\${prefix}input\\.last\\(\\)\\..*`),
			item: /* @__PURE__ */ new RegExp(`\\${prefix}input\\.item\\..*`),
			all: /\$input\.all\(\)\[(?<index>\w+)\]\..*/
		};
		for (const [name, regex] of Object.entries(patterns)) {
			const preCursor = context.matchBefore(regex);
			if (!preCursor || preCursor.from === preCursor.to && !context.explicit) continue;
			let replacementBase = "";
			if (name === "item") replacementBase = `${prefix}input.item`;
			if (name === "first") replacementBase = `${prefix}input.first()`;
			if (name === "last") replacementBase = `${prefix}input.last()`;
			if (name === "all") {
				const match = preCursor.text.match(regex);
				if (!match?.groups?.index) continue;
				const { index: index$1 } = match.groups;
				replacementBase = `${prefix}input.all()[${index$1}]`;
			}
			const options$1 = [{
				label: `${replacementBase}.json`,
				info: i18n$1.baseText("codeNodeEditor.completer.json")
			}, {
				label: `${replacementBase}.binary`,
				info: i18n$1.baseText("codeNodeEditor.completer.binary")
			}];
			return {
				from: preCursor.from,
				options: options$1.map(addVarType).map(addInfoRenderer)
			};
		}
		return null;
	};
	const selectorMethodCompletions = (context, matcher = null) => {
		for (const [name, regex] of Object.entries({
			first: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.first\(\)\..*/,
			last: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.last\(\)\..*/,
			item: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.item\..*/,
			all: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.all\(\)\[(?<index>\w+)\]\..*/
		})) {
			const preCursor = context.matchBefore(regex);
			if (!preCursor || preCursor.from === preCursor.to && !context.explicit) continue;
			const match = preCursor.text.match(regex);
			let start = "";
			if (!matcher && match?.groups?.quotedNodeName) start = `$(${match.groups.quotedNodeName})`;
			let replacementBase = "";
			if (name === "item") replacementBase = `${start}.item`;
			if (name === "first") replacementBase = `${start}.first()`;
			if (name === "last") replacementBase = `${start}.last()`;
			if (name === "all") {
				const match$1 = preCursor.text.match(regex);
				if (!match$1?.groups?.index) continue;
				replacementBase = `${start}.all()[${match$1.groups.index}]`;
			}
			const options$1 = [{
				label: `${replacementBase}.json`,
				info: i18n$1.baseText("codeNodeEditor.completer.json")
			}, {
				label: `${replacementBase}.binary`,
				info: i18n$1.baseText("codeNodeEditor.completer.binary")
			}];
			return {
				from: preCursor.from,
				options: options$1.map(addVarType)
			};
		}
		return null;
	};
	return {
		matcherItemFieldCompletions,
		inputMethodCompletions,
		selectorMethodCompletions
	};
}
function useItemIndexCompletions(mode) {
	const i18n$1 = useI18n();
	const inputCompletions = (context, matcher = "$input") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [];
		if (toValue(mode) === "runOnceForAllItems") options$1.push({
			label: `${matcher}.first()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.first")
		}, {
			label: `${matcher}.last()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.last")
		}, {
			label: `${matcher}.all()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.all")
		}, {
			label: `${matcher}.itemMatching()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.itemMatching")
		});
		if (toValue(mode) === "runOnceForEachItem") options$1.push({
			label: `${matcher}.item`,
			type: "variable",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.item")
		});
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	const selectorCompletions = (context, matcher = null) => {
		const pattern = matcher === null ? /\$\((?<quotedNodeName>['"][\S\s]+['"])\)\..*/ : /* @__PURE__ */ new RegExp(`${matcher}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const match = preCursor.text.match(pattern);
		let replacementBase = "";
		if (matcher === null && match?.groups?.quotedNodeName) replacementBase = `$(${match.groups.quotedNodeName})`;
		else if (matcher) replacementBase = matcher;
		const options$1 = [{
			label: `${replacementBase}.params`,
			type: "variable",
			info: i18n$1.baseText("codeNodeEditor.completer.selector.params")
		}, {
			label: `${replacementBase}.context`,
			type: "variable",
			info: i18n$1.baseText("codeNodeEditor.completer.selector.context")
		}];
		if (toValue(mode) === "runOnceForAllItems") options$1.push({
			label: `${replacementBase}.first()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.first")
		}, {
			label: `${replacementBase}.last()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.last")
		}, {
			label: `${replacementBase}.all()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.$input.all")
		}, {
			label: `${replacementBase}.itemMatching()`,
			type: "function",
			info: i18n$1.baseText("codeNodeEditor.completer.selector.itemMatching")
		});
		if (toValue(mode) === "runOnceForEachItem") options$1.push({
			label: `${replacementBase}.item`,
			type: "variable",
			info: i18n$1.baseText("codeNodeEditor.completer.selector.item")
		});
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	return {
		inputCompletions,
		selectorCompletions
	};
}
function useJsonFieldCompletions() {
	const i18n$1 = useI18n();
	const ndvStore = useNDVStore();
	const workflowsStore = useWorkflowsStore();
	const matcherJsonFieldCompletions = (context, matcher, variablesToValues) => {
		const pattern = /* @__PURE__ */ new RegExp(`(${escape$2(matcher)})\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const inputNodeName = getInputNodeName();
		if (!inputNodeName) return null;
		const [varName] = preCursor.text.split(".");
		const originalValue = variablesToValues[varName];
		if (!originalValue) return null;
		for (const accessor of [
			"first",
			"last",
			"item"
		]) if (originalValue.includes(accessor) || preCursor.text.includes(accessor)) {
			const jsonOutput = getJsonOutput(inputNodeName, { accessor });
			if (!jsonOutput) return null;
			return toJsonFieldCompletions(preCursor, jsonOutput, matcher);
		}
		if (originalValue.includes("all")) {
			const match = originalValue.match(/\$(input|\(.*\))\.all\(\)\[(?<index>.+)\]$/);
			if (!match?.groups?.index) return null;
			const { index: index$1 } = match.groups;
			const jsonOutput = getJsonOutput(inputNodeName, { index: Number(index$1) });
			if (!jsonOutput) return null;
			return toJsonFieldCompletions(preCursor, jsonOutput, matcher);
		}
		return null;
	};
	const inputJsonFieldCompletions = (context) => {
		for (const [name, regex] of Object.entries({
			first: /\$input\.first\(\)\.json(\[|\.).*/,
			last: /\$input\.last\(\)\.json(\[|\.).*/,
			item: /\$input\.item\.json(\[|\.).*/,
			all: /\$input\.all\(\)\[(?<index>\w+)\]\.json(\[|\.).*/
		})) {
			const preCursor = context.matchBefore(regex);
			if (!preCursor || preCursor.from === preCursor.to && !context.explicit) continue;
			const inputNodeName = getInputNodeName();
			if (!inputNodeName) continue;
			if (name === "first" || name === "last") {
				const jsonOutput = getJsonOutput(inputNodeName, { accessor: name });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, `$input.${name}().json`);
			}
			if (name === "item") {
				const jsonOutput = getJsonOutput(inputNodeName, { accessor: "item" });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, "$input.item.json");
			}
			if (name === "all") {
				const match = preCursor.text.match(regex);
				if (!match?.groups?.index) continue;
				const { index: index$1 } = match.groups;
				const jsonOutput = getJsonOutput(inputNodeName, { index: Number(index$1) });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, `$input.all()[${index$1}].json`);
			}
		}
		return null;
	};
	const selectorJsonFieldCompletions = (context) => {
		for (const [name, regex] of Object.entries({
			first: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.first\(\)\.json(\[|\.).*/,
			last: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.last\(\)\.json(\[|\.).*/,
			item: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.item\.json(\[|\.).*/,
			all: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.all\(\)\[(?<index>\w+)\]\.json(\[|\.).*/
		})) {
			const preCursor = context.matchBefore(regex);
			if (!preCursor || preCursor.from === preCursor.to && !context.explicit) continue;
			const match = preCursor.text.match(regex);
			if (!match?.groups?.quotedNodeName) continue;
			const { quotedNodeName } = match.groups;
			const selector = `$(${match.groups.quotedNodeName})`;
			if (name === "first" || name === "last") {
				const jsonOutput = getJsonOutput(quotedNodeName, { accessor: name });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, `${selector}.${name}().json`);
			}
			if (name === "item") {
				const jsonOutput = getJsonOutput(quotedNodeName, { accessor: "item" });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, `${selector}.item.json`);
			}
			if (name === "all") {
				const regexMatch = preCursor.text.match(regex);
				if (!regexMatch?.groups?.index) continue;
				const { index: index$1 } = regexMatch.groups;
				const jsonOutput = getJsonOutput(quotedNodeName, { index: Number(index$1) });
				if (!jsonOutput) continue;
				return toJsonFieldCompletions(preCursor, jsonOutput, `${selector}.all()[${index$1}].json`);
			}
		}
		return null;
	};
	const getInputNodeName = () => {
		try {
			const activeNode = ndvStore.activeNode;
			if (activeNode) {
				const input$5 = workflowsStore.connectionsByDestinationNode[activeNode.name];
				return input$5.main[0] ? input$5.main[0][0].node : null;
			}
		} catch (e) {
			console.error(e);
			return null;
		}
		return null;
	};
	const toJsonFieldCompletions = (preCursor, jsonOutput, matcher) => {
		if (/\.json\[/.test(preCursor.text) || (/* @__PURE__ */ new RegExp(`(${escape$2(matcher)})\\[`)).test(preCursor.text)) {
			const options$1 = Object.keys(jsonOutput).map((field) => `${matcher}['${field}']`).map((label) => ({
				label,
				info: i18n$1.baseText("codeNodeEditor.completer.json")
			}));
			return {
				from: preCursor.from,
				options: options$1
			};
		}
		if (/\.json\./.test(preCursor.text) || (/* @__PURE__ */ new RegExp(`(${escape$2(matcher)})\.`)).test(preCursor.text)) {
			const options$1 = Object.keys(jsonOutput).filter(isAllowedInDotNotation).map((field) => `${matcher}.${field}`).map((label) => ({
				label,
				info: i18n$1.baseText("codeNodeEditor.completer.json")
			}));
			return {
				from: preCursor.from,
				options: options$1
			};
		}
		return null;
	};
	const getJsonOutput = (quotedNodeName, options$1) => {
		let nodeName = quotedNodeName;
		const isSingleQuoteWrapped = quotedNodeName.startsWith("'") && quotedNodeName.endsWith("'");
		const isDoubleQuoteWrapped = quotedNodeName.startsWith("\"") && quotedNodeName.endsWith("\"");
		if (isSingleQuoteWrapped) nodeName = quotedNodeName.replace(/^'/, "").replace(/'$/, "");
		else if (isDoubleQuoteWrapped) nodeName = quotedNodeName.replace(/^"/, "").replace(/"$/, "");
		const nodePinData = useWorkflowsStore().pinnedWorkflowData?.[nodeName];
		if (nodePinData) try {
			let itemIndex = options$1?.index ?? 0;
			if (options$1?.accessor === "last") itemIndex = nodePinData.length - 1;
			return nodePinData[itemIndex].json;
		} catch {}
		const nodeRunData = useWorkflowsStore().getWorkflowRunData?.[nodeName];
		if (!nodeRunData) return null;
		try {
			let itemIndex = options$1?.index ?? 0;
			if (options$1?.accessor === "last") itemIndex = (nodeRunData[0].data?.main[0] ?? []).length - 1;
			return nodeRunData[0].data?.main[0]?.[itemIndex].json;
		} catch {
			return null;
		}
	};
	return {
		matcherJsonFieldCompletions,
		inputJsonFieldCompletions,
		selectorJsonFieldCompletions
	};
}
function useLuxonCompletions() {
	const todayCompletions = (context, matcher = "$today") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		return {
			from: preCursor.from,
			options: instanceCompletions(matcher)
		};
	};
	const nowCompletions = (context, matcher = "$now") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		return {
			from: preCursor.from,
			options: instanceCompletions(matcher)
		};
	};
	const dateTimeCompletions = (context, matcher = "DateTime") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$2(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = Object.entries(luxonStaticDocs.functions).filter(([_$2, { doc }]) => doc && !doc.hidden).map(([method, { doc }]) => {
			return {
				label: `DateTime.${method}()`,
				type: "function",
				info: createInfoBoxRenderer(doc, true)
			};
		});
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	const instanceCompletions = (matcher) => {
		return Object.entries(luxonInstanceDocs.properties).filter(([_$2, { doc }]) => doc && !doc.hidden).map(([getter, { doc }]) => {
			return {
				label: `${matcher}.${getter}`,
				info: createInfoBoxRenderer(doc)
			};
		}).concat(Object.entries(luxonInstanceDocs.functions).filter(([_$2, { doc }]) => doc && !doc.hidden).map(([method, { doc }]) => {
			return {
				label: `${matcher}.${method}()`,
				info: createInfoBoxRenderer(doc, true)
			};
		}));
	};
	return {
		todayCompletions,
		nowCompletions,
		dateTimeCompletions
	};
}
var DEFAULT_MATCHER = "$prevNode";
var escape$1 = (str) => str.replace("$", "\\$");
function usePrevNodeCompletions(matcher = DEFAULT_MATCHER) {
	const i18n$1 = useI18n();
	const prevNodeCompletions = (context) => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape$1(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [
			{
				label: `${matcher}.name`,
				info: i18n$1.baseText("codeNodeEditor.completer.$prevNode.name")
			},
			{
				label: `${matcher}.outputIndex`,
				info: i18n$1.baseText("codeNodeEditor.completer.$prevNode.outputIndex")
			},
			{
				label: `${matcher}.runIndex`,
				info: i18n$1.baseText("codeNodeEditor.completer.$prevNode.runIndex")
			}
		];
		return {
			from: preCursor.from,
			options: options$1.map(addVarType)
		};
	};
	return { prevNodeCompletions };
}
function useRequireCompletions() {
	const allowedModules = useSettingsStore().allowedModules;
	const toOption = (moduleName) => ({
		label: `require('${moduleName}');`,
		type: "variable"
	});
	const requireCompletions = (context) => {
		const preCursor = context.matchBefore(/req.*/);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [];
		if (allowedModules.builtIn) {
			if (allowedModules.builtIn.includes("*")) options$1.push(...AUTOCOMPLETABLE_BUILT_IN_MODULES_JS.map(toOption));
			else if (allowedModules?.builtIn?.length > 0) options$1.push(...allowedModules.builtIn.map(toOption));
		}
		if (allowedModules.external) {
			if (allowedModules?.external?.length > 0) options$1.push(...allowedModules.external.map(toOption));
		}
		return {
			from: preCursor.from,
			options: options$1
		};
	};
	return { requireCompletions };
}
var escape = (str) => str.replace("$", "\\$");
function useWorkflowCompletions() {
	const i18n$1 = useI18n();
	const workflowCompletions = (context, matcher = "$workflow") => {
		const pattern = /* @__PURE__ */ new RegExp(`${escape(matcher)}\..*`);
		const preCursor = context.matchBefore(pattern);
		if (!preCursor || preCursor.from === preCursor.to && !context.explicit) return null;
		const options$1 = [
			{
				label: `${matcher}.id`,
				info: i18n$1.baseText("codeNodeEditor.completer.$workflow.id")
			},
			{
				label: `${matcher}.name`,
				info: i18n$1.baseText("codeNodeEditor.completer.$workflow.name")
			},
			{
				label: `${matcher}.active`,
				info: i18n$1.baseText("codeNodeEditor.completer.$workflow.active")
			}
		];
		return {
			from: preCursor.from,
			options: options$1.map(addVarType)
		};
	};
	return { workflowCompletions };
}
const useCompleter = (mode, editor$5) => {
	function autocompletionExtension(language) {
		if (language === "pythonNative") {
			const completions$1 = (context) => {
				const word = context.matchBefore(/\w*/);
				if (!word) return null;
				const options$1 = [];
				const label = toValue(mode) === "runOnceForEachItem" ? "_item" : "_items";
				options$1.push({
					label,
					type: "variable"
				});
				options$1.push({
					label: "print",
					type: "function"
				});
				return {
					from: word.from,
					options: options$1
				};
			};
			return autocompletion({
				icons: false,
				override: [completions$1]
			});
		}
		const { baseCompletions, itemCompletions, nodeSelectorCompletions } = useBaseCompletions(toValue(mode), language);
		const { executionCompletions } = useExecutionCompletions();
		const { inputMethodCompletions, selectorMethodCompletions } = useItemFieldCompletions(language);
		const { inputCompletions, selectorCompletions } = useItemIndexCompletions(mode);
		const { inputJsonFieldCompletions, selectorJsonFieldCompletions } = useJsonFieldCompletions();
		const { dateTimeCompletions, nowCompletions, todayCompletions } = useLuxonCompletions();
		const { prevNodeCompletions } = usePrevNodeCompletions();
		const { requireCompletions } = useRequireCompletions();
		const { variablesCompletions } = useVariablesCompletions();
		const { workflowCompletions } = useWorkflowCompletions();
		const completions = [];
		if (language === "javaScript") completions.push(jsSnippets, localCompletionSource);
		return autocompletion({
			icons: false,
			compareCompletions: (a, b$1) => {
				if (/\.json$|id$|id['"]\]$/.test(a.label)) return 0;
				return a.label.localeCompare(b$1.label);
			},
			override: [
				...completions,
				itemCompletions,
				baseCompletions,
				requireCompletions,
				nodeSelectorCompletions,
				prevNodeCompletions,
				workflowCompletions,
				variablesCompletions,
				executionCompletions,
				todayCompletions,
				nowCompletions,
				dateTimeCompletions,
				inputCompletions,
				selectorCompletions,
				inputMethodCompletions,
				selectorMethodCompletions,
				inputJsonFieldCompletions,
				selectorJsonFieldCompletions,
				multilineCompletions
			]
		});
	}
	function multilineCompletions(context) {
		const editorValue = toValue(editor$5);
		if (!editorValue) return null;
		let variablesToValueMap = {};
		try {
			variablesToValueMap = variablesToValues();
		} catch {
			return null;
		}
		if (Object.keys(variablesToValueMap).length === 0) return null;
		const uses = extendedUses(editorValue.state.doc.toString().split("\n"), Object.keys(variablesToValueMap));
		const { matcherItemFieldCompletions } = useItemFieldCompletions("javaScript");
		for (const use of uses.itemField) {
			const completions = matcherItemFieldCompletions(context, use.replace(/\.$/, ""), variablesToValueMap);
			if (completions) return completions;
		}
		for (const use of uses.jsonField) {
			const completions = matcherItemFieldCompletions(context, use.replace(/(\.|\[)$/, ""), variablesToValueMap);
			if (completions) return completions;
		}
		const SELECTOR_REGEX = /^\$\((?<quotedNodeName>['"][\w\s]+['"])\)$/;
		const INPUT_METHOD_REGEXES = Object.values({
			first: /\$input\.first\(\)$/,
			last: /\$input\.last\(\)$/,
			item: /\$input\.item$/,
			all: /\$input\.all\(\)\[(?<index>\w+)\]$/
		});
		const SELECTOR_METHOD_REGEXES = Object.values({
			first: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.first\(\)$/,
			last: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.last\(\)$/,
			item: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.item$/,
			all: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.all\(\)\[(?<index>\w+)\]$/
		});
		const INPUT_JSON_REGEXES = Object.values({
			first: /\$input\.first\(\)\.json$/,
			last: /\$input\.last\(\)\.json$/,
			item: /\$input\.item\.json$/,
			all: /\$input\.all\(\)\[(?<index>\w+)\]\.json$/
		});
		const SELECTOR_JSON_REGEXES = Object.values({
			first: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.first\(\)\.json$/,
			last: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.last\(\)\.json$/,
			item: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.item\.json$/,
			all: /\$\((?<quotedNodeName>['"][\w\s]+['"])\)\.all\(\)\[(?<index>\w+)\]\.json$/
		});
		const { executionCompletions } = useExecutionCompletions();
		const { inputCompletions, selectorCompletions } = useItemIndexCompletions(mode);
		const { matcherJsonFieldCompletions } = useJsonFieldCompletions();
		const { dateTimeCompletions, nowCompletions, todayCompletions } = useLuxonCompletions();
		const { variablesCompletions } = useVariablesCompletions();
		const { workflowCompletions } = useWorkflowCompletions();
		for (const [variable, value$1] of Object.entries(variablesToValueMap)) {
			const { prevNodeCompletions } = usePrevNodeCompletions(variable);
			if (value$1 === "$execution") return executionCompletions(context, variable);
			if (value$1 === "$vars") return variablesCompletions(context, variable);
			if (value$1 === "$workflow") return workflowCompletions(context, variable);
			if (value$1 === "$prevNode") return prevNodeCompletions(context);
			if (value$1 === "$now") return nowCompletions(context, variable);
			if (value$1 === "$today") return todayCompletions(context, variable);
			if (value$1 === "DateTime") return dateTimeCompletions(context, variable);
			if (value$1 === "$input") return inputCompletions(context, variable);
			if (SELECTOR_REGEX.test(value$1)) return selectorCompletions(context, variable);
			const inputJsonMatched = INPUT_JSON_REGEXES.some((regex) => regex.test(value$1));
			const selectorJsonMatched = SELECTOR_JSON_REGEXES.some((regex) => regex.test(value$1));
			if (inputJsonMatched || selectorJsonMatched) return matcherJsonFieldCompletions(context, variable, variablesToValueMap);
			const inputMethodMatched = INPUT_METHOD_REGEXES.some((regex) => regex.test(value$1));
			const selectorMethodMatched = SELECTOR_METHOD_REGEXES.some((regex) => regex.test(value$1));
			if (inputMethodMatched || selectorMethodMatched) return matcherItemFieldCompletions(context, variable, variablesToValueMap);
		}
		return null;
	}
	function variablesToValues() {
		return variableDeclarationLines().reduce((acc, line) => {
			const [left, right] = line.split("=");
			const varName = left.replace(/(var|let|const)/, "").trim();
			acc[varName] = right.replace(/;/, "").trim();
			return acc;
		}, {});
	}
	function variableDeclarationLines() {
		const editorValue = toValue(editor$5);
		if (!editorValue) return [];
		const docLines = editorValue.state.doc.toString().split("\n");
		const isVariableDeclarationLine = (line) => [
			"var",
			"const",
			"let"
		].some((varType) => line.startsWith(varType));
		return docLines.filter(isVariableDeclarationLine);
	}
	function extendedUses(docLines, varNames) {
		return docLines.reduce((acc, cur) => {
			varNames.forEach((varName) => {
				const accessorPattern = `(${varName}.first\\(\\)|${varName}.last\\(\\)|${varName}.item|${varName}.all\\(\\)\\[\\w+\\]).*`;
				const methodMatch = cur.match(new RegExp(accessorPattern));
				if (methodMatch) if (/json(\.|\[)$/.test(methodMatch[0])) acc.jsonField.push(methodMatch[0]);
				else acc.itemField.push(methodMatch[0]);
				const jsonPattern = `^${varName}\\.json(\\.|\\[)$`;
				const jsonMatch = cur.match(new RegExp(jsonPattern));
				if (jsonMatch) acc.jsonField.push(jsonMatch[0]);
			});
			return acc;
		}, {
			itemField: [],
			jsonField: []
		});
	}
	return { autocompletionExtension };
};
var import_debounce$1 = /* @__PURE__ */ __toESM(require_debounce());
const useCodeEditor = ({ editorRef, editorValue, language, languageParams, placeholder, targetNodeParameterContext = void 0, extensions = [], isReadOnly = false, theme = {}, onChange = () => {}, id = v4_default() }) => {
	const editor$5 = ref();
	const hasFocus = ref(false);
	const hasChanges = ref(false);
	const selection = ref(EditorSelection.cursor(0));
	const customExtensions = ref(new Compartment());
	const readOnlyExtensions = ref(new Compartment());
	const telemetryExtensions = ref(new Compartment());
	const languageExtensions = ref(new Compartment());
	const themeExtensions = ref(new Compartment());
	const autocompleteStatus = ref(null);
	const dragging$2 = ref(false);
	const storedStateFields = {
		fold: foldState,
		history: historyField
	};
	const storedStateId = computed(() => `${toValue(id)}.editorState`);
	const mode = computed(() => {
		const params = toValue(languageParams);
		return params && "mode" in params ? params.mode : "runOnceForAllItems";
	});
	const { createWorker: createTsWorker } = useTypescript(editor$5, mode, id, targetNodeParameterContext);
	function getInitialLanguageExtensions(lang) {
		switch (lang) {
			case "javaScript": return [javascript()];
			default: return [];
		}
	}
	async function getFullLanguageExtensions() {
		if (!editor$5.value) return [];
		const lang = toValue(language);
		const langExtensions = [languageFacet.of(lang === "pythonNative" ? "python" : lang)];
		switch (lang) {
			case "javaScript": {
				const tsExtension = await createTsWorker();
				langExtensions.push(tsExtension);
				break;
			}
			case "python":
			case "pythonNative": {
				const pythonAutocomplete = useCompleter(mode, editor$5.value ?? null).autocompletionExtension(lang);
				langExtensions.push([python(), pythonAutocomplete]);
				break;
			}
			case "json":
				langExtensions.push(json());
				break;
			case "html":
				langExtensions.push(html());
				break;
		}
		return langExtensions;
	}
	function readEditorValue() {
		return editor$5.value?.state.doc.toString() ?? "";
	}
	function updateSelection(update) {
		const currentSelection = selection.value;
		const newSelection = update.state.selection.ranges[0];
		if (!currentSelection?.eq(newSelection)) selection.value = newSelection;
	}
	const emitChanges = (0, import_debounce$1.default)(onChange, 300);
	function onEditorUpdate(update) {
		autocompleteStatus.value = completionStatus(update.view.state);
		updateSelection(update);
		const shouldIgnoreUpdate = update.transactions.some((tr$1) => tr$1.annotation(ignoreUpdateAnnotation));
		if (update.docChanged && !shouldIgnoreUpdate) {
			hasChanges.value = true;
			emitChanges(update);
		}
	}
	function blur() {
		if (editor$5.value) {
			editor$5.value.contentDOM.blur();
			closeCompletion(editor$5.value);
			closeCursorInfoBox(editor$5.value);
		}
	}
	function blurOnClickOutside(event) {
		if (!dragging$2.value && !isEventTargetContainedBy(event.target, editor$5.value?.dom)) blur();
		dragging$2.value = false;
	}
	async function setLanguageExtensions() {
		if (!editor$5.value) return;
		const initialExtensions = getInitialLanguageExtensions(toValue(language));
		if (initialExtensions.length > 0) editor$5.value.dispatch({ effects: languageExtensions.value.reconfigure(initialExtensions) });
		editor$5.value.dispatch({ effects: languageExtensions.value.reconfigure(await getFullLanguageExtensions()) });
	}
	function getReadOnlyExtensions() {
		return [
			EditorState.readOnly.of(toValue(isReadOnly)),
			EditorView.editable.of(!toValue(isReadOnly)),
			highlightSpecialChars()
		];
	}
	function setReadOnlyExtensions() {
		if (!editor$5.value) return;
		editor$5.value.dispatch({ effects: readOnlyExtensions.value.reconfigure([getReadOnlyExtensions()]) });
	}
	watch(toRef(editorRef), async () => {
		const parent$2 = toValue(editorRef);
		if (!parent$2) return;
		const initialValue = toValue(editorValue) ? toValue(editorValue) : toValue(placeholder);
		const allExtensions = [
			customExtensions.value.of(toValue(extensions)),
			readOnlyExtensions.value.of(getReadOnlyExtensions()),
			telemetryExtensions.value.of([]),
			languageExtensions.value.of(getInitialLanguageExtensions(toValue(language))),
			themeExtensions.value.of(codeEditorTheme(toValue(theme))),
			EditorView.updateListener.of(onEditorUpdate),
			EditorView.focusChangeEffect.of((_$2, newHasFocus) => {
				hasFocus.value = newHasFocus;
				selection.value = state.selection.ranges[0];
				if (!newHasFocus) autocompleteStatus.value = null;
				return null;
			}),
			EditorState.allowMultipleSelections.of(true),
			EditorView.clickAddsSelectionRange.of((event) => event.altKey && !event.metaKey && !event.shiftKey),
			EditorView.contentAttributes.of({ "data-gramm": "false" }),
			EditorView.domEventHandlers({ mousedown: () => {
				dragging$2.value = true;
			} }),
			highlightSelectionMatches({ minSelectionLength: 2 }),
			lineNumbers(),
			drawSelection(),
			foldGutter({ markerDOM: (open) => {
				const svgNS = "http://www.w3.org/2000/svg";
				const wrapper$3 = document.createElement("div");
				wrapper$3.classList.add("cm-fold-marker");
				const svgElement = document.createElementNS(svgNS, "svg");
				svgElement.setAttribute("viewBox", "0 0 10 10");
				svgElement.setAttribute("width", "10");
				svgElement.setAttribute("height", "10");
				const pathElement = document.createElementNS(svgNS, "path");
				const d = open ? "M1 3 L5 7 L9 3" : "M3 1 L7 5 L3 9";
				pathElement.setAttribute("d", d);
				pathElement.setAttribute("fill", "none");
				pathElement.setAttribute("stroke", "currentColor");
				pathElement.setAttribute("stroke-width", "1.5");
				pathElement.setAttribute("stroke-linecap", "round");
				svgElement.appendChild(pathElement);
				wrapper$3.appendChild(svgElement);
				return wrapper$3;
			} }),
			EditorView.lineWrapping,
			history(),
			dropCursor(),
			indentOnInput(),
			bracketMatching(),
			closeBrackets(),
			highlightActiveLine(),
			highlightActiveLineGutter(),
			mappingDropCursor(),
			indentationMarkers({
				highlightActiveBlock: true,
				markerType: "fullScope",
				colors: {
					activeDark: "var(--code--indentation-marker--color--active)",
					activeLight: "var(--code--indentation-marker--color--active)",
					dark: "var(--code--indentation-marker--color)",
					light: "var(--code--indentation-marker--color)"
				}
			}),
			keymap.of(editorKeymap),
			keymap.of(closeBracketsKeymap)
		];
		const parsedStoredState = jsonParse(localStorage.getItem(storedStateId.value) ?? "", { fallbackValue: null });
		const config = {
			doc: initialValue,
			extensions: allExtensions
		};
		const state = parsedStoredState && parsedStoredState.doc === initialValue ? EditorState.fromJSON(parsedStoredState, config, storedStateFields) : EditorState.create(config);
		if (editor$5.value) editor$5.value.destroy();
		editor$5.value = new EditorView({
			parent: parent$2,
			state,
			scrollTo: EditorView.scrollIntoView(state.selection.main, { y: "center" })
		});
		editor$5.value.dispatch({ effects: languageExtensions.value.reconfigure(await getFullLanguageExtensions()) });
	});
	watch(extensions, () => {
		if (editor$5.value) editor$5.value.dispatch({ effects: customExtensions.value.reconfigure(toValue(extensions)) });
	});
	watch(toRef(language), setLanguageExtensions);
	watch(toRef(isReadOnly), setReadOnlyExtensions);
	watch(toRef(theme), () => {
		if (editor$5.value) editor$5.value.dispatch({ effects: themeExtensions.value.reconfigure(codeEditorTheme(toValue(theme))) });
	});
	watch(toRef(editorValue), () => {
		if (!editor$5.value || hasFocus.value) return;
		const newValue = toValue(editorValue);
		const currentValue = readEditorValue();
		if (newValue === void 0 || newValue === currentValue) return;
		editor$5.value.dispatch({ changes: {
			from: 0,
			to: currentValue.length,
			insert: newValue
		} });
	});
	onMounted(() => {
		document.addEventListener("click", blurOnClickOutside);
	});
	onBeforeUnmount(() => {
		document.removeEventListener("click", blurOnClickOutside);
		if (editor$5.value) {
			const stateToStore = editor$5.value.state.toJSON(storedStateFields);
			try {
				localStorage.setItem(storedStateId.value, JSON.stringify(stateToStore));
			} catch (error) {
				localStorage.removeItem(storedStateId.value);
			}
			emitChanges.flush();
			editor$5.value.destroy();
		}
	});
	function setCursorPosition(pos) {
		const finalPos = pos === "end" ? editor$5.value?.state.doc.length ?? 0 : pos;
		editor$5.value?.dispatch({ selection: {
			head: finalPos,
			anchor: finalPos
		} });
	}
	function select$1(anchor, head = "end") {
		editor$5.value?.dispatch({ selection: {
			anchor,
			head: head === "end" ? editor$5.value?.state.doc.length ?? 0 : head
		} });
	}
	function getLine(lineNumber) {
		if (!editor$5.value) return;
		const { doc } = editor$5.value.state;
		switch (lineNumber) {
			case "first": return doc.lineAt(0);
			case "last": return doc.lineAt(doc.length - 1);
			default: return doc.line(lineNumber);
		}
	}
	function selectLine(lineNumber) {
		if (!editor$5.value) return;
		const line = getLine(lineNumber);
		if (!line) return;
		editor$5.value.dispatch({ selection: EditorSelection.range(line.from, line.to) });
	}
	function highlightLine(lineNumber) {
		if (!editor$5.value) return;
		const line = getLine(lineNumber);
		if (!line) return;
		editor$5.value.dispatch({ selection: EditorSelection.cursor(line.from) });
	}
	const selectAll = () => select$1(0, "end");
	function focus() {
		if (hasFocus.value) return;
		editor$5.value?.focus();
	}
	return {
		editor: editor$5,
		hasFocus,
		hasChanges,
		selection,
		readEditorValue,
		setCursorPosition,
		select: select$1,
		selectLine,
		selectAll,
		highlightLine,
		focus,
		blur
	};
};
var import_snakeCase = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createCompounder()(function(result, word, index$1) {
		return result + (index$1 ? "_" : "") + word.toLowerCase();
	});
})))());
var _hoisted_1$27 = ["textContent"];
var _hoisted_2$13 = ["textContent"];
var _hoisted_3$9 = ["textContent"];
var _hoisted_4$7 = ["textContent"];
var _hoisted_5$4 = ["textContent"];
var _hoisted_6$3 = ["textContent"];
var _hoisted_7$1 = ["textContent"];
var AskAI_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AskAI",
	props: {
		hasChanges: { type: Boolean },
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"submit",
		"replaceCode",
		"startedLoading",
		"finishedLoading"
	],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const props = __props;
		const { getSchemaForExecutionData, getInputDataWithPinned } = useDataSchema();
		const i18n$1 = useI18n();
		const loadingPhraseIndex = ref(0);
		const loaderProgress = ref(0);
		const isLoading = ref(false);
		const prompt = ref("");
		const parentNodes = ref([]);
		const isSubmitEnabled = computed(() => {
			return !isEachItemMode.value && prompt.value.length >= 15 && hasExecutionData.value;
		});
		const hasExecutionData = computed(() => (useNDVStore().ndvInputDataWithPinnedData || []).length > 0);
		const loadingString = computed(() => i18n$1.baseText(`codeNodeEditor.askAi.loadingPhrase${loadingPhraseIndex.value}`));
		const isEachItemMode = computed(() => {
			return useNDVStore().activeNode?.parameters.mode === "runOnceForEachItem";
		});
		function getErrorMessageByStatusCode(statusCode, message) {
			return {
				[413]: i18n$1.baseText("codeNodeEditor.askAi.generationFailedTooLarge"),
				[400]: i18n$1.baseText("codeNodeEditor.askAi.generationFailedUnknown"),
				[429]: i18n$1.baseText("codeNodeEditor.askAi.generationFailedRate"),
				[500]: message ? i18n$1.baseText("codeNodeEditor.askAi.generationFailedWithReason", { interpolate: { error: message } }) : i18n$1.baseText("codeNodeEditor.askAi.generationFailedUnknown")
			}[statusCode] || i18n$1.baseText("codeNodeEditor.askAi.generationFailedUnknown");
		}
		function getParentNodes$1() {
			const activeNode = useNDVStore().activeNode;
			const { workflowObject, getNodeByName } = useWorkflowsStore();
			if (!activeNode || !workflowObject) return [];
			return workflowObject.getParentNodesByDepth(activeNode?.name).filter(({ name }, i, nodes) => {
				return name !== activeNode.name && nodes.findIndex((node$1) => node$1.name === name) === i;
			}).map((n) => getNodeByName(n.name)).filter((n) => n !== null);
		}
		function getSchemas() {
			const parentNodesNames = parentNodes.value.map((node$1) => node$1?.name);
			const parentNodesSchemas = parentNodes.value.map((node$1) => {
				const inputData = getInputDataWithPinned(node$1);
				return {
					nodeName: node$1?.name || "",
					schema: getSchemaForExecutionData(executionDataToJson(inputData), true)
				};
			}).filter((node$1) => node$1.schema?.value.length > 0);
			return {
				parentNodesNames,
				inputSchema: parentNodesSchemas.shift() ?? {
					nodeName: parentNodesNames[0] ?? "",
					schema: {
						path: "",
						type: "undefined",
						value: ""
					}
				},
				parentNodesSchemas
			};
		}
		function startLoading() {
			emit("startedLoading");
			loaderProgress.value = 0;
			isLoading.value = true;
			triggerLoadingChange();
		}
		function stopLoading() {
			loaderProgress.value = 100;
			emit("finishedLoading");
			setTimeout(() => {
				isLoading.value = false;
			}, 200);
		}
		async function onSubmit() {
			const { restApiContext } = useRootStore();
			const { activeNode } = useNDVStore();
			const { showMessage } = useToast();
			const { alert } = useMessage();
			if (!activeNode) return;
			const schemas = getSchemas();
			if (props.hasChanges) {
				if (await alert(i18n$1.baseText("codeNodeEditor.askAi.areYouSureToReplace"), {
					title: i18n$1.baseText("codeNodeEditor.askAi.replaceCurrentCode"),
					confirmButtonText: i18n$1.baseText("codeNodeEditor.askAi.generateCodeAndReplace"),
					showClose: true,
					showCancelButton: true
				}) === "cancel") return;
			}
			startLoading();
			const rootStore = useRootStore();
			const payload = {
				question: prompt.value,
				context: {
					schema: schemas.parentNodesSchemas,
					inputSchema: schemas.inputSchema,
					ndvPushRef: useNDVStore().pushRef,
					pushRef: rootStore.pushRef
				},
				forNode: "code"
			};
			try {
				const { code } = await generateCodeForPrompt(restApiContext, payload);
				stopLoading();
				emit("replaceCode", code);
				showMessage({
					type: "success",
					title: i18n$1.baseText("codeNodeEditor.askAi.generationCompleted")
				});
				useTelemetry().trackAskAI("askAi.generationFinished", {
					prompt: prompt.value,
					code
				});
			} catch (error) {
				showMessage({
					type: "error",
					title: i18n$1.baseText("codeNodeEditor.askAi.generationFailed"),
					message: getErrorMessageByStatusCode(error.httpStatusCode || error?.response.status, error?.message)
				});
				stopLoading();
				useTelemetry().trackAskAI("askAi.generationFinished", {
					prompt: prompt.value,
					code: "",
					hasError: true
				});
			}
		}
		function triggerLoadingChange() {
			const loadingPhraseUpdateMs = 2e3;
			const loadingPhrasesCount = 8;
			let start = null;
			let lastPhraseChange = 0;
			const step = (timestamp) => {
				if (!start) start = timestamp;
				if (!lastPhraseChange || timestamp - lastPhraseChange >= loadingPhraseUpdateMs) {
					loadingPhraseIndex.value = randomInt(loadingPhrasesCount);
					lastPhraseChange = timestamp;
				}
				const elapsed = timestamp - start;
				loaderProgress.value = Math.min(elapsed / ASK_AI_LOADING_DURATION_MS * 100, 100);
				if (!isLoading.value) return;
				if (loaderProgress.value < 100 || lastPhraseChange + loadingPhraseUpdateMs > timestamp) window.requestAnimationFrame(step);
			};
			window.requestAnimationFrame(step);
		}
		function getSessionStoragePrompt() {
			return useSessionStorage(`ask_ai_prompt__${(0, import_snakeCase.default)(useNDVStore().activeNode?.name ?? "")}`, "");
		}
		function onPromptInput(inputValue) {
			getSessionStoragePrompt().value = inputValue;
		}
		onMounted(() => {
			prompt.value = getSessionStoragePrompt().value;
			parentNodes.value = getParentNodes$1();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [
				createBaseVNode("p", {
					class: normalizeClass(_ctx.$style.intro),
					textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.intro"))
				}, null, 10, _hoisted_1$27),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.inputContainer) }, [createVNode(unref(N8nInput_default), {
					modelValue: prompt.value,
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => prompt.value = $event),
					class: normalizeClass(_ctx.$style.input),
					type: "textarea",
					rows: 6,
					maxlength: unref(600),
					placeholder: unref(i18n$1).baseText("codeNodeEditor.askAi.placeholder"),
					"data-test-id": "ask-ai-prompt-input",
					readonly: props.isReadOnly,
					onInput: onPromptInput
				}, null, 8, [
					"modelValue",
					"class",
					"maxlength",
					"placeholder",
					"readonly"
				]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.meta) }, [withDirectives(createBaseVNode("span", {
					class: normalizeClass(_ctx.$style.counter),
					"data-test-id": "ask-ai-prompt-counter",
					textContent: toDisplayString(`${prompt.value.length} / ${unref(600)}`)
				}, null, 10, _hoisted_2$13), [[vShow, prompt.value.length > 1]]), createBaseVNode("a", {
					href: "https://docs.n8n.io/code-examples/ai-code",
					target: "_blank",
					class: normalizeClass(_ctx.$style.help)
				}, [createVNode(unref(N8nIcon_default), {
					icon: "circle-help",
					color: "text-light",
					size: "large"
				}), createTextVNode(toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.help")), 1)], 2)], 2)], 2),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.controls) }, [isLoading.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.loader)
				}, [createVNode(Transition, {
					name: "text-fade-in-out",
					mode: "out-in"
				}, {
					default: withCtx(() => [(openBlock(), createElementBlock("div", {
						key: loadingPhraseIndex.value,
						textContent: toDisplayString(loadingString.value)
					}, null, 8, _hoisted_3$9))]),
					_: 1
				}), createVNode(unref(N8nCircleLoader_default), {
					radius: 8,
					progress: loaderProgress.value,
					"stroke-width": 3
				}, null, 8, ["progress"])], 2)) : (openBlock(), createBlock(unref(N8nTooltip_default), {
					key: 1,
					disabled: isSubmitEnabled.value
				}, {
					content: withCtx(() => [!hasExecutionData.value ? (openBlock(), createElementBlock("span", {
						key: 0,
						"data-test-id": "ask-ai-cta-tooltip-no-input-data",
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.noInputData"))
					}, null, 8, _hoisted_4$7)) : prompt.value.length === 0 ? (openBlock(), createElementBlock("span", {
						key: 1,
						"data-test-id": "ask-ai-cta-tooltip-no-prompt",
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.noPrompt"))
					}, null, 8, _hoisted_5$4)) : isEachItemMode.value ? (openBlock(), createElementBlock("span", {
						key: 2,
						"data-test-id": "ask-ai-cta-tooltip-only-all-items-mode",
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.onlyAllItemsMode"))
					}, null, 8, _hoisted_6$3)) : prompt.value.length < unref(15) ? (openBlock(), createElementBlock("span", {
						key: 3,
						"data-test-id": "ask-ai-cta-tooltip-prompt-too-short",
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.promptTooShort", { interpolate: { minLength: unref(15).toString() } }))
					}, null, 8, _hoisted_7$1)) : createCommentVNode("", true)]),
					default: withCtx(() => [createBaseVNode("div", null, [createVNode(unref(N8nButton_default), {
						disabled: !isSubmitEnabled.value,
						size: "small",
						"data-test-id": "ask-ai-cta",
						onClick: onSubmit
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.generateCode")), 1)]),
						_: 1
					}, 8, ["disabled"])])]),
					_: 1
				}, 8, ["disabled"]))], 2)
			]);
		};
	}
});
var AskAI_vue_vue_type_style_index_1_lang_module_default = {
	input: "_input_zopl1_123",
	intro: "_intro_zopl1_148",
	loader: "_loader_zopl1_155",
	inputContainer: "_inputContainer_zopl1_163",
	help: "_help_zopl1_167",
	meta: "_meta_zopl1_176",
	counter: "_counter_zopl1_189",
	controls: "_controls_zopl1_193"
};
var AskAI_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AskAI_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AskAI_vue_vue_type_style_index_1_lang_module_default }], ["__scopeId", "data-v-fae93ed8"]]);
const useLinter = (mode, language) => {
	const i18n$1 = useI18n();
	const linter$1 = computed(() => {
		switch (toValue(language)) {
			case "javaScript": return linter(lintSource, { delay: 500 });
		}
		return [];
	});
	function lintSource(editorView) {
		const script = `module.exports = async function() {${editorView.state.doc.toString()}\n}()`;
		let ast = null;
		try {
			ast = parseScript(script, { range: true });
		} catch (syntaxError) {
			return [];
		}
		if (ast === null) return [];
		const lintings = [];
		if (toValue(mode) === "runOnceForEachItem") {
			const isItemCall = (node$1) => node$1.type === "CallExpression" && node$1.callee.type === "MemberExpression" && node$1.callee.property.type === "Identifier" && node$1.callee.property.name === "item";
			walk(ast, isItemCall).forEach((node$1) => {
				const [start, end] = getRange(node$1);
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.allItems.itemCall"),
					actions: [{
						name: "Fix",
						apply(view, _$2, to) {
							view.dispatch({ changes: {
								from: end - 2,
								to
							} });
						}
					}]
				});
			});
		}
		if (toValue(mode) === "runOnceForAllItems") {
			const isUnavailableVarInAllItems = (node$1) => node$1.type === "Identifier" && [
				"$json",
				"$binary",
				"$itemIndex"
			].includes(node$1.name);
			walk(ast, isUnavailableVarInAllItems).forEach((node$1) => {
				const [start, end] = getRange(node$1);
				const varName = getText(editorView, node$1);
				if (!varName) return;
				const message = [`\`${varName}\``, i18n$1.baseText("codeNodeEditor.linter.allItems.unavailableVar")].join(" ");
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message,
					actions: [{
						name: "Remove",
						apply(view, from, to) {
							view.dispatch({ changes: {
								from,
								to
							} });
						}
					}]
				});
			});
		}
		if (toValue(mode) === "runOnceForAllItems") {
			const isInputIdentifier = (node$1) => node$1.type === "Identifier" && node$1.name === "$input";
			const isPreviousNodeCall = (node$1) => node$1.type === "CallExpression" && node$1.callee.type === "Identifier" && node$1.callee.name === "$";
			const isDirectMemberExpression = (node$1) => node$1.type === "MemberExpression" && !node$1.computed;
			const isItemIdentifier = (node$1) => node$1.type === "Identifier" && node$1.name === "item";
			const isUnavailableInputItemAccess = (node$1) => isDirectMemberExpression(node$1) && (isInputIdentifier(node$1.object) || isPreviousNodeCall(node$1.object)) && isItemIdentifier(node$1.property);
			walk(ast, isUnavailableInputItemAccess).forEach((node$1) => {
				const [start, end] = getRange(node$1.property);
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.allItems.unavailableProperty"),
					actions: [{
						name: "Fix",
						apply(view) {
							view.dispatch({ changes: {
								from: start,
								to: end,
								insert: "first()"
							} });
						}
					}]
				});
			});
		}
		if (toValue(mode) === "runOnceForEachItem" && !/(let|const|var) items =/.test(script)) {
			const isUnavailableLegacyItems = (node$1) => node$1.type === "Identifier" && node$1.name === "items";
			walk(ast, isUnavailableLegacyItems).forEach((node$1) => {
				const [start, end] = getRange(node$1);
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.eachItem.unavailableItems"),
					actions: [{
						name: "Fix",
						apply(view, from, to) {
							if (view.state.doc.toString().slice(from, to).includes("$input.item")) return;
							view.dispatch({ changes: {
								from: start,
								to: end
							} });
							view.dispatch({ changes: {
								from,
								insert: "$input.item"
							} });
						}
					}]
				});
			});
		}
		if (toValue(mode) === "runOnceForEachItem") {
			const isUnavailableMethodinEachItem = (node$1) => node$1.type === "MemberExpression" && !node$1.computed && node$1.object.type === "Identifier" && node$1.object.name === "$input" && node$1.property.type === "Identifier" && [
				"first",
				"last",
				"all",
				"itemMatching"
			].includes(node$1.property.name);
			walk(ast, isUnavailableMethodinEachItem).forEach((node$1) => {
				const [start, end] = getRange(node$1.property);
				const method = getText(editorView, node$1.property);
				if (!method) return;
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.eachItem.unavailableMethod", { interpolate: { method } })
				});
			});
		}
		if (toValue(mode) === "runOnceForAllItems") {
			const isItemMatchingCallWithoutArg = (node$1) => node$1.type === "CallExpression" && node$1.callee.type === "MemberExpression" && node$1.callee.property.type === "Identifier" && node$1.callee.property.name === "itemMatching" && node$1.arguments.length === 0;
			walk(ast, isItemMatchingCallWithoutArg).forEach((node$1) => {
				const [start, end] = getRange(node$1.callee.property);
				lintings.push({
					from: start,
					to: end + 2,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.allItems.itemMatchingNoArg")
				});
			});
		}
		if (toValue(mode) === "runOnceForAllItems") {
			const inputFirstOrLastCalledWithArg = (node$1) => node$1.type === "CallExpression" && node$1.callee.type === "MemberExpression" && !node$1.callee.computed && node$1.callee.object.type === "Identifier" && node$1.callee.object.name === "$input" && node$1.callee.property.type === "Identifier" && ["first", "last"].includes(node$1.callee.property.name) && node$1.arguments.length !== 0;
			walk(ast, inputFirstOrLastCalledWithArg).forEach((node$1) => {
				const [start, end] = getRange(node$1.callee.property);
				const message = [`\`$input.${node$1.callee.property.name}()\``, i18n$1.baseText("codeNodeEditor.linter.allItems.firstOrLastCalledWithArg")].join(" ");
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message
				});
			});
		}
		const isEmptyReturn = (node$1) => node$1.type === "ReturnStatement" && node$1.argument === null;
		const emptyReturnMessage = toValue(mode) === "runOnceForAllItems" ? i18n$1.baseText("codeNodeEditor.linter.allItems.emptyReturn") : i18n$1.baseText("codeNodeEditor.linter.eachItem.emptyReturn");
		walk(ast, isEmptyReturn).forEach((node$1) => {
			const [start, end] = node$1.range.map((loc) => loc - 35);
			lintings.push({
				from: start,
				to: end,
				severity: DEFAULT_LINTER_SEVERITY,
				message: emptyReturnMessage
			});
		});
		if (toValue(mode) === "runOnceForEachItem") {
			const isArrayReturn = (node$1) => node$1.type === "ReturnStatement" && node$1.argument !== null && node$1.argument !== void 0 && node$1.argument.type === "ArrayExpression";
			walk(ast, isArrayReturn).forEach((node$1) => {
				const [start, end] = getRange(node$1);
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.eachItem.returnArray")
				});
			});
		}
		if (toValue(mode) === "runOnceForAllItems") {
			const isForOfStatementOverN8nVar = (node$1) => node$1.type === "ForOfStatement" && node$1.left.type === "VariableDeclaration" && node$1.left.declarations.length === 1 && node$1.left.declarations[0].type === "VariableDeclarator" && node$1.left.declarations[0].id.type === "Identifier" && node$1.right.type === "CallExpression" && node$1.right.callee.type === "MemberExpression" && !node$1.right.callee.computed && node$1.right.callee.object.type === "Identifier" && node$1.right.callee.object.name.startsWith("$");
			const found = walk(ast, isForOfStatementOverN8nVar);
			if (found.length === 1) {
				const itemAlias = found[0].left.declarations[0].id.name;
				const isShadowItemVar = (node$1) => node$1.type === "VariableDeclarator" && node$1.id.type === "Identifier" && node$1.id.name === "item" && node$1.init !== null;
				const shadowFound = walk(ast, isShadowItemVar);
				let shadowStart;
				if (shadowFound.length > 0) {
					const [shadow] = shadowFound;
					const [_shadowStart] = getRange(shadow);
					shadowStart = _shadowStart;
				}
				const isDirectAccessToItem = (node$1) => node$1.type === "MemberExpression" && node$1.object.type === "Identifier" && node$1.object.name === itemAlias && node$1.property.type === "Identifier" && !["json", "binary"].includes(node$1.property.name);
				walk(ast, isDirectAccessToItem).forEach((node$1) => {
					const [start, end] = getRange(node$1);
					if (shadowStart && start > shadowStart) return;
					if (!getText(editorView, node$1)) return;
					lintings.push({
						from: start,
						to: end,
						severity: DEFAULT_LINTER_SEVERITY,
						message: i18n$1.baseText("codeNodeEditor.linter.bothModes.directAccess.itemProperty"),
						actions: [{
							name: "Fix",
							apply(view, from, to) {
								if (view.state.doc.toString().slice(from, to).includes(".json")) return;
								view.dispatch({ changes: {
									from: from + itemAlias.length,
									insert: ".json"
								} });
							}
						}]
					});
				});
			}
		}
		if (toValue(mode) === "runOnceForEachItem") {
			const isDirectAccessToItemSubproperty = (node$1) => node$1.type === "MemberExpression" && node$1.object.type === "MemberExpression" && node$1.object.property.type === "Identifier" && node$1.object.property.name === "item" && node$1.property.type === "Identifier" && !["json", "binary"].includes(node$1.property.name);
			walk(ast, isDirectAccessToItemSubproperty).forEach((node$1) => {
				if (!getText(editorView, node$1)) return;
				const [start, end] = getRange(node$1);
				const [, fixEnd] = getRange(node$1.object.property);
				lintings.push({
					from: start,
					to: end,
					severity: DEFAULT_LINTER_SEVERITY,
					message: i18n$1.baseText("codeNodeEditor.linter.bothModes.directAccess.itemProperty"),
					actions: [{
						name: "Fix",
						apply(view, from, to) {
							if (view.state.doc.toString().slice(from, to).includes(".json")) return;
							view.dispatch({ changes: {
								from: fixEnd,
								insert: ".json"
							} });
						}
					}]
				});
			});
		}
		const isDirectAccessToFirstOrLastCall = (node$1) => node$1.type === "MemberExpression" && node$1.property.type === "Identifier" && !["json", "binary"].includes(node$1.property.name) && node$1.object.type === "CallExpression" && node$1.object.arguments.length === 0 && node$1.object.callee.type === "MemberExpression" && node$1.object.callee.property.type === "Identifier" && ["first", "last"].includes(node$1.object.callee.property.name);
		walk(ast, isDirectAccessToFirstOrLastCall).forEach((node$1) => {
			const [start, end] = getRange(node$1);
			const [, fixEnd] = getRange(node$1.object);
			lintings.push({
				from: start,
				to: end,
				severity: DEFAULT_LINTER_SEVERITY,
				message: i18n$1.baseText("codeNodeEditor.linter.bothModes.directAccess.firstOrLastCall"),
				actions: [{
					name: "Fix",
					apply(view, from, to) {
						if (view.state.doc.toString().slice(from, to).includes(".json")) return;
						view.dispatch({ changes: {
							from: fixEnd,
							insert: ".json"
						} });
					}
				}]
			});
		});
		const isDollarSignWithVariable = (node$1) => node$1.type === "CallExpression" && node$1.callee.type === "Identifier" && node$1.callee.name === "$" && node$1.arguments.length === 1 && (node$1.arguments[0].type !== "Literal" && node$1.arguments[0].type !== "TemplateLiteral" || node$1.arguments[0].type === "TemplateLiteral" && node$1.arguments[0].expressions.length > 0);
		walk(ast, isDollarSignWithVariable).forEach((node$1) => {
			const [start, end] = getRange(node$1);
			lintings.push({
				from: start,
				to: end,
				severity: "warning",
				message: i18n$1.baseText("codeNodeEditor.linter.bothModes.dollarSignVariable")
			});
		});
		if (toValue(mode) === "runOnceForEachItem") {
			const isDollarNodeItemAccess = (node$1) => node$1.type === "MemberExpression" && !node$1.computed && node$1.object.type === "CallExpression" && node$1.object.callee.type === "Identifier" && node$1.object.callee.name === "$" && node$1.object.arguments.length === 1 && node$1.object.arguments[0].type === "Literal" && node$1.property.type === "Identifier" && node$1.property.name === "item";
			walk(ast, isDollarNodeItemAccess).forEach((node$1) => {
				const [start, end] = getRange(node$1.property);
				lintings.push({
					from: start,
					to: end,
					severity: "warning",
					message: i18n$1.baseText("codeNodeEditor.linter.eachItem.preferFirst"),
					actions: [{
						name: "Fix",
						apply(view) {
							view.dispatch({ changes: {
								from: start,
								to: end,
								insert: "first()"
							} });
						}
					}]
				});
			});
		}
		return lintings;
	}
	function getText(editorView, node$1) {
		const [start, end] = getRange(node$1);
		return editorView.state.doc.toString().slice(start, end);
	}
	function getRange(node$1) {
		return node$1.range.map((loc) => loc - 35);
	}
	return linter$1;
};
var CodeNodeEditor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CodeNodeEditor",
	props: {
		mode: {},
		modelValue: {},
		aiButtonEnabled: {
			type: Boolean,
			default: false
		},
		fillParent: {
			type: Boolean,
			default: false
		},
		language: { default: "javaScript" },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		rows: { default: 4 },
		id: { default: () => crypto.randomUUID() },
		targetNodeParameterContext: { default: void 0 },
		disableAskAi: {
			type: Boolean,
			default: false
		}
	},
	emits: ["update:modelValue"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const message = useMessage();
		const tabs$1 = ref(["code", "ask-ai"]);
		const activeTab = ref("code");
		const isLoadingAIResponse = ref(false);
		const codeNodeEditorRef = ref();
		const codeNodeEditorContainerRef = ref();
		const hasManualChanges = ref(false);
		const rootStore = useRootStore();
		const i18n$1 = useI18n();
		const telemetry = useTelemetry();
		const settingsStore = useSettingsStore();
		const linter$1 = useLinter(() => props.mode, () => props.language === "pythonNative" ? "python" : props.language);
		const extensions = computed(() => [linter$1.value]);
		const placeholder = computed(() => CODE_PLACEHOLDERS[props.language]?.[props.mode] ?? "");
		const dragAndDropEnabled = computed(() => {
			return !props.isReadOnly;
		});
		const { highlightLine, readEditorValue, editor: editor$5, focus } = useCodeEditor({
			id: props.id,
			editorRef: codeNodeEditorRef,
			language: () => props.language,
			languageParams: () => ({ mode: props.mode }),
			editorValue: () => props.modelValue,
			placeholder,
			extensions,
			isReadOnly: () => props.isReadOnly,
			theme: {
				maxHeight: props.fillParent ? "100%" : "40vh",
				minHeight: "20vh",
				rows: props.rows
			},
			onChange: onEditorUpdate,
			targetNodeParameterContext: () => props.targetNodeParameterContext
		});
		onMounted(() => {
			if (!props.isReadOnly) codeNodeEditorEventBus.on("highlightLine", highlightLine);
			codeNodeEditorEventBus.on("codeDiffApplied", diffApplied);
			if (!props.modelValue) emit("update:modelValue", placeholder.value);
		});
		onBeforeUnmount(() => {
			codeNodeEditorEventBus.off("codeDiffApplied", diffApplied);
			if (!props.isReadOnly) codeNodeEditorEventBus.off("highlightLine", highlightLine);
		});
		const askAiEnabled = computed(() => {
			return !props.disableAskAi && settingsStore.isAskAiEnabled && props.language === "javaScript";
		});
		watch([() => props.language, () => props.mode], (_$2, [prevLanguage, prevMode]) => {
			if (readEditorValue().trim() === CODE_PLACEHOLDERS[prevLanguage]?.[prevMode]) emit("update:modelValue", placeholder.value);
		});
		async function onBeforeTabLeave(_activeName, oldActiveName) {
			if (oldActiveName === "ask-ai" && isLoadingAIResponse.value) return await message.alert(i18n$1.baseText("codeNodeEditor.askAi.sureLeaveTab"), {
				title: i18n$1.baseText("codeNodeEditor.askAi.areYouSure"),
				confirmButtonText: i18n$1.baseText("codeNodeEditor.askAi.switchTab"),
				showClose: true,
				showCancelButton: true
			}) === "confirm";
			return true;
		}
		async function onAiReplaceCode(code) {
			emit("update:modelValue", await gu(code, {
				parser: "babel",
				plugins: [Ln, estree_exports]
			}));
			activeTab.value = "code";
			hasManualChanges.value = false;
		}
		function onEditorUpdate(viewUpdate) {
			trackCompletion(viewUpdate);
			hasManualChanges.value = true;
			emit("update:modelValue", readEditorValue());
		}
		function diffApplied() {
			codeNodeEditorContainerRef.value?.classList.add("flash-editor");
			codeNodeEditorContainerRef.value?.addEventListener("animationend", () => {
				codeNodeEditorContainerRef.value?.classList.remove("flash-editor");
			});
		}
		function trackCompletion(viewUpdate) {
			if (!viewUpdate.transactions.find((tx) => tx.isUserEvent("input.complete"))) return;
			try {
				const { fromA, toB } = viewUpdate?.changedRanges[0];
				const full = viewUpdate.state.doc.slice(fromA, toB).toString();
				const lastDotIndex = full.lastIndexOf(".");
				let context = null;
				let insertedText = null;
				if (lastDotIndex === -1) {
					context = "";
					insertedText = full;
				} else {
					context = full.slice(0, lastDotIndex);
					insertedText = full.slice(lastDotIndex + 1);
				}
				telemetry.track("User autocompleted code", {
					instance_id: rootStore.instanceId,
					node_type: CODE_NODE_TYPE,
					field_name: props.mode === "runOnceForAllItems" ? "jsCodeAllItems" : "jsCodeEachItem",
					field_type: "code",
					context,
					inserted_text: insertedText
				});
			} catch {}
		}
		function onAiLoadStart() {
			isLoadingAIResponse.value = true;
		}
		function onAiLoadEnd() {
			isLoadingAIResponse.value = false;
		}
		async function onDrop(value$1, event) {
			if (!editor$5.value) return;
			await dropInCodeEditor(toRaw(editor$5.value), event, valueToInsert(value$1, props.language, props.mode));
		}
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "codeNodeEditorContainerRef",
				ref: codeNodeEditorContainerRef,
				class: normalizeClass(["code-node-editor", _ctx.$style["code-node-editor-container"]])
			}, [askAiEnabled.value ? (openBlock(), createBlock(unref(ElTabs), {
				key: 0,
				ref_key: "tabs",
				ref: tabs$1,
				modelValue: activeTab.value,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => activeTab.value = $event),
				type: "card",
				"before-leave": onBeforeTabLeave,
				class: normalizeClass(_ctx.$style.tabs)
			}, {
				default: withCtx(() => [createVNode(unref(ElTabPane), {
					label: unref(i18n$1).baseText("codeNodeEditor.tabs.code"),
					name: "code",
					"data-test-id": "code-node-tab-code",
					class: normalizeClass(_ctx.$style.fillHeight)
				}, {
					default: withCtx(() => [createVNode(DraggableTarget_default, {
						type: "mapping",
						disabled: !dragAndDropEnabled.value,
						class: normalizeClass(_ctx.$style.fillHeight),
						onDrop
					}, {
						default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createBaseVNode("div", {
							ref_key: "codeNodeEditorRef",
							ref: codeNodeEditorRef,
							class: normalizeClass([
								"ph-no-capture",
								"code-editor-tabs",
								_ctx.$style.editorInput,
								_ctx.$style.fillHeight,
								{
									[_ctx.$style.activeDrop]: activeDrop$8,
									[_ctx.$style.droppable]: droppable$10
								}
							])
						}, null, 2)]),
						_: 1
					}, 8, ["disabled", "class"]), renderSlot(_ctx.$slots, "suffix", {}, void 0, true)]),
					_: 3
				}, 8, ["label", "class"]), createVNode(unref(ElTabPane), {
					label: unref(i18n$1).baseText("codeNodeEditor.tabs.askAi"),
					name: "ask-ai",
					"data-test-id": "code-node-tab-ai"
				}, {
					default: withCtx(() => [(openBlock(), createBlock(AskAI_default, {
						key: activeTab.value,
						"has-changes": hasManualChanges.value,
						"is-read-only": props.isReadOnly,
						onReplaceCode: onAiReplaceCode,
						onStartedLoading: onAiLoadStart,
						onFinishedLoading: onAiLoadEnd
					}, null, 8, ["has-changes", "is-read-only"]))]),
					_: 1
				}, 8, ["label"])]),
				_: 3
			}, 8, ["modelValue", "class"])) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.fillHeight)
			}, [createVNode(DraggableTarget_default, {
				type: "mapping",
				disabled: !dragAndDropEnabled.value,
				class: normalizeClass(_ctx.$style.fillHeight),
				onDrop
			}, {
				default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createBaseVNode("div", {
					ref_key: "codeNodeEditorRef",
					ref: codeNodeEditorRef,
					class: normalizeClass([
						"ph-no-capture",
						_ctx.$style.fillHeight,
						_ctx.$style.editorInput,
						{
							[_ctx.$style.activeDrop]: activeDrop$8,
							[_ctx.$style.droppable]: droppable$10
						}
					])
				}, null, 2)]),
				_: 1
			}, 8, ["disabled", "class"]), renderSlot(_ctx.$slots, "suffix", {}, void 0, true)], 2))], 2);
		};
	}
});
const tabs = "_tabs_puigc_123";
const fillHeight$1 = "_fillHeight_puigc_133";
const editorInput = "_editorInput_puigc_137";
const droppable$8 = "_droppable_puigc_137";
const activeDrop$6 = "_activeDrop_puigc_143";
var CodeNodeEditor_vue_vue_type_style_index_1_lang_module_default = {
	tabs,
	"code-node-editor-container": "_code-node-editor-container_puigc_129",
	fillHeight: fillHeight$1,
	editorInput,
	droppable: droppable$8,
	activeDrop: activeDrop$6
};
var CodeNodeEditor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CodeNodeEditor_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CodeNodeEditor_vue_vue_type_style_index_1_lang_module_default }], ["__scopeId", "data-v-08b79abe"]]);
var ScopesNotice_default = /* @__PURE__ */ defineComponent({
	__name: "ScopesNotice",
	props: {
		activeCredentialType: {},
		scopes: {}
	},
	setup(__props) {
		const credentialsStore = useCredentialsStore();
		const i18n$1 = useI18n();
		const props = __props;
		const shortCredentialDisplayName = computed(() => {
			const oauth1Api = i18n$1.baseText("generic.oauth1Api");
			const oauth2Api = i18n$1.baseText("generic.oauth2Api");
			return credentialsStore.getCredentialTypeByName(props.activeCredentialType)?.displayName.replace(/* @__PURE__ */ new RegExp(`${oauth1Api}|${oauth2Api}`), "").trim() || "";
		});
		const scopesShortContent = computed(() => {
			return i18n$1.baseText("nodeSettings.scopes.notice", {
				adjustToNumber: props.scopes.length,
				interpolate: { activeCredential: shortCredentialDisplayName.value }
			});
		});
		const scopesFullContent = computed(() => {
			return i18n$1.baseText("nodeSettings.scopes.expandedNoticeWithScopes", {
				adjustToNumber: props.scopes.length,
				interpolate: {
					activeCredential: shortCredentialDisplayName.value,
					scopes: props.scopes.map((s) => s.includes("/") ? s.split("/").pop() : s).join("<br>")
				}
			});
		});
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nNotice_default), {
				content: scopesShortContent.value,
				"full-content": scopesFullContent.value
			}, null, 8, ["content", "full-content"]);
		};
	}
});
var _hoisted_1$26 = { class: "titled-list" };
var _hoisted_2$12 = ["textContent"];
var TitledList_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	__name: "TitledList",
	props: {
		title: {},
		items: {}
	},
	setup(__props) {
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", _hoisted_1$26, [createBaseVNode("p", { textContent: toDisplayString(_ctx.title) }, null, 8, _hoisted_2$12), createBaseVNode("ul", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item$2) => {
				return withDirectives((openBlock(), createElementBlock("li", {
					key: item$2,
					class: "titled-list-item"
				})), [[_directive_n8n_html, item$2]]);
			}), 128))])]);
		};
	}
}), [["__scopeId", "data-v-98a95125"]]);
function useNodeCredentialOptions(node$1, nodeType, overrideCredType) {
	const nodeHelpers = useNodeHelpers();
	const credentialsStore = useCredentialsStore();
	const mainNodeAuthField = computed(() => getMainAuthField(nodeType.value));
	const credentialTypesNodeDescriptions = computed(() => credentialsStore.getCredentialTypesNodeDescriptions(unref(overrideCredType), nodeType.value));
	const credentialTypesNodeDescriptionDisplayed = computed(() => credentialTypesNodeDescriptions.value.filter(displayCredentials).map((type) => ({
		type,
		options: getCredentialOptions(getAllRelatedCredentialTypes(type))
	})));
	const areAllCredentialsSet = computed(() => credentialTypesNodeDescriptionDisplayed.value.every(({ type }) => isCredentialExisting(type)));
	function getCredentialOptions(types) {
		let options$1 = [];
		types.forEach((type) => {
			options$1 = options$1.concat(credentialsStore.allUsableCredentialsByType[type]?.map((option$1) => ({
				...option$1,
				typeDisplayName: credentialsStore.getCredentialTypeByName(type)?.displayName ?? ""
			})) ?? []);
		});
		if (node$1.value?.type === "n8n-nodes-base.httpRequest") options$1 = options$1.filter((option$1) => !option$1.isManaged);
		return options$1;
	}
	function displayCredentials(credentialTypeDescription) {
		if (!node$1.value) return false;
		if (credentialTypeDescription.displayOptions === void 0) return true;
		return nodeHelpers.displayParameter(node$1.value.parameters, credentialTypeDescription, "", node$1.value);
	}
	function showMixedCredentials(credentialType) {
		if (!node$1.value) return false;
		const isRequired = isRequiredCredential(nodeType.value, credentialType);
		return !KEEP_AUTH_IN_NDV_FOR_NODES.includes(node$1.value.type) && isRequired;
	}
	function getAllRelatedCredentialTypes(credentialType) {
		if (showMixedCredentials(credentialType)) {
			if (mainNodeAuthField.value) return getAllNodeCredentialForAuthType(nodeType.value, mainNodeAuthField.value.name).map((cred) => cred.name);
		}
		return [credentialType.name];
	}
	function isCredentialExisting(credentialType) {
		if (!node$1.value?.credentials?.[credentialType.name]?.id) return false;
		const { id } = node$1.value.credentials[credentialType.name];
		return !!getCredentialOptions([credentialType.name]).find((option$1) => option$1.id === id);
	}
	return {
		credentialTypesNodeDescriptions,
		credentialTypesNodeDescriptionDisplayed,
		mainNodeAuthField,
		areAllCredentialsSet,
		showMixedCredentials,
		isCredentialExisting
	};
}
var _hoisted_1$25 = { key: 0 };
var _hoisted_2$11 = ["disabled", "onClick"];
var NodeCredentials_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "NodeCredentials",
	props: {
		node: {},
		overrideCredType: {
			type: [
				String,
				Number,
				Boolean,
				null,
				Object,
				Array
			],
			default: ""
		},
		readonly: {
			type: Boolean,
			default: false
		},
		showAll: {
			type: Boolean,
			default: false
		},
		hideIssues: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"credentialSelected",
		"valueChanged",
		"blur"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const telemetry = useTelemetry();
		const i18n$1 = useI18n();
		const NEW_CREDENTIALS_TEXT = i18n$1.baseText("nodeCredentials.createNew");
		const credentialsStore = useCredentialsStore();
		const nodeTypesStore = useNodeTypesStore();
		const ndvStore = useNDVStore();
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const projectsStore = useProjectsStore();
		const workflowState = injectWorkflowState();
		const canCreateCredentials = computed(() => getResourcePermissions(projectsStore.currentProject?.scopes ?? projectsStore.personalProject?.scopes).credential.create);
		const nodeHelpers = useNodeHelpers();
		const toast = useToast();
		const subscribedToCredentialType = ref("");
		const filter$1 = ref("");
		const listeningForAuthChange = ref(false);
		const selectRefs = ref([]);
		const node$1 = computed(() => props.node);
		const nodeType = computed(() => nodeTypesStore.getNodeType(props.node.type, props.node.typeVersion));
		const { mainNodeAuthField, credentialTypesNodeDescriptionDisplayed, credentialTypesNodeDescriptions, isCredentialExisting, showMixedCredentials } = useNodeCredentialOptions(node$1, nodeType, computed(() => props.overrideCredType));
		const credentialTypeNames = computed(() => {
			const returnData = {};
			for (const { name } of credentialTypesNodeDescriptions.value) {
				const credentialType = credentialsStore.getCredentialTypeByName(name);
				returnData[name] = credentialType ? credentialType.displayName : name;
			}
			return returnData;
		});
		const selected$1 = computed(() => props.node.credentials ?? {});
		watch(() => props.node.parameters, (newValue, oldValue) => {
			if (props.node.name === ndvStore.activeNode?.name && nodeType.value && listeningForAuthChange.value) {
				if (mainNodeAuthField.value && oldValue && newValue) {
					const newAuth = newValue[mainNodeAuthField.value.name];
					if (newAuth) {
						const authType = typeof newAuth === "object" ? JSON.stringify(newAuth) : newAuth.toString();
						const credentialType = getNodeCredentialForSelectedAuthType(nodeType.value, authType);
						if (credentialType) subscribedToCredentialType.value = credentialType.name;
					}
				}
			}
		}, {
			immediate: true,
			deep: true
		});
		watch(credentialTypesNodeDescriptionDisplayed, (types) => {
			if (types.length === 0 || !isEmpty$1(selected$1.value)) return;
			const allOptions = types.map((type) => type.options).flat();
			if (allOptions.length === 0) return;
			const mostRecentCredential = allOptions.reduce((mostRecent, current) => mostRecent && mostRecent.updatedAt > current.updatedAt ? mostRecent : current, allOptions[0]);
			onCredentialSelected(mostRecentCredential.type, mostRecentCredential.id);
		}, { immediate: true });
		onMounted(() => {
			credentialsStore.$onAction(({ name, after, args }) => {
				const listeningForActions = [
					"createNewCredential",
					"updateCredential",
					"deleteCredential"
				];
				const credentialType = subscribedToCredentialType.value;
				if (!credentialType) return;
				after(async (result) => {
					if (!listeningForActions.includes(name)) return;
					const current = selected$1.value[credentialType];
					let credentialsOfType = [];
					if (props.showAll) {
						if (props.node) credentialsOfType = [...credentialsStore.allUsableCredentialsForNode(props.node) || []];
					} else credentialsOfType = [...credentialsStore.allUsableCredentialsByType[credentialType] || []];
					switch (name) {
						case "createNewCredential":
							if (result) onCredentialSelected(credentialType, result.id);
							break;
						case "updateCredential":
							if (result.name !== current.name) onCredentialSelected(credentialType, current.id);
							break;
						case "deleteCredential":
							if (credentialsOfType.length === 0) clearSelectedCredential(credentialType);
							else {
								const id = args[0].id;
								if (current.id === id) onCredentialSelected(credentialType, credentialsOfType[credentialsOfType.length - 1].id);
							}
							break;
					}
				});
			});
			ndvEventBus.on("credential.createNew", onCreateAndAssignNewCredential);
		});
		onBeforeUnmount(() => {
			ndvEventBus.off("credential.createNew", onCreateAndAssignNewCredential);
		});
		function getSelectedId(type) {
			if (isCredentialExisting(type)) return selected$1.value[type.name].id;
		}
		function getSelectedName(type) {
			return selected$1.value?.[type]?.name;
		}
		function getSelectPlaceholder(type, issues) {
			return issues.length && getSelectedName(type) ? i18n$1.baseText("nodeCredentials.selectedCredentialUnavailable", { interpolate: { name: getSelectedName(type) } }) : i18n$1.baseText("nodeCredentials.selectCredential");
		}
		function clearSelectedCredential(credentialType) {
			const credentials = { ...props.node.credentials ?? {} };
			delete credentials[credentialType];
			emit("credentialSelected", {
				name: props.node.name,
				properties: { credentials }
			});
		}
		function createNewCredential(credentialType, listenForAuthChange = false, showAuthOptions = false) {
			if (listenForAuthChange) {
				listeningForAuthChange.value = true;
				subscribedToCredentialType.value = credentialType;
			}
			uiStore.openNewCredential(credentialType, showAuthOptions);
			telemetry.track("User opened Credential modal", {
				credential_type: credentialType,
				source: "node",
				new_credential: true,
				workflow_id: workflowsStore.workflowId
			});
		}
		function onCreateAndAssignNewCredential({ type, showAuthOptions }) {
			createNewCredential(type, true, showAuthOptions);
		}
		function onCredentialSelected(credentialType, credentialId, showAuthOptions = false) {
			if (!credentialId) {
				createNewCredential(credentialType, false, showAuthOptions);
				return;
			}
			telemetry.track("User selected credential from node modal", {
				credential_type: credentialType,
				node_type: props.node.type,
				...nodeHelpers.hasProxyAuth(props.node) ? { is_service_specific: true } : {},
				workflow_id: workflowsStore.workflowId,
				credential_id: credentialId
			});
			const selectedCredentials = credentialsStore.getCredentialById(credentialId);
			const selectedCredentialsType = props.showAll ? selectedCredentials.type : credentialType;
			const oldCredentials = props.node.credentials?.[selectedCredentialsType] ?? null;
			const newSelectedCredentials = {
				id: selectedCredentials.id,
				name: selectedCredentials.name
			};
			if (oldCredentials?.id === null || oldCredentials?.id && !credentialsStore.getCredentialByIdAndType(oldCredentials.id, selectedCredentialsType)) {
				workflowsStore.replaceInvalidWorkflowCredentials({
					credentials: newSelectedCredentials,
					invalid: oldCredentials,
					type: selectedCredentialsType
				});
				nodeHelpers.updateNodesCredentialsIssues();
				toast.showMessage({
					title: i18n$1.baseText("nodeCredentials.showMessage.title"),
					message: i18n$1.baseText("nodeCredentials.showMessage.message", { interpolate: {
						oldCredentialName: oldCredentials.name,
						newCredentialName: newSelectedCredentials.name
					} }),
					type: "success"
				});
			}
			const updatedNodesCount = workflowsStore.assignCredentialToMatchingNodes({
				credentials: newSelectedCredentials,
				type: selectedCredentialsType,
				currentNodeName: props.node.name
			});
			if (updatedNodesCount > 0) {
				nodeHelpers.updateNodesCredentialsIssues();
				toast.showMessage({
					title: i18n$1.baseText("nodeCredentials.showMessage.title"),
					message: i18n$1.baseText("nodeCredentials.autoAssigned.message", { interpolate: { count: String(updatedNodesCount) } }),
					type: "success"
				});
			}
			if (props.showAll && mainNodeAuthField.value) {
				const nodeCredentialDescription = nodeType.value?.credentials?.find((cred) => cred.name === selectedCredentialsType);
				const authOption = getAuthTypeForNodeCredential(nodeType.value, nodeCredentialDescription);
				if (authOption) {
					updateNodeAuthType(workflowState, props.node, authOption.value);
					emit("valueChanged", {
						name: `parameters.${mainNodeAuthField.value.name}`,
						value: authOption.value
					});
				}
			}
			const credentials = {
				...props.node.credentials ?? {},
				[selectedCredentialsType]: newSelectedCredentials
			};
			emit("credentialSelected", {
				name: props.node.name,
				properties: { credentials }
			});
		}
		function getIssues(credentialTypeName) {
			const node$2 = props.node;
			if (node$2.issues?.credentials === void 0) return [];
			if (!node$2.issues.credentials.hasOwnProperty(credentialTypeName)) return [];
			return node$2.issues.credentials[credentialTypeName];
		}
		function editCredential(credentialType) {
			const credential = props.node.credentials?.[credentialType];
			assert(credential?.id);
			uiStore.openExistingCredential(credential.id);
			telemetry.track("User opened Credential modal", {
				credential_type: credentialType,
				source: "node",
				new_credential: false,
				workflow_id: workflowsStore.workflowId
			});
			subscribedToCredentialType.value = credentialType;
		}
		function getCredentialsFieldLabel(credentialType) {
			if (credentialType.displayName) return credentialType.displayName;
			const credentialTypeName = credentialTypeNames.value[credentialType.name];
			if (props.node.type.startsWith("n8n-creds-base")) return i18n$1.baseText("nodeCredentials.credentialFor", { interpolate: { credentialType: nodeType.value?.displayName ?? credentialTypeName } });
			if (!showMixedCredentials(credentialType)) return i18n$1.baseText("nodeCredentials.credentialFor", { interpolate: { credentialType: credentialTypeName } });
			return i18n$1.baseText("nodeCredentials.credentialsLabel");
		}
		function setFilter(newFilter = "") {
			filter$1.value = newFilter;
		}
		function matches$1(needle, haystack) {
			return haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase());
		}
		async function onClickCreateCredential(type) {
			selectRefs.value.forEach((select$1) => select$1.blur());
			await nextTick();
			createNewCredential(type.name, true, showMixedCredentials(type));
		}
		return (_ctx, _cache) => {
			return unref(credentialTypesNodeDescriptionDisplayed).length ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(["node-credentials", _ctx.$style.container])
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(credentialTypesNodeDescriptionDisplayed), ({ type, options: options$1 }) => {
				return openBlock(), createElementBlock("div", { key: type.name }, [createVNode(unref(N8nInputLabel_default), {
					label: getCredentialsFieldLabel(type),
					bold: false,
					size: "small",
					color: "text-dark",
					"data-test-id": "credentials-label"
				}, {
					default: withCtx(() => [_ctx.readonly ? (openBlock(), createElementBlock("div", _hoisted_1$25, [createVNode(unref(N8nInput_default), {
						"model-value": getSelectedName(type.name),
						disabled: "",
						size: "small",
						"data-test-id": "node-credentials-select"
					}, null, 8, ["model-value"])])) : (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(getIssues(type.name).length && !_ctx.hideIssues ? _ctx.$style.hasIssues : _ctx.$style.input),
						"data-test-id": "node-credentials-select"
					}, [
						createVNode(unref(N8nSelect_default), {
							ref_for: true,
							ref_key: "selectRefs",
							ref: selectRefs,
							"model-value": getSelectedId(type),
							placeholder: getSelectPlaceholder(type.name, getIssues(type.name)),
							size: "small",
							filterable: "",
							"filter-method": setFilter,
							"popper-class": _ctx.$style.selectPopper,
							"onUpdate:modelValue": (value$1) => onCredentialSelected(type.name, value$1, unref(showMixedCredentials)(type)),
							onBlur: _cache[0] || (_cache[0] = ($event) => emit("blur", "credentials"))
						}, {
							empty: withCtx(() => _cache[1] || (_cache[1] = [])),
							footer: withCtx(() => [createBaseVNode("button", {
								type: "button",
								"data-test-id": "node-credentials-select-item-new",
								class: normalizeClass([_ctx.$style.newCredential]),
								disabled: !canCreateCredentials.value,
								onClick: ($event) => onClickCreateCredential(type)
							}, [createVNode(unref(N8nIcon_default), {
								size: "xsmall",
								icon: "plus"
							}), createTextVNode(" " + toDisplayString(unref(NEW_CREDENTIALS_TEXT)), 1)], 10, _hoisted_2$11)]),
							default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(options$1.filter((o) => matches$1(filter$1.value, o.name)), (item$2) => {
								return openBlock(), createBlock(unref(N8nOption_default), {
									key: item$2.id,
									"data-test-id": `node-credentials-select-item-${item$2.id}`,
									label: item$2.name,
									value: item$2.id
								}, {
									default: withCtx(() => [createBaseVNode("div", { class: normalizeClass([
										_ctx.$style.credentialOption,
										"mt-2xs",
										"mb-2xs"
									]) }, [createVNode(unref(N8nText_default), { bold: "" }, {
										default: withCtx(() => [createTextVNode(toDisplayString(item$2.name), 1)]),
										_: 2
									}, 1024), createVNode(unref(N8nText_default), { size: "small" }, {
										default: withCtx(() => [createTextVNode(toDisplayString(item$2.typeDisplayName), 1)]),
										_: 2
									}, 1024)], 2)]),
									_: 2
								}, 1032, [
									"data-test-id",
									"label",
									"value"
								]);
							}), 128))]),
							_: 2
						}, 1032, [
							"model-value",
							"placeholder",
							"popper-class",
							"onUpdate:modelValue"
						]),
						getIssues(type.name).length && !_ctx.hideIssues ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass(_ctx.$style.warning)
						}, [createVNode(unref(N8nTooltip_default), { placement: "top" }, {
							content: withCtx(() => [createVNode(TitledList_default, {
								title: `${unref(i18n$1).baseText("nodeCredentials.issues")}:`,
								items: getIssues(type.name)
							}, null, 8, ["title", "items"])]),
							default: withCtx(() => [createVNode(unref(N8nIcon_default), { icon: "triangle-alert" })]),
							_: 2
						}, 1024)], 2)) : createCommentVNode("", true),
						selected$1.value[type.name] && unref(isCredentialExisting)(type) ? (openBlock(), createElementBlock("div", {
							key: 1,
							class: normalizeClass(_ctx.$style.edit),
							"data-test-id": "credential-edit-button"
						}, [createVNode(unref(N8nIcon_default), {
							icon: "pen",
							class: "clickable",
							title: unref(i18n$1).baseText("nodeCredentials.updateCredential"),
							onClick: ($event) => editCredential(type.name)
						}, null, 8, ["title", "onClick"])], 2)) : createCommentVNode("", true)
					], 2))]),
					_: 2
				}, 1032, ["label"])]);
			}), 128))], 2)) : createCommentVNode("", true);
		};
	}
});
var NodeCredentials_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_7k000_123",
	selectPopper: "_selectPopper_7k000_130",
	newCredential: "_newCredential_7k000_133",
	warning: "_warning_7k000_142",
	edit: "_edit_7k000_148",
	input: "_input_7k000_157",
	hasIssues: "_hasIssues_7k000_162 _input_7k000_157",
	credentialOption: "_credentialOption_7k000_167"
};
var NodeCredentials_default = /* @__PURE__ */ __plugin_vue_export_helper_default(NodeCredentials_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": NodeCredentials_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$24 = { class: "list-option" };
var _hoisted_2$10 = { class: "option-headline" };
var CredentialsSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CredentialsSelect",
	props: {
		activeCredentialType: {},
		parameter: {},
		node: {},
		inputSize: {},
		displayValue: {},
		isReadOnly: { type: Boolean },
		displayTitle: {}
	},
	emits: [
		"update:modelValue",
		"setFocus",
		"onBlur",
		"credentialSelected"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const credentialsStore = useCredentialsStore();
		const i18n$1 = useI18n();
		const innerSelectRef = ref();
		const allCredentialTypes = computed(() => credentialsStore.allCredentialTypes);
		const scopes = computed(() => {
			if (!props.activeCredentialType) return [];
			return credentialsStore.getScopesByCredentialType(props.activeCredentialType);
		});
		const supportedCredentialTypes = computed(() => {
			return allCredentialTypes.value.filter((c) => isSupported(c.name));
		});
		function focus() {
			if (innerSelectRef.value) innerSelectRef.value.focus();
		}
		function isSupported(name) {
			const supported = getSupportedSets(props.parameter.credentialTypes ?? []);
			const checkedCredType = credentialsStore.getCredentialTypeByName(name);
			if (!checkedCredType) return false;
			for (const property of supported.has) if (checkedCredType[property] !== void 0) {
				if (name === "httpHeaderAuth" && property === "authenticate") continue;
				return true;
			}
			if (checkedCredType.extends?.some((parentType) => supported.extends.includes(parentType))) return true;
			if (checkedCredType.extends && supported.extends.length) return checkedCredType.extends.reduce((acc, parentType) => acc || isSupported(parentType), false);
			return false;
		}
		function getSupportedSets(credentialTypes) {
			return credentialTypes.reduce((acc, cur) => {
				const _extends$1 = cur.split("extends:");
				if (_extends$1.length === 2) {
					acc.extends.push(_extends$1[1]);
					return acc;
				}
				const _has = cur.split("has:");
				if (_has.length === 2) {
					acc.has.push(_has[1]);
					return acc;
				}
				return acc;
			}, {
				extends: [],
				has: []
			});
		}
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [
				createBaseVNode("div", { class: normalizeClass(_ctx.$style["parameter-value-container"]) }, [createVNode(unref(N8nSelect_default), {
					ref_key: "innerSelectRef",
					ref: innerSelectRef,
					size: _ctx.inputSize,
					filterable: "",
					"model-value": _ctx.displayValue,
					placeholder: unref(i18n$1).baseText("parameterInput.select"),
					title: _ctx.displayTitle,
					disabled: _ctx.isReadOnly,
					"data-test-id": "credential-select",
					"onUpdate:modelValue": _cache[0] || (_cache[0] = (value$1) => emit("update:modelValue", value$1)),
					onKeydown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
					onFocus: _cache[2] || (_cache[2] = ($event) => emit("setFocus")),
					onBlur: _cache[3] || (_cache[3] = ($event) => emit("onBlur"))
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(supportedCredentialTypes.value, (credType) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: credType.name,
							value: credType.name,
							label: credType.displayName,
							"data-test-id": "credential-select-option"
						}, {
							default: withCtx(() => [createBaseVNode("div", _hoisted_1$24, [createBaseVNode("div", _hoisted_2$10, toDisplayString(credType.displayName), 1)])]),
							_: 2
						}, 1032, ["value", "label"]);
					}), 128))]),
					_: 1
				}, 8, [
					"size",
					"model-value",
					"placeholder",
					"title",
					"disabled"
				]), renderSlot(_ctx.$slots, "issues-and-options")], 2),
				scopes.value.length > 0 ? (openBlock(), createBlock(ScopesNotice_default, {
					key: 0,
					"active-credential-type": _ctx.activeCredentialType,
					scopes: scopes.value
				}, null, 8, ["active-credential-type", "scopes"])) : createCommentVNode("", true),
				createBaseVNode("div", null, [_ctx.node ? (openBlock(), createBlock(NodeCredentials_default, {
					key: 0,
					node: _ctx.node,
					readonly: _ctx.isReadOnly,
					"override-cred-type": _ctx.node?.parameters[_ctx.parameter.name],
					onCredentialSelected: _cache[4] || (_cache[4] = (updateInformation) => emit("credentialSelected", updateInformation))
				}, null, 8, [
					"node",
					"readonly",
					"override-cred-type"
				])) : createCommentVNode("", true)])
			]);
		};
	}
});
var CredentialsSelect_vue_vue_type_style_index_0_lang_module_default = { "parameter-value-container": "_parameter-value-container_7z9yr_123" };
var CredentialsSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CredentialsSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CredentialsSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var commonThemeProps$1 = (isReadOnly = false) => ({
	"&": {
		borderWidth: "var(--border-width)",
		borderStyle: "var(--input--border-style, var(--border-style))",
		borderColor: "var(--input--border-color, var(--border-color))",
		borderRadius: "var(--input--radius, var(--radius))",
		backgroundColor: "var(--expression-editor--color--background)"
	},
	".cm-cursor, .cm-dropCursor": { borderLeftColor: "var(--code--caret--color)" },
	"&.cm-editor": { overflow: "hidden" },
	"&.cm-focused": {
		borderColor: "var(--color--secondary)",
		outline: "0 !important"
	},
	".cm-content": {
		fontFamily: "var(--font-family--monospace)",
		padding: "var(--spacing--xs)",
		color: "var(--input--color--text, var(--color--text--shade-1))",
		caretColor: isReadOnly ? "transparent" : "var(--code--caret--color)"
	},
	".cm-line": { padding: "0" }
});
const inputTheme$1 = (isReadOnly = false) => {
	return [EditorView.theme(commonThemeProps$1(isReadOnly)), highlighter.resolvableStyle];
};
const outputTheme$1 = () => {
	return [EditorView.theme({
		...commonThemeProps$1(true),
		".cm-valid-resolvable": {
			padding: "0 2px",
			borderRadius: "2px"
		},
		".cm-invalid-resolvable": {
			padding: "0 2px",
			borderRadius: "2px"
		}
	}), highlighter.resolvableStyle];
};
var ExpressionEditorModalInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExpressionEditorModalInput",
	props: {
		modelValue: {},
		path: {},
		targetNodeParameterContext: { default: void 0 },
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"change",
		"focus",
		"close"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const root = ref();
		const extensions = computed(() => [
			inputTheme$1(props.isReadOnly),
			Prec.highest(keymap.of(editorKeymap)),
			n8nLang(),
			n8nAutocompletion(),
			mappingDropCursor(),
			dropCursor(),
			history(),
			expressionCloseBrackets(),
			EditorView.lineWrapping,
			EditorView.domEventHandlers({ scroll: (_$2, view) => forceParse(view) }),
			infoBoxTooltips()
		]);
		const editorValue = ref(removeExpressionPrefix(props.modelValue));
		const { segments, readEditorValue, editor: editor$5, hasFocus, focus } = useExpressionEditor({
			editorRef: root,
			editorValue,
			extensions,
			isReadOnly: computed(() => props.isReadOnly),
			autocompleteTelemetry: {
				enabled: true,
				parameterPath: props.path
			},
			targetNodeParameterContext: props.targetNodeParameterContext
		});
		watch(() => props.modelValue, (newValue) => {
			editorValue.value = removeExpressionPrefix(newValue);
		});
		watch(segments.display, (newSegments) => {
			emit("change", {
				value: "=" + readEditorValue(),
				segments: newSegments
			});
		});
		watch(hasFocus, (focused$1) => {
			if (focused$1) emit("focus");
		});
		onMounted(() => {
			focus();
		});
		__expose({
			editor: editor$5,
			focus
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "root",
				ref: root,
				class: normalizeClass(_ctx.$style.editor),
				onKeydown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["stop"]))
			}, null, 34);
		};
	}
});
var ExpressionEditorModalInput_vue_vue_type_style_index_0_lang_module_default = { editor: "_editor_jym8t_123" };
var ExpressionEditorModalInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExpressionEditorModalInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExpressionEditorModalInput_vue_vue_type_style_index_0_lang_module_default }]]);
function createExpressionTelemetryPayload(segments, value$1, workflowId, pushRef, activeNodeType, eventSource = "ndv") {
	const resolvables = segments.filter((s) => s.kind === "resolvable");
	const erroringResolvables = resolvables.filter((r) => r.error);
	return {
		empty_expression: value$1 === "=" || value$1 === "={{}}" || !value$1,
		workflow_id: workflowId,
		source: eventSource,
		push_ref: pushRef,
		is_transforming_data: resolvables.some((r) => isTransformingData(r.resolvable)),
		has_parameter: value$1.includes("$parameter"),
		has_mapping: hasExpressionMapping(value$1),
		node_type: activeNodeType,
		handlebar_count: resolvables.length,
		handlebar_error_count: erroringResolvables.length,
		short_errors: erroringResolvables.map((r) => r.resolved ?? null),
		full_errors: erroringResolvables.map((erroringResolvable) => {
			if (erroringResolvable.fullError) return {
				...exposeErrorProperties(erroringResolvable.fullError),
				stack: erroringResolvable.fullError.stack
			};
			return null;
		})
	};
}
function isTransformingData(resolvable) {
	return /(\$input\.\w+\(\)\.|\$json(\[('|")|\.)\w+('|")]?\.|\$\(('|")\w+('|")\)\.\w+\(\)\.|\$node\[('|")\w+('|")\]\.\w+\(\)\.)/.test(resolvable);
}
function exposeErrorProperties(error) {
	return Object.getOwnPropertyNames(error).reduce((acc, key) => {
		return acc[key] = error[key], acc;
	}, {});
}
var ExpressionOutput_default = /* @__PURE__ */ defineComponent({
	__name: "ExpressionOutput",
	props: {
		segments: {},
		extensions: { default: () => [] }
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const i18n$1 = useI18n();
		const editor$5 = ref(null);
		const root = ref(null);
		const resolvedExpression = computed(() => {
			if (props.segments.length === 0) return i18n$1.baseText("parameterInput.emptyString");
			return props.segments.reduce((acc, segment) => {
				if (acc.cursor >= segment.to) return acc;
				acc.resolved += segment.kind === "resolvable" ? String(segment.resolved) : segment.plaintext;
				acc.cursor = segment.to;
				return acc;
			}, {
				resolved: "",
				cursor: 0
			}).resolved;
		});
		const plaintextSegments = computed(() => {
			return props.segments.filter((s) => s.kind === "plaintext");
		});
		const resolvedSegments = computed(() => {
			if (props.segments.length === 0) {
				const emptyExpression = resolvedExpression.value;
				return [{
					from: 0,
					to: emptyExpression.length,
					kind: "resolvable",
					error: null,
					resolvable: "",
					resolved: emptyExpression,
					state: "pending"
				}];
			}
			let cursor = 0;
			return props.segments.map((segment) => {
				segment.from = cursor;
				cursor += segment.kind === "plaintext" ? segment.plaintext.length : segment.resolved ? segment.resolved.toString().length : 0;
				segment.to = cursor;
				return segment;
			}).filter((segment) => segment.kind === "resolvable");
		});
		watch(() => props.segments, () => {
			if (!editor$5.value) return;
			editor$5.value.dispatch({ changes: {
				from: 0,
				to: editor$5.value.state.doc.length,
				insert: resolvedExpression.value
			} });
			highlighter.addColor(editor$5.value, resolvedSegments.value);
			highlighter.removeColor(editor$5.value, plaintextSegments.value);
		});
		onMounted(() => {
			editor$5.value = new EditorView({
				parent: root.value,
				state: EditorState.create({
					doc: resolvedExpression.value,
					extensions: [
						EditorState.readOnly.of(true),
						EditorView.lineWrapping,
						EditorView.domEventHandlers({ scroll: (_$2, view) => forceParse(view) }),
						...props.extensions
					]
				})
			});
			highlighter.addColor(editor$5.value, resolvedSegments.value);
			highlighter.removeColor(editor$5.value, plaintextSegments.value);
		});
		onBeforeUnmount(() => {
			editor$5.value?.destroy();
		});
		__expose({ getValue: () => "=" + resolvedExpression.value });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "root",
				ref: root,
				"data-test-id": "expression-output"
			}, null, 512);
		};
	}
});
var OutputItemSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "OutputItemSelect",
	setup(__props) {
		const i18n$1 = useI18n();
		const ndvStore = useNDVStore();
		const hoveringItem = computed(() => ndvStore.getHoveringItem);
		const hoveringItemIndex = computed(() => hoveringItem.value?.itemIndex);
		const isHoveringItem = computed(() => Boolean(hoveringItem.value));
		const itemsLength = computed(() => ndvStore.ndvInputDataWithPinnedData.length);
		const itemIndex = computed(() => hoveringItemIndex.value ?? ndvStore.expressionOutputItemIndex ?? 0);
		const max = computed(() => Math.max(itemsLength.value - 1, 0));
		const isItemIndexEditable = computed(() => !isHoveringItem.value && itemsLength.value > 0);
		const hideTableHoverHint = computed(() => ndvStore.isTableHoverOnboarded);
		const canSelectPrevItem = computed(() => isItemIndexEditable.value && itemIndex.value !== 0);
		const canSelectNextItem = computed(() => isItemIndexEditable.value && itemIndex.value < itemsLength.value - 1);
		const inputCharWidth = computed(() => itemIndex.value.toString().length);
		function updateItemIndex(index$1) {
			ndvStore.expressionOutputItemIndex = index$1;
		}
		function nextItem() {
			ndvStore.expressionOutputItemIndex = ndvStore.expressionOutputItemIndex + 1;
		}
		function prevItem() {
			ndvStore.expressionOutputItemIndex = ndvStore.expressionOutputItemIndex - 1;
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.item) }, [createVNode(unref(N8nText_default), {
				size: "small",
				color: "text-base",
				compact: ""
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.item")), 1)]),
				_: 1
			}), createBaseVNode("div", { class: normalizeClass(_ctx.$style.controls) }, [
				createVNode(unref(N8nInputNumber_default), {
					"data-test-id": "inline-expression-editor-item-input",
					size: "mini",
					controls: false,
					class: normalizeClass([_ctx.$style.input, { [_ctx.$style.hovering]: isHoveringItem.value }]),
					min: 0,
					max: max.value,
					"model-value": itemIndex.value,
					style: normalizeStyle({ "--input-width": `calc(${inputCharWidth.value}ch + var(--spacing--sm))` }),
					"onUpdate:modelValue": updateItemIndex
				}, null, 8, [
					"class",
					"max",
					"model-value",
					"style"
				]),
				createVNode(unref(N8nIconButton_default), {
					"data-test-id": "inline-expression-editor-item-prev",
					icon: "chevron-left",
					type: "tertiary",
					text: "",
					size: "mini",
					disabled: !canSelectPrevItem.value,
					onClick: prevItem
				}, null, 8, ["disabled"]),
				createVNode(unref(N8nTooltip_default), {
					placement: "right",
					disabled: hideTableHoverHint.value
				}, {
					content: withCtx(() => [createBaseVNode("div", null, toDisplayString(unref(i18n$1).baseText("parameterInput.hoverTableItemTip")), 1)]),
					default: withCtx(() => [createVNode(unref(N8nIconButton_default), {
						"data-test-id": "inline-expression-editor-item-next",
						icon: "chevron-right",
						type: "tertiary",
						text: "",
						size: "mini",
						disabled: !canSelectNextItem.value,
						onClick: nextItem
					}, null, 8, ["disabled"])]),
					_: 1
				}, 8, ["disabled"])
			], 2)], 2);
		};
	}
});
var OutputItemSelect_vue_vue_type_style_index_0_lang_module_default = {
	item: "_item_x3rj2_123",
	controls: "_controls_x3rj2_129",
	input: "_input_x3rj2_134",
	hovering: "_hovering_x3rj2_142"
};
var OutputItemSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(OutputItemSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": OutputItemSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var DEFAULT_LEFT_SIDEBAR_WIDTH = 360;
var ExpressionEditModal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExpressionEditModal",
	props: {
		parameter: {},
		path: {},
		modelValue: {},
		dialogVisible: {
			type: Boolean,
			default: false
		},
		eventSource: { default: "" },
		redactValues: {
			type: Boolean,
			default: false
		},
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["update:model-value", "closeDialog"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const ndvStore = useNDVStore();
		const workflowsStore = useWorkflowsStore();
		const telemetry = useTelemetry();
		const i18n$1 = useI18n();
		const externalHooks = useExternalHooks();
		const { debounce: debounce$4 } = useDebounce();
		const segments = ref([]);
		const search = ref("");
		const appliedSearch = ref("");
		const sidebarWidth = ref(DEFAULT_LEFT_SIDEBAR_WIDTH);
		const expressionInputRef = ref();
		const expressionResultRef = ref();
		const theme = outputTheme$1();
		const activeNode = computed(() => ndvStore.activeNode);
		const inputEditor = computed(() => expressionInputRef.value?.editor);
		const parentNodes = computed(() => {
			const node$1 = activeNode.value;
			if (!node$1) return [];
			return workflowsStore.workflowObject.getParentNodesByDepth(node$1.name).filter(({ name }) => name !== node$1.name);
		});
		watch(() => props.dialogVisible, (newValue) => {
			const resolvedExpressionValue = expressionResultRef.value?.getValue() ?? "";
			externalHooks.run("expressionEdit.dialogVisibleChanged", {
				dialogVisible: newValue,
				parameter: props.parameter,
				value: props.modelValue.toString(),
				resolvedExpressionValue
			});
			if (!newValue) {
				const telemetryPayload = createExpressionTelemetryPayload(segments.value, props.modelValue.toString(), workflowsStore.workflowId, ndvStore.pushRef, ndvStore.activeNode?.type ?? "");
				telemetry.track("User closed Expression Editor", telemetryPayload);
				externalHooks.run("expressionEdit.closeDialog", telemetryPayload);
			}
		});
		watch(search, debounce$4((newSearch) => {
			appliedSearch.value = newSearch;
		}, { debounceTime: 500 }));
		function valueChanged(update) {
			segments.value = update.segments;
			emit("update:model-value", update.value);
		}
		function closeDialog() {
			emit("closeDialog");
		}
		async function onDrop(expression, event) {
			if (!inputEditor.value) return;
			await dropInExpressionEditor(toRaw(inputEditor.value), event, expression);
		}
		function onResize(event) {
			sidebarWidth.value = event.width;
		}
		const onResizeThrottle = useThrottleFn(onResize, 10);
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createBlock(unref(ElDialog), {
				width: "calc(100% - var(--spacing--3xl))",
				"append-to": `#${unref(APP_MODALS_ELEMENT_ID)}`,
				class: normalizeClass(_ctx.$style.modal),
				"model-value": _ctx.dialogVisible,
				"before-close": closeDialog
			}, {
				default: withCtx(() => [createBaseVNode("button", {
					class: normalizeClass(_ctx.$style.close),
					onClick: closeDialog
				}, [createVNode(unref(close_default), {
					height: "18",
					width: "18"
				})], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.container) }, [createVNode(unref(N8nResizeWrapper_default), {
					width: sidebarWidth.value,
					"min-width": 200,
					style: normalizeStyle({ width: `${sidebarWidth.value}px` }),
					"grid-size": 8,
					"supported-directions": ["left", "right"],
					onResize: unref(onResizeThrottle)
				}, {
					default: withCtx(() => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.sidebar) }, [createVNode(unref(N8nInput_default), {
						modelValue: search.value,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => search.value = $event),
						size: "small",
						class: normalizeClass(_ctx.$style.search),
						placeholder: unref(i18n$1).baseText("ndv.search.placeholder.input.schema")
					}, {
						prefix: withCtx(() => [createVNode(unref(N8nIcon_default), {
							class: normalizeClass(_ctx.$style.ioSearchIcon),
							icon: "search"
						}, null, 8, ["class"])]),
						_: 1
					}, 8, [
						"modelValue",
						"class",
						"placeholder"
					]), createVNode(VirtualSchema_default, {
						class: normalizeClass(_ctx.$style.schema),
						search: appliedSearch.value,
						nodes: parentNodes.value,
						"mapping-enabled": !_ctx.isReadOnly,
						"connection-type": unref(NodeConnectionTypes).Main,
						"pane-type": "input"
					}, null, 8, [
						"class",
						"search",
						"nodes",
						"mapping-enabled",
						"connection-type"
					])], 2)]),
					_: 1
				}, 8, [
					"width",
					"style",
					"onResize"
				]), createBaseVNode("div", { class: normalizeClass(_ctx.$style.io) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.input) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.header) }, [createVNode(unref(N8nText_default), {
					bold: "",
					size: "large"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("expressionEdit.expression")), 1)]),
					_: 1
				}), withDirectives(createVNode(unref(N8nText_default), {
					class: normalizeClass(_ctx.$style.tip),
					size: "small"
				}, null, 8, ["class"]), [[_directive_n8n_html, unref(i18n$1).baseText("expressionTip.javascript")]])], 2), createVNode(DraggableTarget_default, {
					class: normalizeClass(_ctx.$style.editorContainer),
					type: "mapping",
					onDrop
				}, {
					default: withCtx(() => [createVNode(ExpressionEditorModalInput_default, {
						ref_key: "expressionInputRef",
						ref: expressionInputRef,
						"model-value": _ctx.modelValue,
						"is-read-only": _ctx.isReadOnly,
						path: _ctx.path,
						class: normalizeClass([_ctx.$style.editor, { "ph-no-capture": _ctx.redactValues }]),
						"data-test-id": "expression-modal-input",
						onChange: valueChanged,
						onClose: closeDialog
					}, null, 8, [
						"model-value",
						"is-read-only",
						"path",
						"class"
					])]),
					_: 1
				}, 8, ["class"])], 2), createBaseVNode("div", { class: normalizeClass(_ctx.$style.output) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.header) }, [createVNode(unref(N8nText_default), {
					bold: "",
					size: "large"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.result")), 1)]),
					_: 1
				}), createVNode(OutputItemSelect_default)], 2), createBaseVNode("div", { class: normalizeClass([_ctx.$style.editorContainer, { "ph-no-capture": _ctx.redactValues }]) }, [createVNode(ExpressionOutput_default, {
					ref_key: "expressionResultRef",
					ref: expressionResultRef,
					class: normalizeClass(_ctx.$style.editor),
					segments: segments.value,
					extensions: unref(theme),
					"data-test-id": "expression-modal-output"
				}, null, 8, [
					"class",
					"segments",
					"extensions"
				])], 2)], 2)], 2)], 2)]),
				_: 1
			}, 8, [
				"append-to",
				"class",
				"model-value"
			]);
		};
	}
});
var ExpressionEditModal_vue_vue_type_style_index_0_lang_module_default = {
	modal: "_modal_2exev_123",
	container: "_container_2exev_139",
	sidebar: "_sidebar_2exev_146",
	schema: "_schema_2exev_155",
	editor: "_editor_2exev_161",
	editorContainer: "_editorContainer_2exev_170",
	io: "_io_2exev_176",
	input: "_input_2exev_182",
	output: "_output_2exev_183",
	header: "_header_2exev_194",
	tip: "_tip_2exev_200",
	close: "_close_2exev_204"
};
var ExpressionEditModal_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExpressionEditModal_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExpressionEditModal_vue_vue_type_style_index_0_lang_module_default }]]);
var ExpressionFunctionIcon_vue_vue_type_script_lang_default = { name: "ExpressionFunctionIcon" };
var _hoisted_1$23 = {
	width: "14",
	height: "14",
	viewBox: "0 0 14 14",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
	return openBlock(), createElementBlock("svg", _hoisted_1$23, _cache[0] || (_cache[0] = [createBaseVNode("path", {
		d: "M3.69653 4.35645L3.29907 4.80566L3.33813 4.97559H4.36157C4.15258 6.18457 3.99633 7.27441 3.69653 8.9541C3.33813 11.0967 3.13207 11.623 3.01 11.8154C2.90258 12.0059 2.74829 12.1045 2.5393 12.1045C2.30981 12.1045 1.89477 11.9229 1.67211 11.7168C1.59204 11.6621 1.49731 11.6758 1.39672 11.7422C1.19555 11.9121 1.00024 12.1738 1.00024 12.4082C0.988519 12.7246 1.41137 13 1.81469 13C2.17016 13 2.6936 12.7773 3.24438 12.2539C3.99731 11.54 4.56079 10.5605 5.03149 8.44336C5.33422 7.0918 5.4768 6.21289 5.68969 4.97656L6.96118 4.86133L7.23657 4.35645H5.80493C6.17504 2.02832 6.46411 1.68359 6.81957 1.68359C7.0559 1.68359 7.33129 1.86523 7.6477 2.22266C7.74145 2.35156 7.88207 2.33789 7.9895 2.25C8.17016 2.14258 8.39282 1.86719 8.40747 1.61719C8.41821 1.3418 8.09008 1 7.52563 1C7.01391 1 6.22973 1.3418 5.57055 2.01367C4.99243 2.62598 4.68969 3.39062 4.48071 4.35645H3.69653ZM7.76489 5.91504C8.15942 5.38965 8.39575 5.21484 8.51782 5.21484C8.64379 5.21484 8.74438 5.33887 8.9602 6.03613L9.32934 7.22656C8.61547 8.31836 8.09301 8.92676 7.77563 8.92676C7.67016 8.92676 7.56372 8.89355 7.48852 8.81934C7.4143 8.74512 7.33227 8.68359 7.25219 8.68359C6.99047 8.68359 6.66625 9.00098 6.66039 9.39453C6.65454 9.7959 6.93579 10.083 7.30493 10.083C7.93872 10.083 8.47485 9.46094 9.51 7.81152L9.81274 8.83203C10.0725 9.70898 10.3772 10.083 10.7581 10.083C11.2288 10.083 11.8616 9.68164 12.552 8.59668L12.2629 8.2666C11.8479 8.7666 11.5725 9.00098 11.4094 9.00098C11.2278 9.00098 11.0686 8.72363 10.8586 8.04199L10.4163 6.60352C10.678 6.21777 10.9358 5.89355 11.1623 5.63477C11.4319 5.32715 11.6399 5.19629 11.7815 5.19629C11.9006 5.19629 12.0041 5.24707 12.0686 5.31836C12.1536 5.41211 12.2043 5.45605 12.3049 5.45605C12.5325 5.45605 12.884 5.16699 12.8967 4.78418C12.9084 4.42871 12.6877 4.12598 12.3049 4.12598C11.7268 4.12598 11.217 4.62402 10.2356 6.08301L10.0334 5.45703C9.75024 4.57812 9.56274 4.12598 9.16821 4.12598C8.70922 4.12598 8.07836 4.69043 7.46118 5.58496L7.76489 5.91504Z",
		fill: "#7D838F"
	}, null, -1)]));
}
var ExpressionFunctionIcon_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExpressionFunctionIcon_vue_vue_type_script_lang_default, [["render", _sfc_render$1]]);
var commonThemeProps = (isReadOnly = false) => ({
	"&.cm-focused": { outline: "0 !important" },
	".cm-content": {
		fontFamily: "var(--font-family--monospace)",
		color: "var(--input--color--text, var(--color--text--shade-1))",
		caretColor: isReadOnly ? "transparent" : "var(--code--caret--color)"
	},
	".cm-line": { padding: "0" }
});
const inputTheme = ({ rows, isReadOnly } = {
	rows: 5,
	isReadOnly: false
}) => {
	const maxHeight = Math.max(rows * 22 + 8);
	return [EditorView.theme({
		...commonThemeProps(isReadOnly),
		"&": {
			maxHeight: `${maxHeight}px`,
			minHeight: "30px",
			width: "100%",
			fontSize: "var(--font-size--2xs)",
			padding: "0 0 0 var(--spacing--2xs)",
			borderWidth: "var(--border-width)",
			borderStyle: "var(--input--border-style, var(--border-style))",
			borderColor: "var(--input--border-color, var(--border-color))",
			borderRightColor: "var(--input--border-right-color,var(--input--border-color, var(--border-color)))",
			borderBottomColor: "var(--input--border-bottom-color,var(--input--border-color, var(--border-color)))",
			borderRadius: "var(--input--radius, var(--radius))",
			borderTopLeftRadius: 0,
			borderTopRightRadius: "var(--input-border-top-right-radius, var(--input--radius, var(--radius)))",
			borderBottomLeftRadius: 0,
			borderBottomRightRadius: "var(--input-border-bottom-right-radius, var(--input--radius, var(--radius)))",
			backgroundColor: "white"
		},
		".cm-cursor, .cm-dropCursor": { borderLeftColor: "var(--code--caret--color)" },
		".cm-scroller": { lineHeight: "1.68" },
		".cm-lineWrapping": { wordBreak: "break-all" }
	}), highlighter.resolvableStyle];
};
const outputTheme = () => {
	return [EditorView.theme({
		...commonThemeProps(true),
		"&": {
			maxHeight: "95px",
			width: "100%",
			fontSize: "var(--font-size--2xs)",
			padding: "0",
			borderTopLeftRadius: "0",
			borderBottomLeftRadius: "0",
			backgroundColor: "white"
		},
		".cm-scroller": { lineHeight: "1.6" },
		".cm-valid-resolvable": {
			padding: "0 2px",
			borderRadius: "2px"
		},
		".cm-invalid-resolvable": {
			padding: "0 2px",
			borderRadius: "2px"
		}
	}), highlighter.resolvableStyle];
};
var InlineExpressionEditorInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	__name: "InlineExpressionEditorInput",
	props: {
		modelValue: {},
		path: {},
		rows: { default: 5 },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		additionalData: { default: () => ({}) }
	},
	emits: [
		"update:model-value",
		"update:selection",
		"focus"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const root = ref();
		const extensions = computed(() => [
			Prec.highest(keymap.of(editorKeymap)),
			n8nLang(),
			n8nAutocompletion(),
			inputTheme({
				isReadOnly: props.isReadOnly,
				rows: props.rows
			}),
			history(),
			mappingDropCursor(),
			dropCursor(),
			expressionCloseBrackets(),
			EditorView.lineWrapping,
			infoBoxTooltips()
		]);
		const editorValue = computed(() => props.modelValue);
		onKeyStroke("Backspace", () => {
			if (props.modelValue === "") emit("update:model-value", {
				value: "",
				segments: []
			});
		}, { target: root });
		const { editor: editorRef, segments, selection, readEditorValue, setCursorPosition, hasFocus, focus } = useExpressionEditor({
			editorRef: root,
			editorValue,
			extensions,
			disableSearchDialog: true,
			isReadOnly: computed(() => props.isReadOnly),
			autocompleteTelemetry: {
				enabled: true,
				parameterPath: props.path
			},
			additionalData: props.additionalData
		});
		watch(segments.display, (newSegments) => {
			emit("update:model-value", {
				value: "=" + readEditorValue(),
				segments: newSegments
			});
		});
		watch(selection, (newSelection) => {
			if (editorRef.value) emit("update:selection", {
				state: editorRef.value.state,
				selection: newSelection
			});
		});
		watch(hasFocus, (focused$1) => {
			if (focused$1) emit("focus");
		});
		__expose({
			editor: editorRef,
			setCursorPosition,
			focus: () => {
				if (!hasFocus.value) {
					setCursorPosition("lastExpression");
					focus();
				}
			},
			selectAll: () => {
				editorRef.value?.dispatch({ selection: selection.value.extend(0, editorRef.value?.state.doc.length) });
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "root",
				ref: root,
				title: "",
				"data-test-id": "inline-expression-editor-input"
			}, null, 512);
		};
	}
}), [["__scopeId", "data-v-5824e1ca"]]);
var InlineExpressionTip_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InlineExpressionTip",
	props: {
		editorState: { default: void 0 },
		unresolvedExpression: { default: "" },
		selection: { default: () => EditorSelection.cursor(0) }
	},
	setup(__props) {
		const props = __props;
		const i18n$1 = useI18n();
		const ndvStore = useNDVStore();
		const canAddDotToExpression = ref(false);
		const resolvedExpressionHasFields = ref(false);
		const canDragToFocusedInput = computed(() => !ndvStore.isInputPanelEmpty && ndvStore.focusedMappableInput);
		const emptyExpression = computed(() => props.unresolvedExpression.trim().length === 0);
		const tip$3 = computed(() => {
			if (!ndvStore.hasInputData && ndvStore.isInputParentOfActiveNode && ndvStore.focusedMappableInput) return "executePrevious";
			if (canAddDotToExpression.value) return resolvedExpressionHasFields.value ? "dotObject" : "dotPrimitive";
			if (canDragToFocusedInput.value && emptyExpression.value) return "drag";
			return "default";
		});
		function getCompletionsWithDot() {
			if (!props.editorState || !props.selection || !props.unresolvedExpression) return [];
			const cursorAfterDot = props.selection.from + 1;
			const docWithDot = props.editorState.sliceDoc(0, props.selection.from) + "." + props.editorState.sliceDoc(props.selection.to);
			const selectionWithDot = EditorSelection.create([EditorSelection.cursor(cursorAfterDot)]);
			if (cursorAfterDot >= docWithDot.length) return [];
			return datatypeCompletions(new CompletionContext(EditorState.create({
				doc: docWithDot,
				selection: selectionWithDot
			}), cursorAfterDot, true))?.options ?? [];
		}
		onBeforeUnmount(() => {
			ndvStore.setHighlightDraggables(false);
		});
		watch(tip$3, (newTip) => {
			ndvStore.setHighlightDraggables(!ndvStore.isMappingOnboarded && newTip === "drag");
		}, { immediate: true });
		watchDebounced([() => props.selection, () => props.unresolvedExpression], () => {
			const completions = getCompletionsWithDot();
			canAddDotToExpression.value = completions.length > 0;
			resolvedExpressionHasFields.value = completions.some(({ section }) => isCompletionSection(section) && section.name === FIELDS_SECTION.name);
		}, { debounce: 200 });
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", { class: normalizeClass([_ctx.$style.tip, { [_ctx.$style.drag]: tip$3.value === "drag" }]) }, [createVNode(unref(N8nText_default), {
				size: "small",
				class: normalizeClass(_ctx.$style.tipText)
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.tip")) + ": ", 1)]),
				_: 1
			}, 8, ["class"]), tip$3.value === "drag" ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.content)
			}, [
				createVNode(unref(N8nText_default), {
					size: "small",
					class: normalizeClass(_ctx.$style.text)
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.dragTipBeforePill")), 1)]),
					_: 1
				}, 8, ["class"]),
				createBaseVNode("div", { class: normalizeClass([_ctx.$style.pill, { [_ctx.$style.highlight]: !unref(ndvStore).isMappingOnboarded }]) }, toDisplayString(unref(i18n$1).baseText("parameterInput.inputField")), 3),
				createVNode(unref(N8nText_default), {
					size: "small",
					class: normalizeClass(_ctx.$style.text)
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.dragTipAfterPill")), 1)]),
					_: 1
				}, 8, ["class"])
			], 2)) : tip$3.value === "executePrevious" ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.content)
			}, [createBaseVNode("span", null, toDisplayString(unref(i18n$1).baseText("expressionTip.noExecutionData")), 1)], 2)) : tip$3.value === "dotPrimitive" ? (openBlock(), createElementBlock("div", {
				key: 2,
				class: normalizeClass(_ctx.$style.content)
			}, [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, unref(i18n$1).baseText("expressionTip.typeDotPrimitive")]])], 2)) : tip$3.value === "dotObject" ? (openBlock(), createElementBlock("div", {
				key: 3,
				class: normalizeClass(_ctx.$style.content)
			}, [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, unref(i18n$1).baseText("expressionTip.typeDotObject")]])], 2)) : (openBlock(), createElementBlock("div", {
				key: 4,
				class: normalizeClass(_ctx.$style.content)
			}, [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, unref(i18n$1).baseText("expressionTip.javascript")]])], 2))], 2);
		};
	}
});
var InlineExpressionTip_vue_vue_type_style_index_0_lang_module_default = {
	tip: "_tip_1m7jj_123",
	content: "_content_1m7jj_139",
	tipText: "_tipText_1m7jj_143",
	drag: "_drag_1m7jj_150",
	text: "_text_1m7jj_154",
	pill: "_pill_1m7jj_158",
	highlight: "_highlight_1m7jj_170"
};
var InlineExpressionTip_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InlineExpressionTip_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InlineExpressionTip_vue_vue_type_style_index_0_lang_module_default }]]);
var InlineExpressionEditorOutput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InlineExpressionEditorOutput",
	props: {
		segments: {},
		unresolvedExpression: { default: void 0 },
		editorState: { default: void 0 },
		selection: { default: void 0 },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		visible: { type: Boolean },
		virtualRef: {}
	},
	setup(__props, { expose: __expose }) {
		const i18n$1 = useI18n();
		const theme = outputTheme();
		const ndvStore = useNDVStore();
		const contentRef = useTemplateRef("content");
		const { APP_Z_INDEXES } = useStyles();
		onBeforeUnmount(() => {
			ndvStore.expressionOutputItemIndex = 0;
		});
		__expose({ contentRef });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nPopoverReka_default), {
				open: _ctx.visible,
				side: "bottom",
				"side-flip": false,
				"side-offset": 0,
				align: "start",
				reference: _ctx.virtualRef,
				width: "var(--reka-popper-anchor-width)",
				"content-class": _ctx.$style.popover,
				"enable-slide-in": false,
				"enable-scrolling": false,
				"suppress-auto-focus": true,
				"z-index": unref(APP_Z_INDEXES).NDV + 1
			}, {
				content: withCtx(() => [createBaseVNode("div", {
					ref: "content",
					class: normalizeClass([_ctx.$style.dropdown, "ignore-key-press-canvas"])
				}, [
					createBaseVNode("div", { class: normalizeClass(_ctx.$style.header) }, [createVNode(unref(N8nText_default), {
						bold: "",
						size: "small",
						compact: ""
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.result")), 1)]),
						_: 1
					}), createVNode(OutputItemSelect_default)], 2),
					createVNode(unref(N8nText_default), { class: normalizeClass(_ctx.$style.body) }, {
						default: withCtx(() => [createVNode(ExpressionOutput_default, {
							"data-test-id": "inline-expression-editor-output",
							segments: _ctx.segments,
							extensions: unref(theme)
						}, null, 8, ["segments", "extensions"])]),
						_: 1
					}, 8, ["class"]),
					!_ctx.isReadOnly ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.footer)
					}, [createVNode(InlineExpressionTip_default, {
						"editor-state": _ctx.editorState,
						selection: _ctx.selection,
						"unresolved-expression": _ctx.unresolvedExpression
					}, null, 8, [
						"editor-state",
						"selection",
						"unresolved-expression"
					])], 2)) : createCommentVNode("", true)
				], 2)]),
				_: 1
			}, 8, [
				"open",
				"reference",
				"content-class",
				"z-index"
			]);
		};
	}
});
var InlineExpressionEditorOutput_vue_vue_type_style_index_0_lang_module_default = {
	popover: "_popover_1r5mp_123",
	dropdown: "_dropdown_1r5mp_129",
	body: "_body_1r5mp_141",
	footer: "_footer_1r5mp_150",
	header: "_header_1r5mp_153"
};
var InlineExpressionEditorOutput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InlineExpressionEditorOutput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InlineExpressionEditorOutput_vue_vue_type_style_index_0_lang_module_default }]]);
function useIsInExperimentalNdv() {
	const expressionLocalResolveCtx = inject(ExpressionLocalResolveContextSymbol, void 0);
	return computed(() => expressionLocalResolveCtx?.value !== void 0);
}
var _hoisted_1$22 = { key: 0 };
var ExpressionParameterInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExpressionParameterInput",
	props: {
		path: {},
		modelValue: {},
		rows: { default: 5 },
		additionalExpressionData: { default: () => ({}) },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		isAssignment: {
			type: Boolean,
			default: false
		},
		eventBus: { default: () => createEventBus() }
	},
	emits: [
		"modal-opener-click",
		"update:model-value",
		"focus",
		"blur"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const isFocused = ref(false);
		const segments = ref([]);
		const editorState = ref();
		const selection = ref();
		const inlineInput = ref();
		const container$4 = ref();
		const outputPopover = ref();
		const props = __props;
		const emit = __emit;
		const telemetry = useTelemetry();
		const ndvStore = useNDVStore();
		const workflowsStore = useWorkflowsStore();
		const canvas = inject(CanvasKey, void 0);
		const isInExperimentalNdv = useIsInExperimentalNdv();
		const isDragging = computed(() => ndvStore.isDraggableDragging);
		const isOutputPopoverVisible = computed(() => isFocused.value && (!isInExperimentalNdv.value || !canvas?.isPaneMoving.value));
		function select$1() {
			if (inlineInput.value) inlineInput.value.selectAll();
		}
		function focus() {
			if (inlineInput.value) inlineInput.value.focus();
		}
		function onFocus() {
			isFocused.value = true;
			emit("focus");
		}
		function onBlur(event) {
			if (event?.target instanceof Element && Array.from(event.target.classList).some((_class) => _class.includes("resizer"))) return;
			if (isEventTargetContainedBy(event?.target, outputPopover.value?.contentRef)) return;
			const wasFocused = isFocused.value;
			isFocused.value = false;
			if (wasFocused) {
				emit("blur", event);
				const telemetryPayload = createExpressionTelemetryPayload(segments.value, props.modelValue, workflowsStore.workflowId, ndvStore.pushRef, ndvStore.activeNode?.type ?? "");
				telemetry.track("User closed Expression Editor", telemetryPayload);
			}
		}
		function onValueChange({ value: value$1, segments: newSegments }) {
			segments.value = newSegments;
			if (isDragging.value) return;
			if (value$1 === "=" + props.modelValue) return;
			emit("update:model-value", value$1);
		}
		function onSelectionChange({ state: newState, selection: newSelection }) {
			editorState.value = newState;
			selection.value = newSelection;
		}
		async function onDrop(value$1, event) {
			if (!inlineInput.value) return;
			const { editor: editor$5, setCursorPosition } = inlineInput.value;
			if (!editor$5) return;
			const droppedSelection = await dropInExpressionEditor(toRaw(editor$5), event, value$1);
			if (!ndvStore.isMappingOnboarded) ndvStore.setMappingOnboarded();
			if (!ndvStore.isAutocompleteOnboarded) {
				setCursorPosition((droppedSelection.ranges.at(0)?.head ?? 3) - 3);
				setTimeout(() => {
					startCompletion(editor$5);
				});
			}
		}
		async function onDropOnFixedInput() {
			await nextTick();
			if (!inlineInput.value) return;
			const { editor: editor$5, setCursorPosition } = inlineInput.value;
			if (!editor$5 || ndvStore.isAutocompleteOnboarded) return;
			setCursorPosition("lastExpression");
			setTimeout(() => {
				focus();
				startCompletion(editor$5);
			});
		}
		onMounted(() => {
			props.eventBus.on("drop", onDropOnFixedInput);
		});
		onBeforeUnmount(() => {
			props.eventBus.off("drop", onDropOnFixedInput);
		});
		watch(isDragging, (newIsDragging) => {
			if (newIsDragging && !isInExperimentalNdv.value) onBlur();
		});
		onClickOutside(container$4, (event) => onBlur(event));
		__expose({
			focus,
			select: select$1
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "container",
				ref: container$4,
				class: normalizeClass(_ctx.$style["expression-parameter-input"]),
				onKeydown: withKeys(onBlur, ["tab"])
			}, [createBaseVNode("div", { class: normalizeClass([_ctx.$style["all-sections"], {
				[_ctx.$style.focused]: isFocused.value,
				[_ctx.$style.assignment]: _ctx.isAssignment
			}]) }, [
				createBaseVNode("div", { class: normalizeClass([_ctx.$style["prepend-section"], "el-input-group__prepend"]) }, [_ctx.isAssignment ? (openBlock(), createElementBlock("span", _hoisted_1$22, "=")) : (openBlock(), createBlock(ExpressionFunctionIcon_default, { key: 1 }))], 2),
				createVNode(DraggableTarget_default, {
					type: "mapping",
					disabled: _ctx.isReadOnly,
					onDrop
				}, {
					default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createVNode(InlineExpressionEditorInput_default, {
						ref_key: "inlineInput",
						ref: inlineInput,
						"model-value": _ctx.modelValue,
						path: _ctx.path,
						"is-read-only": _ctx.isReadOnly,
						rows: _ctx.rows,
						"additional-data": _ctx.additionalExpressionData,
						class: normalizeClass({
							[_ctx.$style.activeDrop]: activeDrop$8,
							[_ctx.$style.droppable]: droppable$10
						}),
						onFocus,
						onBlur,
						"onUpdate:modelValue": onValueChange,
						"onUpdate:selection": onSelectionChange
					}, null, 8, [
						"model-value",
						"path",
						"is-read-only",
						"rows",
						"additional-data",
						"class"
					])]),
					_: 1
				}, 8, ["disabled"]),
				!isDragging.value ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 0,
					square: "",
					outline: "",
					type: "tertiary",
					icon: "external-link",
					size: "mini",
					class: normalizeClass(_ctx.$style["expression-editor-modal-opener"]),
					"data-test-id": "expander",
					onClick: _cache[0] || (_cache[0] = ($event) => emit("modal-opener-click"))
				}, null, 8, ["class"])) : createCommentVNode("", true)
			], 2), createVNode(InlineExpressionEditorOutput_default, {
				ref_key: "outputPopover",
				ref: outputPopover,
				visible: isOutputPopoverVisible.value,
				"unresolved-expression": _ctx.modelValue,
				selection: selection.value,
				"editor-state": editorState.value,
				segments: segments.value,
				"is-read-only": _ctx.isReadOnly,
				"virtual-ref": container$4.value
			}, null, 8, [
				"visible",
				"unresolved-expression",
				"selection",
				"editor-state",
				"segments",
				"is-read-only",
				"virtual-ref"
			])], 34);
		};
	}
});
const assignment$1 = "_assignment_dv7b3_142";
const focused = "_focused_dv7b3_168";
const droppable$7 = "_droppable_dv7b3_183";
const activeDrop$5 = "_activeDrop_dv7b3_192";
var ExpressionParameterInput_vue_vue_type_style_index_0_lang_module_default = {
	"expression-parameter-input": "_expression-parameter-input_dv7b3_123",
	"all-sections": "_all-sections_dv7b3_130",
	"prepend-section": "_prepend-section_dv7b3_135",
	assignment: assignment$1,
	"expression-editor-modal-opener": "_expression-editor-modal-opener_dv7b3_147",
	focused,
	droppable: droppable$7,
	activeDrop: activeDrop$5
};
var ExpressionParameterInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExpressionParameterInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExpressionParameterInput_vue_vue_type_style_index_0_lang_module_default }]]);
var ParameterIssues_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterIssues",
	props: { issues: {} },
	setup(__props) {
		const i18n$1 = useI18n();
		return (_ctx, _cache) => {
			return _ctx.issues.length ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style["parameter-issues"]),
				"data-test-id": "parameter-issues"
			}, [createVNode(unref(N8nTooltip_default), { placement: "top" }, {
				content: withCtx(() => [createVNode(TitledList_default, {
					title: `${unref(i18n$1).baseText("parameterInput.issues")}:`,
					items: _ctx.issues
				}, null, 8, ["title", "items"])]),
				default: withCtx(() => [createVNode(unref(N8nIcon_default), { icon: "triangle-alert" })]),
				_: 1
			})], 2)) : createCommentVNode("", true);
		};
	}
});
var ParameterIssues_vue_vue_type_style_index_0_lang_module_default = { "parameter-issues": "_parameter-issues_lx5fm_123" };
var ParameterIssues_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterIssues_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterIssues_vue_vue_type_style_index_0_lang_module_default }]]);
var require_fast_json_stable_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(data, opts) {
		if (!opts) opts = {};
		if (typeof opts === "function") opts = { cmp: opts };
		var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
		var cmp = opts.cmp && (function(f) {
			return function(node$1) {
				return function(a, b$1) {
					return f({
						key: a,
						value: node$1[a]
					}, {
						key: b$1,
						value: node$1[b$1]
					});
				};
			};
		})(opts.cmp);
		var seen = [];
		return (function stringify$1(node$1) {
			if (node$1 && node$1.toJSON && typeof node$1.toJSON === "function") node$1 = node$1.toJSON();
			if (node$1 === void 0) return;
			if (typeof node$1 == "number") return isFinite(node$1) ? "" + node$1 : "null";
			if (typeof node$1 !== "object") return JSON.stringify(node$1);
			var i, out;
			if (Array.isArray(node$1)) {
				out = "[";
				for (i = 0; i < node$1.length; i++) {
					if (i) out += ",";
					out += stringify$1(node$1[i]) || "null";
				}
				return out + "]";
			}
			if (node$1 === null) return "null";
			if (seen.indexOf(node$1) !== -1) {
				if (cycles) return JSON.stringify("__cycle__");
				throw new TypeError("Converting circular structure to JSON");
			}
			var seenIndex = seen.push(node$1) - 1;
			var keys = Object.keys(node$1).sort(cmp && cmp(node$1));
			out = "";
			for (i = 0; i < keys.length; i++) {
				var key = keys[i];
				var value$1 = stringify$1(node$1[key]);
				if (!value$1) continue;
				if (out) out += ",";
				out += JSON.stringify(key) + ":" + value$1;
			}
			seen.splice(seenIndex, 1);
			return "{" + out + "}";
		})(data);
	};
}));
var _hoisted_1$21 = ["onClick", "onMouseenter"];
var _hoisted_2$9 = { key: 0 };
var _hoisted_3$8 = { key: 1 };
var SEARCH_BAR_HEIGHT_PX = 40;
var SCROLL_MARGIN_PX = 10;
var ResourceLocatorDropdown_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ResourceLocatorDropdown",
	props: {
		modelValue: { default: void 0 },
		resources: { default: () => [] },
		show: {
			type: Boolean,
			default: false
		},
		filterable: {
			type: Boolean,
			default: false
		},
		loading: {
			type: Boolean,
			default: false
		},
		filter: { default: "" },
		hasMore: {
			type: Boolean,
			default: false
		},
		errorView: {
			type: Boolean,
			default: false
		},
		filterRequired: {
			type: Boolean,
			default: false
		},
		width: { default: void 0 },
		allowNewResources: { default: () => ({}) },
		eventBus: { default: () => createEventBus() }
	},
	emits: [
		"update:modelValue",
		"loadMore",
		"filter",
		"addResourceClick"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const $style = useCssModule();
		const hoverIndex = ref(0);
		const showHoverUrl = ref(false);
		const searchRef = ref();
		const resultsContainerRef = ref();
		const itemsRef = ref([]);
		const sortedResources = computed(() => {
			const seen = /* @__PURE__ */ new Set();
			const result = props.resources.reduce((acc, item$2) => {
				if (seen.has(item$2.value)) return acc;
				seen.add(item$2.value);
				if (props.modelValue && item$2.value === props.modelValue.value) acc.selected = item$2;
				else if (!item$2.isArchived) acc.notSelected.push(item$2);
				return acc;
			}, {
				selected: null,
				notSelected: []
			});
			if (result.selected === null && props.modelValue?.cachedResultName && props.modelValue.value) result.selected = {
				name: props.modelValue.cachedResultName,
				value: props.modelValue.value,
				url: props.modelValue.cachedResultUrl
			};
			if (result.selected) return [result.selected, ...result.notSelected];
			return result.notSelected;
		});
		watch(() => props.show, (value$1) => {
			if (value$1) {
				hoverIndex.value = 0;
				showHoverUrl.value = false;
				setTimeout(() => {
					if (value$1 && props.filterable && searchRef.value) searchRef.value.focus();
				}, 0);
			}
		});
		onMounted(() => {
			props.eventBus.on("keyDown", onKeyDown);
		});
		onBeforeUnmount(() => {
			props.eventBus.off("keyDown", onKeyDown);
		});
		function openUrl(event, url) {
			event.preventDefault();
			event.stopPropagation();
			window.open(url, "_blank");
		}
		function onKeyDown(e) {
			if (e.key === "ArrowDown") {
				if (hoverIndex.value < sortedResources.value.length) {
					hoverIndex.value++;
					if (resultsContainerRef.value && itemsRef.value.length === 1) {
						const item$2 = itemsRef.value[0];
						if (item$2.offsetTop + item$2.clientHeight > resultsContainerRef.value.scrollTop + resultsContainerRef.value.offsetHeight) {
							const top = item$2.offsetTop - resultsContainerRef.value.offsetHeight + item$2.clientHeight;
							resultsContainerRef.value.scrollTo({ top });
						}
					}
				}
			} else if (e.key === "ArrowUp") {
				if (hoverIndex.value > 0) {
					hoverIndex.value--;
					const searchOffset = props.filterable ? SEARCH_BAR_HEIGHT_PX : 0;
					if (resultsContainerRef.value && itemsRef.value.length === 1) {
						const item$2 = itemsRef.value[0];
						if (item$2.offsetTop <= resultsContainerRef.value.scrollTop + searchOffset) resultsContainerRef.value.scrollTo({ top: item$2.offsetTop - searchOffset });
					}
				}
			} else if (e.key === "Enter") {
				if (hoverIndex.value === 0 && props.allowNewResources.label) {
					emit("addResourceClick");
					return;
				}
				const selected$1 = sortedResources.value[hoverIndex.value - 1]?.value;
				if (selected$1 && typeof selected$1 !== "boolean") emit("update:modelValue", selected$1);
			}
		}
		function onFilterInput(value$1) {
			emit("filter", value$1);
		}
		function onItemClick(selected$1) {
			if (typeof selected$1 === "boolean") return;
			emit("update:modelValue", selected$1);
		}
		function onItemHover(index$1) {
			hoverIndex.value = index$1;
			setTimeout(() => {
				if (hoverIndex.value === index$1) showHoverUrl.value = true;
			}, 250);
		}
		function onItemHoverLeave() {
			showHoverUrl.value = false;
		}
		function onResultsEnd() {
			if (props.loading || !props.hasMore) return;
			if (resultsContainerRef.value) {
				const diff = resultsContainerRef.value.offsetHeight - (resultsContainerRef.value.scrollHeight - resultsContainerRef.value.scrollTop);
				if (diff > -SCROLL_MARGIN_PX && diff < SCROLL_MARGIN_PX) emit("loadMore");
			}
		}
		function isWithinDropdown(element) {
			return Boolean(element.closest("." + $style.popover));
		}
		__expose({ isWithinDropdown });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nPopover_default), {
				placement: "bottom",
				width: props.width,
				"popper-class": unref($style).popover,
				visible: props.show,
				teleported: false,
				"data-test-id": "resource-locator-dropdown"
			}, {
				reference: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
				default: withCtx(() => [
					props.errorView ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(unref($style).messageContainer)
					}, [renderSlot(_ctx.$slots, "error")], 2)) : createCommentVNode("", true),
					props.filterable && !props.errorView ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(unref($style).searchInput),
						onKeydown: onKeyDown
					}, [createVNode(unref(N8nInput_default), {
						ref_key: "searchRef",
						ref: searchRef,
						"model-value": props.filter,
						clearable: true,
						placeholder: props.allowNewResources.label ? unref(i18n$1).baseText("resourceLocator.placeholder.searchOrCreate") : unref(i18n$1).baseText("resourceLocator.placeholder.search"),
						"data-test-id": "rlc-search",
						"onUpdate:modelValue": onFilterInput
					}, {
						prefix: withCtx(() => [createVNode(unref(N8nIcon_default), {
							class: normalizeClass(unref($style).searchIcon),
							icon: "search"
						}, null, 8, ["class"])]),
						_: 1
					}, 8, ["model-value", "placeholder"])], 34)) : createCommentVNode("", true),
					props.filterRequired && !props.filter && !props.errorView && !props.loading ? (openBlock(), createElementBlock("div", {
						key: 2,
						class: normalizeClass(unref($style).searchRequired)
					}, toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.searchRequired")), 3)) : !props.errorView && !props.allowNewResources.label && sortedResources.value.length === 0 && !props.loading ? (openBlock(), createElementBlock("div", {
						key: 3,
						class: normalizeClass(unref($style).messageContainer)
					}, toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.noResults")), 3)) : !props.errorView ? (openBlock(), createElementBlock("div", {
						key: 4,
						ref_key: "resultsContainerRef",
						ref: resultsContainerRef,
						class: normalizeClass(unref($style).container),
						onScroll: onResultsEnd
					}, [
						props.allowNewResources.label ? (openBlock(), createElementBlock("div", {
							key: "addResourceKey",
							ref_key: "itemsRef",
							ref: itemsRef,
							"data-test-id": "rlc-item-add-resource",
							class: normalizeClass({
								[unref($style).resourceItem]: true,
								[unref($style).hovering]: hoverIndex.value === 0
							}),
							onMouseenter: _cache[0] || (_cache[0] = () => onItemHover(0)),
							onMouseleave: _cache[1] || (_cache[1] = () => onItemHoverLeave()),
							onClick: _cache[2] || (_cache[2] = () => emit("addResourceClick"))
						}, [createBaseVNode("div", { class: normalizeClass(unref($style).resourceNameContainer) }, [createBaseVNode("span", { class: normalizeClass(unref($style).addResourceText) }, toDisplayString(props.allowNewResources.label), 3), createVNode(unref(N8nIcon_default), {
							class: normalizeClass(unref($style).addResourceIcon),
							icon: "plus"
						}, null, 8, ["class"])], 2)], 34)) : createCommentVNode("", true),
						(openBlock(true), createElementBlock(Fragment, null, renderList(sortedResources.value, (result, i) => {
							return openBlock(), createElementBlock("div", {
								key: result.value.toString(),
								ref_for: true,
								ref_key: "itemsRef",
								ref: itemsRef,
								class: normalizeClass({
									[unref($style).resourceItem]: true,
									[unref($style).selected]: result.value === props.modelValue?.value,
									[unref($style).hovering]: hoverIndex.value === i + 1
								}),
								"data-test-id": "rlc-item",
								onClick: () => onItemClick(result.value),
								onMouseenter: () => onItemHover(i + 1),
								onMouseleave: _cache[3] || (_cache[3] = () => onItemHoverLeave())
							}, [createBaseVNode("div", { class: normalizeClass(unref($style).resourceNameContainer) }, [createBaseVNode("span", null, toDisplayString(result.name), 1), result.isArchived ? (openBlock(), createElementBlock("span", _hoisted_2$9, [createVNode(unref(N8nBadge_default), {
								class: "ml-3xs",
								theme: "tertiary",
								bold: "",
								"data-test-id": "workflow-archived-tag"
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("workflows.item.archived")), 1)]),
								_: 1
							})])) : createCommentVNode("", true)], 2), createBaseVNode("div", { class: normalizeClass(unref($style).urlLink) }, [showHoverUrl.value && result.url && hoverIndex.value === i + 1 ? (openBlock(), createBlock(unref(N8nIcon_default), {
								key: 0,
								icon: "external-link",
								title: result.linkAlt || unref(i18n$1).baseText("resourceLocator.mode.list.openUrl"),
								onClick: ($event) => openUrl($event, result.url)
							}, null, 8, ["title", "onClick"])) : createCommentVNode("", true)], 2)], 42, _hoisted_1$21);
						}), 128)),
						props.loading && !props.errorView ? (openBlock(), createElementBlock("div", _hoisted_3$8, [(openBlock(), createElementBlock(Fragment, null, renderList(3, (i) => {
							return createBaseVNode("div", {
								key: i,
								class: normalizeClass(unref($style).loadingItem)
							}, [createVNode(unref(N8nLoading_default), {
								class: normalizeClass(unref($style).loader),
								variant: "p",
								rows: 1
							}, null, 8, ["class"])], 2);
						}), 64))])) : createCommentVNode("", true)
					], 34)) : createCommentVNode("", true)
				]),
				_: 3
			}, 8, [
				"width",
				"popper-class",
				"visible"
			]);
		};
	}
});
var ResourceLocatorDropdown_vue_vue_type_style_index_0_lang_module_default = {
	popover: "_popover_1i31t_123",
	container: "_container_1i31t_143",
	messageContainer: "_messageContainer_1i31t_148",
	searchInput: "_searchInput_1i31t_155",
	selected: "_selected_1i31t_163",
	resourceItem: "_resourceItem_1i31t_167",
	loadingItem: "_loadingItem_1i31t_178",
	loader: "_loader_1i31t_182",
	hovering: "_hovering_1i31t_190",
	searchRequired: "_searchRequired_1i31t_194",
	urlLink: "_urlLink_1i31t_204",
	resourceNameContainer: "_resourceNameContainer_1i31t_215",
	searchIcon: "_searchIcon_1i31t_228",
	addResourceText: "_addResourceText_1i31t_232",
	addResourceIcon: "_addResourceIcon_1i31t_236"
};
var ResourceLocatorDropdown_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ResourceLocatorDropdown_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ResourceLocatorDropdown_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$20 = ["width", "height"];
var AiStarsIcon_default = /* @__PURE__ */ defineComponent({
	__name: "AiStarsIcon",
	props: { size: { default: "medium" } },
	setup(__props) {
		const sizes = {
			mini: 8,
			small: 10,
			medium: 12,
			large: 16
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("svg", {
				width: sizes[_ctx.size],
				height: sizes[_ctx.size],
				viewBox: "0 0 16 16",
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg"
			}, _cache[0] || (_cache[0] = [createBaseVNode("g", { id: "NodeIcon" }, [createBaseVNode("path", {
				id: "Union",
				"fill-rule": "evenodd",
				"clip-rule": "evenodd",
				d: "M15.7982 7.80784L13.92 7.20243C12.7186 6.80602 12.0148 5.83386 11.6844 4.61226L10.8579 0.586096C10.8363 0.506544 10.7837 0.400024 10.6219 0.400024C10.4857 0.400024 10.4075 0.506544 10.386 0.586096L9.55943 4.61361C9.22773 5.83521 8.52525 6.80737 7.32387 7.20378L5.44562 7.80919C5.18 7.89548 5.17595 8.27032 5.44023 8.36066L7.33196 9.01191C8.52929 9.40968 9.22773 10.3805 9.55943 11.5967L10.3873 15.5784C10.4089 15.6579 10.4534 15.8008 10.6233 15.8008C10.7991 15.8008 10.8362 15.6634 10.858 15.5831L10.8592 15.5784L11.6871 11.5967C12.0188 10.3791 12.7173 9.40833 13.9146 9.01191L15.8063 8.36066C16.0679 8.26897 16.0639 7.89413 15.7982 7.80784ZM5.04114 11.3108C3.92815 10.9434 3.81743 10.5296 3.63184 9.83597L3.62672 9.81687L3.15615 8.16649C3.12784 8.05997 2.85008 8.05997 2.82041 8.16649L2.50085 9.69147C2.31074 10.394 1.90623 10.9522 1.21588 11.18L0.11563 11.6574C-0.0367335 11.7072 -0.0394302 11.923 0.112933 11.9742L1.22127 12.3666C1.90893 12.5945 2.31074 13.1527 2.5022 13.8525L2.82176 15.3114C2.85142 15.4179 3.12784 15.4179 3.15615 15.3114L3.53099 13.8592C3.72111 13.1554 4.01235 12.5958 4.94675 12.3666L5.98768 11.9742C6.14004 11.9216 6.13869 11.7059 5.98498 11.656L5.04114 11.3108ZM5.33019 0.812949C5.36674 0.661849 5.58158 0.659434 5.61894 0.811355L5.61899 0.811582L6.02856 2.50239C6.08442 2.69624 6.23624 2.8465 6.43132 2.89951L7.47286 3.18013C7.61383 3.2197 7.61829 3.41714 7.48035 3.46394L7.48015 3.46401L6.38799 3.83076C6.21241 3.88968 6.07619 4.03027 6.02153 4.20719L5.61894 5.77311L5.61884 5.77349C5.58095 5.92613 5.36829 5.91987 5.33166 5.77336L4.94237 4.21215C4.88888 4.03513 4.75378 3.89336 4.57956 3.83328L3.48805 3.4555C3.34919 3.40591 3.36033 3.20859 3.50031 3.17175L3.50054 3.17169L4.53472 2.90337C4.73486 2.85153 4.89134 2.69755 4.94463 2.49805L5.33019 0.812949Z",
				fill: "currentColor"
			})], -1)]), 8, _hoisted_1$20);
		};
	}
});
var FromAiOverrideButton_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FromAiOverrideButton",
	emits: ["click"],
	setup(__props, { emit: __emit }) {
		const i18n$1 = useI18n();
		const emit = __emit;
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nTooltip_default), null, {
				content: withCtx(() => [createBaseVNode("div", null, toDisplayString(unref(i18n$1).baseText("parameterOverride.applyOverrideButtonTooltip")), 1)]),
				default: withCtx(() => [createVNode(unref(N8nButton_default), {
					class: normalizeClass([_ctx.$style.overrideButton]),
					type: "tertiary",
					"data-test-id": "from-ai-override-button",
					onClick: _cache[0] || (_cache[0] = ($event) => emit("click"))
				}, {
					default: withCtx(() => [createBaseVNode("span", null, [createVNode(AiStarsIcon_default, { size: "large" })])]),
					_: 1
				}, 8, ["class"])]),
				_: 1
			});
		};
	}
});
var FromAiOverrideButton_vue_vue_type_style_index_0_lang_module_default = { overrideButton: "_overrideButton_noctn_123" };
var FromAiOverrideButton_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FromAiOverrideButton_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FromAiOverrideButton_vue_vue_type_style_index_0_lang_module_default }]]);
var FromAiOverrideField_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FromAiOverrideField",
	props: { isReadOnly: { type: Boolean } },
	emits: ["close"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.contentOverrideContainer),
				"data-test-id": "fromAI-override-field"
			}, [
				createBaseVNode("div", { class: normalizeClass([
					_ctx.$style.iconStars,
					"el-input-group__prepend",
					_ctx.$style.noCornersRight
				]) }, [createVNode(AiStarsIcon_default)], 2),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.overrideInput) }, [withDirectives(createVNode(unref(N8nText_default), {
					color: "text-dark",
					size: "small"
				}, null, 512), [[_directive_n8n_html, unref(i18n).baseText("parameterOverride.overridePanelText")]])], 2),
				!_ctx.isReadOnly ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 0,
					type: "tertiary",
					class: normalizeClass(["n8n-input", _ctx.$style.overrideCloseButton]),
					outline: false,
					icon: "x",
					size: "small",
					onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
				}, null, 8, ["class"])) : createCommentVNode("", true)
			], 2);
		};
	}
});
var FromAiOverrideField_vue_vue_type_style_index_0_lang_module_default = {
	iconStars: "_iconStars_2vu8u_123",
	noCornersRight: "_noCornersRight_2vu8u_133",
	overrideInput: "_overrideInput_2vu8u_138",
	overrideCloseButton: "_overrideCloseButton_2vu8u_145",
	contentOverrideContainer: "_contentOverrideContainer_2vu8u_155"
};
var FromAiOverrideField_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FromAiOverrideField_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FromAiOverrideField_vue_vue_type_style_index_0_lang_module_default }]]);
var ParameterOverrideSelectableList_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterOverrideSelectableList",
	props: /* @__PURE__ */ mergeModels({
		parameter: {},
		path: {},
		isReadOnly: {
			type: Boolean,
			default: false
		}
	}, {
		"modelValue": { required: true },
		"modelModifiers": {}
	}),
	emits: /* @__PURE__ */ mergeModels(["update"], ["update:modelValue"]),
	setup(__props, { emit: __emit }) {
		const parameterOverride = useModel(__props, "modelValue");
		const props = __props;
		const inputs$1 = computed(() => Object.entries(parameterOverride.value.extraProps).map(([name, prop]) => ({
			name,
			...prop
		})));
		function proper(s) {
			return s[0].toUpperCase() + s.slice(1);
		}
		const emit = __emit;
		function valueChanged(parameterData) {
			emit("update", parameterData);
		}
		function onExtraPropValueRemove(name) {
			delete parameterOverride.value.extraPropValues[name];
			valueChanged({
				name: props.path,
				value: buildValueFromOverride(parameterOverride.value, props, true)
			});
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nSelectableList_default), {
				modelValue: parameterOverride.value.extraPropValues,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => parameterOverride.value.extraPropValues = $event),
				class: "mt-2xs",
				inputs: inputs$1.value,
				disabled: _ctx.isReadOnly,
				onRemoveItem: onExtraPropValueRemove
			}, {
				displayItem: withCtx(({ name, tooltip, initialValue, type, typeOptions }) => [createVNode(ParameterInputFull_default, {
					parameter: {
						name,
						displayName: proper(name),
						type,
						default: initialValue,
						noDataExpression: true,
						description: tooltip,
						typeOptions
					},
					"is-read-only": _ctx.isReadOnly,
					value: parameterOverride.value?.extraPropValues[name],
					path: `${_ctx.path}.${name}`,
					"input-size": "small",
					onUpdate: (x) => {
						parameterOverride.value.extraPropValues[name] = x.value;
						valueChanged({
							name: props.path,
							value: unref(buildValueFromOverride)(parameterOverride.value, props, true)
						});
					}
				}, null, 8, [
					"parameter",
					"is-read-only",
					"value",
					"path",
					"onUpdate"
				])]),
				_: 1
			}, 8, [
				"modelValue",
				"inputs",
				"disabled"
			]);
		};
	}
});
var import_fast_json_stable_stringify = /* @__PURE__ */ __toESM(require_fast_json_stable_stringify());
var _hoisted_1$19 = ["data-test-id"];
var _hoisted_2$8 = {
	key: 0,
	"data-test-id": "rlc-error-code"
};
var _hoisted_3$7 = { "data-test-id": "rlc-error-message" };
var _hoisted_4$6 = {
	key: 2,
	"data-test-id": "permission-error-link"
};
var ResourceLocator_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ResourceLocator",
	props: {
		modelValue: {},
		parameter: {},
		path: {},
		loadOptionsMethod: { default: void 0 },
		node: { default: void 0 },
		inputSize: { default: "small" },
		parameterIssues: { default: () => [] },
		dependentParametersValues: { default: null },
		displayTitle: { default: "" },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		expressionComputedValue: {},
		expressionDisplayValue: { default: "" },
		forceShowExpression: {
			type: Boolean,
			default: false
		},
		isValueExpression: {
			type: Boolean,
			default: false
		},
		expressionEditDialogVisible: {
			type: Boolean,
			default: false
		},
		eventBus: { default: () => createEventBus() }
	},
	emits: [
		"update:modelValue",
		"drop",
		"blur",
		"modalOpenerClick"
	],
	setup(__props, { emit: __emit }) {
		const CHECK_CREDENTIALS_REGEX = /check\s+(your\s+)?credentials?/i;
		const PERMISSION_ERROR_CODES = ["401", "403"];
		const NODE_API_AUTH_ERROR_MESSAGES = [
			"NodeApiError: Authorization failed",
			"NodeApiError: Unable to sign without access token",
			"secretOrPrivateKey must be an asymmetric key when using RS256"
		];
		const props = __props;
		const emit = __emit;
		const workflowHelpers = useWorkflowHelpers();
		const { callDebounced } = useDebounce();
		const i18n$1 = useI18n();
		const telemetry = useTelemetry();
		const $style = useCssModule();
		const resourceDropdownVisible = ref(false);
		const resourceDropdownHiding = ref(false);
		const searchFilter = ref("");
		const cachedResponses = ref({});
		const hasCompletedASearch = ref(false);
		const width = ref(0);
		const inputRef = ref();
		const containerRef = ref();
		const dropdownRef = ref();
		const nodeTypesStore = useNodeTypesStore();
		const ndvStore = useNDVStore();
		const rootStore = useRootStore();
		const uiStore = useUIStore();
		const workflowsStore = useWorkflowsStore();
		const projectsStore = useProjectsStore();
		const appName = computed(() => {
			if (!props.node) return "";
			return getAppNameFromNodeName(nodeTypesStore.getNodeType(props.node.type)?.displayName ?? "");
		});
		const selectedMode = computed(() => {
			if (typeof props.modelValue !== "object") return "";
			if (!props.modelValue) return props.parameter.modes ? props.parameter.modes[0].name : "";
			return props.modelValue.mode;
		});
		const isListMode = computed(() => selectedMode.value === "list");
		const hasCredentialError = computed(() => {
			const stackTraceContainsCredentialError = (currentResponse.value?.errorDetails?.stackTrace ?? "").split("\n").some((line) => NODE_API_AUTH_ERROR_MESSAGES.includes(line.trim()));
			return PERMISSION_ERROR_CODES.includes(currentResponse.value?.errorDetails?.httpCode ?? "") || NODE_API_AUTH_ERROR_MESSAGES.includes(currentResponse.value?.errorDetails?.message ?? "") || stackTraceContainsCredentialError;
		});
		const credentialsRequiredAndNotSet = computed(() => {
			if (!props.node) return false;
			if (skipCredentialsCheckInRLC.value) return false;
			const nodeType = nodeTypesStore.getNodeType(props.node.type);
			if (nodeType) {
				if (nodeType.credentials !== void 0 && nodeType.credentials.length > 0 && !props.node.credentials) return true;
			}
			return false;
		});
		const inputPlaceholder = computed(() => {
			if (currentMode.value.placeholder) return currentMode.value.placeholder;
			return {
				list: i18n$1.baseText("resourceLocator.mode.list.placeholder"),
				id: i18n$1.baseText("resourceLocator.id.placeholder"),
				url: i18n$1.baseText("resourceLocator.url.placeholder")
			}[selectedMode.value] ?? "";
		});
		const currentMode = computed(() => findModeByName(selectedMode.value) ?? {});
		const hasMultipleModes = computed(() => {
			return props.parameter.modes && props.parameter.modes.length > 1;
		});
		const hasOnlyListMode$1 = computed(() => hasOnlyListMode(props.parameter));
		const valueToDisplay = computed(() => {
			if (typeof props.modelValue !== "object") return `${props.modelValue}`;
			if (isListMode.value) return props.modelValue?.cachedResultName ?? props.modelValue?.value ?? "";
			return props.modelValue?.value ?? "";
		});
		const urlValue = computed(() => {
			if (isListMode.value && typeof props.modelValue === "object") return props.modelValue?.cachedResultUrl ?? null;
			if (selectedMode.value === "url") {
				if (props.isValueExpression && typeof props.expressionComputedValue === "string" && props.expressionComputedValue.startsWith("http")) return props.expressionComputedValue;
				if (typeof valueToDisplay.value === "string" && valueToDisplay.value.startsWith("http")) return valueToDisplay.value;
			}
			if (currentMode.value.url) {
				const value$1 = props.isValueExpression ? props.expressionComputedValue : valueToDisplay.value;
				if (typeof value$1 === "string") {
					const expression = currentMode.value.url.replace(/\{\{\$value\}\}/g, value$1);
					const resolved = workflowHelpers.resolveExpression(expression);
					return typeof resolved === "string" ? resolved : null;
				}
			}
			return null;
		});
		const currentRequestParams = computed(() => {
			return {
				parameters: props.node?.parameters ?? {},
				credentials: props.node?.credentials ?? {},
				filter: searchFilter.value,
				projectId: projectsStore.currentProjectId
			};
		});
		const currentRequestKey = computed(() => {
			const cacheKeys = { ...currentRequestParams.value };
			cacheKeys.parameters = Object.keys(props.node?.parameters ?? {}).reduce((accu, param) => {
				if (param !== props.parameter.name && props.node?.parameters) accu[param] = props.node.parameters[param];
				return accu;
			}, {});
			return (0, import_fast_json_stable_stringify.default)(cacheKeys);
		});
		const currentResponse = computed(() => cachedResponses.value[currentRequestKey.value] ?? null);
		const currentQueryResults = computed(() => {
			return (currentResponse.value?.results ?? []).map((result) => ({
				...result,
				...result.name && result.url ? { linkAlt: getLinkAlt(result.name) } : {}
			}));
		});
		const currentQueryHasMore = computed(() => !!currentResponse.value?.nextPageToken);
		const currentQueryLoading = computed(() => requiresSearchFilter.value && searchFilter.value === "" || !currentResponse.value || !!currentResponse.value?.loading);
		const currentQueryError = computed(() => {
			return !!(currentResponse.value && currentResponse.value.error);
		});
		const isSearchable = computed(() => !!getPropertyArgument(currentMode.value, "searchable"));
		const skipCredentialsCheckInRLC = computed(() => !!getPropertyArgument(currentMode.value, "skipCredentialsCheckInRLC"));
		const requiresSearchFilter = computed(() => !!getPropertyArgument(currentMode.value, "searchFilterRequired"));
		const fromAIOverride = ref(makeOverrideValue({
			value: props.modelValue?.value ?? "",
			...props
		}, props.node));
		const canBeContentOverride = computed(() => {
			if (!props.node) return false;
			return fromAIOverride.value !== null;
		});
		const isContentOverride = computed(() => canBeContentOverride.value && !!isFromAIOverrideValue(props.modelValue?.value?.toString() ?? ""));
		const showOverrideButton = computed(() => canBeContentOverride.value && !isContentOverride.value && !props.isReadOnly);
		const allowNewResources = computed(() => {
			if (!props.node) return;
			const addNewResourceOptions = getPropertyArgument(currentMode.value, "allowNewResource");
			if (!addNewResourceOptions || typeof addNewResourceOptions !== "object") return;
			return {
				label: i18n$1.baseText(addNewResourceOptions.label, { interpolate: { resourceName: searchFilter.value ? searchFilter.value : addNewResourceOptions.defaultName ?? "" } }),
				method: addNewResourceOptions.method,
				url: addNewResourceOptions.url
			};
		});
		const handleAddResourceClick = async () => {
			if (!props.node || !allowNewResources.value) return;
			const { method: addNewResourceMethodName, url: redirectUrl } = allowNewResources.value;
			if (redirectUrl) {
				let resolvedUrl = redirectUrl;
				if (resolvedUrl.includes("{{$projectId}}")) resolvedUrl = resolvedUrl.replace(/\{\{\$projectId\}\}/g, projectsStore.currentProjectId ?? "");
				hideResourceDropdown();
				openResource(resolvedUrl);
				return;
			}
			const resolvedNodeParameters = workflowHelpers.resolveRequiredParameters(props.parameter, currentRequestParams.value.parameters);
			if (!resolvedNodeParameters || !addNewResourceMethodName) return;
			const requestParams = {
				nodeTypeAndVersion: {
					name: props.node.type,
					version: props.node.typeVersion
				},
				path: props.path,
				currentNodeParameters: resolvedNodeParameters,
				credentials: props.node.credentials,
				handler: addNewResourceMethodName,
				payload: { name: searchFilter.value }
			};
			const newResource = await nodeTypesStore.getNodeParameterActionResult(requestParams);
			if (typeof newResource === "boolean") return;
			refreshList();
			await loadResources();
			searchFilter.value = "";
			onListItemSelected(newResource);
		};
		const onAddResourceClicked = computed(() => allowNewResources.value && (allowNewResources.value.method || allowNewResources.value.url) ? handleAddResourceClick : void 0);
		watch(currentQueryError, (curr, prev) => {
			if (resourceDropdownVisible.value && curr && !prev) {
				if (inputRef.value) inputRef.value.focus();
			}
		});
		watch(() => props.isValueExpression, async (newValue) => {
			if (newValue) switchFromListMode();
			await nextTick();
			inputRef.value?.focus();
		});
		watch(currentMode, (mode) => {
			if (mode.extractValue?.regex && isResourceLocatorValue(props.modelValue) && props.modelValue.__regex !== mode.extractValue.regex) emit("update:modelValue", {
				...props.modelValue,
				__regex: mode.extractValue.regex
			});
		});
		watch(() => props.dependentParametersValues, (currentValue, oldValue) => {
			if (oldValue !== null && currentValue !== null && oldValue !== currentValue && props.modelValue && isResourceLocatorValue(props.modelValue) && props.modelValue.value !== "") emit("update:modelValue", {
				...props.modelValue,
				cachedResultName: "",
				cachedResultUrl: "",
				value: ""
			});
		});
		onMounted(() => {
			props.eventBus.on("refreshList", refreshList);
			window.addEventListener("resize", setWidth);
			useNDVStore().$subscribe(() => {
				setWidth();
			});
			setTimeout(() => {
				setWidth();
			}, 0);
		});
		onBeforeUnmount(() => {
			props.eventBus.off("refreshList", refreshList);
			window.removeEventListener("resize", setWidth);
		});
		onClickOutside(dropdownRef, hideResourceDropdown);
		function setWidth() {
			if (containerRef.value) width.value = containerRef.value.offsetWidth;
		}
		function getLinkAlt(entity) {
			if (selectedMode.value === "list" && entity) return i18n$1.baseText("resourceLocator.openSpecificResource", { interpolate: {
				entity: entity.toString(),
				appName: appName.value
			} });
			return i18n$1.baseText("resourceLocator.openResource", { interpolate: { appName: appName.value } });
		}
		function refreshList() {
			cachedResponses.value = {};
			trackEvent("User refreshed resource locator list");
		}
		function onKeyDown(e) {
			if (resourceDropdownVisible.value && !isSearchable.value) props.eventBus.emit("keyDown", e);
		}
		function openResource(url) {
			window.open(url, "_blank");
			trackEvent("User clicked resource locator link");
		}
		function getPropertyArgument(parameter, argumentName) {
			return parameter.typeOptions?.[argumentName];
		}
		function openCredential() {
			const node$1 = ndvStore.activeNode;
			if (!node$1?.credentials) return;
			const credentialKey = Object.keys(node$1.credentials)[0];
			if (!credentialKey) return;
			const id = node$1.credentials[credentialKey].id;
			if (!id) return;
			uiStore.openExistingCredential(id);
		}
		function createNewCredential() {
			if (!props.node) return;
			const nodeType = nodeTypesStore.getNodeType(props.node.type);
			if (!nodeType) return;
			const defaultCredentialType = nodeType.credentials?.[0].name ?? "";
			const mainAuthType = getMainAuthField(nodeType);
			const showAuthOptions = mainAuthType !== null && Array.isArray(mainAuthType.options) && mainAuthType.options?.length > 0;
			ndvEventBus.emit("credential.createNew", {
				type: defaultCredentialType,
				showAuthOptions
			});
		}
		function findModeByName(name) {
			if (props.parameter.modes) return props.parameter.modes.find((mode) => mode.name === name) ?? null;
			return null;
		}
		function getModeLabel(mode) {
			if (mode.name === "id" || mode.name === "url" || mode.name === "list") return i18n$1.baseText(`resourceLocator.mode.${mode.name}`);
			return mode.displayName;
		}
		function onInputChange(value$1) {
			const params = {
				__rl: true,
				value: value$1,
				mode: selectedMode.value
			};
			if (isListMode.value) {
				const resource = currentQueryResults.value.find((result) => result.value === value$1);
				if (resource?.name) params.cachedResultName = resource.name;
				if (resource?.url) params.cachedResultUrl = resource.url;
			} else params.value = completeExpressionSyntax(value$1);
			emit("update:modelValue", params);
		}
		function onInputMouseDown(event) {
			if (isListMode.value) event.preventDefault();
		}
		function onModeSelected(value$1) {
			if (typeof props.modelValue !== "object") emit("update:modelValue", {
				__rl: true,
				value: props.modelValue,
				mode: value$1
			});
			else if (value$1 === "url" && props.modelValue?.cachedResultUrl) emit("update:modelValue", {
				__rl: true,
				mode: value$1,
				value: props.modelValue.cachedResultUrl
			});
			else if (value$1 === "id" && selectedMode.value === "list" && props.modelValue?.value) emit("update:modelValue", {
				__rl: true,
				mode: value$1,
				value: props.modelValue.value
			});
			else emit("update:modelValue", {
				__rl: true,
				mode: value$1,
				value: props.modelValue?.value ?? ""
			});
			trackEvent("User changed resource locator mode", { mode: value$1 });
		}
		function trackEvent(event, params) {
			telemetry.track(event, {
				instance_id: rootStore.instanceId,
				workflow_id: workflowsStore.workflowId,
				node_type: props.node?.type,
				resource: props.node?.parameters.resource,
				operation: props.node?.parameters.operation,
				field_name: props.parameter.name,
				...params
			});
		}
		function onDrop(data) {
			switchFromListMode();
			emit("drop", data);
		}
		function onSearchFilter(filter$1) {
			searchFilter.value = filter$1;
			loadResourcesDebounced();
		}
		async function loadInitialResources() {
			if (!currentResponse.value || currentResponse.value.error) {
				searchFilter.value = "";
				await loadResources();
			}
		}
		function loadResourcesDebounced() {
			if (currentResponse.value?.error) delete cachedResponses.value[currentRequestKey.value];
			callDebounced(loadResources, {
				debounceTime: 1e3,
				trailing: true
			});
		}
		function setResponse(paramsKey, response) {
			const newResponse = {
				...cachedResponses.value[paramsKey] || {},
				...response
			};
			cachedResponses.value = {
				...cachedResponses.value,
				[paramsKey]: newResponse
			};
		}
		async function loadResources() {
			const params = currentRequestParams.value;
			const paramsKey = currentRequestKey.value;
			const cachedResponse = cachedResponses.value[paramsKey];
			if (credentialsRequiredAndNotSet.value) {
				setResponse(paramsKey, { error: true });
				return;
			}
			if (requiresSearchFilter.value && !params.filter) return;
			if (!props.node) return;
			let paginationToken;
			try {
				if (cachedResponse) {
					const nextPageToken = cachedResponse.nextPageToken;
					if (nextPageToken) {
						paginationToken = nextPageToken;
						setResponse(paramsKey, { loading: true });
					} else if (cachedResponse.error) setResponse(paramsKey, {
						error: false,
						loading: true
					});
					else return;
				} else setResponse(paramsKey, {
					loading: true,
					error: false,
					results: [],
					nextPageToken: null
				});
				const resolvedNodeParameters = workflowHelpers.resolveRequiredParameters(props.parameter, params.parameters);
				const loadOptionsMethod = getPropertyArgument(currentMode.value, "searchListMethod");
				const requestParams = {
					nodeTypeAndVersion: {
						name: props.node.type,
						version: props.node.typeVersion
					},
					path: props.path,
					methodName: loadOptionsMethod,
					currentNodeParameters: resolvedNodeParameters,
					credentials: props.node.credentials,
					projectId: projectsStore.currentProjectId
				};
				if (params.filter) requestParams.filter = params.filter;
				if (paginationToken) requestParams.paginationToken = paginationToken;
				const response = await nodeTypesStore.getResourceLocatorResults(requestParams);
				const responseData = {
					results: (cachedResponse?.results ?? []).concat(response.results),
					nextPageToken: response.paginationToken ?? null,
					loading: false,
					error: false
				};
				setResponse(paramsKey, responseData);
				const currentKey = currentRequestKey.value;
				if (currentKey !== paramsKey) setResponse(currentKey, responseData);
				if (params.filter && !hasCompletedASearch.value) {
					hasCompletedASearch.value = true;
					trackEvent("User searched resource locator list");
				}
			} catch (e) {
				const errorData = {
					loading: false,
					error: true,
					errorDetails: {
						message: removeDuplicateTextFromErrorMessage(e.message),
						description: e.description,
						httpCode: e.httpCode,
						stackTrace: e.stacktrace
					}
				};
				setResponse(paramsKey, errorData);
				const currentKey = currentRequestKey.value;
				if (currentKey !== paramsKey) setResponse(currentKey, errorData);
			}
		}
		function removeDuplicateTextFromErrorMessage(message) {
			let segments = [];
			if (/[-–—]/.test(message)) segments = message.split(/\s*[-–—]\s*/);
			else segments = message.split(/(?<=[.!?])\s+/);
			return segments.filter((segment) => {
				if (!segment.trim()) return false;
				return !CHECK_CREDENTIALS_REGEX.test(segment);
			}).join(" ").trim();
		}
		function onInputFocus() {
			if (!isListMode.value || resourceDropdownVisible.value) return;
			loadInitialResources();
			showResourceDropdown();
		}
		function switchFromListMode() {
			if (isListMode.value && props.parameter.modes && props.parameter.modes.length > 1) {
				const mode = findModeByName("id") ?? props.parameter.modes.filter(({ name }) => name !== "list")[0];
				if (mode) emit("update:modelValue", {
					__rl: true,
					value: props.modelValue && typeof props.modelValue === "object" ? props.modelValue.value : "",
					mode: mode.name
				});
			}
		}
		function hideResourceDropdown() {
			if (!resourceDropdownVisible.value) return;
			resourceDropdownVisible.value = false;
			resourceDropdownHiding.value = true;
			nextTick(() => {
				inputRef.value?.blur();
				resourceDropdownHiding.value = false;
			});
		}
		function showResourceDropdown() {
			if (resourceDropdownVisible.value || resourceDropdownHiding.value) return;
			resourceDropdownVisible.value = true;
		}
		function onListItemSelected(value$1) {
			onInputChange(value$1);
			hideResourceDropdown();
		}
		function onInputBlur(event) {
			const newTarget = event.relatedTarget;
			if (newTarget instanceof HTMLElement && dropdownRef.value?.isWithinDropdown(newTarget)) return;
			if (!isSearchable.value || currentQueryError.value) hideResourceDropdown();
			emit("blur");
		}
		function applyOverride() {
			if (!props.node || !fromAIOverride.value) return;
			telemetry.track("User turned on fromAI override", {
				nodeType: props.node.type,
				parameter: props.path
			});
			updateFromAIOverrideValues(fromAIOverride.value, props.modelValue.value?.toString() ?? "");
			emit("update:modelValue", {
				...props.modelValue,
				value: buildValueFromOverride(fromAIOverride.value, props, true)
			});
		}
		function removeOverride() {
			if (!props.node || !fromAIOverride.value) return;
			telemetry.track("User turned off fromAI override", {
				nodeType: props.node.type,
				parameter: props.path
			});
			emit("update:modelValue", {
				...props.modelValue,
				value: buildValueFromOverride(fromAIOverride.value, props, false)
			});
			setTimeout(() => {
				inputRef.value?.focus();
				inputRef.value?.select();
			}, 0);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "containerRef",
				ref: containerRef,
				class: "resource-locator",
				"data-test-id": `resource-locator-${_ctx.parameter.name}`
			}, [createVNode(ResourceLocatorDropdown_default, {
				ref_key: "dropdownRef",
				ref: dropdownRef,
				"model-value": _ctx.modelValue,
				show: resourceDropdownVisible.value,
				filterable: isSearchable.value,
				"filter-required": requiresSearchFilter.value,
				resources: currentQueryResults.value,
				loading: currentQueryLoading.value,
				filter: searchFilter.value,
				"has-more": currentQueryHasMore.value,
				"error-view": currentQueryError.value,
				width: width.value,
				"event-bus": _ctx.eventBus,
				"allow-new-resources": allowNewResources.value,
				"onUpdate:modelValue": onListItemSelected,
				onFilter: onSearchFilter,
				onLoadMore: loadResourcesDebounced,
				onAddResourceClick: onAddResourceClicked.value
			}, {
				error: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(unref($style).errorContainer),
					"data-test-id": "rlc-error-container"
				}, [
					credentialsRequiredAndNotSet.value || currentResponse.value.errorDetails ? (openBlock(), createBlock(unref(N8nText_default), {
						key: 0,
						color: "text-dark",
						align: "center",
						tag: "div"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.error.title")), 1)]),
						_: 1
					})) : createCommentVNode("", true),
					currentResponse.value.errorDetails ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(unref($style).errorDetails)
					}, [createVNode(unref(N8nText_default), { size: "small" }, {
						default: withCtx(() => [currentResponse.value.errorDetails.httpCode ? (openBlock(), createElementBlock("span", _hoisted_2$8, toDisplayString(currentResponse.value.errorDetails.httpCode) + " - ", 1)) : createCommentVNode("", true), createBaseVNode("span", _hoisted_3$7, toDisplayString(currentResponse.value.errorDetails.message), 1)]),
						_: 1
					}), currentResponse.value.errorDetails.description ? (openBlock(), createBlock(unref(N8nNotice_default), {
						key: 0,
						theme: "warning",
						class: normalizeClass(unref($style).errorDescription)
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(currentResponse.value.errorDetails.description), 1)]),
						_: 1
					}, 8, ["class"])) : createCommentVNode("", true)], 2)) : createCommentVNode("", true),
					hasCredentialError.value || credentialsRequiredAndNotSet.value ? (openBlock(), createElementBlock("div", _hoisted_4$6, [credentialsRequiredAndNotSet.value ? (openBlock(), createElementBlock("a", {
						key: 0,
						class: normalizeClass(unref($style)["credential-link"]),
						onClick: createNewCredential
					}, toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.error.description.noCredentials")), 3)) : (openBlock(), createElementBlock("a", {
						key: 1,
						class: normalizeClass(unref($style)["credential-link"]),
						onClick: openCredential
					}, toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.error.description.checkCredentials")), 3))])) : createCommentVNode("", true)
				], 2)]),
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass({
					[unref($style).resourceLocator]: true,
					[unref($style).multipleModes]: hasMultipleModes.value,
					[unref($style).inputContainerInputCorners]: hasMultipleModes.value && canBeContentOverride.value && !isContentOverride.value
				}) }, [
					createBaseVNode("div", { class: normalizeClass([unref($style).background, { [unref($style).backgroundOverride]: showOverrideButton.value }]) }, null, 2),
					hasMultipleModes.value ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(unref($style).modeSelector)
					}, [createVNode(unref(N8nSelect_default), {
						"model-value": selectedMode.value,
						size: _ctx.inputSize,
						disabled: _ctx.isReadOnly,
						placeholder: unref(i18n$1).baseText("resourceLocator.modeSelector.placeholder"),
						"data-test-id": "rlc-mode-selector",
						"onUpdate:modelValue": onModeSelected
					}, {
						default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.parameter.modes, (mode) => {
							return openBlock(), createBlock(unref(N8nOption_default), {
								key: mode.name,
								"data-test-id": `mode-${mode.name}`,
								value: mode.name,
								label: getModeLabel(mode),
								disabled: _ctx.isValueExpression && mode.name === "list",
								title: _ctx.isValueExpression && mode.name === "list" ? unref(i18n$1).baseText("resourceLocator.mode.list.disabled.title") : ""
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(getModeLabel(mode)), 1)]),
								_: 2
							}, 1032, [
								"data-test-id",
								"value",
								"label",
								"disabled",
								"title"
							]);
						}), 128))]),
						_: 1
					}, 8, [
						"model-value",
						"size",
						"disabled",
						"placeholder"
					])], 2)) : createCommentVNode("", true),
					createBaseVNode("div", {
						class: normalizeClass(unref($style).inputContainer),
						"data-test-id": "rlc-input-container"
					}, [createVNode(DraggableTarget_default, {
						type: "mapping",
						disabled: hasOnlyListMode$1.value,
						sticky: true,
						"sticky-offset": _ctx.isValueExpression ? [26, 3] : [3, 3],
						onDrop
					}, {
						default: withCtx(({ droppable: droppable$10, activeDrop: activeDrop$8 }) => [createBaseVNode("div", {
							class: normalizeClass([{
								[unref($style).listModeInputContainer]: isListMode.value,
								[unref($style).droppable]: droppable$10,
								[unref($style).activeDrop]: activeDrop$8,
								[unref($style).rightNoCorner]: canBeContentOverride.value && !isContentOverride.value
							}]),
							onKeydown: withModifiers(onKeyDown, ["stop"])
						}, [fromAIOverride.value && isContentOverride.value ? (openBlock(), createBlock(FromAiOverrideField_default, {
							key: 0,
							class: normalizeClass([unref($style).inputField, unref($style).fromAiOverrideField]),
							"is-read-only": _ctx.isReadOnly,
							onClose: removeOverride
						}, null, 8, ["class", "is-read-only"])) : _ctx.isValueExpression || _ctx.forceShowExpression ? (openBlock(), createBlock(ExpressionParameterInput_default, {
							key: 1,
							ref_key: "inputRef",
							ref: inputRef,
							class: normalizeClass(unref($style).inputField),
							"model-value": _ctx.expressionDisplayValue,
							path: _ctx.path,
							rows: 3,
							"onUpdate:modelValue": onInputChange,
							onModalOpenerClick: _cache[0] || (_cache[0] = ($event) => emit("modalOpenerClick"))
						}, null, 8, [
							"class",
							"model-value",
							"path"
						])) : (openBlock(), createBlock(unref(N8nInput_default), {
							key: 2,
							ref_key: "inputRef",
							ref: inputRef,
							class: normalizeClass([unref($style).inputField, {
								[unref($style).selectInput]: isListMode.value,
								[unref($style).rightNoCorner]: canBeContentOverride.value && !isContentOverride.value
							}]),
							size: _ctx.inputSize,
							"model-value": valueToDisplay.value,
							disabled: _ctx.isReadOnly,
							readonly: isListMode.value,
							title: _ctx.displayTitle,
							placeholder: inputPlaceholder.value,
							type: "text",
							"data-test-id": "rlc-input",
							"onUpdate:modelValue": onInputChange,
							onFocus: onInputFocus,
							onBlur: onInputBlur,
							onMousedown: onInputMouseDown
						}, createSlots({ _: 2 }, [isListMode.value ? {
							name: "suffix",
							fn: withCtx(() => [createBaseVNode("i", { class: normalizeClass({
								["el-input__icon"]: true,
								["el-icon-arrow-down"]: true,
								[unref($style).selectIcon]: true,
								[unref($style).isReverse]: resourceDropdownVisible.value
							}) }, null, 2)]),
							key: "0"
						} : void 0]), 1032, [
							"class",
							"size",
							"model-value",
							"disabled",
							"readonly",
							"title",
							"placeholder"
						])), showOverrideButton.value ? (openBlock(), createElementBlock("div", {
							key: 3,
							class: normalizeClass(unref($style).overrideButtonInline)
						}, [createVNode(FromAiOverrideButton_default, { onClick: applyOverride })], 2)) : createCommentVNode("", true)], 34)]),
						_: 1
					}, 8, ["disabled", "sticky-offset"]), _ctx.parameterIssues && _ctx.parameterIssues.length ? (openBlock(), createBlock(ParameterIssues_default, {
						key: 0,
						issues: _ctx.parameterIssues,
						class: normalizeClass(unref($style)["parameter-issues"])
					}, null, 8, ["issues", "class"])) : urlValue.value ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(unref($style).openResourceLink)
					}, [createVNode(unref(N8nLink_default), {
						theme: "text",
						onClick: _cache[1] || (_cache[1] = withModifiers(($event) => openResource(urlValue.value), ["stop"]))
					}, {
						default: withCtx(() => [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							title: getLinkAlt(valueToDisplay.value)
						}, null, 8, ["title"])]),
						_: 1
					})], 2)) : createCommentVNode("", true)], 2)
				], 2)]),
				_: 1
			}, 8, [
				"model-value",
				"show",
				"filterable",
				"filter-required",
				"resources",
				"loading",
				"filter",
				"has-more",
				"error-view",
				"width",
				"event-bus",
				"allow-new-resources",
				"onAddResourceClick"
			]), isContentOverride.value && fromAIOverride.value ? (openBlock(), createBlock(ParameterOverrideSelectableList_default, {
				key: 0,
				modelValue: fromAIOverride.value,
				"onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => fromAIOverride.value = $event),
				parameter: _ctx.parameter,
				path: _ctx.path,
				"is-read-only": _ctx.isReadOnly,
				onUpdate: _cache[3] || (_cache[3] = (x) => onInputChange(x.value?.toString()))
			}, null, 8, [
				"modelValue",
				"parameter",
				"path",
				"is-read-only"
			])) : createCommentVNode("", true)], 8, _hoisted_1$19);
		};
	}
});
const modeSelector$1 = "_modeSelector_8mz3z_123";
const inputField$1 = "_inputField_8mz3z_141";
const fromAiOverrideField$1 = "_fromAiOverrideField_8mz3z_146";
const overrideButtonInline$2 = "_overrideButtonInline_8mz3z_152";
const rightNoCorner$1 = "_rightNoCorner_8mz3z_160";
const resourceLocator$1 = "_resourceLocator_8mz3z_165";
const inputContainer$2 = "_inputContainer_8mz3z_173";
const background$2 = "_background_8mz3z_186";
const backgroundOverride$1 = "_backgroundOverride_8mz3z_196";
const backgroundWithIssuesAndShowResourceLink$1 = "_backgroundWithIssuesAndShowResourceLink_8mz3z_199";
const multipleModes$1 = "_multipleModes_8mz3z_202";
const inputContainerInputCorners$1 = "_inputContainerInputCorners_8mz3z_208";
const droppable$6 = "_droppable_8mz3z_212";
const activeDrop$4 = "_activeDrop_8mz3z_217";
const selectInput$1 = "_selectInput_8mz3z_227";
const selectIcon$1 = "_selectIcon_8mz3z_233";
const isReverse$1 = "_isReverse_8mz3z_239";
const listModeInputContainer$1 = "_listModeInputContainer_8mz3z_243";
const errorContainer$1 = "_errorContainer_8mz3z_247";
const errorDetails$1 = "_errorDetails_8mz3z_248";
const errorDescription$1 = "_errorDescription_8mz3z_260";
const openResourceLink$1 = "_openResourceLink_8mz3z_270";
var ResourceLocator_vue_vue_type_style_index_0_lang_module_default = {
	modeSelector: modeSelector$1,
	inputField: inputField$1,
	fromAiOverrideField: fromAiOverrideField$1,
	overrideButtonInline: overrideButtonInline$2,
	rightNoCorner: rightNoCorner$1,
	resourceLocator: resourceLocator$1,
	inputContainer: inputContainer$2,
	background: background$2,
	backgroundOverride: backgroundOverride$1,
	backgroundWithIssuesAndShowResourceLink: backgroundWithIssuesAndShowResourceLink$1,
	multipleModes: multipleModes$1,
	inputContainerInputCorners: inputContainerInputCorners$1,
	droppable: droppable$6,
	activeDrop: activeDrop$4,
	selectInput: selectInput$1,
	selectIcon: selectIcon$1,
	isReverse: isReverse$1,
	listModeInputContainer: listModeInputContainer$1,
	errorContainer: errorContainer$1,
	errorDetails: errorDetails$1,
	errorDescription: errorDescription$1,
	"credential-link": "_credential-link_8mz3z_266",
	openResourceLink: openResourceLink$1,
	"parameter-issues": "_parameter-issues_8mz3z_277"
};
var ResourceLocator_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ResourceLocator_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ResourceLocator_vue_vue_type_style_index_0_lang_module_default }]]);
new Set("where group having order union intersect except all distinct limit offset fetch for".split(" "));
function completeKeywords(keywords$1, upperCase) {
	return ifNotIn([
		"QuotedIdentifier",
		"SpecialVar",
		"String",
		"LineComment",
		"BlockComment",
		"."
	], completeFromList(Object.keys(keywords$1).map((keyword) => ({
		label: upperCase ? keyword.toUpperCase() : keyword,
		type: keywords$1[keyword] === 22 ? "type" : keywords$1[keyword] === 21 ? "keyword" : "variable",
		boost: -1
	}))));
}
var Ch = /* @__PURE__ */ function(Ch$1) {
	Ch$1[Ch$1["Newline"] = 10] = "Newline";
	Ch$1[Ch$1["Space"] = 32] = "Space";
	Ch$1[Ch$1["DoubleQuote"] = 34] = "DoubleQuote";
	Ch$1[Ch$1["Hash"] = 35] = "Hash";
	Ch$1[Ch$1["Dollar"] = 36] = "Dollar";
	Ch$1[Ch$1["SingleQuote"] = 39] = "SingleQuote";
	Ch$1[Ch$1["ParenL"] = 40] = "ParenL";
	Ch$1[Ch$1["ParenR"] = 41] = "ParenR";
	Ch$1[Ch$1["Star"] = 42] = "Star";
	Ch$1[Ch$1["Plus"] = 43] = "Plus";
	Ch$1[Ch$1["Comma"] = 44] = "Comma";
	Ch$1[Ch$1["Dash"] = 45] = "Dash";
	Ch$1[Ch$1["Dot"] = 46] = "Dot";
	Ch$1[Ch$1["Slash"] = 47] = "Slash";
	Ch$1[Ch$1["Colon"] = 58] = "Colon";
	Ch$1[Ch$1["Semi"] = 59] = "Semi";
	Ch$1[Ch$1["Question"] = 63] = "Question";
	Ch$1[Ch$1["At"] = 64] = "At";
	Ch$1[Ch$1["BracketL"] = 91] = "BracketL";
	Ch$1[Ch$1["BracketR"] = 93] = "BracketR";
	Ch$1[Ch$1["Backslash"] = 92] = "Backslash";
	Ch$1[Ch$1["Underscore"] = 95] = "Underscore";
	Ch$1[Ch$1["Backtick"] = 96] = "Backtick";
	Ch$1[Ch$1["BraceL"] = 123] = "BraceL";
	Ch$1[Ch$1["BraceR"] = 125] = "BraceR";
	Ch$1[Ch$1["A"] = 65] = "A";
	Ch$1[Ch$1["a"] = 97] = "a";
	Ch$1[Ch$1["B"] = 66] = "B";
	Ch$1[Ch$1["b"] = 98] = "b";
	Ch$1[Ch$1["E"] = 69] = "E";
	Ch$1[Ch$1["e"] = 101] = "e";
	Ch$1[Ch$1["F"] = 70] = "F";
	Ch$1[Ch$1["f"] = 102] = "f";
	Ch$1[Ch$1["N"] = 78] = "N";
	Ch$1[Ch$1["n"] = 110] = "n";
	Ch$1[Ch$1["X"] = 88] = "X";
	Ch$1[Ch$1["x"] = 120] = "x";
	Ch$1[Ch$1["Z"] = 90] = "Z";
	Ch$1[Ch$1["z"] = 122] = "z";
	Ch$1[Ch$1["_0"] = 48] = "_0";
	Ch$1[Ch$1["_1"] = 49] = "_1";
	Ch$1[Ch$1["_9"] = 57] = "_9";
	return Ch$1;
}(Ch || {});
function isAlpha(ch) {
	return ch >= Ch.A && ch <= Ch.Z || ch >= Ch.a && ch <= Ch.z || ch >= Ch._0 && ch <= Ch._9;
}
function isHexDigit(ch) {
	return ch >= Ch._0 && ch <= Ch._9 || ch >= Ch.a && ch <= Ch.f || ch >= Ch.A && ch <= Ch.F;
}
function readLiteral(input$5, endQuote, backslashEscapes) {
	for (let escaped = false;;) {
		if (input$5.next < 0) return;
		if (input$5.next === endQuote && !escaped) {
			input$5.advance();
			return;
		}
		escaped = backslashEscapes && !escaped && input$5.next === Ch.Backslash;
		input$5.advance();
	}
}
function readDoubleDollarLiteral(input$5) {
	for (;;) {
		if (input$5.next < 0 || input$5.peek(1) < 0) return;
		if (input$5.next === Ch.Dollar && input$5.peek(1) === Ch.Dollar) {
			input$5.advance(2);
			return;
		}
		input$5.advance();
	}
}
function readWord(input$5, result) {
	for (;;) {
		if (input$5.next !== Ch.Underscore && !isAlpha(input$5.next)) break;
		if (result !== null) result += String.fromCharCode(input$5.next);
		input$5.advance();
	}
	return result;
}
function readWordOrQuoted(input$5) {
	if (input$5.next === Ch.SingleQuote || input$5.next === Ch.DoubleQuote || input$5.next === Ch.Backtick) {
		const quote = input$5.next;
		input$5.advance();
		readLiteral(input$5, quote, false);
	} else readWord(input$5);
}
function readBits(input$5, endQuote) {
	while (input$5.next === Ch._0 || input$5.next === Ch._1) input$5.advance();
	if (endQuote && input$5.next === endQuote) input$5.advance();
}
function readNumber(input$5, sawDot) {
	for (;;) {
		if (input$5.next === Ch.Dot) {
			if (sawDot) break;
			sawDot = true;
		} else if (input$5.next < Ch._0 || input$5.next > Ch._9) break;
		input$5.advance();
	}
	if (input$5.next === Ch.E || input$5.next === Ch.e) {
		input$5.advance();
		const advancedInput = input$5;
		if (advancedInput.next === Ch.Plus || advancedInput.next === Ch.Dash) input$5.advance();
		while (input$5.next >= Ch._0 && input$5.next <= Ch._9) input$5.advance();
	}
}
function eol(input$5) {
	while (!(input$5.next < 0 || input$5.next === Ch.Newline)) input$5.advance();
}
function inString(ch, str) {
	for (let i = 0; i < str.length; i++) if (str.charCodeAt(i) === ch) return true;
	return false;
}
var Space = " 	\r\n";
function keywords(keywords$1, types, builtin, functions) {
	const result = Object.create(null);
	result["true"] = result["false"] = 6;
	result["null"] = result["unknown"] = 7;
	for (const kw of keywords$1.split(" ")) if (kw) result[kw] = 21;
	for (const tp of types.split(" ")) if (tp) result[tp] = 22;
	for (const kw of (builtin || "").split(" ")) if (kw) result[kw] = 25;
	for (const fn$2 of (functions || "").split(" ")) if (fn$2) result[fn$2] = 26;
	return result;
}
const SQLTypes = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
const SQLFunctions = "abs absolute case check cast concat coalesce cube collate count current_date current_path current_role current_time current_timestamp current_user day exists grouping hour localtime localtimestamp minute month second trim session_user size system_user treat unnest user year equals lower upper pow floor ceil exp log ifnull min max avg sum sqrt round ";
const SQLKeywords = "action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded catalog close collation column commit condition connect connection constraint constraints constructor continue corresponding create cross current current_default_transform_group current_transform_group_for_type cursor cycle data deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exit external fetch first for foreign found from free full function general get global go goto grant group handle having hold identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local locator loop map match method modifies module names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search section select session set sets signal similar some space specific specifictype sql sqlexception sqlstate sqlwarning start state static table temporary then timezone_hour timezone_minute to trailing transaction translation trigger under undo union unique until update usage using value values view when whenever where while with without work write zone ";
var defaults$1 = {
	backslashEscapes: false,
	hashComments: false,
	spaceAfterDashes: false,
	slashComments: false,
	doubleQuotedStrings: false,
	doubleDollarQuotedStrings: false,
	unquotedBitLiterals: false,
	treatBitsAsBytes: false,
	charSetCasts: false,
	operatorChars: "*+-%<>!==&|~^/",
	specialVar: "?",
	identifierQuotes: "\"",
	words: keywords(SQLKeywords, SQLTypes, "", SQLFunctions)
};
function dialect(spec, kws, types, builtin, functions) {
	const dialect$1 = {};
	for (const prop in defaults$1) dialect$1[prop] = (Object.prototype.hasOwnProperty.call(spec, prop) ? spec : defaults$1)[prop];
	if (kws) dialect$1.words = keywords(kws, types || "", builtin, functions);
	return dialect$1;
}
function tokensFor(d) {
	return new ExternalTokenizer((input$5) => {
		const { next } = input$5;
		input$5.advance();
		if (inString(next, Space)) {
			while (inString(input$5.next, Space)) input$5.advance();
			input$5.acceptToken(1);
		} else if (next === Ch.Dollar && input$5.next === Ch.Dollar && d.doubleDollarQuotedStrings) {
			readDoubleDollarLiteral(input$5);
			input$5.acceptToken(4);
		} else if (next === Ch.SingleQuote || next === Ch.DoubleQuote && d.doubleQuotedStrings) {
			readLiteral(input$5, next, d.backslashEscapes);
			input$5.acceptToken(4);
		} else if (next === Ch.Hash && d.hashComments || next === Ch.Slash && input$5.next === Ch.Slash && d.slashComments) {
			eol(input$5);
			input$5.acceptToken(2);
		} else if (next === Ch.Dash && input$5.next === Ch.Dash && (!d.spaceAfterDashes || input$5.peek(1) === Ch.Space)) {
			eol(input$5);
			input$5.acceptToken(2);
		} else if (next === Ch.Slash && input$5.next === Ch.Star) {
			input$5.advance();
			for (let depth = 1;;) {
				const cur = input$5.next;
				if (input$5.next < 0) break;
				input$5.advance();
				if (cur === Ch.Star && input$5.next === Ch.Slash) {
					depth--;
					input$5.advance();
					if (!depth) break;
				} else if (cur === Ch.Slash && input$5.next === Ch.Star) {
					depth++;
					input$5.advance();
				}
			}
			input$5.acceptToken(3);
		} else if ((next === Ch.e || next === Ch.E) && input$5.next === Ch.SingleQuote) {
			input$5.advance();
			readLiteral(input$5, Ch.SingleQuote, true);
		} else if ((next === Ch.n || next === Ch.N) && input$5.next === Ch.SingleQuote && d.charSetCasts) {
			input$5.advance();
			readLiteral(input$5, Ch.SingleQuote, d.backslashEscapes);
			input$5.acceptToken(4);
		} else if (next === Ch.Underscore && d.charSetCasts) for (let i = 0;; i++) {
			if (input$5.next === Ch.SingleQuote && i > 1) {
				input$5.advance();
				readLiteral(input$5, Ch.SingleQuote, d.backslashEscapes);
				input$5.acceptToken(4);
				break;
			}
			if (!isAlpha(input$5.next)) break;
			input$5.advance();
		}
		else if (next === Ch.ParenL) input$5.acceptToken(8);
		else if (next === Ch.ParenR) input$5.acceptToken(9);
		else if (next === Ch.BraceL) input$5.acceptToken(10);
		else if (next === Ch.BraceR) input$5.acceptToken(11);
		else if (next === Ch.BracketL) input$5.acceptToken(12);
		else if (next === Ch.BracketR) input$5.acceptToken(13);
		else if (next === Ch.Semi) input$5.acceptToken(14);
		else if (d.unquotedBitLiterals && next === Ch._0 && input$5.next === Ch.b) {
			input$5.advance();
			readBits(input$5);
			input$5.acceptToken(23);
		} else if ((next === Ch.b || next === Ch.B) && (input$5.next === Ch.SingleQuote || input$5.next === Ch.DoubleQuote)) {
			const quoteStyle = input$5.next;
			input$5.advance();
			if (d.treatBitsAsBytes) {
				readLiteral(input$5, quoteStyle, d.backslashEscapes);
				input$5.acceptToken(24);
			} else {
				readBits(input$5, quoteStyle);
				input$5.acceptToken(23);
			}
		} else if (next === Ch._0 && (input$5.next === Ch.x || input$5.next === Ch.X) || (next === Ch.x || next === Ch.X) && input$5.next === Ch.SingleQuote) {
			const quoted = input$5.next === Ch.SingleQuote;
			input$5.advance();
			while (isHexDigit(input$5.next)) input$5.advance();
			if (quoted && input$5.next === Ch.SingleQuote) input$5.advance();
			input$5.acceptToken(5);
		} else if (next === Ch.Dot && input$5.next >= Ch._0 && input$5.next <= Ch._9) {
			readNumber(input$5, true);
			input$5.acceptToken(5);
		} else if (next === Ch.Dot) input$5.acceptToken(15);
		else if (next >= Ch._0 && next <= Ch._9) {
			readNumber(input$5, false);
			input$5.acceptToken(5);
		} else if (inString(next, d.operatorChars)) {
			while (inString(input$5.next, d.operatorChars)) input$5.advance();
			input$5.acceptToken(16);
		} else if (inString(next, d.specialVar)) {
			if (input$5.next === next) input$5.advance();
			readWordOrQuoted(input$5);
			input$5.acceptToken(18);
		} else if (inString(next, d.identifierQuotes)) {
			readLiteral(input$5, next, false);
			input$5.acceptToken(20);
		} else if (next === Ch.Colon || next === Ch.Comma) input$5.acceptToken(17);
		else if (isAlpha(next)) {
			const word = readWord(input$5, String.fromCharCode(next));
			input$5.acceptToken(input$5.next === Ch.Dot ? 19 : d.words[word.toLowerCase()] ?? 19);
		}
	});
}
const tokens = tokensFor(defaults$1);
const parser = LRParser.deserialize({
	version: 14,
	states: "&SQ]QQOOO#wQRO'#DTO$OQQO'#CyO%eQQO'#CzO%lQQO'#C{O%sQQO'#C|OOQQ'#DT'#DTO%zQQO'#DTOOQQ'#DP'#DPO'ZQRO'#C}OOQQ'#Cx'#CxOOQQ'#DO'#DOQ]QQOOQOQQOOO'eQQO'#DQO(}QRO,59eO)UQQO,59eO)ZQQO'#DTOOQQ,59f,59fO)hQQO,59fOOQQ,59g,59gO)oQQO,59gOOQQ,59h,59hO)vQQO,59hOOQQ,59o,59oOOQQ-E6}-E6}OOQQ,59d,59dOOQQ-E6|-E6|OOQQ,59l,59lOOQQ-E7O-E7OO+[QRO1G/PO+cQQO,59eOOQQ1G/Q1G/QOOQQ1G/R1G/ROOQQ1G/S1G/SP+pQQO'#DPO+wQQO1G/PO)UQQO,59eO,UQQO'#Cy",
	stateData: ",a~OPOSQOSROS~OSUOTUOUUOVUOWROYSO[TO^YO_QO`UOaUObPOcPOdPOeUOfUOgUOhUOiUO~O_^OSwXTwXUwXVwXWwXYwX[wX^wX`wXawXbwXcwXdwXewXfwXgwXhwXiwX~OuwX~P!jOb`Oc`Od`O~OSUOTUOUUOVUOWROYSO[TO_vO`UOaUObaOcaOdaOeUOfUOgUOhUOiUO~OXbO~P$ZOZdO~P$ZO]fO~P$ZOjhO~OSUOTUOUUOVUOWROYSO[TO_QO`UOaUObPOcPOdPOeUOfUOgUOhUOiUO~O^jOuqX~P&POblOclOdlO~O_^OSmaTmaUmaVmaWmaYma[ma^ma`maamabmacmadmaemafmagmahmaima~Ouma~P'pO_^O~OXwXZwX]wX~P!jOXpO~P$ZOZqO~P$ZO]rO~P$ZO_^OSmiTmiUmiVmiWmiYmi[mi^mi`miamibmicmidmiemifmigmihmiimi~Oumi~P)}OXmaZma]ma~P'pO^jO~P$ZOXmiZmi]mi~P)}ObuOcuOduO~O",
	goto: "#uxPPPPPPPPPPPPPPPPPPPPPPPPPPPPy}}}!Z!g!k!q#VPP#iTZO[eUORSTX[cegseVORSTX[cegsT]O[Q[ORk[SXO[QcRQeSQgTZiXcegsQ_PWm_notQn`QoaRtueWORSTX[cegs",
	nodeNames: "⚠ Whitespace LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Function Script Statement CompositeIdentifier Parens Braces Brackets Statement",
	maxTerm: 39,
	skippedNodes: [
		0,
		1,
		2,
		3
	],
	repeatNodeCount: 3,
	tokenData: "RORO",
	tokenizers: [0, tokens],
	topRules: { Script: [0, 27] },
	tokenPrec: 0
});
var getSqlParser = () => {
	return parser.configure({ props: [
		indentNodeProp.add({ Statement: continuedIndent() }),
		foldNodeProp.add({
			Statement(tree) {
				return {
					from: tree.firstChild.to,
					to: tree.to
				};
			},
			BlockComment(tree) {
				return {
					from: tree.from + 2,
					to: tree.to - 2
				};
			}
		}),
		styleTags({
			Keyword: tags.keyword,
			Type: tags.typeName,
			Builtin: tags.standard(tags.name),
			Bits: tags.number,
			Bytes: tags.string,
			Bool: tags.bool,
			Null: tags.null,
			Number: tags.number,
			String: tags.string,
			Identifier: tags.name,
			QuotedIdentifier: tags.special(tags.string),
			SpecialVar: tags.special(tags.name),
			LineComment: tags.lineComment,
			BlockComment: tags.blockComment,
			Operator: tags.operator,
			Function: tags.function(tags.variableName),
			"Semi Punctuation": tags.punctuation,
			"( )": tags.paren,
			"{ }": tags.brace,
			"[ ]": tags.squareBracket
		})
	] });
};
const getParser = (dialect$1) => {
	const sqlLangData = {
		commentTokens: {
			line: "--",
			block: {
				open: "/*",
				close: "*/"
			}
		},
		closeBrackets: { brackets: [
			"(",
			"[",
			"{",
			"'",
			"\"",
			"`"
		] }
	};
	const sqlParser = getSqlParser().configure({ tokenizers: [{
		from: tokens,
		to: tokensFor(dialect$1)
	}] });
	const sqlLanguage = LRLanguage.define({
		name: "sql",
		parser: sqlParser,
		languageData: sqlLangData
	});
	const mixedParser = expressionParser.configure({ wrap: parseMixed((node$1) => {
		return node$1.type.isTop ? {
			parser: sqlLanguage.parser,
			overlay: (node$2) => node$2.type.name === "Plaintext"
		} : null;
	}) });
	return {
		mixedLanguage: LRLanguage.define({
			parser: mixedParser,
			name: "expressionParser"
		}),
		sqlLanguage
	};
};
var SQLDialect = class SQLDialect {
	constructor(dialect$1, language, spec, sqlLanguage) {
		this.dialect = dialect$1;
		this.language = language;
		this.spec = spec;
		this.sqlLanguage = sqlLanguage;
	}
	get extension() {
		return this.language.extension;
	}
	static define(spec) {
		const d = dialect(spec, spec.keywords, spec.types, spec.builtin, spec.functions);
		const { mixedLanguage, sqlLanguage } = getParser(d);
		return new SQLDialect(d, mixedLanguage, spec, sqlLanguage);
	}
};
function keywordCompletionSource(dialect$1, upperCase = false) {
	return completeKeywords(dialect$1.dialect.words, upperCase);
}
const StandardSQL = SQLDialect.define({});
const PostgreSQL = SQLDialect.define({
	charSetCasts: true,
	doubleDollarQuotedStrings: true,
	operatorChars: "+-*/<>=~!@#%^&|`?",
	specialVar: "",
	functions: SQLFunctions + "abs aggregate array_agg array_max_cardinality avg decode encode bernoulli cardinality ceil ceiling char_length character_length coalesce corr degrees substring system xmlcomment xmlvalidate xmlexists length strip lower upper bit_length normalize mod octet_length overlay ln sqrt power exp log lower",
	keywords: SQLKeywords + "abort absent access according ada admin alias also always analyse analyze asensitive assert assignment asymmetric atomic attach attribute attributes backward base64 begin_frame begin_partition bit_length blocked bom c cache called catalog_name chain character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion g generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull k key_member key_type label lag last_value lead leakproof least length library like_regex link listen load location lock locked logged m mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octets off offset oids operator options ordering others over overriding owned owner p parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring_regex succeeds sum symmetric sysid system system_time t table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
	types: SQLTypes + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
});
var MySQLTypes = SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int1 int2 int3 int4 int8 float4 float8 varbinary varcharacter precision datetime unsigned signed";
var MySQLBuiltin = "charset clear edit ego help nopager notee nowarning pager print prompt quit rehash source status system tee";
const MySQL = SQLDialect.define({
	operatorChars: "*+-%<>!=&|^",
	charSetCasts: true,
	doubleQuotedStrings: true,
	unquotedBitLiterals: true,
	hashComments: true,
	spaceAfterDashes: true,
	specialVar: "@?",
	identifierQuotes: "`",
	functions: SQLFunctions,
	keywords: SQLKeywords + "group_concat accessible algorithm analyze asensitive authors auto_increment autocommit avg avg_row_length binlog btree cache catalog_name chain change changed checkpoint checksum class_origin client_statistics coalesce code collations columns comment committed completion concurrent consistent contains contributors convert database databases day_hour day_microsecond day_minute day_second delay_key_write delayed delimiter des_key_file dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile enable enclosed ends engine engines enum errors escaped even event events every explain extended fast field fields flush force found_rows fulltext grants handler hash high_priority hosts hour_microsecond hour_minute hour_second ignore ignore_server_ids import index index_statistics infile innodb insensitive insert_method install invoker iterate keys kill linear lines list load lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modify mutex mysql_errno no_write_to_binlog offline offset one online optimize optionally outfile pack_keys parser partition partitions password phase plugin plugins prev processlist profile profiles purge query quick range read_write rebuild recover regexp relaylog remove rename reorganize repair repeatable replace require resume rlike row_format rtree schedule schema_name schemas second_microsecond security sensitive separator serializable server share show slave slow snapshot soname spatial sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result ssl starting starts std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace terminated triggers truncate uncommitted uninstall unlock upgrade use use_frm user_resources user_statistics utc_date utc_time utc_timestamp variables views warnings xa xor year_month zerofill",
	types: MySQLTypes,
	builtin: MySQLBuiltin
});
const MariaSQL = SQLDialect.define({
	operatorChars: "*+-%<>!=&|^",
	charSetCasts: true,
	doubleQuotedStrings: true,
	unquotedBitLiterals: true,
	hashComments: true,
	spaceAfterDashes: true,
	specialVar: "@?",
	identifierQuotes: "`",
	functions: SQLFunctions,
	keywords: SQLKeywords + "always generated groupby_concat hard persistent shutdown soft virtual accessible algorithm analyze asensitive authors auto_increment autocommit avg avg_row_length binlog btree cache catalog_name chain change changed checkpoint checksum class_origin client_statistics coalesce code collations columns comment committed completion concurrent consistent contains contributors convert database databases day_hour day_microsecond day_minute day_second delay_key_write delayed delimiter des_key_file dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile enable enclosed ends engine engines enum errors escaped even event events every explain extended fast field fields flush force found_rows fulltext grants handler hash high_priority hosts hour_microsecond hour_minute hour_second ignore ignore_server_ids import index index_statistics infile innodb insensitive insert_method install invoker iterate keys kill linear lines list load lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modify mutex mysql_errno no_write_to_binlog offline offset one online optimize optionally outfile pack_keys parser partition partitions password phase plugin plugins prev processlist profile profiles purge query quick range read_write rebuild recover regexp relaylog remove rename reorganize repair repeatable replace require resume rlike row_format rtree schedule schema_name schemas second_microsecond security sensitive separator serializable server share show slave slow snapshot soname spatial sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result ssl starting starts std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace terminated triggers truncate uncommitted uninstall unlock upgrade use use_frm user_resources user_statistics utc_date utc_time utc_timestamp variables views warnings xa xor year_month zerofill",
	types: MySQLTypes,
	builtin: MySQLBuiltin
});
const MSSQL = SQLDialect.define({
	functions: SQLFunctions,
	keywords: SQLKeywords + "trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock pivot readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx unpivot updlock with",
	types: SQLTypes + "bigint smallint smallmoney tinyint money real text nvarchar ntext varbinary image hierarchyid uniqueidentifier sql_variant xml",
	builtin: "binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id",
	operatorChars: "*+-%<>!=^&|/",
	specialVar: "@"
});
const SQLite = SQLDialect.define({
	functions: SQLFunctions + "isnull notnull",
	keywords: SQLKeywords + "abort analyze attach autoincrement conflict database detach exclusive fail glob ignore index indexed instead offset plan pragma query raise regexp reindex rename replace temp vacuum virtual",
	types: SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int2 int8 unsigned signed real",
	builtin: "auth backup bail changes clone databases dbinfo dump echo eqp explain fullschema headers help import imposter indexes iotrace lint load log mode nullvalue once print prompt quit restore save scanstats separator shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width",
	operatorChars: "*+-%<>!=&|/~",
	identifierQuotes: "`\"",
	specialVar: "@:?$"
});
const Cassandra = SQLDialect.define({
	functions: "to_timestamp to_unix_timestamp to_date cast abs round sqrt count sum max avg min log log10 now min_timeuuid max_timeuuid current_timestamp current_date current_time current_timeuuid",
	keywords: "add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime infinity NaN",
	types: SQLTypes + "ascii bigint blob counter frozen inet list map static text timeuuid tuple uuid varint",
	slashComments: true
});
const PLSQL = SQLDialect.define({
	functions: SQLFunctions,
	keywords: SQLKeywords + "abort accept access add all alter and any arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body by case cast char_base check close cluster clusters colauth column comment commit compress connected constant constraint crash create current currval cursor data_base database dba deallocate debugoff debugon declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry exception exception_init exchange exclusive exists external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base of off offline on online only option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw rebuild record ref references refresh rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work",
	builtin: "appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define echo editfile embedded feedback flagger flush heading headsep instance linesize lno loboffset logsource longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar repfooter repheader serveroutput shiftinout show showmode spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout timing trimout trimspool ttitle underline verify version wrap",
	types: SQLTypes + "ascii bfile bfilename bigserial bit blob dec long number nvarchar nvarchar2 serial smallint string text uid varchar2 xml",
	operatorChars: "*/+-%<>!=~",
	doubleQuotedStrings: true,
	charSetCasts: true
});
const OracleDB = SQLDialect.define({
	operatorChars: "*/+-<>=!",
	doubleQuotedStrings: true,
	charSetCasts: true,
	functions: SQLFunctions + " acos asin atan atan2 bitand ceil chr cos cosh cosine_distance count decode exp extract floor greatest inner_product json_array json_arrayagg json_exists json_object json_objectagg json_query json_scalar json_serialize json_table json_transform json_value l1_distance l2_distance least length lower initcap lpad ltrim max median min mod nvl nvl2 nullif power replace round rpad regexp_instr regexp_replace regexp_substr sign sqrt stddev substr to_blob to_char to_clob to_clob to_date to_number to_ncclob to_timestamp to_timestamp_tz to_vector to_vector translate trunc trim upper uuid vector_distance vector_embedding vector_serialize xmlquery xmltable",
	keywords: SQLKeywords + "access char check cluster dual noaudit nocompress nowait null offline pctfree rename resource rowid rowlabel rownum share size smallint successful synonym sysdate uid validate varchar varchar2",
	types: "binary_double binary_float blob bfile boolean char clob date decimal double float integer interval day to second smallint interval year to month json long longraw nchar nclob number nvarchar2 raw rowid timestamp timestamp with local time zone timestamp with time zone urowid vector varchar2 xmltype",
	builtin: "current_date current_timestamp dbtimezone level localtimestamp rowid rownum sql%found sql%isopen sql%notfound sql%rowcount sessiontimezone sysdate systimestamp user",
	hashComments: false,
	slashComments: false,
	spaceAfterDashes: true,
	doubleDollarQuotedStrings: false
});
var SqlEditor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SqlEditor",
	props: {
		modelValue: {},
		dialect: { default: "StandardSQL" },
		rows: { default: 4 },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		fullscreen: {
			type: Boolean,
			default: false
		},
		targetNodeParameterContext: { default: void 0 }
	},
	emits: ["update:model-value"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const SQL_DIALECTS = {
			StandardSQL,
			PostgreSQL,
			MySQL,
			MariaSQL,
			MSSQL,
			SQLite,
			Cassandra,
			PLSQL,
			OracleDB
		};
		const props = __props;
		const emit = __emit;
		const container$4 = ref();
		const sqlEditor$1 = ref();
		const isFocused = ref(false);
		const outputPopover = ref();
		const { editor: editor$5, segments: { all: segments }, readEditorValue, hasFocus: editorHasFocus, focus } = useExpressionEditor({
			editorRef: sqlEditor$1,
			editorValue: () => props.modelValue,
			extensions: computed(() => {
				const dialect$1 = SQL_DIALECTS[props.dialect] ?? SQL_DIALECTS.StandardSQL;
				function sqlWithN8nLanguageSupport() {
					return new LanguageSupport(dialect$1.language, [
						dialect$1.sqlLanguage.data.of({ closeBrackets: expressionCloseBracketsConfig }),
						dialect$1.sqlLanguage.data.of({ autocomplete: keywordCompletionSource(dialect$1, true) }),
						n8nCompletionSources().map((source) => dialect$1.language.data.of(source))
					]);
				}
				const baseExtensions = [
					sqlWithN8nLanguageSupport(),
					expressionCloseBrackets(),
					codeEditorTheme({
						isReadOnly: props.isReadOnly,
						maxHeight: props.fullscreen ? "100%" : "40vh",
						minHeight: "10vh",
						rows: props.rows
					}),
					lineNumbers(),
					EditorView.lineWrapping
				];
				if (!props.isReadOnly) return baseExtensions.concat([
					history(),
					Prec.highest(keymap.of(editorKeymap)),
					n8nAutocompletion(),
					indentOnInput(),
					highlightActiveLine(),
					highlightActiveLineGutter(),
					foldGutter(),
					dropCursor(),
					bracketMatching(),
					mappingDropCursor()
				]);
				return baseExtensions;
			}),
			skipSegments: [
				"Statement",
				"CompositeIdentifier",
				"Parens",
				"Brackets"
			],
			isReadOnly: props.isReadOnly,
			targetNodeParameterContext: props.targetNodeParameterContext,
			onChange: () => {
				emit("update:model-value", readEditorValue());
			}
		});
		watch(editorHasFocus, (hasFocus) => {
			if (hasFocus) isFocused.value = true;
		});
		onMounted(() => {
			codeNodeEditorEventBus.on("highlightLine", highlightLine);
			if (props.fullscreen) focus();
		});
		onBeforeUnmount(() => {
			codeNodeEditorEventBus.off("highlightLine", highlightLine);
		});
		onClickOutside(container$4, (event) => onBlur(event));
		function onBlur(event) {
			if (event?.target instanceof Element && (Array.from(event.target.classList).some((_class) => _class.includes("resizer")) || outputPopover.value?.contentRef?.contains(event.target))) return;
			isFocused.value = false;
		}
		function line(lineNumber) {
			try {
				return editor$5.value?.state.doc.line(lineNumber) ?? null;
			} catch {
				return null;
			}
		}
		function highlightLine(lineNumber) {
			if (!editor$5.value) return;
			if (lineNumber === "last") {
				editor$5.value.dispatch({ selection: { anchor: editor$5.value.state.doc.length } });
				return;
			}
			const lineToHighlight = line(lineNumber);
			if (!lineToHighlight) return;
			editor$5.value.dispatch({ selection: { anchor: lineToHighlight.from } });
		}
		async function onDrop(value$1, event) {
			if (!editor$5.value) return;
			await dropInExpressionEditor(toRaw(editor$5.value), event, value$1);
		}
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "container",
				ref: container$4,
				class: normalizeClass(_ctx.$style.sqlEditor),
				onKeydown: withKeys(onBlur, ["tab"])
			}, [
				createVNode(DraggableTarget_default, {
					type: "mapping",
					disabled: _ctx.isReadOnly,
					onDrop
				}, {
					default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createBaseVNode("div", {
						ref_key: "sqlEditor",
						ref: sqlEditor$1,
						class: normalizeClass([_ctx.$style.codemirror, {
							[_ctx.$style.activeDrop]: activeDrop$8,
							[_ctx.$style.droppable]: droppable$10
						}]),
						"data-test-id": "sql-editor-container"
					}, null, 2)]),
					_: 1
				}, 8, ["disabled"]),
				renderSlot(_ctx.$slots, "suffix"),
				!_ctx.fullscreen ? (openBlock(), createBlock(InlineExpressionEditorOutput_default, {
					key: 0,
					ref_key: "outputPopover",
					ref: outputPopover,
					segments: unref(segments),
					"is-read-only": _ctx.isReadOnly,
					visible: isFocused.value,
					"virtual-ref": container$4.value
				}, null, 8, [
					"segments",
					"is-read-only",
					"visible",
					"virtual-ref"
				])) : createCommentVNode("", true)
			], 34);
		};
	}
});
var SqlEditor_vue_vue_type_style_index_0_lang_module_default = {
	sqlEditor: "_sqlEditor_1o6js_123",
	codemirror: "_codemirror_1o6js_131",
	droppable: "_droppable_1o6js_135",
	activeDrop: "_activeDrop_1o6js_141"
};
var SqlEditor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(SqlEditor_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": SqlEditor_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$18 = { key: 0 };
var _hoisted_2$7 = { class: "ignore-key-press-canvas" };
var TextEdit_default = /* @__PURE__ */ defineComponent({
	__name: "TextEdit",
	props: {
		dialogVisible: { type: Boolean },
		parameter: {},
		path: {},
		modelValue: {},
		isReadOnly: { type: Boolean }
	},
	emits: ["update:modelValue", "closeDialog"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const inputField$2 = ref(null);
		const tempValue = ref("");
		const ndvStore = useNDVStore();
		const i18n$1 = useI18n();
		const { activeNode } = storeToRefs(ndvStore);
		watch(() => props.dialogVisible, async (newValue) => {
			if (newValue) {
				await nextTick();
				inputField$2.value?.focus();
			}
		});
		watch(() => props.modelValue, (value$1) => {
			tempValue.value = value$1;
		});
		onMounted(() => {
			tempValue.value = props.modelValue;
		});
		const valueChanged = (value$1) => {
			emit("update:modelValue", value$1);
		};
		const onKeyDownEsc = () => {
			tempValue.value = props.modelValue;
			closeDialog();
		};
		const closeDialog = () => {
			emit("closeDialog");
		};
		return (_ctx, _cache) => {
			return _ctx.dialogVisible ? (openBlock(), createElementBlock("div", _hoisted_1$18, [createVNode(unref(ElDialog), {
				"model-value": _ctx.dialogVisible,
				"append-to": `#${unref(APP_MODALS_ELEMENT_ID)}`,
				width: "80%",
				title: `${unref(i18n$1).baseText("textEdit.edit")} ${unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path)}`,
				"before-close": closeDialog
			}, {
				default: withCtx(() => [createBaseVNode("div", _hoisted_2$7, [createVNode(unref(N8nInputLabel_default), { label: unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path) }, {
					default: withCtx(() => [createBaseVNode("div", { onKeydown: [_cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])), withKeys(onKeyDownEsc, ["esc"])] }, [createVNode(unref(N8nInput_default), {
						ref_key: "inputField",
						ref: inputField$2,
						modelValue: tempValue.value,
						"onUpdate:modelValue": [_cache[0] || (_cache[0] = ($event) => tempValue.value = $event), valueChanged],
						type: "textarea",
						placeholder: unref(i18n$1).nodeText(unref(activeNode)?.type).placeholder(_ctx.parameter, _ctx.path),
						"read-only": _ctx.isReadOnly,
						rows: 15
					}, null, 8, [
						"modelValue",
						"placeholder",
						"read-only"
					])], 32)]),
					_: 1
				}, 8, ["label"])])]),
				_: 1
			}, 8, [
				"model-value",
				"append-to",
				"title"
			])])) : createCommentVNode("", true);
		};
	}
});
function useWorkflowResourceLocatorDropdown(isListMode, inputRef) {
	const isDropdownVisible = ref(false);
	const resourceDropdownHiding = ref(false);
	function showDropdown() {
		if (!isListMode.value || resourceDropdownHiding.value) return;
		isDropdownVisible.value = true;
	}
	function hideDropdown() {
		isDropdownVisible.value = false;
		resourceDropdownHiding.value = true;
		nextTick(() => {
			inputRef.value?.blur?.();
			resourceDropdownHiding.value = false;
		});
	}
	return {
		isDropdownVisible,
		showDropdown,
		hideDropdown
	};
}
function useWorkflowResourcesLocator(router) {
	const workflowsStore = useWorkflowsStore();
	const ndvStore = useNDVStore();
	const { renameNode } = useCanvasOperations();
	const workflowsResources = ref([]);
	const isLoadingResources = ref(true);
	const searchFilter = ref("");
	const currentPage = ref(0);
	const PAGE_SIZE = 40;
	const totalCount = ref(0);
	const hasMoreWorkflowsToLoad = computed(() => totalCount.value > workflowsResources.value.length);
	function constructName(workflow) {
		if (workflow.homeProject && workflow.homeProject.type !== "personal") return `${workflow.homeProject.name} — ${workflow.name}`;
		return workflow.name;
	}
	function getWorkflowName(id) {
		const workflow = workflowsStore.getWorkflowById(id);
		if (workflow) return constructName(workflow);
		return id;
	}
	function getWorkflowBaseName(id) {
		const workflow = workflowsStore.getWorkflowById(id);
		if (workflow) return workflow.name;
		return null;
	}
	function getWorkflowUrl(workflowId) {
		const { href } = router.resolve({
			name: VIEWS.WORKFLOW,
			params: { name: workflowId }
		});
		return href;
	}
	function workflowDbToResourceMapper(workflow) {
		return {
			name: constructName(workflow),
			value: workflow.id,
			url: getWorkflowUrl(workflow.id),
			isArchived: "isArchived" in workflow ? workflow.isArchived : false
		};
	}
	async function populateNextWorkflowsPage(reset = false) {
		if (reset) currentPage.value = 0;
		currentPage.value++;
		const workflows = await workflowsStore.fetchWorkflowsPage(void 0, currentPage.value, PAGE_SIZE, "updatedAt:desc", searchFilter.value ? { name: searchFilter.value } : void 0);
		totalCount.value = workflowsStore.totalWorkflowCount;
		if (reset) workflowsResources.value = workflows.map(workflowDbToResourceMapper);
		else workflowsResources.value.push(...workflows.map(workflowDbToResourceMapper));
	}
	async function setWorkflowsResources() {
		isLoadingResources.value = true;
		await populateNextWorkflowsPage();
		isLoadingResources.value = false;
	}
	async function onSearchFilter(filter$1) {
		searchFilter.value = filter$1;
		await populateNextWorkflowsPage(true);
	}
	function applyDefaultExecuteWorkflowNodeName(workflowId) {
		if (typeof workflowId !== "string") return;
		const nodeName = ndvStore.activeNodeName;
		if (nodeName === "Execute Workflow" || nodeName === "Call n8n Workflow Tool" || nodeName?.startsWith("Call '") && nodeName?.endsWith("'")) {
			const baseName = getWorkflowBaseName(workflowId);
			if (baseName !== null) renameNode(nodeName, `Call '${baseName}'`);
		}
	}
	return {
		workflowsResources,
		isLoadingResources,
		hasMoreWorkflowsToLoad,
		searchFilter,
		getWorkflowUrl,
		onSearchFilter,
		getWorkflowName,
		applyDefaultExecuteWorkflowNodeName,
		populateNextWorkflowsPage,
		setWorkflowsResources,
		workflowDbToResourceMapper
	};
}
function useWorkflowResourceLocatorModes(modelValue, router) {
	const i18n$1 = useI18n();
	const { getWorkflowName } = useWorkflowResourcesLocator(router);
	const supportedModes = computed(() => [{
		name: "list",
		type: "list",
		displayName: i18n$1.baseText("resourceLocator.mode.list")
	}, {
		type: "string",
		name: "id",
		displayName: i18n$1.baseText("resourceLocator.mode.id")
	}]);
	const selectedMode = computed(() => modelValue.value?.mode || "list");
	const isListMode = computed(() => selectedMode.value === "list");
	function getUpdatedModePayload(value$1) {
		if (typeof modelValue !== "object") return {
			__rl: true,
			value: modelValue,
			mode: value$1
		};
		if (value$1 === "id" && selectedMode.value === "list" && modelValue.value.value) return {
			__rl: true,
			mode: value$1,
			value: modelValue.value.value
		};
		return {
			__rl: true,
			mode: value$1,
			value: modelValue.value.value,
			cachedResultName: getWorkflowName(modelValue.value.value?.toString() ?? "")
		};
	}
	function getModeLabel(mode) {
		if (mode.name === "id" || mode.name === "list") return i18n$1.baseText(`resourceLocator.mode.${mode.name}`);
		return mode.displayName;
	}
	return {
		supportedModes,
		selectedMode,
		isListMode,
		getUpdatedModePayload,
		getModeLabel
	};
}
const SAMPLE_SUBWORKFLOW_TRIGGER_ID = "c055762a-8fe7-4141-a639-df2372f30060";
const SAMPLE_SUBWORKFLOW_WORKFLOW = {
	name: "My Sub-Workflow",
	nodes: [{
		id: SAMPLE_SUBWORKFLOW_TRIGGER_ID,
		typeVersion: 1.1,
		name: "When Executed by Another Workflow",
		type: "n8n-nodes-base.executeWorkflowTrigger",
		position: [260, 340],
		parameters: {}
	}, {
		id: "b5942df6-0160-4ef7-965d-57583acdc8aa",
		name: "Replace me with your logic",
		type: "n8n-nodes-base.noOp",
		position: [520, 340],
		parameters: {}
	}],
	connections: { "When Executed by Another Workflow": { main: [[{
		node: "Replace me with your logic",
		type: NodeConnectionTypes.Main,
		index: 0
	}]] } },
	settings: { executionOrder: "v1" },
	pinData: {}
};
NodeConnectionTypes.Main, NodeConnectionTypes.Main;
function useDocumentVisibility() {
	const isVisible = ref(!document.hidden);
	const visibleHandlers = ref([]);
	const hiddenHandlers = ref([]);
	const onVisibilityChange = () => {
		const newVisibilityState = !document.hidden;
		isVisible.value = newVisibilityState;
		if (newVisibilityState) visibleHandlers.value.forEach((handler) => handler());
		else hiddenHandlers.value.forEach((handler) => handler());
	};
	const onDocumentVisible = (handler) => {
		visibleHandlers.value.push(handler);
	};
	const onDocumentHidden = (handler) => {
		hiddenHandlers.value.push(handler);
	};
	onMounted(() => {
		document.addEventListener("visibilitychange", onVisibilityChange);
	});
	onUnmounted(() => {
		document.removeEventListener("visibilitychange", onVisibilityChange);
		visibleHandlers.value = [];
		hiddenHandlers.value = [];
	});
	return {
		isVisible,
		onDocumentVisible,
		onDocumentHidden
	};
}
var _hoisted_1$17 = ["data-test-id"];
var WorkflowSelectorParameterInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "WorkflowSelectorParameterInput",
	props: {
		modelValue: {},
		eventBus: { default: () => createEventBus() },
		inputSize: { default: "small" },
		isValueExpression: {
			type: Boolean,
			default: false
		},
		isReadOnly: {
			type: Boolean,
			default: false
		},
		path: {},
		expressionDisplayValue: { default: "" },
		forceShowExpression: {
			type: Boolean,
			default: false
		},
		parameterIssues: { default: () => [] },
		parameter: {},
		sampleWorkflow: { default: () => SAMPLE_SUBWORKFLOW_WORKFLOW },
		newResourceLabel: { default: "" }
	},
	emits: [
		"update:modelValue",
		"drop",
		"modalOpenerClick",
		"focus",
		"blur",
		"workflowCreated"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const workflowsStore = useWorkflowsStore();
		const projectStore = useProjectsStore();
		const router = useRouter();
		const i18n$1 = useI18n();
		const container$4 = ref();
		const dropdown$1 = ref();
		const telemetry = useTelemetry();
		const toast = useToast();
		const width = ref(0);
		const inputRef = ref();
		const { isListMode, getUpdatedModePayload, selectedMode, supportedModes, getModeLabel } = useWorkflowResourceLocatorModes(computed(() => props.modelValue), router);
		const { hideDropdown, isDropdownVisible, showDropdown } = useWorkflowResourceLocatorDropdown(isListMode, inputRef);
		const { onDocumentVisible } = useDocumentVisibility();
		const { hasMoreWorkflowsToLoad, isLoadingResources, searchFilter, onSearchFilter, getWorkflowName, applyDefaultExecuteWorkflowNodeName, populateNextWorkflowsPage, setWorkflowsResources, workflowDbToResourceMapper, getWorkflowUrl, workflowsResources } = useWorkflowResourcesLocator(router);
		const currentProjectName = computed(() => {
			if (!projectStore.isTeamProjectFeatureEnabled) return "";
			if (!projectStore?.currentProject || projectStore.currentProject?.type === "personal") return `'${i18n$1.baseText("projects.menu.personal")}'`;
			return `'${projectStore.currentProject?.name}'`;
		});
		const getCreateResourceLabel = computed(() => {
			if (props.newResourceLabel) return props.newResourceLabel;
			if (!currentProjectName.value) return i18n$1.baseText("executeWorkflowTrigger.createNewSubworkflow.noProject");
			return i18n$1.baseText("executeWorkflowTrigger.createNewSubworkflow", { interpolate: { projectName: currentProjectName.value } });
		});
		const valueToDisplay = computed(() => {
			if (typeof props.modelValue !== "object") return props.modelValue ?? "";
			if (isListMode.value) return props.modelValue ? props.modelValue.cachedResultName ?? props.modelValue.value : "";
			return props.modelValue ? props.modelValue.value : "";
		});
		const placeholder = computed(() => {
			if (isListMode.value) return i18n$1.baseText("resourceLocator.mode.list.placeholder");
			return i18n$1.baseText("resourceLocator.id.placeholder");
		});
		const showOpenResourceLink = computed(() => {
			return !props.isValueExpression && props.modelValue.value;
		});
		function setWidth() {
			const containerRef = container$4.value;
			if (containerRef) width.value = containerRef?.offsetWidth;
		}
		function onInputChange(workflowId) {
			if (typeof workflowId !== "string") return;
			const params = {
				__rl: true,
				value: workflowId,
				mode: selectedMode.value,
				cachedResultUrl: getWorkflowUrl(workflowId)
			};
			if (isListMode.value) {
				if (workflowsStore.getWorkflowById(workflowId)?.name) params.cachedResultName = getWorkflowName(workflowId);
			}
			emit("update:modelValue", params);
		}
		function onListItemSelected(value$1) {
			telemetry.track("User chose sub-workflow", {});
			onInputChange(value$1);
			hideDropdown();
			applyDefaultExecuteWorkflowNodeName(value$1);
		}
		function onInputFocus() {
			setWidth();
			emit("focus");
		}
		function onInputBlur() {
			emit("blur");
		}
		async function onDrop(data) {
			emit("drop", data);
		}
		function onModeSwitched(mode) {
			emit("update:modelValue", getUpdatedModePayload(mode));
		}
		function onKeyDown(e) {
			if (isDropdownVisible.value) props.eventBus.emit("keyDown", e);
		}
		function openWorkflow() {
			window.open(getWorkflowUrl(props.modelValue.value?.toString() ?? ""), "_blank");
		}
		async function refreshCachedWorkflow() {
			if (!props.modelValue || props.modelValue.mode !== "list" || !props.modelValue.value) return;
			const workflowId = props.modelValue.value;
			try {
				await workflowsStore.fetchWorkflow(`${workflowId}`);
				onInputChange(workflowId);
			} catch (e) {}
		}
		onDocumentVisible(refreshCachedWorkflow);
		onMounted(() => {
			refreshCachedWorkflow();
			window.addEventListener("resize", setWidth);
			setWidth();
			setWorkflowsResources();
		});
		onUnmounted(() => {
			window.removeEventListener("resize", setWidth);
		});
		watch(() => props.isValueExpression, (isValueExpression$1) => {
			if (isValueExpression$1) onModeSwitched("id");
		});
		watch(() => props.modelValue, (val, old) => {
			if (old.value !== val.value) applyDefaultExecuteWorkflowNodeName(val.value);
		});
		onClickOutside(dropdown$1, () => {
			isDropdownVisible.value = false;
		});
		const onAddResourceClicked = async () => {
			try {
				const projectId = projectStore.currentProjectId;
				const sampleWorkflow = props.sampleWorkflow;
				const workflowName = sampleWorkflow.name ?? "My Sub-Workflow";
				const sampleSubWorkflows = workflowsStore.allWorkflows.filter((w$1) => w$1.name && new RegExp(workflowName).test(w$1.name));
				const workflow = {
					...sampleWorkflow,
					name: `${workflowName} ${sampleSubWorkflows.length + 1}`
				};
				if (projectId) workflow.projectId = projectId;
				telemetry.track("User clicked create new sub-workflow button", {});
				const newWorkflow = await workflowsStore.createNewWorkflow(workflow);
				const { href } = router.resolve({
					name: VIEWS.WORKFLOW,
					params: {
						name: newWorkflow.id,
						nodeId: SAMPLE_SUBWORKFLOW_TRIGGER_ID
					}
				});
				workflowsResources.value.push(workflowDbToResourceMapper(newWorkflow));
				emit("update:modelValue", {
					__rl: true,
					value: newWorkflow.id,
					mode: selectedMode.value,
					cachedResultName: newWorkflow.name,
					cachedResultUrl: getWorkflowUrl(newWorkflow.id)
				});
				hideDropdown();
				window.open(href, "_blank");
				emit("workflowCreated", newWorkflow.id);
			} catch (error) {
				toast.showError(error, i18n$1.baseText("generic.error.subworkflowCreationFailed"));
			}
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				ref_key: "container",
				ref: container$4,
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": `resource-locator-${_ctx.parameter.name}`
			}, [createVNode(ResourceLocatorDropdown_default, {
				ref_key: "dropdown",
				ref: dropdown$1,
				show: unref(isDropdownVisible),
				filterable: true,
				"filter-required": false,
				resources: unref(workflowsResources),
				loading: unref(isLoadingResources),
				filter: unref(searchFilter),
				"has-more": unref(hasMoreWorkflowsToLoad),
				"error-view": false,
				"allow-new-resources": { label: getCreateResourceLabel.value },
				width: width.value,
				"event-bus": _ctx.eventBus,
				"model-value": _ctx.modelValue,
				"onUpdate:modelValue": onListItemSelected,
				onFilter: unref(onSearchFilter),
				onLoadMore: unref(populateNextWorkflowsPage),
				onAddResourceClick: onAddResourceClicked
			}, {
				error: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(_ctx.$style.error),
					"data-test-id": "rlc-error-container"
				}, [createVNode(unref(N8nText_default), {
					color: "text-dark",
					align: "center",
					tag: "div"
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("resourceLocator.mode.list.error.title")), 1)]),
					_: 1
				})], 2)]),
				default: withCtx(() => [createBaseVNode("div", { class: normalizeClass({
					[_ctx.$style.resourceLocator]: true,
					[_ctx.$style.multipleModes]: true
				}) }, [
					createBaseVNode("div", { class: normalizeClass({
						[_ctx.$style.background]: true,
						[_ctx.$style.backgroundWithIssuesAndShowResourceLink]: showOpenResourceLink.value && _ctx.parameterIssues?.length
					}) }, null, 2),
					createBaseVNode("div", { class: normalizeClass(_ctx.$style.modeSelector) }, [createVNode(unref(N8nSelect_default), {
						"model-value": unref(selectedMode),
						size: _ctx.inputSize,
						disabled: _ctx.isReadOnly,
						placeholder: unref(i18n$1).baseText("resourceLocator.modeSelector.placeholder"),
						"data-test-id": "rlc-mode-selector",
						"onUpdate:modelValue": onModeSwitched
					}, {
						default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(supportedModes), (mode) => {
							return openBlock(), createBlock(unref(N8nOption_default), {
								key: mode.name,
								value: mode.name,
								label: unref(getModeLabel)(mode),
								disabled: _ctx.isValueExpression && mode.name === "list",
								title: _ctx.isValueExpression && mode.name === "list" ? unref(i18n$1).baseText("resourceLocator.mode.list.disabled.title") : ""
							}, {
								default: withCtx(() => [createTextVNode(toDisplayString(unref(getModeLabel)(mode)), 1)]),
								_: 2
							}, 1032, [
								"value",
								"label",
								"disabled",
								"title"
							]);
						}), 128))]),
						_: 1
					}, 8, [
						"model-value",
						"size",
						"disabled",
						"placeholder"
					])], 2),
					createBaseVNode("div", {
						class: normalizeClass(_ctx.$style.inputContainer),
						"data-test-id": "rlc-input-container"
					}, [
						createVNode(DraggableTarget_default, {
							type: "mapping",
							sticky: true,
							"sticky-offset": _ctx.isValueExpression ? [26, 3] : [3, 3],
							onDrop
						}, {
							default: withCtx(({ droppable: droppable$10, activeDrop: activeDrop$8 }) => [createBaseVNode("div", {
								class: normalizeClass({
									[_ctx.$style.listModeInputContainer]: unref(isListMode),
									[_ctx.$style.droppable]: droppable$10,
									[_ctx.$style.activeDrop]: activeDrop$8
								}),
								onKeydown: withModifiers(onKeyDown, ["stop"])
							}, [_ctx.isValueExpression || _ctx.forceShowExpression ? (openBlock(), createBlock(ExpressionParameterInput_default, {
								key: 0,
								ref: "input",
								"model-value": _ctx.expressionDisplayValue,
								path: _ctx.path,
								"is-read-only": _ctx.isReadOnly,
								rows: 3,
								"onUpdate:modelValue": onInputChange,
								onModalOpenerClick: _cache[0] || (_cache[0] = ($event) => emit("modalOpenerClick"))
							}, null, 8, [
								"model-value",
								"path",
								"is-read-only"
							])) : (openBlock(), createBlock(unref(N8nInput_default), {
								key: 1,
								ref: "input",
								class: normalizeClass({ [_ctx.$style.selectInput]: unref(isListMode) }),
								size: _ctx.inputSize,
								"model-value": valueToDisplay.value,
								disabled: _ctx.isReadOnly,
								readonly: unref(isListMode),
								placeholder: placeholder.value,
								type: "text",
								"data-test-id": "rlc-input",
								"onUpdate:modelValue": onInputChange,
								onClick: unref(showDropdown),
								onFocus: onInputFocus,
								onBlur: onInputBlur
							}, createSlots({ _: 2 }, [unref(isListMode) ? {
								name: "suffix",
								fn: withCtx(() => [createBaseVNode("i", { class: normalizeClass({
									["el-input__icon"]: true,
									["el-icon-arrow-down"]: true,
									[_ctx.$style.selectIcon]: true,
									[_ctx.$style.isReverse]: unref(isDropdownVisible)
								}) }, null, 2)]),
								key: "0"
							} : void 0]), 1032, [
								"class",
								"size",
								"model-value",
								"disabled",
								"readonly",
								"placeholder",
								"onClick"
							]))], 34)]),
							_: 1
						}, 8, ["sticky-offset"]),
						_ctx.parameterIssues && _ctx.parameterIssues.length ? (openBlock(), createBlock(ParameterIssues_default, {
							key: 0,
							issues: _ctx.parameterIssues,
							class: normalizeClass(_ctx.$style["parameter-issues"])
						}, null, 8, ["issues", "class"])) : createCommentVNode("", true),
						showOpenResourceLink.value ? (openBlock(), createElementBlock("div", {
							key: 1,
							class: normalizeClass(_ctx.$style.openResourceLink),
							"data-test-id": "rlc-open-resource-link"
						}, [createVNode(unref(N8nLink_default), {
							theme: "text",
							onClick: _cache[1] || (_cache[1] = withModifiers(($event) => openWorkflow(), ["stop"]))
						}, {
							default: withCtx(() => [createVNode(unref(N8nIcon_default), {
								icon: "external-link",
								title: "Open resource link"
							})]),
							_: 1
						})], 2)) : createCommentVNode("", true)
					], 2)
				], 2)]),
				_: 1
			}, 8, [
				"show",
				"resources",
				"loading",
				"filter",
				"has-more",
				"allow-new-resources",
				"width",
				"event-bus",
				"model-value",
				"onFilter",
				"onLoadMore"
			])], 10, _hoisted_1$17);
		};
	}
});
const modeSelector = "_modeSelector_8mz3z_123";
const inputField = "_inputField_8mz3z_141";
const fromAiOverrideField = "_fromAiOverrideField_8mz3z_146";
const overrideButtonInline$1 = "_overrideButtonInline_8mz3z_152";
const rightNoCorner = "_rightNoCorner_8mz3z_160";
const resourceLocator = "_resourceLocator_8mz3z_165";
const inputContainer$1 = "_inputContainer_8mz3z_173";
const background$1 = "_background_8mz3z_186";
const backgroundOverride = "_backgroundOverride_8mz3z_196";
const backgroundWithIssuesAndShowResourceLink = "_backgroundWithIssuesAndShowResourceLink_8mz3z_199";
const multipleModes = "_multipleModes_8mz3z_202";
const inputContainerInputCorners = "_inputContainerInputCorners_8mz3z_208";
const droppable$4 = "_droppable_8mz3z_212";
const activeDrop$2 = "_activeDrop_8mz3z_217";
const selectInput = "_selectInput_8mz3z_227";
const selectIcon = "_selectIcon_8mz3z_233";
const isReverse = "_isReverse_8mz3z_239";
const listModeInputContainer = "_listModeInputContainer_8mz3z_243";
const errorContainer = "_errorContainer_8mz3z_247";
const errorDetails = "_errorDetails_8mz3z_248";
const errorDescription = "_errorDescription_8mz3z_260";
const openResourceLink = "_openResourceLink_8mz3z_270";
var WorkflowSelectorParameterInput_vue_vue_type_style_index_0_lang_module_default = {
	modeSelector,
	inputField,
	fromAiOverrideField,
	overrideButtonInline: overrideButtonInline$1,
	rightNoCorner,
	resourceLocator,
	inputContainer: inputContainer$1,
	background: background$1,
	backgroundOverride,
	backgroundWithIssuesAndShowResourceLink,
	multipleModes,
	inputContainerInputCorners,
	droppable: droppable$4,
	activeDrop: activeDrop$2,
	selectInput,
	selectIcon,
	isReverse,
	listModeInputContainer,
	errorContainer,
	errorDetails,
	errorDescription,
	"credential-link": "_credential-link_8mz3z_266",
	openResourceLink,
	"parameter-issues": "_parameter-issues_8mz3z_277"
};
var WorkflowSelectorParameterInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(WorkflowSelectorParameterInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": WorkflowSelectorParameterInput_vue_vue_type_style_index_0_lang_module_default }]]);
var require_set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSet = require__baseSet();
	function set$2(object, path, value$1) {
		return object == null ? object : baseSet(object, path, value$1);
	}
	module.exports = set$2;
}));
var require_last = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function last$1(array) {
		var length = array == null ? 0 : array.length;
		return length ? array[length - 1] : void 0;
	}
	module.exports = last$1;
}));
var require__parent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet = require__baseGet(), baseSlice = require__baseSlice();
	function parent$1(object, path) {
		return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}
	module.exports = parent$1;
}));
var require__baseUnset = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath = require__castPath(), last = require_last(), parent = require__parent(), toKey = require__toKey();
	function baseUnset$1(object, path) {
		path = castPath(path, object);
		object = parent(object, path);
		return object == null || delete object[toKey(last(path))];
	}
	module.exports = baseUnset$1;
}));
var require_unset = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseUnset = require__baseUnset();
	function unset$1(object, path) {
		return object == null ? true : baseUnset(object, path);
	}
	module.exports = unset$1;
}));
var import_isEqual$2 = /* @__PURE__ */ __toESM(require_isEqual());
var import_get$5 = /* @__PURE__ */ __toESM(require_get());
var import_set$1 = /* @__PURE__ */ __toESM(require_set());
var import_unset = /* @__PURE__ */ __toESM(require_unset());
function getNodeSettingsInitialValues() {
	return {
		color: "#ff0000",
		alwaysOutputData: false,
		executeOnce: false,
		notesInFlow: false,
		onError: "stopWorkflow",
		retryOnFail: false,
		maxTries: 3,
		waitBetweenTries: 1e3,
		notes: "",
		parameters: {}
	};
}
function setValue(nodeValues, name, value$1) {
	const nameParts = name.split(".");
	let lastNamePart = nameParts.pop();
	let isArray = false;
	if (lastNamePart?.includes("[")) {
		const lastNameParts = lastNamePart.match(/(.*)\[(\d+)\]$/);
		if (lastNameParts) {
			nameParts.push(lastNameParts[1]);
			lastNamePart = lastNameParts[2];
			isArray = true;
		}
	}
	if (nameParts.length === 0) if (value$1 === null) {
		if (lastNamePart) nodeValues.value = omitKey(nodeValues.value, lastNamePart);
	} else nodeValues.value = {
		...nodeValues.value,
		[lastNamePart]: value$1
	};
	else if (value$1 === null) {
		let tempValue = (0, import_get$5.default)(nodeValues.value, nameParts.join("."));
		if (lastNamePart && !Array.isArray(tempValue)) tempValue = omitKey(tempValue, lastNamePart);
		if (isArray && Array.isArray(tempValue) && tempValue.length === 0) {
			lastNamePart = nameParts.pop();
			tempValue = (0, import_get$5.default)(nodeValues.value, nameParts.join("."));
			if (lastNamePart) tempValue = omitKey(tempValue, lastNamePart);
		}
	} else if (typeof value$1 === "object") (0, import_set$1.default)((0, import_get$5.default)(nodeValues.value, nameParts.join(".")), lastNamePart, deepCopy(value$1));
	else (0, import_set$1.default)((0, import_get$5.default)(nodeValues.value, nameParts.join(".")), lastNamePart, value$1);
	nodeValues.value = { ...nodeValues.value };
}
function updateDynamicConnections(node$1, workflowConnections, parameterData) {
	const connections = { ...workflowConnections };
	try {
		if (parameterData.name.includes("conditions") || !connections[node$1.name]?.main) return null;
		if (node$1.type === "n8n-nodes-base.switch" && parameterData.name === "parameters.numberOutputs") {
			const curentNumberOutputs = node$1.parameters?.numberOutputs;
			const newNumberOutputs = parameterData.value;
			if (newNumberOutputs < curentNumberOutputs) {
				connections[node$1.name].main = connections[node$1.name].main.slice(0, newNumberOutputs);
				return connections;
			}
		}
		if (node$1.type === "n8n-nodes-base.switch" && parameterData.name === "parameters.options.fallbackOutput") {
			if ((node$1.parameters?.options)?.fallbackOutput === "extra") {
				if (!parameterData.value || parameterData.value !== "extra") {
					connections[node$1.name].main = connections[node$1.name].main.slice(0, -1);
					return connections;
				}
			}
		}
		if (node$1.type === "n8n-nodes-base.switch" && parameterData.name.includes("parameters.rules.values")) {
			const { fallbackOutput } = node$1.parameters?.options;
			if (parameterData.value === void 0) {
				function extractIndex(path) {
					const match = path.match(/parameters\.rules\.values\[(\d+)\]$/);
					return match ? parseInt(match[1], 10) : null;
				}
				const index$1 = extractIndex(parameterData.name);
				if (index$1 !== null) {
					connections[node$1.name].main.splice(index$1, 1);
					return connections;
				}
				if (parameterData.name === "parameters.rules.values") {
					if (fallbackOutput === "extra") connections[node$1.name].main = [connections[node$1.name].main[connections[node$1.name].main.length - 1]];
					else connections[node$1.name].main = [];
					return connections;
				}
			} else if (parameterData.name === "parameters.rules.values") {
				const curentRulesvalues = (node$1.parameters?.rules)?.values;
				let lastConnection = void 0;
				if (fallbackOutput === "extra" && connections[node$1.name].main.length === curentRulesvalues.length + 1) lastConnection = connections[node$1.name].main.pop();
				const currentRulesLength = (node$1.parameters?.rules)?.values?.length;
				if (parameterData.value?.length - currentRulesLength === 1) {
					connections[node$1.name].main = [...connections[node$1.name].main, []];
					if (lastConnection) connections[node$1.name].main.push(lastConnection);
					return connections;
				} else {
					const newRulesvalues = parameterData.value;
					const updatedConnectionsIndex = [];
					for (const newRule of newRulesvalues) {
						const index$1 = curentRulesvalues.findIndex((rule) => (0, import_isEqual$2.default)(rule, newRule));
						if (index$1 !== -1) updatedConnectionsIndex.push(index$1);
					}
					const reorderedConnections = [];
					for (const index$1 of updatedConnectionsIndex) reorderedConnections.push(connections[node$1.name].main[index$1] ?? []);
					if (lastConnection) reorderedConnections.push(lastConnection);
					connections[node$1.name].main = reorderedConnections;
					return connections;
				}
			}
		}
	} catch (error) {
		captureException(error);
	}
	return null;
}
function removeMismatchedOptionValues(nodeType, nodeTypeVersion, nodeParameterValues, updatedParameter) {
	nodeType.properties.forEach((prop) => {
		const displayOptions = prop.displayOptions;
		if (!nodeParameterValues || !Object.prototype.hasOwnProperty.call(nodeParameterValues, prop.name) || !displayOptions || !prop.options) return;
		const showCondition = displayOptions.show?.[updatedParameter.name];
		const hideCondition = displayOptions.hide?.[updatedParameter.name];
		if (showCondition === void 0 && hideCondition === void 0) return;
		let hasValidOptions = true;
		if (isINodePropertyCollectionList(prop.options) || isINodePropertiesList(prop.options)) hasValidOptions = Object.keys(nodeParameterValues).every((key) => (prop.options ?? []).find((option$1) => option$1.name === key) !== void 0);
		else if (isINodePropertyOptionsList(prop.options)) hasValidOptions = !!prop.options.find((option$1) => option$1.value === nodeParameterValues[prop.name]);
		if (!hasValidOptions && displayParameter(nodeParameterValues, prop, { typeVersion: nodeTypeVersion }, nodeType)) (0, import_unset.default)(nodeParameterValues, prop.name);
	});
}
function updateParameterByPath(parameterName, newValue, nodeParameters, nodeType, nodeTypeVersion) {
	const parameterPath = parameterName.split(".").slice(1).join(".");
	const parameterPathArray = parameterPath.match(/(.*)\[(\d+)\]$/);
	if (newValue === void 0 && parameterPathArray !== null) {
		const path = parameterPathArray[1];
		const index$1 = parameterPathArray[2];
		const data = (0, import_get$5.default)(nodeParameters, path);
		if (Array.isArray(data)) {
			data.splice(parseInt(index$1, 10), 1);
			(0, import_set$1.default)(nodeParameters, path, data);
		}
	} else {
		if (newValue === void 0) (0, import_unset.default)(nodeParameters, parameterPath);
		else (0, import_set$1.default)(nodeParameters, parameterPath, newValue);
		removeMismatchedOptionValues(nodeType, nodeTypeVersion, nodeParameters, {
			name: parameterPath,
			value: newValue
		});
	}
	return parameterPath;
}
function getParameterTypeOption(parameter, optionName) {
	return parameter.typeOptions?.[optionName];
}
function isResourceLocatorParameterType(type) {
	return type === "resourceLocator" || type === "workflowSelector";
}
function isValidParameterOption(option$1) {
	return "value" in option$1 && isPresent(option$1.value) && isPresent(option$1.name);
}
function mustHideDuringCustomApiCall(parameter, nodeParameters) {
	if (parameter?.displayOptions?.hide) return true;
	return ![
		"authentication",
		"resource",
		"operation",
		...Object.keys(nodeParameters)
	].includes(parameter.name);
}
function nameIsParameter(parameterData) {
	return parameterData.name.startsWith("parameters.");
}
function formatAsExpression(value$1, parameterType) {
	if (isResourceLocatorParameterType(parameterType)) {
		if (isResourceLocatorValue(value$1)) return {
			__rl: true,
			value: `=${value$1.value}`,
			mode: value$1.mode
		};
		return {
			__rl: true,
			value: `=${value$1}`,
			mode: ""
		};
	}
	const isNumber$1 = parameterType === "number";
	const isBoolean = parameterType === "boolean";
	const isMultiOptions = parameterType === "multiOptions";
	if (isNumber$1 && (!value$1 || value$1 === "[Object: null]")) return "={{ 0 }}";
	if (isMultiOptions) return `={{ ${JSON.stringify(value$1)} }}`;
	if (isNumber$1 || isBoolean || typeof value$1 !== "string") return `={{ ${String(value$1)} }}`;
	return `=${value$1}`;
}
function parseFromExpression(currentParameterValue, evaluatedExpressionValue, parameterType, defaultValue, parameterOptions = []) {
	if (parameterType === "multiOptions" && typeof evaluatedExpressionValue === "string") return evaluatedExpressionValue.split(",").filter((valueItem) => parameterOptions.find((option$1) => option$1.value === valueItem));
	if (isResourceLocatorParameterType(parameterType) && isResourceLocatorValue(currentParameterValue)) return {
		__rl: true,
		value: evaluatedExpressionValue,
		mode: currentParameterValue.mode
	};
	if (parameterType === "string") return currentParameterValue ? currentParameterValue.toString().replace(/^=+/, "") : null;
	if (typeof evaluatedExpressionValue !== "undefined") return evaluatedExpressionValue;
	if (["number", "boolean"].includes(parameterType)) return defaultValue;
	return null;
}
function shouldSkipParamValidation(parameter, value$1) {
	return typeof value$1 === "string" && value$1.includes("__CUSTOM_API_CALL__") || ["options", "multiOptions"].includes(parameter.type) && Boolean(parameter.allowArbitraryValues);
}
function createCommonNodeSettings(isExecutable, isTriggerNode, t) {
	const ret = [];
	if (isExecutable && !isTriggerNode) ret.push({
		displayName: t("nodeSettings.alwaysOutputData.displayName"),
		name: "alwaysOutputData",
		type: "boolean",
		default: false,
		noDataExpression: true,
		description: t("nodeSettings.alwaysOutputData.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.executeOnce.displayName"),
		name: "executeOnce",
		type: "boolean",
		default: false,
		noDataExpression: true,
		description: t("nodeSettings.executeOnce.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.retryOnFail.displayName"),
		name: "retryOnFail",
		type: "boolean",
		default: false,
		noDataExpression: true,
		description: t("nodeSettings.retryOnFail.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.maxTries.displayName"),
		name: "maxTries",
		type: "number",
		typeOptions: {
			minValue: 2,
			maxValue: 5
		},
		default: 3,
		displayOptions: { show: { retryOnFail: [true] } },
		noDataExpression: true,
		description: t("nodeSettings.maxTries.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.waitBetweenTries.displayName"),
		name: "waitBetweenTries",
		type: "number",
		typeOptions: {
			minValue: 0,
			maxValue: 5e3
		},
		default: 1e3,
		displayOptions: { show: { retryOnFail: [true] } },
		noDataExpression: true,
		description: t("nodeSettings.waitBetweenTries.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.onError.displayName"),
		name: "onError",
		type: "options",
		options: [
			{
				name: t("nodeSettings.onError.options.stopWorkflow.displayName"),
				value: "stopWorkflow",
				description: t("nodeSettings.onError.options.stopWorkflow.description")
			},
			{
				name: t("nodeSettings.onError.options.continueRegularOutput.displayName"),
				value: "continueRegularOutput",
				description: t("nodeSettings.onError.options.continueRegularOutput.description")
			},
			{
				name: t("nodeSettings.onError.options.continueErrorOutput.displayName"),
				value: "continueErrorOutput",
				description: t("nodeSettings.onError.options.continueErrorOutput.description")
			}
		],
		default: "stopWorkflow",
		description: t("nodeSettings.onError.description"),
		noDataExpression: true,
		isNodeSetting: true
	});
	ret.push({
		displayName: t("nodeSettings.notes.displayName"),
		name: "notes",
		type: "string",
		typeOptions: { rows: 5 },
		default: "",
		noDataExpression: true,
		description: t("nodeSettings.notes.description"),
		isNodeSetting: true
	}, {
		displayName: t("nodeSettings.notesInFlow.displayName"),
		name: "notesInFlow",
		type: "boolean",
		default: false,
		noDataExpression: true,
		description: t("nodeSettings.notesInFlow.description"),
		isNodeSetting: true
	});
	return ret;
}
function collectSettings(node$1, nodeSettings) {
	let ret = getNodeSettingsInitialValues();
	const foundNodeSettings = [];
	if (node$1.color) {
		foundNodeSettings.push("color");
		ret = {
			...ret,
			color: node$1.color
		};
	}
	if (node$1.notes) {
		foundNodeSettings.push("notes");
		ret = {
			...ret,
			notes: node$1.notes
		};
	}
	if (node$1.alwaysOutputData) {
		foundNodeSettings.push("alwaysOutputData");
		ret = {
			...ret,
			alwaysOutputData: node$1.alwaysOutputData
		};
	}
	if (node$1.executeOnce) {
		foundNodeSettings.push("executeOnce");
		ret = {
			...ret,
			executeOnce: node$1.executeOnce
		};
	}
	if (node$1.continueOnFail) {
		foundNodeSettings.push("onError");
		ret = {
			...ret,
			onError: "continueRegularOutput"
		};
	}
	if (node$1.onError) {
		foundNodeSettings.push("onError");
		ret = {
			...ret,
			onError: node$1.onError
		};
	}
	if (node$1.notesInFlow) {
		foundNodeSettings.push("notesInFlow");
		ret = {
			...ret,
			notesInFlow: node$1.notesInFlow
		};
	}
	if (node$1.retryOnFail) {
		foundNodeSettings.push("retryOnFail");
		ret = {
			...ret,
			retryOnFail: node$1.retryOnFail
		};
	}
	if (node$1.maxTries) {
		foundNodeSettings.push("maxTries");
		ret = {
			...ret,
			maxTries: node$1.maxTries
		};
	}
	if (node$1.waitBetweenTries) {
		foundNodeSettings.push("waitBetweenTries");
		ret = {
			...ret,
			waitBetweenTries: node$1.waitBetweenTries
		};
	}
	for (const nodeSetting of nodeSettings) if (!foundNodeSettings.includes(nodeSetting.name)) ret = {
		...ret,
		[nodeSetting.name]: nodeSetting.default
	};
	ret = {
		...ret,
		parameters: deepCopy(node$1.parameters)
	};
	return ret;
}
function collectParametersByTab(parameters, isEmbeddedInCanvas) {
	const ret = {
		settings: [],
		action: [],
		params: []
	};
	for (const item$2 of parameters) {
		if (item$2.isNodeSetting) {
			ret.settings.push(item$2);
			continue;
		}
		if (!isEmbeddedInCanvas) {
			ret.params.push(item$2);
			continue;
		}
		if (item$2.name === "resource" || item$2.name === "operation") {
			ret.action.push(item$2);
			continue;
		}
		ret.params.push(item$2);
	}
	return ret;
}
var import_get$4 = /* @__PURE__ */ __toESM(require_get());
var import_set = /* @__PURE__ */ __toESM(require_set());
function useNodeSettingsParameters() {
	const workflowsStore = useWorkflowsStore();
	const workflowState = injectWorkflowState();
	const nodeTypesStore = useNodeTypesStore();
	const telemetry = useTelemetry();
	const nodeHelpers = useNodeHelpers();
	const workflowHelpers = useWorkflowHelpers();
	const canvasOperations = useCanvasOperations();
	const externalHooks = useExternalHooks();
	function updateNodeParameter(nodeValues, parameterData, newValue, node$1, isToolNode) {
		const nodeTypeDescription = nodeTypesStore.getNodeType(node$1.type, node$1.typeVersion);
		if (!nodeTypeDescription) return;
		let nodeParameters = getNodeParameters(nodeTypeDescription.properties, node$1.parameters, false, false, node$1, nodeTypeDescription);
		const oldNodeParameters = Object.assign({}, nodeParameters);
		nodeParameters = deepCopy(nodeParameters);
		const parameterPath = updateParameterByPath(parameterData.name, newValue, nodeParameters, nodeTypeDescription, node$1.typeVersion);
		nodeParameters = getNodeParameters(nodeTypeDescription.properties, nodeParameters, true, false, node$1, nodeTypeDescription);
		if (isToolNode) {
			const updatedDescription = getUpdatedToolDescription(nodeTypeDescription, nodeParameters, node$1.parameters);
			if (updatedDescription && nodeParameters) nodeParameters.toolDescription = updatedDescription;
		}
		if (isDefaultNodeName(node$1.name, nodeTypeDescription, node$1.parameters ?? {})) {
			const newName = makeNodeName(nodeParameters ?? {}, nodeTypeDescription);
			if (!node$1.name.startsWith(newName)) setTimeout(async () => await canvasOperations.renameNode(node$1.name, newName));
		}
		for (const [key, value$1] of Object.entries(nodeParameters)) if (value$1 !== null && value$1 !== void 0) setValue(nodeValues, `parameters.${key}`, value$1);
		const updateInformation = {
			name: node$1.name,
			value: nodeParameters
		};
		const connections = workflowsStore.allConnections;
		const updatedConnections = updateDynamicConnections(node$1, connections, parameterData);
		if (updatedConnections) workflowsStore.setConnections(updatedConnections);
		workflowState.setNodeParameters(updateInformation);
		externalHooks.run("nodeSettings.valueChanged", {
			parameterPath,
			newValue,
			parameters: nodeTypeDescription.properties,
			oldNodeParameters
		});
		nodeHelpers.updateNodeParameterIssuesByName(node$1.name);
		nodeHelpers.updateNodeCredentialIssuesByName(node$1.name);
		telemetry.trackNodeParametersValuesChange(nodeTypeDescription.name, parameterData);
	}
	function handleFocus(node$1, path, parameter) {
		if (!node$1) return;
		const ndvStore = useNDVStore();
		useFocusPanelStore().openWithFocusedNodeParameter({
			nodeId: node$1.id,
			parameterPath: path,
			parameter
		});
		if (ndvStore.activeNode) {
			ndvStore.unsetActiveNodeName();
			ndvStore.resetNDVPushRef();
		}
	}
	function shouldDisplayNodeParameter(nodeParameters, node$1, parameter, path = "", displayKey = "displayOptions") {
		if (parameter.type === "hidden") return false;
		if (nodeHelpers.isCustomApiCallSelected(nodeParameters) && mustHideDuringCustomApiCall(parameter, nodeParameters)) return false;
		const nodeType = !node$1 ? null : nodeTypesStore.getNodeType(node$1.type, node$1.typeVersion);
		const shouldHideAuthRelatedParameter = isAuthRelatedParameter(getNodeAuthFields(nodeType), parameter);
		const mainNodeAuthField = getMainAuthField(nodeType);
		if (!KEEP_AUTH_IN_NDV_FOR_NODES.includes(node$1?.type ?? "") && mainNodeAuthField && (parameter.name === mainNodeAuthField.name || shouldHideAuthRelatedParameter)) return false;
		if (parameter[displayKey] === void 0) return true;
		const nodeParams = {};
		let rawValues = nodeParameters;
		if (path) rawValues = (0, import_get$4.default)(nodeParameters, path);
		if (!rawValues) return false;
		const resolveKeys = Object.keys(rawValues);
		let key;
		let i = 0;
		let parameterGotResolved = false;
		do {
			key = resolveKeys.shift();
			const value$1 = rawValues[key];
			if (typeof value$1 === "string" && value$1?.charAt(0) === "=") if (value$1.includes("$parameter") && resolveKeys.some((parameterName) => value$1.includes(parameterName))) {
				resolveKeys.push(key);
				continue;
			} else {
				try {
					nodeParams[key] = workflowHelpers.resolveExpression(value$1, nodeParams);
				} catch {
					nodeParams[key] = "";
				}
				parameterGotResolved = true;
			}
			else nodeParams[key] = rawValues[key];
			if (i++ > 50) break;
		} while (resolveKeys.length !== 0);
		if (parameterGotResolved) if (path) {
			rawValues = deepCopy(nodeParameters);
			(0, import_set.default)(rawValues, path, nodeParams);
			return nodeHelpers.displayParameter(rawValues, parameter, path, node$1, displayKey);
		} else return nodeHelpers.displayParameter(nodeParams, parameter, "", node$1, displayKey);
		return nodeHelpers.displayParameter(nodeParameters, parameter, path, node$1, displayKey);
	}
	return {
		setValue,
		shouldDisplayNodeParameter,
		updateParameterByPath,
		updateNodeParameter,
		handleFocus
	};
}
var CssEditor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CssEditor",
	props: {
		modelValue: {},
		rows: { default: 4 },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		fullscreen: {
			type: Boolean,
			default: false
		},
		targetNodeParameterContext: { default: void 0 }
	},
	emits: ["update:model-value"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const cssEditor = ref();
		const { editor: editorRef, readEditorValue, focus } = useExpressionEditor({
			editorRef: cssEditor,
			editorValue: ref(props.modelValue),
			extensions: computed(() => [
				bracketMatching(),
				n8nAutocompletion(),
				new LanguageSupport(cssLanguage, [cssLanguage.data.of({ closeBrackets: expressionCloseBracketsConfig }), n8nCompletionSources().map((source) => cssLanguage.data.of(source))]),
				expressionCloseBrackets(),
				Prec.highest(keymap.of(editorKeymap)),
				indentOnInput(),
				codeEditorTheme({
					isReadOnly: props.isReadOnly,
					maxHeight: props.fullscreen ? "100%" : "40vh",
					minHeight: "20vh",
					rows: props.rows
				}),
				lineNumbers(),
				highlightActiveLineGutter(),
				history(),
				foldGutter(),
				dropCursor(),
				indentOnInput(),
				highlightActiveLine(),
				mappingDropCursor()
			]),
			targetNodeParameterContext: props.targetNodeParameterContext,
			onChange: () => {
				emit("update:model-value", readEditorValue());
			}
		});
		async function onDrop(value$1, event) {
			if (!editorRef.value) return;
			await dropInExpressionEditor(toRaw(editorRef.value), event, value$1);
		}
		__expose({ focus });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.editor) }, [createVNode(DraggableTarget_default, {
				type: "mapping",
				disabled: _ctx.isReadOnly,
				onDrop
			}, {
				default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createBaseVNode("div", {
					ref_key: "cssEditor",
					ref: cssEditor,
					class: normalizeClass([_ctx.$style.fillHeight, {
						[_ctx.$style.activeDrop]: activeDrop$8,
						[_ctx.$style.droppable]: droppable$10
					}]),
					"data-test-id": "css-editor-container"
				}, null, 2)]),
				_: 1
			}, 8, ["disabled"]), renderSlot(_ctx.$slots, "suffix")], 2);
		};
	}
});
var CssEditor_vue_vue_type_style_index_0_lang_module_default = {
	editor: "_editor_1x7m4_123",
	fillHeight: "_fillHeight_1x7m4_130",
	droppable: "_droppable_1x7m4_134",
	activeDrop: "_activeDrop_1x7m4_140"
};
var CssEditor_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CssEditor_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CssEditor_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$16 = { key: 0 };
var InputNodeSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InputNodeSelect",
	props: {
		nodes: {},
		workflow: {},
		modelValue: {}
	},
	emits: ["update:model-value"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const workflowsStore = useWorkflowsStore();
		const nodeTypesStore = useNodeTypesStore();
		const ndvStore = useNDVStore();
		const selectedInputNode = computed(() => workflowsStore.getNodeByName(props.modelValue ?? ""));
		const selectedInputNodeType = computed(() => {
			const node$1 = selectedInputNode.value;
			if (!node$1) return null;
			return nodeTypesStore.getNodeType(node$1.type, node$1.typeVersion);
		});
		const inputNodes = computed(() => props.nodes?.map((node$1) => {
			const fullNode = workflowsStore.getNodeByName(node$1.name);
			if (!fullNode) return null;
			return {
				node: fullNode,
				type: nodeTypesStore.getNodeType(fullNode.type, fullNode.typeVersion),
				depth: node$1.depth
			};
		}).filter(isPresent) ?? []);
		const activeNode = computed(() => ndvStore.activeNode);
		const activeNodeType = computed(() => {
			const node$1 = activeNode.value;
			if (!node$1) return null;
			return nodeTypesStore.getNodeType(node$1.type, node$1.typeVersion);
		});
		const isMultiInputNode = computed(() => {
			const nodeType = activeNodeType.value;
			return nodeType !== null && nodeType.inputs.length > 1;
		});
		const connectedTo = (nodeName) => {
			const connections = ndvStore.ndvNodeInputNumber[nodeName];
			if (!connections) return "";
			if (connections.length === 1) return `Input ${ndvStore.ndvNodeInputNumber[nodeName]}`;
			return `Inputs ${ndvStore.ndvNodeInputNumber[nodeName].join(", ")}`;
		};
		function getMultipleNodesText(nodeName) {
			if (!nodeName || !isMultiInputNode.value || !activeNode.value || !activeNodeType.value?.inputNames) return "";
			const connectedInputs = (workflowsStore.connectionsByDestinationNode[activeNode.value.name].main || []).reduce((acc, node$1, index$1) => {
				if (node$1?.[0] && node$1[0].node === nodeName) return [...acc, index$1];
				return acc;
			}, []).map((inputIndex) => activeNodeType.value?.inputNames?.[inputIndex]);
			if (connectedInputs.length === 0) return "";
			return `(${connectedInputs.join(" & ")})`;
		}
		function title$2(nodeName, length = 30) {
			return truncate(nodeName, length);
		}
		function subtitle$1(nodeName, depth) {
			const multipleNodesText = getMultipleNodesText(nodeName);
			if (multipleNodesText) return multipleNodesText;
			return i18n$1.baseText("ndv.input.nodeDistance", { adjustToNumber: depth });
		}
		function onInputNodeChange(value$1) {
			emit("update:model-value", value$1);
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nSelect_default), {
				"model-value": _ctx.modelValue,
				"no-data-text": unref(i18n$1).baseText("ndv.input.noNodesFound"),
				placeholder: unref(i18n$1).baseText("ndv.input.parentNodes"),
				class: normalizeClass(_ctx.$style.select),
				teleported: "",
				size: "small",
				filterable: "",
				"data-test-id": "ndv-input-select",
				"onUpdate:modelValue": onInputNodeChange
			}, {
				prefix: withCtx(() => [createVNode(NodeIcon_default, {
					disabled: selectedInputNode.value?.disabled,
					"node-type": selectedInputNodeType.value,
					size: 14,
					shrink: false
				}, null, 8, ["disabled", "node-type"])]),
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(inputNodes.value, ({ node: node$1, type, depth }) => {
					return openBlock(), createBlock(unref(N8nOption_default), {
						key: node$1.name,
						value: node$1.name,
						class: normalizeClass([_ctx.$style.node, { [_ctx.$style.disabled]: node$1.disabled }]),
						label: `${title$2(node$1.name)} ${getMultipleNodesText(node$1.name)}`,
						"data-test-id": "ndv-input-option"
					}, {
						default: withCtx(() => [
							createVNode(NodeIcon_default, {
								disabled: node$1.disabled,
								"node-type": type,
								size: 14,
								shrink: false,
								class: normalizeClass(_ctx.$style.icon)
							}, null, 8, [
								"disabled",
								"node-type",
								"class"
							]),
							createBaseVNode("span", { class: normalizeClass(_ctx.$style.title) }, [createTextVNode(toDisplayString(title$2(node$1.name)) + " ", 1), node$1.disabled ? (openBlock(), createElementBlock("span", _hoisted_1$16, "(" + toDisplayString(unref(i18n$1).baseText("node.disabled")) + ")", 1)) : createCommentVNode("", true)], 2),
							createBaseVNode("span", { class: normalizeClass(_ctx.$style.subtitle) }, toDisplayString(connectedTo(node$1.name) ? connectedTo(node$1.name) : subtitle$1(node$1.name, depth)), 3)
						]),
						_: 2
					}, 1032, [
						"value",
						"class",
						"label"
					]);
				}), 128))]),
				_: 1
			}, 8, [
				"model-value",
				"no-data-text",
				"placeholder",
				"class"
			]);
		};
	}
});
var InputNodeSelect_vue_vue_type_style_index_0_lang_module_default = {
	select: "_select_13h9s_123",
	node: "_node_13h9s_132",
	icon: "_icon_13h9s_140",
	title: "_title_13h9s_144",
	disabled: "_disabled_13h9s_153",
	subtitle: "_subtitle_13h9s_157"
};
var InputNodeSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InputNodeSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InputNodeSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var _sfc_main = {};
var _hoisted_1$15 = {
	width: "112",
	height: "80",
	viewBox: "0 0 112 80",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	"xmlns:xlink": "http://www.w3.org/1999/xlink"
};
function _sfc_render(_ctx, _cache) {
	return openBlock(), createElementBlock("svg", _hoisted_1$15, _cache[0] || (_cache[0] = [createStaticVNode("<mask id=\"mask0_489_46042\" style=\"mask-type:alpha;\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"112\" height=\"80\"><rect width=\"112\" height=\"80\" fill=\"url(#paint0_linear_489_46042)\"></rect></mask><g mask=\"url(#mask0_489_46042)\"><rect x=\"-0.5\" width=\"112\" height=\"80\" fill=\"url(#pattern0)\" fill-opacity=\"0.6\"></rect></g><defs><pattern id=\"pattern0\" patternContentUnits=\"objectBoundingBox\" width=\"1\" height=\"1\"><use xlink:href=\"#image0_489_46042\" transform=\"scale(0.00357143 0.005)\"></use></pattern><linearGradient id=\"paint0_linear_489_46042\" x1=\"90.5\" y1=\"40.4494\" x2=\"112.5\" y2=\"40.4494\" gradientUnits=\"userSpaceOnUse\"><stop></stop><stop offset=\"1\" stop-color=\"white\" stop-opacity=\"0\"></stop></linearGradient><image id=\"image0_489_46042\" width=\"280\" height=\"200\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADICAYAAAAzx/4XAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABhdSURBVHgB7d0JcFTVngbw/72d4IYa0Ie4IK2llgpodNwtB9AaxVILF7ZxynkgWupojaRwASXQGEBqEAI8LXfBpZQS9IFabjMFkXFfijCKyqjQqIiKShCUpdP3vvPdpXP7pjtk6dPdSX+/qlPpJX07UfrL/yz3XEOIPJNiswaZkbKBtkiluC0qRB1gCJW86ntmjzYM81YvWIhyhgFTwlCxGJGyBcJKhTQxhUrSpJraKSpcVgjDhTQqEyo5U+6prbVExmV6TnWT6ixbnuxmSZ262xCLVTUIUTsxYEoMKpdM4aKCZV5ZUmIMFMoljsGUkMk1c9RArjE39HBchcuYadVVdUKUYwyYEjEhVhstj8gqdbMi8HA8kpTBqmqJC5EGHOQtEeVlMkXSw6WB4UK6cQymBKB6UYMso4OPWYZMrWG4kGasYEpAmWGHB3Xj0ydVzRUizRgwJcAwjaFpD9gyVYjygAHTxTndo9Bium2WLBWiPGDAdHFlkWT4/KK6uVzrQnnCgOniDNuIBu/blr1aiPKEAdPF2Xba1DQeYfVCecOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2hhCXc7ll19eUVZWNto0zYFGJDLIamys8J+LRMrilpWst217WSKRqFu6dGlciDRhwHQho0aNilqWVavC4/I2vGyhCpqpDBrSISLUJYwcOfJWFS6vq5vHS9tURiKRcf3795c1a9a8JUQ5xAqmk0N3qLy8/O/q5iDpIMMwlu7evXuMqmYahCgHOMjbyalwWSE5CBdA18o7HlFOsIvUiY0YMaJWfWnLeEtr9FbdpQrVXXpDiDqIXaROavjw4aPVlwWiiapmBi9ZsqROiDqAXaTOa4popMZjtIUXlQ4GTCfkVS9R0SvqvQ9RuzFgOqe/Sn7k632oi+IYTCfjTUtvkTxJJBI9OG1N7cUKppMpKyurlDzK9/tR18KA6Xzy+oG3LCsqRO3EgOl8KiSPTNOMClE7MWCISJsyIUcsVlvRGJEVhm3Nq5k8fqEUr3wPuHKAl9qNFYwnFqtqMND9MMwF1TW16yfXzLl1Qqw2KkXGtu245Fe9ELUTAybAaPprHbXFmFsekfXV02oX3BX7r6KZSUkmk3WSR42NjQwYajcGTIBl2aubPWjL6EikfJWqalZU3zN7tBSYtyalTvJAVUt1XANDHcExmDTofmRdezhIdZ8GqaCZYog9d3fSWDYzVhWXwnhScrRFQ0sMw3hSiDqAFUyAZUi8Fd9W8O5TIpFYqr7ERa/44sWLFwpRBzBggiJm28YbCtR9QrfFsqwq0WuqEHUQz0UKwFR1MiIdOc8nns/u01VXXTXXNM1bJcdUeM174YUXxglRBzFgQlQ1goDp+GpZQxYmGxPzZsTu0DYL4534iC0uc9lNq1ddo1OEKAfYRQoYpyoYI1djG6r7ZEbKF+CYogm6Smo8ZjA265YcwHFwPCHKkZKrYPCB31cSUTEjlaYtUSNi9rVtqTTcqiUqOWKLzCtLql5XrCov07zDhg2LqYBo9y53akq6asmSJXOFKIe6ZMDEYvdGG6W80jKNioiYJ6vfUs38qDBxA0T7yYJqNqpq+qSqvH9YceG1xsZGBE1bNorihddIm04ZMMEqJILAMFWI2E5wYCwiKoUTV0E2Zlp1VZ0UEIImmUwOUjeHRiKRSnU76j9nlpU1WI2NdapieUuF0UIupCOdijZgUIXslkhFhq5MVPRWIQ3tOb4KlnrVJboiVrjFdxlNmjo7ZphmqutkW9bUaVPGx4QoDwq6ktfvyhimEVV/W/uiKyNuFVKRVC110SbEoJ2zNGywMZ1sSL2dtLdahlFvGtKgwqEe4aCmqqNqqnp9Ww6Y7/EWos5Ca8Bk6cpExa1CoipEdJVQ6Ko0uCFibbAMM94tIvWSkPieQgAho6aqpbUKNd5C1Bl0OGCaDaiaUpHelSlv+mZbcimuWr1t2RvUoGbcNiSOKkQ91pCDSiIuex7LccZbVLjUhR5vT2bm9r8MUZHYY8CgCqmQnRVZujKpKiTVnclTV0b0QlBFsz2ZZbzFCH0N3w4dIo3Riu/Z0+NERScVMM5Je1nWhiRlb21dGcGHWQWHWLJahVVDa7syOjlVkZn5Nw6Nt4S/yQg0LGJECJ+n2nGqdVPtO9XeUW2lagnZw4+R4bYdeE8GDRW9VMCURcoX2PhA5HhA1WvNujLFNtsSZBjetg12+mfYErtq+uTx86QpQFIvkab/ZOgTnqlajWpniBssQY2qrVJtumornMOK9BQ3jE5XrY9q3VXbodo61d5U7TPVtgeO4QcNQ4aKWipgsNmS+qvdnnNaAl2ZtAHVhmIOkZbYKmCM9HCJJ3bvGjtz2sT/FffDv7e4/+3wTegl7lJtt3f/JHHD5VzVjH333Ve6deuGZfjYHU62b99eZts2gmS+ajHVvlZtjGqjVNsnw4+DkxkfVW2OapuF1Qx1IoExmBY3W1LPFV9XRhcracUjpulUMKq8WP3Lr1uGPzx/Gk6CPFu1gaqdrNrB4lYjP6n2iWr/p9pG1W5X7Z9UM4499li59NJL5ZRTTnFC5ssvv5Tly5fL+++/L7t370alMkO1TaqdYqr36969uxx44IG42Bm2xpStW7fK77//fqAKpPHiVkYIpR+897Wl5WBh6FDBNQWMaSJAFhZgQLXYGNbO5AZzn4gkLWv+199+O23xgr/tpR7/V9VuUK1fhtdcLW43BhXOaart07NnT5kzZ44MGTLECQxABTN06FAZM2aM1NfXI817oyFcEEbnn3++DBgwwAmZbdu2yTvvvCNvvPGGbN68WRVU9s3ijt9sFbdqOki1fcUNEoTfL9I0rhOsbogKJhUw06qrcEZuTs7K7exmzpy49a7qe8feWzPxKXErh39TrVq1ngiLCjWv1qNHD+ybggpDGhoasMtcf/X8ieJ9sC+88EI599xzU+ECuH3MMcfIyJEjETCpxw8++GCpqqqSa665RtCl8g0fPlzuuusuWbRoEaoZHOhKcSumY8Ttgh0pbjWD6ul/xJ39+i3wq7CKoYLinrzpUlPNM9xwwQAtQuM/VeuJILjgggucdvTRRzsVyTfffCPLli2T9957D1VHauD3zDPPdLpFYfvtt5+cdtppTpD8+eefzmP9+vWTgQMHpoULoAq69tpr5e2333a6S8r54obLaaHDXqTaNar9TbUnVPtVguGC8SSDBQ3lHwOmueA0MwZdMRN01D777COnnnqq1NTUON2ZIHRr7rzzTidkfAcddJBEIpHmB1cfdARV37595YsvvnAeQ0X0l7/8JeMPc8IJJ8ghhxwin3/+ObZU6KUe6uUfPxqNyo4dO2TdunXGzp07D1UP/4dq34hbiWJ2Cq8x8J4MGSoEbjjVJLhQLhgwGNB1xkVQuYTDBc444ww5++yz5YADDkg9tv/++zthkgnCChUQIITQ3cLxM8FxjjrqKCkvb1oRjdCZMWOGzJs3zxnnufrqq3ENaTyFMZ1LxR2ANv3fif0kKhRWMOnCC+XQMMDrjJ+EuzC+vfbay+n2YEB2zZo1zmP+1HQme++9t1OV+LdRwQTHasJQ7SBg1MyTc//mm2+W66+/3jk+xoHw3GuvvSabNm3CQfp4zRmLsdWkO+sWKhRWMJkFF9JhdsYZL9m4cWPWF5x++ulOpeGHSksBg0BCFwdQoWTrHvmOOOKIVAWDMBoxYkTq2KhcevXq5by3Zz9xK5iI83uoAEL3yKlibNYylF8MmHTh6sWfoXEGWT/99NPUwGwYxkMwJY1qA10m3M80BgPoEmGGqbKy0hkMRmsJxn4wOIxQwXuEAwlhhuDx74obMs7vkFRjMIwVKhR2kVzBpf7BbhICZr1qW5LJZA/MGK1du9ZZOBeGLs5ll13mTEPj9mGHHeaPizSDQBg8eLAzZoNqpn///tISjPvMmjVLNmzYIIMGDWr2PN4Hx/Eg1RAyTsBgkDdVubCzRHnGgMkcLH4Fg9vbxK1iBm7evNlZhZspYODII4902h7fUH3QES4ImdbA2M+wYcOcGSNUMpkEwsw/uT01yEtUKKXeRco0c4SG2ZgrVLtRtb+KNxGDBXXvvvsuVtZKvmEMBqGUrdsVkgpIO5k0/HMK2FWifCvlCiZT5YJp6RGqjVXtEO++3+Vwzg/CepS6ujpnlW2RMkKNqGBYwTRVLvuLe8byveIurouKGzKYkUktcME09EsvveSvrC16lhAVTqlWMMHqxe9O3CbuuT7OdMzxxx/vnAmNLsknn3wiK1eudNah7Nq1ywmZVatWZRxwLQScsrBz507/LjIFJz2ygqGCK+Uukj8Iiq/YcW6keOFyww03yN133+2sUcHgKaqV5557TqZOnepMU3/77bfO1gvFEjDougWmzxEuu4WoCJRiwGSaLbpANWdxyVlnnSUPPfRQ2gswuDp27Fhn1ezEiROdr63xww8/yPr16+Wcc85ptugOA8aYkcIpAlg3Ex68xZQ0zrg++eSTpU+fPi0O7qKCCXTZEC47hKgIlOoYTDBk8MnFMlhnqewll1yS8QVYeYvl+Y8++qjMnDnTmTZuCVb94gzp8847T6qrq9OeQxg888wzcvHFF8tNN90kL7/8ctrzv/zyi0yYMEGuvPJKufHGG+Wrr75q8b3QbcNrPOgrdY4BIurySrmCQbj660XKvcdSS/gzwXPXXXedtAbGabBXjG3bznYLQVjP8v333zu3f/vtN6fLFYSw2LJli1Mpff3119hms8X3QsD8+uuv/l30lRAwzsw0l2pTIZXav7/wJUX8CuYP8SZc8IHvTBBgCKA//vjDuStuBfO7EBWBUvwDF5xd8cdgUttNrlu3TjqTRCIh8Xg8dVfczaawCTnX1VHBlXIFHewqob/iBAy6NnYnOusYAYOBZA+ql58leOUBNQvGVXdUKFxo58In1Pmrj5W6GP/o8IEDs0aYRtYFa3NwlrcH/SR/TwlWMFRwpV7B+PChxEhrI3bzf/7556WjsGudHzLZtnjoKExPYzr7448/9h/CANL/S9OpR9gvk0FDBVPKARP84KHEeEu89SNPPPFEh09oxJYNfsDoqmAwsPvqq6/6U9T42dHVQ1Cmn9+In4NbNVABlGLAhK/57DcsRomrlvzoo4/kvvvuS21RWawwIP3444/7dzG4i8vMImgwI8YTqKngSi1ggpdd9ZvlNVwxEbvxO4tO8MFdunRpq1ft5hsGonH6gjfrhSTEJWhxWYNguLCLRAVV6l0kS9JD5lVxr87oLFybPXu2rFixQnINXSd/gygERXtCDCdfPvvss/5d9JH+W7Ufpel3SS20S80gsZtEeVaqXaRgwwCJ5X3FwMsDqq3CN+JcICzz/+CDDySXcF6Rv8UlBmrb2hVbvXq1cyVIbxNyTK9jqTACxgo1VjBUUKVawQS7R37I+A19DlwhcR0++NiWAdce+uyzzySXgicvtqWCQWU1efJk5+cS9+fHz/uCuDNIflimmmFGbFYuVCilXMH4H0L/Q9no3cbXD1Wbr9pm7LPyyiuvSG1tbcFX+SKIHnzwQXn99df9hzCw+4i4ewYHQ5KDvFQUSn0Mxg+a4IcTAYM+CwZfZqm2BetYsDYGlcN3333XqoMfeuihqbUwuMJAEK4qgEuXADb0Dp9giX1ounfv7rwWx8HF2QAXV3vssceCXaoHxb3o/W7v5/ZD0g9PB8dfqFBatYN0F5TppMdwQ/g0iLv0/sxEIlGOcEFFc+KJJ2a91KsPwYFrUGNnPGy5cPjhh6eewxoZvB7PY9OqK664wgkVHwIFe9DgciWjRo2Sk046yTkDe/z48c64kKdO3IDBVQ8QLAlJr8KcKmbg4Iv+WQXVoFTA2PZbK+verBOiPCjVHe0QHn6I+GMwqOYS3vP+SZAIl9dU66Vme67fsmVL+YIFC+Tnn3+W6dOnOxdZywZVysiRI51qI3ypEYy/IHjuuOOO8DWNUq+96KKLnMua4Htx//777xesz/HOk8Ks0Qxxt2VISnq4sItERaPUr4sUnk0KngDp38bWB4vFvUb1v2/durUcm36j4sBMznHHHZf14AiOcHgEZbvWNaDK8a9XjbGXxYsXC05j8Dyh2iZp6hZlC5emlbxEBVDKAROsYvzxiuAVHYMnIP+k2jOq7VIVxLXbt2/f++mnn3bOMbrttttkwIABohO23sSWDN5sE6qVl6SpagmHS7ARFVSpn02daU1MIktDyDyl2gMqZLbhPKCnnnpKbr/9dmeLh/ZAcNxyyy3Su3dv6devnzz88MPBKiUF2zFg1zoPRpl/C/1smWaQRNhFogLjpWObPoTBv/jB7pIEvqK7hDUn+LTfotoBb775pnOdJAziBi5Av0c//vijzJ8/Xx544AHn/k8//SRTpkxxFt5hn97gda2xQXjghMmNkh4o4XDh+AsVDW7Zmnm62p+V8S8BEqwWMLD6d9UeVu1nDLouX77cuYxJa2FbTgQTAsZ7b6e7g5BZtGiRfPjhh2lnYKN6CWyCtUOyj70EqxeigmPAuIJdinDQBMPGb9jg5RPVPseLsGQfVUZrYYOoWbNmOVPP4p5cWe8dy8a1r1ER4Zh+qIQueWJK5vEWW9g1oiLDLlKTTFPXRuh5/3vQsO2ds7k2LkPiX4wNMLUcvg4SwgLbW2ItDS7g5p16gLDCiU4LVTtBtR5qILcPVuuiizRkyBBnvQwqG7zWg+s3ZQsXdo2oqDBg0vkBgg+tXymINL9YW3DTcKfL88gjj8iLL77oBAMWygXHUABjK9iKEwHj7aGLY8dVW6baN+IO3PZW7SpVDVXgTO4lS5Y44zp4XWBXvL7e+zJYqOgxYJoLhox4t4NB4y/CA2clNFb34vrVbYBuF1IG+898JE1ncmO7CKzK+xd1zB5r167N1IXtJu51nFi9UNFjwGQWDhlfsILBtDVOisSJRPuGno9I8038cUzMPmHnf8wEYd+ZleKGjR8MOJtyobhbX1aqdqB3LASQf0lY7PD9hzBYqBNgwGQXDBm/e+QP/vrXUkIFgg98T0m/UmQ3aQqi4DQ4ggELXbBvrn/1xeDMD74f4YNFfW94x8WxEt7rMO6zSTKfDsCQoaLDgGlZeLVveJUvQgZBgS5LRJoCxsxwnEzbRPiDyb5gFwxVzEbJvAgwKaxgqBNgwLROOBwQMqb31YcP/Z4CxsrS/IDwqx5T0isgW9L3rOGCOuoUGDB7FuyCBM9bagw8jsf8cMk2/tJSwPiCYzzB2apM+9bwrGkqegyY1guGCzQGHiuTpqom05VagwETDppgQISnws0Mr/cXAPK8Iyp6DJjWC6/2Dd72181ASwETrmQyVR/h7SLCxwhu88kxGCpqDJjWCa/ytaR5WIR3xAu/Pjzj01LA7Cmk2DWiToEB03Z+mJiB28GAEckcMMHbVuhxO/S6TCHlf1+msGLQUFFiwLSeX8X4ty1pHiit2TouU7cmU8BI6Lad5StR0WLAtE0wCMKDs209RkvPtTY8GDJU1Bgw7WNnuW+04TVEXR4DJrcYIkQB3HCKiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBdnGFI2gWbjIjZV4jyhAHTxdmGHU9/QKJClCcMmC6uLBmpDz1UOS5W2/qLaBN1AAOmi4vFquLiXuDNV7GfaY0WojxgwJQA27KeDN43DXOoEOUBA6YElNnmwtBDg6rvmT1OiDRjwJQAdJNssdOqGDHMKRNitVEh0ogBUyLKkkZMfQlOWVeUR2QFQ4Z0YsCUCGew15CpoYejCJlJNbWDhEiDtmz1SF2ACpOY+p8+pdkThixMNMrUme6sE1FOMGBK0KSaOXMNMW7N8vRSNe20LGkl62fE7qgXog5gwJSorJUMUQ4xYEoYxl7UP4AF6mZUiDRgwJBU31M7Wv1LQDUTFaIcYsBQSmx6bWVjo3W5mOZAww2bqBB1wD8AobUpv0xPqN8AAAAASUVORK5CYII=\"></image></defs>", 3)]));
}
var WireMeUp_default = /* @__PURE__ */ __plugin_vue_export_helper_default(_sfc_main, [["render", _sfc_render]]);
var import_uniqBy = /* @__PURE__ */ __toESM(require_uniqBy());
var InputPanel_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InputPanel",
	props: {
		runIndex: {},
		workflowObject: {},
		pushRef: {},
		activeNodeName: {},
		currentNodeName: { default: "" },
		canLinkRuns: {
			type: Boolean,
			default: false
		},
		linkedRuns: { type: Boolean },
		readOnly: {
			type: Boolean,
			default: false
		},
		isProductionExecutionPreview: {
			type: Boolean,
			default: false
		},
		searchShortcut: { default: void 0 },
		displayMode: {},
		compact: { type: Boolean },
		disableDisplayModeSelection: { type: Boolean },
		focusedMappableInput: {},
		isMappingOnboarded: { type: Boolean },
		nodeNotRunMessageVariant: { default: "default" },
		truncateLimit: {}
	},
	emits: [
		"itemHover",
		"tableMounted",
		"linkRun",
		"unlinkRun",
		"runChange",
		"search",
		"changeInputNode",
		"execute",
		"activatePane",
		"displayModeChange"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const telemetry = useTelemetry();
		const showDraggableHintWithDelay = ref(false);
		const draggableHintShown = ref(false);
		const mappedNode$1 = ref(null);
		const collapsingColumnName = ref(null);
		const inputModes = [{
			value: "mapping",
			label: i18n$1.baseText("ndv.input.mapping")
		}, {
			value: "debugging",
			label: i18n$1.baseText("ndv.input.fromAI")
		}];
		const nodeTypesStore = useNodeTypesStore();
		const workflowsStore = useWorkflowsStore();
		const workflowState = injectWorkflowState();
		const posthogStore = usePostHog();
		const { runWorkflow } = useRunWorkflow({ router: useRouter() });
		const activeNode = computed(() => workflowsStore.getNodeByName(props.activeNodeName));
		const rootNode = computed(() => {
			if (!activeNode.value) return null;
			const findRootWithMainConnection = (nodeName) => {
				const children = props.workflowObject.getChildNodes(nodeName, "ALL");
				for (let i = children.length - 1; i >= 0; i--) {
					const childName = children[i];
					if (props.workflowObject.getParentNodes(childName, NodeConnectionTypes.Main).length > 0) return childName;
				}
				return null;
			};
			return findRootWithMainConnection(activeNode.value.name);
		});
		const hasRootNodeRun = computed(() => {
			return !!(rootNode.value && workflowsStore.getWorkflowExecution?.data?.resultData.runData[rootNode.value]);
		});
		const inputMode = ref(activeNode.value && workflowsStore.getWorkflowExecution?.data?.resultData.runData[activeNode.value.name] ? "debugging" : "mapping");
		const isMappingMode = computed(() => isActiveNodeConfig.value && inputMode.value === "mapping");
		const showDraggableHint = computed(() => {
			const toIgnore = [
				START_NODE_TYPE,
				MANUAL_TRIGGER_NODE_TYPE,
				CRON_NODE_TYPE,
				INTERVAL_NODE_TYPE
			];
			if (!currentNode.value || toIgnore.includes(currentNode.value.type)) return false;
			return !!props.focusedMappableInput && !props.isMappingOnboarded;
		});
		const isActiveNodeConfig = computed(() => {
			let inputs$1 = activeNodeType.value?.inputs ?? [];
			let outputs = activeNodeType.value?.outputs ?? [];
			if (props.workflowObject && activeNode.value) {
				const node$1 = props.workflowObject.getNode(activeNode.value.name);
				if (node$1 && activeNodeType.value) {
					inputs$1 = getNodeInputs(props.workflowObject, node$1, activeNodeType.value);
					outputs = getNodeOutputs(props.workflowObject, node$1, activeNodeType.value);
				}
			}
			if (!Array.isArray(inputs$1)) inputs$1 = [];
			if (!Array.isArray(outputs)) outputs = [];
			return inputs$1.length === 0 || inputs$1.every((input$5) => filterOutConnectionType(input$5, NodeConnectionTypes.Main)) && outputs.find((output$1) => filterOutConnectionType(output$1, NodeConnectionTypes.Main));
		});
		const isMappingEnabled = computed(() => {
			if (props.readOnly) return false;
			if (isActiveNodeConfig.value) return isMappingMode.value && mappedNode$1.value !== null;
			return true;
		});
		const isExecutingPrevious = computed(() => {
			if (!workflowsStore.isWorkflowRunning) return false;
			const triggeredNode = workflowsStore.executedNode;
			const executingNode = workflowState.executingNode.executingNode;
			if (activeNode.value && triggeredNode === activeNode.value.name && workflowState.executingNode.isNodeExecuting(props.currentNodeName)) return true;
			if (executingNode.length || triggeredNode) return !!parentNodes.value.find((node$1) => workflowState.executingNode.isNodeExecuting(node$1.name) || node$1.name === triggeredNode);
			return false;
		});
		const rootNodesParents = computed(() => {
			if (!rootNode.value) return [];
			return props.workflowObject.getParentNodesByDepth(rootNode.value);
		});
		const currentNode = computed(() => {
			if (isActiveNodeConfig.value) {
				if (mappedNode$1.value) return workflowsStore.getNodeByName(mappedNode$1.value);
				return activeNode.value;
			}
			return workflowsStore.getNodeByName(props.currentNodeName ?? "");
		});
		const connectedCurrentNodeOutputs = computed(() => {
			return parentNodes.value.find(({ name }) => name === props.currentNodeName)?.indicies;
		});
		const parentNodes = computed(() => {
			if (!activeNode.value) return [];
			return (0, import_uniqBy.default)(props.workflowObject.getParentNodesByDepth(activeNode.value.name).filter((parent$2) => parent$2.name !== activeNode.value?.name), (parent$2) => parent$2.name);
		});
		const currentNodeDepth = computed(() => {
			return parentNodes.value.find((parent$2) => currentNode.value && parent$2.name === currentNode.value.name)?.depth ?? -1;
		});
		const activeNodeType = computed(() => {
			if (!activeNode.value) return null;
			return nodeTypesStore.getNodeType(activeNode.value.type, activeNode.value.typeVersion);
		});
		const waitingMessage = computed(() => {
			const parentNode = parentNodes.value[0];
			return parentNode && waitingNodeTooltip(workflowsStore.getNodeByName(parentNode.name), props.workflowObject);
		});
		const isNDVV2 = computed(() => posthogStore.isVariantEnabled(NDV_UI_OVERHAUL_EXPERIMENT.name, NDV_UI_OVERHAUL_EXPERIMENT.variant));
		const nodeNameToExecute = computed(() => (isActiveNodeConfig.value ? rootNode.value : activeNode.value?.name) ?? "");
		watch(inputMode, (mode) => {
			onRunIndexChange(-1);
			if (mode === "mapping") {
				onUnlinkRun();
				mappedNode$1.value = rootNodesParents.value[0]?.name ?? null;
			} else mappedNode$1.value = null;
		}, { immediate: true });
		watch(showDraggableHint, (curr, prev) => {
			if (curr && !prev) setTimeout(() => {
				if (draggableHintShown.value) return;
				showDraggableHintWithDelay.value = showDraggableHint.value;
				if (showDraggableHintWithDelay.value) {
					draggableHintShown.value = true;
					telemetry.track("User viewed data mapping tooltip", { type: "unexecuted input pane" });
				}
			}, 1e3);
			else if (!curr) showDraggableHintWithDelay.value = false;
		});
		function filterOutConnectionType(item$2, type) {
			if (!item$2) return false;
			return typeof item$2 === "string" ? item$2 !== type : item$2.type !== type;
		}
		function onInputModeChange(val) {
			inputMode.value = val;
		}
		function onMappedNodeSelected(val) {
			mappedNode$1.value = val;
			onRunIndexChange(0);
			onUnlinkRun();
		}
		function onNodeExecute() {
			emit("execute");
			if (activeNode.value) telemetry.track("User clicked ndv button", {
				node_type: activeNode.value.type,
				workflow_id: workflowsStore.workflowId,
				push_ref: props.pushRef,
				pane: "input",
				type: "executePrevious"
			});
		}
		function onRunIndexChange(run) {
			emit("runChange", run);
		}
		function onLinkRun() {
			emit("linkRun");
		}
		function onUnlinkRun() {
			emit("unlinkRun");
		}
		function onSearch(search) {
			emit("search", search);
		}
		function onItemHover(item$2) {
			emit("itemHover", item$2);
		}
		function onTableMounted(event) {
			emit("tableMounted", event);
		}
		function onInputNodeChange(value$1) {
			emit("changeInputNode", value$1, parentNodes.value.findIndex((node$1) => node$1.name === value$1) + 1);
		}
		function onConnectionHelpClick() {
			if (activeNode.value) telemetry.track("User clicked ndv link", {
				node_type: activeNode.value.type,
				workflow_id: workflowsStore.workflowId,
				push_ref: props.pushRef,
				pane: "input",
				type: "not-connected-help"
			});
		}
		function activatePane() {
			emit("activatePane");
		}
		function handleChangeCollapsingColumn(columnName) {
			collapsingColumnName.value = columnName;
		}
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createBlock(RunData_default, {
				class: normalizeClass([_ctx.$style.runData, { [_ctx.$style.runDataV2]: isNDVV2.value }]),
				node: currentNode.value,
				nodes: isMappingMode.value ? rootNodesParents.value : parentNodes.value,
				"workflow-object": _ctx.workflowObject,
				"run-index": isMappingMode.value ? 0 : _ctx.runIndex,
				"linked-runs": _ctx.linkedRuns,
				"can-link-runs": !mappedNode$1.value && _ctx.canLinkRuns,
				"too-much-data-title": unref(i18n$1).baseText("ndv.input.tooMuchData.title"),
				"no-data-in-branch-message": unref(i18n$1).baseText("ndv.input.noOutputDataInBranch"),
				"is-executing": isExecutingPrevious.value,
				"executing-message": unref(i18n$1).baseText("ndv.input.executingPrevious"),
				"push-ref": _ctx.pushRef,
				"override-outputs": connectedCurrentNodeOutputs.value,
				"mapping-enabled": isMappingEnabled.value,
				"distance-from-active": currentNodeDepth.value,
				"is-production-execution-preview": _ctx.isProductionExecutionPreview,
				"search-shortcut": _ctx.searchShortcut,
				"display-mode": _ctx.displayMode,
				"pane-type": "input",
				"data-test-id": "ndv-input-panel",
				"disable-ai-content": true,
				"collapsing-table-column-name": collapsingColumnName.value,
				compact: _ctx.compact,
				"truncate-limit": _ctx.truncateLimit,
				"disable-display-mode-selection": _ctx.disableDisplayModeSelection,
				onActivatePane: activatePane,
				onItemHover,
				onLinkRun,
				onUnlinkRun,
				onRunChange: onRunIndexChange,
				onTableMounted,
				onSearch,
				onDisplayModeChange: _cache[3] || (_cache[3] = ($event) => emit("displayModeChange", $event)),
				onCollapsingTableColumnChanged: handleChangeCollapsingColumn
			}, createSlots({
				header: withCtx(() => [createBaseVNode("div", { class: normalizeClass([_ctx.$style.titleSection, { [_ctx.$style.titleSectionV2]: isNDVV2.value }]) }, [createVNode(unref(N8nText_default), {
					bold: true,
					color: "text-light",
					size: _ctx.compact ? "small" : "medium",
					class: normalizeClass([_ctx.$style.title, { [_ctx.$style.titleV2]: isNDVV2.value }])
				}, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("ndv.input")), 1)]),
					_: 1
				}, 8, ["size", "class"]), isActiveNodeConfig.value && !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nRadioButtons_default), {
					key: 0,
					"data-test-id": "input-panel-mode",
					options: inputModes,
					"model-value": inputMode.value,
					"onUpdate:modelValue": onInputModeChange
				}, null, 8, ["model-value"])) : createCommentVNode("", true)], 2)]),
				"input-select": withCtx(() => [parentNodes.value.length && _ctx.currentNodeName ? (openBlock(), createBlock(InputNodeSelect_default, {
					key: 0,
					"model-value": _ctx.currentNodeName,
					workflow: _ctx.workflowObject,
					nodes: parentNodes.value,
					"onUpdate:modelValue": onInputNodeChange
				}, null, 8, [
					"model-value",
					"workflow",
					"nodes"
				])) : createCommentVNode("", true)]),
				"node-not-run": withCtx(() => [isActiveNodeConfig.value && rootNode.value || parentNodes.value.length ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.noOutputData)
				}, [_ctx.nodeNotRunMessageVariant === "simple" ? (openBlock(), createBlock(NDVEmptyState_default, { key: 0 }, {
					default: withCtx(() => [createVNode(unref(I18nT), {
						scope: "global",
						keypath: "ndv.input.noOutputData.embeddedNdv.description"
					}, {
						link: withCtx(() => [createBaseVNode("a", {
							href: "#",
							onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(runWorkflow)({ destinationNode: _ctx.activeNodeName }), ["prevent"]))
						}, toDisplayString(unref(i18n$1).baseText("ndv.input.noOutputData.embeddedNdv.link")), 1)]),
						_: 1
					})]),
					_: 1
				})) : isNDVV2.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [_ctx.readOnly ? (openBlock(), createBlock(NDVEmptyState_default, {
					key: 0,
					title: unref(i18n$1).baseText("ndv.input.noOutputData.v2.title")
				}, null, 8, ["title"])) : isMappingEnabled.value || hasRootNodeRun.value ? (openBlock(), createBlock(NDVEmptyState_default, {
					key: 1,
					title: unref(i18n$1).baseText("ndv.input.noOutputData.v2.title"),
					icon: "arrow-right-to-line"
				}, {
					default: withCtx(() => [createVNode(unref(I18nT), {
						tag: "span",
						keypath: "ndv.input.noOutputData.v2.description",
						scope: "global"
					}, {
						link: withCtx(() => [createVNode(NodeExecuteButton_default, {
							"hide-icon": "",
							transparent: "",
							type: "secondary",
							"node-name": nodeNameToExecute.value,
							label: unref(i18n$1).baseText("ndv.input.noOutputData.v2.action"),
							tooltip: unref(i18n$1).baseText("ndv.input.noOutputData.v2.tooltip"),
							"tooltip-placement": "bottom",
							"telemetry-source": "inputs",
							"data-test-id": "execute-previous-node",
							onExecute: onNodeExecute
						}, null, 8, [
							"node-name",
							"label",
							"tooltip"
						]), _cache[5] || (_cache[5] = createBaseVNode("br", null, null, -1))]),
						_: 1
					})]),
					_: 1
				}, 8, ["title"])) : (openBlock(), createBlock(NDVEmptyState_default, {
					key: 2,
					title: unref(i18n$1).baseText("ndv.input.rootNodeHasNotRun.title")
				}, {
					icon: withCtx(() => _cache[6] || (_cache[6] = [createBaseVNode("svg", {
						width: "16px",
						viewBox: "0 0 16 14",
						fill: "none",
						xmlns: "http://www.w3.org/2000/svg"
					}, [createBaseVNode("path", {
						d: "M11 2C10.4375 2 10 1.5625 10 1C10 0.46875 10.4375 0 11 0H13C14.6562 0 16 1.34375 16 3V11C16 12.6562 14.6562 14 13 14H11C10.4375 14 10 13.5625 10 13C10 12.4688 10.4375 12 11 12H13C13.5312 12 14 11.5625 14 11V3C14 2.46875 13.5312 2 13 2H11ZM10.6875 7.71875L6.6875 11.7188C6.3125 12.125 5.65625 12.125 5.28125 11.7188C4.875 11.3438 4.875 10.6875 5.28125 10.3125L7.5625 8H1C0.4375 8 0 7.5625 0 7C0 6.46875 0.4375 6 1 6H7.5625L5.28125 3.71875C4.875 3.34375 4.875 2.6875 5.28125 2.3125C5.65625 1.90625 6.3125 1.90625 6.6875 2.3125L10.6875 6.3125C11.0938 6.6875 11.0938 7.34375 10.6875 7.71875Z",
						fill: "currentColor"
					})], -1)])),
					default: withCtx(() => [createVNode(unref(I18nT), {
						tag: "span",
						keypath: "ndv.input.rootNodeHasNotRun.description",
						scope: "global"
					}, {
						link: withCtx(() => [createBaseVNode("a", {
							href: "#",
							"data-test-id": "switch-to-mapping-mode-link",
							onClick: _cache[1] || (_cache[1] = withModifiers(($event) => onInputModeChange("mapping"), ["prevent"]))
						}, toDisplayString(unref(i18n$1).baseText("ndv.input.rootNodeHasNotRun.description.link")), 1)]),
						_: 1
					})]),
					_: 1
				}, 8, ["title"]))], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
					isMappingEnabled.value || hasRootNodeRun.value ? (openBlock(), createBlock(NDVEmptyState_default, {
						key: 0,
						title: unref(i18n$1).baseText("ndv.input.noOutputData.title")
					}, null, 8, ["title"])) : (openBlock(), createBlock(NDVEmptyState_default, {
						key: 1,
						title: unref(i18n$1).baseText("ndv.input.rootNodeHasNotRun.title")
					}, {
						default: withCtx(() => [createVNode(unref(I18nT), {
							tag: "span",
							keypath: "ndv.input.rootNodeHasNotRun.description",
							scope: "global"
						}, {
							link: withCtx(() => [createBaseVNode("a", {
								href: "#",
								"data-test-id": "switch-to-mapping-mode-link",
								onClick: _cache[2] || (_cache[2] = withModifiers(($event) => onInputModeChange("mapping"), ["prevent"]))
							}, toDisplayString(unref(i18n$1).baseText("ndv.input.rootNodeHasNotRun.description.link")), 1)]),
							_: 1
						})]),
						_: 1
					}, 8, ["title"])),
					!_ctx.readOnly ? (openBlock(), createBlock(NodeExecuteButton_default, {
						key: 2,
						type: "secondary",
						"hide-icon": "",
						transparent: true,
						"node-name": nodeNameToExecute.value,
						label: unref(i18n$1).baseText("ndv.input.noOutputData.executePrevious"),
						class: "mt-m",
						"telemetry-source": "inputs",
						"data-test-id": "execute-previous-node",
						"tooltip-placement": "bottom",
						"show-loading-spinner": false,
						onExecute: onNodeExecute
					}, createSlots({ _: 2 }, [showDraggableHint.value && showDraggableHintWithDelay.value ? {
						name: "persistentTooltipContent",
						fn: withCtx(() => [withDirectives(createBaseVNode("div", null, null, 512), [[_directive_n8n_html, unref(i18n$1).baseText("dataMapping.dragFromPreviousHint", { interpolate: { name: _ctx.focusedMappableInput } })]])]),
						key: "0"
					} : void 0]), 1032, ["node-name", "label"])) : createCommentVNode("", true),
					!_ctx.readOnly ? (openBlock(), createBlock(unref(N8nText_default), {
						key: 3,
						tag: "div",
						size: "small"
					}, {
						default: withCtx(() => [createVNode(unref(I18nT), {
							keypath: "ndv.input.noOutputData.hint",
							scope: "global"
						}, {
							info: withCtx(() => [createVNode(unref(N8nTooltip_default), { placement: "bottom" }, {
								content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("ndv.input.noOutputData.hint.tooltip")), 1)]),
								default: withCtx(() => [createVNode(unref(N8nIcon_default), { icon: "circle-help" })]),
								_: 1
							})]),
							_: 1
						})]),
						_: 1
					})) : createCommentVNode("", true)
				], 64))], 2)) : (openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(_ctx.$style.notConnected)
				}, [isNDVV2.value ? (openBlock(), createBlock(NDVEmptyState_default, {
					key: 0,
					title: unref(i18n$1).baseText("ndv.input.notConnected.v2.title")
				}, {
					icon: withCtx(() => [createVNode(WireMeUp_default)]),
					description: withCtx(() => [createVNode(unref(I18nT), {
						tag: "span",
						keypath: "ndv.input.notConnected.v2.description",
						scope: "global"
					}, {
						link: withCtx(() => [createBaseVNode("a", {
							href: "https://docs.n8n.io/workflows/connections/",
							target: "_blank",
							onClick: onConnectionHelpClick
						}, toDisplayString(unref(i18n$1).baseText("ndv.input.notConnected.learnMore")), 1)]),
						_: 1
					})]),
					_: 1
				}, 8, ["title"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
					createBaseVNode("div", null, [createVNode(WireMeUp_default)]),
					createVNode(unref(N8nText_default), {
						tag: "div",
						bold: true,
						color: "text-dark",
						size: "large"
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("ndv.input.notConnected.title")), 1)]),
						_: 1
					}),
					createVNode(unref(N8nText_default), { tag: "div" }, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("ndv.input.notConnected.message")) + " ", 1), createBaseVNode("a", {
							href: "https://docs.n8n.io/workflows/connections/",
							target: "_blank",
							onClick: onConnectionHelpClick
						}, toDisplayString(unref(i18n$1).baseText("ndv.input.notConnected.learnMore")), 1)]),
						_: 1
					})
				], 64))], 2))]),
				"node-waiting": withCtx(() => [createVNode(NDVEmptyState_default, {
					title: unref(i18n$1).baseText("ndv.output.waitNodeWaiting.title"),
					wide: ""
				}, {
					default: withCtx(() => [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, waitingMessage.value]])]),
					_: 1
				}, 8, ["title"])]),
				"no-output-data": withCtx(() => [createVNode(NDVEmptyState_default, { title: unref(i18n$1).baseText("ndv.input.noOutputData") }, null, 8, ["title"])]),
				"recovered-artificial-output-data": withCtx(() => [createVNode(NDVEmptyState_default, { title: unref(i18n$1).baseText("executionDetails.executionFailed.recoveredNodeTitle") }, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("executionDetails.executionFailed.recoveredNodeMessage")), 1)]),
					_: 1
				}, 8, ["title"])]),
				_: 2
			}, [isMappingMode.value ? {
				name: "before-data",
				fn: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent("style"), null, {
					default: withCtx(() => _cache[4] || (_cache[4] = [createTextVNode("button.linkRun { display: none }")])),
					_: 1
				})), createBaseVNode("div", { class: normalizeClass(_ctx.$style.mappedNode) }, [createVNode(InputNodeSelect_default, {
					"model-value": mappedNode$1.value,
					workflow: _ctx.workflowObject,
					nodes: rootNodesParents.value,
					"onUpdate:modelValue": onMappedNodeSelected
				}, null, 8, [
					"model-value",
					"workflow",
					"nodes"
				])], 2)]),
				key: "0"
			} : void 0]), 1032, [
				"class",
				"node",
				"nodes",
				"workflow-object",
				"run-index",
				"linked-runs",
				"can-link-runs",
				"too-much-data-title",
				"no-data-in-branch-message",
				"is-executing",
				"executing-message",
				"push-ref",
				"override-outputs",
				"mapping-enabled",
				"distance-from-active",
				"is-production-execution-preview",
				"search-shortcut",
				"display-mode",
				"collapsing-table-column-name",
				"compact",
				"truncate-limit",
				"disable-display-mode-selection"
			]);
		};
	}
});
var InputPanel_vue_vue_type_style_index_0_lang_module_default = {
	runData: "_runData_ukwlv_123",
	runDataV2: "_runDataV2_ukwlv_127",
	mappedNode: "_mappedNode_ukwlv_131",
	titleSection: "_titleSection_ukwlv_135",
	titleSectionV2: "_titleSectionV2_ukwlv_144",
	inputModeTab: "_inputModeTab_ukwlv_148",
	noOutputData: "_noOutputData_ukwlv_152",
	notConnected: "_notConnected_ukwlv_159",
	title: "_title_ukwlv_135",
	titleV2: "_titleV2_ukwlv_174",
	executeButton: "_executeButton_ukwlv_179"
};
var InputPanel_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InputPanel_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InputPanel_vue_vue_type_style_index_0_lang_module_default }]]);
var ExperimentalEmbeddedNdvMapper_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ExperimentalEmbeddedNdvMapper",
	props: {
		workflow: {},
		node: {},
		inputNodeName: {},
		visibleOnHover: {
			type: Boolean,
			default: false
		},
		reference: {}
	},
	setup(__props) {
		const hoverOptions = { delayLeave: 200 };
		const state = ref({ isOpen: false });
		const contentRef = useTemplateRef("content");
		const ndvStore = useNDVStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const contentElRef = computed(() => contentRef.value?.$el ?? null);
		const { APP_Z_INDEXES } = useStyles();
		const isReferenceHovered = useElementHover(__props.visibleOnHover ? __props.reference : null, hoverOptions);
		const isMapperHovered = useElementHover(__props.visibleOnHover ? contentElRef : null, hoverOptions);
		const isHovered = computed(() => isReferenceHovered.value || isMapperHovered.value);
		function handleFocusIn() {
			if (experimentalNdvStore.isMapperOpen) return;
			state.value = {
				isOpen: true,
				closeOnMouseLeave: false
			};
		}
		function handleReferenceFocusOut(event) {
			if (isEventTargetContainedBy(event.target, __props.reference) || isEventTargetContainedBy(event.target, contentElRef) || isEventTargetContainedBy(event.relatedTarget, contentElRef)) return;
			state.value = { isOpen: false };
		}
		watch(isHovered, (hovered) => {
			if (!__props.visibleOnHover || state.value.isOpen && !state.value.closeOnMouseLeave || experimentalNdvStore.isMapperOpen) return;
			state.value = hovered ? {
				isOpen: true,
				closeOnMouseLeave: true
			} : { isOpen: false };
		});
		watch(state, (value$1) => {
			experimentalNdvStore.setMapperOpen(value$1.isOpen && !value$1.closeOnMouseLeave);
		}, { immediate: true });
		onBeforeUnmount(() => {
			experimentalNdvStore.setMapperOpen(false);
		});
		useEventListener(__props.reference, "focusin", handleFocusIn);
		useEventListener(__props.reference, "focusout", handleReferenceFocusOut);
		useEventListener(contentElRef, "focusin", handleFocusIn);
		onClickOutside(contentElRef, handleReferenceFocusOut);
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nPopoverReka_default), {
				open: state.value.isOpen,
				side: "left",
				"side-flip": false,
				align: "start",
				width: "360px",
				"max-height": `calc(100vh - var(--spacing--sm) * 2)`,
				reference: _ctx.reference,
				"suppress-auto-focus": true,
				"z-index": unref(APP_Z_INDEXES).NDV + 1,
				"content-class": "ignore-key-press-canvas ignore-key-press-node-creator"
			}, {
				content: withCtx(() => [createVNode(InputPanel_default, {
					ref: "content",
					tabindex: -1,
					class: normalizeClass(_ctx.$style.inputPanel),
					"workflow-object": _ctx.workflow,
					"run-index": 0,
					compact: "",
					"push-ref": "",
					"display-mode": "schema",
					"disable-display-mode-selection": "",
					"active-node-name": _ctx.node.name,
					"current-node-name": _ctx.inputNodeName,
					"is-mapping-onboarded": unref(ndvStore).isMappingOnboarded,
					"focused-mappable-input": unref(ndvStore).focusedMappableInput,
					"node-not-run-message-variant": "simple",
					"truncate-limit": 60,
					"search-shortcut": "ctrl+f"
				}, null, 8, [
					"class",
					"workflow-object",
					"active-node-name",
					"current-node-name",
					"is-mapping-onboarded",
					"focused-mappable-input"
				])]),
				_: 1
			}, 8, [
				"open",
				"reference",
				"z-index"
			]);
		};
	}
});
var ExperimentalEmbeddedNdvMapper_vue_vue_type_style_index_0_lang_module_default = {
	inputPanel: "_inputPanel_kwzrz_123",
	inputPanelTitle: "_inputPanelTitle_kwzrz_130"
};
var ExperimentalEmbeddedNdvMapper_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ExperimentalEmbeddedNdvMapper_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ExperimentalEmbeddedNdvMapper_vue_vue_type_style_index_0_lang_module_default }]]);
var import_get$3 = /* @__PURE__ */ __toESM(require_get());
var _hoisted_1$14 = ["data-parameter-path"];
var _hoisted_2$6 = { key: 3 };
var _hoisted_3$6 = { class: "ignore-key-press-canvas code-edit-dialog" };
var _hoisted_4$5 = { class: "list-option" };
var _hoisted_5$3 = {
	key: 0,
	class: "option-description"
};
var _hoisted_6$2 = { class: "list-option" };
var _hoisted_7 = { class: "option-headline" };
var _hoisted_8 = {
	key: 0,
	class: "option-description"
};
var ParameterInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterInput",
	props: {
		parameter: {},
		path: {},
		modelValue: { type: [
			String,
			Number,
			Boolean,
			null,
			Object,
			Array
		] },
		eventBus: { default: () => createEventBus() },
		label: { default: () => ({ size: "small" }) },
		additionalExpressionData: { default: () => ({}) },
		rows: { default: 5 },
		hint: { default: void 0 },
		inputSize: { default: void 0 },
		eventSource: { default: void 0 },
		expressionEvaluated: {},
		documentationUrl: { default: void 0 },
		isAssignment: {
			type: Boolean,
			default: false
		},
		isReadOnly: {
			type: Boolean,
			default: false
		},
		hideLabel: { type: Boolean },
		droppable: { type: Boolean },
		activeDrop: { type: Boolean },
		forceShowExpression: { type: Boolean },
		hideIssues: { type: Boolean },
		errorHighlight: { type: Boolean },
		isForCredential: { type: Boolean },
		canBeOverridden: { type: Boolean }
	},
	emits: [
		"focus",
		"blur",
		"drop",
		"textInput",
		"update"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const externalHooks = useExternalHooks();
		const i18n$1 = useI18n();
		const nodeHelpers = useNodeHelpers();
		const { debounce: debounce$4 } = useDebounce();
		const workflowHelpers = useWorkflowHelpers();
		const nodeSettingsParameters = useNodeSettingsParameters();
		const telemetry = useTelemetry();
		const credentialsStore = useCredentialsStore();
		const ndvStore = useNDVStore();
		const workflowsStore = useWorkflowsStore();
		const workflowState = injectWorkflowState();
		const settingsStore = useSettingsStore();
		const nodeTypesStore = useNodeTypesStore();
		const uiStore = useUIStore();
		const focusPanelStore = useFocusPanelStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const projectsStore = useProjectsStore();
		const expressionLocalResolveCtx = inject(ExpressionLocalResolveContextSymbol, void 0);
		const inputField$2 = ref();
		const wrapper$3 = ref();
		const nodeName = ref("");
		const codeEditDialogVisible = ref(false);
		const expressionEditDialogVisible = ref(false);
		const remoteParameterOptions = ref([]);
		const remoteParameterOptionsLoading = ref(false);
		const remoteParameterOptionsLoadingIssues = ref(null);
		const textEditDialogVisible = ref(false);
		const editDialogClosing = ref(false);
		const tempValue = ref("");
		const activeCredentialType = ref("");
		const dateTimePickerOptions = ref({ shortcuts: [
			{
				text: "Today",
				onClick(picker) {
					picker.$emit("pick", /* @__PURE__ */ new Date());
				}
			},
			{
				text: "Yesterday",
				onClick(picker) {
					const date = /* @__PURE__ */ new Date();
					date.setTime(date.getTime() - 3600 * 1e3 * 24);
					picker.$emit("pick", date);
				}
			},
			{
				text: "A week ago",
				onClick(picker) {
					const date = /* @__PURE__ */ new Date();
					date.setTime(date.getTime() - 3600 * 1e3 * 24 * 7);
					picker.$emit("pick", date);
				}
			}
		] });
		const isFocused = ref(false);
		const contextNode = expressionLocalResolveCtx?.value?.workflow.getNode(expressionLocalResolveCtx.value.nodeName);
		const node$1 = computed(() => contextNode ?? ndvStore.activeNode ?? void 0);
		const nodeType = computed(() => node$1.value && nodeTypesStore.getNodeType(node$1.value.type, node$1.value.typeVersion));
		const shortPath = computed(() => {
			const short = props.path.split(".");
			short.shift();
			return short.join(".");
		});
		function getTypeOption(optionName) {
			return getParameterTypeOption(props.parameter, optionName);
		}
		const isModelValueExpression = computed(() => isValueExpression(props.parameter, props.modelValue));
		const isResourceLocatorParameter = computed(() => {
			return isResourceLocatorParameterType(props.parameter.type);
		});
		const isSecretParameter = computed(() => {
			return getTypeOption("password") === true;
		});
		const hasRemoteMethod = computed(() => {
			return !!getTypeOption("loadOptionsMethod") || !!getTypeOption("loadOptions");
		});
		const parameterOptions = computed(() => {
			const safeOptions = ((hasRemoteMethod.value ? remoteParameterOptions.value : props.parameter.options) ?? []).filter(isValidParameterOption);
			if (props.parameter.name === "language") if (settingsStore.isNativePythonRunnerEnabled) return safeOptions.filter((o) => o.value !== "python");
			else return safeOptions.filter((o) => o.value !== "pythonNative");
			return getParameterDisplayableOptions(safeOptions, ndvStore.activeNode);
		});
		const modelValueString = computed(() => {
			return props.modelValue;
		});
		const modelValueResourceLocator = computed(() => {
			return props.modelValue;
		});
		const modelValueExpressionEdit = computed(() => {
			return isResourceLocatorParameter.value && typeof props.modelValue !== "string" ? props.modelValue ? props.modelValue.value : "" : props.modelValue;
		});
		const editorRows = computed(() => getTypeOption("rows"));
		const editorType = computed(() => {
			return getTypeOption("editor");
		});
		const editorIsReadOnly = computed(() => {
			return getTypeOption("editorIsReadOnly") ?? false;
		});
		const editorLanguage = computed(() => {
			if (editorType.value === "json" || props.parameter.type === "json") return "json";
			if (node$1.value?.parameters?.language === "pythonNative") return "pythonNative";
			return getTypeOption("editorLanguage") ?? "javaScript";
		});
		const codeEditorMode = computed(() => {
			return node$1.value?.parameters.mode;
		});
		const displayValue = computed(() => {
			if (remoteParameterOptionsLoadingIssues.value) {
				if (!nodeType.value || nodeType.value?.codex?.categories?.includes("Core Nodes")) return i18n$1.baseText("parameterInput.loadOptionsError");
				if (nodeType.value?.credentials && nodeType.value?.credentials?.length > 0) {
					if ((nodeType.value?.credentials[0]).required && !node$1.value?.credentials) return i18n$1.baseText("parameterInput.loadOptionsCredentialsRequired");
				}
				return i18n$1.baseText("parameterInput.loadOptionsErrorService", { interpolate: { service: nodeType.value.displayName } });
			}
			if (remoteParameterOptionsLoading.value) return i18n$1.baseText("parameterInput.loadingOptions");
			if (props.modelValue === "__n8n_EMPTY_VALUE_7b1af746-3729-4c60-9b9b-e08eb29e58da") return "";
			let returnValue;
			if (!isModelValueExpression.value) returnValue = isResourceLocatorParameter.value ? isResourceLocatorValue(props.modelValue) ? props.modelValue.value : "" : props.modelValue;
			else returnValue = props.expressionEvaluated;
			if (props.parameter.type === "credentialsSelect" && typeof props.modelValue === "string") {
				const credType = credentialsStore.getCredentialTypeByName(props.modelValue);
				if (credType) returnValue = credType.displayName;
			}
			if (Array.isArray(returnValue) && props.parameter.type === "color" && getTypeOption("showAlpha") === true && returnValue.charAt(0) === "#") {
				const bigint = parseInt(returnValue.slice(1), 16);
				const h$1 = [];
				h$1.push(bigint >> 24 & 255);
				h$1.push(bigint >> 16 & 255);
				h$1.push(bigint >> 8 & 255);
				h$1.push((255 - bigint & 255) / 255);
				returnValue = "rgba(" + h$1.join() + ")";
			}
			if (returnValue !== void 0 && returnValue !== null && props.parameter.type === "string") {
				const rows = editorRows.value;
				if (rows === void 0 || rows === 1) returnValue = returnValue.toString().replace(/\n/, "|");
			}
			return returnValue;
		});
		const expressionDisplayValue = computed(() => {
			if (props.forceShowExpression) return "";
			const value$1 = isResourceLocatorValue(props.modelValue) ? props.modelValue.value : props.modelValue;
			if (typeof value$1 === "string" && value$1.startsWith("=")) return value$1.slice(1);
			return `${displayValue.value ?? ""}`;
		});
		const dependentParametersValues = computed(() => {
			const loadOptionsDependsOn = getTypeOption("loadOptionsDependsOn");
			if (loadOptionsDependsOn === void 0) return null;
			const currentNodeParameters = ndvStore.activeNode?.parameters;
			try {
				const resolvedNodeParameters = workflowHelpers.resolveParameter(currentNodeParameters);
				const returnValues = [];
				for (let parameterPath of loadOptionsDependsOn) {
					parameterPath = resolveRelativePath(props.path, parameterPath);
					returnValues.push((0, import_get$3.default)(resolvedNodeParameters, parameterPath));
				}
				return returnValues.join("|");
			} catch {
				return null;
			}
		});
		const getStringInputType = computed(() => {
			if (getTypeOption("password") === true) return "password";
			const rows = editorRows.value;
			if (rows !== void 0 && rows > 1) return "textarea";
			if (editorType.value === "code") return "textarea";
			return "text";
		});
		const getIssues = computed(() => {
			if (props.hideIssues || !node$1.value) return [];
			const newPath = shortPath.value.split(".");
			newPath.pop();
			const issues = getParameterIssues(props.parameter, node$1.value.parameters, newPath.join("."), node$1.value, nodeTypesStore.getNodeType(node$1.value.type, node$1.value.typeVersion));
			if (props.parameter.type === "credentialsSelect" && displayValue.value === "") {
				issues.parameters = issues.parameters ?? {};
				const issue = i18n$1.baseText("parameterInput.selectACredentialTypeFromTheDropdown");
				issues.parameters[props.parameter.name] = [issue];
			} else if (["options", "multiOptions"].includes(props.parameter.type) && !remoteParameterOptionsLoading.value && remoteParameterOptionsLoadingIssues.value === null && parameterOptions.value && (!isModelValueExpression.value || props.expressionEvaluated !== null)) {
				const validOptions = parameterOptions.value.map((options$1) => options$1.value);
				let checkValues = [];
				if (!shouldSkipParamValidation(props.parameter, displayValue.value)) if (Array.isArray(displayValue.value)) checkValues = checkValues.concat(displayValue.value);
				else checkValues.push(displayValue.value);
				for (const checkValue of checkValues) if (checkValue === null || !validOptions.includes(checkValue)) {
					issues.parameters = issues.parameters ?? {};
					const issue = i18n$1.baseText("parameterInput.theValueIsNotSupported", { interpolate: { checkValue } });
					issues.parameters[props.parameter.name] = [issue];
				}
			} else if (remoteParameterOptionsLoadingIssues.value !== null && !isModelValueExpression.value) {
				issues.parameters = issues.parameters ?? {};
				issues.parameters[props.parameter.name] = [`There was a problem loading the parameter options from server: "${remoteParameterOptionsLoadingIssues.value}"`];
			} else if (props.parameter.type === "workflowSelector") {
				const selected$1 = modelValueResourceLocator.value?.value;
				if (selected$1) {
					if (workflowsStore.allWorkflows.some((resource) => resource.id === selected$1 && resource.isArchived)) {
						issues.parameters = issues.parameters ?? {};
						const issue = i18n$1.baseText("parameterInput.selectedWorkflowIsArchived");
						issues.parameters[props.parameter.name] = [issue];
					}
				}
			}
			if (issues?.parameters?.[props.parameter.name] !== void 0) return issues.parameters[props.parameter.name];
			return [];
		});
		const displayTitle = computed(() => {
			const interpolation = { interpolate: { shortPath: shortPath.value } };
			if (getIssues.value.length && isModelValueExpression.value) return i18n$1.baseText("parameterInput.parameterHasIssuesAndExpression", interpolation);
			else if (getIssues.value.length && !isModelValueExpression.value) return i18n$1.baseText("parameterInput.parameterHasIssues", interpolation);
			else if (!getIssues.value.length && isModelValueExpression.value) return i18n$1.baseText("parameterInput.parameterHasExpression", interpolation);
			return i18n$1.baseText("parameterInput.parameter", interpolation);
		});
		const displayIssues = computed(() => props.parameter.type !== "credentialsSelect" && !isResourceLocatorParameter.value && getIssues.value.length > 0);
		const isSwitch = computed(() => props.parameter.type === "boolean" && !isModelValueExpression.value);
		const isTextarea = computed(() => props.parameter.type === "string" && editorRows.value !== void 0);
		const parameterInputClasses = computed(() => {
			const classes = {
				droppable: props.droppable,
				activeDrop: props.activeDrop
			};
			if (isSwitch.value) classes["parameter-switch"] = true;
			else classes["parameter-value-container"] = true;
			if (!props.droppable && !props.activeDrop && (getIssues.value.length > 0 || props.errorHighlight) && !isModelValueExpression.value) classes["has-issues"] = true;
			return classes;
		});
		const parameterInputWrapperStyle = computed(() => {
			let deductWidth = 0;
			const styles = { width: "100%" };
			if (props.parameter.type === "credentialsSelect" || isResourceLocatorParameter.value) return styles;
			if (getIssues.value.length) deductWidth += 20;
			if (deductWidth !== 0) styles.width = `calc(100% - ${deductWidth}px)`;
			return styles;
		});
		const parameterId = computed(() => {
			return `${node$1.value?.id ?? crypto.randomUUID()}${props.path}`;
		});
		const remoteParameterOptionsKeys = computed(() => {
			return (remoteParameterOptions.value || []).map((o) => o.name);
		});
		const shouldRedactValue = computed(() => {
			return getStringInputType.value === "password" || props.isForCredential;
		});
		const isCodeNode = computed(() => !!node$1.value && NODES_USING_CODE_NODE_EDITOR.includes(node$1.value.type));
		const isHtmlNode = computed(() => !!node$1.value && node$1.value.type === "n8n-nodes-base.html");
		const isInputTypeString = computed(() => props.parameter.type === "string");
		const isInputTypeNumber = computed(() => props.parameter.type === "number");
		const isInputDataEmpty = computed(() => ndvStore.isInputPanelEmpty);
		const isDropDisabled = computed(() => props.parameter.noDataExpression === true || props.isReadOnly || isResourceLocatorParameter.value || isModelValueExpression.value);
		const showDragnDropTip = computed(() => isFocused.value && (isInputTypeString.value || isInputTypeNumber.value) && !isModelValueExpression.value && !isDropDisabled.value && (!ndvStore.hasInputData || !isInputDataEmpty.value) && !ndvStore.isMappingOnboarded && ndvStore.isInputParentOfActiveNode && !props.isForCredential);
		const shouldCaptureForPosthog = computed(() => node$1.value?.type === AI_TRANSFORM_NODE_TYPE);
		const isMapperAvailable = computed(() => !props.parameter.isNodeSetting && (isModelValueExpression.value || props.forceShowExpression || isEmpty$1(props.modelValue) && props.parameter.type !== "dateTime" || editorType.value !== void 0));
		function isRemoteParameterOption(option$1) {
			return remoteParameterOptionsKeys.value.includes(option$1.name);
		}
		function credentialSelected(updateInformation) {
			workflowState.updateNodeProperties(updateInformation);
			const updateNode = workflowsStore.getNodeByName(updateInformation.name);
			if (updateNode) nodeHelpers.updateNodeCredentialIssues(updateNode);
			externalHooks.run("nodeSettings.credentialSelected", { updateInformation });
		}
		function getPlaceholder() {
			return props.isForCredential ? i18n$1.credText(uiStore.activeCredentialType).placeholder(props.parameter) : i18n$1.nodeText(ndvStore.activeNode?.type).placeholder(props.parameter, props.path);
		}
		function getOptionsOptionDisplayName(option$1) {
			return props.isForCredential ? i18n$1.credText(uiStore.activeCredentialType).optionsOptionDisplayName(props.parameter, option$1) : i18n$1.nodeText(ndvStore.activeNode?.type).optionsOptionDisplayName(props.parameter, option$1, props.path);
		}
		function getOptionsOptionDescription(option$1) {
			return props.isForCredential ? i18n$1.credText(uiStore.activeCredentialType).optionsOptionDescription(props.parameter, option$1) : i18n$1.nodeText(ndvStore.activeNode?.type).optionsOptionDescription(props.parameter, option$1, props.path);
		}
		async function loadRemoteParameterOptions() {
			if (!node$1.value || !hasRemoteMethod.value || remoteParameterOptionsLoading.value || !props.parameter) return;
			remoteParameterOptionsLoadingIssues.value = null;
			remoteParameterOptionsLoading.value = true;
			remoteParameterOptions.value.length = 0;
			try {
				const currentNodeParameters = ndvStore.activeNode.parameters;
				const resolvedNodeParameters = workflowHelpers.resolveRequiredParameters(props.parameter, currentNodeParameters);
				const loadOptionsMethod = getTypeOption("loadOptionsMethod");
				const loadOptions = getTypeOption("loadOptions");
				const options$1 = await nodeTypesStore.getNodeParameterOptions({
					nodeTypeAndVersion: {
						name: node$1.value.type,
						version: node$1.value.typeVersion
					},
					path: props.path,
					methodName: loadOptionsMethod,
					loadOptions,
					currentNodeParameters: resolvedNodeParameters,
					credentials: node$1.value.credentials,
					projectId: projectsStore.currentProjectId
				});
				remoteParameterOptions.value = remoteParameterOptions.value.concat(options$1);
			} catch (error) {
				if (error instanceof Error) remoteParameterOptionsLoadingIssues.value = error.message;
				else remoteParameterOptionsLoadingIssues.value = String(error);
			}
			remoteParameterOptionsLoading.value = false;
		}
		function closeCodeEditDialog() {
			codeEditDialogVisible.value = false;
			editDialogClosing.value = true;
			nextTick().then(() => {
				editDialogClosing.value = false;
			});
		}
		function closeExpressionEditDialog() {
			expressionEditDialogVisible.value = false;
		}
		function trackExpressionEditOpen() {
			if (!node$1.value) return;
			if (node$1.value.type.startsWith("n8n-nodes-base") || isCredentialOnlyNodeType(node$1.value.type)) telemetry.track("User opened Expression Editor", {
				node_type: node$1.value.type,
				parameter_name: props.parameter.displayName,
				parameter_field_type: props.parameter.type,
				new_expression: !isModelValueExpression.value,
				workflow_id: workflowsStore.workflowId,
				push_ref: ndvStore.pushRef,
				source: props.eventSource ?? "ndv"
			});
		}
		function closeTextEditDialog() {
			textEditDialogVisible.value = false;
			editDialogClosing.value = true;
			nextTick().then(() => {
				if (isBlurrableEl(inputField$2.value)) inputField$2.value.blur();
				editDialogClosing.value = false;
			});
		}
		function displayEditDialog() {
			if (editDialogClosing.value) return;
			if (editorType.value || props.parameter.type === "json") codeEditDialogVisible.value = true;
			else textEditDialogVisible.value = true;
		}
		function openExpressionEditorModal() {
			if (!isModelValueExpression.value) return;
			expressionEditDialogVisible.value = true;
			trackExpressionEditOpen();
		}
		function selectInput$2() {
			if (inputField$2.value) {
				if (isSelectableEl(inputField$2.value)) inputField$2.value.select();
			}
		}
		async function setFocus() {
			if (["json"].includes(props.parameter.type) && getTypeOption("alwaysOpenEditWindow")) {
				displayEditDialog();
				return;
			}
			if (node$1.value) nodeName.value = node$1.value.name;
			await nextTick();
			if (inputField$2.value) {
				if (hasFocusOnInput(inputField$2.value)) inputField$2.value.focusOnInput();
				else if (isFocusableEl(inputField$2.value)) inputField$2.value.focus();
				isFocused.value = true;
			}
			emit("focus");
		}
		function rgbaToHex(value$1) {
			const valueMatch = value$1.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d+(\.\d+)?)\)$/);
			if (valueMatch === null) return null;
			const [r, g, b$1, a] = valueMatch.splice(1, 4).map((v$1) => Number(v$1));
			return "#" + ((1 << 24) + (r << 16) + (g << 8) + b$1).toString(16).slice(1) + (256 + Math.floor((1 - a) * 255)).toString(16).slice(1);
		}
		function onTextInputChange(value$1) {
			emit("textInput", {
				node: node$1.value ? node$1.value.name : nodeName.value,
				name: props.path,
				value: value$1
			});
		}
		function trackWorkflowInputModeEvent(value$1) {
			telemetry.track("User chose input data mode", {
				option: {
					workflowInputs: "fields",
					jsonExample: "json",
					passthrough: "all"
				}[value$1],
				workflow_id: workflowsStore.workflowId,
				node_id: node$1.value?.id
			});
		}
		function valueChanged(untypedValue) {
			if (remoteParameterOptionsLoading.value) return;
			const oldValue = (0, import_get$3.default)(node$1.value, props.path);
			if (oldValue !== void 0 && oldValue === untypedValue) return;
			let value$1;
			if (untypedValue instanceof Date) value$1 = untypedValue.toISOString();
			else if (typeof untypedValue === "string" || typeof untypedValue === "number" || typeof untypedValue === "boolean" || untypedValue === null || Array.isArray(untypedValue)) value$1 = untypedValue;
			else if (typeof untypedValue === "object" && untypedValue !== null && "__rl" in untypedValue) value$1 = untypedValue;
			else value$1 = untypedValue;
			const isSpecializedEditor = props.parameter.typeOptions?.editor !== void 0;
			if (!oldValue && oldValue !== void 0 && shouldConvertToExpression(value$1, isSpecializedEditor)) value$1 = "=" + value$1;
			if (props.parameter.name === "nodeCredentialType") activeCredentialType.value = value$1;
			value$1 = completeExpressionSyntax(value$1, isSpecializedEditor);
			if (props.parameter.type === "color" && getTypeOption("showAlpha") === true && value$1 !== null && value$1 !== void 0 && value$1.toString().charAt(0) !== "#") {
				const newValue = rgbaToHex(value$1);
				if (newValue !== null) {
					tempValue.value = newValue;
					value$1 = newValue;
				}
			}
			emit("update", {
				node: node$1.value ? node$1.value.name : nodeName.value,
				name: props.path,
				value: value$1
			});
			if (props.parameter.name === "operation" || props.parameter.name === "mode") telemetry.track("User set node operation or mode", {
				workflow_id: workflowsStore.workflowId,
				node_type: node$1.value?.type,
				resource: node$1.value?.parameters.resource,
				is_custom: value$1 === CUSTOM_API_CALL_KEY,
				push_ref: ndvStore.pushRef,
				parameter: props.parameter.name,
				value: value$1
			});
			if (props.parameter.name === "inputSource" && props.parameter.default === "workflowInputs") trackWorkflowInputModeEvent(value$1);
		}
		const valueChangedDebounced = debounce$4(valueChanged, { debounceTime: 100 });
		function expressionUpdated(value$1) {
			valueChanged(isResourceLocatorParameter.value ? {
				__rl: true,
				value: value$1,
				mode: modelValueResourceLocator.value.mode
			} : value$1);
		}
		function onBlur() {
			emit("blur");
			isFocused.value = false;
		}
		function onPaste(event) {
			const pastedText = event.clipboardData?.getData("text");
			const input$5 = event.target;
			if (!(input$5 instanceof HTMLInputElement)) return;
			const start = input$5.selectionStart ?? 0;
			if (pastedText && pastedText.startsWith("=") && !pastedText.match(/{{.*?}}/g) && start === 0) {
				event.preventDefault();
				const end = input$5.selectionEnd ?? start;
				const text$1 = input$5.value;
				const withExpressionPrefix = "=" + pastedText;
				input$5.value = text$1.substring(0, start) + withExpressionPrefix + text$1.substring(end);
				input$5.selectionStart = input$5.selectionEnd = start + withExpressionPrefix.length;
				valueChanged(input$5.value);
			}
		}
		function onPasteNumber(event) {
			const pastedText = event.clipboardData?.getData("text");
			if (shouldConvertToExpression(pastedText)) {
				event.preventDefault();
				valueChanged("=" + pastedText);
				return;
			}
		}
		function onResourceLocatorDrop(data) {
			emit("drop", data);
		}
		function onUpdateTextInput(value$1) {
			valueChanged(value$1);
			onTextInputChange(value$1);
		}
		const onUpdateTextInputDebounced = debounce$4(onUpdateTextInput, { debounceTime: 200 });
		async function optionSelected(command) {
			const prevValue = props.modelValue;
			switch (command) {
				case "resetValue": return valueChanged(props.parameter.default);
				case "addExpression":
					valueChanged(formatAsExpression(props.modelValue, props.parameter.type));
					await setFocus();
					break;
				case "removeExpression":
					isFocused.value = false;
					valueChanged(parseFromExpression(props.modelValue, props.expressionEvaluated, props.parameter.type, props.parameter.default, parameterOptions.value));
					break;
				case "refreshOptions":
					if (isResourceLocatorParameter.value) props.eventBus.emit("refreshList");
					loadRemoteParameterOptions();
					return;
				case "formatHtml":
					htmlEditorEventBus.emit("format-html");
					return;
				case "focus":
					nodeSettingsParameters.handleFocus(node$1.value, props.path, props.parameter);
					if (experimentalNdvStore.isNdvInFocusPanelEnabled) telemetry.track("User added focused param", {
						source: "parameterButton",
						parameters: focusPanelStore.focusedNodeParametersInTelemetryFormat
					});
					else telemetry.track("User opened focus panel", {
						source: "parameterButton",
						parameters: focusPanelStore.focusedNodeParametersInTelemetryFormat
					});
					return;
			}
			if (node$1.value && (command === "addExpression" || command === "removeExpression")) {
				const telemetryPayload = {
					node_type: node$1.value.type,
					parameter: props.path,
					old_mode: command === "addExpression" ? "fixed" : "expression",
					new_mode: command === "removeExpression" ? "fixed" : "expression",
					was_parameter_empty: prevValue === "" || prevValue === void 0,
					had_mapping: hasExpressionMapping(prevValue),
					had_parameter: typeof prevValue === "string" && prevValue.includes("$parameter")
				};
				telemetry.track("User switched parameter mode", telemetryPayload);
				externalHooks.run("parameterInput.modeSwitch", telemetryPayload);
			}
		}
		onMounted(() => {
			props.eventBus.on("optionSelected", optionSelected);
			tempValue.value = displayValue.value;
			if (node$1.value) nodeName.value = node$1.value.name;
			if (node$1.value && node$1.value.parameters.authentication === "predefinedCredentialType") activeCredentialType.value = node$1.value.parameters.nodeCredentialType;
			if (props.parameter.type === "color" && getTypeOption("showAlpha") === true && displayValue.value !== null && displayValue.value.toString().charAt(0) !== "#") {
				const newValue = rgbaToHex(displayValue.value);
				if (newValue !== null) tempValue.value = newValue;
			}
			externalHooks.run("parameterInput.mount", {
				parameter: props.parameter,
				inputFieldRef: inputField$2.value
			});
		});
		const { height } = useElementSize(wrapper$3);
		const isSingleLineInput = computed(() => {
			if (isTextarea.value && !isModelValueExpression.value) return false;
			if (isSingleLineInput.value) return height.value <= 70;
			return height.value <= 35;
		});
		__expose({
			isSingleLineInput,
			displaysIssues: displayIssues.value,
			focusInput: async () => await setFocus(),
			selectInput: () => selectInput$2()
		});
		onBeforeUnmount(() => {
			valueChangedDebounced.flush();
			onUpdateTextInputDebounced.flush();
			props.eventBus.off("optionSelected", optionSelected);
		});
		watch(() => node$1.value?.credentials, () => {
			if (hasRemoteMethod.value && node$1.value) loadRemoteParameterOptions();
		}, { immediate: true });
		watch(dependentParametersValues, async () => {
			await loadRemoteParameterOptions();
		});
		watch(() => props.modelValue, () => {
			if (props.parameter.type === "color" && getTypeOption("showAlpha") === true) return;
			tempValue.value = displayValue.value;
		});
		watch(remoteParameterOptionsLoading, () => {
			tempValue.value = displayValue.value;
		});
		watch(isModelValueExpression, async (isExpression$1, wasExpression) => {
			if (!props.isReadOnly && isFocused.value && isExpression$1 !== wasExpression) {
				await nextTick();
				await setFocus();
			}
		});
		const unwatchParameterOptions = watch([remoteParameterOptions, () => props.parameter.options], ([remoteOptions, options$1]) => {
			const invalidOptions = [...remoteOptions, ...options$1 ?? []].filter((option$1) => !isValidParameterOption(option$1));
			if (invalidOptions.length > 0) {
				captureMessage("Invalid parameter options", {
					level: "error",
					extra: {
						invalidOptions,
						parameter: props.parameter.name,
						node: node$1.value
					}
				});
				unwatchParameterOptions();
			}
		});
		onUpdated(async () => {
			await nextTick();
			if (wrapper$3.value) {
				const remoteParamOptions = wrapper$3.value.querySelectorAll(".remote-parameter-option") ?? [];
				if (remoteParamOptions.length > 0) externalHooks.run("parameterInput.updated", { remoteParameterOptions: remoteParamOptions });
			}
		});
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", {
				ref_key: "wrapper",
				ref: wrapper$3,
				class: normalizeClass([parameterInputClasses.value, { [_ctx.$style.tipVisible]: showDragnDropTip.value }]),
				onKeydown: _cache[17] || (_cache[17] = withModifiers(() => {}, ["stop"]))
			}, [
				typeof modelValueExpressionEdit.value === "string" ? (openBlock(), createBlock(ExpressionEditModal_default, {
					key: 0,
					"dialog-visible": expressionEditDialogVisible.value,
					"model-value": modelValueExpressionEdit.value,
					parameter: _ctx.parameter,
					node: node$1.value,
					path: _ctx.path,
					"event-source": _ctx.eventSource || "ndv",
					"is-read-only": _ctx.isReadOnly,
					"redact-values": shouldRedactValue.value,
					onCloseDialog: closeExpressionEditDialog,
					"onUpdate:modelValue": expressionUpdated
				}, null, 8, [
					"dialog-visible",
					"model-value",
					"parameter",
					"node",
					"path",
					"event-source",
					"is-read-only",
					"redact-values"
				])) : createCommentVNode("", true),
				wrapper$3.value && isMapperAvailable.value && node$1.value && unref(expressionLocalResolveCtx)?.inputNode ? (openBlock(), createBlock(ExperimentalEmbeddedNdvMapper_default, {
					key: 1,
					workflow: unref(expressionLocalResolveCtx).workflow,
					node: node$1.value,
					"input-node-name": unref(expressionLocalResolveCtx).inputNode.name,
					reference: wrapper$3.value
				}, null, 8, [
					"workflow",
					"node",
					"input-node-name",
					"reference"
				])) : createCommentVNode("", true),
				createBaseVNode("div", {
					class: normalizeClass([
						"parameter-input",
						"ignore-key-press-canvas",
						{ [_ctx.$style.noRightCornersInput]: _ctx.canBeOverridden }
					]),
					style: normalizeStyle(parameterInputWrapperStyle.value),
					"data-parameter-path": _ctx.path
				}, [_ctx.parameter.type === "resourceLocator" ? (openBlock(), createBlock(ResourceLocator_default, {
					key: 0,
					ref: "resourceLocator",
					parameter: _ctx.parameter,
					"model-value": modelValueResourceLocator.value,
					"dependent-parameters-values": dependentParametersValues.value,
					"display-title": displayTitle.value,
					"expression-display-value": expressionDisplayValue.value,
					"expression-computed-value": _ctx.expressionEvaluated,
					"is-value-expression": isModelValueExpression.value,
					"is-read-only": _ctx.isReadOnly,
					"parameter-issues": getIssues.value,
					droppable: _ctx.droppable,
					node: node$1.value,
					path: _ctx.path,
					"event-bus": _ctx.eventBus,
					"onUpdate:modelValue": unref(valueChangedDebounced),
					onModalOpenerClick: openExpressionEditorModal,
					onFocus: setFocus,
					onBlur,
					onDrop: onResourceLocatorDrop
				}, null, 8, [
					"parameter",
					"model-value",
					"dependent-parameters-values",
					"display-title",
					"expression-display-value",
					"expression-computed-value",
					"is-value-expression",
					"is-read-only",
					"parameter-issues",
					"droppable",
					"node",
					"path",
					"event-bus",
					"onUpdate:modelValue"
				])) : _ctx.parameter.type === "workflowSelector" ? (openBlock(), createBlock(WorkflowSelectorParameterInput_default, {
					key: 1,
					ref: "resourceLocator",
					parameter: _ctx.parameter,
					"model-value": modelValueResourceLocator.value,
					"dependent-parameters-values": dependentParametersValues.value,
					"display-title": displayTitle.value,
					"expression-display-value": expressionDisplayValue.value,
					"expression-computed-value": _ctx.expressionEvaluated,
					"is-value-expression": isModelValueExpression.value,
					"expression-edit-dialog-visible": expressionEditDialogVisible.value,
					path: _ctx.path,
					"parameter-issues": getIssues.value,
					"is-read-only": _ctx.isReadOnly,
					"onUpdate:modelValue": unref(valueChangedDebounced),
					onModalOpenerClick: openExpressionEditorModal,
					onFocus: setFocus,
					onBlur,
					onDrop: onResourceLocatorDrop
				}, null, 8, [
					"parameter",
					"model-value",
					"dependent-parameters-values",
					"display-title",
					"expression-display-value",
					"expression-computed-value",
					"is-value-expression",
					"expression-edit-dialog-visible",
					"path",
					"parameter-issues",
					"is-read-only",
					"onUpdate:modelValue"
				])) : isModelValueExpression.value || _ctx.forceShowExpression ? (openBlock(), createBlock(ExpressionParameterInput_default, {
					key: 2,
					ref_key: "inputField",
					ref: inputField$2,
					"model-value": expressionDisplayValue.value,
					title: displayTitle.value,
					"is-read-only": _ctx.isReadOnly,
					rows: _ctx.rows,
					"is-assignment": _ctx.isAssignment,
					path: _ctx.path,
					"additional-expression-data": _ctx.additionalExpressionData,
					class: normalizeClass({ "ph-no-capture": shouldRedactValue.value }),
					"event-bus": _ctx.eventBus,
					"onUpdate:modelValue": expressionUpdated,
					onModalOpenerClick: openExpressionEditorModal,
					onFocus: setFocus,
					onBlur
				}, null, 8, [
					"model-value",
					"title",
					"is-read-only",
					"rows",
					"is-assignment",
					"path",
					"additional-expression-data",
					"class",
					"event-bus"
				])) : ["json", "string"].includes(_ctx.parameter.type) || remoteParameterOptionsLoadingIssues.value !== null ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
					createVNode(unref(ElDialog), {
						width: "calc(100% - var(--spacing--3xl))",
						class: normalizeClass(_ctx.$style.modal),
						"model-value": codeEditDialogVisible.value,
						"append-to": `#${unref(APP_MODALS_ELEMENT_ID)}`,
						title: `${unref(i18n$1).baseText("codeEdit.edit")} ${unref(i18n$1).nodeText(unref(ndvStore).activeNode?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path)}`,
						"before-close": closeCodeEditDialog,
						"data-test-id": "code-editor-fullscreen"
					}, {
						default: withCtx(() => [createBaseVNode("div", _hoisted_3$6, [editorType.value === "codeNodeEditor" && codeEditDialogVisible.value ? (openBlock(), createBlock(CodeNodeEditor_default, {
							key: 0,
							id: parameterId.value,
							mode: codeEditorMode.value,
							"model-value": modelValueString.value,
							"default-value": _ctx.parameter.default,
							language: editorLanguage.value,
							"is-read-only": _ctx.isReadOnly,
							"fill-parent": "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"id",
							"mode",
							"model-value",
							"default-value",
							"language",
							"is-read-only",
							"onUpdate:modelValue"
						])) : editorType.value === "htmlEditor" && codeEditDialogVisible.value ? (openBlock(), createBlock(HtmlEditor_default, {
							key: 1,
							"model-value": modelValueString.value,
							"is-read-only": _ctx.isReadOnly,
							rows: editorRows.value,
							"disable-expression-coloring": !isHtmlNode.value,
							"disable-expression-completions": !isHtmlNode.value,
							fullscreen: "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"model-value",
							"is-read-only",
							"rows",
							"disable-expression-coloring",
							"disable-expression-completions",
							"onUpdate:modelValue"
						])) : editorType.value === "cssEditor" && codeEditDialogVisible.value ? (openBlock(), createBlock(CssEditor_default, {
							key: 2,
							"model-value": modelValueString.value,
							"is-read-only": _ctx.isReadOnly,
							rows: editorRows.value,
							fullscreen: "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"model-value",
							"is-read-only",
							"rows",
							"onUpdate:modelValue"
						])) : editorType.value === "sqlEditor" && codeEditDialogVisible.value ? (openBlock(), createBlock(SqlEditor_default, {
							key: 3,
							"model-value": modelValueString.value,
							dialect: getTypeOption("sqlDialect"),
							"is-read-only": _ctx.isReadOnly,
							rows: editorRows.value,
							fullscreen: "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"model-value",
							"dialect",
							"is-read-only",
							"rows",
							"onUpdate:modelValue"
						])) : editorType.value === "jsEditor" && codeEditDialogVisible.value ? (openBlock(), createBlock(JsEditor_default, {
							key: 4,
							"model-value": modelValueString.value,
							"is-read-only": _ctx.isReadOnly,
							rows: editorRows.value,
							"posthog-capture": shouldCaptureForPosthog.value,
							"fill-parent": "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"model-value",
							"is-read-only",
							"rows",
							"posthog-capture",
							"onUpdate:modelValue"
						])) : _ctx.parameter.type === "json" && codeEditDialogVisible.value ? (openBlock(), createBlock(JsonEditor_default, {
							key: 5,
							"model-value": modelValueString.value,
							"is-read-only": _ctx.isReadOnly,
							rows: editorRows.value,
							fullscreen: "",
							"fill-parent": "",
							"onUpdate:modelValue": unref(valueChangedDebounced)
						}, null, 8, [
							"model-value",
							"is-read-only",
							"rows",
							"onUpdate:modelValue"
						])) : createCommentVNode("", true)])]),
						_: 1
					}, 8, [
						"class",
						"model-value",
						"append-to",
						"title"
					]),
					createVNode(TextEdit_default, {
						"dialog-visible": textEditDialogVisible.value,
						"model-value": `${_ctx.modelValue}`,
						parameter: _ctx.parameter,
						path: _ctx.path,
						"is-read-only": _ctx.isReadOnly,
						onCloseDialog: closeTextEditDialog,
						"onUpdate:modelValue": expressionUpdated
					}, null, 8, [
						"dialog-visible",
						"model-value",
						"parameter",
						"path",
						"is-read-only"
					]),
					editorType.value === "codeNodeEditor" && isCodeNode.value && !codeEditDialogVisible.value ? (openBlock(), createBlock(CodeNodeEditor_default, {
						key: 0,
						id: parameterId.value,
						mode: codeEditorMode.value,
						"model-value": modelValueString.value,
						"default-value": _ctx.parameter.default,
						language: editorLanguage.value,
						"is-read-only": _ctx.isReadOnly || editorIsReadOnly.value,
						rows: editorRows.value,
						"ai-button-enabled": unref(settingsStore).isCloudDeployment,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [!editorIsReadOnly.value ? (openBlock(), createElementBlock("span", {
							key: 0,
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[0] || (_cache[0] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])) : createCommentVNode("", true)]),
						_: 1
					}, 8, [
						"id",
						"mode",
						"model-value",
						"default-value",
						"language",
						"is-read-only",
						"rows",
						"ai-button-enabled",
						"onUpdate:modelValue"
					])) : editorType.value === "htmlEditor" && !codeEditDialogVisible.value ? (openBlock(), createBlock(HtmlEditor_default, {
						key: 1,
						"model-value": modelValueString.value,
						"is-read-only": _ctx.isReadOnly,
						rows: editorRows.value,
						"disable-expression-coloring": !isHtmlNode.value,
						"disable-expression-completions": !isHtmlNode.value,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [createBaseVNode("span", {
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[1] || (_cache[1] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])]),
						_: 1
					}, 8, [
						"model-value",
						"is-read-only",
						"rows",
						"disable-expression-coloring",
						"disable-expression-completions",
						"onUpdate:modelValue"
					])) : editorType.value === "cssEditor" && !codeEditDialogVisible.value ? (openBlock(), createBlock(CssEditor_default, {
						key: 2,
						"model-value": modelValueString.value,
						"is-read-only": _ctx.isReadOnly,
						rows: editorRows.value,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [createBaseVNode("span", {
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[2] || (_cache[2] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])]),
						_: 1
					}, 8, [
						"model-value",
						"is-read-only",
						"rows",
						"onUpdate:modelValue"
					])) : editorType.value === "sqlEditor" ? (openBlock(), createBlock(SqlEditor_default, {
						key: 3,
						"model-value": modelValueString.value,
						dialect: getTypeOption("sqlDialect"),
						"is-read-only": _ctx.isReadOnly,
						rows: editorRows.value,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [createBaseVNode("span", {
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[3] || (_cache[3] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])]),
						_: 1
					}, 8, [
						"model-value",
						"dialect",
						"is-read-only",
						"rows",
						"onUpdate:modelValue"
					])) : editorType.value === "jsEditor" ? (openBlock(), createBlock(JsEditor_default, {
						key: 4,
						"model-value": modelValueString.value,
						"is-read-only": _ctx.isReadOnly || editorIsReadOnly.value,
						rows: editorRows.value,
						"posthog-capture": shouldCaptureForPosthog.value,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [!editorIsReadOnly.value ? (openBlock(), createElementBlock("span", {
							key: 0,
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[4] || (_cache[4] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])) : createCommentVNode("", true)]),
						_: 1
					}, 8, [
						"model-value",
						"is-read-only",
						"rows",
						"posthog-capture",
						"onUpdate:modelValue"
					])) : _ctx.parameter.type === "json" && !codeEditDialogVisible.value ? (openBlock(), createBlock(JsonEditor_default, {
						key: 5,
						"model-value": modelValueString.value,
						"is-read-only": _ctx.isReadOnly,
						rows: editorRows.value,
						"onUpdate:modelValue": unref(valueChangedDebounced)
					}, {
						suffix: withCtx(() => [createBaseVNode("span", {
							class: "textarea-modal-opener",
							"data-test-id": "code-editor-fullscreen-button",
							onClick: _cache[5] || (_cache[5] = ($event) => displayEditDialog())
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])])]),
						_: 1
					}, 8, [
						"model-value",
						"is-read-only",
						"rows",
						"onUpdate:modelValue"
					])) : editorType.value ? (openBlock(), createElementBlock("div", {
						key: 6,
						class: "readonly-code clickable",
						onClick: _cache[6] || (_cache[6] = ($event) => displayEditDialog())
					}, [!codeEditDialogVisible.value ? (openBlock(), createBlock(CodeNodeEditor_default, {
						key: 0,
						id: parameterId.value,
						mode: codeEditorMode.value,
						"model-value": modelValueString.value,
						language: editorLanguage.value,
						"is-read-only": true,
						rows: editorRows.value
					}, null, 8, [
						"id",
						"mode",
						"model-value",
						"language",
						"rows"
					])) : createCommentVNode("", true)])) : (openBlock(), createBlock(unref(N8nInput_default), {
						key: 7,
						ref_key: "inputField",
						ref: inputField$2,
						modelValue: tempValue.value,
						"onUpdate:modelValue": [_cache[8] || (_cache[8] = ($event) => tempValue.value = $event), _cache[9] || (_cache[9] = ($event) => unref(onUpdateTextInputDebounced)($event))],
						class: normalizeClass({
							"input-with-opener": true,
							"ph-no-capture": shouldRedactValue.value
						}),
						size: _ctx.inputSize,
						type: getStringInputType.value,
						rows: editorRows.value,
						disabled: _ctx.isReadOnly || remoteParameterOptionsLoading.value || remoteParameterOptionsLoadingIssues.value !== null,
						title: displayTitle.value,
						placeholder: getPlaceholder(),
						"data-test-id": "parameter-input-field",
						onKeydown: _cache[10] || (_cache[10] = withModifiers(() => {}, ["stop"])),
						onFocus: setFocus,
						onBlur,
						onPaste
					}, {
						suffix: withCtx(() => [!_ctx.isReadOnly && !isSecretParameter.value ? (openBlock(), createElementBlock("span", {
							key: 0,
							class: normalizeClass({
								"textarea-modal-opener": true,
								"edit-window-button": true,
								focused: isFocused.value,
								invalid: !isFocused.value && getIssues.value.length > 0 && !isModelValueExpression.value
							}),
							onClick: _cache[7] || (_cache[7] = ($event) => displayEditDialog()),
							onFocus: setFocus
						}, [createVNode(unref(N8nIcon_default), {
							icon: "external-link",
							size: "xsmall",
							title: unref(i18n$1).baseText("parameterInput.openEditWindow")
						}, null, 8, ["title"])], 34)) : createCommentVNode("", true)]),
						_: 1
					}, 8, [
						"modelValue",
						"class",
						"size",
						"type",
						"rows",
						"disabled",
						"title",
						"placeholder"
					]))
				])) : _ctx.parameter.type === "color" ? (openBlock(), createElementBlock("div", {
					key: 4,
					ref_key: "inputField",
					ref: inputField$2,
					class: "color-input"
				}, [createVNode(unref(ElColorPicker), {
					size: "small",
					class: "color-picker",
					"model-value": displayValue.value,
					disabled: _ctx.isReadOnly,
					title: displayTitle.value,
					"show-alpha": getTypeOption("showAlpha"),
					onFocus: setFocus,
					onBlur,
					"onUpdate:modelValue": valueChanged
				}, null, 8, [
					"model-value",
					"disabled",
					"title",
					"show-alpha"
				]), createVNode(unref(N8nInput_default), {
					modelValue: tempValue.value,
					"onUpdate:modelValue": [_cache[11] || (_cache[11] = ($event) => tempValue.value = $event), unref(valueChangedDebounced)],
					size: _ctx.inputSize,
					type: "text",
					disabled: _ctx.isReadOnly,
					title: displayTitle.value,
					onKeydown: _cache[12] || (_cache[12] = withModifiers(() => {}, ["stop"])),
					onFocus: setFocus,
					onBlur
				}, null, 8, [
					"modelValue",
					"size",
					"disabled",
					"title",
					"onUpdate:modelValue"
				])], 512)) : _ctx.parameter.type === "dateTime" ? (openBlock(), createBlock(unref(ElDatePicker), {
					key: 5,
					ref_key: "inputField",
					ref: inputField$2,
					modelValue: tempValue.value,
					"onUpdate:modelValue": [_cache[13] || (_cache[13] = ($event) => tempValue.value = $event), valueChanged],
					type: "datetime",
					"value-format": "YYYY-MM-DDTHH:mm:ss",
					size: _ctx.inputSize === "mini" ? "small" : _ctx.inputSize === "xlarge" || _ctx.inputSize === "medium" ? "large" : _ctx.inputSize,
					title: displayTitle.value,
					disabled: _ctx.isReadOnly,
					placeholder: _ctx.parameter.placeholder ? getPlaceholder() : unref(i18n$1).baseText("parameterInput.selectDateAndTime"),
					"picker-options": dateTimePickerOptions.value,
					class: normalizeClass({ "ph-no-capture": shouldRedactValue.value }),
					onFocus: setFocus,
					onBlur,
					onKeydown: _cache[14] || (_cache[14] = withModifiers(() => {}, ["stop"]))
				}, null, 8, [
					"modelValue",
					"size",
					"title",
					"disabled",
					"placeholder",
					"picker-options",
					"class"
				])) : _ctx.parameter.type === "number" ? (openBlock(), createBlock(unref(N8nInputNumber_default), {
					key: 6,
					ref_key: "inputField",
					ref: inputField$2,
					size: _ctx.inputSize,
					"model-value": displayValue.value,
					controls: false,
					max: getTypeOption("maxValue"),
					min: getTypeOption("minValue"),
					precision: getTypeOption("numberPrecision"),
					disabled: _ctx.isReadOnly,
					class: normalizeClass({ "ph-no-capture": shouldRedactValue.value }),
					title: displayTitle.value,
					placeholder: _ctx.parameter.placeholder,
					"onUpdate:modelValue": onUpdateTextInput,
					onFocus: setFocus,
					onBlur,
					onPaste: onPasteNumber
				}, null, 8, [
					"size",
					"model-value",
					"max",
					"min",
					"precision",
					"disabled",
					"class",
					"title",
					"placeholder"
				])) : _ctx.parameter.type === "credentialsSelect" || _ctx.parameter.name === "genericAuthType" ? (openBlock(), createBlock(CredentialsSelect_default, {
					key: 7,
					ref_key: "inputField",
					ref: inputField$2,
					parameter: _ctx.parameter,
					node: node$1.value,
					"active-credential-type": activeCredentialType.value,
					"input-size": _ctx.inputSize,
					"display-value": displayValue.value,
					"is-read-only": _ctx.isReadOnly,
					"display-title": displayTitle.value,
					onCredentialSelected: credentialSelected,
					"onUpdate:modelValue": valueChanged,
					onSetFocus: setFocus,
					onOnBlur: onBlur
				}, {
					"issues-and-options": withCtx(() => [createVNode(ParameterIssues_default, { issues: getIssues.value }, null, 8, ["issues"])]),
					_: 1
				}, 8, [
					"parameter",
					"node",
					"active-credential-type",
					"input-size",
					"display-value",
					"is-read-only",
					"display-title"
				])) : _ctx.parameter.type === "options" ? (openBlock(), createBlock(unref(N8nSelect_default), {
					key: 8,
					ref_key: "inputField",
					ref: inputField$2,
					size: _ctx.inputSize,
					filterable: "",
					"model-value": displayValue.value,
					placeholder: _ctx.parameter.placeholder ? getPlaceholder() : unref(i18n$1).baseText("parameterInput.select"),
					loading: remoteParameterOptionsLoading.value,
					disabled: _ctx.isReadOnly || remoteParameterOptionsLoading.value,
					title: displayTitle.value,
					"onUpdate:modelValue": valueChanged,
					onKeydown: _cache[15] || (_cache[15] = withModifiers(() => {}, ["stop"])),
					onFocus: setFocus,
					onBlur
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(parameterOptions.value, (option$1) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: option$1.value.toString(),
							value: option$1.value,
							label: getOptionsOptionDisplayName(option$1),
							"data-test-id": "parameter-input-item"
						}, {
							default: withCtx(() => [createBaseVNode("div", _hoisted_4$5, [createBaseVNode("div", { class: normalizeClass(["option-headline", { "remote-parameter-option": isRemoteParameterOption(option$1) }]) }, toDisplayString(getOptionsOptionDisplayName(option$1)), 3), option$1.description ? withDirectives((openBlock(), createElementBlock("div", _hoisted_5$3, null, 512)), [[_directive_n8n_html, getOptionsOptionDescription(option$1)]]) : createCommentVNode("", true)])]),
							_: 2
						}, 1032, ["value", "label"]);
					}), 128))]),
					_: 1
				}, 8, [
					"size",
					"model-value",
					"placeholder",
					"loading",
					"disabled",
					"title"
				])) : _ctx.parameter.type === "multiOptions" ? (openBlock(), createBlock(unref(N8nSelect_default), {
					key: 9,
					ref_key: "inputField",
					ref: inputField$2,
					size: _ctx.inputSize,
					filterable: "",
					multiple: "",
					"model-value": displayValue.value,
					loading: remoteParameterOptionsLoading.value,
					disabled: _ctx.isReadOnly || remoteParameterOptionsLoading.value,
					title: displayTitle.value,
					placeholder: unref(i18n$1).baseText("parameterInput.select"),
					"onUpdate:modelValue": valueChanged,
					onKeydown: _cache[16] || (_cache[16] = withModifiers(() => {}, ["stop"])),
					onFocus: setFocus,
					onBlur
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(parameterOptions.value, (option$1) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: option$1.value.toString(),
							value: option$1.value,
							label: getOptionsOptionDisplayName(option$1)
						}, {
							default: withCtx(() => [createBaseVNode("div", _hoisted_6$2, [createBaseVNode("div", _hoisted_7, toDisplayString(getOptionsOptionDisplayName(option$1)), 1), option$1.description ? withDirectives((openBlock(), createElementBlock("div", _hoisted_8, null, 512)), [[_directive_n8n_html, getOptionsOptionDescription(option$1)]]) : createCommentVNode("", true)])]),
							_: 2
						}, 1032, ["value", "label"]);
					}), 128))]),
					_: 1
				}, 8, [
					"size",
					"model-value",
					"loading",
					"disabled",
					"title",
					"placeholder"
				])) : _ctx.parameter.type === "boolean" && _ctx.droppable ? (openBlock(), createBlock(unref(N8nInput_default), {
					key: 10,
					size: _ctx.inputSize,
					"model-value": JSON.stringify(displayValue.value),
					disabled: _ctx.isReadOnly,
					title: displayTitle.value
				}, null, 8, [
					"size",
					"model-value",
					"disabled",
					"title"
				])) : _ctx.parameter.type === "boolean" ? (openBlock(), createBlock(unref(ElSwitch), {
					key: 11,
					ref_key: "inputField",
					ref: inputField$2,
					class: normalizeClass({
						"switch-input": true,
						"ph-no-capture": shouldRedactValue.value
					}),
					"active-color": "#13ce66",
					"model-value": displayValue.value,
					disabled: _ctx.isReadOnly,
					"onUpdate:modelValue": valueChanged
				}, null, 8, [
					"class",
					"model-value",
					"disabled"
				])) : createCommentVNode("", true), !_ctx.isReadOnly && showDragnDropTip.value ? (openBlock(), createElementBlock("div", {
					key: 12,
					class: normalizeClass(_ctx.$style.tip)
				}, [createVNode(InlineExpressionTip_default)], 2)) : createCommentVNode("", true)], 14, _hoisted_1$14),
				_ctx.$slots.overrideButton ? (openBlock(), createElementBlock("div", {
					key: 2,
					class: normalizeClass([_ctx.$style.overrideButton, {
						[_ctx.$style.overrideButtonStandalone]: isSwitch.value,
						[_ctx.$style.overrideButtonInline]: !isSwitch.value
					}])
				}, [renderSlot(_ctx.$slots, "overrideButton", {}, void 0, true)], 2)) : createCommentVNode("", true),
				displayIssues.value ? (openBlock(), createBlock(ParameterIssues_default, {
					key: 3,
					issues: getIssues.value
				}, null, 8, ["issues"])) : createCommentVNode("", true)
			], 34);
		};
	}
});
var ParameterInput_vue_vue_type_style_index_2_lang_module_default = {
	modal: "_modal_bkqdq_2",
	tipVisible: "_tipVisible_bkqdq_20",
	tip: "_tip_bkqdq_20",
	noRightCornersInput: "_noRightCornersInput_bkqdq_38",
	overrideButton: "_overrideButton_bkqdq_43",
	overrideButtonStandalone: "_overrideButtonStandalone_bkqdq_47",
	overrideButtonInline: "_overrideButtonInline_bkqdq_53"
};
var ParameterInput_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterInput_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterInput_vue_vue_type_style_index_2_lang_module_default }], ["__scopeId", "data-v-66171f99"]]);
var _hoisted_1$13 = { "data-test-id": "parameter-input-hint" };
var ParameterInputHint_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterInputHint",
	props: {
		hint: {},
		highlight: {
			type: Boolean,
			default: false
		},
		singleLine: {
			type: Boolean,
			default: false
		},
		renderHTML: {
			type: Boolean,
			default: false
		}
	},
	setup(__props) {
		const hintTextRef = ref();
		const props = __props;
		onMounted(() => {
			if (hintTextRef.value) hintTextRef.value.querySelectorAll("a").forEach((a) => a.target = "_blank");
		});
		const simplyText = computed(() => {
			if (props.hint) return String(props.hint).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/ /g, "&nbsp;");
			return "";
		});
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return _ctx.hint ? (openBlock(), createBlock(unref(N8nText_default), {
				key: 0,
				size: "small",
				color: "text-base",
				tag: "div"
			}, {
				default: withCtx(() => [!_ctx.renderHTML ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass({
						[_ctx.$style.singleline]: _ctx.singleLine,
						[_ctx.$style.highlight]: _ctx.highlight
					})
				}, [withDirectives(createBaseVNode("span", _hoisted_1$13, null, 512), [[_directive_n8n_html, simplyText.value]])], 2)) : withDirectives((openBlock(), createElementBlock("div", {
					key: 1,
					ref_key: "hintTextRef",
					ref: hintTextRef,
					class: normalizeClass({
						[_ctx.$style.singleline]: _ctx.singleLine,
						[_ctx.$style.highlight]: _ctx.highlight
					})
				}, null, 2)), [[_directive_n8n_html, unref(sanitizeHtml)(_ctx.hint)]])]),
				_: 1
			})) : createCommentVNode("", true);
		};
	}
});
var ParameterInputHint_vue_vue_type_style_index_0_lang_module_default = {
	singleline: "_singleline_1peeu_123",
	highlight: "_highlight_1peeu_130"
};
var ParameterInputHint_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterInputHint_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterInputHint_vue_vue_type_style_index_0_lang_module_default }]]);
var import_debounce = /* @__PURE__ */ __toESM(require_debounce());
function useResolvedExpression({ expression, additionalData, isForCredential, stringifyObject, contextNodeName }) {
	const ndvStore = useNDVStore();
	const workflowsStore = useWorkflowsStore();
	const { resolveExpression } = useWorkflowHelpers();
	const expressionLocalResolveCtx = inject(ExpressionLocalResolveContextSymbol, computed(() => void 0));
	const resolvedExpression = ref(null);
	const resolvedExpressionString = ref("");
	const targetItem = computed(() => ndvStore.expressionTargetItem ?? void 0);
	const activeNode = computed(() => ndvStore.activeNode);
	const hasRunData = computed(() => Boolean(workflowsStore.workflowExecutionData?.data?.resultData?.runData[activeNode.value?.name ?? ""]));
	const isExpression$1 = computed(() => isExpression(toValue(expression)));
	function resolve(ctx) {
		const expressionString = toValue(expression);
		if (!isExpression$1.value || typeof expressionString !== "string") return {
			ok: true,
			result: ""
		};
		const options$1 = ctx ?? {
			isForCredential: toValue(isForCredential),
			additionalKeys: toValue(additionalData),
			contextNodeName: toValue(contextNodeName),
			...contextNodeName === void 0 && ndvStore.isInputParentOfActiveNode ? {
				targetItem: targetItem.value ?? void 0,
				inputNodeName: ndvStore.ndvInputNodeName,
				inputRunIndex: ndvStore.ndvInputRunIndex,
				inputBranchIndex: ndvStore.ndvInputBranchIndex
			} : {}
		};
		try {
			return createResultOk(resolveExpression(expressionString, void 0, options$1, toValue(stringifyObject) ?? true));
		} catch (error) {
			return createResultError(error);
		}
	}
	const debouncedUpdateExpression = (0, import_debounce.default)(updateExpression, 200);
	function updateExpression() {
		if (isExpression$1.value) {
			const resolved = resolve(expressionLocalResolveCtx.value);
			resolvedExpression.value = resolved.ok ? resolved.result : null;
			resolvedExpressionString.value = stringifyExpressionResult(resolved, hasRunData.value);
		} else {
			resolvedExpression.value = null;
			resolvedExpressionString.value = "";
		}
	}
	watch([
		expressionLocalResolveCtx,
		toRef(expression),
		() => workflowsStore.getWorkflowExecution,
		() => workflowsStore.getWorkflowRunData,
		() => workflowsStore.workflow.name,
		targetItem
	], debouncedUpdateExpression);
	onMounted(updateExpression);
	return {
		resolvedExpression,
		resolvedExpressionString,
		isExpression: isExpression$1
	};
}
var ParameterInputWrapper_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterInputWrapper",
	props: {
		parameter: {},
		path: {},
		modelValue: { type: [
			String,
			Number,
			Boolean,
			null,
			Object,
			Array
		] },
		additionalExpressionData: { default: () => ({}) },
		rows: { default: 5 },
		isReadOnly: { type: Boolean },
		isAssignment: { type: Boolean },
		droppable: { type: Boolean },
		activeDrop: { type: Boolean },
		forceShowExpression: { type: Boolean },
		hint: {},
		hideHint: { type: Boolean },
		inputSize: {},
		hideIssues: { type: Boolean },
		documentationUrl: {},
		errorHighlight: { type: Boolean },
		isForCredential: { type: Boolean },
		eventSource: {},
		label: { default: () => ({ size: "small" }) },
		eventBus: { default: () => createEventBus() },
		canBeOverridden: { type: Boolean }
	},
	emits: [
		"focus",
		"blur",
		"drop",
		"update",
		"textInput"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const ndvStore = useNDVStore();
		const externalSecretsStore = useExternalSecretsStore();
		const environmentsStore = environments_store_default();
		const isExpression$1 = computed(() => {
			return isValueExpression(props.parameter, props.modelValue);
		});
		const selectedRLMode = computed(() => {
			if (typeof props.modelValue !== "object" || props.parameter.type !== "resourceLocator" || !isResourceLocatorValue(props.modelValue)) return;
			const mode = props.modelValue.mode;
			if (mode) return props.parameter.modes?.find((m$1) => m$1.name === mode);
		});
		const parameterHint = computed(() => {
			if (isExpression$1.value) return;
			if (selectedRLMode.value?.hint) return selectedRLMode.value.hint;
			return props.hint;
		});
		const targetItem = computed(() => ndvStore.expressionTargetItem);
		const isInputParentOfActiveNode = computed(() => ndvStore.isInputParentOfActiveNode);
		const expression = computed(() => {
			if (!isExpression$1.value) return "";
			return isResourceLocatorValue(props.modelValue) ? props.modelValue.value : props.modelValue;
		});
		const resolvedAdditionalExpressionData = computed(() => {
			return {
				$vars: environmentsStore.variablesAsObject,
				...externalSecretsStore.isEnterpriseExternalSecretsEnabled && props.isForCredential ? { $secrets: externalSecretsStore.secretsAsObject } : {},
				...props.additionalExpressionData
			};
		});
		const { resolvedExpression, resolvedExpressionString } = useResolvedExpression({
			expression,
			additionalData: resolvedAdditionalExpressionData,
			isForCredential: props.isForCredential,
			stringifyObject: props.parameter.type !== "multiOptions"
		});
		const parsedParameterName = computed(() => {
			return parseResourceMapperFieldName(props.parameter?.name ?? "");
		});
		const expectsBinaryData = computed(() => {
			return props.parameter.name.includes("binaryPropertyName") || props.parameter.typeOptions?.binaryDataProperty;
		});
		function onFocus() {
			emit("focus");
		}
		function onBlur() {
			emit("blur");
		}
		function onDrop(data) {
			emit("drop", data);
		}
		function onValueChanged(parameterData) {
			emit("update", parameterData);
		}
		function onTextInput(parameterData) {
			emit("textInput", parameterData);
		}
		const param = useTemplateRef("param");
		__expose({
			isSingleLineInput: computed(() => param.value?.isSingleLineInput),
			displaysIssues: computed(() => param.value?.displaysIssues),
			focusInput: () => param.value?.focusInput(),
			selectInput: () => param.value?.selectInput()
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.parameterInput),
				"data-test-id": "parameter-input"
			}, [createVNode(unref(N8nTooltip_default), {
				placement: "left",
				disabled: !expectsBinaryData.value
			}, {
				content: withCtx(() => [createTextVNode(toDisplayString(unref(BINARY_DATA_ACCESS_TOOLTIP)), 1)]),
				default: withCtx(() => [createVNode(ParameterInput_default, {
					ref_key: "param",
					ref: param,
					"input-size": _ctx.inputSize,
					parameter: _ctx.parameter,
					"model-value": _ctx.modelValue,
					path: _ctx.path,
					"is-read-only": _ctx.isReadOnly,
					"is-assignment": _ctx.isAssignment,
					droppable: _ctx.droppable,
					"active-drop": _ctx.activeDrop,
					"force-show-expression": _ctx.forceShowExpression,
					"hide-issues": _ctx.hideIssues,
					"documentation-url": _ctx.documentationUrl,
					"error-highlight": _ctx.errorHighlight,
					"is-for-credential": _ctx.isForCredential,
					"event-source": _ctx.eventSource,
					"expression-evaluated": unref(resolvedExpression),
					"additional-expression-data": resolvedAdditionalExpressionData.value,
					label: _ctx.label,
					rows: _ctx.rows,
					"data-test-id": `parameter-input-${parsedParameterName.value}`,
					"event-bus": _ctx.eventBus,
					"can-be-overridden": _ctx.canBeOverridden,
					onFocus,
					onBlur,
					onDrop,
					onTextInput,
					onUpdate: onValueChanged
				}, {
					overrideButton: withCtx(() => [_ctx.$slots.overrideButton ? renderSlot(_ctx.$slots, "overrideButton", { key: 0 }) : createCommentVNode("", true)]),
					_: 3
				}, 8, [
					"input-size",
					"parameter",
					"model-value",
					"path",
					"is-read-only",
					"is-assignment",
					"droppable",
					"active-drop",
					"force-show-expression",
					"hide-issues",
					"documentation-url",
					"error-highlight",
					"is-for-credential",
					"event-source",
					"expression-evaluated",
					"additional-expression-data",
					"label",
					"rows",
					"data-test-id",
					"event-bus",
					"can-be-overridden"
				])]),
				_: 3
			}, 8, ["disabled"]), !_ctx.hideHint && (unref(resolvedExpressionString) || parameterHint.value) ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.hint)
			}, [createBaseVNode("div", null, [unref(resolvedExpressionString) ? (openBlock(), createBlock(ParameterInputHint_default, {
				key: 0,
				class: normalizeClass({
					[_ctx.$style.hint]: true,
					"ph-no-capture": _ctx.isForCredential
				}),
				"data-test-id": `parameter-expression-preview-${parsedParameterName.value}`,
				highlight: !!(unref(resolvedExpressionString) && targetItem.value) && isInputParentOfActiveNode.value,
				hint: unref(resolvedExpressionString),
				"single-line": true
			}, null, 8, [
				"class",
				"data-test-id",
				"highlight",
				"hint"
			])) : parameterHint.value ? (openBlock(), createBlock(ParameterInputHint_default, {
				key: 1,
				"render-h-t-m-l": true,
				hint: parameterHint.value
			}, null, 8, ["hint"])) : createCommentVNode("", true)]), _ctx.$slots.options ? renderSlot(_ctx.$slots, "options", { key: 0 }) : createCommentVNode("", true)], 2)) : createCommentVNode("", true)], 2);
		};
	}
});
var ParameterInputWrapper_vue_vue_type_style_index_0_lang_module_default = {
	parameterInput: "_parameterInput_teyek_123",
	hovering: "_hovering_teyek_129"
};
var ParameterInputWrapper_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterInputWrapper_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterInputWrapper_vue_vue_type_style_index_0_lang_module_default }]]);
var ParameterOptions_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterOptions",
	props: {
		parameter: {},
		isReadOnly: { type: Boolean },
		value: { type: [
			String,
			Number,
			Boolean,
			null,
			Object,
			Array
		] },
		showOptions: {
			type: Boolean,
			default: true
		},
		showExpressionSelector: {
			type: Boolean,
			default: true
		},
		customActions: { default: () => [] },
		iconOrientation: { default: "vertical" },
		loading: {
			type: Boolean,
			default: false
		},
		loadingMessage: { default: () => useI18n().baseText("genericHelpers.loading") },
		isContentOverridden: {
			type: Boolean,
			default: false
		}
	},
	emits: ["update:modelValue", "menu-expanded"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const ndvStore = useNDVStore();
		const activeNode = computed(() => ndvStore.activeNode);
		const isDefault = computed(() => props.parameter.default === props.value);
		const isValueAnExpression = computed(() => isValueExpression(props.parameter, props.value));
		const editor$5 = computed(() => getParameterTypeOption(props.parameter, "editor"));
		const shouldShowExpressionSelector = computed(() => !props.parameter.noDataExpression && props.showExpressionSelector && !props.isReadOnly);
		const isInEmbeddedNdv = useIsInExperimentalNdv();
		const experimentalNdvStore = useExperimentalNdvStore();
		const canBeOpenedInFocusPanel = computed(() => {
			if (props.parameter.isNodeSetting || props.isReadOnly || props.isContentOverridden) return false;
			if (!activeNode.value && !isInEmbeddedNdv.value) return false;
			if (experimentalNdvStore.isNdvInFocusPanelEnabled) return (props.parameter.typeOptions?.rows ?? 1) > 1 || editor$5.value !== void 0;
			return props.parameter.type === "string" || props.parameter.type === "json";
		});
		const shouldShowOptions = computed(() => {
			if (props.isReadOnly) return false;
			if (props.parameter.type === "collection" || props.parameter.type === "credentialsSelect") return false;
			if (["codeNodeEditor", "sqlEditor"].includes(props.parameter.typeOptions?.editor ?? "")) return false;
			if (props.showOptions) return true;
			return false;
		});
		const selectedView = computed(() => isValueAnExpression.value ? "expression" : "fixed");
		const hasRemoteMethod = computed(() => !!props.parameter.typeOptions?.loadOptionsMethod || !!props.parameter.typeOptions?.loadOptions);
		const resetValueLabel = computed(() => {
			if (activeNode.value && ["n8n-nodes-base.aiTransform"].includes(activeNode.value.type)) return i18n$1.baseText("parameterInput.clearContents");
			return i18n$1.baseText("parameterInput.resetValue");
		});
		const actions = computed(() => {
			if (Array.isArray(props.customActions) && props.customActions.length > 0) return props.customActions;
			if (editor$5.value === "htmlEditor" && !isValueAnExpression.value) return [{
				label: i18n$1.baseText("parameterInput.formatHtml"),
				value: "formatHtml"
			}];
			const resetAction = {
				label: resetValueLabel.value,
				value: "resetValue",
				disabled: isDefault.value
			};
			const parameterActions = [!["codeNodeEditor", "sqlEditor"].includes(props.parameter.typeOptions?.editor ?? "") ? resetAction : []].flat();
			if (hasRemoteMethod.value || props.parameter.type === "resourceLocator" && isResourceLocatorValue(props.value) && props.value.mode === "list") return [{
				label: i18n$1.baseText("parameterInput.refreshList"),
				value: "refreshOptions"
			}, ...parameterActions];
			return parameterActions;
		});
		const onMenuToggle = (visible$1) => emit("menu-expanded", visible$1);
		const onViewSelected = (selected$1) => {
			if (selected$1 === "expression") emit("update:modelValue", isValueAnExpression.value ? "openExpression" : "addExpression");
			if (selected$1 === "fixed" && isValueAnExpression.value) emit("update:modelValue", "removeExpression");
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass(_ctx.$style.container),
				"data-test-id": "parameter-options-container"
			}, [_ctx.loading ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.loader),
				"data-test-id": "parameter-options-loader"
			}, [_ctx.loading ? (openBlock(), createBlock(unref(N8nText_default), {
				key: 0,
				size: "small"
			}, {
				default: withCtx(() => [createVNode(unref(N8nIcon_default), {
					icon: "refresh-cw",
					size: "xsmall",
					spin: true
				}), createTextVNode(" " + toDisplayString(_ctx.loadingMessage), 1)]),
				_: 1
			})) : createCommentVNode("", true)], 2)) : (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(_ctx.$style.controlsContainer)
			}, [
				canBeOpenedInFocusPanel.value ? (openBlock(), createBlock(unref(N8nTooltip_default), { key: 0 }, {
					content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("parameterInput.focusParameter")), 1)]),
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						size: "medium",
						icon: "panel-right",
						class: normalizeClass(_ctx.$style.focusButton),
						onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", "focus"))
					}, null, 8, ["class"])]),
					_: 1
				})) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass({ [_ctx.$style.noExpressionSelector]: !shouldShowExpressionSelector.value }) }, [shouldShowOptions.value ? (openBlock(), createBlock(unref(N8nActionToggle_default), {
					key: 0,
					placement: "bottom-end",
					size: "small",
					color: "foreground-xdark",
					"icon-size": "small",
					actions: actions.value,
					"icon-orientation": _ctx.iconOrientation,
					onAction: _cache[1] || (_cache[1] = (action) => _ctx.$emit("update:modelValue", action)),
					onVisibleChange: onMenuToggle
				}, null, 8, ["actions", "icon-orientation"])) : createCommentVNode("", true)], 2),
				shouldShowExpressionSelector.value ? (openBlock(), createBlock(unref(N8nRadioButtons_default), {
					key: 1,
					size: "small",
					"model-value": selectedView.value,
					disabled: _ctx.isReadOnly,
					options: [{
						label: unref(i18n$1).baseText("parameterInput.fixed"),
						value: "fixed"
					}, {
						label: unref(i18n$1).baseText("parameterInput.expression"),
						value: "expression"
					}],
					"onUpdate:modelValue": onViewSelected
				}, null, 8, [
					"model-value",
					"disabled",
					"options"
				])) : createCommentVNode("", true)
			], 2))], 2);
		};
	}
});
var ParameterOptions_vue_vue_type_style_index_0_lang_module_default = {
	container: "_container_ufxfw_123",
	loader: "_loader_ufxfw_129",
	controlsContainer: "_controlsContainer_ufxfw_136",
	noExpressionSelector: "_noExpressionSelector_ufxfw_142",
	focusButton: "_focusButton_ufxfw_146"
};
var ParameterOptions_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterOptions_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterOptions_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$12 = { key: 1 };
var ParameterInputFull_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterInputFull",
	props: {
		parameter: {},
		path: {},
		value: { type: [
			String,
			Number,
			Boolean,
			null,
			Object,
			Array
		] },
		label: { default: () => ({ size: "small" }) },
		displayOptions: { type: Boolean },
		optionsPosition: { default: "top" },
		hideHint: {
			type: Boolean,
			default: false
		},
		isReadOnly: {
			type: Boolean,
			default: false
		},
		rows: { default: 5 },
		isAssignment: { type: Boolean },
		hideLabel: {
			type: Boolean,
			default: false
		},
		hideIssues: {
			type: Boolean,
			default: false
		},
		entryIndex: {}
	},
	emits: [
		"blur",
		"update",
		"hover"
	],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const toast = useToast();
		const eventBus = ref(createEventBus());
		const focused$1 = ref(false);
		const menuExpanded = ref(false);
		const forceShowExpression = ref(false);
		const wrapperHovered = ref(false);
		const ndvStore = useNDVStore();
		const telemetry = useTelemetry();
		const expressionLocalResolveCtx = inject(ExpressionLocalResolveContextSymbol, void 0);
		const activeNode = computed(() => {
			const ctx = expressionLocalResolveCtx?.value;
			if (ctx) return ctx.workflow.getNode(ctx.nodeName);
			return ndvStore.activeNode;
		});
		const fromAIOverride = ref(makeOverrideValue(props, activeNode.value));
		const canBeContentOverride = computed(() => {
			if (!activeNode.value || isResourceLocator.value) return false;
			return fromAIOverride.value !== null;
		});
		const isContentOverride = computed(() => canBeContentOverride.value && !!isFromAIOverrideValue(props.value?.toString() ?? ""));
		const hint$1 = computed(() => i18n$1.nodeText(activeNode.value?.type).hint(props.parameter, props.path));
		const isResourceLocator = computed(() => props.parameter.type === "resourceLocator" || props.parameter.type === "workflowSelector");
		const isDropDisabled = computed(() => props.parameter.noDataExpression || props.isReadOnly || isResourceLocator.value || isExpression$1.value);
		const isExpression$1 = computed(() => isValueExpression(props.parameter, props.value));
		const showExpressionSelector = computed(() => {
			if (isResourceLocator.value) {
				const value$1 = props.value && typeof props.value === "object" && "value" in props.value && props.value.value;
				if (value$1 && isFromAIOverrideValue(String(value$1))) return false;
				return !hasOnlyListMode(props.parameter);
			}
			return !isContentOverride.value;
		});
		function onFocus() {
			focused$1.value = true;
			if (!props.parameter.noDataExpression) ndvStore.setMappableNDVInputFocus(props.parameter.displayName);
			ndvStore.setFocusedInputPath(props.path ?? "");
		}
		function onBlur() {
			focused$1.value = false;
			if (!props.parameter.noDataExpression && ndvStore.focusedMappableInput === props.parameter.displayName) ndvStore.setMappableNDVInputFocus("");
			ndvStore.setFocusedInputPath("");
			emit("blur");
		}
		function onMenuExpanded(expanded) {
			menuExpanded.value = expanded;
		}
		function onWrapperMouseEnter() {
			wrapperHovered.value = true;
		}
		function onWrapperMouseLeave() {
			wrapperHovered.value = false;
		}
		function optionSelected(command) {
			if (isContentOverride.value && command === "resetValue") removeOverride(true);
			eventBus.value.emit("optionSelected", command);
		}
		function valueChanged(parameterData) {
			emit("update", parameterData);
		}
		function onTextInput(parameterData) {
			if (isValueExpression(props.parameter, parameterData.value)) eventBus.value.emit("optionSelected", "addExpression");
		}
		function onDrop(newParamValue) {
			const value$1 = props.value;
			const updatedValue = getMappedResult(props.parameter, newParamValue, value$1);
			const prevValue = isResourceLocator.value && isResourceLocatorValue(value$1) ? value$1.value : value$1;
			if (updatedValue.startsWith("=")) forceShowExpression.value = true;
			setTimeout(() => {
				if (activeNode.value) {
					let parameterData;
					if (isResourceLocator.value) if (!isResourceLocatorValue(props.value)) parameterData = {
						node: activeNode.value.name,
						name: props.path,
						value: {
							__rl: true,
							value: updatedValue,
							mode: ""
						}
					};
					else if (props.value.mode === "list" && props.parameter.modes && props.parameter.modes.length > 1) {
						let mode = props.parameter.modes.find((m$1) => m$1.name === "id") ?? null;
						if (!mode) mode = props.parameter.modes.filter((m$1) => m$1.name !== "list")[0];
						parameterData = {
							node: activeNode.value.name,
							name: props.path,
							value: {
								__rl: true,
								value: updatedValue,
								mode: mode ? mode.name : ""
							}
						};
					} else parameterData = {
						node: activeNode.value.name,
						name: props.path,
						value: {
							__rl: true,
							value: updatedValue,
							mode: props.value?.mode
						}
					};
					else parameterData = {
						node: activeNode.value.name,
						name: props.path,
						value: updatedValue
					};
					valueChanged(parameterData);
					eventBus.value.emit("drop", updatedValue);
					if (!ndvStore.isMappingOnboarded) {
						toast.showMessage({
							title: i18n$1.baseText("dataMapping.success.title"),
							message: i18n$1.baseText("dataMapping.success.moreInfo"),
							type: "success"
						});
						ndvStore.setMappingOnboarded();
					}
					ndvStore.setMappingTelemetry({
						dest_node_type: activeNode.value.type,
						dest_parameter: props.path,
						dest_parameter_mode: typeof prevValue === "string" && prevValue.startsWith("=") ? "expression" : "fixed",
						dest_parameter_empty: prevValue === "" || prevValue === void 0,
						dest_parameter_had_mapping: typeof prevValue === "string" && prevValue.startsWith("=") && hasExpressionMapping(prevValue),
						success: true
					});
				}
				forceShowExpression.value = false;
			}, 200);
		}
		const showOverrideButton = computed(() => canBeContentOverride.value && !isContentOverride.value && !props.isReadOnly);
		watch(() => props.isReadOnly, (isReadOnly) => {
			if (isReadOnly && props.parameter.disabledOptions !== void 0) valueChanged({
				name: props.path,
				value: props.parameter.default
			});
		});
		watch(wrapperHovered, (hovered) => {
			emit("hover", hovered);
		});
		const parameterInputWrapper = useTemplateRef("parameterInputWrapper");
		const isSingleLineInput = computed(() => parameterInputWrapper.value?.isSingleLineInput ?? false);
		function applyOverride() {
			if (!fromAIOverride.value) return;
			telemetry.track("User turned on fromAI override", {
				nodeType: activeNode.value?.type,
				parameter: props.path
			});
			updateFromAIOverrideValues(fromAIOverride.value, String(props.value));
			const value$1 = buildValueFromOverride(fromAIOverride.value, props, true);
			valueChanged({
				node: activeNode.value?.name,
				name: props.path,
				value: value$1
			});
		}
		function removeOverride(clearField = false) {
			if (!fromAIOverride.value) return;
			telemetry.track("User turned off fromAI override", {
				nodeType: activeNode.value?.type,
				parameter: props.path
			});
			valueChanged({
				node: activeNode.value?.name,
				name: props.path,
				value: clearField ? props.parameter.default : buildValueFromOverride(fromAIOverride.value, props, false)
			});
			setTimeout(async () => {
				await parameterInputWrapper.value?.focusInput();
				parameterInputWrapper.value?.selectInput();
			}, 0);
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nInputLabel_default), {
				ref: "inputLabel",
				class: normalizeClass([_ctx.$style.wrapper]),
				label: _ctx.hideLabel ? "" : unref(i18n$1).nodeText(activeNode.value?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path),
				"tooltip-text": _ctx.hideLabel ? "" : unref(i18n$1).nodeText(activeNode.value?.type).inputLabelDescription(_ctx.parameter, _ctx.path),
				"show-tooltip": focused$1.value,
				"show-options": menuExpanded.value || focused$1.value || forceShowExpression.value,
				"options-position": _ctx.optionsPosition,
				bold: false,
				size: _ctx.label.size,
				"input-name": _ctx.parameter.name,
				color: "text-dark",
				onMouseenter: onWrapperMouseEnter,
				onMouseleave: onWrapperMouseLeave
			}, createSlots({
				default: withCtx(() => [
					createVNode(DraggableTarget_default, {
						type: "mapping",
						disabled: isDropDisabled.value,
						sticky: "",
						"sticky-offset": [3, 3],
						onDrop
					}, {
						default: withCtx(({ droppable: droppable$10, activeDrop: activeDrop$8 }) => [fromAIOverride.value && isContentOverride.value ? (openBlock(), createBlock(FromAiOverrideField_default, {
							key: 0,
							"is-read-only": _ctx.isReadOnly,
							onClose: removeOverride
						}, null, 8, ["is-read-only"])) : (openBlock(), createElementBlock("div", _hoisted_1$12, [createVNode(ParameterInputWrapper_default, {
							ref_key: "parameterInputWrapper",
							ref: parameterInputWrapper,
							parameter: _ctx.parameter,
							"model-value": _ctx.value,
							path: _ctx.path,
							"is-read-only": _ctx.isReadOnly,
							"is-assignment": _ctx.isAssignment,
							rows: _ctx.rows,
							droppable: droppable$10,
							"active-drop": activeDrop$8,
							"force-show-expression": forceShowExpression.value,
							hint: hint$1.value,
							"hide-hint": _ctx.hideHint,
							"hide-issues": _ctx.hideIssues,
							label: _ctx.label,
							"event-bus": eventBus.value,
							"can-be-overridden": canBeContentOverride.value,
							"input-size": "small",
							onUpdate: valueChanged,
							onTextInput,
							onFocus,
							onBlur,
							onDrop
						}, createSlots({ _: 2 }, [showOverrideButton.value && isSingleLineInput.value ? {
							name: "overrideButton",
							fn: withCtx(() => [createVNode(FromAiOverrideButton_default, { onClick: applyOverride })]),
							key: "0"
						} : void 0]), 1032, [
							"parameter",
							"model-value",
							"path",
							"is-read-only",
							"is-assignment",
							"rows",
							"droppable",
							"active-drop",
							"force-show-expression",
							"hint",
							"hide-hint",
							"hide-issues",
							"label",
							"event-bus",
							"can-be-overridden"
						])]))]),
						_: 1
					}, 8, ["disabled"]),
					createBaseVNode("div", { class: normalizeClass({
						[_ctx.$style.options]: true,
						[_ctx.$style.visible]: menuExpanded.value || focused$1.value || forceShowExpression.value
					}) }, [_ctx.optionsPosition === "bottom" ? (openBlock(), createBlock(ParameterOptions_default, {
						key: 0,
						parameter: _ctx.parameter,
						value: _ctx.value,
						"is-read-only": _ctx.isReadOnly,
						"show-options": _ctx.displayOptions,
						"show-expression-selector": showExpressionSelector.value,
						"is-content-overridden": isContentOverride.value,
						"onUpdate:modelValue": optionSelected,
						onMenuExpanded
					}, null, 8, [
						"parameter",
						"value",
						"is-read-only",
						"show-options",
						"show-expression-selector",
						"is-content-overridden"
					])) : createCommentVNode("", true)], 2),
					isContentOverride.value && fromAIOverride.value ? (openBlock(), createBlock(ParameterOverrideSelectableList_default, {
						key: 0,
						modelValue: fromAIOverride.value,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => fromAIOverride.value = $event),
						parameter: _ctx.parameter,
						path: _ctx.path,
						"is-read-only": _ctx.isReadOnly,
						onUpdate: valueChanged
					}, null, 8, [
						"modelValue",
						"parameter",
						"path",
						"is-read-only"
					])) : createCommentVNode("", true)
				]),
				_: 2
			}, [showOverrideButton.value && !isSingleLineInput.value && _ctx.optionsPosition === "top" ? {
				name: "persistentOptions",
				fn: withCtx(() => [createBaseVNode("div", { class: normalizeClass([
					_ctx.$style.noCornersBottom,
					_ctx.$style.overrideButtonInOptions,
					{ [_ctx.$style.overrideButtonIssueOffset]: unref(parameterInputWrapper)?.displaysIssues }
				]) }, [createVNode(FromAiOverrideButton_default, { onClick: applyOverride })], 2)]),
				key: "0"
			} : void 0, _ctx.displayOptions && _ctx.optionsPosition === "top" ? {
				name: "options",
				fn: withCtx(() => [createVNode(ParameterOptions_default, {
					parameter: _ctx.parameter,
					value: _ctx.value,
					"is-read-only": _ctx.isReadOnly,
					"show-options": _ctx.displayOptions,
					"show-expression-selector": showExpressionSelector.value,
					"is-content-overridden": isContentOverride.value,
					"onUpdate:modelValue": optionSelected,
					onMenuExpanded
				}, null, 8, [
					"parameter",
					"value",
					"is-read-only",
					"show-options",
					"show-expression-selector",
					"is-content-overridden"
				])]),
				key: "1"
			} : void 0]), 1032, [
				"class",
				"label",
				"tooltip-text",
				"show-tooltip",
				"show-options",
				"options-position",
				"size",
				"input-name"
			]);
		};
	}
});
var ParameterInputFull_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_114s6_123",
	options: "_options_114s6_126",
	overrideButtonInOptions: "_overrideButtonInOptions_114s6_130",
	overrideButtonIssueOffset: "_overrideButtonIssueOffset_114s6_135",
	noCornersBottom: "_noCornersBottom_114s6_140",
	visible: "_visible_114s6_153"
};
var ParameterInputFull_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ParameterInputFull_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ParameterInputFull_vue_vue_type_style_index_0_lang_module_default }]]);
var DropArea_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "DropArea",
	emits: ["drop"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const onDrop = (value$1) => {
			emit("drop", value$1);
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(DraggableTarget_default, {
				type: "mapping",
				onDrop
			}, {
				default: withCtx(({ droppable: droppable$10, activeDrop: activeDrop$8 }) => [createBaseVNode("div", {
					"data-test-id": "drop-area",
					class: normalizeClass({
						[_ctx.$style.area]: true,
						[_ctx.$style.active]: activeDrop$8,
						[_ctx.$style.droppable]: droppable$10
					})
				}, [renderSlot(_ctx.$slots, "default", {
					active: activeDrop$8,
					droppable: droppable$10
				})], 2)]),
				_: 3
			});
		};
	}
});
var DropArea_vue_vue_type_style_index_0_lang_module_default = {
	area: "_area_ybelb_123",
	active: "_active_ybelb_135",
	droppable: "_droppable_ybelb_140"
};
var DropArea_default = /* @__PURE__ */ __plugin_vue_export_helper_default(DropArea_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": DropArea_vue_vue_type_style_index_0_lang_module_default }]]);
var InputTriple_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "InputTriple",
	props: { middleWidth: { default: "160px" } },
	setup(__props) {
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(ResizeObserver_default), {
				class: normalizeClass({ [_ctx.$style.observer]: true }),
				breakpoints: [{
					bp: "stacked",
					width: 400
				}, {
					bp: "medium",
					width: 680
				}]
			}, {
				default: withCtx(({ bp }) => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.background) }, null, 2), createBaseVNode("div", { class: normalizeClass({
					[_ctx.$style.triple]: true,
					[_ctx.$style.stacked]: bp === "stacked",
					[_ctx.$style.medium]: bp === "medium",
					[_ctx.$style.default]: bp === "default",
					[_ctx.$style.noRightSlot]: !_ctx.$slots.right,
					[_ctx.$style.noMiddleSlot]: !_ctx.$slots.middle
				}) }, [
					_ctx.$slots.left ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.item)
					}, [renderSlot(_ctx.$slots, "left", { breakpoint: bp })], 2)) : createCommentVNode("", true),
					_ctx.$slots.middle ? (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass([_ctx.$style.item, _ctx.$style.middle]),
						style: normalizeStyle({ flexBasis: _ctx.middleWidth })
					}, [renderSlot(_ctx.$slots, "middle", { breakpoint: bp })], 6)) : createCommentVNode("", true),
					_ctx.$slots.right ? (openBlock(), createElementBlock("div", {
						key: 2,
						class: normalizeClass(_ctx.$style.item)
					}, [renderSlot(_ctx.$slots, "right", { breakpoint: bp })], 2)) : createCommentVNode("", true)
				], 2)]),
				_: 3
			}, 8, ["class"]);
		};
	}
});
const triple = "_triple_1j7zy_123";
const observer = "_observer_1j7zy_129";
const background = "_background_1j7zy_135";
const item = "_item_1j7zy_146";
const middle = "_middle_1j7zy_162";
const medium = "_medium_1j7zy_182";
const noRightSlot = "_noRightSlot_1j7zy_182";
const stacked = "_stacked_1j7zy_204";
var InputTriple_vue_vue_type_style_index_0_lang_module_default = {
	triple,
	observer,
	background,
	item,
	"default": "_default_1j7zy_158",
	middle,
	medium,
	noRightSlot,
	stacked
};
var InputTriple_default = /* @__PURE__ */ __plugin_vue_export_helper_default(InputTriple_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": InputTriple_vue_vue_type_style_index_0_lang_module_default }]]);
const ASSIGNMENT_TYPES = [
	{
		type: "string",
		icon: DATA_TYPE_ICON_MAP.string
	},
	{
		type: "number",
		icon: DATA_TYPE_ICON_MAP.number
	},
	{
		type: "boolean",
		icon: DATA_TYPE_ICON_MAP.boolean
	},
	{
		type: "array",
		icon: DATA_TYPE_ICON_MAP.array
	},
	{
		type: "object",
		icon: DATA_TYPE_ICON_MAP.object
	},
	{
		type: "binary",
		icon: DATA_TYPE_ICON_MAP.file
	}
];
var TypeSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TypeSelect",
	props: {
		modelValue: {},
		isReadOnly: { type: Boolean }
	},
	emits: ["update:model-value"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const types = ASSIGNMENT_TYPES;
		const icon$4 = computed(() => types.find((type) => type.type === props.modelValue)?.icon ?? "box");
		const onTypeChange = (type) => {
			emit("update:model-value", type);
		};
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nSelect_default), {
				"data-test-id": "assignment-type-select",
				size: "small",
				"model-value": _ctx.modelValue,
				disabled: _ctx.isReadOnly,
				"onUpdate:modelValue": onTypeChange
			}, {
				prefix: withCtx(() => [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.icon),
					icon: icon$4.value,
					color: "text-light",
					size: "small"
				}, null, 8, ["class", "icon"])]),
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(types), (option$1) => {
					return openBlock(), createBlock(unref(N8nOption_default), {
						key: option$1.type,
						value: option$1.type,
						label: unref(i18n$1).baseText(`type.${option$1.type}`),
						class: normalizeClass(_ctx.$style.option)
					}, {
						default: withCtx(() => [createVNode(unref(N8nIcon_default), {
							icon: option$1.icon,
							color: _ctx.modelValue === option$1.type ? "primary" : "text-light",
							size: "small"
						}, null, 8, ["icon", "color"]), createBaseVNode("span", null, toDisplayString(unref(i18n$1).baseText(`type.${option$1.type}`)), 1)]),
						_: 2
					}, 1032, [
						"value",
						"label",
						"class"
					]);
				}), 128))]),
				_: 1
			}, 8, ["model-value", "disabled"]);
		};
	}
});
var TypeSelect_vue_vue_type_style_index_0_lang_module_default = {
	icon: "_icon_1ci1i_123",
	option: "_option_1ci1i_127"
};
var TypeSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(TypeSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": TypeSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var Assignment_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Assignment",
	props: {
		path: {},
		modelValue: {},
		issues: {},
		hideType: { type: Boolean },
		disableType: { type: Boolean },
		isReadOnly: { type: Boolean },
		index: {}
	},
	emits: ["update:model-value", "remove"],
	setup(__props, { emit: __emit }) {
		const assignment$2 = ref(__props.modelValue);
		const valueInputHovered = ref(false);
		const emit = __emit;
		const i18n$1 = useI18n();
		const ndvStore = useNDVStore();
		const environmentsStore = environments_store_default();
		const assignmentTypeToNodeProperty = (type) => {
			switch (type) {
				case "boolean": return {
					type: "options",
					default: false,
					options: [{
						name: "false",
						value: false
					}, {
						name: "true",
						value: true
					}]
				};
				case "array":
				case "object":
				case "binary": return { type: "string" };
				case "any": return { type: "string" };
				default: return { type };
			}
		};
		const nameParameter = computed(() => ({
			name: "name",
			displayName: "Name",
			default: "",
			requiresDataPath: "single",
			placeholder: "name",
			type: "string"
		}));
		const valueParameter = computed(() => {
			return {
				name: "value",
				displayName: "Value",
				default: "",
				placeholder: assignment$2.value.type === "binary" ? i18n$1.baseText("assignment.binaryData.placeholder") : "value",
				...assignmentTypeToNodeProperty(assignment$2.value.type ?? "string")
			};
		});
		const { resolvedExpressionString, isExpression: isExpression$1 } = useResolvedExpression({
			expression: computed(() => assignment$2.value.value),
			additionalData: computed(() => {
				return { $vars: environmentsStore.variablesAsObject };
			})
		});
		const hint$1 = computed(() => resolvedExpressionString.value);
		const highlightHint = computed(() => Boolean(hint$1.value && ndvStore.getHoveringItem));
		const onAssignmentNameChange = (update) => {
			assignment$2.value.name = update.value;
		};
		const onAssignmentTypeChange = (update) => {
			assignment$2.value.type = update;
			if (update === "boolean" && !isExpression$1.value) assignment$2.value.value = false;
		};
		const onAssignmentValueChange = (update) => {
			assignment$2.value.value = update.value;
		};
		const onRemove = () => {
			emit("remove");
		};
		const onBlur = () => {
			emit("update:model-value", assignment$2.value);
		};
		const onValueInputHoverChange = (hovered) => {
			valueInputHovered.value = hovered;
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass({
					[_ctx.$style.wrapper]: true,
					[_ctx.$style.hasIssues]: _ctx.issues.length > 0,
					[_ctx.$style.hasHint]: !!hint$1.value
				}),
				"data-test-id": "assignment"
			}, [
				!_ctx.isReadOnly ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 0,
					type: "tertiary",
					text: "",
					size: "small",
					icon: "grip-vertical",
					class: normalizeClass([
						_ctx.$style.iconButton,
						_ctx.$style.defaultTopPadding,
						"drag-handle"
					])
				}, null, 8, ["class"])) : createCommentVNode("", true),
				!_ctx.isReadOnly ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 1,
					type: "tertiary",
					text: "",
					size: "small",
					icon: "trash-2",
					"data-test-id": "assignment-remove",
					class: normalizeClass([_ctx.$style.iconButton, _ctx.$style.extraTopPadding]),
					onClick: onRemove
				}, null, 8, ["class"])) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.inputs) }, [createVNode(InputTriple_default, { "middle-width": "100px" }, createSlots({
					left: withCtx(() => [(openBlock(), createBlock(ParameterInputFull_default, {
						key: nameParameter.value.type,
						"display-options": "",
						"hide-label": "",
						"hide-hint": "",
						"is-read-only": _ctx.isReadOnly,
						parameter: nameParameter.value,
						value: assignment$2.value.name,
						path: `${_ctx.path}.name`,
						"data-test-id": "assignment-name",
						onUpdate: onAssignmentNameChange,
						onBlur
					}, null, 8, [
						"is-read-only",
						"parameter",
						"value",
						"path"
					]))]),
					right: withCtx(({ breakpoint }) => [createBaseVNode("div", { class: normalizeClass(_ctx.$style.value) }, [(openBlock(), createBlock(ParameterInputFull_default, {
						key: valueParameter.value.type,
						"display-options": "",
						"hide-label": "",
						"hide-issues": "",
						"hide-hint": "",
						"is-assignment": "",
						"is-read-only": _ctx.isReadOnly,
						"options-position": breakpoint === "default" ? "top" : "bottom",
						parameter: valueParameter.value,
						value: assignment$2.value.value,
						path: `${_ctx.path}.value`,
						"data-test-id": "assignment-value",
						onUpdate: onAssignmentValueChange,
						onBlur,
						onHover: onValueInputHoverChange
					}, null, 8, [
						"is-read-only",
						"options-position",
						"parameter",
						"value",
						"path"
					])), unref(resolvedExpressionString) ? (openBlock(), createBlock(ParameterInputHint_default, {
						key: 0,
						"data-test-id": "parameter-expression-preview-value",
						class: normalizeClass({
							[_ctx.$style.hint]: true,
							[_ctx.$style.optionsPadding]: breakpoint !== "default" && !_ctx.isReadOnly && valueInputHovered.value
						}),
						highlight: highlightHint.value,
						hint: hint$1.value,
						"single-line": ""
					}, null, 8, [
						"class",
						"highlight",
						"hint"
					])) : createCommentVNode("", true)], 2)]),
					_: 2
				}, [!_ctx.hideType ? {
					name: "middle",
					fn: withCtx(() => [createVNode(unref(N8nTooltip_default), {
						placement: "left",
						disabled: assignment$2.value.type !== "binary"
					}, {
						content: withCtx(() => [createTextVNode(toDisplayString(unref(BINARY_DATA_ACCESS_TOOLTIP)), 1)]),
						default: withCtx(() => [createVNode(TypeSelect_default, {
							class: normalizeClass(_ctx.$style.select),
							"model-value": assignment$2.value.type ?? "string",
							"is-read-only": _ctx.disableType || _ctx.isReadOnly,
							"onUpdate:modelValue": onAssignmentTypeChange
						}, null, 8, [
							"class",
							"model-value",
							"is-read-only"
						])]),
						_: 1
					}, 8, ["disabled"])]),
					key: "0"
				} : void 0]), 1024)], 2),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.status) }, [_ctx.issues.length > 0 ? (openBlock(), createBlock(ParameterIssues_default, {
					key: 0,
					issues: _ctx.issues
				}, null, 8, ["issues"])) : createCommentVNode("", true)], 2)
			], 2);
		};
	}
});
var Assignment_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_mc247_123",
	hasIssues: "_hasIssues_mc247_129",
	hasHint: "_hasHint_mc247_132",
	iconButton: "_iconButton_mc247_135",
	inputs: "_inputs_mc247_139",
	value: "_value_mc247_149",
	hint: "_hint_mc247_152",
	optionsPadding: "_optionsPadding_mc247_159",
	extraTopPadding: "_extraTopPadding_mc247_171",
	defaultTopPadding: "_defaultTopPadding_mc247_175",
	status: "_status_mc247_179",
	statusIcon: "_statusIcon_mc247_184"
};
var Assignment_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Assignment_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Assignment_vue_vue_type_style_index_0_lang_module_default }]]);
var import_isObject = /* @__PURE__ */ __toESM(require_isObject());
function inferAssignmentType(value$1) {
	if (typeof value$1 === "boolean") return "boolean";
	if (typeof value$1 === "number") return "number";
	if (typeof value$1 === "string") return "string";
	if (Array.isArray(value$1)) return "array";
	if ((0, import_isObject.default)(value$1)) return "object";
	return "string";
}
function typeFromExpression(expression) {
	try {
		return inferAssignmentType(resolveParameter(`=${expression}`));
	} catch (error) {
		return "string";
	}
}
function inputDataToAssignments(input$5) {
	const assignments$1 = [];
	function processValue(value$1, path = []) {
		if (Array.isArray(value$1)) value$1.forEach((element, index$1) => {
			processValue(element, [...path, index$1]);
		});
		else if ((0, import_isObject.default)(value$1)) for (const [key, objectValue] of Object.entries(value$1)) processValue(objectValue, [...path, key]);
		else {
			const stringPath = path.reduce((fullPath, part) => {
				if (typeof part === "number") return `${fullPath}[${part}]`;
				return `${fullPath}.${part}`;
			}, "$json");
			const expression = `={{ ${stringPath} }}`;
			assignments$1.push({
				id: v4_default(),
				name: stringPath.replace("$json.", ""),
				value: expression,
				type: inferAssignmentType(value$1)
			});
		}
	}
	processValue(input$5);
	return assignments$1;
}
var sortable_esm_exports = /* @__PURE__ */ __export({
	MultiDrag: () => MultiDragPlugin,
	Sortable: () => Sortable,
	Swap: () => SwapPlugin,
	default: () => sortable_esm_default
});
/**!
* Sortable 1.14.0
* @author	RubaXa   <trash@rubaxa.org>
* @author	owenm    <owen23355@gmail.com>
* @license MIT
*/
function ownKeys(object, enumerableOnly) {
	var keys = Object.keys(object);
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		if (enumerableOnly) symbols = symbols.filter(function(sym) {
			return Object.getOwnPropertyDescriptor(object, sym).enumerable;
		});
		keys.push.apply(keys, symbols);
	}
	return keys;
}
function _objectSpread2(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
		else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
		else ownKeys(Object(source)).forEach(function(key) {
			Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		});
	}
	return target;
}
function _typeof(obj) {
	"@babel/helpers - typeof";
	if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function(obj$1) {
		return typeof obj$1;
	};
	else _typeof = function(obj$1) {
		return obj$1 && typeof Symbol === "function" && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
	};
	return _typeof(obj);
}
function _defineProperty(obj, key, value$1) {
	if (key in obj) Object.defineProperty(obj, key, {
		value: value$1,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value$1;
	return obj;
}
function _extends() {
	_extends = Object.assign || function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _toConsumableArray(arr) {
	return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function userAgent(pattern) {
	if (typeof window !== "undefined" && window.navigator) return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
}
function on(el$1, event, fn$2) {
	el$1.addEventListener(event, fn$2, !IE11OrLess && captureMode);
}
function off(el$1, event, fn$2) {
	el$1.removeEventListener(event, fn$2, !IE11OrLess && captureMode);
}
function matches(el$1, selector) {
	if (!selector) return;
	selector[0] === ">" && (selector = selector.substring(1));
	if (el$1) try {
		if (el$1.matches) return el$1.matches(selector);
		else if (el$1.msMatchesSelector) return el$1.msMatchesSelector(selector);
		else if (el$1.webkitMatchesSelector) return el$1.webkitMatchesSelector(selector);
	} catch (_$2) {
		return false;
	}
	return false;
}
function getParentOrHost(el$1) {
	return el$1.host && el$1 !== document && el$1.host.nodeType ? el$1.host : el$1.parentNode;
}
function closest(el$1, selector, ctx, includeCTX) {
	if (el$1) {
		ctx = ctx || document;
		do {
			if (selector != null && (selector[0] === ">" ? el$1.parentNode === ctx && matches(el$1, selector) : matches(el$1, selector)) || includeCTX && el$1 === ctx) return el$1;
			if (el$1 === ctx) break;
		} while (el$1 = getParentOrHost(el$1));
	}
	return null;
}
function toggleClass(el$1, name, state) {
	if (el$1 && name) if (el$1.classList) el$1.classList[state ? "add" : "remove"](name);
	else el$1.className = ((" " + el$1.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ") + (state ? " " + name : "")).replace(R_SPACE, " ");
}
function css(el$1, prop, val) {
	var style = el$1 && el$1.style;
	if (style) if (val === void 0) {
		if (document.defaultView && document.defaultView.getComputedStyle) val = document.defaultView.getComputedStyle(el$1, "");
		else if (el$1.currentStyle) val = el$1.currentStyle;
		return prop === void 0 ? val : val[prop];
	} else {
		if (!(prop in style) && prop.indexOf("webkit") === -1) prop = "-webkit-" + prop;
		style[prop] = val + (typeof val === "string" ? "" : "px");
	}
}
function matrix(el$1, selfOnly) {
	var appliedTransforms = "";
	if (typeof el$1 === "string") appliedTransforms = el$1;
	else do {
		var transform = css(el$1, "transform");
		if (transform && transform !== "none") appliedTransforms = transform + " " + appliedTransforms;
	} while (!selfOnly && (el$1 = el$1.parentNode));
	var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
	return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
	if (ctx) {
		var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
		if (iterator) for (; i < n; i++) iterator(list[i], i);
		return list;
	}
	return [];
}
function getWindowScrollingElement() {
	var scrollingElement = document.scrollingElement;
	if (scrollingElement) return scrollingElement;
	else return document.documentElement;
}
function getRect(el$1, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container$4) {
	if (!el$1.getBoundingClientRect && el$1 !== window) return;
	var elRect, top, left, bottom, right, height, width;
	if (el$1 !== window && el$1.parentNode && el$1 !== getWindowScrollingElement()) {
		elRect = el$1.getBoundingClientRect();
		top = elRect.top;
		left = elRect.left;
		bottom = elRect.bottom;
		right = elRect.right;
		height = elRect.height;
		width = elRect.width;
	} else {
		top = 0;
		left = 0;
		bottom = window.innerHeight;
		right = window.innerWidth;
		height = window.innerHeight;
		width = window.innerWidth;
	}
	if ((relativeToContainingBlock || relativeToNonStaticParent) && el$1 !== window) {
		container$4 = container$4 || el$1.parentNode;
		if (!IE11OrLess) do
			if (container$4 && container$4.getBoundingClientRect && (css(container$4, "transform") !== "none" || relativeToNonStaticParent && css(container$4, "position") !== "static")) {
				var containerRect = container$4.getBoundingClientRect();
				top -= containerRect.top + parseInt(css(container$4, "border-top-width"));
				left -= containerRect.left + parseInt(css(container$4, "border-left-width"));
				bottom = top + elRect.height;
				right = left + elRect.width;
				break;
			}
		while (container$4 = container$4.parentNode);
	}
	if (undoScale && el$1 !== window) {
		var elMatrix = matrix(container$4 || el$1), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
		if (elMatrix) {
			top /= scaleY;
			left /= scaleX;
			width /= scaleX;
			height /= scaleY;
			bottom = top + height;
			right = left + width;
		}
	}
	return {
		top,
		left,
		bottom,
		right,
		width,
		height
	};
}
function isScrolledPast(el$1, elSide, parentSide) {
	var parent$2 = getParentAutoScrollElement(el$1, true), elSideVal = getRect(el$1)[elSide];
	while (parent$2) {
		var parentSideVal = getRect(parent$2)[parentSide], visible$1 = void 0;
		if (parentSide === "top" || parentSide === "left") visible$1 = elSideVal >= parentSideVal;
		else visible$1 = elSideVal <= parentSideVal;
		if (!visible$1) return parent$2;
		if (parent$2 === getWindowScrollingElement()) break;
		parent$2 = getParentAutoScrollElement(parent$2, false);
	}
	return false;
}
function getChild(el$1, childNum, options$1, includeDragEl) {
	var currentChild = 0, i = 0, children = el$1.children;
	while (i < children.length) {
		if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options$1.draggable, el$1, false)) {
			if (currentChild === childNum) return children[i];
			currentChild++;
		}
		i++;
	}
	return null;
}
function lastChild(el$1, selector) {
	var last$2 = el$1.lastElementChild;
	while (last$2 && (last$2 === Sortable.ghost || css(last$2, "display") === "none" || selector && !matches(last$2, selector))) last$2 = last$2.previousElementSibling;
	return last$2 || null;
}
function index(el$1, selector) {
	var index$1 = 0;
	if (!el$1 || !el$1.parentNode) return -1;
	while (el$1 = el$1.previousElementSibling) if (el$1.nodeName.toUpperCase() !== "TEMPLATE" && el$1 !== Sortable.clone && (!selector || matches(el$1, selector))) index$1++;
	return index$1;
}
function getRelativeScrollOffset(el$1) {
	var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
	if (el$1) do {
		var elMatrix = matrix(el$1), scaleX = elMatrix.a, scaleY = elMatrix.d;
		offsetLeft += el$1.scrollLeft * scaleX;
		offsetTop += el$1.scrollTop * scaleY;
	} while (el$1 !== winScroller && (el$1 = el$1.parentNode));
	return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
	for (var i in arr) {
		if (!arr.hasOwnProperty(i)) continue;
		for (var key in obj) if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
	}
	return -1;
}
function getParentAutoScrollElement(el$1, includeSelf) {
	if (!el$1 || !el$1.getBoundingClientRect) return getWindowScrollingElement();
	var elem = el$1;
	var gotSelf = false;
	do
		if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
			var elemCSS = css(elem);
			if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
				if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
				if (gotSelf || includeSelf) return elem;
				gotSelf = true;
			}
		}
	while (elem = elem.parentNode);
	return getWindowScrollingElement();
}
function extend(dst, src) {
	if (dst && src) {
		for (var key in src) if (src.hasOwnProperty(key)) dst[key] = src[key];
	}
	return dst;
}
function isRectEqual(rect1, rect2) {
	return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
function throttle(callback, ms$1) {
	return function() {
		if (!_throttleTimeout) {
			var args = arguments, _this = this;
			if (args.length === 1) callback.call(_this, args[0]);
			else callback.apply(_this, args);
			_throttleTimeout = setTimeout(function() {
				_throttleTimeout = void 0;
			}, ms$1);
		}
	};
}
function cancelThrottle() {
	clearTimeout(_throttleTimeout);
	_throttleTimeout = void 0;
}
function scrollBy(el$1, x, y$1) {
	el$1.scrollLeft += x;
	el$1.scrollTop += y$1;
}
function clone(el$1) {
	var Polymer = window.Polymer;
	var $$1 = window.jQuery || window.Zepto;
	if (Polymer && Polymer.dom) return Polymer.dom(el$1).cloneNode(true);
	else if ($$1) return $$1(el$1).clone(true)[0];
	else return el$1.cloneNode(true);
}
function setRect(el$1, rect) {
	css(el$1, "position", "absolute");
	css(el$1, "top", rect.top);
	css(el$1, "left", rect.left);
	css(el$1, "width", rect.width);
	css(el$1, "height", rect.height);
}
function unsetRect(el$1) {
	css(el$1, "position", "");
	css(el$1, "top", "");
	css(el$1, "left", "");
	css(el$1, "width", "");
	css(el$1, "height", "");
}
function AnimationStateManager() {
	var animationStates = [], animationCallbackId;
	return {
		captureAnimationState: function captureAnimationState() {
			animationStates = [];
			if (!this.options.animation) return;
			[].slice.call(this.el.children).forEach(function(child) {
				if (css(child, "display") === "none" || child === Sortable.ghost) return;
				animationStates.push({
					target: child,
					rect: getRect(child)
				});
				var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
				if (child.thisAnimationDuration) {
					var childMatrix = matrix(child, true);
					if (childMatrix) {
						fromRect.top -= childMatrix.f;
						fromRect.left -= childMatrix.e;
					}
				}
				child.fromRect = fromRect;
			});
		},
		addAnimationState: function addAnimationState(state) {
			animationStates.push(state);
		},
		removeAnimationState: function removeAnimationState(target) {
			animationStates.splice(indexOfObject(animationStates, { target }), 1);
		},
		animateAll: function animateAll(callback) {
			var _this = this;
			if (!this.options.animation) {
				clearTimeout(animationCallbackId);
				if (typeof callback === "function") callback();
				return;
			}
			var animating = false, animationTime = 0;
			animationStates.forEach(function(state) {
				var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
				if (targetMatrix) {
					toRect.top -= targetMatrix.f;
					toRect.left -= targetMatrix.e;
				}
				target.toRect = toRect;
				if (target.thisAnimationDuration) {
					if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
				}
				if (!isRectEqual(toRect, fromRect)) {
					target.prevFromRect = fromRect;
					target.prevToRect = toRect;
					if (!time) time = _this.options.animation;
					_this.animate(target, animatingRect, toRect, time);
				}
				if (time) {
					animating = true;
					animationTime = Math.max(animationTime, time);
					clearTimeout(target.animationResetTimer);
					target.animationResetTimer = setTimeout(function() {
						target.animationTime = 0;
						target.prevFromRect = null;
						target.fromRect = null;
						target.prevToRect = null;
						target.thisAnimationDuration = null;
					}, time);
					target.thisAnimationDuration = time;
				}
			});
			clearTimeout(animationCallbackId);
			if (!animating) {
				if (typeof callback === "function") callback();
			} else animationCallbackId = setTimeout(function() {
				if (typeof callback === "function") callback();
			}, animationTime);
			animationStates = [];
		},
		animate: function animate(target, currentRect, toRect, duration) {
			if (duration) {
				css(target, "transition", "");
				css(target, "transform", "");
				var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
				target.animatingX = !!translateX;
				target.animatingY = !!translateY;
				css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
				this.forRepaintDummy = repaint(target);
				css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
				css(target, "transform", "translate3d(0,0,0)");
				typeof target.animated === "number" && clearTimeout(target.animated);
				target.animated = setTimeout(function() {
					css(target, "transition", "");
					css(target, "transform", "");
					target.animated = false;
					target.animatingX = false;
					target.animatingY = false;
				}, duration);
			}
		}
	};
}
function repaint(target) {
	return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options$1) {
	return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options$1.animation;
}
function dispatchEvent(_ref) {
	var sortable = _ref.sortable, rootEl$1 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl$1 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex$1 = _ref.oldIndex, newIndex$1 = _ref.newIndex, oldDraggableIndex$1 = _ref.oldDraggableIndex, newDraggableIndex$1 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable$1 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
	sortable = sortable || rootEl$1 && rootEl$1[expando];
	if (!sortable) return;
	var evt, options$1 = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
	if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent(name, {
		bubbles: true,
		cancelable: true
	});
	else {
		evt = document.createEvent("Event");
		evt.initEvent(name, true, true);
	}
	evt.to = toEl || rootEl$1;
	evt.from = fromEl || rootEl$1;
	evt.item = targetEl || rootEl$1;
	evt.clone = cloneEl$1;
	evt.oldIndex = oldIndex$1;
	evt.newIndex = newIndex$1;
	evt.oldDraggableIndex = oldDraggableIndex$1;
	evt.newDraggableIndex = newDraggableIndex$1;
	evt.originalEvent = originalEvent;
	evt.pullMode = putSortable$1 ? putSortable$1.lastPutMode : void 0;
	var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
	for (var option$1 in allEventProperties) evt[option$1] = allEventProperties[option$1];
	if (rootEl$1) rootEl$1.dispatchEvent(evt);
	if (options$1[onName]) options$1[onName].call(sortable, evt);
}
function _dispatchEvent(info) {
	dispatchEvent(_objectSpread2({
		putSortable,
		cloneEl,
		targetEl: dragEl,
		rootEl,
		oldIndex,
		oldDraggableIndex,
		newIndex,
		newDraggableIndex
	}, info));
}
function Sortable(el$1, options$1) {
	if (!(el$1 && el$1.nodeType && el$1.nodeType === 1)) throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el$1));
	this.el = el$1;
	this.options = options$1 = _extends({}, options$1);
	el$1[expando] = this;
	var defaults$2 = {
		group: null,
		sort: true,
		disabled: false,
		store: null,
		handle: null,
		draggable: /^[uo]l$/i.test(el$1.nodeName) ? ">li" : ">*",
		swapThreshold: 1,
		invertSwap: false,
		invertedSwapThreshold: null,
		removeCloneOnHide: true,
		direction: function direction() {
			return _detectDirection(el$1, this.options);
		},
		ghostClass: "sortable-ghost",
		chosenClass: "sortable-chosen",
		dragClass: "sortable-drag",
		ignore: "a, img",
		filter: null,
		preventOnFilter: true,
		animation: 0,
		easing: null,
		setData: function setData(dataTransfer, dragEl$2) {
			dataTransfer.setData("Text", dragEl$2.textContent);
		},
		dropBubble: false,
		dragoverBubble: false,
		dataIdAttr: "data-id",
		delay: 0,
		delayOnTouchOnly: false,
		touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
		forceFallback: false,
		fallbackClass: "sortable-fallback",
		fallbackOnBody: false,
		fallbackTolerance: 0,
		fallbackOffset: {
			x: 0,
			y: 0
		},
		supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
		emptyInsertThreshold: 5
	};
	PluginManager.initializePlugins(this, el$1, defaults$2);
	for (var name in defaults$2) !(name in options$1) && (options$1[name] = defaults$2[name]);
	_prepareGroup(options$1);
	for (var fn$2 in this) if (fn$2.charAt(0) === "_" && typeof this[fn$2] === "function") this[fn$2] = this[fn$2].bind(this);
	this.nativeDraggable = options$1.forceFallback ? false : supportDraggable;
	if (this.nativeDraggable) this.options.touchStartThreshold = 1;
	if (options$1.supportPointer) on(el$1, "pointerdown", this._onTapStart);
	else {
		on(el$1, "mousedown", this._onTapStart);
		on(el$1, "touchstart", this._onTapStart);
	}
	if (this.nativeDraggable) {
		on(el$1, "dragover", this);
		on(el$1, "dragenter", this);
	}
	sortables.push(this.el);
	options$1.store && options$1.store.get && this.sort(options$1.store.get(this) || []);
	_extends(this, AnimationStateManager());
}
function _globalDragOver(evt) {
	if (evt.dataTransfer) evt.dataTransfer.dropEffect = "move";
	evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl$2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
	var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
	if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent("move", {
		bubbles: true,
		cancelable: true
	});
	else {
		evt = document.createEvent("Event");
		evt.initEvent("move", true, true);
	}
	evt.to = toEl;
	evt.from = fromEl;
	evt.dragged = dragEl$2;
	evt.draggedRect = dragRect;
	evt.related = targetEl || toEl;
	evt.relatedRect = targetRect || getRect(toEl);
	evt.willInsertAfter = willInsertAfter;
	evt.originalEvent = originalEvent;
	fromEl.dispatchEvent(evt);
	if (onMoveFn) retVal = onMoveFn.call(sortable, evt, originalEvent);
	return retVal;
}
function _disableDraggable(el$1) {
	el$1.draggable = false;
}
function _unsilent() {
	_silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
	var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
	var spacer = 10;
	return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
	var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
	var spacer = 10;
	return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
	var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
	if (!invertSwap) {
		if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
			if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) pastFirstInvertThresh = true;
			if (!pastFirstInvertThresh) {
				if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) return -lastDirection;
			} else invert = true;
		} else if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) return _getInsertDirection(target);
	}
	invert = invert || invertSwap;
	if (invert) {
		if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
	}
	return 0;
}
function _getInsertDirection(target) {
	if (index(dragEl) < index(target)) return 1;
	else return -1;
}
function _generateId(el$1) {
	var str = el$1.tagName + el$1.className + el$1.src + el$1.href + el$1.textContent, i = str.length, sum = 0;
	while (i--) sum += str.charCodeAt(i);
	return sum.toString(36);
}
function _saveInputCheckedState(root) {
	savedInputChecked.length = 0;
	var inputs$1 = root.getElementsByTagName("input");
	var idx = inputs$1.length;
	while (idx--) {
		var el$1 = inputs$1[idx];
		el$1.checked && savedInputChecked.push(el$1);
	}
}
function _nextTick(fn$2) {
	return setTimeout(fn$2, 0);
}
function _cancelNextTick(id) {
	return clearTimeout(id);
}
function AutoScrollPlugin() {
	function AutoScroll() {
		this.defaults = {
			scroll: true,
			forceAutoScrollFallback: false,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			bubbleScroll: true
		};
		for (var fn$2 in this) if (fn$2.charAt(0) === "_" && typeof this[fn$2] === "function") this[fn$2] = this[fn$2].bind(this);
	}
	AutoScroll.prototype = {
		dragStarted: function dragStarted$1(_ref) {
			var originalEvent = _ref.originalEvent;
			if (this.sortable.nativeDraggable) on(document, "dragover", this._handleAutoScroll);
			else if (this.options.supportPointer) on(document, "pointermove", this._handleFallbackAutoScroll);
			else if (originalEvent.touches) on(document, "touchmove", this._handleFallbackAutoScroll);
			else on(document, "mousemove", this._handleFallbackAutoScroll);
		},
		dragOverCompleted: function dragOverCompleted(_ref2) {
			var originalEvent = _ref2.originalEvent;
			if (!this.options.dragOverBubble && !originalEvent.rootEl) this._handleAutoScroll(originalEvent);
		},
		drop: function drop$1() {
			if (this.sortable.nativeDraggable) off(document, "dragover", this._handleAutoScroll);
			else {
				off(document, "pointermove", this._handleFallbackAutoScroll);
				off(document, "touchmove", this._handleFallbackAutoScroll);
				off(document, "mousemove", this._handleFallbackAutoScroll);
			}
			clearPointerElemChangedInterval();
			clearAutoScrolls();
			cancelThrottle();
		},
		nulling: function nulling() {
			touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
			autoScrolls.length = 0;
		},
		_handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
			this._handleAutoScroll(evt, true);
		},
		_handleAutoScroll: function _handleAutoScroll(evt, fallback) {
			var _this = this;
			var x = (evt.touches ? evt.touches[0] : evt).clientX, y$1 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y$1);
			touchEvt$1 = evt;
			if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
				autoScroll(evt, this.options, elem, fallback);
				var ogElemScroller = getParentAutoScrollElement(elem, true);
				if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y$1 !== lastAutoScrollY)) {
					pointerElemChangedInterval && clearPointerElemChangedInterval();
					pointerElemChangedInterval = setInterval(function() {
						var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y$1), true);
						if (newElem !== ogElemScroller) {
							ogElemScroller = newElem;
							clearAutoScrolls();
						}
						autoScroll(evt, _this.options, newElem, fallback);
					}, 10);
					lastAutoScrollX = x;
					lastAutoScrollY = y$1;
				}
			} else {
				if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
					clearAutoScrolls();
					return;
				}
				autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
			}
		}
	};
	return _extends(AutoScroll, {
		pluginName: "scroll",
		initializeByDefault: true
	});
}
function clearAutoScrolls() {
	autoScrolls.forEach(function(autoScroll$1) {
		clearInterval(autoScroll$1.pid);
	});
	autoScrolls = [];
}
function clearPointerElemChangedInterval() {
	clearInterval(pointerElemChangedInterval);
}
function Revert() {}
function Remove() {}
function SwapPlugin() {
	function Swap() {
		this.defaults = { swapClass: "sortable-swap-highlight" };
	}
	Swap.prototype = {
		dragStart: function dragStart(_ref) {
			lastSwapEl = _ref.dragEl;
		},
		dragOverValid: function dragOverValid(_ref2) {
			var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
			if (!activeSortable.options.swap) return;
			var el$1 = this.sortable.el, options$1 = this.options;
			if (target && target !== el$1) {
				var prevSwapEl = lastSwapEl;
				if (onMove(target) !== false) {
					toggleClass(target, options$1.swapClass, true);
					lastSwapEl = target;
				} else lastSwapEl = null;
				if (prevSwapEl && prevSwapEl !== lastSwapEl) toggleClass(prevSwapEl, options$1.swapClass, false);
			}
			changed();
			completed(true);
			cancel();
		},
		drop: function drop$1(_ref3) {
			var activeSortable = _ref3.activeSortable, putSortable$1 = _ref3.putSortable, dragEl$2 = _ref3.dragEl;
			var toSortable = putSortable$1 || this.sortable;
			var options$1 = this.options;
			lastSwapEl && toggleClass(lastSwapEl, options$1.swapClass, false);
			if (lastSwapEl && (options$1.swap || putSortable$1 && putSortable$1.options.swap)) {
				if (dragEl$2 !== lastSwapEl) {
					toSortable.captureAnimationState();
					if (toSortable !== activeSortable) activeSortable.captureAnimationState();
					swapNodes(dragEl$2, lastSwapEl);
					toSortable.animateAll();
					if (toSortable !== activeSortable) activeSortable.animateAll();
				}
			}
		},
		nulling: function nulling() {
			lastSwapEl = null;
		}
	};
	return _extends(Swap, {
		pluginName: "swap",
		eventProperties: function eventProperties() {
			return { swapItem: lastSwapEl };
		}
	});
}
function swapNodes(n1, n2) {
	var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
	if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
	i1 = index(n1);
	i2 = index(n2);
	if (p1.isEqualNode(p2) && i1 < i2) i2++;
	p1.insertBefore(n2, p1.children[i1]);
	p2.insertBefore(n1, p2.children[i2]);
}
function MultiDragPlugin() {
	function MultiDrag(sortable) {
		for (var fn$2 in this) if (fn$2.charAt(0) === "_" && typeof this[fn$2] === "function") this[fn$2] = this[fn$2].bind(this);
		if (sortable.options.supportPointer) on(document, "pointerup", this._deselectMultiDrag);
		else {
			on(document, "mouseup", this._deselectMultiDrag);
			on(document, "touchend", this._deselectMultiDrag);
		}
		on(document, "keydown", this._checkKeyDown);
		on(document, "keyup", this._checkKeyUp);
		this.defaults = {
			selectedClass: "sortable-selected",
			multiDragKey: null,
			setData: function setData(dataTransfer, dragEl$2) {
				var data = "";
				if (multiDragElements.length && multiDragSortable === sortable) multiDragElements.forEach(function(multiDragElement, i) {
					data += (!i ? "" : ", ") + multiDragElement.textContent;
				});
				else data = dragEl$2.textContent;
				dataTransfer.setData("Text", data);
			}
		};
	}
	MultiDrag.prototype = {
		multiDragKeyDown: false,
		isMultiDrag: false,
		delayStartGlobal: function delayStartGlobal(_ref) {
			dragEl$1 = _ref.dragEl;
		},
		delayEnded: function delayEnded() {
			this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
		},
		setupClone: function setupClone(_ref2) {
			var sortable = _ref2.sortable, cancel = _ref2.cancel;
			if (!this.isMultiDrag) return;
			for (var i = 0; i < multiDragElements.length; i++) {
				multiDragClones.push(clone(multiDragElements[i]));
				multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
				multiDragClones[i].draggable = false;
				multiDragClones[i].style["will-change"] = "";
				toggleClass(multiDragClones[i], this.options.selectedClass, false);
				multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
			}
			sortable._hideClone();
			cancel();
		},
		clone: function clone$1(_ref3) {
			var sortable = _ref3.sortable, rootEl$1 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
			if (!this.isMultiDrag) return;
			if (!this.options.removeCloneOnHide) {
				if (multiDragElements.length && multiDragSortable === sortable) {
					insertMultiDragClones(true, rootEl$1);
					dispatchSortableEvent("clone");
					cancel();
				}
			}
		},
		showClone: function showClone(_ref4) {
			var cloneNowShown = _ref4.cloneNowShown, rootEl$1 = _ref4.rootEl, cancel = _ref4.cancel;
			if (!this.isMultiDrag) return;
			insertMultiDragClones(false, rootEl$1);
			multiDragClones.forEach(function(clone$1) {
				css(clone$1, "display", "");
			});
			cloneNowShown();
			clonesHidden = false;
			cancel();
		},
		hideClone: function hideClone(_ref5) {
			var _this = this;
			_ref5.sortable;
			var cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
			if (!this.isMultiDrag) return;
			multiDragClones.forEach(function(clone$1) {
				css(clone$1, "display", "none");
				if (_this.options.removeCloneOnHide && clone$1.parentNode) clone$1.parentNode.removeChild(clone$1);
			});
			cloneNowHidden();
			clonesHidden = true;
			cancel();
		},
		dragStartGlobal: function dragStartGlobal(_ref6) {
			_ref6.sortable;
			if (!this.isMultiDrag && multiDragSortable) multiDragSortable.multiDrag._deselectMultiDrag();
			multiDragElements.forEach(function(multiDragElement) {
				multiDragElement.sortableIndex = index(multiDragElement);
			});
			multiDragElements = multiDragElements.sort(function(a, b$1) {
				return a.sortableIndex - b$1.sortableIndex;
			});
			dragStarted = true;
		},
		dragStarted: function dragStarted$1(_ref7) {
			var _this2 = this;
			var sortable = _ref7.sortable;
			if (!this.isMultiDrag) return;
			if (this.options.sort) {
				sortable.captureAnimationState();
				if (this.options.animation) {
					multiDragElements.forEach(function(multiDragElement) {
						if (multiDragElement === dragEl$1) return;
						css(multiDragElement, "position", "absolute");
					});
					var dragRect = getRect(dragEl$1, false, true, true);
					multiDragElements.forEach(function(multiDragElement) {
						if (multiDragElement === dragEl$1) return;
						setRect(multiDragElement, dragRect);
					});
					folding = true;
					initialFolding = true;
				}
			}
			sortable.animateAll(function() {
				folding = false;
				initialFolding = false;
				if (_this2.options.animation) multiDragElements.forEach(function(multiDragElement) {
					unsetRect(multiDragElement);
				});
				if (_this2.options.sort) removeMultiDragElements();
			});
		},
		dragOver: function dragOver(_ref8) {
			var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
			if (folding && ~multiDragElements.indexOf(target)) {
				completed(false);
				cancel();
			}
		},
		revert: function revert(_ref9) {
			var fromSortable = _ref9.fromSortable, rootEl$1 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
			if (multiDragElements.length > 1) {
				multiDragElements.forEach(function(multiDragElement) {
					sortable.addAnimationState({
						target: multiDragElement,
						rect: folding ? getRect(multiDragElement) : dragRect
					});
					unsetRect(multiDragElement);
					multiDragElement.fromRect = dragRect;
					fromSortable.removeAnimationState(multiDragElement);
				});
				folding = false;
				insertMultiDragElements(!this.options.removeCloneOnHide, rootEl$1);
			}
		},
		dragOverCompleted: function dragOverCompleted(_ref10) {
			var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl$1 = _ref10.parentEl, putSortable$1 = _ref10.putSortable;
			var options$1 = this.options;
			if (insertion) {
				if (isOwner) activeSortable._hideClone();
				initialFolding = false;
				if (options$1.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable$1)) {
					var dragRectAbsolute = getRect(dragEl$1, false, true, true);
					multiDragElements.forEach(function(multiDragElement) {
						if (multiDragElement === dragEl$1) return;
						setRect(multiDragElement, dragRectAbsolute);
						parentEl$1.appendChild(multiDragElement);
					});
					folding = true;
				}
				if (!isOwner) {
					if (!folding) removeMultiDragElements();
					if (multiDragElements.length > 1) {
						var clonesHiddenBefore = clonesHidden;
						activeSortable._showClone(sortable);
						if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) multiDragClones.forEach(function(clone$1) {
							activeSortable.addAnimationState({
								target: clone$1,
								rect: clonesFromRect
							});
							clone$1.fromRect = clonesFromRect;
							clone$1.thisAnimationDuration = null;
						});
					} else activeSortable._showClone(sortable);
				}
			}
		},
		dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
			var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
			multiDragElements.forEach(function(multiDragElement) {
				multiDragElement.thisAnimationDuration = null;
			});
			if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
				clonesFromRect = _extends({}, dragRect);
				var dragMatrix = matrix(dragEl$1, true);
				clonesFromRect.top -= dragMatrix.f;
				clonesFromRect.left -= dragMatrix.e;
			}
		},
		dragOverAnimationComplete: function dragOverAnimationComplete() {
			if (folding) {
				folding = false;
				removeMultiDragElements();
			}
		},
		drop: function drop$1(_ref12) {
			var evt = _ref12.originalEvent, rootEl$1 = _ref12.rootEl, parentEl$1 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex$1 = _ref12.oldIndex, putSortable$1 = _ref12.putSortable;
			var toSortable = putSortable$1 || this.sortable;
			if (!evt) return;
			var options$1 = this.options, children = parentEl$1.children;
			if (!dragStarted) {
				if (options$1.multiDragKey && !this.multiDragKeyDown) this._deselectMultiDrag();
				toggleClass(dragEl$1, options$1.selectedClass, !~multiDragElements.indexOf(dragEl$1));
				if (!~multiDragElements.indexOf(dragEl$1)) {
					multiDragElements.push(dragEl$1);
					dispatchEvent({
						sortable,
						rootEl: rootEl$1,
						name: "select",
						targetEl: dragEl$1,
						originalEvt: evt
					});
					if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
						var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
						if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
							var n, i;
							if (currentIndex > lastIndex) {
								i = lastIndex;
								n = currentIndex;
							} else {
								i = currentIndex;
								n = lastIndex + 1;
							}
							for (; i < n; i++) {
								if (~multiDragElements.indexOf(children[i])) continue;
								toggleClass(children[i], options$1.selectedClass, true);
								multiDragElements.push(children[i]);
								dispatchEvent({
									sortable,
									rootEl: rootEl$1,
									name: "select",
									targetEl: children[i],
									originalEvt: evt
								});
							}
						}
					} else lastMultiDragSelect = dragEl$1;
					multiDragSortable = toSortable;
				} else {
					multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
					lastMultiDragSelect = null;
					dispatchEvent({
						sortable,
						rootEl: rootEl$1,
						name: "deselect",
						targetEl: dragEl$1,
						originalEvt: evt
					});
				}
			}
			if (dragStarted && this.isMultiDrag) {
				folding = false;
				if ((parentEl$1[expando].options.sort || parentEl$1 !== rootEl$1) && multiDragElements.length > 1) {
					var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
					if (!initialFolding && options$1.animation) dragEl$1.thisAnimationDuration = null;
					toSortable.captureAnimationState();
					if (!initialFolding) {
						if (options$1.animation) {
							dragEl$1.fromRect = dragRect;
							multiDragElements.forEach(function(multiDragElement) {
								multiDragElement.thisAnimationDuration = null;
								if (multiDragElement !== dragEl$1) {
									var rect = folding ? getRect(multiDragElement) : dragRect;
									multiDragElement.fromRect = rect;
									toSortable.addAnimationState({
										target: multiDragElement,
										rect
									});
								}
							});
						}
						removeMultiDragElements();
						multiDragElements.forEach(function(multiDragElement) {
							if (children[multiDragIndex]) parentEl$1.insertBefore(multiDragElement, children[multiDragIndex]);
							else parentEl$1.appendChild(multiDragElement);
							multiDragIndex++;
						});
						if (oldIndex$1 === index(dragEl$1)) {
							var update = false;
							multiDragElements.forEach(function(multiDragElement) {
								if (multiDragElement.sortableIndex !== index(multiDragElement)) {
									update = true;
									return;
								}
							});
							if (update) dispatchSortableEvent("update");
						}
					}
					multiDragElements.forEach(function(multiDragElement) {
						unsetRect(multiDragElement);
					});
					toSortable.animateAll();
				}
				multiDragSortable = toSortable;
			}
			if (rootEl$1 === parentEl$1 || putSortable$1 && putSortable$1.lastPutMode !== "clone") multiDragClones.forEach(function(clone$1) {
				clone$1.parentNode && clone$1.parentNode.removeChild(clone$1);
			});
		},
		nullingGlobal: function nullingGlobal() {
			this.isMultiDrag = dragStarted = false;
			multiDragClones.length = 0;
		},
		destroyGlobal: function destroyGlobal() {
			this._deselectMultiDrag();
			off(document, "pointerup", this._deselectMultiDrag);
			off(document, "mouseup", this._deselectMultiDrag);
			off(document, "touchend", this._deselectMultiDrag);
			off(document, "keydown", this._checkKeyDown);
			off(document, "keyup", this._checkKeyUp);
		},
		_deselectMultiDrag: function _deselectMultiDrag(evt) {
			if (typeof dragStarted !== "undefined" && dragStarted) return;
			if (multiDragSortable !== this.sortable) return;
			if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;
			if (evt && evt.button !== 0) return;
			while (multiDragElements.length) {
				var el$1 = multiDragElements[0];
				toggleClass(el$1, this.options.selectedClass, false);
				multiDragElements.shift();
				dispatchEvent({
					sortable: this.sortable,
					rootEl: this.sortable.el,
					name: "deselect",
					targetEl: el$1,
					originalEvt: evt
				});
			}
		},
		_checkKeyDown: function _checkKeyDown(evt) {
			if (evt.key === this.options.multiDragKey) this.multiDragKeyDown = true;
		},
		_checkKeyUp: function _checkKeyUp(evt) {
			if (evt.key === this.options.multiDragKey) this.multiDragKeyDown = false;
		}
	};
	return _extends(MultiDrag, {
		pluginName: "multiDrag",
		utils: {
			select: function select$1(el$1) {
				var sortable = el$1.parentNode[expando];
				if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el$1)) return;
				if (multiDragSortable && multiDragSortable !== sortable) {
					multiDragSortable.multiDrag._deselectMultiDrag();
					multiDragSortable = sortable;
				}
				toggleClass(el$1, sortable.options.selectedClass, true);
				multiDragElements.push(el$1);
			},
			deselect: function deselect(el$1) {
				var sortable = el$1.parentNode[expando], index$1 = multiDragElements.indexOf(el$1);
				if (!sortable || !sortable.options.multiDrag || !~index$1) return;
				toggleClass(el$1, sortable.options.selectedClass, false);
				multiDragElements.splice(index$1, 1);
			}
		},
		eventProperties: function eventProperties() {
			var _this3 = this;
			var oldIndicies = [], newIndicies = [];
			multiDragElements.forEach(function(multiDragElement) {
				oldIndicies.push({
					multiDragElement,
					index: multiDragElement.sortableIndex
				});
				var newIndex$1;
				if (folding && multiDragElement !== dragEl$1) newIndex$1 = -1;
				else if (folding) newIndex$1 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
				else newIndex$1 = index(multiDragElement);
				newIndicies.push({
					multiDragElement,
					index: newIndex$1
				});
			});
			return {
				items: _toConsumableArray(multiDragElements),
				clones: [].concat(multiDragClones),
				oldIndicies,
				newIndicies
			};
		},
		optionListeners: { multiDragKey: function multiDragKey(key) {
			key = key.toLowerCase();
			if (key === "ctrl") key = "Control";
			else if (key.length > 1) key = key.charAt(0).toUpperCase() + key.substr(1);
			return key;
		} }
	});
}
function insertMultiDragElements(clonesInserted, rootEl$1) {
	multiDragElements.forEach(function(multiDragElement, i) {
		var target = rootEl$1.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
		if (target) rootEl$1.insertBefore(multiDragElement, target);
		else rootEl$1.appendChild(multiDragElement);
	});
}
function insertMultiDragClones(elementsInserted, rootEl$1) {
	multiDragClones.forEach(function(clone$1, i) {
		var target = rootEl$1.children[clone$1.sortableIndex + (elementsInserted ? Number(i) : 0)];
		if (target) rootEl$1.insertBefore(clone$1, target);
		else rootEl$1.appendChild(clone$1);
	});
}
function removeMultiDragElements() {
	multiDragElements.forEach(function(multiDragElement) {
		if (multiDragElement === dragEl$1) return;
		multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
	});
}
var version, IE11OrLess, Edge, FireFox, Safari, IOS, ChromeForAndroid, captureMode, R_SPACE, _throttleTimeout, expando, plugins, defaults, PluginManager, _excluded, pluginEvent, dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted, ignoreNextClick, sortables, tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh, isCircumstantialInvert, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll, _silent, savedInputChecked, documentExists, PositionGhostAbsolutely, CSSFloatProperty, supportDraggable, supportCssPointerEvents, _detectDirection, _dragElInRowColumn, _detectNearestEmptySortable, _prepareGroup, _hideGhostForTarget, _unhideGhostForTarget, nearestEmptyInsertDetectEvent, _checkOutsideTargetEl, autoScrolls, scrollEl, scrollRootEl, scrolling, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval, autoScroll, drop, lastSwapEl, multiDragElements, multiDragClones, lastMultiDragSelect, multiDragSortable, initialFolding, folding, dragStarted, dragEl$1, clonesFromRect, clonesHidden, sortable_esm_default;
var init_sortable_esm = __esmMin((() => {
	version = "1.14.0";
	IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
	Edge = userAgent(/Edge/i);
	FireFox = userAgent(/firefox/i);
	Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
	IOS = userAgent(/iP(ad|od|hone)/i);
	ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
	captureMode = {
		capture: false,
		passive: false
	};
	R_SPACE = /\s+/g;
	expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
	plugins = [];
	defaults = { initializeByDefault: true };
	PluginManager = {
		mount: function mount(plugin) {
			for (var option$1 in defaults) if (defaults.hasOwnProperty(option$1) && !(option$1 in plugin)) plugin[option$1] = defaults[option$1];
			plugins.forEach(function(p) {
				if (p.pluginName === plugin.pluginName) throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
			});
			plugins.push(plugin);
		},
		pluginEvent: function pluginEvent$1(eventName, sortable, evt) {
			var _this = this;
			this.eventCanceled = false;
			evt.cancel = function() {
				_this.eventCanceled = true;
			};
			var eventNameGlobal = eventName + "Global";
			plugins.forEach(function(plugin) {
				if (!sortable[plugin.pluginName]) return;
				if (sortable[plugin.pluginName][eventNameGlobal]) sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({ sortable }, evt));
				if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) sortable[plugin.pluginName][eventName](_objectSpread2({ sortable }, evt));
			});
		},
		initializePlugins: function initializePlugins(sortable, el$1, defaults$2, options$1) {
			plugins.forEach(function(plugin) {
				var pluginName = plugin.pluginName;
				if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
				var initialized = new plugin(sortable, el$1, sortable.options);
				initialized.sortable = sortable;
				initialized.options = sortable.options;
				sortable[pluginName] = initialized;
				_extends(defaults$2, initialized.defaults);
			});
			for (var option$1 in sortable.options) {
				if (!sortable.options.hasOwnProperty(option$1)) continue;
				var modified = this.modifyOption(sortable, option$1, sortable.options[option$1]);
				if (typeof modified !== "undefined") sortable.options[option$1] = modified;
			}
		},
		getEventProperties: function getEventProperties(name, sortable) {
			var eventProperties = {};
			plugins.forEach(function(plugin) {
				if (typeof plugin.eventProperties !== "function") return;
				_extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
			});
			return eventProperties;
		},
		modifyOption: function modifyOption(sortable, name, value$1) {
			var modifiedValue;
			plugins.forEach(function(plugin) {
				if (!sortable[plugin.pluginName]) return;
				if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value$1);
			});
			return modifiedValue;
		}
	};
	_excluded = ["evt"];
	pluginEvent = function pluginEvent$1(eventName, sortable) {
		var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
		PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
			dragEl,
			parentEl,
			ghostEl,
			rootEl,
			nextEl,
			lastDownEl,
			cloneEl,
			cloneHidden,
			dragStarted: moved,
			putSortable,
			activeSortable: Sortable.active,
			originalEvent,
			oldIndex,
			oldDraggableIndex,
			newIndex,
			newDraggableIndex,
			hideGhostForTarget: _hideGhostForTarget,
			unhideGhostForTarget: _unhideGhostForTarget,
			cloneNowHidden: function cloneNowHidden() {
				cloneHidden = true;
			},
			cloneNowShown: function cloneNowShown() {
				cloneHidden = false;
			},
			dispatchSortableEvent: function dispatchSortableEvent(name) {
				_dispatchEvent({
					sortable,
					name,
					originalEvent
				});
			}
		}, data));
	};
	awaitingDragStarted = false, ignoreNextClick = false, sortables = [], pastFirstInvertThresh = false, isCircumstantialInvert = false, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
	documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
		if (!documentExists) return;
		if (IE11OrLess) return false;
		var el$1 = document.createElement("x");
		el$1.style.cssText = "pointer-events:auto";
		return el$1.style.pointerEvents === "auto";
	}(), _detectDirection = function _detectDirection$1(el$1, options$1) {
		var elCSS = css(el$1), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el$1, 0, options$1), child2 = getChild(el$1, 1, options$1), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
		if (elCSS.display === "flex") return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
		if (elCSS.display === "grid") return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
		if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
			var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
			return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
		}
		return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
	}, _dragElInRowColumn = function _dragElInRowColumn$1(dragRect, targetRect, vertical) {
		var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
		return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
	}, _detectNearestEmptySortable = function _detectNearestEmptySortable$1(x, y$1) {
		var ret;
		sortables.some(function(sortable) {
			var threshold = sortable[expando].options.emptyInsertThreshold;
			if (!threshold || lastChild(sortable)) return;
			var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y$1 >= rect.top - threshold && y$1 <= rect.bottom + threshold;
			if (insideHorizontally && insideVertically) return ret = sortable;
		});
		return ret;
	}, _prepareGroup = function _prepareGroup$1(options$1) {
		function toFn(value$1, pull) {
			return function(to, from, dragEl$2, evt) {
				var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
				if (value$1 == null && (pull || sameGroup)) return true;
				else if (value$1 == null || value$1 === false) return false;
				else if (pull && value$1 === "clone") return value$1;
				else if (typeof value$1 === "function") return toFn(value$1(to, from, dragEl$2, evt), pull)(to, from, dragEl$2, evt);
				else {
					var otherGroup = (pull ? to : from).options.group.name;
					return value$1 === true || typeof value$1 === "string" && value$1 === otherGroup || value$1.join && value$1.indexOf(otherGroup) > -1;
				}
			};
		}
		var group$1 = {};
		var originalGroup = options$1.group;
		if (!originalGroup || _typeof(originalGroup) != "object") originalGroup = { name: originalGroup };
		group$1.name = originalGroup.name;
		group$1.checkPull = toFn(originalGroup.pull, true);
		group$1.checkPut = toFn(originalGroup.put);
		group$1.revertClone = originalGroup.revertClone;
		options$1.group = group$1;
	}, _hideGhostForTarget = function _hideGhostForTarget$1() {
		if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "none");
	}, _unhideGhostForTarget = function _unhideGhostForTarget$1() {
		if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "");
	};
	if (documentExists) document.addEventListener("click", function(evt) {
		if (ignoreNextClick) {
			evt.preventDefault();
			evt.stopPropagation && evt.stopPropagation();
			evt.stopImmediatePropagation && evt.stopImmediatePropagation();
			ignoreNextClick = false;
			return false;
		}
	}, true);
	nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent$1(evt) {
		if (dragEl) {
			evt = evt.touches ? evt.touches[0] : evt;
			var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
			if (nearest) {
				var event = {};
				for (var i in evt) if (evt.hasOwnProperty(i)) event[i] = evt[i];
				event.target = event.rootEl = nearest;
				event.preventDefault = void 0;
				event.stopPropagation = void 0;
				nearest[expando]._onDragOver(event);
			}
		}
	};
	_checkOutsideTargetEl = function _checkOutsideTargetEl$1(evt) {
		if (dragEl) dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
	};
	Sortable.prototype = {
		constructor: Sortable,
		_isOutsideThisEl: function _isOutsideThisEl(target) {
			if (!this.el.contains(target) && target !== this.el) lastTarget = null;
		},
		_getDirection: function _getDirection(evt, target) {
			return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
		},
		_onTapStart: function _onTapStart(evt) {
			if (!evt.cancelable) return;
			var _this = this, el$1 = this.el, options$1 = this.options, preventOnFilter = options$1.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter$1 = options$1.filter;
			_saveInputCheckedState(el$1);
			if (dragEl) return;
			if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options$1.disabled) return;
			if (originalTarget.isContentEditable) return;
			if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") return;
			target = closest(target, options$1.draggable, el$1, false);
			if (target && target.animated) return;
			if (lastDownEl === target) return;
			oldIndex = index(target);
			oldDraggableIndex = index(target, options$1.draggable);
			if (typeof filter$1 === "function") {
				if (filter$1.call(this, evt, target, this)) {
					_dispatchEvent({
						sortable: _this,
						rootEl: originalTarget,
						name: "filter",
						targetEl: target,
						toEl: el$1,
						fromEl: el$1
					});
					pluginEvent("filter", _this, { evt });
					preventOnFilter && evt.cancelable && evt.preventDefault();
					return;
				}
			} else if (filter$1) {
				filter$1 = filter$1.split(",").some(function(criteria) {
					criteria = closest(originalTarget, criteria.trim(), el$1, false);
					if (criteria) {
						_dispatchEvent({
							sortable: _this,
							rootEl: criteria,
							name: "filter",
							targetEl: target,
							fromEl: el$1,
							toEl: el$1
						});
						pluginEvent("filter", _this, { evt });
						return true;
					}
				});
				if (filter$1) {
					preventOnFilter && evt.cancelable && evt.preventDefault();
					return;
				}
			}
			if (options$1.handle && !closest(originalTarget, options$1.handle, el$1, false)) return;
			this._prepareDragStart(evt, touch, target);
		},
		_prepareDragStart: function _prepareDragStart(evt, touch, target) {
			var _this = this, el$1 = _this.el, options$1 = _this.options, ownerDocument = el$1.ownerDocument, dragStartFn;
			if (target && !dragEl && target.parentNode === el$1) {
				var dragRect = getRect(target);
				rootEl = el$1;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				lastDownEl = target;
				activeGroup = options$1.group;
				Sortable.dragged = dragEl;
				tapEvt = {
					target: dragEl,
					clientX: (touch || evt).clientX,
					clientY: (touch || evt).clientY
				};
				tapDistanceLeft = tapEvt.clientX - dragRect.left;
				tapDistanceTop = tapEvt.clientY - dragRect.top;
				this._lastX = (touch || evt).clientX;
				this._lastY = (touch || evt).clientY;
				dragEl.style["will-change"] = "all";
				dragStartFn = function dragStartFn$1() {
					pluginEvent("delayEnded", _this, { evt });
					if (Sortable.eventCanceled) {
						_this._onDrop();
						return;
					}
					_this._disableDelayedDragEvents();
					if (!FireFox && _this.nativeDraggable) dragEl.draggable = true;
					_this._triggerDragStart(evt, touch);
					_dispatchEvent({
						sortable: _this,
						name: "choose",
						originalEvent: evt
					});
					toggleClass(dragEl, options$1.chosenClass, true);
				};
				options$1.ignore.split(",").forEach(function(criteria) {
					find(dragEl, criteria.trim(), _disableDraggable);
				});
				on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
				on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
				on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
				on(ownerDocument, "mouseup", _this._onDrop);
				on(ownerDocument, "touchend", _this._onDrop);
				on(ownerDocument, "touchcancel", _this._onDrop);
				if (FireFox && this.nativeDraggable) {
					this.options.touchStartThreshold = 4;
					dragEl.draggable = true;
				}
				pluginEvent("delayStart", this, { evt });
				if (options$1.delay && (!options$1.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
					if (Sortable.eventCanceled) {
						this._onDrop();
						return;
					}
					on(ownerDocument, "mouseup", _this._disableDelayedDrag);
					on(ownerDocument, "touchend", _this._disableDelayedDrag);
					on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
					on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
					on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
					options$1.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
					_this._dragStartTimer = setTimeout(dragStartFn, options$1.delay);
				} else dragStartFn();
			}
		},
		_delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
			var touch = e.touches ? e.touches[0] : e;
			if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) this._disableDelayedDrag();
		},
		_disableDelayedDrag: function _disableDelayedDrag() {
			dragEl && _disableDraggable(dragEl);
			clearTimeout(this._dragStartTimer);
			this._disableDelayedDragEvents();
		},
		_disableDelayedDragEvents: function _disableDelayedDragEvents() {
			var ownerDocument = this.el.ownerDocument;
			off(ownerDocument, "mouseup", this._disableDelayedDrag);
			off(ownerDocument, "touchend", this._disableDelayedDrag);
			off(ownerDocument, "touchcancel", this._disableDelayedDrag);
			off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
			off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
			off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
		},
		_triggerDragStart: function _triggerDragStart(evt, touch) {
			touch = touch || evt.pointerType == "touch" && evt;
			if (!this.nativeDraggable || touch) if (this.options.supportPointer) on(document, "pointermove", this._onTouchMove);
			else if (touch) on(document, "touchmove", this._onTouchMove);
			else on(document, "mousemove", this._onTouchMove);
			else {
				on(dragEl, "dragend", this);
				on(rootEl, "dragstart", this._onDragStart);
			}
			try {
				if (document.selection) _nextTick(function() {
					document.selection.empty();
				});
				else window.getSelection().removeAllRanges();
			} catch (err) {}
		},
		_dragStarted: function _dragStarted(fallback, evt) {
			awaitingDragStarted = false;
			if (rootEl && dragEl) {
				pluginEvent("dragStarted", this, { evt });
				if (this.nativeDraggable) on(document, "dragover", _checkOutsideTargetEl);
				var options$1 = this.options;
				!fallback && toggleClass(dragEl, options$1.dragClass, false);
				toggleClass(dragEl, options$1.ghostClass, true);
				Sortable.active = this;
				fallback && this._appendGhost();
				_dispatchEvent({
					sortable: this,
					name: "start",
					originalEvent: evt
				});
			} else this._nulling();
		},
		_emulateDragOver: function _emulateDragOver() {
			if (touchEvt) {
				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;
				_hideGhostForTarget();
				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
				var parent$2 = target;
				while (target && target.shadowRoot) {
					target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					if (target === parent$2) break;
					parent$2 = target;
				}
				dragEl.parentNode[expando]._isOutsideThisEl(target);
				if (parent$2) do {
					if (parent$2[expando]) {
						var inserted = void 0;
						inserted = parent$2[expando]._onDragOver({
							clientX: touchEvt.clientX,
							clientY: touchEvt.clientY,
							target,
							rootEl: parent$2
						});
						if (inserted && !this.options.dragoverBubble) break;
					}
					target = parent$2;
				} while (parent$2 = parent$2.parentNode);
				_unhideGhostForTarget();
			}
		},
		_onTouchMove: function _onTouchMove(evt) {
			if (tapEvt) {
				var options$1 = this.options, fallbackTolerance = options$1.fallbackTolerance, fallbackOffset = options$1.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy$1 = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
				if (!Sortable.active && !awaitingDragStarted) {
					if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) return;
					this._onDragStart(evt, true);
				}
				if (ghostEl) {
					if (ghostMatrix) {
						ghostMatrix.e += dx - (lastDx || 0);
						ghostMatrix.f += dy$1 - (lastDy || 0);
					} else ghostMatrix = {
						a: 1,
						b: 0,
						c: 0,
						d: 1,
						e: dx,
						f: dy$1
					};
					var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
					css(ghostEl, "webkitTransform", cssMatrix);
					css(ghostEl, "mozTransform", cssMatrix);
					css(ghostEl, "msTransform", cssMatrix);
					css(ghostEl, "transform", cssMatrix);
					lastDx = dx;
					lastDy = dy$1;
					touchEvt = touch;
				}
				evt.cancelable && evt.preventDefault();
			}
		},
		_appendGhost: function _appendGhost() {
			if (!ghostEl) {
				var container$4 = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container$4), options$1 = this.options;
				if (PositionGhostAbsolutely) {
					ghostRelativeParent = container$4;
					while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) ghostRelativeParent = ghostRelativeParent.parentNode;
					if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
						if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
						rect.top += ghostRelativeParent.scrollTop;
						rect.left += ghostRelativeParent.scrollLeft;
					} else ghostRelativeParent = getWindowScrollingElement();
					ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
				}
				ghostEl = dragEl.cloneNode(true);
				toggleClass(ghostEl, options$1.ghostClass, false);
				toggleClass(ghostEl, options$1.fallbackClass, true);
				toggleClass(ghostEl, options$1.dragClass, true);
				css(ghostEl, "transition", "");
				css(ghostEl, "transform", "");
				css(ghostEl, "box-sizing", "border-box");
				css(ghostEl, "margin", 0);
				css(ghostEl, "top", rect.top);
				css(ghostEl, "left", rect.left);
				css(ghostEl, "width", rect.width);
				css(ghostEl, "height", rect.height);
				css(ghostEl, "opacity", "0.8");
				css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
				css(ghostEl, "zIndex", "100000");
				css(ghostEl, "pointerEvents", "none");
				Sortable.ghost = ghostEl;
				container$4.appendChild(ghostEl);
				css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
			}
		},
		_onDragStart: function _onDragStart(evt, fallback) {
			var _this = this;
			var dataTransfer = evt.dataTransfer;
			var options$1 = _this.options;
			pluginEvent("dragStart", this, { evt });
			if (Sortable.eventCanceled) {
				this._onDrop();
				return;
			}
			pluginEvent("setupClone", this);
			if (!Sortable.eventCanceled) {
				cloneEl = clone(dragEl);
				cloneEl.draggable = false;
				cloneEl.style["will-change"] = "";
				this._hideClone();
				toggleClass(cloneEl, this.options.chosenClass, false);
				Sortable.clone = cloneEl;
			}
			_this.cloneId = _nextTick(function() {
				pluginEvent("clone", _this);
				if (Sortable.eventCanceled) return;
				if (!_this.options.removeCloneOnHide) rootEl.insertBefore(cloneEl, dragEl);
				_this._hideClone();
				_dispatchEvent({
					sortable: _this,
					name: "clone"
				});
			});
			!fallback && toggleClass(dragEl, options$1.dragClass, true);
			if (fallback) {
				ignoreNextClick = true;
				_this._loopId = setInterval(_this._emulateDragOver, 50);
			} else {
				off(document, "mouseup", _this._onDrop);
				off(document, "touchend", _this._onDrop);
				off(document, "touchcancel", _this._onDrop);
				if (dataTransfer) {
					dataTransfer.effectAllowed = "move";
					options$1.setData && options$1.setData.call(_this, dataTransfer, dragEl);
				}
				on(document, "drop", _this);
				css(dragEl, "transform", "translateZ(0)");
			}
			awaitingDragStarted = true;
			_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
			on(document, "selectstart", _this);
			moved = true;
			if (Safari) css(document.body, "user-select", "none");
		},
		_onDragOver: function _onDragOver(evt) {
			var el$1 = this.el, target = evt.target, dragRect, targetRect, revert, options$1 = this.options, group$1 = options$1.group, activeSortable = Sortable.active, isOwner = activeGroup === group$1, canSort = options$1.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
			if (_silent) return;
			function dragOverEvent(name, extra) {
				pluginEvent(name, _this, _objectSpread2({
					evt,
					isOwner,
					axis: vertical ? "vertical" : "horizontal",
					revert,
					dragRect,
					targetRect,
					canSort,
					fromSortable,
					target,
					completed,
					onMove: function onMove(target$1, after$1) {
						return _onMove(rootEl, el$1, dragEl, dragRect, target$1, getRect(target$1), evt, after$1);
					},
					changed
				}, extra));
			}
			function capture() {
				dragOverEvent("dragOverAnimationCapture");
				_this.captureAnimationState();
				if (_this !== fromSortable) fromSortable.captureAnimationState();
			}
			function completed(insertion) {
				dragOverEvent("dragOverCompleted", { insertion });
				if (insertion) {
					if (isOwner) activeSortable._hideClone();
					else activeSortable._showClone(_this);
					if (_this !== fromSortable) {
						toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
						toggleClass(dragEl, options$1.ghostClass, true);
					}
					if (putSortable !== _this && _this !== Sortable.active) putSortable = _this;
					else if (_this === Sortable.active && putSortable) putSortable = null;
					if (fromSortable === _this) _this._ignoreWhileAnimating = target;
					_this.animateAll(function() {
						dragOverEvent("dragOverAnimationComplete");
						_this._ignoreWhileAnimating = null;
					});
					if (_this !== fromSortable) {
						fromSortable.animateAll();
						fromSortable._ignoreWhileAnimating = null;
					}
				}
				if (target === dragEl && !dragEl.animated || target === el$1 && !target.animated) lastTarget = null;
				if (!options$1.dragoverBubble && !evt.rootEl && target !== document) {
					dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
					!insertion && nearestEmptyInsertDetectEvent(evt);
				}
				!options$1.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
				return completedFired = true;
			}
			function changed() {
				newIndex = index(dragEl);
				newDraggableIndex = index(dragEl, options$1.draggable);
				_dispatchEvent({
					sortable: _this,
					name: "change",
					toEl: el$1,
					newIndex,
					newDraggableIndex,
					originalEvent: evt
				});
			}
			if (evt.preventDefault !== void 0) evt.cancelable && evt.preventDefault();
			target = closest(target, options$1.draggable, el$1, true);
			dragOverEvent("dragOver");
			if (Sortable.eventCanceled) return completedFired;
			if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) return completed(false);
			ignoreNextClick = false;
			if (activeSortable && !options$1.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group$1.checkPut(this, activeSortable, dragEl, evt))) {
				vertical = this._getDirection(evt, target) === "vertical";
				dragRect = getRect(dragEl);
				dragOverEvent("dragOverValid");
				if (Sortable.eventCanceled) return completedFired;
				if (revert) {
					parentEl = rootEl;
					capture();
					this._hideClone();
					dragOverEvent("revert");
					if (!Sortable.eventCanceled) if (nextEl) rootEl.insertBefore(dragEl, nextEl);
					else rootEl.appendChild(dragEl);
					return completed(true);
				}
				var elLastChild = lastChild(el$1, options$1.draggable);
				if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
					if (elLastChild === dragEl) return completed(false);
					if (elLastChild && el$1 === evt.target) target = elLastChild;
					if (target) targetRect = getRect(target);
					if (_onMove(rootEl, el$1, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
						capture();
						el$1.appendChild(dragEl);
						parentEl = el$1;
						changed();
						return completed(true);
					}
				} else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
					var firstChild = getChild(el$1, 0, options$1, true);
					if (firstChild === dragEl) return completed(false);
					target = firstChild;
					targetRect = getRect(target);
					if (_onMove(rootEl, el$1, dragEl, dragRect, target, targetRect, evt, false) !== false) {
						capture();
						el$1.insertBefore(dragEl, firstChild);
						parentEl = el$1;
						changed();
						return completed(true);
					}
				} else if (target.parentNode === el$1) {
					targetRect = getRect(target);
					var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el$1, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
					if (lastTarget !== target) {
						targetBeforeFirstSwap = targetRect[side1];
						pastFirstInvertThresh = false;
						isCircumstantialInvert = !differentRowCol && options$1.invertSwap || differentLevel;
					}
					direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options$1.swapThreshold, options$1.invertedSwapThreshold == null ? options$1.swapThreshold : options$1.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
					var sibling;
					if (direction !== 0) {
						var dragIndex = index(dragEl);
						do {
							dragIndex -= direction;
							sibling = parentEl.children[dragIndex];
						} while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
					}
					if (direction === 0 || sibling === target) return completed(false);
					lastTarget = target;
					lastDirection = direction;
					var nextSibling = target.nextElementSibling, after = false;
					after = direction === 1;
					var moveVector = _onMove(rootEl, el$1, dragEl, dragRect, target, targetRect, evt, after);
					if (moveVector !== false) {
						if (moveVector === 1 || moveVector === -1) after = moveVector === 1;
						_silent = true;
						setTimeout(_unsilent, 30);
						capture();
						if (after && !nextSibling) el$1.appendChild(dragEl);
						else target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
						if (scrolledPastTop) scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
						parentEl = dragEl.parentNode;
						if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
						changed();
						return completed(true);
					}
				}
				if (el$1.contains(dragEl)) return completed(false);
			}
			return false;
		},
		_ignoreWhileAnimating: null,
		_offMoveEvents: function _offMoveEvents() {
			off(document, "mousemove", this._onTouchMove);
			off(document, "touchmove", this._onTouchMove);
			off(document, "pointermove", this._onTouchMove);
			off(document, "dragover", nearestEmptyInsertDetectEvent);
			off(document, "mousemove", nearestEmptyInsertDetectEvent);
			off(document, "touchmove", nearestEmptyInsertDetectEvent);
		},
		_offUpEvents: function _offUpEvents() {
			var ownerDocument = this.el.ownerDocument;
			off(ownerDocument, "mouseup", this._onDrop);
			off(ownerDocument, "touchend", this._onDrop);
			off(ownerDocument, "pointerup", this._onDrop);
			off(ownerDocument, "touchcancel", this._onDrop);
			off(document, "selectstart", this);
		},
		_onDrop: function _onDrop(evt) {
			var el$1 = this.el, options$1 = this.options;
			newIndex = index(dragEl);
			newDraggableIndex = index(dragEl, options$1.draggable);
			pluginEvent("drop", this, { evt });
			parentEl = dragEl && dragEl.parentNode;
			newIndex = index(dragEl);
			newDraggableIndex = index(dragEl, options$1.draggable);
			if (Sortable.eventCanceled) {
				this._nulling();
				return;
			}
			awaitingDragStarted = false;
			isCircumstantialInvert = false;
			pastFirstInvertThresh = false;
			clearInterval(this._loopId);
			clearTimeout(this._dragStartTimer);
			_cancelNextTick(this.cloneId);
			_cancelNextTick(this._dragStartId);
			if (this.nativeDraggable) {
				off(document, "drop", this);
				off(el$1, "dragstart", this._onDragStart);
			}
			this._offMoveEvents();
			this._offUpEvents();
			if (Safari) css(document.body, "user-select", "");
			css(dragEl, "transform", "");
			if (evt) {
				if (moved) {
					evt.cancelable && evt.preventDefault();
					!options$1.dropBubble && evt.stopPropagation();
				}
				ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
				if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
				if (dragEl) {
					if (this.nativeDraggable) off(dragEl, "dragend", this);
					_disableDraggable(dragEl);
					dragEl.style["will-change"] = "";
					if (moved && !awaitingDragStarted) toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
					toggleClass(dragEl, this.options.chosenClass, false);
					_dispatchEvent({
						sortable: this,
						name: "unchoose",
						toEl: parentEl,
						newIndex: null,
						newDraggableIndex: null,
						originalEvent: evt
					});
					if (rootEl !== parentEl) {
						if (newIndex >= 0) {
							_dispatchEvent({
								rootEl: parentEl,
								name: "add",
								toEl: parentEl,
								fromEl: rootEl,
								originalEvent: evt
							});
							_dispatchEvent({
								sortable: this,
								name: "remove",
								toEl: parentEl,
								originalEvent: evt
							});
							_dispatchEvent({
								rootEl: parentEl,
								name: "sort",
								toEl: parentEl,
								fromEl: rootEl,
								originalEvent: evt
							});
							_dispatchEvent({
								sortable: this,
								name: "sort",
								toEl: parentEl,
								originalEvent: evt
							});
						}
						putSortable && putSortable.save();
					} else if (newIndex !== oldIndex) {
						if (newIndex >= 0) {
							_dispatchEvent({
								sortable: this,
								name: "update",
								toEl: parentEl,
								originalEvent: evt
							});
							_dispatchEvent({
								sortable: this,
								name: "sort",
								toEl: parentEl,
								originalEvent: evt
							});
						}
					}
					if (Sortable.active) {
						if (newIndex == null || newIndex === -1) {
							newIndex = oldIndex;
							newDraggableIndex = oldDraggableIndex;
						}
						_dispatchEvent({
							sortable: this,
							name: "end",
							toEl: parentEl,
							originalEvent: evt
						});
						this.save();
					}
				}
			}
			this._nulling();
		},
		_nulling: function _nulling() {
			pluginEvent("nulling", this);
			rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
			savedInputChecked.forEach(function(el$1) {
				el$1.checked = true;
			});
			savedInputChecked.length = lastDx = lastDy = 0;
		},
		handleEvent: function handleEvent(evt) {
			switch (evt.type) {
				case "drop":
				case "dragend":
					this._onDrop(evt);
					break;
				case "dragenter":
				case "dragover":
					if (dragEl) {
						this._onDragOver(evt);
						_globalDragOver(evt);
					}
					break;
				case "selectstart":
					evt.preventDefault();
					break;
			}
		},
		toArray: function toArray() {
			var order = [], el$1, children = this.el.children, i = 0, n = children.length, options$1 = this.options;
			for (; i < n; i++) {
				el$1 = children[i];
				if (closest(el$1, options$1.draggable, this.el, false)) order.push(el$1.getAttribute(options$1.dataIdAttr) || _generateId(el$1));
			}
			return order;
		},
		sort: function sort(order, useAnimation) {
			var items = {}, rootEl$1 = this.el;
			this.toArray().forEach(function(id, i) {
				var el$1 = rootEl$1.children[i];
				if (closest(el$1, this.options.draggable, rootEl$1, false)) items[id] = el$1;
			}, this);
			useAnimation && this.captureAnimationState();
			order.forEach(function(id) {
				if (items[id]) {
					rootEl$1.removeChild(items[id]);
					rootEl$1.appendChild(items[id]);
				}
			});
			useAnimation && this.animateAll();
		},
		save: function save() {
			var store = this.options.store;
			store && store.set && store.set(this);
		},
		closest: function closest$1(el$1, selector) {
			return closest(el$1, selector || this.options.draggable, this.el, false);
		},
		option: function option$1(name, value$1) {
			var options$1 = this.options;
			if (value$1 === void 0) return options$1[name];
			else {
				var modifiedValue = PluginManager.modifyOption(this, name, value$1);
				if (typeof modifiedValue !== "undefined") options$1[name] = modifiedValue;
				else options$1[name] = value$1;
				if (name === "group") _prepareGroup(options$1);
			}
		},
		destroy: function destroy() {
			pluginEvent("destroy", this);
			var el$1 = this.el;
			el$1[expando] = null;
			off(el$1, "mousedown", this._onTapStart);
			off(el$1, "touchstart", this._onTapStart);
			off(el$1, "pointerdown", this._onTapStart);
			if (this.nativeDraggable) {
				off(el$1, "dragover", this);
				off(el$1, "dragenter", this);
			}
			Array.prototype.forEach.call(el$1.querySelectorAll("[draggable]"), function(el$2) {
				el$2.removeAttribute("draggable");
			});
			this._onDrop();
			this._disableDelayedDragEvents();
			sortables.splice(sortables.indexOf(this.el), 1);
			this.el = el$1 = null;
		},
		_hideClone: function _hideClone() {
			if (!cloneHidden) {
				pluginEvent("hideClone", this);
				if (Sortable.eventCanceled) return;
				css(cloneEl, "display", "none");
				if (this.options.removeCloneOnHide && cloneEl.parentNode) cloneEl.parentNode.removeChild(cloneEl);
				cloneHidden = true;
			}
		},
		_showClone: function _showClone(putSortable$1) {
			if (putSortable$1.lastPutMode !== "clone") {
				this._hideClone();
				return;
			}
			if (cloneHidden) {
				pluginEvent("showClone", this);
				if (Sortable.eventCanceled) return;
				if (dragEl.parentNode == rootEl && !this.options.group.revertClone) rootEl.insertBefore(cloneEl, dragEl);
				else if (nextEl) rootEl.insertBefore(cloneEl, nextEl);
				else rootEl.appendChild(cloneEl);
				if (this.options.group.revertClone) this.animate(dragEl, cloneEl);
				css(cloneEl, "display", "");
				cloneHidden = false;
			}
		}
	};
	if (documentExists) on(document, "touchmove", function(evt) {
		if ((Sortable.active || awaitingDragStarted) && evt.cancelable) evt.preventDefault();
	});
	Sortable.utils = {
		on,
		off,
		css,
		find,
		is: function is(el$1, selector) {
			return !!closest(el$1, selector, el$1, false);
		},
		extend,
		throttle,
		closest,
		toggleClass,
		clone,
		index,
		nextTick: _nextTick,
		cancelNextTick: _cancelNextTick,
		detectDirection: _detectDirection,
		getChild
	};
	Sortable.get = function(element) {
		return element[expando];
	};
	Sortable.mount = function() {
		for (var _len = arguments.length, plugins$1 = new Array(_len), _key = 0; _key < _len; _key++) plugins$1[_key] = arguments[_key];
		if (plugins$1[0].constructor === Array) plugins$1 = plugins$1[0];
		plugins$1.forEach(function(plugin) {
			if (!plugin.prototype || !plugin.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
			if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
			PluginManager.mount(plugin);
		});
	};
	Sortable.create = function(el$1, options$1) {
		return new Sortable(el$1, options$1);
	};
	Sortable.version = version;
	autoScrolls = [], scrolling = false;
	autoScroll = throttle(function(evt, options$1, rootEl$1, isFallback) {
		if (!options$1.scroll) return;
		var x = (evt.touches ? evt.touches[0] : evt).clientX, y$1 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options$1.scrollSensitivity, speed = options$1.scrollSpeed, winScroller = getWindowScrollingElement();
		var scrollThisInstance = false, scrollCustomFn;
		if (scrollRootEl !== rootEl$1) {
			scrollRootEl = rootEl$1;
			clearAutoScrolls();
			scrollEl = options$1.scroll;
			scrollCustomFn = options$1.scrollFn;
			if (scrollEl === true) scrollEl = getParentAutoScrollElement(rootEl$1, true);
		}
		var layersOut = 0;
		var currentParent = scrollEl;
		do {
			var el$1 = currentParent, rect = getRect(el$1), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el$1.scrollWidth, scrollHeight = el$1.scrollHeight, elCSS = css(el$1), scrollPosX = el$1.scrollLeft, scrollPosY = el$1.scrollTop;
			if (el$1 === winScroller) {
				canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
				canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
			} else {
				canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
				canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
			}
			var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
			var vy$1 = canScrollY && (Math.abs(bottom - y$1) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y$1) <= sens && !!scrollPosY);
			if (!autoScrolls[layersOut]) {
				for (var i = 0; i <= layersOut; i++) if (!autoScrolls[i]) autoScrolls[i] = {};
			}
			if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy$1 || autoScrolls[layersOut].el !== el$1) {
				autoScrolls[layersOut].el = el$1;
				autoScrolls[layersOut].vx = vx;
				autoScrolls[layersOut].vy = vy$1;
				clearInterval(autoScrolls[layersOut].pid);
				if (vx != 0 || vy$1 != 0) {
					scrollThisInstance = true;
					autoScrolls[layersOut].pid = setInterval(function() {
						if (isFallback && this.layer === 0) Sortable.active._onTouchMove(touchEvt$1);
						var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
						var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
						if (typeof scrollCustomFn === "function") {
							if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") return;
						}
						scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
					}.bind({ layer: layersOut }), 24);
				}
			}
			layersOut++;
		} while (options$1.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
		scrolling = scrollThisInstance;
	}, 30);
	drop = function drop$1(_ref) {
		var originalEvent = _ref.originalEvent, putSortable$1 = _ref.putSortable, dragEl$2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
		if (!originalEvent) return;
		var toSortable = putSortable$1 || activeSortable;
		hideGhostForTarget();
		var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
		var target = document.elementFromPoint(touch.clientX, touch.clientY);
		unhideGhostForTarget();
		if (toSortable && !toSortable.el.contains(target)) {
			dispatchSortableEvent("spill");
			this.onSpill({
				dragEl: dragEl$2,
				putSortable: putSortable$1
			});
		}
	};
	Revert.prototype = {
		startIndex: null,
		dragStart: function dragStart(_ref2) {
			this.startIndex = _ref2.oldDraggableIndex;
		},
		onSpill: function onSpill(_ref3) {
			var dragEl$2 = _ref3.dragEl, putSortable$1 = _ref3.putSortable;
			this.sortable.captureAnimationState();
			if (putSortable$1) putSortable$1.captureAnimationState();
			var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
			if (nextSibling) this.sortable.el.insertBefore(dragEl$2, nextSibling);
			else this.sortable.el.appendChild(dragEl$2);
			this.sortable.animateAll();
			if (putSortable$1) putSortable$1.animateAll();
		},
		drop
	};
	_extends(Revert, { pluginName: "revertOnSpill" });
	Remove.prototype = {
		onSpill: function onSpill(_ref4) {
			var dragEl$2 = _ref4.dragEl;
			var parentSortable = _ref4.putSortable || this.sortable;
			parentSortable.captureAnimationState();
			dragEl$2.parentNode && dragEl$2.parentNode.removeChild(dragEl$2);
			parentSortable.animateAll();
		},
		drop
	};
	_extends(Remove, { pluginName: "removeOnSpill" });
	multiDragElements = [], multiDragClones = [], initialFolding = false, folding = false, dragStarted = false;
	Sortable.mount(new AutoScrollPlugin());
	Sortable.mount(Remove, Revert);
	sortable_esm_default = Sortable;
}));
var require_vuedraggable_umd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function webpackUniversalModuleDefinition(root, factory) {
		if (typeof exports === "object" && typeof module === "object") module.exports = factory(require_vue(), (init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
		else if (typeof define === "function" && define.amd) define([, "sortablejs"], factory);
		else if (typeof exports === "object") exports["vuedraggable"] = factory(require_vue(), (init_sortable_esm(), __toCommonJS(sortable_esm_exports)));
		else root["vuedraggable"] = factory(root["Vue"], root["Sortable"]);
	})(typeof self !== "undefined" ? self : exports, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
		return (function(modules) {
			var installedModules = {};
			function __webpack_require__(moduleId) {
				if (installedModules[moduleId]) return installedModules[moduleId].exports;
				var module$1 = installedModules[moduleId] = {
					i: moduleId,
					l: false,
					exports: {}
				};
				modules[moduleId].call(module$1.exports, module$1, module$1.exports, __webpack_require__);
				module$1.l = true;
				return module$1.exports;
			}
			__webpack_require__.m = modules;
			__webpack_require__.c = installedModules;
			__webpack_require__.d = function(exports$1, name, getter) {
				if (!__webpack_require__.o(exports$1, name)) Object.defineProperty(exports$1, name, {
					enumerable: true,
					get: getter
				});
			};
			__webpack_require__.r = function(exports$1) {
				if (typeof Symbol !== "undefined" && Symbol.toStringTag) Object.defineProperty(exports$1, Symbol.toStringTag, { value: "Module" });
				Object.defineProperty(exports$1, "__esModule", { value: true });
			};
			__webpack_require__.t = function(value$1, mode) {
				if (mode & 1) value$1 = __webpack_require__(value$1);
				if (mode & 8) return value$1;
				if (mode & 4 && typeof value$1 === "object" && value$1 && value$1.__esModule) return value$1;
				var ns$1 = Object.create(null);
				__webpack_require__.r(ns$1);
				Object.defineProperty(ns$1, "default", {
					enumerable: true,
					value: value$1
				});
				if (mode & 2 && typeof value$1 != "string") for (var key in value$1) __webpack_require__.d(ns$1, key, function(key$1) {
					return value$1[key$1];
				}.bind(null, key));
				return ns$1;
			};
			__webpack_require__.n = function(module$1) {
				var getter = module$1 && module$1.__esModule ? function getDefault() {
					return module$1["default"];
				} : function getModuleExports() {
					return module$1;
				};
				__webpack_require__.d(getter, "a", getter);
				return getter;
			};
			__webpack_require__.o = function(object, property) {
				return Object.prototype.hasOwnProperty.call(object, property);
			};
			__webpack_require__.p = "";
			return __webpack_require__(__webpack_require__.s = "fb15");
		})({
			"00ee": (function(module$1, exports$1, __webpack_require__) {
				var TO_STRING_TAG = __webpack_require__("b622")("toStringTag");
				var test = {};
				test[TO_STRING_TAG] = "z";
				module$1.exports = String(test) === "[object z]";
			}),
			"0366": (function(module$1, exports$1, __webpack_require__) {
				var aFunction = __webpack_require__("1c0b");
				module$1.exports = function(fn$2, that, length) {
					aFunction(fn$2);
					if (that === void 0) return fn$2;
					switch (length) {
						case 0: return function() {
							return fn$2.call(that);
						};
						case 1: return function(a) {
							return fn$2.call(that, a);
						};
						case 2: return function(a, b$1) {
							return fn$2.call(that, a, b$1);
						};
						case 3: return function(a, b$1, c) {
							return fn$2.call(that, a, b$1, c);
						};
					}
					return function() {
						return fn$2.apply(that, arguments);
					};
				};
			}),
			"057f": (function(module$1, exports$1, __webpack_require__) {
				var toIndexedObject = __webpack_require__("fc6a");
				var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
				var toString = {}.toString;
				var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
				var getWindowNames = function(it$2) {
					try {
						return nativeGetOwnPropertyNames(it$2);
					} catch (error) {
						return windowNames.slice();
					}
				};
				module$1.exports.f = function getOwnPropertyNames(it$2) {
					return windowNames && toString.call(it$2) == "[object Window]" ? getWindowNames(it$2) : nativeGetOwnPropertyNames(toIndexedObject(it$2));
				};
			}),
			"06cf": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var propertyIsEnumerableModule = __webpack_require__("d1e7");
				var createPropertyDescriptor = __webpack_require__("5c6c");
				var toIndexedObject = __webpack_require__("fc6a");
				var toPrimitive = __webpack_require__("c04e");
				var has = __webpack_require__("5135");
				var IE8_DOM_DEFINE = __webpack_require__("0cfb");
				var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
				exports$1.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P$2) {
					O = toIndexedObject(O);
					P$2 = toPrimitive(P$2, true);
					if (IE8_DOM_DEFINE) try {
						return nativeGetOwnPropertyDescriptor(O, P$2);
					} catch (error) {}
					if (has(O, P$2)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P$2), O[P$2]);
				};
			}),
			"0cfb": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var fails = __webpack_require__("d039");
				var createElement = __webpack_require__("cc12");
				module$1.exports = !DESCRIPTORS && !fails(function() {
					return Object.defineProperty(createElement("div"), "a", { get: function() {
						return 7;
					} }).a != 7;
				});
			}),
			"13d5": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $reduce = __webpack_require__("d58f").left;
				var arrayMethodIsStrict = __webpack_require__("a640");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var STRICT_METHOD = arrayMethodIsStrict("reduce");
				var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
				$$1({
					target: "Array",
					proto: true,
					forced: !STRICT_METHOD || !USES_TO_LENGTH
				}, { reduce: function reduce(callbackfn) {
					return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
				} });
			}),
			"14c3": (function(module$1, exports$1, __webpack_require__) {
				var classof = __webpack_require__("c6b6");
				var regexpExec = __webpack_require__("9263");
				module$1.exports = function(R, S$2) {
					var exec = R.exec;
					if (typeof exec === "function") {
						var result = exec.call(R, S$2);
						if (typeof result !== "object") throw TypeError("RegExp exec method returned something other than an Object or null");
						return result;
					}
					if (classof(R) !== "RegExp") throw TypeError("RegExp#exec called on incompatible receiver");
					return regexpExec.call(R, S$2);
				};
			}),
			"159b": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var DOMIterables = __webpack_require__("fdbc");
				var forEach = __webpack_require__("17c2");
				var createNonEnumerableProperty = __webpack_require__("9112");
				for (var COLLECTION_NAME in DOMIterables) {
					var Collection = global[COLLECTION_NAME];
					var CollectionPrototype = Collection && Collection.prototype;
					if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
						createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
					} catch (error) {
						CollectionPrototype.forEach = forEach;
					}
				}
			}),
			"17c2": (function(module$1, exports$1, __webpack_require__) {
				var $forEach = __webpack_require__("b727").forEach;
				var arrayMethodIsStrict = __webpack_require__("a640");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var STRICT_METHOD = arrayMethodIsStrict("forEach");
				var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
				module$1.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn) {
					return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
				} : [].forEach;
			}),
			"1be4": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = __webpack_require__("d066")("document", "documentElement");
			}),
			"1c0b": (function(module$1, exports$1) {
				module$1.exports = function(it$2) {
					if (typeof it$2 != "function") throw TypeError(String(it$2) + " is not a function");
					return it$2;
				};
			}),
			"1c7e": (function(module$1, exports$1, __webpack_require__) {
				var ITERATOR = __webpack_require__("b622")("iterator");
				var SAFE_CLOSING = false;
				try {
					var called = 0;
					var iteratorWithReturn = {
						next: function() {
							return { done: !!called++ };
						},
						"return": function() {
							SAFE_CLOSING = true;
						}
					};
					iteratorWithReturn[ITERATOR] = function() {
						return this;
					};
					Array.from(iteratorWithReturn, function() {
						throw 2;
					});
				} catch (error) {}
				module$1.exports = function(exec, SKIP_CLOSING) {
					if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
					var ITERATION_SUPPORT = false;
					try {
						var object = {};
						object[ITERATOR] = function() {
							return { next: function() {
								return { done: ITERATION_SUPPORT = true };
							} };
						};
						exec(object);
					} catch (error) {}
					return ITERATION_SUPPORT;
				};
			}),
			"1d80": (function(module$1, exports$1) {
				module$1.exports = function(it$2) {
					if (it$2 == void 0) throw TypeError("Can't call method on " + it$2);
					return it$2;
				};
			}),
			"1dde": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				var wellKnownSymbol = __webpack_require__("b622");
				var V8_VERSION = __webpack_require__("2d00");
				var SPECIES = wellKnownSymbol("species");
				module$1.exports = function(METHOD_NAME) {
					return V8_VERSION >= 51 || !fails(function() {
						var array = [];
						var constructor = array.constructor = {};
						constructor[SPECIES] = function() {
							return { foo: 1 };
						};
						return array[METHOD_NAME](Boolean).foo !== 1;
					});
				};
			}),
			"23cb": (function(module$1, exports$1, __webpack_require__) {
				var toInteger = __webpack_require__("a691");
				var max = Math.max;
				var min = Math.min;
				module$1.exports = function(index$1, length) {
					var integer = toInteger(index$1);
					return integer < 0 ? max(integer + length, 0) : min(integer, length);
				};
			}),
			"23e7": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
				var createNonEnumerableProperty = __webpack_require__("9112");
				var redefine = __webpack_require__("6eeb");
				var setGlobal = __webpack_require__("ce4e");
				var copyConstructorProperties = __webpack_require__("e893");
				var isForced = __webpack_require__("94ca");
				module$1.exports = function(options$1, source) {
					var TARGET = options$1.target;
					var GLOBAL = options$1.global;
					var STATIC = options$1.stat;
					var FORCED, target, key, targetProperty, sourceProperty, descriptor;
					if (GLOBAL) target = global;
					else if (STATIC) target = global[TARGET] || setGlobal(TARGET, {});
					else target = (global[TARGET] || {}).prototype;
					if (target) for (key in source) {
						sourceProperty = source[key];
						if (options$1.noTargetGet) {
							descriptor = getOwnPropertyDescriptor(target, key);
							targetProperty = descriptor && descriptor.value;
						} else targetProperty = target[key];
						FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options$1.forced);
						if (!FORCED && targetProperty !== void 0) {
							if (typeof sourceProperty === typeof targetProperty) continue;
							copyConstructorProperties(sourceProperty, targetProperty);
						}
						if (options$1.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, "sham", true);
						redefine(target, key, sourceProperty, options$1);
					}
				};
			}),
			"241c": (function(module$1, exports$1, __webpack_require__) {
				var internalObjectKeys = __webpack_require__("ca84");
				var hiddenKeys = __webpack_require__("7839").concat("length", "prototype");
				exports$1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
					return internalObjectKeys(O, hiddenKeys);
				};
			}),
			"25f0": (function(module$1, exports$1, __webpack_require__) {
				var redefine = __webpack_require__("6eeb");
				var anObject = __webpack_require__("825a");
				var fails = __webpack_require__("d039");
				var flags = __webpack_require__("ad6d");
				var TO_STRING = "toString";
				var RegExpPrototype = RegExp.prototype;
				var nativeToString = RegExpPrototype[TO_STRING];
				var NOT_GENERIC = fails(function() {
					return nativeToString.call({
						source: "a",
						flags: "b"
					}) != "/a/b";
				});
				var INCORRECT_NAME = nativeToString.name != TO_STRING;
				if (NOT_GENERIC || INCORRECT_NAME) redefine(RegExp.prototype, TO_STRING, function toString() {
					var R = anObject(this);
					var p = String(R.source);
					var rf = R.flags;
					var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
					return "/" + p + "/" + f;
				}, { unsafe: true });
			}),
			"2ca0": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
				var toLength = __webpack_require__("50c4");
				var notARegExp = __webpack_require__("5a34");
				var requireObjectCoercible = __webpack_require__("1d80");
				var correctIsRegExpLogic = __webpack_require__("ab13");
				var IS_PURE = __webpack_require__("c430");
				var nativeStartsWith = "".startsWith;
				var min = Math.min;
				var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
				$$1({
					target: "String",
					proto: true,
					forced: !(!IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
						var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
						return descriptor && !descriptor.writable;
					}()) && !CORRECT_IS_REGEXP_LOGIC
				}, { startsWith: function startsWith(searchString) {
					var that = String(requireObjectCoercible(this));
					notARegExp(searchString);
					var index$1 = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
					var search = String(searchString);
					return nativeStartsWith ? nativeStartsWith.call(that, search, index$1) : that.slice(index$1, index$1 + search.length) === search;
				} });
			}),
			"2d00": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var userAgent$1 = __webpack_require__("342f");
				var process = global.process;
				var versions = process && process.versions;
				var v8 = versions && versions.v8;
				var match, version$1;
				if (v8) {
					match = v8.split(".");
					version$1 = match[0] + match[1];
				} else if (userAgent$1) {
					match = userAgent$1.match(/Edge\/(\d+)/);
					if (!match || match[1] >= 74) {
						match = userAgent$1.match(/Chrome\/(\d+)/);
						if (match) version$1 = match[1];
					}
				}
				module$1.exports = version$1 && +version$1;
			}),
			"342f": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = __webpack_require__("d066")("navigator", "userAgent") || "";
			}),
			"35a1": (function(module$1, exports$1, __webpack_require__) {
				var classof = __webpack_require__("f5df");
				var Iterators = __webpack_require__("3f8c");
				var ITERATOR = __webpack_require__("b622")("iterator");
				module$1.exports = function(it$2) {
					if (it$2 != void 0) return it$2[ITERATOR] || it$2["@@iterator"] || Iterators[classof(it$2)];
				};
			}),
			"37e8": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var definePropertyModule = __webpack_require__("9bf2");
				var anObject = __webpack_require__("825a");
				var objectKeys = __webpack_require__("df75");
				module$1.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
					anObject(O);
					var keys = objectKeys(Properties);
					var length = keys.length;
					var index$1 = 0;
					var key;
					while (length > index$1) definePropertyModule.f(O, key = keys[index$1++], Properties[key]);
					return O;
				};
			}),
			"3bbe": (function(module$1, exports$1, __webpack_require__) {
				var isObject$1 = __webpack_require__("861d");
				module$1.exports = function(it$2) {
					if (!isObject$1(it$2) && it$2 !== null) throw TypeError("Can't set " + String(it$2) + " as a prototype");
					return it$2;
				};
			}),
			"3ca3": (function(module$1, exports$1, __webpack_require__) {
				var charAt = __webpack_require__("6547").charAt;
				var InternalStateModule = __webpack_require__("69f3");
				var defineIterator = __webpack_require__("7dd0");
				var STRING_ITERATOR = "String Iterator";
				var setInternalState = InternalStateModule.set;
				var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
				defineIterator(String, "String", function(iterated) {
					setInternalState(this, {
						type: STRING_ITERATOR,
						string: String(iterated),
						index: 0
					});
				}, function next() {
					var state = getInternalState(this);
					var string = state.string;
					var index$1 = state.index;
					var point;
					if (index$1 >= string.length) return {
						value: void 0,
						done: true
					};
					point = charAt(string, index$1);
					state.index += point.length;
					return {
						value: point,
						done: false
					};
				});
			}),
			"3f8c": (function(module$1, exports$1) {
				module$1.exports = {};
			}),
			"4160": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var forEach = __webpack_require__("17c2");
				$$1({
					target: "Array",
					proto: true,
					forced: [].forEach != forEach
				}, { forEach });
			}),
			"428f": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = __webpack_require__("da84");
			}),
			"44ad": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				var classof = __webpack_require__("c6b6");
				var split = "".split;
				module$1.exports = fails(function() {
					return !Object("z").propertyIsEnumerable(0);
				}) ? function(it$2) {
					return classof(it$2) == "String" ? split.call(it$2, "") : Object(it$2);
				} : Object;
			}),
			"44d2": (function(module$1, exports$1, __webpack_require__) {
				var wellKnownSymbol = __webpack_require__("b622");
				var create = __webpack_require__("7c73");
				var definePropertyModule = __webpack_require__("9bf2");
				var UNSCOPABLES = wellKnownSymbol("unscopables");
				var ArrayPrototype = Array.prototype;
				if (ArrayPrototype[UNSCOPABLES] == void 0) definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
					configurable: true,
					value: create(null)
				});
				module$1.exports = function(key) {
					ArrayPrototype[UNSCOPABLES][key] = true;
				};
			}),
			"44e7": (function(module$1, exports$1, __webpack_require__) {
				var isObject$1 = __webpack_require__("861d");
				var classof = __webpack_require__("c6b6");
				var MATCH = __webpack_require__("b622")("match");
				module$1.exports = function(it$2) {
					var isRegExp;
					return isObject$1(it$2) && ((isRegExp = it$2[MATCH]) !== void 0 ? !!isRegExp : classof(it$2) == "RegExp");
				};
			}),
			"4930": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				module$1.exports = !!Object.getOwnPropertySymbols && !fails(function() {
					return !String(Symbol());
				});
			}),
			"4d64": (function(module$1, exports$1, __webpack_require__) {
				var toIndexedObject = __webpack_require__("fc6a");
				var toLength = __webpack_require__("50c4");
				var toAbsoluteIndex = __webpack_require__("23cb");
				var createMethod = function(IS_INCLUDES) {
					return function($this, el$1, fromIndex) {
						var O = toIndexedObject($this);
						var length = toLength(O.length);
						var index$1 = toAbsoluteIndex(fromIndex, length);
						var value$1;
						if (IS_INCLUDES && el$1 != el$1) while (length > index$1) {
							value$1 = O[index$1++];
							if (value$1 != value$1) return true;
						}
						else for (; length > index$1; index$1++) if ((IS_INCLUDES || index$1 in O) && O[index$1] === el$1) return IS_INCLUDES || index$1 || 0;
						return !IS_INCLUDES && -1;
					};
				};
				module$1.exports = {
					includes: createMethod(true),
					indexOf: createMethod(false)
				};
			}),
			"4de4": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $filter = __webpack_require__("b727").filter;
				var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
				var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
				$$1({
					target: "Array",
					proto: true,
					forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
				}, { filter: function filter$1(callbackfn) {
					return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
				} });
			}),
			"4df4": (function(module$1, exports$1, __webpack_require__) {
				var bind = __webpack_require__("0366");
				var toObject = __webpack_require__("7b0b");
				var callWithSafeIterationClosing = __webpack_require__("9bdd");
				var isArrayIteratorMethod = __webpack_require__("e95a");
				var toLength = __webpack_require__("50c4");
				var createProperty = __webpack_require__("8418");
				var getIteratorMethod = __webpack_require__("35a1");
				module$1.exports = function from(arrayLike) {
					var O = toObject(arrayLike);
					var C = typeof this == "function" ? this : Array;
					var argumentsLength = arguments.length;
					var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
					var mapping = mapfn !== void 0;
					var iteratorMethod = getIteratorMethod(O);
					var index$1 = 0;
					var length, result, step, iterator, next, value$1;
					if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
					if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
						iterator = iteratorMethod.call(O);
						next = iterator.next;
						result = new C();
						for (; !(step = next.call(iterator)).done; index$1++) {
							value$1 = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index$1], true) : step.value;
							createProperty(result, index$1, value$1);
						}
					} else {
						length = toLength(O.length);
						result = new C(length);
						for (; length > index$1; index$1++) {
							value$1 = mapping ? mapfn(O[index$1], index$1) : O[index$1];
							createProperty(result, index$1, value$1);
						}
					}
					result.length = index$1;
					return result;
				};
			}),
			"4fad": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $entries = __webpack_require__("6f53").entries;
				$$1({
					target: "Object",
					stat: true
				}, { entries: function entries(O) {
					return $entries(O);
				} });
			}),
			"50c4": (function(module$1, exports$1, __webpack_require__) {
				var toInteger = __webpack_require__("a691");
				var min = Math.min;
				module$1.exports = function(argument) {
					return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
				};
			}),
			"5135": (function(module$1, exports$1) {
				var hasOwnProperty = {}.hasOwnProperty;
				module$1.exports = function(it$2, key) {
					return hasOwnProperty.call(it$2, key);
				};
			}),
			"5319": (function(module$1, exports$1, __webpack_require__) {
				var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
				var anObject = __webpack_require__("825a");
				var toObject = __webpack_require__("7b0b");
				var toLength = __webpack_require__("50c4");
				var toInteger = __webpack_require__("a691");
				var requireObjectCoercible = __webpack_require__("1d80");
				var advanceStringIndex = __webpack_require__("8aa5");
				var regExpExec = __webpack_require__("14c3");
				var max = Math.max;
				var min = Math.min;
				var floor = Math.floor;
				var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
				var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
				var maybeToString = function(it$2) {
					return it$2 === void 0 ? it$2 : String(it$2);
				};
				fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
					var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
					var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
					var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
					return [function replace(searchValue, replaceValue) {
						var O = requireObjectCoercible(this);
						var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE];
						return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
					}, function(regexp, replaceValue) {
						if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
							var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
							if (res.done) return res.value;
						}
						var rx = anObject(regexp);
						var S$2 = String(this);
						var functionalReplace = typeof replaceValue === "function";
						if (!functionalReplace) replaceValue = String(replaceValue);
						var global = rx.global;
						if (global) {
							var fullUnicode = rx.unicode;
							rx.lastIndex = 0;
						}
						var results = [];
						while (true) {
							var result = regExpExec(rx, S$2);
							if (result === null) break;
							results.push(result);
							if (!global) break;
							if (String(result[0]) === "") rx.lastIndex = advanceStringIndex(S$2, toLength(rx.lastIndex), fullUnicode);
						}
						var accumulatedResult = "";
						var nextSourcePosition = 0;
						for (var i = 0; i < results.length; i++) {
							result = results[i];
							var matched = String(result[0]);
							var position = max(min(toInteger(result.index), S$2.length), 0);
							var captures = [];
							for (var j$1 = 1; j$1 < result.length; j$1++) captures.push(maybeToString(result[j$1]));
							var namedCaptures = result.groups;
							if (functionalReplace) {
								var replacerArgs = [matched].concat(captures, position, S$2);
								if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
								var replacement = String(replaceValue.apply(void 0, replacerArgs));
							} else replacement = getSubstitution(matched, S$2, position, captures, namedCaptures, replaceValue);
							if (position >= nextSourcePosition) {
								accumulatedResult += S$2.slice(nextSourcePosition, position) + replacement;
								nextSourcePosition = position + matched.length;
							}
						}
						return accumulatedResult + S$2.slice(nextSourcePosition);
					}];
					function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
						var tailPos = position + matched.length;
						var m$1 = captures.length;
						var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
						if (namedCaptures !== void 0) {
							namedCaptures = toObject(namedCaptures);
							symbols = SUBSTITUTION_SYMBOLS;
						}
						return nativeReplace.call(replacement, symbols, function(match, ch) {
							var capture;
							switch (ch.charAt(0)) {
								case "$": return "$";
								case "&": return matched;
								case "`": return str.slice(0, position);
								case "'": return str.slice(tailPos);
								case "<":
									capture = namedCaptures[ch.slice(1, -1)];
									break;
								default:
									var n = +ch;
									if (n === 0) return match;
									if (n > m$1) {
										var f = floor(n / 10);
										if (f === 0) return match;
										if (f <= m$1) return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
										return match;
									}
									capture = captures[n - 1];
							}
							return capture === void 0 ? "" : capture;
						});
					}
				});
			}),
			"5692": (function(module$1, exports$1, __webpack_require__) {
				var IS_PURE = __webpack_require__("c430");
				var store = __webpack_require__("c6cd");
				(module$1.exports = function(key, value$1) {
					return store[key] || (store[key] = value$1 !== void 0 ? value$1 : {});
				})("versions", []).push({
					version: "3.6.5",
					mode: IS_PURE ? "pure" : "global",
					copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
				});
			}),
			"56ef": (function(module$1, exports$1, __webpack_require__) {
				var getBuiltIn = __webpack_require__("d066");
				var getOwnPropertyNamesModule = __webpack_require__("241c");
				var getOwnPropertySymbolsModule = __webpack_require__("7418");
				var anObject = __webpack_require__("825a");
				module$1.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys$1(it$2) {
					var keys = getOwnPropertyNamesModule.f(anObject(it$2));
					var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
					return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it$2)) : keys;
				};
			}),
			"5a34": (function(module$1, exports$1, __webpack_require__) {
				var isRegExp = __webpack_require__("44e7");
				module$1.exports = function(it$2) {
					if (isRegExp(it$2)) throw TypeError("The method doesn't accept regular expressions");
					return it$2;
				};
			}),
			"5c6c": (function(module$1, exports$1) {
				module$1.exports = function(bitmap, value$1) {
					return {
						enumerable: !(bitmap & 1),
						configurable: !(bitmap & 2),
						writable: !(bitmap & 4),
						value: value$1
					};
				};
			}),
			"5db7": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var flattenIntoArray = __webpack_require__("a2bf");
				var toObject = __webpack_require__("7b0b");
				var toLength = __webpack_require__("50c4");
				var aFunction = __webpack_require__("1c0b");
				var arraySpeciesCreate = __webpack_require__("65f0");
				$$1({
					target: "Array",
					proto: true
				}, { flatMap: function flatMap(callbackfn) {
					var O = toObject(this);
					var sourceLen = toLength(O.length);
					var A$1;
					aFunction(callbackfn);
					A$1 = arraySpeciesCreate(O, 0);
					A$1.length = flattenIntoArray(A$1, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
					return A$1;
				} });
			}),
			"6547": (function(module$1, exports$1, __webpack_require__) {
				var toInteger = __webpack_require__("a691");
				var requireObjectCoercible = __webpack_require__("1d80");
				var createMethod = function(CONVERT_TO_STRING) {
					return function($this, pos) {
						var S$2 = String(requireObjectCoercible($this));
						var position = toInteger(pos);
						var size = S$2.length;
						var first, second;
						if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
						first = S$2.charCodeAt(position);
						return first < 55296 || first > 56319 || position + 1 === size || (second = S$2.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S$2.charAt(position) : first : CONVERT_TO_STRING ? S$2.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
					};
				};
				module$1.exports = {
					codeAt: createMethod(false),
					charAt: createMethod(true)
				};
			}),
			"65f0": (function(module$1, exports$1, __webpack_require__) {
				var isObject$1 = __webpack_require__("861d");
				var isArray = __webpack_require__("e8b5");
				var SPECIES = __webpack_require__("b622")("species");
				module$1.exports = function(originalArray, length) {
					var C;
					if (isArray(originalArray)) {
						C = originalArray.constructor;
						if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
						else if (isObject$1(C)) {
							C = C[SPECIES];
							if (C === null) C = void 0;
						}
					}
					return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
				};
			}),
			"69f3": (function(module$1, exports$1, __webpack_require__) {
				var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
				var global = __webpack_require__("da84");
				var isObject$1 = __webpack_require__("861d");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var objectHas = __webpack_require__("5135");
				var sharedKey = __webpack_require__("f772");
				var hiddenKeys = __webpack_require__("d012");
				var WeakMap$1 = global.WeakMap;
				var set$3, get$6, has;
				var enforce = function(it$2) {
					return has(it$2) ? get$6(it$2) : set$3(it$2, {});
				};
				var getterFor = function(TYPE) {
					return function(it$2) {
						var state;
						if (!isObject$1(it$2) || (state = get$6(it$2)).type !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required");
						return state;
					};
				};
				if (NATIVE_WEAK_MAP) {
					var store = new WeakMap$1();
					var wmget = store.get;
					var wmhas = store.has;
					var wmset = store.set;
					set$3 = function(it$2, metadata) {
						wmset.call(store, it$2, metadata);
						return metadata;
					};
					get$6 = function(it$2) {
						return wmget.call(store, it$2) || {};
					};
					has = function(it$2) {
						return wmhas.call(store, it$2);
					};
				} else {
					var STATE = sharedKey("state");
					hiddenKeys[STATE] = true;
					set$3 = function(it$2, metadata) {
						createNonEnumerableProperty(it$2, STATE, metadata);
						return metadata;
					};
					get$6 = function(it$2) {
						return objectHas(it$2, STATE) ? it$2[STATE] : {};
					};
					has = function(it$2) {
						return objectHas(it$2, STATE);
					};
				}
				module$1.exports = {
					set: set$3,
					get: get$6,
					has,
					enforce,
					getterFor
				};
			}),
			"6eeb": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var has = __webpack_require__("5135");
				var setGlobal = __webpack_require__("ce4e");
				var inspectSource = __webpack_require__("8925");
				var InternalStateModule = __webpack_require__("69f3");
				var getInternalState = InternalStateModule.get;
				var enforceInternalState = InternalStateModule.enforce;
				var TEMPLATE = String(String).split("String");
				(module$1.exports = function(O, key, value$1, options$1) {
					var unsafe = options$1 ? !!options$1.unsafe : false;
					var simple = options$1 ? !!options$1.enumerable : false;
					var noTargetGet = options$1 ? !!options$1.noTargetGet : false;
					if (typeof value$1 == "function") {
						if (typeof key == "string" && !has(value$1, "name")) createNonEnumerableProperty(value$1, "name", key);
						enforceInternalState(value$1).source = TEMPLATE.join(typeof key == "string" ? key : "");
					}
					if (O === global) {
						if (simple) O[key] = value$1;
						else setGlobal(key, value$1);
						return;
					} else if (!unsafe) delete O[key];
					else if (!noTargetGet && O[key]) simple = true;
					if (simple) O[key] = value$1;
					else createNonEnumerableProperty(O, key, value$1);
				})(Function.prototype, "toString", function toString() {
					return typeof this == "function" && getInternalState(this).source || inspectSource(this);
				});
			}),
			"6f53": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var objectKeys = __webpack_require__("df75");
				var toIndexedObject = __webpack_require__("fc6a");
				var propertyIsEnumerable = __webpack_require__("d1e7").f;
				var createMethod = function(TO_ENTRIES) {
					return function(it$2) {
						var O = toIndexedObject(it$2);
						var keys = objectKeys(O);
						var length = keys.length;
						var i = 0;
						var result = [];
						var key;
						while (length > i) {
							key = keys[i++];
							if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
						}
						return result;
					};
				};
				module$1.exports = {
					entries: createMethod(true),
					values: createMethod(false)
				};
			}),
			"73d9": (function(module$1, exports$1, __webpack_require__) {
				__webpack_require__("44d2")("flatMap");
			}),
			"7418": (function(module$1, exports$1) {
				exports$1.f = Object.getOwnPropertySymbols;
			}),
			"746f": (function(module$1, exports$1, __webpack_require__) {
				var path = __webpack_require__("428f");
				var has = __webpack_require__("5135");
				var wrappedWellKnownSymbolModule = __webpack_require__("e538");
				var defineProperty = __webpack_require__("9bf2").f;
				module$1.exports = function(NAME) {
					var Symbol$1 = path.Symbol || (path.Symbol = {});
					if (!has(Symbol$1, NAME)) defineProperty(Symbol$1, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });
				};
			}),
			"7839": (function(module$1, exports$1) {
				module$1.exports = [
					"constructor",
					"hasOwnProperty",
					"isPrototypeOf",
					"propertyIsEnumerable",
					"toLocaleString",
					"toString",
					"valueOf"
				];
			}),
			"7b0b": (function(module$1, exports$1, __webpack_require__) {
				var requireObjectCoercible = __webpack_require__("1d80");
				module$1.exports = function(argument) {
					return Object(requireObjectCoercible(argument));
				};
			}),
			"7c73": (function(module$1, exports$1, __webpack_require__) {
				var anObject = __webpack_require__("825a");
				var defineProperties = __webpack_require__("37e8");
				var enumBugKeys = __webpack_require__("7839");
				var hiddenKeys = __webpack_require__("d012");
				var html$1 = __webpack_require__("1be4");
				var documentCreateElement = __webpack_require__("cc12");
				var sharedKey = __webpack_require__("f772");
				var GT = ">";
				var LT = "<";
				var PROTOTYPE = "prototype";
				var SCRIPT = "script";
				var IE_PROTO = sharedKey("IE_PROTO");
				var EmptyConstructor = function() {};
				var scriptTag = function(content$3) {
					return LT + SCRIPT + GT + content$3 + LT + "/" + SCRIPT + GT;
				};
				var NullProtoObjectViaActiveX = function(activeXDocument$1) {
					activeXDocument$1.write(scriptTag(""));
					activeXDocument$1.close();
					var temp = activeXDocument$1.parentWindow.Object;
					activeXDocument$1 = null;
					return temp;
				};
				var NullProtoObjectViaIFrame = function() {
					var iframe = documentCreateElement("iframe");
					var JS = "java" + SCRIPT + ":";
					var iframeDocument;
					iframe.style.display = "none";
					html$1.appendChild(iframe);
					iframe.src = String(JS);
					iframeDocument = iframe.contentWindow.document;
					iframeDocument.open();
					iframeDocument.write(scriptTag("document.F=Object"));
					iframeDocument.close();
					return iframeDocument.F;
				};
				var activeXDocument;
				var NullProtoObject = function() {
					try {
						activeXDocument = document.domain && new ActiveXObject("htmlfile");
					} catch (error) {}
					NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
					var length = enumBugKeys.length;
					while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
					return NullProtoObject();
				};
				hiddenKeys[IE_PROTO] = true;
				module$1.exports = Object.create || function create(O, Properties) {
					var result;
					if (O !== null) {
						EmptyConstructor[PROTOTYPE] = anObject(O);
						result = new EmptyConstructor();
						EmptyConstructor[PROTOTYPE] = null;
						result[IE_PROTO] = O;
					} else result = NullProtoObject();
					return Properties === void 0 ? result : defineProperties(result, Properties);
				};
			}),
			"7dd0": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var createIteratorConstructor = __webpack_require__("9ed3");
				var getPrototypeOf = __webpack_require__("e163");
				var setPrototypeOf = __webpack_require__("d2bb");
				var setToStringTag = __webpack_require__("d44e");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var redefine = __webpack_require__("6eeb");
				var wellKnownSymbol = __webpack_require__("b622");
				var IS_PURE = __webpack_require__("c430");
				var Iterators = __webpack_require__("3f8c");
				var IteratorsCore = __webpack_require__("ae93");
				var IteratorPrototype = IteratorsCore.IteratorPrototype;
				var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
				var ITERATOR = wellKnownSymbol("iterator");
				var KEYS = "keys";
				var VALUES = "values";
				var ENTRIES = "entries";
				var returnThis = function() {
					return this;
				};
				module$1.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
					createIteratorConstructor(IteratorConstructor, NAME, next);
					var getIterationMethod = function(KIND) {
						if (KIND === DEFAULT && defaultIterator) return defaultIterator;
						if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
						switch (KIND) {
							case KEYS: return function keys() {
								return new IteratorConstructor(this, KIND);
							};
							case VALUES: return function values$1() {
								return new IteratorConstructor(this, KIND);
							};
							case ENTRIES: return function entries() {
								return new IteratorConstructor(this, KIND);
							};
						}
						return function() {
							return new IteratorConstructor(this);
						};
					};
					var TO_STRING_TAG = NAME + " Iterator";
					var INCORRECT_VALUES_NAME = false;
					var IterablePrototype = Iterable.prototype;
					var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
					var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
					var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
					var CurrentIteratorPrototype, methods, KEY;
					if (anyNativeIterator) {
						CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
						if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
							if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
								if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
								else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
							}
							setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
							if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
						}
					}
					if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
						INCORRECT_VALUES_NAME = true;
						defaultIterator = function values$1() {
							return nativeIterator.call(this);
						};
					}
					if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
					Iterators[NAME] = defaultIterator;
					if (DEFAULT) {
						methods = {
							values: getIterationMethod(VALUES),
							keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
							entries: getIterationMethod(ENTRIES)
						};
						if (FORCED) {
							for (KEY in methods) if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);
						} else $$1({
							target: NAME,
							proto: true,
							forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
						}, methods);
					}
					return methods;
				};
			}),
			"7f9a": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var inspectSource = __webpack_require__("8925");
				var WeakMap$1 = global.WeakMap;
				module$1.exports = typeof WeakMap$1 === "function" && /native code/.test(inspectSource(WeakMap$1));
			}),
			"825a": (function(module$1, exports$1, __webpack_require__) {
				var isObject$1 = __webpack_require__("861d");
				module$1.exports = function(it$2) {
					if (!isObject$1(it$2)) throw TypeError(String(it$2) + " is not an object");
					return it$2;
				};
			}),
			"83ab": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = !__webpack_require__("d039")(function() {
					return Object.defineProperty({}, 1, { get: function() {
						return 7;
					} })[1] != 7;
				});
			}),
			"8418": (function(module$1, exports$1, __webpack_require__) {
				var toPrimitive = __webpack_require__("c04e");
				var definePropertyModule = __webpack_require__("9bf2");
				var createPropertyDescriptor = __webpack_require__("5c6c");
				module$1.exports = function(object, key, value$1) {
					var propertyKey = toPrimitive(key);
					if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value$1));
					else object[propertyKey] = value$1;
				};
			}),
			"861d": (function(module$1, exports$1) {
				module$1.exports = function(it$2) {
					return typeof it$2 === "object" ? it$2 !== null : typeof it$2 === "function";
				};
			}),
			"8875": (function(module$1, exports$1, __webpack_require__) {
				var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
				(function(root, factory) {
					__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports$1, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module$1.exports = __WEBPACK_AMD_DEFINE_RESULT__);
				})(typeof self !== "undefined" ? self : this, function() {
					function getCurrentScript() {
						var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
						if (!descriptor && "currentScript" in document && document.currentScript) return document.currentScript;
						if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) return document.currentScript;
						try {
							throw new Error();
						} catch (err) {
							var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(err.stack) || /@([^@]*):(\d+):(\d+)\s*$/gi.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
							if (scriptLocation === currentLocation) {
								pageSource = document.documentElement.outerHTML;
								inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
								inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
							}
							for (var i = 0; i < scripts.length; i++) {
								if (scripts[i].readyState === "interactive") return scripts[i];
								if (scripts[i].src === scriptLocation) return scripts[i];
								if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) return scripts[i];
							}
							return null;
						}
					}
					return getCurrentScript;
				});
			}),
			"8925": (function(module$1, exports$1, __webpack_require__) {
				var store = __webpack_require__("c6cd");
				var functionToString = Function.toString;
				if (typeof store.inspectSource != "function") store.inspectSource = function(it$2) {
					return functionToString.call(it$2);
				};
				module$1.exports = store.inspectSource;
			}),
			"8aa5": (function(module$1, exports$1, __webpack_require__) {
				var charAt = __webpack_require__("6547").charAt;
				module$1.exports = function(S$2, index$1, unicode) {
					return index$1 + (unicode ? charAt(S$2, index$1).length : 1);
				};
			}),
			"8bbf": (function(module$1, exports$1) {
				module$1.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
			}),
			"90e3": (function(module$1, exports$1) {
				var id = 0;
				var postfix = Math.random();
				module$1.exports = function(key) {
					return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
				};
			}),
			"9112": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var definePropertyModule = __webpack_require__("9bf2");
				var createPropertyDescriptor = __webpack_require__("5c6c");
				module$1.exports = DESCRIPTORS ? function(object, key, value$1) {
					return definePropertyModule.f(object, key, createPropertyDescriptor(1, value$1));
				} : function(object, key, value$1) {
					object[key] = value$1;
					return object;
				};
			}),
			"9263": (function(module$1, exports$1, __webpack_require__) {
				var regexpFlags = __webpack_require__("ad6d");
				var stickyHelpers = __webpack_require__("9f7f");
				var nativeExec = RegExp.prototype.exec;
				var nativeReplace = String.prototype.replace;
				var patchedExec = nativeExec;
				var UPDATES_LAST_INDEX_WRONG = (function() {
					var re1 = /a/;
					var re2 = /b*/g;
					nativeExec.call(re1, "a");
					nativeExec.call(re2, "a");
					return re1.lastIndex !== 0 || re2.lastIndex !== 0;
				})();
				var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
				var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
				if (UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y) patchedExec = function exec(str) {
					var re$2 = this;
					var lastIndex, reCopy, match, i;
					var sticky = UNSUPPORTED_Y && re$2.sticky;
					var flags = regexpFlags.call(re$2);
					var source = re$2.source;
					var charsAdded = 0;
					var strCopy = str;
					if (sticky) {
						flags = flags.replace("y", "");
						if (flags.indexOf("g") === -1) flags += "g";
						strCopy = String(str).slice(re$2.lastIndex);
						if (re$2.lastIndex > 0 && (!re$2.multiline || re$2.multiline && str[re$2.lastIndex - 1] !== "\n")) {
							source = "(?: " + source + ")";
							strCopy = " " + strCopy;
							charsAdded++;
						}
						reCopy = new RegExp("^(?:" + source + ")", flags);
					}
					if (NPCG_INCLUDED) reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
					if (UPDATES_LAST_INDEX_WRONG) lastIndex = re$2.lastIndex;
					match = nativeExec.call(sticky ? reCopy : re$2, strCopy);
					if (sticky) if (match) {
						match.input = match.input.slice(charsAdded);
						match[0] = match[0].slice(charsAdded);
						match.index = re$2.lastIndex;
						re$2.lastIndex += match[0].length;
					} else re$2.lastIndex = 0;
					else if (UPDATES_LAST_INDEX_WRONG && match) re$2.lastIndex = re$2.global ? match.index + match[0].length : lastIndex;
					if (NPCG_INCLUDED && match && match.length > 1) nativeReplace.call(match[0], reCopy, function() {
						for (i = 1; i < arguments.length - 2; i++) if (arguments[i] === void 0) match[i] = void 0;
					});
					return match;
				};
				module$1.exports = patchedExec;
			}),
			"94ca": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				var replacement = /#|\.prototype\./;
				var isForced = function(feature, detection) {
					var value$1 = data[normalize(feature)];
					return value$1 == POLYFILL ? true : value$1 == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
				};
				var normalize = isForced.normalize = function(string) {
					return String(string).replace(replacement, ".").toLowerCase();
				};
				var data = isForced.data = {};
				var NATIVE = isForced.NATIVE = "N";
				var POLYFILL = isForced.POLYFILL = "P";
				module$1.exports = isForced;
			}),
			"99af": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var fails = __webpack_require__("d039");
				var isArray = __webpack_require__("e8b5");
				var isObject$1 = __webpack_require__("861d");
				var toObject = __webpack_require__("7b0b");
				var toLength = __webpack_require__("50c4");
				var createProperty = __webpack_require__("8418");
				var arraySpeciesCreate = __webpack_require__("65f0");
				var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
				var wellKnownSymbol = __webpack_require__("b622");
				var V8_VERSION = __webpack_require__("2d00");
				var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
				var MAX_SAFE_INTEGER = 9007199254740991;
				var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
				var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
					var array = [];
					array[IS_CONCAT_SPREADABLE] = false;
					return array.concat()[0] !== array;
				});
				var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
				var isConcatSpreadable = function(O) {
					if (!isObject$1(O)) return false;
					var spreadable = O[IS_CONCAT_SPREADABLE];
					return spreadable !== void 0 ? !!spreadable : isArray(O);
				};
				$$1({
					target: "Array",
					proto: true,
					forced: !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT
				}, { concat: function concat(arg) {
					var O = toObject(this);
					var A$1 = arraySpeciesCreate(O, 0);
					var n = 0;
					var i, k$1, length, len, E$2;
					for (i = -1, length = arguments.length; i < length; i++) {
						E$2 = i === -1 ? O : arguments[i];
						if (isConcatSpreadable(E$2)) {
							len = toLength(E$2.length);
							if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
							for (k$1 = 0; k$1 < len; k$1++, n++) if (k$1 in E$2) createProperty(A$1, n, E$2[k$1]);
						} else {
							if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
							createProperty(A$1, n++, E$2);
						}
					}
					A$1.length = n;
					return A$1;
				} });
			}),
			"9bdd": (function(module$1, exports$1, __webpack_require__) {
				var anObject = __webpack_require__("825a");
				module$1.exports = function(iterator, fn$2, value$1, ENTRIES) {
					try {
						return ENTRIES ? fn$2(anObject(value$1)[0], value$1[1]) : fn$2(value$1);
					} catch (error) {
						var returnMethod = iterator["return"];
						if (returnMethod !== void 0) anObject(returnMethod.call(iterator));
						throw error;
					}
				};
			}),
			"9bf2": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var IE8_DOM_DEFINE = __webpack_require__("0cfb");
				var anObject = __webpack_require__("825a");
				var toPrimitive = __webpack_require__("c04e");
				var nativeDefineProperty = Object.defineProperty;
				exports$1.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P$2, Attributes) {
					anObject(O);
					P$2 = toPrimitive(P$2, true);
					anObject(Attributes);
					if (IE8_DOM_DEFINE) try {
						return nativeDefineProperty(O, P$2, Attributes);
					} catch (error) {}
					if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
					if ("value" in Attributes) O[P$2] = Attributes.value;
					return O;
				};
			}),
			"9ed3": (function(module$1, exports$1, __webpack_require__) {
				var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
				var create = __webpack_require__("7c73");
				var createPropertyDescriptor = __webpack_require__("5c6c");
				var setToStringTag = __webpack_require__("d44e");
				var Iterators = __webpack_require__("3f8c");
				var returnThis = function() {
					return this;
				};
				module$1.exports = function(IteratorConstructor, NAME, next) {
					var TO_STRING_TAG = NAME + " Iterator";
					IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
					setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
					Iterators[TO_STRING_TAG] = returnThis;
					return IteratorConstructor;
				};
			}),
			"9f7f": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				function RE(s, f) {
					return RegExp(s, f);
				}
				exports$1.UNSUPPORTED_Y = fails(function() {
					var re$2 = RE("a", "y");
					re$2.lastIndex = 2;
					return re$2.exec("abcd") != null;
				});
				exports$1.BROKEN_CARET = fails(function() {
					var re$2 = RE("^r", "gy");
					re$2.lastIndex = 2;
					return re$2.exec("str") != null;
				});
			}),
			"a2bf": (function(module$1, exports$1, __webpack_require__) {
				var isArray = __webpack_require__("e8b5");
				var toLength = __webpack_require__("50c4");
				var bind = __webpack_require__("0366");
				var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
					var targetIndex = start;
					var sourceIndex = 0;
					var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
					var element;
					while (sourceIndex < sourceLen) {
						if (sourceIndex in source) {
							element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
							if (depth > 0 && isArray(element)) targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
							else {
								if (targetIndex >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
								target[targetIndex] = element;
							}
							targetIndex++;
						}
						sourceIndex++;
					}
					return targetIndex;
				};
				module$1.exports = flattenIntoArray;
			}),
			"a352": (function(module$1, exports$1) {
				module$1.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
			}),
			"a434": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var toAbsoluteIndex = __webpack_require__("23cb");
				var toInteger = __webpack_require__("a691");
				var toLength = __webpack_require__("50c4");
				var toObject = __webpack_require__("7b0b");
				var arraySpeciesCreate = __webpack_require__("65f0");
				var createProperty = __webpack_require__("8418");
				var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
				var USES_TO_LENGTH = arrayMethodUsesToLength("splice", {
					ACCESSORS: true,
					0: 0,
					1: 2
				});
				var max = Math.max;
				var min = Math.min;
				var MAX_SAFE_INTEGER = 9007199254740991;
				var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
				$$1({
					target: "Array",
					proto: true,
					forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
				}, { splice: function splice(start, deleteCount) {
					var O = toObject(this);
					var len = toLength(O.length);
					var actualStart = toAbsoluteIndex(start, len);
					var argumentsLength = arguments.length;
					var insertCount, actualDeleteCount, A$1, k$1, from, to;
					if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
					else if (argumentsLength === 1) {
						insertCount = 0;
						actualDeleteCount = len - actualStart;
					} else {
						insertCount = argumentsLength - 2;
						actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
					}
					if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
					A$1 = arraySpeciesCreate(O, actualDeleteCount);
					for (k$1 = 0; k$1 < actualDeleteCount; k$1++) {
						from = actualStart + k$1;
						if (from in O) createProperty(A$1, k$1, O[from]);
					}
					A$1.length = actualDeleteCount;
					if (insertCount < actualDeleteCount) {
						for (k$1 = actualStart; k$1 < len - actualDeleteCount; k$1++) {
							from = k$1 + actualDeleteCount;
							to = k$1 + insertCount;
							if (from in O) O[to] = O[from];
							else delete O[to];
						}
						for (k$1 = len; k$1 > len - actualDeleteCount + insertCount; k$1--) delete O[k$1 - 1];
					} else if (insertCount > actualDeleteCount) for (k$1 = len - actualDeleteCount; k$1 > actualStart; k$1--) {
						from = k$1 + actualDeleteCount - 1;
						to = k$1 + insertCount - 1;
						if (from in O) O[to] = O[from];
						else delete O[to];
					}
					for (k$1 = 0; k$1 < insertCount; k$1++) O[k$1 + actualStart] = arguments[k$1 + 2];
					O.length = len - actualDeleteCount + insertCount;
					return A$1;
				} });
			}),
			"a4d3": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var global = __webpack_require__("da84");
				var getBuiltIn = __webpack_require__("d066");
				var IS_PURE = __webpack_require__("c430");
				var DESCRIPTORS = __webpack_require__("83ab");
				var NATIVE_SYMBOL = __webpack_require__("4930");
				var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
				var fails = __webpack_require__("d039");
				var has = __webpack_require__("5135");
				var isArray = __webpack_require__("e8b5");
				var isObject$1 = __webpack_require__("861d");
				var anObject = __webpack_require__("825a");
				var toObject = __webpack_require__("7b0b");
				var toIndexedObject = __webpack_require__("fc6a");
				var toPrimitive = __webpack_require__("c04e");
				var createPropertyDescriptor = __webpack_require__("5c6c");
				var nativeObjectCreate = __webpack_require__("7c73");
				var objectKeys = __webpack_require__("df75");
				var getOwnPropertyNamesModule = __webpack_require__("241c");
				var getOwnPropertyNamesExternal = __webpack_require__("057f");
				var getOwnPropertySymbolsModule = __webpack_require__("7418");
				var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
				var definePropertyModule = __webpack_require__("9bf2");
				var propertyIsEnumerableModule = __webpack_require__("d1e7");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var redefine = __webpack_require__("6eeb");
				var shared = __webpack_require__("5692");
				var sharedKey = __webpack_require__("f772");
				var hiddenKeys = __webpack_require__("d012");
				var uid = __webpack_require__("90e3");
				var wellKnownSymbol = __webpack_require__("b622");
				var wrappedWellKnownSymbolModule = __webpack_require__("e538");
				var defineWellKnownSymbol = __webpack_require__("746f");
				var setToStringTag = __webpack_require__("d44e");
				var InternalStateModule = __webpack_require__("69f3");
				var $forEach = __webpack_require__("b727").forEach;
				var HIDDEN = sharedKey("hidden");
				var SYMBOL = "Symbol";
				var PROTOTYPE = "prototype";
				var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
				var setInternalState = InternalStateModule.set;
				var getInternalState = InternalStateModule.getterFor(SYMBOL);
				var ObjectPrototype = Object[PROTOTYPE];
				var $Symbol = global.Symbol;
				var $stringify = getBuiltIn("JSON", "stringify");
				var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
				var nativeDefineProperty = definePropertyModule.f;
				var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
				var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
				var AllSymbols = shared("symbols");
				var ObjectPrototypeSymbols = shared("op-symbols");
				var StringToSymbolRegistry = shared("string-to-symbol-registry");
				var SymbolToStringRegistry = shared("symbol-to-string-registry");
				var WellKnownSymbolsStore = shared("wks");
				var QObject = global.QObject;
				var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
				var setSymbolDescriptor = DESCRIPTORS && fails(function() {
					return nativeObjectCreate(nativeDefineProperty({}, "a", { get: function() {
						return nativeDefineProperty(this, "a", { value: 7 }).a;
					} })).a != 7;
				}) ? function(O, P$2, Attributes) {
					var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P$2);
					if (ObjectPrototypeDescriptor) delete ObjectPrototype[P$2];
					nativeDefineProperty(O, P$2, Attributes);
					if (ObjectPrototypeDescriptor && O !== ObjectPrototype) nativeDefineProperty(ObjectPrototype, P$2, ObjectPrototypeDescriptor);
				} : nativeDefineProperty;
				var wrap$1 = function(tag, description) {
					var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
					setInternalState(symbol, {
						type: SYMBOL,
						tag,
						description
					});
					if (!DESCRIPTORS) symbol.description = description;
					return symbol;
				};
				var isSymbol = USE_SYMBOL_AS_UID ? function(it$2) {
					return typeof it$2 == "symbol";
				} : function(it$2) {
					return Object(it$2) instanceof $Symbol;
				};
				var $defineProperty = function defineProperty(O, P$2, Attributes) {
					if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P$2, Attributes);
					anObject(O);
					var key = toPrimitive(P$2, true);
					anObject(Attributes);
					if (has(AllSymbols, key)) {
						if (!Attributes.enumerable) {
							if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
							O[HIDDEN][key] = true;
						} else {
							if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
							Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
						}
						return setSymbolDescriptor(O, key, Attributes);
					}
					return nativeDefineProperty(O, key, Attributes);
				};
				var $defineProperties = function defineProperties(O, Properties) {
					anObject(O);
					var properties$1 = toIndexedObject(Properties);
					$forEach(objectKeys(properties$1).concat($getOwnPropertySymbols(properties$1)), function(key) {
						if (!DESCRIPTORS || $propertyIsEnumerable.call(properties$1, key)) $defineProperty(O, key, properties$1[key]);
					});
					return O;
				};
				var $create = function create(O, Properties) {
					return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
				};
				var $propertyIsEnumerable = function propertyIsEnumerable(V$1) {
					var P$2 = toPrimitive(V$1, true);
					var enumerable = nativePropertyIsEnumerable.call(this, P$2);
					if (this === ObjectPrototype && has(AllSymbols, P$2) && !has(ObjectPrototypeSymbols, P$2)) return false;
					return enumerable || !has(this, P$2) || !has(AllSymbols, P$2) || has(this, HIDDEN) && this[HIDDEN][P$2] ? enumerable : true;
				};
				var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P$2) {
					var it$2 = toIndexedObject(O);
					var key = toPrimitive(P$2, true);
					if (it$2 === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
					var descriptor = nativeGetOwnPropertyDescriptor(it$2, key);
					if (descriptor && has(AllSymbols, key) && !(has(it$2, HIDDEN) && it$2[HIDDEN][key])) descriptor.enumerable = true;
					return descriptor;
				};
				var $getOwnPropertyNames = function getOwnPropertyNames(O) {
					var names = nativeGetOwnPropertyNames(toIndexedObject(O));
					var result = [];
					$forEach(names, function(key) {
						if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
					});
					return result;
				};
				var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
					var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
					var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
					var result = [];
					$forEach(names, function(key) {
						if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) result.push(AllSymbols[key]);
					});
					return result;
				};
				if (!NATIVE_SYMBOL) {
					$Symbol = function Symbol$1() {
						if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor");
						var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
						var tag = uid(description);
						var setter = function(value$1) {
							if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value$1);
							if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
							setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value$1));
						};
						if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
							configurable: true,
							set: setter
						});
						return wrap$1(tag, description);
					};
					redefine($Symbol[PROTOTYPE], "toString", function toString() {
						return getInternalState(this).tag;
					});
					redefine($Symbol, "withoutSetter", function(description) {
						return wrap$1(uid(description), description);
					});
					propertyIsEnumerableModule.f = $propertyIsEnumerable;
					definePropertyModule.f = $defineProperty;
					getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
					getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
					getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
					wrappedWellKnownSymbolModule.f = function(name) {
						return wrap$1(wellKnownSymbol(name), name);
					};
					if (DESCRIPTORS) {
						nativeDefineProperty($Symbol[PROTOTYPE], "description", {
							configurable: true,
							get: function description() {
								return getInternalState(this).description;
							}
						});
						if (!IS_PURE) redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
					}
				}
				$$1({
					global: true,
					wrap: true,
					forced: !NATIVE_SYMBOL,
					sham: !NATIVE_SYMBOL
				}, { Symbol: $Symbol });
				$forEach(objectKeys(WellKnownSymbolsStore), function(name) {
					defineWellKnownSymbol(name);
				});
				$$1({
					target: SYMBOL,
					stat: true,
					forced: !NATIVE_SYMBOL
				}, {
					"for": function(key) {
						var string = String(key);
						if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
						var symbol = $Symbol(string);
						StringToSymbolRegistry[string] = symbol;
						SymbolToStringRegistry[symbol] = string;
						return symbol;
					},
					keyFor: function keyFor(sym) {
						if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol");
						if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
					},
					useSetter: function() {
						USE_SETTER = true;
					},
					useSimple: function() {
						USE_SETTER = false;
					}
				});
				$$1({
					target: "Object",
					stat: true,
					forced: !NATIVE_SYMBOL,
					sham: !DESCRIPTORS
				}, {
					create: $create,
					defineProperty: $defineProperty,
					defineProperties: $defineProperties,
					getOwnPropertyDescriptor: $getOwnPropertyDescriptor
				});
				$$1({
					target: "Object",
					stat: true,
					forced: !NATIVE_SYMBOL
				}, {
					getOwnPropertyNames: $getOwnPropertyNames,
					getOwnPropertySymbols: $getOwnPropertySymbols
				});
				$$1({
					target: "Object",
					stat: true,
					forced: fails(function() {
						getOwnPropertySymbolsModule.f(1);
					})
				}, { getOwnPropertySymbols: function getOwnPropertySymbols(it$2) {
					return getOwnPropertySymbolsModule.f(toObject(it$2));
				} });
				if ($stringify) $$1({
					target: "JSON",
					stat: true,
					forced: !NATIVE_SYMBOL || fails(function() {
						var symbol = $Symbol();
						return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
					})
				}, { stringify: function stringify$1(it$2, replacer, space$2) {
					var args = [it$2];
					var index$1 = 1;
					var $replacer;
					while (arguments.length > index$1) args.push(arguments[index$1++]);
					$replacer = replacer;
					if (!isObject$1(replacer) && it$2 === void 0 || isSymbol(it$2)) return;
					if (!isArray(replacer)) replacer = function(key, value$1) {
						if (typeof $replacer == "function") value$1 = $replacer.call(this, key, value$1);
						if (!isSymbol(value$1)) return value$1;
					};
					args[1] = replacer;
					return $stringify.apply(null, args);
				} });
				if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
				setToStringTag($Symbol, SYMBOL);
				hiddenKeys[HIDDEN] = true;
			}),
			"a630": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var from = __webpack_require__("4df4");
				$$1({
					target: "Array",
					stat: true,
					forced: !__webpack_require__("1c7e")(function(iterable) {
						Array.from(iterable);
					})
				}, { from });
			}),
			"a640": (function(module$1, exports$1, __webpack_require__) {
				var fails = __webpack_require__("d039");
				module$1.exports = function(METHOD_NAME, argument) {
					var method = [][METHOD_NAME];
					return !!method && fails(function() {
						method.call(null, argument || function() {
							throw 1;
						}, 1);
					});
				};
			}),
			"a691": (function(module$1, exports$1) {
				var ceil = Math.ceil;
				var floor = Math.floor;
				module$1.exports = function(argument) {
					return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
				};
			}),
			"ab13": (function(module$1, exports$1, __webpack_require__) {
				var MATCH = __webpack_require__("b622")("match");
				module$1.exports = function(METHOD_NAME) {
					var regexp = /./;
					try {
						"/./"[METHOD_NAME](regexp);
					} catch (e) {
						try {
							regexp[MATCH] = false;
							return "/./"[METHOD_NAME](regexp);
						} catch (f) {}
					}
					return false;
				};
			}),
			"ac1f": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var exec = __webpack_require__("9263");
				$$1({
					target: "RegExp",
					proto: true,
					forced: /./.exec !== exec
				}, { exec });
			}),
			"ad6d": (function(module$1, exports$1, __webpack_require__) {
				var anObject = __webpack_require__("825a");
				module$1.exports = function() {
					var that = anObject(this);
					var result = "";
					if (that.global) result += "g";
					if (that.ignoreCase) result += "i";
					if (that.multiline) result += "m";
					if (that.dotAll) result += "s";
					if (that.unicode) result += "u";
					if (that.sticky) result += "y";
					return result;
				};
			}),
			"ae40": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var fails = __webpack_require__("d039");
				var has = __webpack_require__("5135");
				var defineProperty = Object.defineProperty;
				var cache$1 = {};
				var thrower = function(it$2) {
					throw it$2;
				};
				module$1.exports = function(METHOD_NAME, options$1) {
					if (has(cache$1, METHOD_NAME)) return cache$1[METHOD_NAME];
					if (!options$1) options$1 = {};
					var method = [][METHOD_NAME];
					var ACCESSORS = has(options$1, "ACCESSORS") ? options$1.ACCESSORS : false;
					var argument0 = has(options$1, 0) ? options$1[0] : thrower;
					var argument1 = has(options$1, 1) ? options$1[1] : void 0;
					return cache$1[METHOD_NAME] = !!method && !fails(function() {
						if (ACCESSORS && !DESCRIPTORS) return true;
						var O = { length: -1 };
						if (ACCESSORS) defineProperty(O, 1, {
							enumerable: true,
							get: thrower
						});
						else O[1] = 1;
						method.call(O, argument0, argument1);
					});
				};
			}),
			"ae93": (function(module$1, exports$1, __webpack_require__) {
				var getPrototypeOf = __webpack_require__("e163");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var has = __webpack_require__("5135");
				var wellKnownSymbol = __webpack_require__("b622");
				var IS_PURE = __webpack_require__("c430");
				var ITERATOR = wellKnownSymbol("iterator");
				var BUGGY_SAFARI_ITERATORS = false;
				var returnThis = function() {
					return this;
				};
				var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
				if ([].keys) {
					arrayIterator = [].keys();
					if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
					else {
						PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
						if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
					}
				}
				if (IteratorPrototype == void 0) IteratorPrototype = {};
				if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
				module$1.exports = {
					IteratorPrototype,
					BUGGY_SAFARI_ITERATORS
				};
			}),
			"b041": (function(module$1, exports$1, __webpack_require__) {
				var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
				var classof = __webpack_require__("f5df");
				module$1.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
					return "[object " + classof(this) + "]";
				};
			}),
			"b0c0": (function(module$1, exports$1, __webpack_require__) {
				var DESCRIPTORS = __webpack_require__("83ab");
				var defineProperty = __webpack_require__("9bf2").f;
				var FunctionPrototype = Function.prototype;
				var FunctionPrototypeToString = FunctionPrototype.toString;
				var nameRE = /^\s*function ([^ (]*)/;
				var NAME = "name";
				if (DESCRIPTORS && !(NAME in FunctionPrototype)) defineProperty(FunctionPrototype, NAME, {
					configurable: true,
					get: function() {
						try {
							return FunctionPrototypeToString.call(this).match(nameRE)[1];
						} catch (error) {
							return "";
						}
					}
				});
			}),
			"b622": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var shared = __webpack_require__("5692");
				var has = __webpack_require__("5135");
				var uid = __webpack_require__("90e3");
				var NATIVE_SYMBOL = __webpack_require__("4930");
				var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
				var WellKnownSymbolsStore = shared("wks");
				var Symbol$1 = global.Symbol;
				var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
				module$1.exports = function(name) {
					if (!has(WellKnownSymbolsStore, name)) if (NATIVE_SYMBOL && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
					else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
					return WellKnownSymbolsStore[name];
				};
			}),
			"b64b": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var toObject = __webpack_require__("7b0b");
				var nativeKeys = __webpack_require__("df75");
				$$1({
					target: "Object",
					stat: true,
					forced: __webpack_require__("d039")(function() {
						nativeKeys(1);
					})
				}, { keys: function keys(it$2) {
					return nativeKeys(toObject(it$2));
				} });
			}),
			"b727": (function(module$1, exports$1, __webpack_require__) {
				var bind = __webpack_require__("0366");
				var IndexedObject = __webpack_require__("44ad");
				var toObject = __webpack_require__("7b0b");
				var toLength = __webpack_require__("50c4");
				var arraySpeciesCreate = __webpack_require__("65f0");
				var push = [].push;
				var createMethod = function(TYPE) {
					var IS_MAP = TYPE == 1;
					var IS_FILTER = TYPE == 2;
					var IS_SOME = TYPE == 3;
					var IS_EVERY = TYPE == 4;
					var IS_FIND_INDEX = TYPE == 6;
					var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
					return function($this, callbackfn, that, specificCreate) {
						var O = toObject($this);
						var self$1 = IndexedObject(O);
						var boundFunction = bind(callbackfn, that, 3);
						var length = toLength(self$1.length);
						var index$1 = 0;
						var create = specificCreate || arraySpeciesCreate;
						var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
						var value$1, result;
						for (; length > index$1; index$1++) if (NO_HOLES || index$1 in self$1) {
							value$1 = self$1[index$1];
							result = boundFunction(value$1, index$1, O);
							if (TYPE) {
								if (IS_MAP) target[index$1] = result;
								else if (result) switch (TYPE) {
									case 3: return true;
									case 5: return value$1;
									case 6: return index$1;
									case 2: push.call(target, value$1);
								}
								else if (IS_EVERY) return false;
							}
						}
						return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
					};
				};
				module$1.exports = {
					forEach: createMethod(0),
					map: createMethod(1),
					filter: createMethod(2),
					some: createMethod(3),
					every: createMethod(4),
					find: createMethod(5),
					findIndex: createMethod(6)
				};
			}),
			"c04e": (function(module$1, exports$1, __webpack_require__) {
				var isObject$1 = __webpack_require__("861d");
				module$1.exports = function(input$5, PREFERRED_STRING) {
					if (!isObject$1(input$5)) return input$5;
					var fn$2, val;
					if (PREFERRED_STRING && typeof (fn$2 = input$5.toString) == "function" && !isObject$1(val = fn$2.call(input$5))) return val;
					if (typeof (fn$2 = input$5.valueOf) == "function" && !isObject$1(val = fn$2.call(input$5))) return val;
					if (!PREFERRED_STRING && typeof (fn$2 = input$5.toString) == "function" && !isObject$1(val = fn$2.call(input$5))) return val;
					throw TypeError("Can't convert object to primitive value");
				};
			}),
			"c430": (function(module$1, exports$1) {
				module$1.exports = false;
			}),
			"c6b6": (function(module$1, exports$1) {
				var toString = {}.toString;
				module$1.exports = function(it$2) {
					return toString.call(it$2).slice(8, -1);
				};
			}),
			"c6cd": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var setGlobal = __webpack_require__("ce4e");
				var SHARED = "__core-js_shared__";
				module$1.exports = global[SHARED] || setGlobal(SHARED, {});
			}),
			"c740": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $findIndex = __webpack_require__("b727").findIndex;
				var addToUnscopables = __webpack_require__("44d2");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var FIND_INDEX = "findIndex";
				var SKIPS_HOLES = true;
				var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
				if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
					SKIPS_HOLES = false;
				});
				$$1({
					target: "Array",
					proto: true,
					forced: SKIPS_HOLES || !USES_TO_LENGTH
				}, { findIndex: function findIndex(callbackfn) {
					return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
				} });
				addToUnscopables(FIND_INDEX);
			}),
			"c8ba": (function(module$1, exports$1) {
				var g = (function() {
					return this;
				})();
				try {
					g = g || new Function("return this")();
				} catch (e) {
					if (typeof window === "object") g = window;
				}
				module$1.exports = g;
			}),
			"c975": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $indexOf = __webpack_require__("4d64").indexOf;
				var arrayMethodIsStrict = __webpack_require__("a640");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var nativeIndexOf = [].indexOf;
				var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
				var STRICT_METHOD = arrayMethodIsStrict("indexOf");
				var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", {
					ACCESSORS: true,
					1: 0
				});
				$$1({
					target: "Array",
					proto: true,
					forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH
				}, { indexOf: function indexOf(searchElement) {
					return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
				} });
			}),
			"ca84": (function(module$1, exports$1, __webpack_require__) {
				var has = __webpack_require__("5135");
				var toIndexedObject = __webpack_require__("fc6a");
				var indexOf = __webpack_require__("4d64").indexOf;
				var hiddenKeys = __webpack_require__("d012");
				module$1.exports = function(object, names) {
					var O = toIndexedObject(object);
					var i = 0;
					var result = [];
					var key;
					for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
					while (names.length > i) if (has(O, key = names[i++])) ~indexOf(result, key) || result.push(key);
					return result;
				};
			}),
			"caad": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $includes = __webpack_require__("4d64").includes;
				var addToUnscopables = __webpack_require__("44d2");
				$$1({
					target: "Array",
					proto: true,
					forced: !__webpack_require__("ae40")("indexOf", {
						ACCESSORS: true,
						1: 0
					})
				}, { includes: function includes(el$1) {
					return $includes(this, el$1, arguments.length > 1 ? arguments[1] : void 0);
				} });
				addToUnscopables("includes");
			}),
			"cc12": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var isObject$1 = __webpack_require__("861d");
				var document$1 = global.document;
				var EXISTS = isObject$1(document$1) && isObject$1(document$1.createElement);
				module$1.exports = function(it$2) {
					return EXISTS ? document$1.createElement(it$2) : {};
				};
			}),
			"ce4e": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var createNonEnumerableProperty = __webpack_require__("9112");
				module$1.exports = function(key, value$1) {
					try {
						createNonEnumerableProperty(global, key, value$1);
					} catch (error) {
						global[key] = value$1;
					}
					return value$1;
				};
			}),
			"d012": (function(module$1, exports$1) {
				module$1.exports = {};
			}),
			"d039": (function(module$1, exports$1) {
				module$1.exports = function(exec) {
					try {
						return !!exec();
					} catch (error) {
						return true;
					}
				};
			}),
			"d066": (function(module$1, exports$1, __webpack_require__) {
				var path = __webpack_require__("428f");
				var global = __webpack_require__("da84");
				var aFunction = function(variable) {
					return typeof variable == "function" ? variable : void 0;
				};
				module$1.exports = function(namespace, method) {
					return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
				};
			}),
			"d1e7": (function(module$1, exports$1, __webpack_require__) {
				var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
				var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
				exports$1.f = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1) ? function propertyIsEnumerable(V$1) {
					var descriptor = getOwnPropertyDescriptor(this, V$1);
					return !!descriptor && descriptor.enumerable;
				} : nativePropertyIsEnumerable;
			}),
			"d28b": (function(module$1, exports$1, __webpack_require__) {
				__webpack_require__("746f")("iterator");
			}),
			"d2bb": (function(module$1, exports$1, __webpack_require__) {
				var anObject = __webpack_require__("825a");
				var aPossiblePrototype = __webpack_require__("3bbe");
				module$1.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
					var CORRECT_SETTER = false;
					var test = {};
					var setter;
					try {
						setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
						setter.call(test, []);
						CORRECT_SETTER = test instanceof Array;
					} catch (error) {}
					return function setPrototypeOf(O, proto) {
						anObject(O);
						aPossiblePrototype(proto);
						if (CORRECT_SETTER) setter.call(O, proto);
						else O.__proto__ = proto;
						return O;
					};
				}() : void 0);
			}),
			"d3b7": (function(module$1, exports$1, __webpack_require__) {
				var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
				var redefine = __webpack_require__("6eeb");
				var toString = __webpack_require__("b041");
				if (!TO_STRING_TAG_SUPPORT) redefine(Object.prototype, "toString", toString, { unsafe: true });
			}),
			"d44e": (function(module$1, exports$1, __webpack_require__) {
				var defineProperty = __webpack_require__("9bf2").f;
				var has = __webpack_require__("5135");
				var TO_STRING_TAG = __webpack_require__("b622")("toStringTag");
				module$1.exports = function(it$2, TAG, STATIC) {
					if (it$2 && !has(it$2 = STATIC ? it$2 : it$2.prototype, TO_STRING_TAG)) defineProperty(it$2, TO_STRING_TAG, {
						configurable: true,
						value: TAG
					});
				};
			}),
			"d58f": (function(module$1, exports$1, __webpack_require__) {
				var aFunction = __webpack_require__("1c0b");
				var toObject = __webpack_require__("7b0b");
				var IndexedObject = __webpack_require__("44ad");
				var toLength = __webpack_require__("50c4");
				var createMethod = function(IS_RIGHT) {
					return function(that, callbackfn, argumentsLength, memo) {
						aFunction(callbackfn);
						var O = toObject(that);
						var self$1 = IndexedObject(O);
						var length = toLength(O.length);
						var index$1 = IS_RIGHT ? length - 1 : 0;
						var i = IS_RIGHT ? -1 : 1;
						if (argumentsLength < 2) while (true) {
							if (index$1 in self$1) {
								memo = self$1[index$1];
								index$1 += i;
								break;
							}
							index$1 += i;
							if (IS_RIGHT ? index$1 < 0 : length <= index$1) throw TypeError("Reduce of empty array with no initial value");
						}
						for (; IS_RIGHT ? index$1 >= 0 : length > index$1; index$1 += i) if (index$1 in self$1) memo = callbackfn(memo, self$1[index$1], index$1, O);
						return memo;
					};
				};
				module$1.exports = {
					left: createMethod(false),
					right: createMethod(true)
				};
			}),
			"d784": (function(module$1, exports$1, __webpack_require__) {
				__webpack_require__("ac1f");
				var redefine = __webpack_require__("6eeb");
				var fails = __webpack_require__("d039");
				var wellKnownSymbol = __webpack_require__("b622");
				var regexpExec = __webpack_require__("9263");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var SPECIES = wellKnownSymbol("species");
				var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
					var re$2 = /./;
					re$2.exec = function() {
						var result = [];
						result.groups = { a: "7" };
						return result;
					};
					return "".replace(re$2, "$<a>") !== "7";
				});
				var REPLACE_KEEPS_$0 = (function() {
					return "a".replace(/./, "$0") === "$0";
				})();
				var REPLACE = wellKnownSymbol("replace");
				var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
					if (/./[REPLACE]) return /./[REPLACE]("a", "$0") === "";
					return false;
				})();
				var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
					var re$2 = /(?:)/;
					var originalExec = re$2.exec;
					re$2.exec = function() {
						return originalExec.apply(this, arguments);
					};
					var result = "ab".split(re$2);
					return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
				});
				module$1.exports = function(KEY, length, exec, sham) {
					var SYMBOL = wellKnownSymbol(KEY);
					var DELEGATES_TO_SYMBOL = !fails(function() {
						var O = {};
						O[SYMBOL] = function() {
							return 7;
						};
						return ""[KEY](O) != 7;
					});
					var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
						var execCalled = false;
						var re$2 = /a/;
						if (KEY === "split") {
							re$2 = {};
							re$2.constructor = {};
							re$2.constructor[SPECIES] = function() {
								return re$2;
							};
							re$2.flags = "";
							re$2[SYMBOL] = /./[SYMBOL];
						}
						re$2.exec = function() {
							execCalled = true;
							return null;
						};
						re$2[SYMBOL]("");
						return !execCalled;
					});
					if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
						var nativeRegExpMethod = /./[SYMBOL];
						var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
							if (regexp.exec === regexpExec) {
								if (DELEGATES_TO_SYMBOL && !forceStringMethod) return {
									done: true,
									value: nativeRegExpMethod.call(regexp, str, arg2)
								};
								return {
									done: true,
									value: nativeMethod.call(str, regexp, arg2)
								};
							}
							return { done: false };
						}, {
							REPLACE_KEEPS_$0,
							REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
						});
						var stringMethod = methods[0];
						var regexMethod = methods[1];
						redefine(String.prototype, KEY, stringMethod);
						redefine(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
							return regexMethod.call(string, this, arg);
						} : function(string) {
							return regexMethod.call(string, this);
						});
					}
					if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
				};
			}),
			"d81d": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var $map = __webpack_require__("b727").map;
				var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
				var USES_TO_LENGTH = arrayMethodUsesToLength("map");
				$$1({
					target: "Array",
					proto: true,
					forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
				}, { map: function map(callbackfn) {
					return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
				} });
			}),
			"da84": (function(module$1, exports$1, __webpack_require__) {
				(function(global) {
					var check = function(it$2) {
						return it$2 && it$2.Math == Math && it$2;
					};
					module$1.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || Function("return this")();
				}).call(this, __webpack_require__("c8ba"));
			}),
			"dbb4": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var DESCRIPTORS = __webpack_require__("83ab");
				var ownKeys$1 = __webpack_require__("56ef");
				var toIndexedObject = __webpack_require__("fc6a");
				var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
				var createProperty = __webpack_require__("8418");
				$$1({
					target: "Object",
					stat: true,
					sham: !DESCRIPTORS
				}, { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
					var O = toIndexedObject(object);
					var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
					var keys = ownKeys$1(O);
					var result = {};
					var index$1 = 0;
					var key, descriptor;
					while (keys.length > index$1) {
						descriptor = getOwnPropertyDescriptor(O, key = keys[index$1++]);
						if (descriptor !== void 0) createProperty(result, key, descriptor);
					}
					return result;
				} });
			}),
			"dbf1": (function(module$1, __webpack_exports__, __webpack_require__) {
				(function(global) {
					__webpack_require__.d(__webpack_exports__, "a", function() {
						return console$1;
					});
					function getConsole() {
						if (typeof window !== "undefined") return window.console;
						return global.console;
					}
					var console$1 = getConsole();
				}).call(this, __webpack_require__("c8ba"));
			}),
			"ddb0": (function(module$1, exports$1, __webpack_require__) {
				var global = __webpack_require__("da84");
				var DOMIterables = __webpack_require__("fdbc");
				var ArrayIteratorMethods = __webpack_require__("e260");
				var createNonEnumerableProperty = __webpack_require__("9112");
				var wellKnownSymbol = __webpack_require__("b622");
				var ITERATOR = wellKnownSymbol("iterator");
				var TO_STRING_TAG = wellKnownSymbol("toStringTag");
				var ArrayValues = ArrayIteratorMethods.values;
				for (var COLLECTION_NAME in DOMIterables) {
					var Collection = global[COLLECTION_NAME];
					var CollectionPrototype = Collection && Collection.prototype;
					if (CollectionPrototype) {
						if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
							createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
						} catch (error) {
							CollectionPrototype[ITERATOR] = ArrayValues;
						}
						if (!CollectionPrototype[TO_STRING_TAG]) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
						if (DOMIterables[COLLECTION_NAME]) {
							for (var METHOD_NAME in ArrayIteratorMethods) if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
								createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
							} catch (error) {
								CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
							}
						}
					}
				}
			}),
			"df75": (function(module$1, exports$1, __webpack_require__) {
				var internalObjectKeys = __webpack_require__("ca84");
				var enumBugKeys = __webpack_require__("7839");
				module$1.exports = Object.keys || function keys(O) {
					return internalObjectKeys(O, enumBugKeys);
				};
			}),
			"e01a": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var DESCRIPTORS = __webpack_require__("83ab");
				var global = __webpack_require__("da84");
				var has = __webpack_require__("5135");
				var isObject$1 = __webpack_require__("861d");
				var defineProperty = __webpack_require__("9bf2").f;
				var copyConstructorProperties = __webpack_require__("e893");
				var NativeSymbol = global.Symbol;
				if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || NativeSymbol().description !== void 0)) {
					var EmptyStringDescriptionStore = {};
					var SymbolWrapper = function Symbol$1() {
						var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
						var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
						if (description === "") EmptyStringDescriptionStore[result] = true;
						return result;
					};
					copyConstructorProperties(SymbolWrapper, NativeSymbol);
					var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
					symbolPrototype.constructor = SymbolWrapper;
					var symbolToString = symbolPrototype.toString;
					var native = String(NativeSymbol("test")) == "Symbol(test)";
					var regexp = /^Symbol\((.*)\)[^)]+$/;
					defineProperty(symbolPrototype, "description", {
						configurable: true,
						get: function description() {
							var symbol = isObject$1(this) ? this.valueOf() : this;
							var string = symbolToString.call(symbol);
							if (has(EmptyStringDescriptionStore, symbol)) return "";
							var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
							return desc === "" ? void 0 : desc;
						}
					});
					$$1({
						global: true,
						forced: true
					}, { Symbol: SymbolWrapper });
				}
			}),
			"e163": (function(module$1, exports$1, __webpack_require__) {
				var has = __webpack_require__("5135");
				var toObject = __webpack_require__("7b0b");
				var sharedKey = __webpack_require__("f772");
				var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
				var IE_PROTO = sharedKey("IE_PROTO");
				var ObjectPrototype = Object.prototype;
				module$1.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
					O = toObject(O);
					if (has(O, IE_PROTO)) return O[IE_PROTO];
					if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
					return O instanceof Object ? ObjectPrototype : null;
				};
			}),
			"e177": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = !__webpack_require__("d039")(function() {
					function F() {}
					F.prototype.constructor = null;
					return Object.getPrototypeOf(new F()) !== F.prototype;
				});
			}),
			"e260": (function(module$1, exports$1, __webpack_require__) {
				var toIndexedObject = __webpack_require__("fc6a");
				var addToUnscopables = __webpack_require__("44d2");
				var Iterators = __webpack_require__("3f8c");
				var InternalStateModule = __webpack_require__("69f3");
				var defineIterator = __webpack_require__("7dd0");
				var ARRAY_ITERATOR = "Array Iterator";
				var setInternalState = InternalStateModule.set;
				var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
				module$1.exports = defineIterator(Array, "Array", function(iterated, kind) {
					setInternalState(this, {
						type: ARRAY_ITERATOR,
						target: toIndexedObject(iterated),
						index: 0,
						kind
					});
				}, function() {
					var state = getInternalState(this);
					var target = state.target;
					var kind = state.kind;
					var index$1 = state.index++;
					if (!target || index$1 >= target.length) {
						state.target = void 0;
						return {
							value: void 0,
							done: true
						};
					}
					if (kind == "keys") return {
						value: index$1,
						done: false
					};
					if (kind == "values") return {
						value: target[index$1],
						done: false
					};
					return {
						value: [index$1, target[index$1]],
						done: false
					};
				}, "values");
				Iterators.Arguments = Iterators.Array;
				addToUnscopables("keys");
				addToUnscopables("values");
				addToUnscopables("entries");
			}),
			"e439": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var fails = __webpack_require__("d039");
				var toIndexedObject = __webpack_require__("fc6a");
				var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
				var DESCRIPTORS = __webpack_require__("83ab");
				var FAILS_ON_PRIMITIVES = fails(function() {
					nativeGetOwnPropertyDescriptor(1);
				});
				$$1({
					target: "Object",
					stat: true,
					forced: !DESCRIPTORS || FAILS_ON_PRIMITIVES,
					sham: !DESCRIPTORS
				}, { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it$2, key) {
					return nativeGetOwnPropertyDescriptor(toIndexedObject(it$2), key);
				} });
			}),
			"e538": (function(module$1, exports$1, __webpack_require__) {
				exports$1.f = __webpack_require__("b622");
			}),
			"e893": (function(module$1, exports$1, __webpack_require__) {
				var has = __webpack_require__("5135");
				var ownKeys$1 = __webpack_require__("56ef");
				var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
				var definePropertyModule = __webpack_require__("9bf2");
				module$1.exports = function(target, source) {
					var keys = ownKeys$1(source);
					var defineProperty = definePropertyModule.f;
					var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
					for (var i = 0; i < keys.length; i++) {
						var key = keys[i];
						if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
					}
				};
			}),
			"e8b5": (function(module$1, exports$1, __webpack_require__) {
				var classof = __webpack_require__("c6b6");
				module$1.exports = Array.isArray || function isArray(arg) {
					return classof(arg) == "Array";
				};
			}),
			"e95a": (function(module$1, exports$1, __webpack_require__) {
				var wellKnownSymbol = __webpack_require__("b622");
				var Iterators = __webpack_require__("3f8c");
				var ITERATOR = wellKnownSymbol("iterator");
				var ArrayPrototype = Array.prototype;
				module$1.exports = function(it$2) {
					return it$2 !== void 0 && (Iterators.Array === it$2 || ArrayPrototype[ITERATOR] === it$2);
				};
			}),
			"f5df": (function(module$1, exports$1, __webpack_require__) {
				var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
				var classofRaw = __webpack_require__("c6b6");
				var TO_STRING_TAG = __webpack_require__("b622")("toStringTag");
				var CORRECT_ARGUMENTS = classofRaw(function() {
					return arguments;
				}()) == "Arguments";
				var tryGet = function(it$2, key) {
					try {
						return it$2[key];
					} catch (error) {}
				};
				module$1.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it$2) {
					var O, tag, result;
					return it$2 === void 0 ? "Undefined" : it$2 === null ? "Null" : typeof (tag = tryGet(O = Object(it$2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
				};
			}),
			"f772": (function(module$1, exports$1, __webpack_require__) {
				var shared = __webpack_require__("5692");
				var uid = __webpack_require__("90e3");
				var keys = shared("keys");
				module$1.exports = function(key) {
					return keys[key] || (keys[key] = uid(key));
				};
			}),
			"fb15": (function(module$1, __webpack_exports__, __webpack_require__) {
				__webpack_require__.r(__webpack_exports__);
				if (typeof window !== "undefined") {
					var currentScript = window.document.currentScript;
					var getCurrentScript = __webpack_require__("8875");
					currentScript = getCurrentScript();
					if (!("currentScript" in document)) Object.defineProperty(document, "currentScript", { get: getCurrentScript });
					var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
					if (src) __webpack_require__.p = src[1];
				}
				__webpack_require__("99af");
				__webpack_require__("4de4");
				__webpack_require__("4160");
				__webpack_require__("c975");
				__webpack_require__("d81d");
				__webpack_require__("a434");
				__webpack_require__("159b");
				__webpack_require__("a4d3");
				__webpack_require__("e439");
				__webpack_require__("dbb4");
				__webpack_require__("b64b");
				function _defineProperty$1(obj, key, value$1) {
					if (key in obj) Object.defineProperty(obj, key, {
						value: value$1,
						enumerable: true,
						configurable: true,
						writable: true
					});
					else obj[key] = value$1;
					return obj;
				}
				function ownKeys$1(object, enumerableOnly) {
					var keys = Object.keys(object);
					if (Object.getOwnPropertySymbols) {
						var symbols = Object.getOwnPropertySymbols(object);
						if (enumerableOnly) symbols = symbols.filter(function(sym) {
							return Object.getOwnPropertyDescriptor(object, sym).enumerable;
						});
						keys.push.apply(keys, symbols);
					}
					return keys;
				}
				function _objectSpread2$1(target) {
					for (var i = 1; i < arguments.length; i++) {
						var source = arguments[i] != null ? arguments[i] : {};
						if (i % 2) ownKeys$1(Object(source), true).forEach(function(key) {
							_defineProperty$1(target, key, source[key]);
						});
						else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
						else ownKeys$1(Object(source)).forEach(function(key) {
							Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
						});
					}
					return target;
				}
				function _arrayWithHoles(arr) {
					if (Array.isArray(arr)) return arr;
				}
				__webpack_require__("e01a");
				__webpack_require__("d28b");
				__webpack_require__("e260");
				__webpack_require__("d3b7");
				__webpack_require__("3ca3");
				__webpack_require__("ddb0");
				function _iterableToArrayLimit(arr, i) {
					if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
					var _arr = [];
					var _n$2 = true;
					var _d = false;
					var _e$2 = void 0;
					try {
						for (var _i$1 = arr[Symbol.iterator](), _s$2; !(_n$2 = (_s$2 = _i$1.next()).done); _n$2 = true) {
							_arr.push(_s$2.value);
							if (i && _arr.length === i) break;
						}
					} catch (err) {
						_d = true;
						_e$2 = err;
					} finally {
						try {
							if (!_n$2 && _i$1["return"] != null) _i$1["return"]();
						} finally {
							if (_d) throw _e$2;
						}
					}
					return _arr;
				}
				__webpack_require__("a630");
				__webpack_require__("fb6a");
				__webpack_require__("b0c0");
				__webpack_require__("25f0");
				function _arrayLikeToArray$1(arr, len) {
					if (len == null || len > arr.length) len = arr.length;
					for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
					return arr2;
				}
				function _unsupportedIterableToArray$1(o, minLen) {
					if (!o) return;
					if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
					var n = Object.prototype.toString.call(o).slice(8, -1);
					if (n === "Object" && o.constructor) n = o.constructor.name;
					if (n === "Map" || n === "Set") return Array.from(o);
					if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
				}
				function _nonIterableRest() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				function _slicedToArray(arr, i) {
					return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
				}
				function _arrayWithoutHoles$1(arr) {
					if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
				}
				function _iterableToArray$1(iter) {
					if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
				}
				function _nonIterableSpread$1() {
					throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				function _toConsumableArray$1(arr) {
					return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
				}
				var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
				var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
				function removeNode(node$1) {
					if (node$1.parentElement !== null) node$1.parentElement.removeChild(node$1);
				}
				function insertNodeAt(fatherNode, node$1, position) {
					var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
					fatherNode.insertBefore(node$1, refNode);
				}
				var console$1 = __webpack_require__("dbf1");
				__webpack_require__("13d5");
				__webpack_require__("4fad");
				__webpack_require__("ac1f");
				__webpack_require__("5319");
				function cached(fn$2) {
					var cache$1 = Object.create(null);
					return function cachedFn(str) {
						return cache$1[str] || (cache$1[str] = fn$2(str));
					};
				}
				var regex = /-(\w)/g;
				var camelize = cached(function(str) {
					return str.replace(regex, function(_$2, c) {
						return c.toUpperCase();
					});
				});
				__webpack_require__("5db7");
				__webpack_require__("73d9");
				var manageAndEmit = [
					"Start",
					"Add",
					"Remove",
					"Update",
					"End"
				];
				var emit = [
					"Choose",
					"Unchoose",
					"Sort",
					"Filter",
					"Clone"
				];
				var manage = ["Move"];
				var eventHandlerNames = [
					manage,
					manageAndEmit,
					emit
				].flatMap(function(events$1) {
					return events$1;
				}).map(function(evt) {
					return "on".concat(evt);
				});
				var events = {
					manage,
					manageAndEmit,
					emit
				};
				function isReadOnly(eventName) {
					return eventHandlerNames.indexOf(eventName) !== -1;
				}
				__webpack_require__("caad");
				__webpack_require__("2ca0");
				var tags$2 = [
					"a",
					"abbr",
					"address",
					"area",
					"article",
					"aside",
					"audio",
					"b",
					"base",
					"bdi",
					"bdo",
					"blockquote",
					"body",
					"br",
					"button",
					"canvas",
					"caption",
					"cite",
					"code",
					"col",
					"colgroup",
					"data",
					"datalist",
					"dd",
					"del",
					"details",
					"dfn",
					"dialog",
					"div",
					"dl",
					"dt",
					"em",
					"embed",
					"fieldset",
					"figcaption",
					"figure",
					"footer",
					"form",
					"h1",
					"h2",
					"h3",
					"h4",
					"h5",
					"h6",
					"head",
					"header",
					"hgroup",
					"hr",
					"html",
					"i",
					"iframe",
					"img",
					"input",
					"ins",
					"kbd",
					"label",
					"legend",
					"li",
					"link",
					"main",
					"map",
					"mark",
					"math",
					"menu",
					"menuitem",
					"meta",
					"meter",
					"nav",
					"noscript",
					"object",
					"ol",
					"optgroup",
					"option",
					"output",
					"p",
					"param",
					"picture",
					"pre",
					"progress",
					"q",
					"rb",
					"rp",
					"rt",
					"rtc",
					"ruby",
					"s",
					"samp",
					"script",
					"section",
					"select",
					"slot",
					"small",
					"source",
					"span",
					"strong",
					"style",
					"sub",
					"summary",
					"sup",
					"svg",
					"table",
					"tbody",
					"td",
					"template",
					"textarea",
					"tfoot",
					"th",
					"thead",
					"time",
					"title",
					"tr",
					"track",
					"u",
					"ul",
					"var",
					"video",
					"wbr"
				];
				function isHtmlTag(name) {
					return tags$2.includes(name);
				}
				function isTransition(name) {
					return ["transition-group", "TransitionGroup"].includes(name);
				}
				function isHtmlAttribute(value$1) {
					return [
						"id",
						"class",
						"role",
						"style"
					].includes(value$1) || value$1.startsWith("data-") || value$1.startsWith("aria-") || value$1.startsWith("on");
				}
				function project(entries) {
					return entries.reduce(function(res, _ref) {
						var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0];
						res[key] = _ref2[1];
						return res;
					}, {});
				}
				function getComponentAttributes(_ref3) {
					var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
					return _objectSpread2$1(_objectSpread2$1({}, project(Object.entries($attrs).filter(function(_ref4) {
						var _ref5 = _slicedToArray(_ref4, 2), key = _ref5[0];
						_ref5[1];
						return isHtmlAttribute(key);
					}))), componentData);
				}
				function createSortableOption(_ref6) {
					var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
					var options$1 = project(getValidSortableEntries($attrs));
					Object.entries(callBackBuilder).forEach(function(_ref7) {
						var _ref8 = _slicedToArray(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
						events[eventType].forEach(function(event) {
							options$1["on".concat(event)] = eventBuilder(event);
						});
					});
					var draggable = "[data-draggable]".concat(options$1.draggable || "");
					return _objectSpread2$1(_objectSpread2$1({}, options$1), {}, { draggable });
				}
				function getValidSortableEntries(value$1) {
					return Object.entries(value$1).filter(function(_ref9) {
						var _ref10 = _slicedToArray(_ref9, 2), key = _ref10[0];
						_ref10[1];
						return !isHtmlAttribute(key);
					}).map(function(_ref11) {
						var _ref12 = _slicedToArray(_ref11, 2), key = _ref12[0], value$2 = _ref12[1];
						return [camelize(key), value$2];
					}).filter(function(_ref13) {
						var _ref14 = _slicedToArray(_ref13, 2), key = _ref14[0];
						_ref14[1];
						return !isReadOnly(key);
					});
				}
				__webpack_require__("c740");
				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
				}
				function _defineProperties(target, props$1) {
					for (var i = 0; i < props$1.length; i++) {
						var descriptor = props$1[i];
						descriptor.enumerable = descriptor.enumerable || false;
						descriptor.configurable = true;
						if ("value" in descriptor) descriptor.writable = true;
						Object.defineProperty(target, descriptor.key, descriptor);
					}
				}
				function _createClass(Constructor, protoProps, staticProps) {
					if (protoProps) _defineProperties(Constructor.prototype, protoProps);
					if (staticProps) _defineProperties(Constructor, staticProps);
					return Constructor;
				}
				var getHtmlElementFromNode = function getHtmlElementFromNode$1(_ref) {
					return _ref.el;
				};
				var addContext = function addContext$1(domElement, context) {
					return domElement.__draggable_context = context;
				};
				var getContext = function getContext$1(domElement) {
					return domElement.__draggable_context;
				};
				var componentStructure_ComponentStructure = /* @__PURE__ */ function() {
					function ComponentStructure(_ref2) {
						var _ref2$nodes = _ref2.nodes, header$2 = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer$1 = _ref2$nodes.footer, root = _ref2.root, realList = _ref2.realList;
						_classCallCheck(this, ComponentStructure);
						this.defaultNodes = defaultNodes;
						this.children = [].concat(_toConsumableArray$1(header$2), _toConsumableArray$1(defaultNodes), _toConsumableArray$1(footer$1));
						this.externalComponent = root.externalComponent;
						this.rootTransition = root.transition;
						this.tag = root.tag;
						this.realList = realList;
					}
					_createClass(ComponentStructure, [
						{
							key: "render",
							value: function render(h$1, attributes) {
								var tag = this.tag, children = this.children;
								return h$1(tag, attributes, !this._isRootComponent ? children : { default: function _default() {
									return children;
								} });
							}
						},
						{
							key: "updated",
							value: function updated() {
								var defaultNodes = this.defaultNodes, realList = this.realList;
								defaultNodes.forEach(function(node$1, index$1) {
									addContext(getHtmlElementFromNode(node$1), {
										element: realList[index$1],
										index: index$1
									});
								});
							}
						},
						{
							key: "getUnderlyingVm",
							value: function getUnderlyingVm(domElement) {
								return getContext(domElement);
							}
						},
						{
							key: "getVmIndexFromDomIndex",
							value: function getVmIndexFromDomIndex(domIndex, element) {
								var defaultNodes = this.defaultNodes;
								var length = defaultNodes.length;
								var domChildren = element.children;
								var domElement = domChildren.item(domIndex);
								if (domElement === null) return length;
								var context = getContext(domElement);
								if (context) return context.index;
								if (length === 0) return 0;
								var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
								return domIndex < _toConsumableArray$1(domChildren).findIndex(function(element$1) {
									return element$1 === firstDomListElement;
								}) ? 0 : length;
							}
						},
						{
							key: "_isRootComponent",
							get: function get$6() {
								return this.externalComponent || this.rootTransition;
							}
						}
					]);
					return ComponentStructure;
				}();
				var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
				function getSlot(slots, key) {
					var slotValue = slots[key];
					return slotValue ? slotValue() : [];
				}
				function computeNodes(_ref) {
					var $slots = _ref.$slots, realList = _ref.realList, getKey = _ref.getKey;
					var normalizedList = realList || [];
					var _map2 = _slicedToArray(["header", "footer"].map(function(name) {
						return getSlot($slots, name);
					}), 2), header$2 = _map2[0], footer$1 = _map2[1];
					var item$2 = $slots.item;
					if (!item$2) throw new Error("draggable element must have an item slot");
					var defaultNodes = normalizedList.flatMap(function(element, index$1) {
						return item$2({
							element,
							index: index$1
						}).map(function(node$1) {
							node$1.key = getKey(element);
							node$1.props = _objectSpread2$1(_objectSpread2$1({}, node$1.props || {}), {}, { "data-draggable": true });
							return node$1;
						});
					});
					if (defaultNodes.length !== normalizedList.length) throw new Error("Item slot must have only one child");
					return {
						header: header$2,
						footer: footer$1,
						default: defaultNodes
					};
				}
				function getRootInformation(tag) {
					var transition = isTransition(tag);
					var externalComponent = !isHtmlTag(tag) && !transition;
					return {
						transition,
						externalComponent,
						tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
					};
				}
				function computeComponentStructure(_ref2) {
					var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey = _ref2.getKey;
					return new componentStructure_ComponentStructure({
						nodes: computeNodes({
							$slots,
							realList,
							getKey
						}),
						root: getRootInformation(tag),
						realList
					});
				}
				function _emit(evtName, evtData) {
					var _this = this;
					Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
						return _this.$emit(evtName.toLowerCase(), evtData);
					});
				}
				function _manage(evtName) {
					var _this2 = this;
					return function(evtData, originalElement) {
						if (_this2.realList !== null) return _this2["onDrag".concat(evtName)](evtData, originalElement);
					};
				}
				function _manageAndEmit(evtName) {
					var _this3 = this;
					var delegateCallBack = _manage.call(this, evtName);
					return function(evtData, originalElement) {
						delegateCallBack.call(_this3, evtData, originalElement);
						_emit.call(_this3, evtName, evtData);
					};
				}
				var draggingElement = null;
				var props = {
					list: {
						type: Array,
						required: false,
						default: null
					},
					modelValue: {
						type: Array,
						required: false,
						default: null
					},
					itemKey: {
						type: [String, Function],
						required: true
					},
					clone: {
						type: Function,
						default: function _default(original) {
							return original;
						}
					},
					tag: {
						type: String,
						default: "div"
					},
					move: {
						type: Function,
						default: null
					},
					componentData: {
						type: Object,
						required: false,
						default: null
					}
				};
				var emits = ["update:modelValue", "change"].concat(_toConsumableArray$1([].concat(_toConsumableArray$1(events.manageAndEmit), _toConsumableArray$1(events.emit)).map(function(evt) {
					return evt.toLowerCase();
				})));
				__webpack_exports__["default"] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
					name: "draggable",
					inheritAttrs: false,
					props,
					emits,
					data: function data() {
						return { error: false };
					},
					render: function render() {
						try {
							this.error = false;
							var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey = this.getKey;
							var componentStructure = computeComponentStructure({
								$slots,
								tag,
								realList,
								getKey
							});
							this.componentStructure = componentStructure;
							var attributes = getComponentAttributes({
								$attrs,
								componentData
							});
							return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
						} catch (err) {
							this.error = true;
							return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", { style: { color: "red" } }, err.stack);
						}
					},
					created: function created() {
						if (this.list !== null && this.modelValue !== null) console$1["a"].error("modelValue and list props are mutually exclusive! Please set one or another.");
					},
					mounted: function mounted() {
						var _this4 = this;
						if (this.error) return;
						var $attrs = this.$attrs, $el = this.$el;
						this.componentStructure.updated();
						var sortableOptions = createSortableOption({
							$attrs,
							callBackBuilder: {
								manageAndEmit: function manageAndEmit$1(event) {
									return _manageAndEmit.call(_this4, event);
								},
								emit: function emit$1(event) {
									return _emit.bind(_this4, event);
								},
								manage: function manage$1(event) {
									return _manage.call(_this4, event);
								}
							}
						});
						var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
						this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
						this.targetDomElement = targetDomElement;
						targetDomElement.__draggable_component__ = this;
					},
					updated: function updated() {
						this.componentStructure.updated();
					},
					beforeUnmount: function beforeUnmount() {
						if (this._sortable !== void 0) this._sortable.destroy();
					},
					computed: {
						realList: function realList() {
							var list = this.list;
							return list ? list : this.modelValue;
						},
						getKey: function getKey() {
							var itemKey = this.itemKey;
							if (typeof itemKey === "function") return itemKey;
							return function(element) {
								return element[itemKey];
							};
						}
					},
					watch: { $attrs: {
						handler: function handler(newOptionValue) {
							var _sortable = this._sortable;
							if (!_sortable) return;
							getValidSortableEntries(newOptionValue).forEach(function(_ref) {
								var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value$1 = _ref2[1];
								_sortable.option(key, value$1);
							});
						},
						deep: true
					} },
					methods: {
						getUnderlyingVm: function getUnderlyingVm(domElement) {
							return this.componentStructure.getUnderlyingVm(domElement) || null;
						},
						getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
							return htmElement.__draggable_component__;
						},
						emitChanges: function emitChanges(evt) {
							var _this5 = this;
							Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
								return _this5.$emit("change", evt);
							});
						},
						alterList: function alterList(onList) {
							if (this.list) {
								onList(this.list);
								return;
							}
							var newList = _toConsumableArray$1(this.modelValue);
							onList(newList);
							this.$emit("update:modelValue", newList);
						},
						spliceList: function spliceList() {
							var _arguments = arguments;
							this.alterList(function spliceList$1(list) {
								return list.splice.apply(list, _toConsumableArray$1(_arguments));
							});
						},
						updatePosition: function updatePosition(oldIndex$1, newIndex$1) {
							this.alterList(function updatePosition$1(list) {
								return list.splice(newIndex$1, 0, list.splice(oldIndex$1, 1)[0]);
							});
						},
						getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
							var to = _ref3.to, related = _ref3.related;
							var component = this.getUnderlyingPotencialDraggableComponent(to);
							if (!component) return { component };
							var list = component.realList;
							var context = {
								list,
								component
							};
							if (to !== related && list) return _objectSpread2$1(_objectSpread2$1({}, component.getUnderlyingVm(related) || {}), context);
							return context;
						},
						getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex) {
							return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
						},
						onDragStart: function onDragStart(evt) {
							this.context = this.getUnderlyingVm(evt.item);
							evt.item._underlying_vm_ = this.clone(this.context.element);
							draggingElement = evt.item;
						},
						onDragAdd: function onDragAdd(evt) {
							var element = evt.item._underlying_vm_;
							if (element === void 0) return;
							removeNode(evt.item);
							var newIndex$1 = this.getVmIndexFromDomIndex(evt.newIndex);
							this.spliceList(newIndex$1, 0, element);
							var added = {
								element,
								newIndex: newIndex$1
							};
							this.emitChanges({ added });
						},
						onDragRemove: function onDragRemove(evt) {
							insertNodeAt(this.$el, evt.item, evt.oldIndex);
							if (evt.pullMode === "clone") {
								removeNode(evt.clone);
								return;
							}
							var _this$context = this.context, oldIndex$1 = _this$context.index, element = _this$context.element;
							this.spliceList(oldIndex$1, 1);
							var removed = {
								element,
								oldIndex: oldIndex$1
							};
							this.emitChanges({ removed });
						},
						onDragUpdate: function onDragUpdate(evt) {
							removeNode(evt.item);
							insertNodeAt(evt.from, evt.item, evt.oldIndex);
							var oldIndex$1 = this.context.index;
							var newIndex$1 = this.getVmIndexFromDomIndex(evt.newIndex);
							this.updatePosition(oldIndex$1, newIndex$1);
							var moved$1 = {
								element: this.context.element,
								oldIndex: oldIndex$1,
								newIndex: newIndex$1
							};
							this.emitChanges({ moved: moved$1 });
						},
						computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
							if (!relatedContext.element) return 0;
							var domChildren = _toConsumableArray$1(evt.to.children).filter(function(el$1) {
								return el$1.style["display"] !== "none";
							});
							var currentDomIndex = domChildren.indexOf(evt.related);
							var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
							return domChildren.indexOf(draggingElement) !== -1 || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
						},
						onDragMove: function onDragMove(evt, originalEvent) {
							var move = this.move, realList = this.realList;
							if (!move || !realList) return true;
							var relatedContext = this.getRelatedContextFromMoveEvent(evt);
							var futureIndex = this.computeFutureIndex(relatedContext, evt);
							var draggedContext = _objectSpread2$1(_objectSpread2$1({}, this.context), {}, { futureIndex });
							return move(_objectSpread2$1(_objectSpread2$1({}, evt), {}, {
								relatedContext,
								draggedContext
							}), originalEvent);
						},
						onDragEnd: function onDragEnd() {
							draggingElement = null;
						}
					}
				});
			}),
			"fb6a": (function(module$1, exports$1, __webpack_require__) {
				var $$1 = __webpack_require__("23e7");
				var isObject$1 = __webpack_require__("861d");
				var isArray = __webpack_require__("e8b5");
				var toAbsoluteIndex = __webpack_require__("23cb");
				var toLength = __webpack_require__("50c4");
				var toIndexedObject = __webpack_require__("fc6a");
				var createProperty = __webpack_require__("8418");
				var wellKnownSymbol = __webpack_require__("b622");
				var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
				var arrayMethodUsesToLength = __webpack_require__("ae40");
				var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
				var USES_TO_LENGTH = arrayMethodUsesToLength("slice", {
					ACCESSORS: true,
					0: 0,
					1: 2
				});
				var SPECIES = wellKnownSymbol("species");
				var nativeSlice = [].slice;
				var max = Math.max;
				$$1({
					target: "Array",
					proto: true,
					forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
				}, { slice: function slice(start, end) {
					var O = toIndexedObject(this);
					var length = toLength(O.length);
					var k$1 = toAbsoluteIndex(start, length);
					var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
					var Constructor, result, n;
					if (isArray(O)) {
						Constructor = O.constructor;
						if (typeof Constructor == "function" && (Constructor === Array || isArray(Constructor.prototype))) Constructor = void 0;
						else if (isObject$1(Constructor)) {
							Constructor = Constructor[SPECIES];
							if (Constructor === null) Constructor = void 0;
						}
						if (Constructor === Array || Constructor === void 0) return nativeSlice.call(O, k$1, fin);
					}
					result = new (Constructor === void 0 ? Array : Constructor)(max(fin - k$1, 0));
					for (n = 0; k$1 < fin; k$1++, n++) if (k$1 in O) createProperty(result, n, O[k$1]);
					result.length = n;
					return result;
				} });
			}),
			"fc6a": (function(module$1, exports$1, __webpack_require__) {
				var IndexedObject = __webpack_require__("44ad");
				var requireObjectCoercible = __webpack_require__("1d80");
				module$1.exports = function(it$2) {
					return IndexedObject(requireObjectCoercible(it$2));
				};
			}),
			"fdbc": (function(module$1, exports$1) {
				module$1.exports = {
					CSSRuleList: 0,
					CSSStyleDeclaration: 0,
					CSSValueList: 0,
					ClientRectList: 0,
					DOMRectList: 0,
					DOMStringList: 0,
					DOMTokenList: 1,
					DataTransferItemList: 0,
					FileList: 0,
					HTMLAllCollection: 0,
					HTMLCollection: 0,
					HTMLFormElement: 0,
					HTMLSelectElement: 0,
					MediaList: 0,
					MimeTypeArray: 0,
					NamedNodeMap: 0,
					NodeList: 1,
					PaintRequestList: 0,
					Plugin: 0,
					PluginArray: 0,
					SVGLengthList: 0,
					SVGNumberList: 0,
					SVGPathSegList: 0,
					SVGPointList: 0,
					SVGStringList: 0,
					SVGTransformList: 0,
					SourceBufferList: 0,
					StyleSheetList: 0,
					TextTrackCueList: 0,
					TextTrackList: 0,
					TouchList: 0
				};
			}),
			"fdbf": (function(module$1, exports$1, __webpack_require__) {
				module$1.exports = __webpack_require__("4930") && !Symbol.sham && typeof Symbol.iterator == "symbol";
			})
		})["default"];
	});
}));
var import_vuedraggable_umd$1 = /* @__PURE__ */ __toESM(require_vuedraggable_umd());
var _hoisted_1$11 = ["data-test-id"];
var AssignmentCollection_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "AssignmentCollection",
	props: {
		parameter: {},
		value: {},
		path: {},
		defaultType: { default: void 0 },
		disableType: {
			type: Boolean,
			default: false
		},
		node: {},
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["valueChanged"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const expressionLocalResolveCtx = inject(ExpressionLocalResolveContextSymbol, void 0);
		const dropAreaContainer = useTemplateRef("dropArea");
		const state = reactive({ paramValue: { assignments: props.value.assignments?.map((assignment$2) => {
			if (!assignment$2.id) assignment$2.id = crypto.randomUUID();
			return assignment$2;
		}) ?? [] } });
		const ndvStore = useNDVStore();
		const experimentalNdvStore = useExperimentalNdvStore();
		const { callDebounced } = useDebounce();
		const issues = computed(() => {
			if (!ndvStore.activeNode) return {};
			return ndvStore.activeNode?.issues?.parameters ?? {};
		});
		const empty$1 = computed(() => state.paramValue.assignments.length === 0);
		const activeDragField = computed(() => propertyNameFromExpression(ndvStore.draggableData));
		const inputData = computed(() => ndvStore.ndvInputData?.[0]?.json);
		const actions = computed(() => {
			return [{
				label: i18n$1.baseText("assignment.addAll"),
				value: "addAll",
				disabled: !inputData.value
			}, {
				label: i18n$1.baseText("assignment.clearAll"),
				value: "clearAll",
				disabled: state.paramValue.assignments.length === 0
			}];
		});
		watch(state.paramValue, (value$1) => {
			callDebounced(() => {
				emit("valueChanged", {
					name: props.path,
					value: value$1,
					node: props.node?.name
				});
			}, { debounceTime: 1e3 });
		});
		function addAssignment() {
			state.paramValue.assignments.push({
				id: crypto.randomUUID(),
				name: "",
				value: "",
				type: props.defaultType ?? "string"
			});
		}
		function dropAssignment(expression) {
			state.paramValue.assignments.push({
				id: crypto.randomUUID(),
				name: propertyNameFromExpression(expression),
				value: `=${expression}`,
				type: props.defaultType ?? typeFromExpression(expression)
			});
		}
		function onAssignmentUpdate(index$1, value$1) {
			state.paramValue.assignments[index$1] = value$1;
		}
		function onAssignmentRemove(index$1) {
			state.paramValue.assignments.splice(index$1, 1);
		}
		function getIssues(index$1) {
			return issues.value[`${props.parameter.name}.${index$1}`] ?? [];
		}
		function optionSelected(action) {
			if (action === "clearAll") state.paramValue.assignments = [];
			else if (action === "addAll" && inputData.value) {
				const newAssignments = inputDataToAssignments(inputData.value);
				state.paramValue.assignments = state.paramValue.assignments.concat(newAssignments);
			}
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass({
					[_ctx.$style.assignmentCollection]: true,
					[_ctx.$style.empty]: empty$1.value
				}),
				"data-test-id": `assignment-collection-${_ctx.parameter.name}`
			}, [
				createVNode(unref(N8nInputLabel_default), {
					label: _ctx.parameter.displayName,
					"show-expression-selector": false,
					size: "small",
					underline: "",
					color: "text-dark"
				}, {
					options: withCtx(() => [createVNode(ParameterOptions_default, {
						parameter: _ctx.parameter,
						value: _ctx.value,
						"custom-actions": actions.value,
						"is-read-only": _ctx.isReadOnly,
						"show-expression-selector": false,
						"onUpdate:modelValue": optionSelected
					}, null, 8, [
						"parameter",
						"value",
						"custom-actions",
						"is-read-only"
					])]),
					_: 1
				}, 8, ["label"]),
				unref(experimentalNdvStore).isNdvInFocusPanelEnabled && unref(dropAreaContainer)?.$el && _ctx.node && unref(expressionLocalResolveCtx)?.inputNode ? (openBlock(), createBlock(ExperimentalEmbeddedNdvMapper_default, {
					key: 0,
					workflow: unref(expressionLocalResolveCtx).workflow,
					node: _ctx.node,
					"input-node-name": unref(expressionLocalResolveCtx).inputNode.name,
					reference: unref(dropAreaContainer)?.$el,
					"visible-on-hover": ""
				}, null, 8, [
					"workflow",
					"node",
					"input-node-name",
					"reference"
				])) : createCommentVNode("", true),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.content) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.assignments) }, [createVNode(unref(import_vuedraggable_umd$1.default), {
					modelValue: state.paramValue.assignments,
					"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.paramValue.assignments = $event),
					"item-key": "id",
					handle: ".drag-handle",
					"drag-class": _ctx.$style.dragging,
					"ghost-class": _ctx.$style.ghost
				}, {
					item: withCtx(({ index: index$1, element: assignment$2 }) => [createVNode(Assignment_default, {
						"model-value": assignment$2,
						index: index$1,
						path: `${_ctx.path}.assignments.${index$1}`,
						issues: getIssues(index$1),
						class: normalizeClass(_ctx.$style.assignment),
						"is-read-only": _ctx.isReadOnly,
						"disable-type": _ctx.disableType,
						"onUpdate:modelValue": (value$1) => onAssignmentUpdate(index$1, value$1),
						onRemove: () => onAssignmentRemove(index$1)
					}, null, 8, [
						"model-value",
						"index",
						"path",
						"issues",
						"class",
						"is-read-only",
						"disable-type",
						"onUpdate:modelValue",
						"onRemove"
					])]),
					_: 1
				}, 8, [
					"modelValue",
					"drag-class",
					"ghost-class"
				])], 2), !_ctx.isReadOnly ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.dropAreaWrapper),
					"data-test-id": "assignment-collection-drop-area",
					onClick: addAssignment
				}, [createVNode(DropArea_default, {
					ref: "dropArea",
					"sticky-offset": empty$1.value ? [-4, 32] : [92, 0],
					onDrop: dropAssignment
				}, {
					default: withCtx(({ active: active$2, droppable: droppable$10 }) => [createBaseVNode("div", { class: normalizeClass({
						[_ctx.$style.active]: active$2,
						[_ctx.$style.droppable]: droppable$10
					}) }, [droppable$10 ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.dropArea)
					}, [createBaseVNode("span", null, toDisplayString(unref(i18n$1).baseText("assignment.dropField")), 1), createBaseVNode("span", { class: normalizeClass(_ctx.$style.activeField) }, toDisplayString(activeDragField.value), 3)], 2)) : (openBlock(), createElementBlock("div", {
						key: 1,
						class: normalizeClass(_ctx.$style.dropArea)
					}, [
						createBaseVNode("span", null, toDisplayString(unref(i18n$1).baseText("assignment.dragFields")), 1),
						createBaseVNode("span", { class: normalizeClass(_ctx.$style.or) }, toDisplayString(unref(i18n$1).baseText("assignment.or")), 3),
						createBaseVNode("span", { class: normalizeClass(_ctx.$style.add) }, toDisplayString(unref(i18n$1).baseText("assignment.add")), 3)
					], 2))], 2)]),
					_: 1
				}, 8, ["sticky-offset"])], 2)) : createCommentVNode("", true)], 2)
			], 10, _hoisted_1$11);
		};
	}
});
var AssignmentCollection_vue_vue_type_style_index_0_lang_module_default = {
	assignmentCollection: "_assignmentCollection_1yy2w_123",
	content: "_content_1yy2w_129",
	assignments: "_assignments_1yy2w_135",
	assignment: "_assignment_1yy2w_123",
	dropAreaWrapper: "_dropAreaWrapper_1yy2w_145",
	empty: "_empty_1yy2w_148",
	add: "_add_1yy2w_151",
	dropArea: "_dropArea_1yy2w_145",
	or: "_or_1yy2w_173",
	activeField: "_activeField_1yy2w_183",
	active: "_active_1yy2w_183",
	droppable: "_droppable_1yy2w_198",
	icon: "_icon_1yy2w_206",
	ghost: "_ghost_1yy2w_210",
	dragging: "_dragging_1yy2w_211"
};
var AssignmentCollection_default = /* @__PURE__ */ __plugin_vue_export_helper_default(AssignmentCollection_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": AssignmentCollection_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$10 = ["hidden"];
var _hoisted_2$5 = ["textContent"];
var _hoisted_3$5 = ["textContent"];
var _hoisted_4$4 = ["textContent"];
var AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT = "codeGeneratedForPrompt";
var ButtonParameter_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ButtonParameter",
	props: {
		parameter: {},
		value: {},
		path: {},
		isReadOnly: { type: Boolean }
	},
	emits: ["valueChanged"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const props = __props;
		const ndvStore = useNDVStore();
		const activeNode = computed(() => ndvStore.activeNode);
		const i18n$1 = useI18n();
		const isLoading = ref(false);
		const prompt = ref(props.value);
		const parentNodes = ref([]);
		const textareaRowsData = ref(null);
		const hasExecutionData = computed(() => (useNDVStore().ndvInputData || []).length > 0);
		const hasInputField = computed(() => props.parameter.typeOptions?.buttonConfig?.hasInputField);
		const inputFieldMaxLength = computed(() => props.parameter.typeOptions?.buttonConfig?.inputFieldMaxLength);
		const buttonLabel = computed(() => props.parameter.typeOptions?.buttonConfig?.label ?? props.parameter.displayName);
		const isSubmitEnabled = computed(() => {
			if (!hasExecutionData.value || !prompt.value || props.isReadOnly) return false;
			const maxlength = inputFieldMaxLength.value;
			if (maxlength && prompt.value.length > maxlength) return false;
			return true;
		});
		const promptUpdated = computed(() => {
			const lastPrompt = activeNode.value?.parameters[AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT];
			if (!lastPrompt) return false;
			return lastPrompt.trim() !== prompt.value.trim();
		});
		function startLoading() {
			isLoading.value = true;
		}
		function stopLoading() {
			setTimeout(() => {
				isLoading.value = false;
			}, 200);
		}
		function getPath(parameter) {
			return (props.path ? `${props.path}.` : "") + parameter;
		}
		async function onSubmit() {
			const { showMessage } = useToast();
			const action = props.parameter.typeOptions?.buttonConfig?.action;
			if (!action || !activeNode.value) return;
			if (typeof action === "string") switch (action) {
				default: return;
			}
			emit("valueChanged", {
				name: getPath(props.parameter.name),
				value: prompt.value
			});
			const { type, target } = action;
			startLoading();
			try {
				switch (type) {
					case "askAiCodeGeneration":
						const updateInformation = await generateCodeForAiTransform(prompt.value, getPath(target), 5);
						if (!updateInformation) return;
						emit("valueChanged", updateInformation);
						emit("valueChanged", {
							name: getPath(AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT),
							value: prompt.value
						});
						useTelemetry().trackAiTransform("generationFinished", {
							prompt: prompt.value,
							code: updateInformation.value
						});
						break;
					default: return;
				}
				showMessage({
					type: "success",
					title: i18n$1.baseText("codeNodeEditor.askAi.generationCompleted")
				});
				stopLoading();
			} catch (error) {
				useTelemetry().trackAiTransform("generationFinished", {
					prompt: prompt.value,
					code: "",
					hasError: true
				});
				showMessage({
					type: "error",
					title: i18n$1.baseText("codeNodeEditor.askAi.generationFailed"),
					message: error.message
				});
				stopLoading();
			}
		}
		function onPromptInput(inputValue) {
			prompt.value = inputValue;
			emit("valueChanged", {
				name: getPath(props.parameter.name),
				value: inputValue
			});
		}
		onMounted(() => {
			parentNodes.value = getParentNodes();
		});
		function cleanTextareaRowsData() {
			textareaRowsData.value = null;
		}
		async function onDrop(value$1, event) {
			value$1 = propertyNameFromExpression(value$1);
			prompt.value = getUpdatedTextareaValue(event, textareaRowsData.value, value$1);
			emit("valueChanged", {
				name: getPath(props.parameter.name),
				value: prompt.value
			});
		}
		async function updateCursorPositionOnMouseMove(event, activeDrop$8) {
			if (!activeDrop$8) return;
			const textarea = event.target;
			const position = getTextareaCursorPosition(textarea, textareaRowsData.value, event.clientX, event.clientY);
			textarea.focus();
			textarea.setSelectionRange(position, position);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", null, [
				hasInputField.value ? (openBlock(), createBlock(unref(N8nInputLabel_default), {
					key: 0,
					label: unref(i18n$1).nodeText(activeNode.value?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path),
					"tooltip-text": unref(i18n$1).nodeText(activeNode.value?.type).inputLabelDescription(_ctx.parameter, _ctx.path),
					bold: false,
					size: "small",
					color: "text-dark"
				}, null, 8, ["label", "tooltip-text"])) : createCommentVNode("", true),
				createBaseVNode("div", {
					class: normalizeClass([_ctx.$style.inputContainer, { [_ctx.$style.disabled]: _ctx.isReadOnly }]),
					hidden: !hasInputField.value
				}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.meta) }, [inputFieldMaxLength.value ? withDirectives((openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(_ctx.$style.counter),
					textContent: toDisplayString(`${prompt.value.length} / ${inputFieldMaxLength.value}`)
				}, null, 10, _hoisted_2$5)), [[vShow, prompt.value.length > 1]]) : createCommentVNode("", true), promptUpdated.value ? (openBlock(), createElementBlock("span", {
					key: 1,
					class: normalizeClass(_ctx.$style["warning-text"]),
					textContent: "Instructions changed"
				}, null, 2)) : createCommentVNode("", true)], 2), createVNode(DraggableTarget_default, {
					type: "mapping",
					disabled: isLoading.value,
					onDrop
				}, {
					default: withCtx(({ activeDrop: activeDrop$8, droppable: droppable$10 }) => [createVNode(unref(N8nInput_default), {
						modelValue: prompt.value,
						"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => prompt.value = $event),
						class: normalizeClass([_ctx.$style.input, {
							[_ctx.$style.activeDrop]: activeDrop$8,
							[_ctx.$style.droppable]: droppable$10
						}]),
						style: { "border": "1.5px solid var(--color--foreground)" },
						type: "textarea",
						rows: 6,
						maxlength: inputFieldMaxLength.value,
						placeholder: _ctx.parameter.placeholder,
						disabled: _ctx.isReadOnly,
						onInput: onPromptInput,
						onMousemove: ($event) => updateCursorPositionOnMouseMove($event, activeDrop$8),
						onMouseleave: cleanTextareaRowsData
					}, null, 8, [
						"modelValue",
						"class",
						"maxlength",
						"placeholder",
						"disabled",
						"onMousemove"
					])]),
					_: 1
				}, 8, ["disabled"])], 10, _hoisted_1$10),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.controls) }, [createVNode(unref(N8nTooltip_default), { disabled: isSubmitEnabled.value }, {
					content: withCtx(() => [!hasExecutionData.value ? (openBlock(), createElementBlock("span", {
						key: 0,
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.noInputData"))
					}, null, 8, _hoisted_3$5)) : prompt.value.length === 0 ? (openBlock(), createElementBlock("span", {
						key: 1,
						textContent: toDisplayString(unref(i18n$1).baseText("codeNodeEditor.askAi.noPrompt"))
					}, null, 8, _hoisted_4$4)) : createCommentVNode("", true)]),
					default: withCtx(() => [createBaseVNode("div", null, [createVNode(unref(N8nButton_default), {
						disabled: !isSubmitEnabled.value,
						size: "small",
						loading: isLoading.value,
						type: "secondary",
						onClick: onSubmit
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(buttonLabel.value), 1)]),
						_: 1
					}, 8, ["disabled", "loading"])])]),
					_: 1
				}, 8, ["disabled"])], 2)
			]);
		};
	}
});
const input = "_input_1skxv_123";
const intro = "_intro_1skxv_139";
const inputContainer = "_inputContainer_1skxv_146";
const meta = "_meta_1skxv_150";
const counter = "_counter_1skxv_169";
const controls = "_controls_1skxv_174";
const droppable = "_droppable_1skxv_185";
const activeDrop = "_activeDrop_1skxv_189";
const disabled = "_disabled_1skxv_194";
var ButtonParameter_vue_vue_type_style_index_0_lang_module_default = {
	input,
	intro,
	inputContainer,
	meta,
	counter,
	controls,
	"warning-text": "_warning-text_1skxv_180",
	droppable,
	activeDrop,
	disabled
};
var ButtonParameter_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ButtonParameter_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ButtonParameter_vue_vue_type_style_index_0_lang_module_default }]]);
const DEFAULT_FILTER_OPTIONS = {
	caseSensitive: true,
	leftValue: "",
	typeValidation: "strict",
	version: 1
};
const OPERATORS_BY_ID = {
	"string:exists": {
		type: "string",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"string:notExists": {
		type: "string",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"string:empty": {
		type: "string",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"string:notEmpty": {
		type: "string",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	},
	"string:equals": {
		type: "string",
		operation: "equals",
		name: "filter.operator.equals"
	},
	"string:notEquals": {
		type: "string",
		operation: "notEquals",
		name: "filter.operator.notEquals"
	},
	"string:contains": {
		type: "string",
		operation: "contains",
		name: "filter.operator.contains"
	},
	"string:notContains": {
		type: "string",
		operation: "notContains",
		name: "filter.operator.notContains"
	},
	"string:startsWith": {
		type: "string",
		operation: "startsWith",
		name: "filter.operator.startsWith"
	},
	"string:notStartsWith": {
		type: "string",
		operation: "notStartsWith",
		name: "filter.operator.notStartsWith"
	},
	"string:endsWith": {
		type: "string",
		operation: "endsWith",
		name: "filter.operator.endsWith"
	},
	"string:notEndsWith": {
		type: "string",
		operation: "notEndsWith",
		name: "filter.operator.notEndsWith"
	},
	"string:regex": {
		type: "string",
		operation: "regex",
		name: "filter.operator.regex"
	},
	"string:notRegex": {
		type: "string",
		operation: "notRegex",
		name: "filter.operator.notRegex"
	},
	"number:exists": {
		type: "number",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"number:notExists": {
		type: "number",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"number:empty": {
		type: "number",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"number:notEmpty": {
		type: "number",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	},
	"number:equals": {
		type: "number",
		operation: "equals",
		name: "filter.operator.equals"
	},
	"number:notEquals": {
		type: "number",
		operation: "notEquals",
		name: "filter.operator.notEquals"
	},
	"number:gt": {
		type: "number",
		operation: "gt",
		name: "filter.operator.gt"
	},
	"number:lt": {
		type: "number",
		operation: "lt",
		name: "filter.operator.lt"
	},
	"number:gte": {
		type: "number",
		operation: "gte",
		name: "filter.operator.gte"
	},
	"number:lte": {
		type: "number",
		operation: "lte",
		name: "filter.operator.lte"
	},
	"dateTime:exists": {
		type: "dateTime",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"dateTime:notExists": {
		type: "dateTime",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"dateTime:empty": {
		type: "dateTime",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"dateTime:notEmpty": {
		type: "dateTime",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	},
	"dateTime:equals": {
		type: "dateTime",
		operation: "equals",
		name: "filter.operator.equals"
	},
	"dateTime:notEquals": {
		type: "dateTime",
		operation: "notEquals",
		name: "filter.operator.notEquals"
	},
	"dateTime:after": {
		type: "dateTime",
		operation: "after",
		name: "filter.operator.after"
	},
	"dateTime:before": {
		type: "dateTime",
		operation: "before",
		name: "filter.operator.before"
	},
	"dateTime:afterOrEquals": {
		type: "dateTime",
		operation: "afterOrEquals",
		name: "filter.operator.afterOrEquals"
	},
	"dateTime:beforeOrEquals": {
		type: "dateTime",
		operation: "beforeOrEquals",
		name: "filter.operator.beforeOrEquals"
	},
	"boolean:exists": {
		type: "boolean",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"boolean:notExists": {
		type: "boolean",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"boolean:empty": {
		type: "boolean",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"boolean:notEmpty": {
		type: "boolean",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	},
	"boolean:true": {
		type: "boolean",
		operation: "true",
		name: "filter.operator.true",
		singleValue: true
	},
	"boolean:false": {
		type: "boolean",
		operation: "false",
		name: "filter.operator.false",
		singleValue: true
	},
	"boolean:equals": {
		type: "boolean",
		operation: "equals",
		name: "filter.operator.equals"
	},
	"boolean:notEquals": {
		type: "boolean",
		operation: "notEquals",
		name: "filter.operator.notEquals"
	},
	"array:exists": {
		type: "array",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"array:notExists": {
		type: "array",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"array:empty": {
		type: "array",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"array:notEmpty": {
		type: "array",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	},
	"array:contains": {
		type: "array",
		operation: "contains",
		name: "filter.operator.contains",
		rightType: "any"
	},
	"array:notContains": {
		type: "array",
		operation: "notContains",
		name: "filter.operator.notContains",
		rightType: "any"
	},
	"array:lengthEquals": {
		type: "array",
		operation: "lengthEquals",
		name: "filter.operator.lengthEquals",
		rightType: "number"
	},
	"array:lengthNotEquals": {
		type: "array",
		operation: "lengthNotEquals",
		name: "filter.operator.lengthNotEquals",
		rightType: "number"
	},
	"array:lengthGt": {
		type: "array",
		operation: "lengthGt",
		name: "filter.operator.lengthGt",
		rightType: "number"
	},
	"array:lengthLt": {
		type: "array",
		operation: "lengthLt",
		name: "filter.operator.lengthLt",
		rightType: "number"
	},
	"array:lengthGte": {
		type: "array",
		operation: "lengthGte",
		name: "filter.operator.lengthGte",
		rightType: "number"
	},
	"array:lengthLte": {
		type: "array",
		operation: "lengthLte",
		name: "filter.operator.lengthLte",
		rightType: "number"
	},
	"object:exists": {
		type: "object",
		operation: "exists",
		name: "filter.operator.exists",
		singleValue: true
	},
	"object:notExists": {
		type: "object",
		operation: "notExists",
		name: "filter.operator.notExists",
		singleValue: true
	},
	"object:empty": {
		type: "object",
		operation: "empty",
		name: "filter.operator.empty",
		singleValue: true
	},
	"object:notEmpty": {
		type: "object",
		operation: "notEmpty",
		name: "filter.operator.notEmpty",
		singleValue: true
	}
};
const OPERATORS = Object.values(OPERATORS_BY_ID);
const DEFAULT_OPERATOR_VALUE = OPERATORS_BY_ID["string:equals"];
const OPERATOR_GROUPS = [
	{
		id: "string",
		name: "type.string",
		icon: DATA_TYPE_ICON_MAP.string,
		children: OPERATORS.filter((operator) => operator.type === "string")
	},
	{
		id: "number",
		name: "type.number",
		icon: DATA_TYPE_ICON_MAP.number,
		children: OPERATORS.filter((operator) => operator.type === "number")
	},
	{
		id: "dateTime",
		name: "type.dateTime",
		icon: DATA_TYPE_ICON_MAP.date,
		children: OPERATORS.filter((operator) => operator.type === "dateTime")
	},
	{
		id: "boolean",
		name: "type.boolean",
		icon: DATA_TYPE_ICON_MAP.boolean,
		children: OPERATORS.filter((operator) => operator.type === "boolean")
	},
	{
		id: "array",
		name: "type.array",
		icon: DATA_TYPE_ICON_MAP.array,
		children: OPERATORS.filter((operator) => operator.type === "array")
	},
	{
		id: "object",
		name: "type.object",
		icon: DATA_TYPE_ICON_MAP.object,
		children: OPERATORS.filter((operator) => operator.type === "object")
	}
];
const getFilterOperator = (key) => OPERATORS_BY_ID[key];
var getTargetType = (type) => {
	if (type === "number") return "number";
	if (type === "boolean") return "boolean";
	return "string";
};
var convertToType = (value$1, type) => {
	if (type === "any") return value$1;
	const fallback = type === "boolean" ? false : value$1;
	const validationResult = validateFieldType("filter", value$1, getTargetType(type), { parseStrings: true });
	if (!validationResult.valid) return fallback;
	return validationResult.newValue ?? fallback;
};
const handleOperatorChange = ({ condition: condition$1, newOperator }) => {
	const currentOperator = condition$1.operator;
	const rightType = currentOperator.rightType ?? currentOperator.type;
	const newRightType = newOperator.rightType ?? newOperator.type;
	const leftTypeChanged = currentOperator.type !== newOperator.type;
	const rightTypeChanged = rightType !== newRightType;
	if (leftTypeChanged && !isExpression(condition$1.leftValue)) condition$1.leftValue = convertToType(condition$1.leftValue, newOperator.type);
	if (rightTypeChanged && !newOperator.singleValue && !isExpression(condition$1.rightValue)) condition$1.rightValue = convertToType(condition$1.rightValue, newRightType);
	condition$1.operator = {
		type: newOperator.type,
		operation: newOperator.operation,
		rightType: newOperator.rightType,
		singleValue: newOperator.singleValue
	};
	return condition$1;
};
const isEmptyInput = (value$1) => {
	return value$1 === "" || value$1 === "=";
};
const resolveCondition = ({ condition: condition$1, options: options$1, index: index$1 = 0 }) => {
	try {
		const resolved = resolveParameter(condition$1);
		if (resolved.leftValue === void 0 || resolved.rightValue === void 0) return { status: "resolve_error" };
		try {
			return {
				status: "success",
				result: executeFilterCondition(resolved, options$1, {
					index: index$1,
					errorFormat: "inline"
				}),
				resolved
			};
		} catch (error) {
			let errorMessage = i18n.baseText("parameterInput.error");
			if (error instanceof FilterError) errorMessage = `${error.message}.\n${error.description}`;
			return {
				status: "validation_error",
				error: errorMessage,
				resolved
			};
		}
	} catch (error) {
		return { status: "resolve_error" };
	}
};
const operatorTypeToNodeProperty = (operatorType) => {
	switch (operatorType) {
		case "boolean": return {
			type: "options",
			options: [{
				name: "true",
				value: true
			}, {
				name: "false",
				value: false
			}]
		};
		case "array":
		case "object":
		case "any": return { type: "string" };
		default: return { type: operatorType };
	}
};
const inferOperatorType = (value$1) => {
	if (typeof value$1 === "string") {
		if (validateFieldType("filter", value$1, "dateTime").valid) return "dateTime";
		return "string";
	} else if (typeof value$1 === "number") return "number";
	else if (typeof value$1 === "boolean") return "boolean";
	else if (DateTime.isDateTime(value$1)) return "dateTime";
	else if (value$1 && typeof value$1 === "object") return Array.isArray(value$1) ? "array" : "object";
	return "any";
};
var _hoisted_1$9 = ["onMouseenter", "onClick"];
var OperatorSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "OperatorSelect",
	props: {
		selected: {},
		suggestedType: { default: "any" },
		readOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["operatorChange"],
	setup(__props, { emit: __emit }) {
		const selected$1 = ref(__props.selected);
		const menuOpen = ref(false);
		const shouldRenderItems = ref(false);
		const submenu = ref("none");
		const emit = __emit;
		const i18n$1 = useI18n();
		const groups$1 = OPERATOR_GROUPS;
		const selectedGroupIcon = computed(() => groups$1.find((group$1) => group$1.id === selected$1.value.split(":")[0])?.icon);
		const selectedOperator = computed(() => getFilterOperator(selected$1.value));
		const selectedType = computed(() => selectedOperator.value.type);
		const onOperatorChange = (operator) => {
			selected$1.value = operator;
			emit("operatorChange", operator);
		};
		const getOperatorId = (operator) => `${operator.type}:${operator.operation}`;
		function onSelectVisibleChange(open) {
			menuOpen.value = open;
			if (!open) submenu.value = "none";
		}
		function onGroupSelect(group$1) {
			if (menuOpen.value) submenu.value = group$1;
		}
		return (_ctx, _cache) => {
			return openBlock(), createBlock(unref(N8nSelect_default), {
				key: selectedGroupIcon.value,
				"data-test-id": "filter-operator-select",
				size: "small",
				"model-value": selected$1.value,
				disabled: _ctx.readOnly,
				"onUpdate:modelValue": onOperatorChange,
				onVisibleChange: onSelectVisibleChange,
				onMouseenter: _cache[0] || (_cache[0] = ($event) => shouldRenderItems.value = true)
			}, createSlots({
				default: withCtx(() => [shouldRenderItems.value ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: normalizeClass(_ctx.$style.groups)
				}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(groups$1), (group$1) => {
					return openBlock(), createElementBlock("div", { key: group$1.name }, [createVNode(unref(N8nPopover_default), {
						visible: submenu.value === group$1.id,
						placement: "right-start",
						"show-arrow": false,
						offset: 2,
						"popper-style": { padding: "var(--spacing--3xs) 0" },
						width: "auto"
					}, {
						reference: withCtx(() => [createBaseVNode("div", {
							class: normalizeClass([_ctx.$style.group, {
								[_ctx.$style.selected]: group$1.id === selectedType.value,
								[_ctx.$style.suggested]: group$1.id === _ctx.suggestedType
							}]),
							onMouseenter: () => onGroupSelect(group$1.id),
							onClick: () => onGroupSelect(group$1.id)
						}, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.groupTitle) }, [group$1.icon ? (openBlock(), createBlock(unref(N8nIcon_default), {
							key: 0,
							icon: group$1.icon,
							class: normalizeClass(_ctx.$style.icon),
							size: "small"
						}, null, 8, ["icon", "class"])) : createCommentVNode("", true), createBaseVNode("span", null, toDisplayString(unref(i18n$1).baseText(group$1.name)), 1)], 2), createVNode(unref(N8nIcon_default), {
							icon: "chevron-right",
							color: "text-light",
							size: "xsmall"
						})], 42, _hoisted_1$9)]),
						default: withCtx(() => [createBaseVNode("div", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(group$1.children, (operator) => {
							return openBlock(), createBlock(unref(N8nOption_default), {
								key: getOperatorId(operator),
								value: getOperatorId(operator),
								label: unref(i18n$1).baseText(operator.name)
							}, null, 8, ["value", "label"]);
						}), 128))])]),
						_: 2
					}, 1032, ["visible"])]);
				}), 128))], 2)) : (openBlock(), createBlock(unref(N8nOption_default), {
					key: selected$1.value,
					value: selected$1.value,
					label: unref(i18n$1).baseText(selectedOperator.value.name)
				}, null, 8, ["value", "label"]))]),
				_: 2
			}, [selectedGroupIcon.value ? {
				name: "prefix",
				fn: withCtx(() => [createVNode(unref(N8nIcon_default), {
					class: normalizeClass(_ctx.$style.icon),
					icon: selectedGroupIcon.value,
					color: "text-light",
					size: "small"
				}, null, 8, ["class", "icon"])]),
				key: "0"
			} : void 0]), 1032, ["model-value", "disabled"]);
		};
	}
});
var OperatorSelect_vue_vue_type_style_index_0_lang_module_default = {
	icon: "_icon_1ub2o_123",
	groups: "_groups_1ub2o_127",
	group: "_group_1ub2o_127",
	suggested: "_suggested_1ub2o_143",
	groupTitle: "_groupTitle_1ub2o_150"
};
var OperatorSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(OperatorSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": OperatorSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var Condition_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Condition",
	props: {
		path: {},
		condition: {},
		options: {},
		issues: { default: () => [] },
		fixedLeftValue: {
			type: Boolean,
			default: false
		},
		canRemove: {
			type: Boolean,
			default: true
		},
		readOnly: {
			type: Boolean,
			default: false
		},
		index: { default: 0 },
		canDrag: {
			type: Boolean,
			default: true
		}
	},
	emits: ["update", "remove"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const { debounce: debounce$4 } = useDebounce();
		const condition$1 = ref(props.condition);
		const operatorId = computed(() => {
			const { type, operation } = props.condition.operator;
			return `${type}:${operation}`;
		});
		const operator = computed(() => getFilterOperator(operatorId.value));
		const isEmpty$2 = computed(() => {
			if (operator.value.singleValue) return isEmptyInput(condition$1.value.leftValue);
			return isEmptyInput(condition$1.value.leftValue) && isEmptyInput(condition$1.value.rightValue);
		});
		const conditionResult = computed(() => resolveCondition({
			condition: condition$1.value,
			options: props.options
		}));
		const suggestedType = computed(() => {
			if (conditionResult.value.status !== "resolve_error") return inferOperatorType(conditionResult.value.resolved.leftValue);
			return "any";
		});
		const allIssues = computed(() => {
			if (conditionResult.value.status === "validation_error" && !isEmpty$2.value) return [conditionResult.value.error];
			return props.issues;
		});
		const now = computed(() => DateTime.now().toISO());
		const leftParameter = computed(() => ({
			name: "left",
			displayName: "Left",
			default: "",
			placeholder: operator.value.type === "dateTime" ? now.value : i18n$1.baseText("filter.condition.placeholderLeft"),
			...operatorTypeToNodeProperty(operator.value.type)
		}));
		const rightParameter = computed(() => {
			const type = operator.value.rightType ?? operator.value.type;
			return {
				name: "right",
				displayName: "Right",
				default: "",
				placeholder: type === "dateTime" ? now.value : i18n$1.baseText("filter.condition.placeholderRight"),
				...operatorTypeToNodeProperty(type)
			};
		});
		const debouncedEmitUpdate = debounce$4(() => emit("update", condition$1.value), { debounceTime: 500 });
		const onLeftValueChange = (update) => {
			condition$1.value.leftValue = update.value;
			debouncedEmitUpdate();
		};
		const onRightValueChange = (update) => {
			condition$1.value.rightValue = update.value;
			debouncedEmitUpdate();
		};
		const onOperatorChange = (value$1) => {
			const newOperator = getFilterOperator(value$1);
			condition$1.value = handleOperatorChange({
				condition: condition$1.value,
				newOperator
			});
			debouncedEmitUpdate();
		};
		const onRemove = () => {
			emit("remove");
		};
		const onBlur = () => {
			debouncedEmitUpdate();
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass({
					[_ctx.$style.wrapper]: true,
					[_ctx.$style.hasIssues]: allIssues.value.length > 0
				}),
				"data-test-id": "filter-condition"
			}, [
				_ctx.canDrag && !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 0,
					type: "tertiary",
					text: "",
					size: "small",
					icon: "grip-vertical",
					title: unref(i18n$1).baseText("filter.dragCondition"),
					class: normalizeClass([
						_ctx.$style.iconButton,
						_ctx.$style.defaultTopPadding,
						"drag-handle"
					])
				}, null, 8, ["title", "class"])) : createCommentVNode("", true),
				_ctx.canRemove && !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 1,
					type: "tertiary",
					text: "",
					size: "small",
					icon: "trash-2",
					"data-test-id": "filter-remove-condition",
					title: unref(i18n$1).baseText("filter.removeCondition"),
					class: normalizeClass([_ctx.$style.iconButton, _ctx.$style.extraTopPadding]),
					onClick: onRemove
				}, null, 8, ["title", "class"])) : createCommentVNode("", true),
				createVNode(InputTriple_default, null, createSlots({
					left: withCtx(() => [!_ctx.fixedLeftValue ? (openBlock(), createBlock(ParameterInputFull_default, {
						key: leftParameter.value.type,
						"display-options": "",
						"hide-label": "",
						"hide-hint": "",
						"hide-issues": "",
						"is-read-only": _ctx.readOnly,
						parameter: leftParameter.value,
						value: condition$1.value.leftValue,
						path: `${_ctx.path}.leftValue`,
						class: normalizeClass([_ctx.$style.input, _ctx.$style.inputLeft]),
						"data-test-id": "filter-condition-left",
						onUpdate: onLeftValueChange,
						onBlur
					}, null, 8, [
						"is-read-only",
						"parameter",
						"value",
						"path",
						"class"
					])) : createCommentVNode("", true)]),
					middle: withCtx(() => [createVNode(OperatorSelect_default, {
						selected: `${operator.value.type}:${operator.value.operation}`,
						"suggested-type": suggestedType.value,
						"read-only": _ctx.readOnly,
						onOperatorChange
					}, null, 8, [
						"selected",
						"suggested-type",
						"read-only"
					])]),
					_: 2
				}, [!operator.value.singleValue ? {
					name: "right",
					fn: withCtx(({ breakpoint }) => [(openBlock(), createBlock(ParameterInputFull_default, {
						key: rightParameter.value.type,
						"display-options": "",
						"hide-label": "",
						"hide-hint": "",
						"hide-issues": "",
						"is-read-only": _ctx.readOnly,
						"options-position": breakpoint === "default" ? "top" : "bottom",
						parameter: rightParameter.value,
						value: condition$1.value.rightValue,
						path: `${_ctx.path}.rightValue`,
						class: normalizeClass([_ctx.$style.input, _ctx.$style.inputRight]),
						"data-test-id": "filter-condition-right",
						onUpdate: onRightValueChange,
						onBlur
					}, null, 8, [
						"is-read-only",
						"options-position",
						"parameter",
						"value",
						"path",
						"class"
					]))]),
					key: "0"
				} : void 0]), 1024),
				createBaseVNode("div", { class: normalizeClass(_ctx.$style.status) }, [allIssues.value.length > 0 ? (openBlock(), createBlock(ParameterIssues_default, {
					key: 0,
					issues: allIssues.value
				}, null, 8, ["issues"])) : conditionResult.value.status === "success" && conditionResult.value.result === true ? (openBlock(), createBlock(unref(N8nTooltip_default), {
					key: 1,
					"show-after": 500
				}, {
					content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("filter.condition.resolvedTrue")), 1)]),
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						icon: "circle-check",
						size: "medium",
						color: "text-light"
					})]),
					_: 1
				})) : conditionResult.value.status === "success" && conditionResult.value.result === false ? (openBlock(), createBlock(unref(N8nTooltip_default), {
					key: 2,
					"show-after": 500
				}, {
					content: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("filter.condition.resolvedFalse")), 1)]),
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						icon: "circle-x",
						size: "medium",
						color: "text-light"
					})]),
					_: 1
				})) : createCommentVNode("", true)], 2)
			], 2);
		};
	}
});
var Condition_vue_vue_type_style_index_0_lang_module_default = {
	wrapper: "_wrapper_1alvy_123",
	hasIssues: "_hasIssues_1alvy_129",
	iconButton: "_iconButton_1alvy_132",
	status: "_status_1alvy_136",
	defaultTopPadding: "_defaultTopPadding_1alvy_149",
	extraTopPadding: "_extraTopPadding_1alvy_153"
};
var Condition_default = /* @__PURE__ */ __plugin_vue_export_helper_default(Condition_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": Condition_vue_vue_type_style_index_0_lang_module_default }]]);
var _hoisted_1$8 = { key: 0 };
var CombinatorSelect_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CombinatorSelect",
	props: {
		options: {},
		selected: {},
		readOnly: { type: Boolean }
	},
	emits: ["combinatorChange"],
	setup(__props, { emit: __emit }) {
		const emit = __emit;
		const i18n$1 = useI18n();
		const onCombinatorChange = (combinator$1) => {
			emit("combinatorChange", combinator$1);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				"data-test-id": "filter-combinator-select",
				class: normalizeClass(_ctx.$style.combinatorSelect)
			}, [_ctx.readOnly || _ctx.options.length === 1 ? (openBlock(), createElementBlock("div", _hoisted_1$8, toDisplayString(unref(i18n$1).baseText(`filter.combinator.${_ctx.selected}`)), 1)) : (openBlock(), createBlock(unref(N8nSelect_default), {
				key: 1,
				size: "small",
				"model-value": _ctx.selected,
				"onUpdate:modelValue": onCombinatorChange
			}, {
				default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option$1) => {
					return openBlock(), createBlock(unref(N8nOption_default), {
						key: option$1,
						value: option$1,
						label: unref(i18n$1).baseText(`filter.combinator.${option$1}`)
					}, null, 8, ["value", "label"]);
				}), 128))]),
				_: 1
			}, 8, ["model-value"]))], 2);
		};
	}
});
var CombinatorSelect_vue_vue_type_style_index_0_lang_module_default = { combinatorSelect: "_combinatorSelect_1dc1o_123" };
var CombinatorSelect_default = /* @__PURE__ */ __plugin_vue_export_helper_default(CombinatorSelect_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": CombinatorSelect_vue_vue_type_style_index_0_lang_module_default }]]);
var import_isEmpty = /* @__PURE__ */ __toESM(require_isEmpty());
var import_isEqual$1 = /* @__PURE__ */ __toESM(require_isEqual());
var import_vuedraggable_umd = /* @__PURE__ */ __toESM(require_vuedraggable_umd());
var _hoisted_1$7 = ["data-test-id"];
var FilterConditions_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "FilterConditions",
	props: {
		parameter: {},
		value: {},
		path: {},
		node: {},
		readOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["valueChanged"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const i18n$1 = useI18n();
		const ndvStore = useNDVStore();
		const { debounce: debounce$4 } = useDebounce();
		const debouncedEmitChange = debounce$4(emitChange, { debounceTime: 1e3 });
		function createCondition() {
			return {
				id: crypto.randomUUID(),
				leftValue: "",
				rightValue: "",
				operator: DEFAULT_OPERATOR_VALUE
			};
		}
		const allowedCombinators = computed(() => props.parameter.typeOptions?.filter?.allowedCombinators ?? ["and", "or"]);
		const state = reactive({ paramValue: {
			options: props.value?.options ?? DEFAULT_FILTER_OPTIONS,
			conditions: props.value?.conditions?.map((condition$1) => {
				if (!condition$1.id) condition$1.id = crypto.randomUUID();
				return condition$1;
			}) ?? [createCondition()],
			combinator: props.value?.combinator ?? allowedCombinators.value[0]
		} });
		const maxConditions = computed(() => props.parameter.typeOptions?.filter?.maxConditions ?? 10);
		const singleCondition = computed(() => props.parameter.typeOptions?.multipleValues === false);
		const maxConditionsReached = computed(() => maxConditions.value <= state.paramValue.conditions.length);
		const issues = computed(() => {
			if (!ndvStore.activeNode) return {};
			return ndvStore.activeNode?.issues?.parameters ?? {};
		});
		watch(() => props.node?.parameters, () => {
			const typeOptions = props.parameter.typeOptions?.filter;
			if (!typeOptions) return;
			let newOptions = DEFAULT_FILTER_OPTIONS;
			try {
				newOptions = {
					...DEFAULT_FILTER_OPTIONS,
					...resolveParameter(typeOptions)
				};
			} catch (error) {}
			if (!(0, import_isEqual$1.default)(state.paramValue.options, newOptions)) {
				state.paramValue.options = newOptions;
				debouncedEmitChange();
			}
		}, { immediate: true });
		watch(() => props.value, (value$1) => {
			if ((0, import_isEmpty.default)(value$1) || (0, import_isEqual$1.default)(state.paramValue, value$1)) return;
			state.paramValue.conditions = value$1.conditions;
			state.paramValue.combinator = value$1.combinator;
			state.paramValue.options = value$1.options;
		});
		watch(() => state.paramValue, () => {
			debouncedEmitChange();
		}, { deep: true });
		function emitChange() {
			emit("valueChanged", {
				name: props.path,
				value: state.paramValue,
				node: props.node?.name
			});
		}
		function addCondition$1() {
			state.paramValue.conditions.push(createCondition());
		}
		function onConditionUpdate(index$1, value$1) {
			state.paramValue.conditions[index$1] = value$1;
		}
		function onCombinatorChange(combinator$1) {
			state.paramValue.combinator = combinator$1;
		}
		function onConditionRemove(index$1) {
			state.paramValue.conditions.splice(index$1, 1);
		}
		function getIssues(index$1) {
			return issues.value[`${props.parameter.name}.${index$1}`] ?? [];
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: normalizeClass({
					[_ctx.$style.filter]: true,
					[_ctx.$style.single]: singleCondition.value
				}),
				"data-test-id": `filter-${_ctx.parameter.name}`
			}, [!singleCondition.value ? (openBlock(), createBlock(unref(N8nInputLabel_default), {
				key: 0,
				label: _ctx.parameter.displayName,
				underline: true,
				"show-options": true,
				"show-expression-selector": false,
				size: "small",
				color: "text-dark"
			}, null, 8, ["label"])) : createCommentVNode("", true), createBaseVNode("div", { class: normalizeClass(_ctx.$style.content) }, [createBaseVNode("div", { class: normalizeClass(_ctx.$style.conditions) }, [createVNode(unref(import_vuedraggable_umd.default), {
				modelValue: state.paramValue.conditions,
				"onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.paramValue.conditions = $event),
				"item-key": "id",
				handle: ".drag-handle",
				"drag-class": _ctx.$style.dragging,
				"ghost-class": _ctx.$style.ghost
			}, {
				item: withCtx(({ index: index$1, element: condition$1 }) => [createBaseVNode("div", null, [index$1 !== 0 ? (openBlock(), createBlock(CombinatorSelect_default, {
					key: 0,
					"read-only": index$1 !== 1 || _ctx.readOnly,
					options: allowedCombinators.value,
					selected: state.paramValue.combinator,
					class: normalizeClass(_ctx.$style.combinator),
					onCombinatorChange
				}, null, 8, [
					"read-only",
					"options",
					"selected",
					"class"
				])) : createCommentVNode("", true), createVNode(Condition_default, {
					condition: condition$1,
					index: index$1,
					options: state.paramValue.options,
					"fixed-left-value": !!_ctx.parameter.typeOptions?.filter?.leftValue,
					"read-only": _ctx.readOnly,
					"can-remove": index$1 !== 0 || state.paramValue.conditions.length > 1,
					"can-drag": index$1 !== 0 || state.paramValue.conditions.length > 1,
					path: `${_ctx.path}.conditions.${index$1}`,
					issues: getIssues(index$1),
					class: normalizeClass(_ctx.$style.condition),
					onUpdate: (value$1) => onConditionUpdate(index$1, value$1),
					onRemove: () => onConditionRemove(index$1)
				}, null, 8, [
					"condition",
					"index",
					"options",
					"fixed-left-value",
					"read-only",
					"can-remove",
					"can-drag",
					"path",
					"issues",
					"class",
					"onUpdate",
					"onRemove"
				])])]),
				_: 1
			}, 8, [
				"modelValue",
				"drag-class",
				"ghost-class"
			])], 2), !singleCondition.value && !_ctx.readOnly ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(_ctx.$style.addConditionWrapper)
			}, [createVNode(unref(N8nButton_default), {
				type: "tertiary",
				block: "",
				class: normalizeClass(_ctx.$style.addCondition),
				label: unref(i18n$1).baseText("filter.addCondition"),
				title: maxConditionsReached.value ? unref(i18n$1).baseText("filter.maxConditions") : "",
				disabled: maxConditionsReached.value,
				"data-test-id": "filter-add-condition",
				onClick: addCondition$1
			}, null, 8, [
				"class",
				"label",
				"title",
				"disabled"
			])], 2)) : createCommentVNode("", true)], 2)], 10, _hoisted_1$7);
		};
	}
});
var FilterConditions_vue_vue_type_style_index_0_lang_module_default = {
	filter: "_filter_fwpkp_123",
	conditions: "_conditions_fwpkp_129",
	combinator: "_combinator_fwpkp_135",
	condition: "_condition_fwpkp_129",
	single: "_single_fwpkp_148",
	content: "_content_fwpkp_151",
	addConditionWrapper: "_addConditionWrapper_fwpkp_155",
	addCondition: "_addCondition_fwpkp_155",
	ghost: "_ghost_fwpkp_179",
	dragging: "_dragging_fwpkp_180"
};
var FilterConditions_default = /* @__PURE__ */ __plugin_vue_export_helper_default(FilterConditions_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": FilterConditions_vue_vue_type_style_index_0_lang_module_default }]]);
var ImportCurlParameter_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ImportCurlParameter",
	props: { isReadOnly: { type: Boolean } },
	setup(__props) {
		const uiStore = useUIStore();
		const i18n$1 = useI18n();
		function onImportCurlClicked() {
			uiStore.openModal(IMPORT_CURL_MODAL_KEY);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", { class: normalizeClass(_ctx.$style.importSection) }, [createVNode(unref(N8nButton_default), {
				type: "secondary",
				label: unref(i18n$1).baseText("importCurlParameter.label"),
				disabled: _ctx.isReadOnly,
				size: "mini",
				onClick: onImportCurlClicked
			}, null, 8, ["label", "disabled"])], 2);
		};
	}
});
var ImportCurlParameter_vue_vue_type_style_index_0_lang_module_default = { importSection: "_importSection_zsiqy_123" };
var ImportCurlParameter_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ImportCurlParameter_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ImportCurlParameter_vue_vue_type_style_index_0_lang_module_default }]]);
var import_get$2 = /* @__PURE__ */ __toESM(require_get());
var _hoisted_1$6 = { class: "collection-parameter-wrapper" };
var _hoisted_2$4 = {
	key: 0,
	class: "no-items-exist"
};
var _hoisted_3$4 = {
	key: 1,
	class: "param-options"
};
var _hoisted_4$3 = {
	key: 1,
	class: "add-option"
};
var CollectionParameter_default = /* @__PURE__ */ defineComponent({
	__name: "CollectionParameter",
	props: {
		hideDelete: { type: Boolean },
		nodeValues: {},
		parameter: {},
		path: {},
		values: {},
		isReadOnly: { type: Boolean }
	},
	emits: ["valueChanged"],
	setup(__props, { emit: __emit }) {
		const selectedOption = ref(void 0);
		const emit = __emit;
		const props = __props;
		const ndvStore = useNDVStore();
		const i18n$1 = useI18n();
		const nodeHelpers = useNodeHelpers();
		const { activeNode } = storeToRefs(ndvStore);
		const getPlaceholderText = computed(() => {
			return i18n$1.nodeText(activeNode.value?.type).placeholder(props.parameter, props.path) ?? i18n$1.baseText("collectionParameter.choose");
		});
		function isNodePropertyCollection(object) {
			return "values" in object;
		}
		function getParameterOptionLabel(item$2) {
			if (isNodePropertyCollection(item$2)) return i18n$1.nodeText(activeNode.value?.type).collectionOptionDisplayName(props.parameter, item$2, props.path);
			return "displayName" in item$2 ? item$2.displayName : item$2.name;
		}
		function displayNodeParameter(parameter) {
			if (parameter.type === "hidden") return false;
			if (parameter.displayOptions === void 0) return true;
			return nodeHelpers.displayParameter(props.nodeValues, parameter, props.path, ndvStore.activeNode);
		}
		function getOptionProperties(optionName) {
			const properties$1 = [];
			for (const option$1 of props.parameter.options ?? []) if (option$1.name === optionName) properties$1.push(option$1);
			return properties$1;
		}
		const propertyNames = computed(() => {
			if (props.values) return Object.keys(props.values);
			return [];
		});
		const getProperties = computed(() => {
			const returnProperties = [];
			let tempProperties;
			for (const name of propertyNames.value) {
				tempProperties = getOptionProperties(name);
				if (tempProperties !== void 0) returnProperties.push(...tempProperties);
			}
			return returnProperties;
		});
		const filteredOptions = computed(() => {
			return props.parameter.options.filter((option$1) => {
				return displayNodeParameter(option$1);
			});
		});
		const parameterOptions = computed(() => {
			return filteredOptions.value.filter((option$1) => {
				return !propertyNames.value.includes(option$1.name);
			});
		});
		function optionSelected(optionName) {
			const options$1 = getOptionProperties(optionName);
			if (options$1.length === 0) return;
			const option$1 = options$1[0];
			const name = `${props.path}.${option$1.name}`;
			let parameterData;
			if ("typeOptions" in option$1 && option$1.typeOptions !== void 0 && option$1.typeOptions.multipleValues === true) {
				let newValue;
				if (option$1.type === "fixedCollection") newValue = (0, import_get$2.default)(props.nodeValues, [props.path, optionName], {});
				else {
					const retrievedArrayValue = (0, import_get$2.default)(props.nodeValues, [props.path, optionName], []);
					if (Array.isArray(retrievedArrayValue)) {
						newValue = retrievedArrayValue;
						newValue.push(deepCopy(option$1.default));
					}
				}
				parameterData = {
					name,
					value: newValue
				};
			} else parameterData = {
				name,
				value: "default" in option$1 ? deepCopy(option$1.default) : null
			};
			emit("valueChanged", parameterData);
			selectedOption.value = void 0;
		}
		function valueChanged(parameterData) {
			emit("valueChanged", parameterData);
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: "collection-parameter",
				onKeydown: _cache[2] || (_cache[2] = withModifiers(() => {}, ["stop"]))
			}, [createBaseVNode("div", _hoisted_1$6, [
				getProperties.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_2$4, [createVNode(unref(N8nText_default), { size: "small" }, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("collectionParameter.noProperties")), 1)]),
					_: 1
				})])) : createCommentVNode("", true),
				(openBlock(), createBlock(Suspense, null, {
					default: withCtx(() => [createVNode(ParameterInputList_default, {
						parameters: getProperties.value,
						"node-values": _ctx.nodeValues,
						path: _ctx.path,
						"hide-delete": _ctx.hideDelete,
						indent: true,
						"is-read-only": _ctx.isReadOnly,
						onValueChanged: valueChanged
					}, null, 8, [
						"parameters",
						"node-values",
						"path",
						"hide-delete",
						"is-read-only"
					])]),
					_: 1
				})),
				parameterOptions.value.length > 0 && !_ctx.isReadOnly ? (openBlock(), createElementBlock("div", _hoisted_3$4, [(_ctx.parameter.options ?? []).length === 1 ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 0,
					type: "tertiary",
					block: "",
					label: getPlaceholderText.value,
					onClick: _cache[0] || (_cache[0] = ($event) => optionSelected((_ctx.parameter.options ?? [])[0].name))
				}, null, 8, ["label"])) : (openBlock(), createElementBlock("div", _hoisted_4$3, [createVNode(unref(N8nSelect_default), {
					modelValue: selectedOption.value,
					"onUpdate:modelValue": [_cache[1] || (_cache[1] = ($event) => selectedOption.value = $event), optionSelected],
					placeholder: getPlaceholderText.value,
					size: "small",
					filterable: ""
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(parameterOptions.value, (item$2) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: item$2.name,
							label: getParameterOptionLabel(item$2),
							value: item$2.name,
							"data-test-id": "collection-parameter-option"
						}, null, 8, ["label", "value"]);
					}), 128))]),
					_: 1
				}, 8, ["modelValue", "placeholder"])]))])) : createCommentVNode("", true)
			])], 32);
		};
	}
});
var import_get$1 = /* @__PURE__ */ __toESM(require_get());
var _hoisted_1$5 = {
	key: 0,
	class: "delete-item clickable"
};
var _hoisted_2$3 = { key: 0 };
var _hoisted_3$3 = { key: 1 };
var _hoisted_4$2 = { key: 2 };
var _hoisted_5$2 = { class: "add-item-wrapper" };
var _hoisted_6$1 = {
	key: 0,
	class: "no-items-exist"
};
var MultipleParameter_default = /* @__PURE__ */ __plugin_vue_export_helper_default(/* @__PURE__ */ defineComponent({
	name: "MultipleParameter",
	__name: "MultipleParameter",
	props: {
		nodeValues: {},
		parameter: {},
		path: {},
		values: { default: () => [] },
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["valueChanged"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const ndvStore = useNDVStore();
		const i18n$1 = useI18n();
		const { activeNode } = storeToRefs(ndvStore);
		const mutableValues = ref(deepCopy(props.values));
		watch(() => props.values, (newValues) => {
			mutableValues.value = deepCopy(newValues);
		}, { deep: true });
		const addButtonText = computed(() => {
			if (!props.parameter.typeOptions?.multipleValueButtonText) return i18n$1.baseText("multipleParameter.addItem");
			return i18n$1.nodeText(activeNode.value?.type).multipleValueButtonText(props.parameter);
		});
		const hideDelete = computed(() => props.parameter.options?.length === 1);
		const sortable = computed(() => !!props.parameter.typeOptions?.sortable);
		const addItem = () => {
			const name = getPath();
			const currentValue = (0, import_get$1.default)(props.nodeValues, name, []);
			currentValue.push(deepCopy(props.parameter.default));
			emit("valueChanged", {
				name,
				value: currentValue
			});
		};
		const deleteItem = (index$1) => {
			emit("valueChanged", {
				name: getPath(index$1),
				value: void 0
			});
		};
		const getPath = (index$1) => {
			return props.path + (index$1 !== void 0 ? `[${index$1}]` : "");
		};
		const moveOptionDown = (index$1) => {
			mutableValues.value.splice(index$1 + 1, 0, mutableValues.value.splice(index$1, 1)[0]);
			emit("valueChanged", {
				name: props.path,
				value: mutableValues.value
			});
		};
		const moveOptionUp = (index$1) => {
			mutableValues.value.splice(index$1 - 1, 0, mutableValues.value.splice(index$1, 1)[0]);
			emit("valueChanged", {
				name: props.path,
				value: mutableValues.value
			});
		};
		const valueChanged = (parameterData) => {
			emit("valueChanged", parameterData);
		};
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", {
				class: "duplicate-parameter",
				onKeydown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
			}, [
				createVNode(unref(N8nInputLabel_default), {
					label: unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(_ctx.parameter, _ctx.path),
					"tooltip-text": unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDescription(_ctx.parameter, _ctx.path),
					underline: true,
					size: "small",
					color: "text-dark"
				}, null, 8, ["label", "tooltip-text"]),
				(openBlock(true), createElementBlock(Fragment, null, renderList(mutableValues.value, (value$1, index$1) => {
					return openBlock(), createElementBlock("div", {
						key: index$1,
						class: normalizeClass(["duplicate-parameter-item", _ctx.parameter.type])
					}, [!_ctx.isReadOnly ? (openBlock(), createElementBlock("div", _hoisted_1$5, [createVNode(unref(N8nIcon_default), {
						icon: "trash-2",
						title: unref(i18n$1).baseText("multipleParameter.deleteItem"),
						onClick: ($event) => deleteItem(index$1)
					}, null, 8, ["title", "onClick"]), sortable.value ? (openBlock(), createElementBlock("div", _hoisted_2$3, [index$1 !== 0 ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 0,
						icon: "chevron-up",
						class: "clickable",
						title: unref(i18n$1).baseText("multipleParameter.moveUp"),
						onClick: ($event) => moveOptionUp(index$1)
					}, null, 8, ["title", "onClick"])) : createCommentVNode("", true), index$1 !== mutableValues.value.length - 1 ? (openBlock(), createBlock(unref(N8nIcon_default), {
						key: 1,
						icon: "chevron-down",
						class: "clickable",
						title: unref(i18n$1).baseText("multipleParameter.moveDown"),
						onClick: ($event) => moveOptionDown(index$1)
					}, null, 8, ["title", "onClick"])) : createCommentVNode("", true)])) : createCommentVNode("", true)])) : createCommentVNode("", true), _ctx.parameter.type === "collection" ? (openBlock(), createElementBlock("div", _hoisted_3$3, [createVNode(CollectionParameter_default, {
						parameter: _ctx.parameter,
						values: value$1,
						"node-values": _ctx.nodeValues,
						path: getPath(index$1),
						"hide-delete": hideDelete.value,
						"is-read-only": _ctx.isReadOnly,
						onValueChanged: valueChanged
					}, null, 8, [
						"parameter",
						"values",
						"node-values",
						"path",
						"hide-delete",
						"is-read-only"
					])])) : (openBlock(), createElementBlock("div", _hoisted_4$2, [createVNode(ParameterInputFull_default, {
						class: "duplicate-parameter-input-item",
						parameter: _ctx.parameter,
						value: value$1,
						"display-options": true,
						"hide-label": true,
						path: getPath(index$1),
						"input-size": "small",
						"is-read-only": _ctx.isReadOnly,
						onUpdate: valueChanged
					}, null, 8, [
						"parameter",
						"value",
						"path",
						"is-read-only"
					])]))], 2);
				}), 128)),
				createBaseVNode("div", _hoisted_5$2, [mutableValues.value && mutableValues.value.length === 0 || _ctx.isReadOnly ? (openBlock(), createElementBlock("div", _hoisted_6$1, [createVNode(unref(N8nText_default), { size: "small" }, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("multipleParameter.currentlyNoItemsExist")), 1)]),
					_: 1
				})])) : createCommentVNode("", true), !_ctx.isReadOnly ? (openBlock(), createBlock(unref(N8nButton_default), {
					key: 1,
					type: "tertiary",
					block: "",
					label: addButtonText.value,
					onClick: _cache[0] || (_cache[0] = ($event) => addItem())
				}, null, 8, ["label"])) : createCommentVNode("", true)])
			], 32);
		};
	}
}), [["__scopeId", "data-v-ed9cd59b"]]);
function useNodeSpecificationValues(typeOptions) {
	const resourceMapperTypeOptions = computed(() => {
		return typeOptions?.resourceMapper;
	});
	const singularFieldWord = computed(() => {
		return resourceMapperTypeOptions.value?.fieldWords?.singular || i18n.baseText("generic.field");
	});
	const singularFieldWordCapitalized = computed(() => {
		return singularFieldWord.value.charAt(0).toUpperCase() + singularFieldWord.value.slice(1);
	});
	const pluralFieldWord = computed(() => {
		return resourceMapperTypeOptions.value?.fieldWords?.plural || i18n.baseText("generic.fields");
	});
	return {
		resourceMapperTypeOptions,
		singularFieldWord,
		singularFieldWordCapitalized,
		pluralFieldWord,
		pluralFieldWordCapitalized: computed(() => {
			return pluralFieldWord.value.charAt(0).toUpperCase() + pluralFieldWord.value.slice(1);
		})
	};
}
var _hoisted_1$4 = { "data-test-id": "mapping-mode-select" };
var _hoisted_2$2 = { class: "mt-5xs" };
var _hoisted_3$2 = { class: "list-option" };
var _hoisted_4$1 = { class: "option-headline" };
var _hoisted_5$1 = { class: "option-description" };
var _hoisted_6 = { class: "mt-5xs" };
var MappingModeSelect_default = /* @__PURE__ */ defineComponent({
	__name: "MappingModeSelect",
	props: {
		initialValue: {},
		fieldsToMap: {},
		inputSize: {},
		labelSize: {},
		typeOptions: {},
		serviceName: {},
		loading: { type: Boolean },
		loadingError: { type: Boolean },
		teleported: { type: Boolean },
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["modeChanged", "retryFetch"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const { resourceMapperTypeOptions, pluralFieldWord, singularFieldWord } = useNodeSpecificationValues(props.typeOptions);
		const mappingModeOptions = [{
			name: i18n.baseText("resourceMapper.mappingMode.defineBelow.name"),
			value: "defineBelow",
			description: i18n.baseText("resourceMapper.mappingMode.defineBelow.description", { interpolate: { fieldWord: singularFieldWord.value } })
		}, {
			name: i18n.baseText("resourceMapper.mappingMode.autoMapInputData.name"),
			value: "autoMapInputData",
			description: i18n.baseText("resourceMapper.mappingMode.autoMapInputData.description", { interpolate: {
				fieldWord: pluralFieldWord.value,
				serviceName: props.serviceName
			} })
		}];
		const emit = __emit;
		const selected$1 = ref(props.initialValue);
		watch(() => props.initialValue, () => {
			selected$1.value = props.initialValue;
		});
		const errorMessage = computed(() => {
			if (selected$1.value === "defineBelow") {
				if (props.loadingError) return i18n.baseText("resourceMapper.fetchingFields.errorMessage", { interpolate: { fieldWord: pluralFieldWord.value } });
				if (props.fieldsToMap.length === 0 && !props.typeOptions?.resourceMapper?.hideNoDataError) return resourceMapperTypeOptions.value?.noFieldsError || i18n.baseText("resourceMapper.fetchingFields.noFieldsFound", { interpolate: {
					fieldWord: pluralFieldWord.value,
					serviceName: props.serviceName
				} });
				return "";
			}
			return "";
		});
		function onModeChanged(value$1) {
			selected$1.value = value$1;
			emit("modeChanged", value$1);
		}
		function onRetryClick() {
			emit("retryFetch");
		}
		__expose({
			selected: selected$1,
			onModeChanged,
			mappingModeOptions
		});
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", _hoisted_1$4, [createVNode(unref(N8nInputLabel_default), {
				label: unref(i18n).baseText("resourceMapper.mappingMode.label"),
				bold: false,
				required: false,
				size: _ctx.labelSize,
				color: "text-dark"
			}, {
				default: withCtx(() => [createBaseVNode("div", _hoisted_2$2, [createVNode(unref(N8nSelect_default), {
					"model-value": selected$1.value,
					teleported: _ctx.teleported,
					size: props.inputSize,
					disabled: _ctx.isReadOnly,
					"onUpdate:modelValue": onModeChanged
				}, {
					default: withCtx(() => [(openBlock(), createElementBlock(Fragment, null, renderList(mappingModeOptions, (option$1) => {
						return createVNode(unref(N8nOption_default), {
							key: option$1.value,
							value: option$1.value,
							label: option$1.name,
							description: "sadasd"
						}, {
							default: withCtx(() => [createBaseVNode("div", _hoisted_3$2, [createBaseVNode("div", _hoisted_4$1, toDisplayString(option$1.name), 1), withDirectives(createBaseVNode("div", _hoisted_5$1, null, 512), [[_directive_n8n_html, option$1.description]])])]),
							_: 2
						}, 1032, ["value", "label"]);
					}), 64))]),
					_: 1
				}, 8, [
					"model-value",
					"teleported",
					"size",
					"disabled"
				])]), createBaseVNode("div", _hoisted_6, [_ctx.loading ? (openBlock(), createBlock(unref(N8nText_default), {
					key: 0,
					size: "small"
				}, {
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						icon: "refresh-cw",
						size: "xsmall",
						spin: true
					}), createTextVNode(" " + toDisplayString(unref(i18n).baseText("resourceMapper.fetchingFields.message", { interpolate: { fieldWord: unref(pluralFieldWord) } })), 1)]),
					_: 1
				})) : errorMessage.value !== "" ? (openBlock(), createBlock(unref(N8nText_default), {
					key: 1,
					size: "small",
					color: "danger"
				}, {
					default: withCtx(() => [
						createVNode(unref(N8nIcon_default), {
							icon: "triangle-alert",
							size: "xsmall"
						}),
						createTextVNode(" " + toDisplayString(errorMessage.value) + " ", 1),
						createVNode(unref(N8nLink_default), {
							size: "small",
							theme: "danger",
							underline: true,
							onClick: onRetryClick
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("generic.retry")), 1)]),
							_: 1
						})
					]),
					_: 1
				})) : createCommentVNode("", true)])]),
				_: 1
			}, 8, ["label", "size"])]);
		};
	}
});
var _hoisted_1$3 = {
	class: "mt-2xs",
	"data-test-id": "matching-column-select"
};
var MatchingColumnsSelect_default = /* @__PURE__ */ defineComponent({
	__name: "MatchingColumnsSelect",
	props: {
		parameter: {},
		initialValue: {},
		fieldsToMap: {},
		typeOptions: {},
		labelSize: {},
		inputSize: {},
		loading: { type: Boolean },
		serviceName: {},
		refreshInProgress: { type: Boolean },
		teleported: {
			type: Boolean,
			default: true
		},
		isReadOnly: {
			type: Boolean,
			default: false
		}
	},
	emits: ["matchingColumnsChanged", "refreshFieldList"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const { resourceMapperTypeOptions, singularFieldWord, singularFieldWordCapitalized, pluralFieldWord, pluralFieldWordCapitalized } = useNodeSpecificationValues(props.typeOptions);
		const initialValue = computed(() => {
			return resourceMapperTypeOptions.value?.multiKeyMatch === true ? props.initialValue : props.initialValue[0];
		});
		const state = reactive({ selected: initialValue.value });
		watch(() => props.initialValue, () => {
			state.selected = initialValue.value;
		});
		const emit = __emit;
		const availableMatchingFields = computed(() => {
			return props.fieldsToMap.filter((field) => {
				return (field.canBeUsedToMatch || field.defaultMatch) && field.display;
			});
		});
		const fieldLabel = computed(() => {
			if (resourceMapperTypeOptions.value?.matchingFieldsLabels?.title) return resourceMapperTypeOptions.value.matchingFieldsLabels.title;
			const fieldWord = resourceMapperTypeOptions.value?.multiKeyMatch === true ? pluralFieldWordCapitalized.value : singularFieldWordCapitalized.value;
			return i18n.baseText("resourceMapper.columnsToMatchOn.label", { interpolate: { fieldWord } });
		});
		const fieldDescription = computed(() => {
			if (resourceMapperTypeOptions.value?.matchingFieldsLabels?.hint) return resourceMapperTypeOptions.value.matchingFieldsLabels.hint;
			const labeli18nKey = resourceMapperTypeOptions.value?.multiKeyMatch === true ? "resourceMapper.columnsToMatchOn.multi.description" : "resourceMapper.columnsToMatchOn.single.description";
			return i18n.baseText(labeli18nKey, { interpolate: {
				fieldWord: resourceMapperTypeOptions.value?.multiKeyMatch === true ? `${pluralFieldWord.value}` : `${singularFieldWord.value}`,
				nodeDisplayName: props.serviceName
			} });
		});
		const fieldTooltip = computed(() => {
			if (resourceMapperTypeOptions.value?.matchingFieldsLabels?.description) return resourceMapperTypeOptions.value.matchingFieldsLabels.description;
			return i18n.baseText("resourceMapper.columnsToMatchOn.tooltip", { interpolate: { fieldWord: resourceMapperTypeOptions.value?.multiKeyMatch === true ? `${pluralFieldWord.value}` : `${singularFieldWord.value}` } });
		});
		const parameterActions = computed(() => {
			return [{
				label: i18n.baseText("resourceMapper.refreshFieldList", { interpolate: { fieldWord: singularFieldWordCapitalized.value } }),
				value: "refreshFieldList"
			}];
		});
		const fetchingFieldsLabel = computed(() => {
			return i18n.baseText("resourceMapper.fetchingFields.message", { interpolate: { fieldWord: pluralFieldWord.value } });
		});
		function onSelectionChange(value$1) {
			if (resourceMapperTypeOptions.value?.multiKeyMatch === true) state.selected = value$1;
			else state.selected = value$1;
			emitValueChanged();
		}
		function emitValueChanged() {
			if (state.selected) emit("matchingColumnsChanged", Array.isArray(state.selected) ? state.selected : [state.selected]);
		}
		function onParameterActionSelected(action) {
			switch (action) {
				case "refreshFieldList":
					emit("refreshFieldList");
					break;
				default: break;
			}
		}
		__expose({ state });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", _hoisted_1$3, [availableMatchingFields.value.length > 0 ? (openBlock(), createBlock(unref(N8nInputLabel_default), {
				key: 0,
				label: fieldLabel.value,
				"tooltip-text": fieldTooltip.value,
				bold: false,
				required: false,
				size: _ctx.labelSize,
				color: "text-dark"
			}, {
				options: withCtx(() => [createVNode(ParameterOptions_default, {
					parameter: _ctx.parameter,
					"custom-actions": parameterActions.value,
					loading: props.refreshInProgress,
					"loading-message": fetchingFieldsLabel.value,
					"is-read-only": _ctx.isReadOnly,
					value: state.selected,
					"onUpdate:modelValue": onParameterActionSelected
				}, null, 8, [
					"parameter",
					"custom-actions",
					"loading",
					"loading-message",
					"is-read-only",
					"value"
				])]),
				default: withCtx(() => [createVNode(unref(N8nSelect_default), {
					multiple: unref(resourceMapperTypeOptions)?.multiKeyMatch === true,
					"model-value": state.selected,
					size: props.inputSize,
					disabled: _ctx.loading || _ctx.isReadOnly,
					teleported: _ctx.teleported,
					"onUpdate:modelValue": onSelectionChange
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(availableMatchingFields.value, (field) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: field.id,
							value: field.id,
							"data-test-id": `matching-column-option-${field.id}`
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(field.displayName), 1)]),
							_: 2
						}, 1032, ["value", "data-test-id"]);
					}), 128))]),
					_: 1
				}, 8, [
					"multiple",
					"model-value",
					"size",
					"disabled",
					"teleported"
				]), createVNode(unref(N8nText_default), { size: "small" }, {
					default: withCtx(() => [createTextVNode(toDisplayString(fieldDescription.value), 1)]),
					_: 1
				})]),
				_: 1
			}, 8, [
				"label",
				"tooltip-text",
				"size"
			])) : (openBlock(), createBlock(unref(N8nNotice_default), { key: 1 }, {
				default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("resourceMapper.columnsToMatchOn.noFieldsFound", { interpolate: {
					fieldWord: unref(singularFieldWord),
					serviceName: props.serviceName
				} })), 1)]),
				_: 1
			}))]);
		};
	}
});
var _hoisted_1$2 = {
	class: "mt-xs",
	"data-test-id": "mapping-fields-container"
};
var _hoisted_2$1 = {
	key: 0,
	class: "mt-3xs mb-xs"
};
var _hoisted_3$1 = {
	key: 1,
	class: /* @__PURE__ */ normalizeClass(["delete-option", "mt-5xs"])
};
var MappingFields_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MappingFields",
	props: {
		parameter: {},
		path: {},
		nodeValues: {},
		fieldsToMap: {},
		paramValue: {},
		labelSize: {},
		showMatchingColumnsSelector: { type: Boolean },
		showMappingModeSelect: { type: Boolean },
		loading: { type: Boolean },
		refreshInProgress: { type: Boolean },
		teleported: {
			type: Boolean,
			default: true
		},
		isReadOnly: {
			type: Boolean,
			default: false
		},
		isDataStale: {
			type: Boolean,
			default: false
		}
	},
	emits: [
		"fieldValueChanged",
		"removeField",
		"addField",
		"refreshFieldList"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const FORCE_TEXT_INPUT_FOR_TYPES = [
			"time",
			"object",
			"array"
		];
		const { resourceMapperTypeOptions, singularFieldWord, singularFieldWordCapitalized, pluralFieldWord, pluralFieldWordCapitalized } = useNodeSpecificationValues(props.parameter.typeOptions);
		const i18n$1 = useI18n();
		const emit = __emit;
		const ndvStore = useNDVStore();
		function markAsReadOnly(field) {
			if (isMatchingField(field.id, props.paramValue.matchingColumns, props.showMatchingColumnsSelector)) return false;
			return field.readOnly || false;
		}
		const fieldsUi = computed(() => {
			return props.fieldsToMap.filter((field) => field.display && field.removed !== true).map((field) => {
				return {
					displayName: getFieldLabel(field),
					name: `value["${field.id}"]`,
					type: getParamType(field),
					default: field.type === "boolean" ? false : "",
					required: field.required,
					description: getFieldDescription(field),
					options: field.options,
					readOnly: markAsReadOnly(field)
				};
			});
		});
		const orderedFields = computed(() => {
			if (props.paramValue.matchingColumns) fieldsUi.value.forEach((field, i) => {
				const fieldName = field.name && parseResourceMapperFieldName(field.name);
				if (fieldName) {
					if (props.paramValue.matchingColumns.includes(fieldName)) {
						fieldsUi.value.splice(i, 1);
						fieldsUi.value.unshift(field);
					}
				}
			});
			return fieldsUi.value;
		});
		const removedFields = computed(() => {
			return props.fieldsToMap.filter((field) => field.removed === true && field.display);
		});
		const addFieldOptions = computed(() => {
			return removedFields.value.map((field) => {
				return {
					name: field.displayName,
					value: field.id,
					disabled: false
				};
			});
		});
		const parameterActions = computed(() => {
			return [
				{
					label: i18n.baseText("resourceMapper.refreshFieldList", { interpolate: { fieldWord: singularFieldWordCapitalized.value } }),
					value: "refreshFieldList"
				},
				{
					label: i18n.baseText("resourceMapper.addAllFields", { interpolate: { fieldWord: pluralFieldWordCapitalized.value } }),
					value: "addAllFields",
					disabled: removedFields.value.length === 0
				},
				{
					label: i18n.baseText("resourceMapper.removeAllFields", { interpolate: { fieldWord: pluralFieldWordCapitalized.value } }),
					value: "removeAllFields",
					disabled: !isRemoveAllAvailable.value
				}
			];
		});
		const isRemoveAllAvailable = computed(() => {
			return removedFields.value.length !== props.fieldsToMap.length && props.fieldsToMap.some((field) => {
				return field.removed !== true && !fieldCannotBeDeleted(field, props.showMatchingColumnsSelector, resourceMapperMode.value, props.paramValue.matchingColumns);
			});
		});
		const resourceMapperMode = computed(() => {
			return resourceMapperTypeOptions.value?.mode;
		});
		const resourceMapperValuesLabel = computed(() => {
			return resourceMapperTypeOptions.value?.valuesLabel;
		});
		const valuesLabel = computed(() => {
			if (resourceMapperValuesLabel.value) return resourceMapperValuesLabel.value;
			if (resourceMapperMode.value && resourceMapperMode.value === "update") return i18n.baseText("resourceMapper.valuesToUpdate.label");
			return i18n.baseText("resourceMapper.valuesToSend.label");
		});
		const fetchingFieldsLabel = computed(() => {
			return i18n.baseText("resourceMapper.fetchingFields.message", { interpolate: { fieldWord: pluralFieldWord.value } });
		});
		function getFieldLabel(field) {
			if (isMatchingField(field.id, props.paramValue.matchingColumns, props.showMatchingColumnsSelector)) {
				const suffix = i18n.baseText("resourceMapper.usingToMatch") || "";
				return `${field.displayName} ${suffix}`;
			}
			return field.displayName;
		}
		function getFieldDescription(field) {
			if (isMatchingField(field.id, props.paramValue.matchingColumns, props.showMatchingColumnsSelector)) return i18n.baseText("resourceMapper.usingToMatch.description", { interpolate: { fieldWord: singularFieldWord.value } }) || "";
			return "";
		}
		function getParameterValue(parameterName) {
			const fieldName = parseResourceMapperFieldName(parameterName);
			if (fieldName && props.paramValue.value) {
				if (props.paramValue.value[fieldName] === void 0 || props.paramValue.value[fieldName] === null) return "";
				return props.paramValue.value[fieldName];
			}
			return null;
		}
		function getFieldIssues(field) {
			if (!ndvStore.activeNode) return [];
			const nodeIssues = ndvStore.activeNode.issues || {};
			const fieldName = parseResourceMapperFieldName(field.name);
			if (!fieldName) return [];
			let fieldIssues = [];
			const key = `${props.parameter.name}.${fieldName}`;
			if (nodeIssues.parameters && key in nodeIssues.parameters) fieldIssues = fieldIssues.concat(nodeIssues.parameters[key]);
			return fieldIssues;
		}
		function getParamType(field) {
			if (field.type && !FORCE_TEXT_INPUT_FOR_TYPES.includes(field.type)) return field.type;
			return "string";
		}
		function getParsedFieldName(fullName) {
			return parseResourceMapperFieldName(fullName) ?? fullName;
		}
		function onValueChanged(value$1) {
			emit("fieldValueChanged", value$1);
		}
		function removeField(fieldName) {
			emit("removeField", fieldName);
		}
		function addField(fieldName) {
			emit("addField", fieldName);
		}
		function onParameterActionSelected(action) {
			switch (action) {
				case "addAllFields":
					emit("addField", action);
					break;
				case "removeAllFields":
					emit("removeField", action);
					break;
				case "refreshFieldList":
					emit("refreshFieldList");
					break;
				default: break;
			}
		}
		__expose({ orderedFields });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("div", _hoisted_1$2, [
				createVNode(unref(N8nInputLabel_default), {
					label: valuesLabel.value,
					underline: true,
					size: _ctx.labelSize,
					"show-options": true,
					"show-expression-selector": false,
					"input-name": "columns",
					color: "text-dark"
				}, {
					options: withCtx(() => [props.isDataStale && !props.refreshInProgress ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(_ctx.$style.staleDataWarning)
					}, [createVNode(unref(N8nTooltip_default), null, {
						content: withCtx(() => [createBaseVNode("span", null, toDisplayString(unref(i18n).baseText("resourceMapper.staleDataWarning.tooltip", { interpolate: { fieldWord: unref(pluralFieldWordCapitalized) } })), 1)]),
						default: withCtx(() => [createVNode(unref(N8nIcon_default), {
							icon: "triangle-alert",
							size: "small",
							color: "warning"
						})]),
						_: 1
					}), createVNode(unref(N8nIconButton_default), {
						icon: "refresh-cw",
						type: "tertiary",
						size: "small",
						text: true,
						title: unref(i18n).baseText("generic.refresh"),
						disabled: props.refreshInProgress,
						onClick: _cache[0] || (_cache[0] = ($event) => onParameterActionSelected("refreshFieldList"))
					}, null, 8, ["title", "disabled"])], 2)) : createCommentVNode("", true), createVNode(ParameterOptions_default, {
						parameter: _ctx.parameter,
						"custom-actions": parameterActions.value,
						loading: props.refreshInProgress,
						"loading-message": fetchingFieldsLabel.value,
						"is-read-only": _ctx.isReadOnly,
						value: props.paramValue,
						"onUpdate:modelValue": onParameterActionSelected
					}, null, 8, [
						"parameter",
						"custom-actions",
						"loading",
						"loading-message",
						"is-read-only",
						"value"
					])]),
					_: 1
				}, 8, ["label", "size"]),
				orderedFields.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_2$1, [createVNode(unref(N8nText_default), { size: "small" }, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n$1).baseText("fixedCollectionParameter.currentlyNoItemsExist")), 1)]),
					_: 1
				})])) : createCommentVNode("", true),
				(openBlock(true), createElementBlock(Fragment, null, renderList(orderedFields.value, (field) => {
					return openBlock(), createElementBlock("div", {
						key: field.name,
						class: normalizeClass({
							["parameter-item"]: true,
							[_ctx.$style.parameterItem]: true,
							[_ctx.$style.hasIssues]: getFieldIssues(field).length > 0
						})
					}, [
						resourceMapperMode.value === "add" && field.required ? (openBlock(), createElementBlock("div", {
							key: 0,
							class: normalizeClass([
								"delete-option",
								"mt-2xs",
								_ctx.$style.parameterTooltipIcon
							])
						}, [createVNode(unref(N8nTooltip_default), { placement: "top" }, {
							content: withCtx(() => [createBaseVNode("span", null, toDisplayString(unref(i18n).baseText("resourceMapper.mandatoryField.title", { interpolate: { fieldWord: unref(singularFieldWord) } })), 1)]),
							default: withCtx(() => [createVNode(unref(N8nIcon_default), { icon: "circle-help" })]),
							_: 1
						})], 2)) : !unref(isMatchingField)(field.name, props.paramValue.matchingColumns, props.showMatchingColumnsSelector) ? (openBlock(), createElementBlock("div", _hoisted_3$1, [createVNode(unref(N8nIconButton_default), {
							type: "tertiary",
							text: "",
							size: "small",
							icon: "trash-2",
							"data-test-id": `remove-field-button-${getParsedFieldName(field.name)}`,
							title: unref(i18n).baseText("resourceMapper.removeField", { interpolate: { fieldWord: unref(singularFieldWord) } }),
							disabled: _ctx.isReadOnly,
							onClick: ($event) => removeField(field.name)
						}, null, 8, [
							"data-test-id",
							"title",
							"disabled",
							"onClick"
						])])) : createCommentVNode("", true),
						createBaseVNode("div", { class: normalizeClass(_ctx.$style.parameterInput) }, [createVNode(ParameterInputFull_default, {
							parameter: field,
							value: getParameterValue(field.name),
							"display-options": true,
							path: `${props.path}.${field.name}`,
							"is-read-only": _ctx.refreshInProgress || field.readOnly || _ctx.isReadOnly,
							"hide-issues": true,
							"node-values": _ctx.nodeValues,
							class: normalizeClass(_ctx.$style.parameterInputFull),
							onUpdate: onValueChanged
						}, null, 8, [
							"parameter",
							"value",
							"path",
							"is-read-only",
							"node-values",
							"class"
						])], 2),
						getFieldIssues(field).length > 0 ? (openBlock(), createBlock(ParameterIssues_default, {
							key: 2,
							issues: getFieldIssues(field),
							class: normalizeClass([_ctx.$style.parameterIssues, "ml-5xs"])
						}, null, 8, ["issues", "class"])) : createCommentVNode("", true)
					], 2);
				}), 128)),
				createBaseVNode("div", {
					class: normalizeClass(["add-option", _ctx.$style.addOption]),
					"data-test-id": "add-fields-select"
				}, [createVNode(unref(N8nSelect_default), {
					placeholder: unref(i18n).baseText("resourceMapper.addFieldToSend", { interpolate: { fieldWord: unref(singularFieldWord) } }),
					size: "small",
					teleported: _ctx.teleported,
					disabled: addFieldOptions.value.length == 0 || _ctx.isReadOnly,
					"onUpdate:modelValue": addField
				}, {
					default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(addFieldOptions.value, (item$2) => {
						return openBlock(), createBlock(unref(N8nOption_default), {
							key: item$2.value,
							label: item$2.name,
							value: item$2.value,
							disabled: item$2.disabled
						}, null, 8, [
							"label",
							"value",
							"disabled"
						]);
					}), 128))]),
					_: 1
				}, 8, [
					"placeholder",
					"teleported",
					"disabled"
				])], 2)
			]);
		};
	}
});
var MappingFields_vue_vue_type_style_index_0_lang_module_default = {
	parameterItem: "_parameterItem_1cwhk_123",
	parameterInput: "_parameterInput_1cwhk_128",
	hasIssues: "_hasIssues_1cwhk_134",
	parameterIssues: "_parameterIssues_1cwhk_134",
	parameterTooltipIcon: "_parameterTooltipIcon_1cwhk_144",
	addOption: "_addOption_1cwhk_151",
	staleDataWarning: "_staleDataWarning_1cwhk_156"
};
var MappingFields_default = /* @__PURE__ */ __plugin_vue_export_helper_default(MappingFields_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": MappingFields_vue_vue_type_style_index_0_lang_module_default }]]);
var import_isEqual = /* @__PURE__ */ __toESM(require_isEqual());
var _hoisted_1$1 = {
	class: "mt-4xs",
	"data-test-id": "resource-mapper-container"
};
var ResourceMapper_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ResourceMapper",
	props: {
		parameter: {},
		node: {},
		path: {},
		inputSize: {},
		labelSize: {},
		teleported: {
			type: Boolean,
			default: true
		},
		dependentParametersValues: { default: null },
		isReadOnly: {
			type: Boolean,
			default: false
		},
		allowEmptyStrings: {
			type: Boolean,
			default: false
		}
	},
	emits: ["valueChanged"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const nodeTypesStore = useNodeTypesStore();
		const ndvStore = useNDVStore();
		const workflowsStore = useWorkflowsStore();
		const projectsStore = useProjectsStore();
		const props = __props;
		const { onDocumentVisible } = useDocumentVisibility();
		const emit = __emit;
		const state = reactive({
			paramValue: {
				mappingMode: "defineBelow",
				value: {},
				matchingColumns: [],
				schema: [],
				attemptToConvertTypes: false,
				convertFieldsToString: false
			},
			parameterValues: {},
			loading: false,
			refreshInProgress: false,
			loadingError: false,
			hasStaleFields: false,
			emptyFieldsNotice: ""
		});
		watch(() => props.dependentParametersValues, async (currentValue, oldValue) => {
			if (oldValue !== null && currentValue !== null && oldValue !== currentValue) {
				state.paramValue = {
					...state.paramValue,
					value: null,
					schema: []
				};
				emitValueChanged();
				await initFetching();
				setDefaultFieldValues(true);
			}
		});
		onDocumentVisible(async () => {
			await checkStaleFields();
		});
		async function checkStaleFields() {
			const fetchedFields = await fetchFields();
			if (fetchedFields) state.hasStaleFields = isResourceMapperFieldListStale(state.paramValue.schema, fetchedFields.fields);
		}
		watch(() => workflowsStore.getWorkflowExecution, async (data) => {
			if (data && isFullExecutionResponse(data) && data.status === "success" && state.paramValue.mappingMode === "autoMapInputData") await initFetching(true);
		});
		onMounted(async () => {
			if (props.node) {
				state.parameterValues = {
					...state.parameterValues,
					parameters: props.node.parameters
				};
				if (showTypeConversionOptions.value) state.paramValue.convertFieldsToString = true;
			}
			const params = state.parameterValues.parameters;
			const parameterName = props.parameter.name;
			if (!(parameterName in params)) return;
			let hasSchema = false;
			const nodeValues = params[parameterName];
			state.paramValue = {
				...state.paramValue,
				...nodeValues
			};
			if (!state.paramValue.schema) state.paramValue = {
				...state.paramValue,
				schema: []
			};
			else hasSchema = state.paramValue.schema.length > 0;
			Object.keys(state.paramValue.value || {}).forEach((key) => {
				if (state.paramValue.value && state.paramValue.value[key] === "") state.paramValue = {
					...state.paramValue,
					value: {
						...state.paramValue.value,
						[key]: null
					}
				};
			});
			if (nodeValues.matchingColumns) state.paramValue = {
				...state.paramValue,
				matchingColumns: nodeValues.matchingColumns
			};
			if (!hasSchema) await initFetching();
			else await checkStaleFields();
			if (!state.paramValue.value) setDefaultFieldValues();
			updateNodeIssues();
		});
		const resourceMapperMode = computed(() => {
			return props.parameter.typeOptions?.resourceMapper?.mode;
		});
		const nodeType = computed(() => {
			if (props.node) return nodeTypesStore.getNodeType(props.node.type, props.node.typeVersion);
			return null;
		});
		const showMappingModeSelect = computed(() => {
			return props.parameter.typeOptions?.resourceMapper?.supportAutoMap !== false;
		});
		const showTypeConversionOptions = computed(() => {
			return props.parameter.typeOptions?.resourceMapper?.showTypeConversionOptions === true;
		});
		const hasFields = computed(() => {
			return state.paramValue.schema.length > 0;
		});
		const showMatchingColumnsSelector = computed(() => {
			return !state.loading && ["upsert", "update"].includes(props.parameter.typeOptions?.resourceMapper?.mode ?? "") && hasFields.value;
		});
		const showMappingFields = computed(() => {
			return state.paramValue.mappingMode === "defineBelow" && !state.loading && !state.loadingError && hasFields.value && hasAvailableMatchingColumns.value;
		});
		const matchingColumns = computed(() => {
			if (!showMatchingColumnsSelector.value) return [];
			if (state.paramValue.matchingColumns) return state.paramValue.matchingColumns;
			return defaultSelectedMatchingColumns.value;
		});
		const hasAvailableMatchingColumns = computed(() => {
			if (resourceMapperMode.value === "map") return true;
			if (resourceMapperMode.value !== "add" && resourceMapperMode.value !== "upsert") return state.paramValue.schema.filter((field) => (field.canBeUsedToMatch || field.defaultMatch) && field.display && field.removed !== true).length > 0;
			return true;
		});
		const defaultSelectedMatchingColumns = computed(() => {
			return state.paramValue.schema.length === 1 ? [state.paramValue.schema[0].id] : state.paramValue.schema.reduce((acc, field) => {
				if (field.defaultMatch) acc.push(field.id);
				return acc;
			}, []);
		});
		const pluralFieldWord = computed(() => {
			return props.parameter.typeOptions?.resourceMapper?.fieldWords?.plural || i18n.baseText("generic.fields");
		});
		async function initFetching(inlineLoading = false) {
			state.loadingError = false;
			if (inlineLoading) state.refreshInProgress = true;
			else state.loading = true;
			try {
				await loadAndSetFieldsToMap();
				if (!state.paramValue.matchingColumns || state.paramValue.matchingColumns.length === 0) onMatchingColumnsChanged(defaultSelectedMatchingColumns.value);
				state.hasStaleFields = false;
			} catch (error) {
				state.loadingError = true;
			} finally {
				state.loading = false;
				state.refreshInProgress = false;
			}
		}
		const createRequestParams = (methodName) => {
			if (!props.node) return;
			return {
				nodeTypeAndVersion: {
					name: props.node.type,
					version: props.node.typeVersion
				},
				currentNodeParameters: resolveRequiredParameters(props.parameter, props.node.parameters),
				path: props.path,
				methodName,
				credentials: props.node.credentials,
				projectId: projectsStore.currentProjectId
			};
		};
		async function fetchFields() {
			const { resourceMapperMethod, localResourceMapperMethod } = props.parameter.typeOptions?.resourceMapper ?? {};
			let fetchedFields = null;
			if (typeof resourceMapperMethod === "string") {
				const requestParams = createRequestParams(resourceMapperMethod);
				fetchedFields = await nodeTypesStore.getResourceMapperFields(requestParams);
			} else if (typeof localResourceMapperMethod === "string") {
				const requestParams = createRequestParams(localResourceMapperMethod);
				fetchedFields = await nodeTypesStore.getLocalResourceMapperFields(requestParams);
			}
			if (fetchedFields?.emptyFieldsNotice) state.emptyFieldsNotice = fetchedFields.emptyFieldsNotice;
			return fetchedFields;
		}
		async function loadAndSetFieldsToMap() {
			if (!props.node) return;
			const fetchedFields = await fetchFields();
			if (fetchedFields !== null) {
				const newSchema = fetchedFields.fields.map((field) => {
					const existingField = state.paramValue.schema.find((f) => f.id === field.id);
					if (existingField) field.removed = existingField.removed;
					else if (state.paramValue.value !== null && !(field.id in state.paramValue.value)) field.removed = false;
					return field;
				});
				if (!(0, import_isEqual.default)(newSchema, state.paramValue.schema)) {
					state.paramValue.schema = newSchema;
					emitValueChanged();
				}
			}
		}
		async function onModeChanged(mode) {
			state.paramValue.mappingMode = mode;
			if (mode === "defineBelow") await initFetching();
			else state.loadingError = false;
			emitValueChanged();
		}
		function setDefaultFieldValues(forceMatchingFieldsUpdate = false) {
			state.paramValue.value = {};
			const hideAllFields = props.parameter.typeOptions?.resourceMapper?.addAllFields === false;
			state.paramValue.schema.forEach((field) => {
				if (state.paramValue.value) {
					if (hideAllFields) field.removed = !field.required;
					if (field.type === "boolean") state.paramValue.value = {
						...state.paramValue.value,
						[field.id]: false
					};
					else state.paramValue.value = {
						...state.paramValue.value,
						[field.id]: null
					};
				}
			});
			emitValueChanged();
			if (!state.paramValue.matchingColumns || forceMatchingFieldsUpdate) {
				state.paramValue.matchingColumns = defaultSelectedMatchingColumns.value;
				emitValueChanged();
			}
		}
		function updateNodeIssues() {
			if (props.node) {
				const parameterIssues$1 = getNodeParametersIssues(nodeType.value?.properties ?? [], props.node, nodeType.value);
				if (parameterIssues$1) ndvStore.updateNodeParameterIssues(parameterIssues$1);
			}
		}
		function onMatchingColumnsChanged(columns) {
			state.paramValue = {
				...state.paramValue,
				matchingColumns: columns
			};
			state.paramValue.schema.forEach((field) => {
				if (state.paramValue.matchingColumns?.includes(field.id)) {
					field.removed = false;
					state.paramValue.schema.splice(state.paramValue.schema.indexOf(field), 1, field);
				}
			});
			if (!state.loading) emitValueChanged();
		}
		function fieldValueChanged(updateInfo) {
			let newValue = null;
			if (updateInfo.value !== void 0 && updateInfo.value !== null && (props.allowEmptyStrings || updateInfo.value !== "") && isResourceMapperValue(updateInfo.value)) newValue = updateInfo.value;
			const fieldName = parseResourceMapperFieldName(updateInfo.name);
			if (fieldName && state.paramValue.value) {
				state.paramValue.value = {
					...state.paramValue.value,
					[fieldName]: newValue
				};
				emitValueChanged();
			}
		}
		function removeField(name) {
			if (name === "removeAllFields") return removeAllFields();
			const fieldName = parseResourceMapperFieldName(name);
			if (fieldName) {
				const field = state.paramValue.schema.find((f) => f.id === fieldName);
				if (field) {
					deleteField(field);
					emitValueChanged();
				}
			}
		}
		function removeAllFields() {
			state.paramValue.schema.forEach((field) => {
				if (!fieldCannotBeDeleted(field, showMatchingColumnsSelector.value, resourceMapperMode.value, matchingColumns.value)) deleteField(field);
			});
			emitValueChanged();
		}
		function deleteField(field) {
			if (state.paramValue.value) {
				delete state.paramValue.value[field.id];
				field.removed = true;
				state.paramValue.schema.splice(state.paramValue.schema.indexOf(field), 1, field);
			}
		}
		function addField(name) {
			if (name === "addAllFields") return addAllFields();
			if (name === "removeAllFields") return removeAllFields();
			const schema$1 = state.paramValue.schema;
			const field = schema$1.find((f) => f.id === name);
			state.paramValue.value = {
				...state.paramValue.value,
				[name]: field?.type === "boolean" ? false : null
			};
			if (field) {
				field.removed = false;
				schema$1.splice(schema$1.indexOf(field), 1, field);
			}
			emitValueChanged();
		}
		function addAllFields() {
			const newValues = {};
			state.paramValue.schema.forEach((field) => {
				if (field.display && field.removed) {
					newValues[field.id] = null;
					field.removed = false;
					state.paramValue.schema.splice(state.paramValue.schema.indexOf(field), 1, field);
				}
			});
			state.paramValue.value = {
				...state.paramValue.value,
				...newValues
			};
			emitValueChanged();
		}
		function emitValueChanged() {
			pruneParamValues();
			emit("valueChanged", {
				name: `${props.path}`,
				value: deepCopy(state.paramValue),
				node: props.node?.name
			});
			updateNodeIssues();
		}
		function pruneParamValues() {
			const { value: value$1, schema: schema$1 } = state.paramValue;
			if (!value$1) return;
			const schemaKeys = new Set(schema$1.map((s) => s.id));
			for (const key of Object.keys(value$1)) if (value$1[key] === null || !schemaKeys.has(key)) delete value$1[key];
		}
		__expose({ state });
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", _hoisted_1$1, [
				showMappingModeSelect.value ? (openBlock(), createBlock(MappingModeSelect_default, {
					key: 0,
					"input-size": _ctx.inputSize,
					"label-size": _ctx.labelSize,
					"initial-value": state.paramValue.mappingMode || "defineBelow",
					"type-options": props.parameter.typeOptions,
					"service-name": nodeType.value?.displayName || unref(i18n).baseText("generic.service"),
					loading: state.loading,
					"loading-error": state.loadingError,
					"fields-to-map": state.paramValue.schema,
					teleported: _ctx.teleported,
					"is-read-only": _ctx.isReadOnly,
					onModeChanged,
					onRetryFetch: initFetching
				}, null, 8, [
					"input-size",
					"label-size",
					"initial-value",
					"type-options",
					"service-name",
					"loading",
					"loading-error",
					"fields-to-map",
					"teleported",
					"is-read-only"
				])) : createCommentVNode("", true),
				showMatchingColumnsSelector.value ? (openBlock(), createBlock(MatchingColumnsSelect_default, {
					key: 1,
					parameter: props.parameter,
					"label-size": _ctx.labelSize,
					"fields-to-map": state.paramValue.schema,
					"type-options": props.parameter.typeOptions,
					"input-size": _ctx.inputSize,
					loading: state.loading,
					"initial-value": matchingColumns.value,
					"service-name": nodeType.value?.displayName || unref(i18n).baseText("generic.service"),
					teleported: _ctx.teleported,
					"refresh-in-progress": state.refreshInProgress,
					"is-read-only": _ctx.isReadOnly,
					onMatchingColumnsChanged,
					onRefreshFieldList: _cache[0] || (_cache[0] = ($event) => initFetching(true))
				}, null, 8, [
					"parameter",
					"label-size",
					"fields-to-map",
					"type-options",
					"input-size",
					"loading",
					"initial-value",
					"service-name",
					"teleported",
					"refresh-in-progress",
					"is-read-only"
				])) : createCommentVNode("", true),
				!showMappingModeSelect.value && state.loading ? (openBlock(), createBlock(unref(N8nText_default), {
					key: 2,
					size: "small"
				}, {
					default: withCtx(() => [createVNode(unref(N8nIcon_default), {
						icon: "refresh-cw",
						size: "xsmall",
						spin: true
					}), createTextVNode(" " + toDisplayString(unref(i18n).baseText("resourceMapper.fetchingFields.message", { interpolate: { fieldWord: pluralFieldWord.value } })), 1)]),
					_: 1
				})) : createCommentVNode("", true),
				showMappingFields.value ? (openBlock(), createBlock(MappingFields_default, {
					key: 3,
					parameter: props.parameter,
					path: props.path,
					"node-values": state.parameterValues,
					"fields-to-map": state.paramValue.schema,
					"param-value": state.paramValue,
					"label-size": _ctx.labelSize,
					"show-matching-columns-selector": showMatchingColumnsSelector.value,
					"show-mapping-mode-select": showMappingModeSelect.value,
					loading: state.loading,
					teleported: _ctx.teleported,
					"refresh-in-progress": state.refreshInProgress,
					"is-read-only": _ctx.isReadOnly,
					"is-data-stale": state.hasStaleFields,
					onFieldValueChanged: fieldValueChanged,
					onRemoveField: removeField,
					onAddField: addField,
					onRefreshFieldList: _cache[1] || (_cache[1] = ($event) => initFetching(true))
				}, null, 8, [
					"parameter",
					"path",
					"node-values",
					"fields-to-map",
					"param-value",
					"label-size",
					"show-matching-columns-selector",
					"show-mapping-mode-select",
					"loading",
					"teleported",
					"refresh-in-progress",
					"is-read-only",
					"is-data-stale"
				])) : state.emptyFieldsNotice && !state.hasStaleFields ? (openBlock(), createBlock(unref(N8nNotice_default), {
					key: 4,
					type: "info",
					"data-test-id": "empty-fields-notice"
				}, {
					default: withCtx(() => [withDirectives(createBaseVNode("span", null, null, 512), [[_directive_n8n_html, state.emptyFieldsNotice]])]),
					_: 1
				})) : state.hasStaleFields ? (openBlock(), createBlock(unref(N8nCallout_default), {
					key: 5,
					theme: "info",
					iconless: true
				}, {
					trailingContent: withCtx(() => [createVNode(unref(N8nButton_default), {
						size: "mini",
						icon: "refresh-cw",
						type: "secondary",
						loading: state.refreshInProgress,
						onClick: _cache[2] || (_cache[2] = ($event) => initFetching(true))
					}, {
						default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("generic.refresh")), 1)]),
						_: 1
					}, 8, ["loading"])]),
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("resourceMapper.staleDataWarning.notice")) + " ", 1)]),
					_: 1
				})) : createCommentVNode("", true),
				state.paramValue.mappingMode === "autoMapInputData" && hasAvailableMatchingColumns.value ? (openBlock(), createBlock(unref(N8nNotice_default), { key: 6 }, {
					default: withCtx(() => [createTextVNode(toDisplayString(unref(i18n).baseText("resourceMapper.autoMappingNotice", { interpolate: {
						fieldWord: pluralFieldWord.value,
						serviceName: nodeType.value?.displayName || unref(i18n).baseText("generic.service")
					} })), 1)]),
					_: 1
				})) : createCommentVNode("", true),
				showTypeConversionOptions.value && hasFields.value ? (openBlock(), createElementBlock("div", {
					key: 7,
					class: normalizeClass(_ctx.$style.typeConversionOptions)
				}, [createVNode(ParameterInputFull_default, {
					parameter: {
						name: "attemptToConvertTypes",
						type: "boolean",
						displayName: unref(i18n).baseText("resourceMapper.attemptToConvertTypes.displayName"),
						default: false,
						description: unref(i18n).baseText("resourceMapper.attemptToConvertTypes.description"),
						noDataExpression: true
					},
					path: props.path + ".attemptToConvertTypes",
					value: state.paramValue.attemptToConvertTypes,
					"is-read-only": _ctx.isReadOnly,
					onUpdate: _cache[3] || (_cache[3] = (x) => {
						state.paramValue.attemptToConvertTypes = x.value;
						emitValueChanged();
					})
				}, null, 8, [
					"parameter",
					"path",
					"value",
					"is-read-only"
				])], 2)) : createCommentVNode("", true)
			]);
		};
	}
});
var ResourceMapper_vue_vue_type_style_index_0_lang_module_default = { typeConversionOptions: "_typeConversionOptions_1jjfe_123" };
var ResourceMapper_default = /* @__PURE__ */ __plugin_vue_export_helper_default(ResourceMapper_vue_vue_type_script_setup_true_lang_default, [["__cssModules", { "$style": ResourceMapper_vue_vue_type_style_index_0_lang_module_default }]]);
var import_get = /* @__PURE__ */ __toESM(require_get());
var _hoisted_1 = { class: "parameter-input-list-wrapper" };
var _hoisted_2 = {
	key: 1,
	class: "parameter-item"
};
var _hoisted_3 = {
	key: 5,
	class: "parameter-item"
};
var _hoisted_4 = {
	key: 6,
	class: "multi-parameter"
};
var _hoisted_5 = {
	key: 10,
	class: "parameter-item"
};
var ParameterInputList_default = /* @__PURE__ */ defineComponent({
	__name: "ParameterInputList",
	props: {
		node: {},
		nodeValues: {},
		parameters: {},
		path: { default: "" },
		hideDelete: { type: Boolean },
		indent: { type: Boolean },
		isReadOnly: { type: Boolean },
		hiddenIssuesInputs: { default: () => [] },
		entryIndex: {}
	},
	emits: [
		"activate",
		"valueChanged",
		"parameterBlur"
	],
	setup(__props, { emit: __emit }) {
		const LazyFixedCollectionParameter = defineAsyncComponent(async () => await __vitePreload(() => import("./FixedCollectionParameter-C1-2JFIV.js"), __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66])));
		const LazyCollectionParameter = defineAsyncComponent(async () => await __vitePreload(() => import("./CollectionParameter-Bb4k4hYX.js"), __vite__mapDeps([67,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65])));
		const showIssuesInLabelFor = ["fixedCollection"];
		const props = __props;
		const emit = __emit;
		const nodeTypesStore = useNodeTypesStore();
		const ndvStore = useNDVStore();
		const workflowsStore = useWorkflowsStore();
		const message = useMessage();
		const nodeSettingsParameters = useNodeSettingsParameters();
		const asyncLoadingError = ref(false);
		const workflowHelpers = useWorkflowHelpers();
		const i18n$1 = useI18n();
		const { dismissCallout, isCalloutDismissed, openPreBuiltAgentsCollection, openSampleWorkflowTemplate, isRagStarterCalloutVisible, isPreBuiltAgentsCalloutVisible } = useCalloutHelpers();
		const { activeNode } = storeToRefs(ndvStore);
		onErrorCaptured((e, component) => {
			if (!["LazyFixedCollectionParameter", "LazyCollectionParameter"].includes(component?.$options.name)) return;
			asyncLoadingError.value = true;
			console.error(e);
			captureException(e, { tags: { asyncLoadingError: true } });
			return false;
		});
		const node$1 = computed(() => props.node ?? ndvStore.activeNode);
		const nodeType = computed(() => {
			if (node$1.value) return nodeTypesStore.getNodeType(node$1.value.type, node$1.value.typeVersion);
			return null;
		});
		const filteredParameters = computedWithControl([() => props.parameters, () => props.nodeValues], () => {
			const parameters = props.parameters.filter((parameter) => shouldDisplayNodeParameter(parameter));
			if (node$1.value && node$1.value.type === "n8n-nodes-base.formTrigger") return updateFormTriggerParameters(parameters, node$1.value.name);
			if (node$1.value && node$1.value.type === "n8n-nodes-base.form") return updateFormParameters(parameters, node$1.value.name);
			if (node$1.value && node$1.value.type === "n8n-nodes-base.wait" && node$1.value.parameters.resume === "form") return updateWaitParameters(parameters, node$1.value.name);
			return parameters;
		});
		const filteredParameterNames = computed(() => {
			return filteredParameters.value.map((parameter) => parameter.name);
		});
		const credentialsParameterIndex = computed(() => {
			return filteredParameters.value.findIndex((parameter) => parameter.type === "credentials");
		});
		const calloutParameterIndex = computed(() => {
			return filteredParameters.value.findIndex((parameter) => parameter.type === "callout");
		});
		const indexToShowSlotAt = computed(() => {
			if (credentialsParameterIndex.value !== -1) return credentialsParameterIndex.value;
			let index$1 = 0;
			if (calloutParameterIndex.value !== -1) index$1 = calloutParameterIndex.value + 1;
			const fieldOffset = KEEP_AUTH_IN_NDV_FOR_NODES.includes(nodeType.value?.name || "") ? 1 : 0;
			const credentialsDependencies = getCredentialsDependencies();
			filteredParameters.value.forEach((prop, propIndex) => {
				if (credentialsDependencies.has(prop.name)) index$1 = propIndex + fieldOffset;
			});
			return Math.min(index$1, filteredParameters.value.length - 1);
		});
		watch(filteredParameterNames, (newValue, oldValue) => {
			if (newValue === void 0) return;
			for (const parameter of oldValue) if (!newValue.includes(parameter)) emit("valueChanged", {
				name: `${props.path}.${parameter}`,
				node: ndvStore.activeNode?.name || "",
				value: void 0
			});
		});
		function updateFormTriggerParameters(parameters, triggerName) {
			const workflowObject = workflowsStore.workflowObject;
			if (workflowObject.getChildNodes(triggerName).some((nodeName) => {
				const _node = workflowObject.getNode(nodeName);
				return _node && _node.type === "n8n-nodes-base.form";
			})) {
				const triggerParameters = [];
				for (const parameter of parameters) {
					if (parameter.name === "responseMode") {
						triggerParameters.push({
							displayName: "On submission, the user will be taken to the next form node",
							name: "formResponseModeNotice",
							type: "notice",
							default: ""
						});
						continue;
					}
					if (parameter.name === "addFormPage") continue;
					if (parameter.name === "options") {
						const options$1 = parameter.options.filter((option$1) => option$1.name !== "respondWithOptions");
						triggerParameters.push({
							...parameter,
							options: options$1
						});
						continue;
					}
					triggerParameters.push(parameter);
				}
				return triggerParameters;
			}
			return parameters;
		}
		function updateWaitParameters(parameters, nodeName) {
			const workflowObject = workflowsStore.workflowObject;
			const formTriggerName = workflowObject.getParentNodes(nodeName).find((_node) => workflowObject.nodes[_node].type === FORM_TRIGGER_NODE_TYPE);
			if (!formTriggerName) return parameters;
			if (workflowObject.getChildNodes(formTriggerName).some((_nodeName) => {
				const _node = workflowObject.getNode(_nodeName);
				return _node && _node.type === "n8n-nodes-base.form";
			})) {
				const waitNodeParameters = [];
				for (const parameter of parameters) {
					if (parameter.name === "options") {
						const options$1 = parameter.options.filter((option$1) => option$1.name !== "respondWithOptions" && option$1.name !== "webhookSuffix");
						waitNodeParameters.push({
							...parameter,
							options: options$1
						});
						continue;
					}
					waitNodeParameters.push(parameter);
				}
				return waitNodeParameters;
			}
			return parameters;
		}
		function updateFormParameters(parameters, nodeName) {
			const workflowObject = workflowsStore.workflowObject;
			if (workflowObject.getParentNodes(nodeName).find((_node) => workflowObject.nodes[_node].type === "n8n-nodes-base.formTrigger")) return parameters.filter((parameter) => parameter.name !== "triggerNotice");
			return parameters;
		}
		function onParameterBlur(parameterName) {
			emit("parameterBlur", parameterName);
		}
		function getCredentialsDependencies() {
			const dependencies = /* @__PURE__ */ new Set();
			if (nodeType.value?.credentials) {
				for (const cred of nodeType.value.credentials) if (cred.displayOptions?.show) Object.keys(cred.displayOptions.show).forEach((fieldName) => dependencies.add(fieldName));
			}
			return dependencies;
		}
		function multipleValues(parameter) {
			return getParameterTypeOption(parameter, "multipleValues") === true;
		}
		function getPath(parameterName) {
			return (props.path ? `${props.path}.` : "") + parameterName;
		}
		function deleteOption(optionName) {
			emit("valueChanged", {
				name: getPath(optionName),
				value: void 0
			});
		}
		function shouldDisplayNodeParameter(parameter, displayKey = "displayOptions") {
			return nodeSettingsParameters.shouldDisplayNodeParameter(props.nodeValues, node$1.value, parameter, props.path, displayKey);
		}
		function valueChanged(parameterData) {
			emit("valueChanged", parameterData);
		}
		function onNoticeAction(action) {
			if (action === "activate") emit("activate");
		}
		function getParameterIssues$1(parameter) {
			if (!node$1.value || !showIssuesInLabelFor.includes(parameter.type)) return [];
			return getParameterIssues(parameter, node$1.value.parameters, "", node$1.value, nodeType.value).parameters?.[parameter.name] ?? [];
		}
		function shouldShowOptions(parameter) {
			return parameter.type !== "resourceMapper";
		}
		function getDependentParametersValues(parameter) {
			const loadOptionsDependsOn = getParameterTypeOption(parameter, "loadOptionsDependsOn");
			if (loadOptionsDependsOn === void 0) return null;
			const currentNodeParameters = ndvStore.activeNode?.parameters;
			try {
				const resolvedNodeParameters = workflowHelpers.resolveParameter(currentNodeParameters);
				const returnValues = [];
				for (let parameterPath of loadOptionsDependsOn) {
					parameterPath = resolveRelativePath(props.path, parameterPath);
					returnValues.push((0, import_get.default)(resolvedNodeParameters, parameterPath));
				}
				return returnValues.join("|");
			} catch {
				return null;
			}
		}
		function getParameterValue(name) {
			return getParameterValueByPath(props.nodeValues, name, props.path);
		}
		function isRagStarterCallout(parameter) {
			return parameter.type === "callout" && parameter.name === "ragStarterCallout";
		}
		function isAgentDefaultCallout(parameter) {
			return parameter.type === "callout" && parameter.name === "aiAgentStarterCallout";
		}
		function isPreBuiltAgentsCallout(parameter) {
			return parameter.type === "callout" && parameter.name.startsWith("preBuiltAgentsCallout");
		}
		function isCalloutVisible(parameter) {
			if (isCalloutDismissed(parameter.name)) return false;
			if (isRagStarterCallout(parameter)) return isRagStarterCalloutVisible.value;
			if (isAgentDefaultCallout(parameter)) return !isPreBuiltAgentsCalloutVisible.value;
			if (isPreBuiltAgentsCallout(parameter)) return isPreBuiltAgentsCalloutVisible.value;
			return true;
		}
		function onCalloutAction(action) {
			switch (action.type) {
				case "openPreBuiltAgentsCollection":
					openPreBuiltAgentsCollection({
						telemetry: {
							source: "ndv",
							nodeType: activeNode.value?.type
						},
						resetStacks: false
					});
					break;
				case "openSampleWorkflowTemplate":
					openSampleWorkflowTemplate(action.templateId, { telemetry: {
						source: "ndv",
						nodeType: activeNode.value?.type
					} });
					break;
				default: break;
			}
		}
		async function onCalloutDismiss(parameter) {
			if (await message.confirm(i18n$1.baseText("parameterInputList.callout.dismiss.confirm.text"), {
				showClose: true,
				confirmButtonText: i18n$1.baseText("parameterInputList.callout.dismiss.confirm.confirmButtonText"),
				cancelButtonText: i18n$1.baseText("parameterInputList.callout.dismiss.confirm.cancelButtonText")
			}) !== "confirm") return;
			await dismissCallout(parameter.name);
		}
		return (_ctx, _cache) => {
			const _directive_n8n_html = resolveDirective("n8n-html");
			return openBlock(), createElementBlock("div", _hoisted_1, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(filteredParameters), (parameter, index$1) => {
				return openBlock(), createElementBlock("div", {
					key: parameter.name,
					class: normalizeClass({ indent: _ctx.indent }),
					"data-test-id": "parameter-item"
				}, [indexToShowSlotAt.value === index$1 ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true), multipleValues(parameter) === true && parameter.type !== "fixedCollection" ? (openBlock(), createElementBlock("div", _hoisted_2, [createVNode(MultipleParameter_default, {
					parameter,
					values: getParameterValue(parameter.name),
					"node-values": _ctx.nodeValues,
					path: getPath(parameter.name),
					"is-read-only": _ctx.isReadOnly,
					onValueChanged: valueChanged
				}, null, 8, [
					"parameter",
					"values",
					"node-values",
					"path",
					"is-read-only"
				])])) : parameter.type === "curlImport" ? (openBlock(), createBlock(ImportCurlParameter_default, {
					key: 2,
					"is-read-only": _ctx.isReadOnly,
					onValueChanged: valueChanged
				}, null, 8, ["is-read-only"])) : parameter.type === "notice" ? (openBlock(), createBlock(unref(N8nNotice_default), {
					key: 3,
					class: normalizeClass(["parameter-item", parameter.typeOptions?.containerClass ?? ""]),
					content: unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(parameter, _ctx.path),
					onAction: onNoticeAction
				}, null, 8, ["class", "content"])) : parameter.type === "callout" ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [isCalloutVisible(parameter) ? (openBlock(), createBlock(unref(N8nCallout_default), {
					key: 0,
					icon: parameter.typeOptions?.calloutAction?.icon || "info",
					"icon-size": "large",
					class: normalizeClass(["parameter-item", parameter.typeOptions?.containerClass ?? ""]),
					theme: "secondary"
				}, {
					trailingContent: withCtx(() => [createVNode(unref(N8nIcon_default), {
						icon: "x",
						title: "Dismiss",
						size: "medium",
						type: "secondary",
						class: "callout-dismiss",
						"data-test-id": "callout-dismiss-icon",
						onClick: ($event) => onCalloutDismiss(parameter)
					}, null, 8, ["onClick"])]),
					default: withCtx(() => [createVNode(unref(N8nText_default), { size: "small" }, {
						default: withCtx(() => [withDirectives(createVNode(unref(N8nText_default), { size: "small" }, null, 512), [[_directive_n8n_html, unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(parameter, _ctx.path)]]), parameter.typeOptions?.calloutAction ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [_cache[0] || (_cache[0] = createTextVNode(toDisplayString(" ") + " ")), parameter.typeOptions?.calloutAction ? (openBlock(), createBlock(unref(N8nLink_default), {
							key: 0,
							theme: "secondary",
							size: "small",
							bold: true,
							underline: true,
							onClick: ($event) => onCalloutAction(parameter.typeOptions.calloutAction)
						}, {
							default: withCtx(() => [createTextVNode(toDisplayString(parameter.typeOptions.calloutAction.label), 1)]),
							_: 2
						}, 1032, ["onClick"])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)]),
						_: 2
					}, 1024)]),
					_: 2
				}, 1032, ["icon", "class"])) : createCommentVNode("", true)], 64)) : parameter.type === "button" ? (openBlock(), createElementBlock("div", _hoisted_3, [createVNode(ButtonParameter_default, {
					parameter,
					path: _ctx.path,
					value: getParameterValue(parameter.name),
					"is-read-only": _ctx.isReadOnly,
					onValueChanged: valueChanged
				}, null, 8, [
					"parameter",
					"path",
					"value",
					"is-read-only"
				])])) : ["collection", "fixedCollection"].includes(parameter.type) ? (openBlock(), createElementBlock("div", _hoisted_4, [
					createVNode(unref(N8nInputLabel_default), {
						label: unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDisplayName(parameter, _ctx.path),
						"tooltip-text": unref(i18n$1).nodeText(unref(activeNode)?.type).inputLabelDescription(parameter, _ctx.path),
						size: "small",
						underline: true,
						"input-name": parameter.name,
						color: "text-dark"
					}, createSlots({ _: 2 }, [showIssuesInLabelFor.includes(parameter.type) && getParameterIssues$1(parameter).length > 0 ? {
						name: "issues",
						fn: withCtx(() => [createVNode(unref(N8nTooltip_default), null, {
							content: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(getParameterIssues$1(parameter), (issue, i) => {
								return openBlock(), createElementBlock("span", { key: i }, toDisplayString(issue), 1);
							}), 128))]),
							default: withCtx(() => [createVNode(unref(N8nIcon_default), {
								icon: "triangle-alert",
								size: "small",
								color: "danger"
							})]),
							_: 2
						}, 1024)]),
						key: "0"
					} : void 0]), 1032, [
						"label",
						"tooltip-text",
						"input-name"
					]),
					!asyncLoadingError.value ? (openBlock(), createBlock(Suspense, { key: 0 }, {
						default: withCtx(() => [parameter.type === "collection" ? (openBlock(), createBlock(unref(LazyCollectionParameter), {
							key: 0,
							parameter,
							values: getParameterValue(parameter.name),
							"node-values": _ctx.nodeValues,
							path: getPath(parameter.name),
							"is-read-only": _ctx.isReadOnly,
							onValueChanged: valueChanged
						}, null, 8, [
							"parameter",
							"values",
							"node-values",
							"path",
							"is-read-only"
						])) : parameter.type === "fixedCollection" ? (openBlock(), createBlock(unref(LazyFixedCollectionParameter), {
							key: 1,
							parameter,
							values: getParameterValue(parameter.name),
							"node-values": _ctx.nodeValues,
							path: getPath(parameter.name),
							"is-read-only": _ctx.isReadOnly,
							onValueChanged: valueChanged
						}, null, 8, [
							"parameter",
							"values",
							"node-values",
							"path",
							"is-read-only"
						])) : createCommentVNode("", true)]),
						fallback: withCtx(() => [createVNode(unref(N8nText_default), {
							size: "small",
							class: "async-notice"
						}, {
							default: withCtx(() => [createVNode(unref(N8nIcon_default), {
								icon: "refresh-cw",
								size: "xsmall",
								spin: true
							}), createTextVNode(" " + toDisplayString(unref(i18n$1).baseText("parameterInputList.loadingFields")), 1)]),
							_: 1
						})]),
						_: 2
					}, 1024)) : (openBlock(), createBlock(unref(N8nText_default), {
						key: 1,
						size: "small",
						color: "danger",
						class: "async-notice"
					}, {
						default: withCtx(() => [createVNode(unref(N8nIcon_default), {
							icon: "triangle-alert",
							size: "xsmall"
						}), createTextVNode(" " + toDisplayString(unref(i18n$1).baseText("parameterInputList.loadingError")), 1)]),
						_: 1
					})),
					_ctx.hideDelete !== true && !_ctx.isReadOnly && !parameter.isNodeSetting ? (openBlock(), createBlock(unref(N8nIconButton_default), {
						key: 2,
						type: "tertiary",
						text: "",
						size: "small",
						icon: "trash-2",
						class: "icon-button",
						title: unref(i18n$1).baseText("parameterInputList.delete"),
						onClick: ($event) => deleteOption(parameter.name)
					}, null, 8, ["title", "onClick"])) : createCommentVNode("", true)
				])) : parameter.type === "resourceMapper" ? (openBlock(), createBlock(ResourceMapper_default, {
					key: 7,
					parameter,
					node: node$1.value,
					path: getPath(parameter.name),
					"dependent-parameters-values": getDependentParametersValues(parameter),
					"is-read-only": _ctx.isReadOnly,
					"allow-empty-strings": parameter.typeOptions?.resourceMapper?.allowEmptyValues,
					"input-size": "small",
					"label-size": "small",
					onValueChanged: valueChanged
				}, null, 8, [
					"parameter",
					"node",
					"path",
					"dependent-parameters-values",
					"is-read-only",
					"allow-empty-strings"
				])) : parameter.type === "filter" ? (openBlock(), createBlock(FilterConditions_default, {
					key: 8,
					parameter,
					value: getParameterValue(parameter.name),
					path: getPath(parameter.name),
					node: node$1.value,
					"read-only": _ctx.isReadOnly,
					onValueChanged: valueChanged
				}, null, 8, [
					"parameter",
					"value",
					"path",
					"node",
					"read-only"
				])) : parameter.type === "assignmentCollection" ? (openBlock(), createBlock(AssignmentCollection_default, {
					key: 9,
					parameter,
					value: getParameterValue(parameter.name),
					path: getPath(parameter.name),
					node: node$1.value,
					"is-read-only": _ctx.isReadOnly,
					"default-type": parameter.typeOptions?.assignment?.defaultType,
					"disable-type": parameter.typeOptions?.assignment?.disableType,
					onValueChanged: valueChanged
				}, null, 8, [
					"parameter",
					"value",
					"path",
					"node",
					"is-read-only",
					"default-type",
					"disable-type"
				])) : credentialsParameterIndex.value !== index$1 ? (openBlock(), createElementBlock("div", _hoisted_5, [_ctx.hideDelete !== true && !_ctx.isReadOnly && !parameter.isNodeSetting ? (openBlock(), createBlock(unref(N8nIconButton_default), {
					key: 0,
					type: "tertiary",
					text: "",
					size: "small",
					icon: "trash-2",
					class: "icon-button",
					title: unref(i18n$1).baseText("parameterInputList.delete"),
					onClick: ($event) => deleteOption(parameter.name)
				}, null, 8, ["title", "onClick"])) : createCommentVNode("", true), createVNode(ParameterInputFull_default, {
					parameter,
					"hide-issues": _ctx.hiddenIssuesInputs.includes(parameter.name),
					value: getParameterValue(parameter.name),
					"display-options": shouldShowOptions(parameter),
					path: getPath(parameter.name),
					"is-read-only": _ctx.isReadOnly || parameter.disabledOptions && shouldDisplayNodeParameter(parameter, "disabledOptions"),
					"hide-label": false,
					"node-values": _ctx.nodeValues,
					onUpdate: valueChanged,
					onBlur: ($event) => onParameterBlur(parameter.name)
				}, null, 8, [
					"parameter",
					"hide-issues",
					"value",
					"display-options",
					"path",
					"is-read-only",
					"node-values",
					"onBlur"
				])])) : createCommentVNode("", true)], 2);
			}), 128)), unref(filteredParameters).length === 0 ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass({ indent: _ctx.indent })
			}, [renderSlot(_ctx.$slots, "default")], 2)) : createCommentVNode("", true)]);
		};
	}
});
export { ExpressionEditorModalInput_default as C, CodeNodeEditor_default as D, TitledList_default as E, JsEditor_default as O, SqlEditor_default as S, useNodeCredentialOptions as T, isValidParameterOption as _, ParameterOptions_default as a, require_unset as b, InputPanel_default as c, collectParametersByTab as d, collectSettings as f, getParameterTypeOption as g, getNodeSettingsInitialValues as h, ParameterInputFull_default as i, HtmlEditor_default as k, CssEditor_default as l, formatAsExpression as m, CollectionParameter_default as n, ParameterInputWrapper_default as o, createCommonNodeSettings as p, require_vuedraggable_umd as r, useResolvedExpression as s, ParameterInputList_default as t, useNodeSettingsParameters as u, nameIsParameter as v, NodeCredentials_default as w, require_set as x, parseFromExpression as y };
